---
layout: post
title: '线程池的实现原理'
date: "2025-08-18T00:46:49Z"
---
线程池的实现原理
========

笔者本来是想要自己去研读美团的文章([https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html))，去实现一个动态线程池，虽然最后没有成功，因为发现已经有大佬写好了，我们只需要引入依赖就可以了，但是通过这篇文章，我也更加深刻的了解了线程池的工作流程和原理

一、线程池的概述
========

1.1 线程池是什么
----------

线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。

1.2 线程池的好处
----------

1.  **降低资源消耗**：使用池化技术重复利用已创建的线程，降低线程的创建和销毁造成的损耗。
2.  **提高响应速度**：任务到达的时候，无须等待线程创建即可立即执行
3.  **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
4.  **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。

二、如何设计和实现线程池
============

线程池
---

### 2.1 线程池的状态

### 2.2 线程池的生命周期转换

### 2.3 线程池的状态维护

线程池运行的状态不是由用户显示设置的，而是伴随着线程池的运行由内部来维护的。由内部来维护。线程池内部使用一个变量维护两个值：**运行状态(runState)**和**线程数量 (workerCount)**。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起。  
`private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));`  
ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段。他包含两部分信息，线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount。

> 使用一个变量存储两个值的好处：由于某些情况下，需要同时去判断这两个值的状态，用一个变量存储两个值可以避免在做相关的决策的时候，出现不一致的情况，不必为维护两者的一致性，而占用锁资源。

三、线程
----

### 3.1 线程的封装

在线程池里面的线程被封装成工作线程worker，他的代码如下：

    private final class Worker extends AbstractQueuedSynchronizer implements Runnable{
        final Thread thread;//Worker持有的线程
        Runnable firstTask;//初始化的任务，可以为null
    }
    

这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务。firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。  
也就说对于线程池里面的线程而言，他每次每次被创建出来，他如果当前线程数量小于核心线程数量，那么此时的worker线程就是核心线程，他被创建的时候就是来执行当前的任务，反之此时的worker线程就是非核心线程，此时他并不是去执行当前的线程，而是从阻塞队列里面拿去任务来执行。

### 3.2 线程的存储

线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。  
​Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。

> 使AQS的独占锁，而不是使用可重入锁ReentrantLock的原因是因为我们需要去通过是否获取锁成功来判断该线程是否是在执行任务。

### 3.3 线程的增加

增加线程是通过线程池中的**addWorker**方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize。

### 3.4 线程的执行任务

在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：

1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。

### 3.5 线程池的销毁

线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。

    try {
      while (task != null || (task = getTask()) != null) {
        //执行任务
      }
    } finally {
      processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己
    }
    

四、任务的执行机制
---------

### 4.1 任务调度

任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。

首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：

1.  首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。
2.  如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。
3.  如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
4.  如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
5.  如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。  
    

### 4.2 任务缓冲

任务缓冲其实指的就是线程池里面的阻塞队列。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。使用不同的队列可以实现不一样的任务存取策略。  

### 4.3 任务申请

上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。

线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现  

### 4.4 任务拒绝

任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。  
拒绝策略是一个接口，代码如下：

    public interface RejectedExecutionHandler {
        void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
    }
    

用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略。