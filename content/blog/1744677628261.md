---
layout: post
title: 'C++数据的共享和保护'
date: "2025-04-15T00:40:28Z"
---
C++数据的共享和保护
===========

1、函数原型作用域：C++中最小的作用域

①在函数原型声明时，形参的作用范围就是函数原型作用域。

2、局部作用域/块作用域  
![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151453507-292329417.png)  
3、类作用域

类可以被看做是一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有如下三种：

①如果在X的成员函数中，没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m

②通过表达式X.m或X::m（访问静态成员变量）访问。

③通过ptr→m这样的表达式，ptr为指向X类的一个对象的指针

对象的成员函数具有类作用域

4、文件作用域

eg：全局变量  
![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151518594-1381436908.png)  
5、限定作用域的enum枚举类

定义限定作用域的枚举类型的方式是enum class{...}，即多了class或struct限定符，此时枚举元素的名字遵循类作用域，在枚举类型的作用域外是不可访问的。相反，在不限定作用域的枚举类型中，枚举元素的作用域与枚举类型本身的作用域相同。  
![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151541822-431961148.png)  
6、可见性

①如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见。

7、对象的生存期

①静态生存期

*   如果对象的生存期与程序的运行期相同，我们称它具有静态生存期。
*   使用static可以在函数内部的局部作用域中声明具有静态生存期的对象
*   局部作用域中静态变量的特点：当一个函数返回后，下一次再调用时，该变量还会保持上一回的值，即使发生了递归调用，也不会为该变量建立新的副本，该变量会在各次调用间共享。
*   定义静态变量的同时可以为它赋初值，只有第一次调用时赋值语句才生效。
*   定义时未指定初值的基本类型静态生存期变量，会被以0值初始化

②动态生存期

8、静态数据成员

static的作用域为类

①static关键字可以实现同一类的不同对象之间的数据共享，静态数据成员具有静态生存期

②由于静态数据成员不属于任何一个对象，因此可以通过类名对它进行访问，一般的用法是“类名::标识符”

③在类的定义中仅仅对静态数据成员进行引用性声明，必须在文件作用域的某个地方使用类名限定进行定义性声明，这时也可以进行初始化

④C++11标准支持常量表达式类型修饰（constexpr,const）的静态常量在类内初始化，此时仍可在类外定义该静态成员，但不能做再次初始化操作。

【注】之所以类的静态数据成员需要在类定义之外再加以定义，是因为需要以这种方式专门为它们分配空间。非静态数据成员无须以此方式定义，因为它们的空间是与它们所属对象的空间同时分配的。

9、静态函数成员

①在静态函数成员中访问类的非静态成员需要指明对象，因为对静态成员函数的调用是没有目的对象的  
![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151602452-404877751.png)  
10、传对象参数时，习惯传引用，传引用可以降低开销

11、友元：提供不同类或对象之间的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制

①从一定程度上讲，友元是对数据隐蔽和封装的破坏

②在一个类中，可以利用关键字friend将其他函数或类声明为友元。

③三点友元声明

*   友元关系是不能传递的
*   友元关系是单向的
*   友元关系是不能被继承的。（理解：别人信任你，不见得信任你的孩子）

12、友元函数：在类中用friend修饰的非成员函数

①虽然**友元函数不是本类的成员函数**，但是在它的函数体中可以通过对象名访问类的私有和保护成员。  
![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151623151-1739393582.png)  
②友元函数不能通过对象调用【因为友元函数不是类的成员函数，不属于该类】

③友元函数必须在参数表中显示地指明要访问的对象，而成员函数则在它的对象上操作

13、友元类

①若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员。  
14、常对象

①常对象的数据成员的值在对象的整个生存期内不能被改变。

②常对象必须进行初始化，而且不能被更新。  
![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151651415-1185943192.png)  
15、用const修饰的类成员

①常成员函数：使用const修饰的函数为常成员函数，常成员函数**声明**的格式如下：  
![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151711391-1333421880.png)  
【注1】const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字

【注2】如果将一个对象说明为常对象，则通过该常对象只能调用它的常成员函数，而不能调用其他成员函数

【注3】无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都被视为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数

【注4】const关键字可以用于对重载函数的区分  
![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151730213-159188051.png)  
如果仅以const关键字区分对成员函数的重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的函数——不带const关键字的函数  
![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151749688-1796462683.png)  
②常数据成员

*   构造函数对常数据成员进行初始化，只能通过初始化列表
*   类成员中的常静态变量和常量都应当在类体之外加以定义，C++中规定：类的静态常量如果具有整数类型或枚举类型，那么可以直接在类定义中为它指定常量值  
    ![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151821357-1015027348.png)  
    16、常引用

①如果在声明引用时用const修饰，被声明的引用就是常引用。常引用所引用的对象不能被更新。常引用的声明形式如下：  
![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151840584-861532414.png)  
②非const的引用只能绑定到普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象

③一个常引用，无论绑定到一个普通对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象。

17、多文件结构和编译预处理命令

①通常一个项目至少划分为3个文件：类定义文件(_.h文件)、类实现文件(_.cpp文件)、类使用文件(\*.cpp,注函数文件)

18、静态函数成员的访问  
![image](https://img2024.cnblogs.com/blog/2381996/202504/2381996-20250414151912597-1381008216.png)