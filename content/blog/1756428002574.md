---
layout: post
title: 'ã€æ¸²æŸ“ç®¡çº¿ã€‘UnityURP[æ¸²æŸ“è·¯å¾„]åº•å±‚æºç è§£æ'
date: "2025-08-29T00:40:02Z"
---
ã€æ¸²æŸ“ç®¡çº¿ã€‘UnityURP\[æ¸²æŸ“è·¯å¾„\]åº•å±‚æºç è§£æ
============================

![ã€æ¸²æŸ“ç®¡çº¿ã€‘UnityURP[æ¸²æŸ“è·¯å¾„]åº•å±‚æºç è§£æ](https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250828104212575-485313448.png) æœ¬æ–‡æ·±å…¥è§£æäº†Unity URPï¼ˆUniversal Render Pipelineï¼‰çš„æ¶æ„ä¸å®ç°æœºåˆ¶ã€‚URPåŸºäºSRPï¼ˆScriptable Render Pipelineï¼‰æ„å»ºï¼Œé€šè¿‡RenderPipelineåŸºç±»ã€ScriptableRenderContextç­‰æ ¸å¿ƒç»„ä»¶å®ç°å¯ç¼–ç¨‹æ¸²æŸ“ç®¡çº¿ã€‚æ–‡ç« è¯¦ç»†å‰–æäº†URPçš„åˆå§‹åŒ–æµç¨‹ã€æ¸²æŸ“é˜¶æ®µåˆ’åˆ†ï¼ˆå‡†å¤‡/å‡ ä½•/å…‰ç…§/å…‰æ …åŒ–/åå¤„ç†ï¼‰ä»¥åŠå…³é”®ä¼˜åŒ–æŠ€æœ¯ï¼ˆå¦‚SRP Batcherï¼‰ã€‚åŒæ—¶å¯¹æ¯”äº†URPä¸HDRPçš„åŒºåˆ«ï¼ŒåŒ…æ‹¬URPé‡‡ç”¨çš„ç®€åŒ–PBRæ¨¡å‹ã€è·¨å¹³å°é€‚é…ç­–ç•¥ç­‰ã€‚æœ€å

> [ã€ä»UnityURPå¼€å§‹æ¢ç´¢æ¸¸æˆæ¸²æŸ“ã€‘](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**ä¸“æ -ç›´è¾¾**

**SRPæä¾›çš„æ ¸å¿ƒåŠŸèƒ½ä¸æ¶æ„â€Œ**
==================

â€Œ**å¯ç¼–ç¨‹ç®¡çº¿åŸºç¡€**â€Œ
-------------

### â€Œ**RenderPipelineåŸºç±»**â€Œ

*   é€šè¿‡ç»§æ‰¿è¯¥ç±»å¹¶é‡å†™`Render()`æ–¹æ³•ï¼Œå¼€å‘è€…å¯è‡ªå®šä¹‰æ¸²æŸ“æµç¨‹è°ƒåº¦é€»è¾‘ï¼Œæ›¿ä»£ä¼ ç»Ÿå›ºå®šç®¡çº¿ã€‚_ï¼ˆURPä¸­`UniversalRenderPipeline : RenderPipeline` ç»§æ‰¿å¹¶é‡å†™Renderæ–¹æ³•ã€‚ï¼‰_

### â€Œ**ScriptableRenderContext**â€Œ

*   ä½œä¸ºC#è„šæœ¬ä¸åº•å±‚å›¾å½¢APIçš„æ¡¥æ¢ï¼Œå…è®¸é€šè¿‡ä»£ç è°ƒåº¦æ¸²æŸ“å‘½ä»¤ï¼ˆå¦‚å‰”é™¤ã€ç»˜åˆ¶ï¼‰ã€‚_ï¼ˆ`public struct ScriptableRenderContext : IEquatable<ScriptableRenderContext>`å®šä¹‰**è‡ªå®šä¹‰æ¸²æŸ“ç®¡é“**ä½¿ç”¨çš„**çŠ¶æ€**å’Œ**ç»˜å›¾å‘½ä»¤**ã€‚ï¼‰_

### â€Œ**ç®¡çº¿èµ„æºåˆ†ç¦»æœºåˆ¶**â€Œ

*   `RenderPipelineAsset`ï¼šå­˜å‚¨é…ç½®æ•°æ®ï¼ˆå¦‚æè´¨ã€Shaderå‚æ•°ï¼‰_ï¼ˆURPä¸­æ˜¯  
    `public partial class UniversalRenderPipelineAsset : RenderPipelineAsset, ISerializationCallbackReceiver`ï¼‰_
*   `RenderPipelineInstance`ï¼šæ‰§è¡Œå®é™…æ¸²æŸ“é€»è¾‘çš„å®ä¾‹ç±»ã€‚_ï¼ˆåœ¨URPä¸­ï¼Œä¸Šé¢çš„RenderPipelineAssetèµ„äº§ç±»ä¸­é‡å†™`protected override RenderPipeline CreatePipeline()`æ–¹æ³•ï¼Œåœ¨å…¶ä¸­åˆ›å»ºæ¸²æŸ“ç®¡çº¿å®ä¾‹`var pipeline = new UniversalRenderPipeline(this);`ï¼‰_

â€Œ**å…³é”®æ‰©å±•ç‚¹**â€Œ
-----------

### â€Œ**äº‹ä»¶å›è°ƒ**â€Œ

*   é€šè¿‡`RenderPipelineManager`è®¢é˜…æ¸²æŸ“ç”Ÿå‘½å‘¨æœŸäº‹ä»¶ï¼ˆå¦‚`beginContextRendering`ï¼‰ï¼Œåœ¨ç‰¹å®šé˜¶æ®µæ³¨å…¥è‡ªå®šä¹‰é€»è¾‘ã€‚

### â€Œ**åŠ¨æ€æ¸²æŸ“ç­–ç•¥**â€Œ

*   æ”¯æŒè¿è¡Œæ—¶åˆ‡æ¢æ¸²æŸ“è·¯å¾„ï¼ˆå¦‚æ­£å‘/å»¶è¿Ÿæ¸²æŸ“ï¼‰ï¼Œé€‚åº”ä¸åŒç¡¬ä»¶æ€§èƒ½éœ€æ±‚ï¼ˆè¿™é‡Œçš„æ¸²æŸ“è·¯å¾„æ˜¯URPæˆ–HDRPè‡ªå·±å®ç°çš„ï¼Œä¾‹å¦‚Forward+ä¹Ÿæ˜¯ï¼Œæ‰€ä»¥è¿™ä¸ªæ¸²æŸ“è·¯å¾„åªæ˜¯å®ç°ç®¡çº¿æ—¶çš„è‡ªå®šä¹‰æ¸²æŸ“ç­–ç•¥ï¼Œæ‰€ä»¥è¿è¡Œæ—¶èƒ½åˆ‡æ¢ã€‚ä½†æ˜¯ä¸€èˆ¬ä¸å»ºè®®åˆ‡æ¢ï¼Œå› ä¸ºå„ç§shaderå®ç°æ—¶éƒ½ä¼šæ ¹æ®æ¸²æŸ“è·¯å¾„å®ç°ç›¸åº”æ‰§è¡Œçš„Passï¼Œå¦‚æœéšä¾¿åˆ‡æ¢ï¼Œä¼šå¯¼è‡´éƒ¨åˆ†shaderå¯èƒ½å› ä¸ºåªé€‚é…æŸç§æ¸²æŸ“è·¯å¾„ï¼Œå¯¹å…¶ä»–æ¸²æŸ“è·¯å¾„æ˜¾ç¤ºæ¸²æŸ“å¼‚å¸¸ã€‚ï¼‰ã€‚

**URPåœ¨SRPä¸Šçš„å…·ä½“å®ç°â€Œ**
==================

â€Œ**èµ„æºä¸å®ä¾‹åˆå§‹åŒ–**â€Œ
--------------

### â€Œ**URPç®¡çº¿èµ„æº**â€Œï¼ˆ`UniversalRenderPipelineAsset`ï¼‰ï¼š

*   å®šä¹‰é»˜è®¤Shaderã€å…‰ç…§æ¨¡å‹ã€åå¤„ç†æ ˆç­‰å‚æ•°ã€‚

### â€Œ**å®ä¾‹åŒ–æµç¨‹**â€Œï¼š

*   èµ„æºåˆ›å»ºæ—¶è°ƒç”¨`CreatePipeline()`ç”Ÿæˆ`UniversalRenderPipeline`å®ä¾‹ï¼Œæ¥ç®¡Unityæ¸²æŸ“å¾ªç¯ã€‚
*   å…¶ä¸­çš„æ¸²æŸ“å™¨åŸºç±»`ScriptableRenderer`ä½œä¸º æ¸²æŸ“å™¨å¯ä»¥ç”¨äºæ‰€æœ‰æ‘„åƒæœºï¼Œä¹Ÿå¯ä»¥åœ¨æ¯ä¸ªæ‘„åƒæœºçš„åŸºç¡€ä¸Šé‡å†™ã€‚å®ƒå°†å®ç°å…‰å‰”é™¤å’Œè®¾ç½®ï¼Œå¹¶æè¿°è¦åœ¨å¸§ä¸­æ‰§è¡Œçš„`ScriptableRenderPass`åˆ—è¡¨ã€‚æ¸²æŸ“å™¨å¯ä»¥é€šè¿‡é¢å¤–çš„`scriptablerendererfeature`è¿›è¡Œæ‰©å±•ï¼Œä»¥æ”¯æŒæ›´å¤šçš„æ•ˆæœã€‚æ¸²æŸ“å™¨çš„èµ„æºåœ¨`ScriptableRendererData`ä¸­åºåˆ—åŒ–ï¼ˆç¼–è¾‘å™¨ä¸­å°±åœ¨è¿™ä¸ªèµ„æºä¸ŠæŒ‚è½½è®¾ç½®RendererFeatureï¼‰ã€‚
    *   `UniversalRenderer` é»˜è®¤çš„3Dæ¸²æŸ“å™¨ç»§æ‰¿è‡ª`ScriptableRenderer`ã€‚åœ¨å…¶æ„é€ å‡½æ•°ä¸­  
        `public UniversalRenderer(UniversalRendererData data) : base(data)` æ ¹æ®ä¸Šè¿°åºåˆ—åŒ–çš„Dataæ•°æ®ï¼Œåˆ›å»ºé»˜è®¤çš„æ¸²æŸ“Passé€»è¾‘ã€‚æ¸²æŸ“è·¯å¾„å°±æ˜¯åœ¨è¿™ä¸ªç±»æ–‡ä»¶ä¸­ä¸€åŒå®šä¹‰çš„ï¼Œåœ¨æ„é€ å‡½æ•°ä¸­æ ¹æ®ä¸åŒè·¯å¾„ï¼Œç»™å‡ºä¸åŒç­–ç•¥æ‰§è¡ŒPassã€‚
        
    *   **å®šä¹‰æ¸²æŸ“è·¯å¾„**
        
            namespace UnityEngine.Rendering.Universal
            {
                /// <summary>
                /// Rendering modes for Universal renderer.
                /// </summary>
                public enum RenderingMode
                {
                    /// <summary>Render all objects and lighting in one pass, with a hard limit on the number of lights that can be applied on an object.</summary>
                    Forward = 0,
                    /// <summary>Render all objects and lighting in one pass using a clustered data structure to access lighting data.</summary>
                    [InspectorName("Forward+")]
                    ForwardPlus = 2,
                    /// <summary>Render all objects first in a g-buffer pass, then apply all lighting in a separate pass using deferred shading.</summary>
                    Deferred = 1
                };
                // çœç•¥ä¸‹é¢ä»£ç ã€‚ã€‚ã€‚
            }
            
        
    *   **æ„é€ å‡½æ•°æ ¹æ®æ¸²æŸ“è·¯å¾„ç»™å‡ºä¸åŒPassæ‰§è¡Œç­–ç•¥**
        
            /// <summary>
            /// Constructor for the Universal Renderer.
            /// </summary>
            /// <param name="data">The settings to create the renderer with.</param>
            public UniversalRenderer(UniversalRendererData data) : base(data)
            {
                  // Query and cache runtime platform info first before setting up URP.
                  PlatformAutoDetect.Initialize();
                  ...
            
        
        *   **è®¾ç½®å„ç§æè´¨å’ŒçŠ¶æ€**
            
                // è®¾ç½®å„ç§æè´¨å’ŒçŠ¶æ€
                
                #if ENABLE_VR && ENABLE_XR_MODULE
                            Experimental.Rendering.XRSystem.Initialize(XRPassUniversal.Create, data.xrSystemData.shaders.xrOcclusionMeshPS, data.xrSystemData.shaders.xrMirrorViewPS);
                #endif
                            m_BlitMaterial = CoreUtils.CreateEngineMaterial(data.shaders.coreBlitPS);
                            m_BlitHDRMaterial = CoreUtils.CreateEngineMaterial(data.shaders.blitHDROverlay);
                            m_CopyDepthMaterial = CoreUtils.CreateEngineMaterial(data.shaders.copyDepthPS);
                            m_SamplingMaterial = CoreUtils.CreateEngineMaterial(data.shaders.samplingPS);
                            m_StencilDeferredMaterial = CoreUtils.CreateEngineMaterial(data.shaders.stencilDeferredPS);
                            m_CameraMotionVecMaterial = CoreUtils.CreateEngineMaterial(data.shaders.cameraMotionVector);
                            m_ObjectMotionVecMaterial = CoreUtils.CreateEngineMaterial(data.shaders.objectMotionVector);
                
                            StencilStateData stencilData = data.defaultStencilState;
                            m_DefaultStencilState = StencilState.defaultValue;
                            m_DefaultStencilState.enabled = stencilData.overrideStencilState;
                            m_DefaultStencilState.SetCompareFunction(stencilData.stencilCompareFunction);
                            m_DefaultStencilState.SetPassOperation(stencilData.passOperation);
                            m_DefaultStencilState.SetFailOperation(stencilData.failOperation);
                            m_DefaultStencilState.SetZFailOperation(stencilData.zFailOperation);
                
                            m_IntermediateTextureMode = data.intermediateTextureMode;
                
                            if (UniversalRenderPipeline.asset?.supportsLightCookies ?? false)
                            {
                                var settings = LightCookieManager.Settings.Create();
                                var asset = UniversalRenderPipeline.asset;
                                if (asset)
                                {
                                    settings.atlas.format = asset.additionalLightsCookieFormat;
                                    settings.atlas.resolution = asset.additionalLightsCookieResolution;
                                }
                
                                m_LightCookieManager = new LightCookieManager(ref settings);
                            }
                
                            this.stripShadowsOffVariants = true;
                            this.stripAdditionalLightOffVariants = true;
                #if ENABLE_VR && ENABLE_VR_MODULE
                #if PLATFORM_WINRT || PLATFORM_ANDROID
                            // AdditionalLightOff variant is available on HL&Quest platform due to performance consideration.
                            this.stripAdditionalLightOffVariants = !PlatformAutoDetect.isXRMobile;
                #endif
                #endif
                
            
        *   **Forwardå’ŒForward+ç¯å…‰å‡†å¤‡ï¼Œæ·±åº¦é¢„å¤„ç†ã€æ·±åº¦æ‹·è´æ¨¡å¼ç­‰è®¾ç½®ã€‚**
            
                            ForwardLights.InitParams forwardInitParams;
                            forwardInitParams.lightCookieManager = m_LightCookieManager;
                            forwardInitParams.forwardPlus = data.renderingMode == RenderingMode.ForwardPlus;
                            m_Clustering = data.renderingMode == RenderingMode.ForwardPlus;
                            m_ForwardLights = new ForwardLights(forwardInitParams);
                            //m_DeferredLights.LightCulling = data.lightCulling;
                            this.m_RenderingMode = data.renderingMode;
                            this.m_DepthPrimingMode = data.depthPrimingMode;
                            this.m_CopyDepthMode = data.copyDepthMode;
                
                #if UNITY_ANDROID || UNITY_IOS || UNITY_TVOS
                            this.m_DepthPrimingRecommended = false;
                #else
                            this.m_DepthPrimingRecommended = true;
                #endif
                
                
            
        *   å…³é”®æ¥äº†ï¼URPå®šåˆ¶çš„æµç¨‹åœ¨è¿™é‡Œï¼ˆä»ç¯å…‰é˜´å½±æŠ•å°„ã€æ·±åº¦å’Œæ·±åº¦æ³•çº¿é¢„æ¸²æŸ“ã€åˆ°æ·±åº¦æ‹·è´ã€å»¶è¿Ÿæ¸²æŸ“ä¸­çš„ç‰¹åˆ«æ‰§è¡Œçš„LightModeï¼šâ€UniversalForwardOnlyâ€ã€å†åˆ°å»¶è¿Ÿæ¸²æŸ“çš„GBufferåŠå…¶å¯¹GBufferçš„å±å¹•ç©ºé—´çš„å…‰ç…§å¤„ç†ã€ä¸é€æ˜é˜¶æ®µPassã€æ·±åº¦æ‹·è´ã€è¿åŠ¨å‘é‡Passã€å¤©ç©ºç›’Passã€é€æ˜ç‰©ä½“Passã€ç¦»å±UIPassã€è¦†ç›–UIPassã€æœ€åçš„æ··åˆã€æ·±åº¦æ‹·è´ã€è¾“å‡ºåˆ°ç¼“å†²åŒºâ€œ\_CameraColorAttachmentâ€ï¼‰
            
                            // Note: Since all custom render passes inject first and we have stable sort,
                            // we inject the builtin passes in the before events.
                            m_MainLightShadowCasterPass = new MainLightShadowCasterPass(RenderPassEvent.BeforeRenderingShadows);
                            m_AdditionalLightsShadowCasterPass = new AdditionalLightsShadowCasterPass(RenderPassEvent.BeforeRenderingShadows);
                
                #if ENABLE_VR && ENABLE_XR_MODULE
                            m_XROcclusionMeshPass = new XROcclusionMeshPass(RenderPassEvent.BeforeRenderingOpaques);
                            // Schedule XR copydepth right after m_FinalBlitPass
                            m_XRCopyDepthPass = new CopyDepthPass(RenderPassEvent.AfterRendering + k_AfterFinalBlitPassQueueOffset, m_CopyDepthMaterial);
                #endif
                            m_DepthPrepass = new DepthOnlyPass(RenderPassEvent.BeforeRenderingPrePasses, RenderQueueRange.opaque, data.opaqueLayerMask);
                            m_DepthNormalPrepass = new DepthNormalOnlyPass(RenderPassEvent.BeforeRenderingPrePasses, RenderQueueRange.opaque, data.opaqueLayerMask);
                
                            if (renderingModeRequested == RenderingMode.Forward || renderingModeRequested == RenderingMode.ForwardPlus)
                            {
                                m_PrimedDepthCopyPass = new CopyDepthPass(RenderPassEvent.AfterRenderingPrePasses, m_CopyDepthMaterial, true);
                            }
                
                            if (this.renderingModeRequested == RenderingMode.Deferred)
                            {
                                var deferredInitParams = new DeferredLights.InitParams();
                                deferredInitParams.stencilDeferredMaterial = m_StencilDeferredMaterial;
                                deferredInitParams.lightCookieManager = m_LightCookieManager;
                                m_DeferredLights = new DeferredLights(deferredInitParams, useRenderPassEnabled);
                                m_DeferredLights.AccurateGbufferNormals = data.accurateGbufferNormals;
                
                                m_GBufferPass = new GBufferPass(RenderPassEvent.BeforeRenderingGbuffer, RenderQueueRange.opaque, data.opaqueLayerMask, m_DefaultStencilState, stencilData.stencilReference, m_DeferredLights);
                                // Forward-only pass only runs if deferred renderer is enabled.
                                // It allows specific materials to be rendered in a forward-like pass.
                                // We render both gbuffer pass and forward-only pass before the deferred lighting pass so we can minimize copies of depth buffer and
                                // benefits from some depth rejection.
                                // - If a material can be rendered either forward or deferred, then it should declare a UniversalForward and a UniversalGBuffer pass.
                                // - If a material cannot be lit in deferred (unlit, bakedLit, special material such as hair, skin shader), then it should declare UniversalForwardOnly pass
                                // - Legacy materials have unamed pass, which is implicitely renamed as SRPDefaultUnlit. In that case, they are considered forward-only too.
                                // TO declare a material with unnamed pass and UniversalForward/UniversalForwardOnly pass is an ERROR, as the material will be rendered twice.
                                StencilState forwardOnlyStencilState = DeferredLights.OverwriteStencil(m_DefaultStencilState, (int)StencilUsage.MaterialMask);
                                ShaderTagId[] forwardOnlyShaderTagIds = new ShaderTagId[]
                                {
                                    new ShaderTagId("UniversalForwardOnly"),
                                    new ShaderTagId("SRPDefaultUnlit"), // Legacy shaders (do not have a gbuffer pass) are considered forward-only for backward compatibility
                                    new ShaderTagId("LightweightForward") // Legacy shaders (do not have a gbuffer pass) are considered forward-only for backward compatibility
                                };
                                int forwardOnlyStencilRef = stencilData.stencilReference | (int)StencilUsage.MaterialUnlit;
                                m_GBufferCopyDepthPass = new CopyDepthPass(RenderPassEvent.BeforeRenderingGbuffer + 1, m_CopyDepthMaterial, true);
                                m_DeferredPass = new DeferredPass(RenderPassEvent.BeforeRenderingDeferredLights, m_DeferredLights);
                                m_RenderOpaqueForwardOnlyPass = new DrawObjectsPass("Render Opaques Forward Only", forwardOnlyShaderTagIds, true, RenderPassEvent.BeforeRenderingOpaques, RenderQueueRange.opaque, data.opaqueLayerMask, forwardOnlyStencilState, forwardOnlyStencilRef);
                            }
                
                            // Always create this pass even in deferred because we use it for wireframe rendering in the Editor or offscreen depth texture rendering.
                            m_RenderOpaqueForwardPass = new DrawObjectsPass(URPProfileId.DrawOpaqueObjects, true, RenderPassEvent.BeforeRenderingOpaques, RenderQueueRange.opaque, data.opaqueLayerMask, m_DefaultStencilState, stencilData.stencilReference);
                            m_RenderOpaqueForwardWithRenderingLayersPass = new DrawObjectsWithRenderingLayersPass(URPProfileId.DrawOpaqueObjects, true, RenderPassEvent.BeforeRenderingOpaques, RenderQueueRange.opaque, data.opaqueLayerMask, m_DefaultStencilState, stencilData.stencilReference);
                
                            bool copyDepthAfterTransparents = m_CopyDepthMode == CopyDepthMode.AfterTransparents;
                            RenderPassEvent copyDepthEvent = copyDepthAfterTransparents ? RenderPassEvent.AfterRenderingTransparents : RenderPassEvent.AfterRenderingSkybox;
                
                            m_CopyDepthPass = new CopyDepthPass(
                                copyDepthEvent,
                                m_CopyDepthMaterial,
                                shouldClear: true,
                                copyResolvedDepth: RenderingUtils.MultisampleDepthResolveSupported() && SystemInfo.supportsMultisampleAutoResolve && copyDepthAfterTransparents);
                
                            // Motion vectors depend on the (copy) depth texture. Depth is reprojected to calculate motion vectors.
                            m_MotionVectorPass = new MotionVectorRenderPass(copyDepthEvent + 1, m_CameraMotionVecMaterial, m_ObjectMotionVecMaterial, data.opaqueLayerMask);
                
                            m_DrawSkyboxPass = new DrawSkyboxPass(RenderPassEvent.BeforeRenderingSkybox);
                            m_CopyColorPass = new CopyColorPass(RenderPassEvent.AfterRenderingSkybox, m_SamplingMaterial, m_BlitMaterial);
                #if ADAPTIVE_PERFORMANCE_2_1_0_OR_NEWER
                            if (needTransparencyPass)
                #endif
                            {
                                m_TransparentSettingsPass = new TransparentSettingsPass(RenderPassEvent.BeforeRenderingTransparents, data.shadowTransparentReceive);
                                m_RenderTransparentForwardPass = new DrawObjectsPass(URPProfileId.DrawTransparentObjects, false, RenderPassEvent.BeforeRenderingTransparents, RenderQueueRange.transparent, data.transparentLayerMask, m_DefaultStencilState, stencilData.stencilReference);
                            }
                            m_OnRenderObjectCallbackPass = new InvokeOnRenderObjectCallbackPass(RenderPassEvent.BeforeRenderingPostProcessing);
                
                            m_DrawOffscreenUIPass = new DrawScreenSpaceUIPass(RenderPassEvent.BeforeRenderingPostProcessing, true);
                            m_DrawOverlayUIPass = new DrawScreenSpaceUIPass(RenderPassEvent.AfterRendering + k_AfterFinalBlitPassQueueOffset, false); // after m_FinalBlitPass
                
                            {
                                var postProcessParams = PostProcessParams.Create();
                                postProcessParams.blitMaterial = m_BlitMaterial;
                                postProcessParams.requestHDRFormat = GraphicsFormat.B10G11R11_UFloatPack32;
                                var asset = UniversalRenderPipeline.asset;
                                if (asset)
                                    postProcessParams.requestHDRFormat = UniversalRenderPipeline.MakeRenderTextureGraphicsFormat(asset.supportsHDR, asset.hdrColorBufferPrecision, false);
                
                                m_PostProcessPasses = new PostProcessPasses(data.postProcessData, ref postProcessParams);
                            }
                
                            m_CapturePass = new CapturePass(RenderPassEvent.AfterRendering);
                            m_FinalBlitPass = new FinalBlitPass(RenderPassEvent.AfterRendering + k_FinalBlitPassQueueOffset, m_BlitMaterial, m_BlitHDRMaterial);
                
                #if UNITY_EDITOR
                            m_FinalDepthCopyPass = new CopyDepthPass(RenderPassEvent.AfterRendering + 9, m_CopyDepthMaterial);
                #endif
                
                            // RenderTexture format depends on camera and pipeline (HDR, non HDR, etc)
                            // Samples (MSAA) depend on camera and pipeline
                            m_ColorBufferSystem = new RenderTargetBufferSystem("_CameraColorAttachment");
                
            
        *   **æœ€åæœ€ä¸€äº›å…¼å®¹æ“ä½œï¼Œç»“æŸæ„é€ ã€‚å®ŒæˆURPåŸºæœ¬ç®¡çº¿çš„ä¸»ä½“æµç¨‹ã€‚**
            
                supportedRenderingFeatures = new RenderingFeatures();
                
                            if (this.renderingModeRequested == RenderingMode.Deferred)
                            {
                                // Deferred rendering does not support MSAA.
                                this.supportedRenderingFeatures.msaa = false;
                
                                // Avoid legacy platforms: use vulkan instead.
                                unsupportedGraphicsDeviceTypes = new GraphicsDeviceType[]
                                {
                                    GraphicsDeviceType.OpenGLCore,
                                    GraphicsDeviceType.OpenGLES2,
                                    GraphicsDeviceType.OpenGLES3
                                };
                            }
                
                            LensFlareCommonSRP.mergeNeeded = 0;
                            LensFlareCommonSRP.maxLensFlareWithOcclusionTemporalSample = 1;
                            LensFlareCommonSRP.Initialize();
                
                            m_VulkanEnablePreTransform = GraphicsSettings.HasShaderDefine(BuiltinShaderDefine.UNITY_PRETRANSFORM_TO_DISPLAY_ORIENTATION);
                        }
                
            

### â€Œ**æ ¸å¿ƒæ¸²æŸ“æµç¨‹åˆ†è§£**â€Œ

URPå°†æ¸²æŸ“åˆ†ä¸ºäº”ä¸ªé˜¶æ®µï¼Œå‡åœ¨`Render()`æ–¹æ³•ä¸­è°ƒåº¦ï¼š

â€Œ**é˜¶æ®µ**â€Œ

â€Œ**URPå®ç°ç»†èŠ‚**â€Œ

â€Œ**å‡†å¤‡é˜¶æ®µ**â€Œ

æ”¶é›†åœºæ™¯æ¸²æŸ“å¯¹è±¡ä¸å…‰æºæ•°æ®ï¼Œé…ç½®ç›¸æœºå‚æ•°ä¸ç›®æ ‡çº¹ç†ã€‚

â€Œ**å‡ ä½•é˜¶æ®µ**â€Œ

æ‰§è¡Œè§†é”¥å‰”é™¤ï¼Œç”ŸæˆGPUé¡¶ç‚¹æ•°æ®ï¼›é€šè¿‡`ScriptableRenderContext.DrawRenderers`æäº¤ç»˜åˆ¶å‘½ä»¤ã€‚

â€Œ**å…‰ç…§é˜¶æ®µ**â€Œ

é‡‡ç”¨ç®€åŒ–PBRæ¨¡å‹ï¼šè®¡ç®—å®æ—¶å…‰æºè´¡çŒ®ï¼Œæ”¯æŒçƒ˜ç„™å…‰ç…§æ··åˆï¼›åŠ¨æ€å…‰æºé‡‡ç”¨Tile-Basedä¼˜åŒ–ç­–ç•¥ï¼ˆForward+è·¯å¾„æ—¶ï¼‰ã€‚

â€Œ**å…‰æ …åŒ–é˜¶æ®µ**â€Œ

æ‰§è¡Œæ·±åº¦é¢„é€šé“ï¼ˆDepth Prepassï¼‰å‡å°‘è¿‡åº¦ç»˜åˆ¶ï¼Œç»“åˆGPU Instancingä¼˜åŒ–æ‰¹æ¬¡å¤„ç†ã€‚

â€Œ**åå¤„ç†é˜¶æ®µ**â€Œ

åœ¨ç‹¬ç«‹Passä¸­åº”ç”¨æŠ—é”¯é½¿ï¼ˆFXAA/TAAï¼‰ã€Bloomç­‰æ•ˆæœï¼Œæ”¯æŒ**è‡ªå®šä¹‰RendererFeatureæ‰©å±•**ã€‚

### â€Œ**æ€§èƒ½ä¼˜åŒ–å…³é”®æŠ€æœ¯**â€Œ

*   â€Œ**SRP Batcher**â€Œï¼šå¯¹ç›¸åŒShaderå˜ä½“ä½†ä¸åŒæè´¨çš„ç‰©ä½“è¿›è¡ŒåŠ¨æ€åˆæ‰¹ï¼Œæ˜¾è‘—é™ä½SetPass Callã€‚
*   â€Œ**å…‰ç…§å‰”é™¤ä¼˜åŒ–**â€Œï¼šæŒ‰å±‚çº§æ§åˆ¶å‰”é™¤è·ç¦»ï¼ˆ`layerCullDistances`ï¼‰ï¼Œå¯¹é™æ€ç‰©ä½“é¢„è®¡ç®—é®æŒ¡æ•°æ®ã€‚

### **URPå¯¹SRPçš„æ‰©å±•ä¸ç®€åŒ–â€Œ**

*   â€Œ**æ ‡å‡†åŒ–åŠŸèƒ½å°è£…**â€Œ
    *   å†…ç½®è½»é‡çº§PBRå…‰ç…§æ¨¡å‹ï¼Œå–ä»£HDRPçš„å¤æ‚ç‰©ç†æ¨¡æ‹Ÿä»¥æå‡è·¨å¹³å°æ€§èƒ½ã€‚
    *   é›†æˆâ€Œ**Shader Graph**â€Œå¯è§†åŒ–å·¥å…·é“¾ï¼Œé™ä½ç€è‰²å™¨å¼€å‘é—¨æ§›ã€‚ï¼ˆåæœŸç‰ˆæœ¬å†…ç½®ç®¡çº¿ä¹Ÿå¯ç”¨ShaderGraphäº†ï¼‰
*   â€Œ**è·¨å¹³å°é€‚é…ç­–ç•¥**â€Œ
    *   åŠ¨æ€åˆ‡æ¢æ¸²æŸ“ç²¾åº¦ï¼ˆå¦‚ç§»åŠ¨ç«¯ç¦ç”¨å®æ—¶é˜´å½±ï¼‰ï¼Œé€šè¿‡`QualitySettings`åˆ†çº§é…ç½®ã€‚
    *   èµ„æºåŒ…ç²¾ç®€ï¼šå‰”é™¤HDRPçš„é«˜ç²¾åº¦è´´å›¾ä¸è®¡ç®—å¯†é›†å‹ç‰¹æ•ˆï¼Œç¼©å°è¿è¡Œæ—¶å†…å­˜å ç”¨ã€‚

### å¯¹URPçš„æ‰©å±•

*   URPåŸºæœ¬ç®¡çº¿æµç¨‹åœ¨`UniversalRenderer`çš„æ„é€ å‡½æ•°ä¸­å·²ç»å®šä¹‰å®Œæ•´ã€‚å¹¶ä¸”åœ¨å…¶ä¸­æ¯ä¸ªé˜¶æ®µéƒ½ç»™å‡ºäº†æ’å…¥ç‚¹ã€‚é‚£ä¹ˆåªéœ€è¦åœ¨è¿™äº›æ’å…¥ç‚¹ç”¨åˆ›å»ºRendererFeatureçš„æ–¹å¼æ’å…¥è‡ªå®šä¹‰çš„Passæ¥å½±å“å’Œæ‰©å……åŸºæœ¬çš„URPç®¡çº¿ã€‚
*   è¿˜æœ‰ä¸€ç§æ–¹å¼ç”¨`RenderPipelineManager` æä¾›çš„ç‚¹ä½æ’å…¥è‡ªå®šä¹‰Passã€‚

* * *

> [ã€ä»UnityURPå¼€å§‹æ¢ç´¢æ¸¸æˆæ¸²æŸ“ã€‘](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**ä¸“æ -ç›´è¾¾**

ï¼ˆæ¬¢è¿_ç‚¹èµç•™è¨€_æ¢è®¨ï¼Œæ›´å¤šäººåŠ å…¥è¿›æ¥èƒ½æ›´åŠ å®Œå–„è¿™ä¸ªæ¢ç´¢çš„è¿‡ç¨‹ï¼ŒğŸ™ï¼‰