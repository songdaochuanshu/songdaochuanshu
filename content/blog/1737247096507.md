---
layout: post
title: '使用PythonDEAP库实现简单遗传算法'
date: "2025-01-19T00:38:16Z"
---
使用PythonDEAP库实现简单遗传算法
=====================

​  
[本人博客食用体验更佳哦](https://lkasnive.github.io/2025/01/18/%E4%BD%BF%E7%94%A8PythonDEAP%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/)

DEAP（Distributed Evolutionary Algorithms in Python）是一个用于快速原型设计和实验的进化计算框架。它支持多种进化算法，包括遗传算法、遗传编程、进化策略、粒子群优化等。DEAP 的设计目标是灵活性和易用性，使得研究人员和开发者能够轻松地实现和测试各种进化算法。

[官方文档](https://deap.readthedocs.io/en/master/)

[官方GitHub仓库](https://github.com/DEAP/deap?tab=readme-ov-file)

因本人主攻方向并不是Python甚至可以说之前对Python一窍不通，如有错误，还望各位读者指正。

本篇也以讲解用法为主，具体的类的继承和原理并不涉及。

这里以求 \\(f(x) = (x - 5) ^ 2\\) 和 \\(f(x) = -x ^ 2 + 4x + 4\\) 在 \\(\[0, 31\]\\) 上都尽可能大为目标的，多目标优化为例。

0.载入DEAP库
---------

    
    import random
    
    from deap import base, creator, tools, algorithms
    
    

由于并不需要deap库所有的功能，这里仅载入要用到的几个模块。

1\. 创建适应度函数
-----------

    
    def evaluate(individual):
    
        ans = 0
    
        for i in range(len(individual)):
    
            ans += (individual[i] << i)
    
        return ((ans - 5) ** 2, -ans ** 2 + ans * 4 + 4)
    
    

因为适应度默认是一个元组，这里选择返回一个元组。而每个整数采用二进制存储，则是因为在后面的基因交换中，要求两个基因是列表，整数无法进行交换操作。

2\. 创建个体，种群
-----------

    
    def init_individual(icls):
    
        content = [toolbox.attr_int() for _ in range(5)]
    
        individual = icls(content)
    
        individual.fitness.values = (0.0, 0.0) #初始化适应度
    
        return individual
    
    creator.create("FitnessMulti", base.Fitness, weights=(1.0, 1.0)) #创建适应度
    
    creator.create("Individual", list, fitness=creator.FitnessMulti) #创建个体类，个体为一个列表，并将适应度作为其中的一个属性
    
    toolbox = base.Toolbox()
    
    toolbox.register("attr_int", random.randint, 0, 1) #随即生成0或1作为二进制的每一位
    
    toolbox.register("individual", init_individual, creator.Individual)#注册个体生成函数
    
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)#注册种群生成函数，生成种群为一个列表
    
    

此处第六行weights是适应度，库默认为一个元组。因为此次举例是双函数得到多目标优化，因此元组有两个元素，每个元素的绝对值表示该维函数的权重，正负则表示是最大化还是最小化；为正，则表示目的是使该维元素最大化。

### 各个函数介绍

#### creator.creat基本用法

在 DEAP 库中，creator.create 是一个非常重要的函数，用于动态创建新的类型。这些类型通常用于定义个体的表示方式（如染色体）和适应度函数。creator.create 的灵活性使得 DEAP 能够适应各种不同的进化算法需求。

    
    creator.create(name, base, **kwargs)
    
    

参数说明：

参数名

类型

说明

name

字符串

新类型的名称 。

base

python内置类或自定义类

用于生成每个对象的函数（例如生成随机个体的函数）。

\*\*kwargs

视情况而定

额外的属性，通常用于添加适应度函数或其他自定义属性 。

#### toolbox.register基本用法

toolbox.register 用于将函数或操作注册到 toolbox 对象中，方便在算法中调用。通常用于注册个体生成、交叉、变异、选择等操作。如所给代码中，注册后individual和population就是可以直接调用的函数。

    
    toolbox.register(alias, method, *args, **kargs)
    
    

参数说明：

参数名

类型

说明

lias

类型

这是你为操作定义的名称，后续可以通过 toolbox.alias 调用该操作。

method

可调用对象

这是实际执行操作的函数或方法。

\*args

可变位置参数

如果 method 需要若干个参数，可以通过 \*args 传递。

\*\*kargs

可变关键字参数

如果 method 需要关键字参数，可以通过 \*\*kargs 传递。

以原代码中的为例

    
    toolbox.register("individual", init_individual, creator.Individual)
    
    

我们注册了一个名为individual的函数，后续可通过toolbox.individual()调用，函数实际上执行的是init\_individual函数的内容,creator.Individual是之前创造的个体类，作为参数传入init\_individual。

#### tools.initRepeat基本用法

在 DEAP 库中，tools.initRepeat 是一个用于生成重复结构的工具函数。它通常用于初始化个体或种群，生成包含重复元素的列表或其他数据结构。以下是 tools.initRepeat 的详细参数及其用法：

    
    deap.tools.initRepeat(container, func, n)
    
    

参数说明：

参数名

类型

说明

container

类型

用于存储生成对象的容器类型（例如 list、set 等）。

func

可调用对象

用于生成每个对象的函数（例如生成随机个体的函数）。

n

整数

需要生成的对象数量（例如种群大小）。

实际上是执行func函数n次，并将其存入container类型中。

以原代码中的为例

    
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)
    
    

我们注册了一个名为population的函数函数，实际上执行的是tools.initRepeat函数的内容,list表明生成的对象，也就是种群，是一个列表，作为参数传入tools.initRepeat，toolbox.individual是initRepeat重复执行的内容。注意到，此处并未写出重复执行次数n。这样我们在后续的种群生成中就可以自由选择生成种群的大小。

同时，因为此例我们的个体是一个整数，也就是一个五个元素的列表。但在某些情况下，我们的个体未必是一个元素，这时，生成个体的函数也可以通过同样的方法实现。例如：我可以定义一个个体是由五个列表构成，每个列表有五个元素（0或1）。toolbox.individual可以如此注册：

    
    toolbox.register("individual", tools.initRepeat, list, init_individual, creator.Individual, n = 5)
    
    

_注意：_ 此处的注册函数有误，因为此种写法会导致creator.Individual被视作tools.initRepeat的第三个参数也就是重复次数，而不会被视作init\_individual的参数。因此init\_individual应使用匿名函数形式，以避免这种情况。这里没做修改。

3\. 创建其他需要的参数和函数
----------------

    
    toolbox.register("evaluate", evaluate) #注册适应度函数
    
    toolbox.register("mate", tools.cxTwoPoint) #采用两点交叉方法
    
    toolbox.register("mutate", tools.mutFlipBit, indpb=0.1) #采用位翻转变异发，每个基因变异概率0.1
    
    toolbox.register("select", tools.selNSGA2)  # 因为是多目标优化问题，使用 NSGA-II 选择机制
    
    population_size = 50 # 种群规模
    
    generations = 40 # 繁殖代数
    
    crossover_prob = 0.9 # 交叉概率
    
    mutation_prob = 0.2# 个体变异概率
    
    population = toolbox.population(n = population_size) #生成规模为50的种群
    
    

在这个过程中，基因交叉，变异，选择机制都有很多，各位读者可以根据需求自由选择。

4.执行遗传算法
--------

    
    for gen in range(generations):
    
        offspring = algorithms.varAnd(population, toolbox, cxpb = crossover_prob, mutpb = mutation_prob)
    
        fits = map(toolbox.evaluate, offspring)
    
        for fit, ind in zip(fits, offspring):
    
            ind.fitness.values = fit
    
        population = toolbox.select(offspring + population, k = population_size)
    
    

#### algorithms.varAnd基本用法

    
    algorithms.varAnd(population, toolbox, cxpb, mutpb)
    
    

参数名

类型

说明

population

注册的种群类

当前种群。

toolbox

Toolbox 对象

包含注册的交叉、变异和选择操作。

cxpb

浮点数

表示两个个体进行交叉的概率。

mutpb

浮点数

表示个体发生变异的概率。

varAnd 会从 toolbox 中调用注册的函数；toolbox.mate：交叉操作；toolbox.mutate：变异操作。

之后如有需要，可以输出最后的种群，也可结合matplotlib绘制图表。

​