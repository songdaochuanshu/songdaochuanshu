---
layout: post
title: '吴恩达深度学习课程二： 改善深层神经网络 第三周：超参数调整，批量标准化和编程框架（三）多值预测与多分类'
date: "2025-11-19T00:42:41Z"
---
吴恩达深度学习课程二： 改善深层神经网络 第三周：超参数调整，批量标准化和编程框架（三）多值预测与多分类
====================================================

此分类用于记录吴恩达深度学习课程的学习笔记。  
课程相关信息链接如下：

1.  原课程视频链接：[\[双语字幕\]吴恩达深度学习deeplearning.ai](https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&from_spmid=playlist.playlist-detail.0.0&is_story_h5=false&mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&plat_id=116&share_from=ugc&share_medium=android&share_plat=android&share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&share_source=COPY&share_tag=s_i&spmid=united.player-video-detail.0.0&timestamp=1713085655&unique_k=DfBgvFW&up_id=8654113&vd_source=e035e9878d32f414b4354b839a4c31a4)
2.  github课程资料，含课件与笔记:[吴恩达深度学习教学资料](https://github.com/robbertliu/deeplearning.ai-andrewNG)
3.  课程配套练习（中英）与答案：[吴恩达深度学习课后习题与答案](https://blog.csdn.net/u013733326/article/details/79827273)

本篇为第二课的第三周内容，[3.8](https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&vd_source=e035e9878d32f414b4354b839a4c31a4&p=78)到[3.9](https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&vd_source=e035e9878d32f414b4354b839a4c31a4&p=79)的内容。

* * *

本周为第二课的第三周内容，你会发现这周的题目很长，实际上，作为第二课的最后一周内容，**这一周是对基础部分的最后补充。**  
在整个第一课和第二课部分，我们会了解到最基本的全连接神经网络的基本结构和一个完整的模型训练，验证的各个部分。  
之后几课就会进行更多的实践和进阶内容介绍，从“通用”走向“特化”。  
总的来说这周的难度不高，但也有需要理解的内容，我仍会在相对较难理解的部分增加更多基础和例子，以及最后的“人话版”总结。

本篇的内容关于**多值预测与多分类**，之前的内容里我们一直只进行“是”或“不是”的二分类或者单值预测，通过本篇的了解后，便可以拓展到多分类和多值预测。

1\. 神经网络的输出层
============

在之前的内容里，我们基本**默认神经网络的输出层只有一个神经元**。  
而要从单值预测到多值预测，从二分类拓展到多分类，最大的改变就是神经网络输出层的神经元数量。  
现在，我们展开叙述一下**神经网络输出层不同数量的神经元所带来的影响**。

1.1 输出层为单个神经元
-------------

这是我们之前一直使用的结构，它的含义取决于你在做什么任务：  
如果是预测任务，我们便认为这个神经元的输出是最终的预测值。  
如果是分类任务，我们便把这个神经元经过sigmoid激活函数的输出视为“是”的概率。  
简单展开一下：

#### （1）回归任务

比如预测房价、预测温度这种“输出一个具体数值”的任务：  
在这种任务里，我们的”答案“ 就是房价或者温度，因此，**整个网络就是在通过输入拟合最终这个”答案“。**  
因此：

*   输出层一个神经元
*   不加激活函数
*   输出值直接就是模型的预测结果

就像这样：  
![Pasted image 20251118124635](https://img2024.cnblogs.com/blog/3708248/202511/3708248-20251118144059205-167032707.png)

#### （2）二分类任务

就是我们一直在用的“猫狗分类”，  
回归和分类在逻辑上是相通的，只看我们的处理方式。在这个例子里，**我们的“答案”就是”是不是猫“，不同于回归问题的具体数值，二分类的输出是一个”是不是“即 ”0或1“的选择。**  
因此：

*   输出层一个神经元
*   最后接一个 **sigmoid**
*   输出在 0~1 之间，通过决策阈值进行选择，可以理解为“是”的概率  
    这种结构我们已经非常熟悉了，我们之前所有分类例子都是这种方式。  
    就像这样：  
    ![Pasted image 20251118104144](https://img2024.cnblogs.com/blog/3708248/202511/3708248-20251118144108894-1782868911.png)

**1.2 输出层为两个神经元**
-----------------

当输出层的神经元数量从 1 个变为 2 个时，模型的输出形式就发生变化了：  
它从“输出一个值 / 一个概率”，变成了“输出两个值 / 两个概率”。  
这种结构在两类场景下非常常见：  
**（1）预测两个连续量的回归任务**。  
**（2）二分类任务的另一种表达方式(实际上并不常用)**  
我们逐一展开。

#### （1）预测两个连续量回归任务

上面我们用温度和房价来举例预测一个连续量的任务。  
但在生活中，我们你也会遇到一些**模型需要同时预测两个值的情况**，例如：

*   预测一个物体的 **x 坐标** 和 **y 坐标**
*   预测产品的 **高度** 和 **宽度**
*   预测天气中的 **风的两个分量（ 东西方向风和南北方向风）**  
    在这样的任务要求中，需要预测的量变成了两个，**就像是我们原本的”答案“只有一个空要填，现在要填两个。**  
    因此：
*   输出层两个神经元
*   依旧不加激活函数（保持数值范围连续）
*   每个神经元输出一个独立的回归值，各自代表一项预测结果。  
    模型最终的输出是两个具体数值，如：

\\\[\[3.5,\\ 1.2\] \\\]

**直观的理解就是： 网络要输出两个信息，所以自然需要两个神经元各自负责一项。**  
就像这样：  
![Pasted image 20251118110211](https://img2024.cnblogs.com/blog/3708248/202511/3708248-20251118144122820-1760218299.png)

#### （2）二分类任务的另一种表达

我们已经非常习惯 “一个神经元 + sigmoid” 的二分类方式了。  
但实际上，**如果按照刚刚二值预测的回归逻辑，那其实二分类也应该使用两个输出层神经元来表示才对吧？**  
就像我们一直用的猫狗二分类，实际在逻辑上，我们不应该输出”是猫的概率“和”是狗的概率“吗？  
为什么我们能只用一个输出层神经元来进行二分类，答案很简单，相信不用我多解释：  
**因为二分类是一个非黑即白，非此即彼的问题。**  
所以我们用下面这样的逻辑来化简了网络结构：

\\\[是A的概率+决策阈值=是A的概率+是B的概率+取A,B中的大值 \\\]

因此，这其实只是二分类任务的另一种表达，且**我们并不常用**，形式如下：

*   输出层两个神经元
*   最后接 **softmax**
*   softmax 输出的是一个长度为 2 的概率分布

\\\[ \[P(\\text{类1}),\\ P(\\text{类2})\] \\\]

*   两个概率加起来一定等于 1  
    **这里要说明：softmax是针对多分类问题的激活函数，它和sigmoid的区别，为什么适用，我们在下面马上就会展开介绍。**  
    就像这样：  
    ![Pasted image 20251118112233](https://img2024.cnblogs.com/blog/3708248/202511/3708248-20251118144136223-1188536848.png)

1.3 输出层为多个神经元
-------------

当输出层的神经元数量从 **2 个继续扩展到更多个**时，本质上意味着：  
**我们希望神经网络一次性输出更多的信息。**  
这种结构在回归和分类领域都非常常见，我们依旧像前面一样分两种情况展开。

#### （1）预测多个连续量的回归任务

上面的内容中，我们分别预测了一个值（房价）、两个值（x,y 风向）。  
而在很多实际任务中，“答案”往往不止两个，有时候甚至要预测一整个向量。  
例如：

*   一次预测物体的 **位置 + 宽度 + 高度 + 朝向**（共 4 个值）
*   一次预测未来 **多天的气温序列**（比如预测未来 7 天，每天一个温度，共 7 个输出）
*   预测某个过程的 **多个物理量**（速度、加速度、角速度、角加速度……）  
    这些任务都在告诉我们：  
    **需要输出多少个数，输出层就要给多少个神经元。**  
    因此：
*   输出层有 **n 个神经元**
*   每个神经元负责预测一个独立的连续值
*   输出层一般 **不加激活函数**（保持回归问题需要的连续范围）  
    这样，模型最终输出的是一个 n 维向量，例如：

\\\[\[2.1,\\ 0.7,\\ 5.6,\\ 1.2,\\ 3.9\] \\\]

还是用答案打比方：原本答案只有一个空，现在有 n 个空，所以输出层神经元自然跟着变多。

就像这样：  
![Pasted image 20251118123716](https://img2024.cnblogs.com/blog/3708248/202511/3708248-20251118144146058-823166760.png)

#### （2）多分类任务

前面我们说过：

*   二分类判断的是 **是不是**（0 或 1）
*   多分类判断的是 **是哪一种**（从多个类别中选 1）  
    因此非常自然地：  
    **输出层的神经元数量 = 类别数量**  
    例如：
*   手写数字识别：10 种 → 输出层 10 个神经元
*   动物识别：5 种 → 输出层 5 个神经元
*   情感分析：3 种 → 输出层 3 个神经元  
    当类别多起来时，我们不能再用一个神经元得出一个概率了。  
    所以它的输出结构变为：
*   输出层 n 个神经元
*   最后接 **softmax 激活函数**
*   softmax 把 n 个输出变成一个概率分布

\\\[\[P(类1),\\ P(类2),\\ \\dots,\\ P(类n)\], \\quad \\sum\_i P\_i = 1 \\\]

简单来说：**每个神经元都是一个“类别候选”，softmax 会让它们“竞争”，谁分最高就是谁。**  
现在可能还不太清晰，别担心，我们马上就会详细展开。  
先来看一下网络结构，就像这样：  
![Pasted image 20251118124551](https://img2024.cnblogs.com/blog/3708248/202511/3708248-20251118144204493-146026311.png)

**总之，输出层有多少神经元，完全取决于你的任务希望模型给你多少信息。**

2\. 多分类的核心：softmax
==================

在上面我们提到：  
当输出层神经元从 1 个扩展到多个时，分类任务往往使用 **softmax** 来得到一个“概率分布”。  
但为什么我们之前一直用的 **sigmoid** 不行呢？  
softmax 又到底“厉害”在哪里？  
这里我们就来详细展开：

**2.1 sigmoid 为什么不适用多分类问题？**
----------------------------

我们第一次介绍sigmoid是在这里：[激活函数和反向传播](https://www.cnblogs.com/Goblinscholar/p/19150292)  
通过之前的学习内容：我们可以简单地总结：  
**sigmoid 的本质，就是把一个数压到 0~1，用来表示“是”的概率。**  
这种映射非常适合二分类，因为二分类的问题就是：

> 是 / 不是  
> 1 / 0  
> 猫 / 不是猫

可到了多分类问题里，它就会出现一些问题，我们来展开说明：

#### （1）sigmoid的分类逻辑

现在，假如我们要做 3 类分类：猫 / 狗 / 老虎。  
如果输出层有三个神经元，每个都接 sigmoid，那么可能出现：

类别

sigmoid 输出

猫

0.9

狗

0.8

老虎

0.85

这些概率 **加起来不是 1**，并且三个看起来都“很像”，但我们的问题本质是 —— **只能选其中一个**！  
sigmoid 的输出互不影响，彼此独立，就像问模型三次：

*   像猫吗？
*   像狗吗？
*   像老虎吗？  
    模型每次都可以说“很像”。  
    这显然不符合“选一个类别”的逻辑。  
    **你可能会说：那我选最大的可能，也就是输出最大的那个不就行了吗？**  
    这么做看起来是一个解决方案，但它的**核心问题是：没有考虑到传播**，这会对拟合产生极大影响。

#### （2）为什么不能只“选最大”？

我们就上面这个问题继续展开：  
比如真实标签是“猫”，也就是说正确答案是：

*   猫：1
*   狗：0
*   老虎：0  
    但因为三个 sigmoid 之间互不影响，模型可以学到一种非常奇怪但“不会被惩罚”的策略：
*   猫：0.99（正确，因为要接近 1）
*   狗：0.95（虽然应该接近 0，但 sigmoid 的 loss 不会让它“被压下很多”）
*   老虎：0.97（同上）  
    只要“猫”这一类够高，它就能被认为预测正确。  
    换句话说：**sigmoid 的多分类本质上是 3 个互不相关的二分类任务，它无法学到“如果是猫，那就不应该是狗或老虎”。**  
    这是为什么？我们再来复习一下二分类的损失函数，它第一次出现在这里：[损失函数](https://www.cnblogs.com/Goblinscholar/p/19133349)

#### （3）从损失函数看sigmoid

**sigmoid 的损失函数**（二分类交叉熵损失，Binary Cross-Entropy）如下：  
对于单个神经元输出 \\(\\hat{y}\\) 和真实标签 \\(y \\in {0,1}\\)：

\\\[\\text{loss} = - \\big( y \\log \\hat{y} + (1-y) \\log (1-\\hat{y}) \\big) \\\]

这条公式告诉我们：

*   当 \\(y=1\\) 时，loss 只关注让 \\(\\hat{y}\\) 越接近 1 越好
*   当 \\(y=0\\) 时，loss 只关注让 \\(\\hat{y}\\) 越接近 0 越好

现在回到三分类的例子：猫 / 狗 / 老虎  
我们计算它的一次传播如下：

类别

真实标签 \\(y\\)

模型输出 \\(\\hat{y}\\)

Loss 公式

Loss 值

猫

1

0.99

\\(-\\log 0.99\\)

\\(\\approx 0.01\\)

狗

0

0.95

\\(-\\log (1-0.95)\\)

\\(\\approx 3.0\\)

老虎

0

0.97

\\(-\\log (1-0.97)\\)

\\(\\approx 3.0\\)

看上去似乎其他类别会被压低，为什么会出现“它们也很像”这种情况呢？  
关键在于 **梯度的传播和训练目标**：

*   每个 sigmoid 输出对应一个 **独立的二分类任务**
*   当使用 mini-batch 或者权重初始化不理想时，**梯度更新仍可能非常弱**，让梯度消失。
*   模型可以通过调整权重让 **猫** 输出极大，同时让 **狗/老虎** 也维持相对高值，只要最终“猫”的输出比阈值高，整体预测还是正确的。**sigmoid 没有全局约束去强制其他输出必须降低。**

总的来说：**sigmoid它没有“互斥性“的逻辑，在二分类里，它可以只针对正类不断强化，因为不是正类自然就是负类。**  
**而现在的多分类里，它不知道“只有一个类别应该成立”，”惩罚力度”不够大，对错误类别的拳不够快，不够狠！**  
这就是它的不适用性的核心重点，再直白点：**它很好，只是现在在这方面有比它更好的。**  
不过这也并不绝对，在一些多标签多分类问题里，sigmoid反而更适用，我们遇到再说。

**2.2 softmax 如何适应多分类问题？**
--------------------------

接下来，我们的主角是 **softmax**。

如果说 sigmoid 是“我像不像猫？”，  
那么 softmax 更像是：“把所有类别排排队，看谁最像”，也就是说，它会让各个类别互相 **竞争**，最后给出一个 **概率分布**。

它的数学形式如下：

\\\[P\_i = \\frac{e^{z^{(i)}}}{\\sum\_j e^{z{\[j\]}}} \\\]

并不复杂，我们一一展开这个公式的组成：

#### (1) 把输出转为正数并凸显最优类别

我们知道，网络输出的 \\(z^{(i)}\\) 可能是负数、零或正数，直接当作概率不行。  
所以，softmax 先用指数函数 \\(e^{z^{(i)}}\\) 转换：  
1\. 保证所有值为正  
2\. 放大原本相近的差距，使“最优类别”更明显。

举个实例：

\\\[\[e^{2.1},e^{0.0},e^{−1.0}\]≈\[8.17,1.00,0.37\] \\\]

这样，第一个类别概率最高 → 最可能被选中  
同时，指数化差别被放大→ 其他类别自动压低更多 → 避免像 sigmoid 那样“多个类别都很高”。  
现在来看下一步：

#### （2）把指数值归一化成概率

\\\[P\_i = \\frac{e^{z^{(i)}}}{\\sum\_j e^{z^{\[j\]}}} \\\]

直白的说，就是把数值转变成这个数占所有数和的比例。  
继续上面的例子：

\\\[\[8.17/(8.17+1+0.37), 1/9.54, 0.37/9.54\]≈\[0.86,0.10,0.04\] \\\]

这样下来：

1.  所有 \\(P\_i\\) 都在 0~1 之间
2.  所有 \\(P\_i\\) 的和 = 1

这正好符合单标签多分类问题的要求：“**输出一个概率分布，所有类别概率加起来为 1**。”

补充一点：**什么叫单标签多分类，什么叫多标签多分类？**

1.  单标签多分类：每个样本只对应一个标签：一张图里只有猫或狗。
2.  多标签多分类：每个样本可以对应多个标签：一张图里可以同时有猫和狗。

#### （3）总结 softmax 的优势

*   **互斥性**：输出自然体现“只能选一个类别”的逻辑
*   **概率分布**：所有输出加和为 1，方便解释和比较
*   **指数放大**：最可能的类别更明显，更易学习  
    这便是softmax 适合多分类的原因所在。

2.3 softmax的损失函数
----------------

在二分类里，我们用 **Binary Cross-Entropy（BCE）** 来衡量预测概率和真实标签的差距。  
在多分类里，softmax 对应的损失函数叫 **Categorical Cross-Entropy（多分类交叉熵）**。  
它如何和 softmax 配合？我们来看看。

#### （1）损失函数公式

假设样本真实类别是 \\(y\\)，模型预测概率是 \\(P\_i\\)，那么损失函数为：

\\\[\\text{Loss} = - \\sum\_{i=1}^{n} y\_i \\log P\_i \\\]

**注意，这里假设用一种叫独热编码的技术表示类别，不会因用1，2，3表示类别而出现数值差别，我们后面就会了解到。**  
现在解释一下：

*   \\(y\_i\\) = 1 → 正确类别
*   \\(y\_i\\) = 0 → 其他类别
*   损失只关注正确类别对应的概率 \\(P\_\\text{正确类别}\\)
*   如果正确类别的概率越高，\\(\\log P\_\\text{正确类别}\\) 越接近 0，损失越小  
    来看一个实例。

#### （2）举例说明

假设一个三分类问题（猫 / 狗 / 老虎），真实类别是“猫”，模型 softmax 输出概率为：

\\\[P = \[0.7, 0.2, 0.1\] \\\]

*   正确类别猫 → \\(y = \[1,0,0\]\\)
*   损失计算：

\\\[\\text{Loss} = -(1 \\cdot \\log 0.7 + 0 \\cdot \\log 0.2 + 0 \\cdot \\log 0.1) = -\\log 0.7 \\approx 0.357 \\\]

再来看一个不理想的情况：

\\\[P = \[0.4, 0.3, 0.3\] \\\]

*   损失：

\\\[\\text{Loss} = -\\log 0.4 \\approx 0.916 \\\]

**可以看到：正确类别概率越高，损失越小；概率低，损失变大 → 模型会被强烈“惩罚”，迫使它把正确类别概率提高。**

这样，由于 softmax 的**互斥性**，提升正确类别概率的同时，其他类别概率会被压低，反向传播时梯度明确，模型容易学习，就避免 sigmoid 多分类中“**多个类别都高**”问题。

3\. ”人话版“ 总结
============

概念

原理

比喻

**单输出神经元（回归任务）**

输出一个连续数值，直接作为预测结果，不加激活函数

就像填一张表格的一个空，直接写结果

**单输出神经元（二分类任务）**

输出一个概率（sigmoid），表示“是/不是”的可能性

问模型：“这是不是猫？” → 得到 0~1 的答案

**两个输出神经元（回归任务）**

输出两个独立连续数值，每个神经元负责一项预测

原本填一个空，现在要填两个空（比如预测 x, y 坐标）

**两个输出神经元（二分类任务）**

输出两个概率（softmax），表示两类的概率和为1

给猫和狗各发一张票，看看谁票多 → 猫或狗获胜

**多输出神经元（回归任务）**

输出 n 个连续数值，每个神经元预测一个量

一次预测多个空，例如物体的位置、宽度、高度…

**多输出神经元（多分类任务）**

输出 n 个概率（softmax），形成概率分布，和为 1

所有候选类别排队投票，票多的就是预测类别

**sigmoid 多分类问题**

每个输出独立，无法体现“互斥性”，可能出现多个高概率类别

三个人独立问：“像猫吗？”“像狗吗？”“像老虎吗？” → 每个人都说“很像”，模型很困惑

**softmax 多分类问题**

输出互斥概率，提升正确类别概率时自动压低其他类别概率

总票数一定，有人票多，其他人自然票少 → 模型更聪明、更有方向性

**损失函数**

二分类用 BCE，多分类用 Categorical Cross-Entropy

损失就是“罚款”：预测越错 → 罚得越重 → 模型被迫改正