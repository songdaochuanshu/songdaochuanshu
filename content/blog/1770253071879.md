---
layout: post
title: 'AI Agent 框架探秘：拆解 OpenHands（6）--- 事件系统'
date: "2026-02-05T00:57:51Z"
---
AI Agent 框架探秘：拆解 OpenHands（6）--- 事件系统
=====================================

AI Agent 框架探秘：拆解 OpenHands（6）--- 事件系统
=====================================

目录

*   [AI Agent 框架探秘：拆解 OpenHands（6）--- 事件系统](#ai-agent-框架探秘拆解-openhands6----事件系统)
    *   [0x00 概要](#0x00-概要)
    *   [0x01 EventStream](#0x01-eventstream)
        *   [1.1 功能](#11-功能)
        *   [1.2 实现](#12-实现)
        *   [1.3 订阅](#13-订阅)
            *   [1.3.1 订阅者](#131-订阅者)
            *   [1.3.2 分发](#132-分发)
            *   [1.3.3 资源管理](#133-资源管理)
    *   [0x02 Event](#0x02-event)
        *   [2.1 Event](#21-event)
            *   [2.1.1 定义](#211-定义)
            *   [2.1.2 分类](#212-分类)
        *   [2.2 Action](#22-action)
            *   [2.2.1 类型](#221-类型)
            *   [2.2.2 流程](#222-流程)
        *   [2.3 Observation](#23-observation)
            *   [2.3.1 类型](#231-类型)
            *   [2.3.2 流程](#232-流程)
            *   [2.3.3 细节](#233-细节)
        *   [2.4 Environment](#24-environment)
        *   [2.5 AgentThinkAction](#25-agentthinkaction)
            *   [Anthropic Think Tool](#anthropic--think-tool)
                *   [何时使用“思考”工具](#何时使用思考工具)
                *   [最佳实践](#最佳实践)
            *   [代码](#代码)
    *   [0xFF 参考](#0xff-参考)

0x00 概要
-------

如果说 ReAct 范式是代理的 “大脑思维模式”，那么事件驱动架构就是Agent系统的 “神经网络”，它使用了发布-订阅模式，以去中心化的方式协调各组件高效运作，允许组件之间的松耦合通信。整个系统的核心并非僵硬的同步调用，而是一条承载所有关键活动的 “事件流”，系统中的各类核心操作都会被抽象为标准化的 “事件”。

OpenHands 中，EventStream 负责管理session中的触发的事件，以及事件注册函数的回调项目中注册事件回调函数，比如：

*   `Runtime`注册：只接收`Action`的事件与runtime进行交互
*   `AgentController`注册，根据事件更新Agent状态
*   `main`：命令行方式执行agent效果评估时使用，接收agent状态变更事件

因为本系列借鉴的文章过多，可能在参考文献中有遗漏的文章，如果有，还请大家指出。

0x01 EventStream
----------------

要掌握整个程序的运作，首先要理解事件系统的，它就像是程序中的信息高速公路，各个部分通过它来交换信息。OpenHands 事件系统的核心是`EventStream`类（事件流系统），这是一个专门处理事件的系统，它的核心作用是维护了事件队列并支持事件的发布和订阅，管理和分发事件。这种事件驱动的架构使OpenHands能够处理异步操作，并支持多Agent之间的协作。

OpenHands 的代码实现相对简单，关键在于理解其工作原理。主要步骤包括：

*   启动一个循环运行的线程，这个线程负责从事件队列中读取事件，并将它们逐一发送到各个订阅模块的处理队列中。
*   当模块需要订阅事件时，它会调用一个订阅函数`subscribe`，这样事件流就会为该模块维护一个线程池，所有发送到该模块的事件都会被相应的回调函数处理。
*   任何地方需要向事件流中添加事件时，都会调用一个添加事件的函数`add_event`。

事件流的逻辑虽然简单，但确保了程序各部分之间的独立性和通信的一致性。这里的消息都是事件，分为两种类型：

*   `Action`：指需要执行的任务。
*   `Observation`：指环境对任务执行结果的回应。

下图展示了 OpenHands 中 Agent 与环境交互的核心机制：Agent 通过执行动作影响环境，环境通过观察结果反馈给 Agent，Agent 基于这些反馈做出下一步决策。：

*   Agent 决定执行一个动作，通过AgentController和EventStream传到了Runtime。
*   Runtime 在环境中执行该动作
*   环境产生一个观察结果作为执行结果
*   Runtime 捕获这个观察结果并发送到 EventStream（事件流）
*   EventStream 存储观察结果，然后通过AgentController通知Agent
*   Agent 获取更新后的历史记录（包括新的观察结果）
*   Agent 使用观察结果做出下一个决策
*   循环重复进行

### 1.1 功能

EventStream 的功能如下：

*   事件订阅与通知机制。
    *   多订阅者支持：通过EventStreamSubscriber枚举定义了多种订阅者类型。
    *   灵活订阅机制：使用 subscribe 和 unscribe 方法管理订阅关系。
    *   多回调支持：每个订阅者可以注册多个回调函数，通过callback\_id进行区分。
*   事件处理与分发
    *   异步队列处理：使用 queue.Queue和独立线程处理事件队列。
    *   线程池执行：为每个订阅者的回调函数创建独立的线程池，避免阻塞。
    *   顺序分发：按照订阅者ID的排序顺序将事件分发给订阅者。
*   事件存储与持久化
    *   事件ID管理：为每个事件分配唯一ID并维护递增计数器。
    *   时间戳记录：自动为事件添加时间戳。
    *   文件存储：将事件以JSON格式持久化到文件系统。
    *   缓存页面机制：使用页面缓存提高大量事件的读写性能。
*   工作流程：
    *   组件通过subscribe方法注册为事件订阅者。
    *   当有事件发生时，通过add\_event方法添加到事件流。
    *   add\_event方法处理事件ID分配，时间戳设置、持久化存储。
    *   事件被放入处理队列，由独立线程异步分发。
    *   \_process\_queue 分发按照顺序将事件分发给所有订阅者的回调函数。

这种设计使EventStream称为系统中核心的事件中枢，实现了组件间的解耦和异步通信。

### 1.2 实现

EventStream 相关的代码如下：

    class EventStream(EventStore):
        secrets: dict[str, str]
        # For each subscriber ID, there is a map of callback functions - useful
        # when there are multiple listeners
        _subscribers: dict[str, dict[str, Callable]]
        _lock: threading.Lock
        _queue: queue.Queue[Event]
        _queue_thread: threading.Thread
        _queue_loop: asyncio.AbstractEventLoop | None
        _thread_pools: dict[str, dict[str, ThreadPoolExecutor]]
        _thread_loops: dict[str, dict[str, asyncio.AbstractEventLoop]]
        _write_page_cache: list[dict]
    
        def __init__(self, sid: str, file_store: FileStore, user_id: str | None = None):
            super().__init__(sid, file_store, user_id)
            self._stop_flag = threading.Event()
            self._queue: queue.Queue[Event] = queue.Queue()
            self._thread_pools = {}
            self._thread_loops = {}
            self._queue_loop = None
            self._queue_thread = threading.Thread(target=self._run_queue_loop)
            self._queue_thread.daemon = True
            self._queue_thread.start()
            self._subscribers = {}
            self._lock = threading.Lock()
            self.secrets = {}
            self._write_page_cache = []
    
        def _init_thread_loop(self, subscriber_id: str, callback_id: str) -> None:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            if subscriber_id not in self._thread_loops:
                self._thread_loops[subscriber_id] = {}
            self._thread_loops[subscriber_id][callback_id] = loop
    

### 1.3 订阅

任何复杂任务的执行，都离不开对状态变化的精准感知与实时响应。OpenHands 采用观察者模式作为任务调度的核心机制，其设计灵感源自现实世界的 "指挥 - 侦察" 体系 —— 就像战场上的指挥官需要侦察兵实时传递前线动态，框架中的调度中心也依赖分布式的 "状态观察者" 来掌握每一个任务的进展。

具体而言，系统将任务拆解为一系列可监控的 "状态节点"，每个节点都配备专属的观察者实例。当某一节点的状态发生变更（例如从 "待执行" 转为 "执行中"，或从 "成功" 转为 "失败"），观察者会立即触发预设的回调逻辑，通知调度中心进行下一步处理。这种设计带来了两大核心优势：

*   实现了任务调度的 "松耦合"。调度中心无需主动查询每个任务的状态，而是被动接收状态变更通知，这大幅降低了系统各模块间的依赖关系，使得新增任务类型或修改调度逻辑时，无需重构整个框架。
    
*   支持动态优先级调整。当高紧急度的任务插入时，观察者可实时捕获这一事件，触发调度中心的优先级重排机制，暂停低优先级任务的资源分配，确保关键任务优先执行。这种灵活性在多项目并行的场景中尤为重要。
    

在这一架构中，所有组件都扮演着 “生产者” 或 “消费者” 的角色。生产者负责生成事件：代理决策后产生 “动作事件”，运行时环境执行任务后生成 “反馈事件”。消费者则通过订阅特定事件获取信息并响应：运行时订阅 “动作事件” 以执行具体任务，控制器订阅全量事件以维护系统状态。这种基于事件的交互模式，彻底打破了组件间的直接依赖。

事件流像一条环形高架，任何车辆（事件）一旦驶入，就会被并行匝道分流到几座收费站——Session、Runtime、Memory 、 AgentController、......。它们各自领取专属「通行券」（Subscriber 标识），在同一时刻对同一辆车进行安检、收费或记录，而无需等待前一关卡放行。

#### 1.3.1 订阅者

\_subscribers 和 subscriber\_id 起到如下作用。

subscriber\_id 会唯一标识一个订阅者，每个订阅者代表系统的不同组件或者服务。不同的订阅者会处理事件，比如：

*   EventStreamSubscriber.SERVER: 服务器处理
    
*   EventStreamSubscriber.RUNTIME: 运行时处理
    
*   EventStreamSubscriber.AGENT\_CONTROLLER: 代理控制器处理
    

    class EventStreamSubscriber(str, Enum):
        AGENT_CONTROLLER = 'agent_controller'
        RESOLVER = 'openhands_resolver'
        SERVER = 'server'
        RUNTIME = 'runtime'
        MEMORY = 'memory'
        MAIN = 'main'
        TEST = 'test'
    

几个大模块都是在`__init__`函数中完成模块的初始化准备工作，并且向事件流中订阅消息并注册各自模块的消息处理函数。事件回调函数会根据当前的事件进行状态机的状态转移。

*   Runtime 在事件流中订阅 EventStreamSubscriber.RUNTIME，事件回调函数会处理需要runtine处理的action，比如mcp/tool等等。`Runtime`只处理可运行的`Action`事件，执行动作拿到输出`Observation`发送回事件流中`isinstance(event, MCPAction)`执行MCP获取结果其他runtime支持的action则执行获取结果。
*   Memory 在事件流中订阅 EventStreamSubscriber.MEMORY。事件回调函数根据当前的`event`生成一个带`microagent_knowledge`的`RecallObservation`并以`ENVIRONMENT`作为源添加回事件流中，这里的`microagent_knowledge`是一种特定提示词增强的方法。`Memory`只处理`RecallAction`，对于用户首次输入信息则将一些额外的工作空间上下文信息添加到`RecallObservation`发送回事件流中，对于其他非用户首次的输入信息则加入microagent\_knowledge到`RecallObservation`发送回事件流中。
*   AgentController 在事件流中订阅 EventStreamSubscriber.AGENT\_CONTROLLER。`AgentController`作为主要状态管理模块，
    *   根据`Observation`事件进行状态变换
    *   根据`Action`进行状态变换和以下处理：
        *   对于`MessageAction`发送`RecallAction`到事件流中
        *   对于`AgentDelegateAction`做Agent路由（后续机制解读中再详细介绍）
    *   根据当前的`event`判断进行调用`agent.step`
*   run\_controller 在事件流中订阅 EventStreamSubscriber.MAIN。
*   WebSession、ConversationManager 会订阅 EventStreamSubscriber.SERVER。

#### 1.3.2 分发

用户发送消息添加了一条消息到消息流中，系统会依据 subscriber\_id 来决定哪些订阅者应该接收该类事件。这条消息会被广播到每一个消息通道中，通过注册的回调函数可以分析哪些模块对消息进行了处理。

        async def _process_queue(self) -> None:
            while should_continue() and not self._stop_flag.is_set():
                event = None
                try:
                    event = self._queue.get(timeout=0.1)
                except queue.Empty:
                    continue
    
                # pass each event to each callback in order
                for key in sorted(self._subscribers.keys()): # 此处会决定分发到哪里
                    callbacks = self._subscribers[key]
                    # Create a copy of the keys to avoid "dictionary changed size during iteration" error
                    callback_ids = list(callbacks.keys())
                    for callback_id in callback_ids:
                        # Check if callback_id still exists (might have been removed during iteration)
                        if callback_id in callbacks:
                            callback = callbacks[callback_id]
                            pool = self._thread_pools[key][callback_id]
                            future = pool.submit(callback, event)
                            future.add_done_callback(
                                self._make_error_handler(callback_id, key)
                            )
    

#### 1.3.3 资源管理

subscriber\_id 帮助系统管理每个订阅者的资源。

        def _clean_up_subscriber(self, subscriber_id: str, callback_id: str) -> None:
            if subscriber_id not in self._subscribers:
                logger.warning(f'Subscriber not found during cleanup: {subscriber_id}')
                return
            if callback_id not in self._subscribers[subscriber_id]:
                logger.warning(f'Callback not found during cleanup: {callback_id}')
                return
            if (
                subscriber_id in self._thread_loops
                and callback_id in self._thread_loops[subscriber_id]
            ):
                loop = self._thread_loops[subscriber_id][callback_id]
                current_task = asyncio.current_task(loop)
                pending = [
                    task for task in asyncio.all_tasks(loop) if task is not current_task
                ]
                for task in pending:
                    task.cancel()
                try:
                    loop.stop()
                    loop.close()
                except Exception as e:
                    logger.warning(
                        f'Error closing loop for {subscriber_id}/{callback_id}: {e}'
                    )
                del self._thread_loops[subscriber_id][callback_id]
    
            if (
                subscriber_id in self._thread_pools
                and callback_id in self._thread_pools[subscriber_id]
            ):
                pool = self._thread_pools[subscriber_id][callback_id]
                pool.shutdown()
                del self._thread_pools[subscriber_id][callback_id]
    
            del self._subscribers[subscriber_id][callback_id]
    

0x02 Event
----------

在 OpenHands 系统中，Event 是系统中最基本的数据单元，代表系统中发生的各种动作和观察结果（用户输入、智能体文本、工具调用/结果、状态变更请求、控制信号）。所有事件都继承自 Event 基类。表示一个原子性事件。

想象一下，如果我们把`Event Stream`比作一个信息传递的“邮政系统”，那么`Event`就是这个系统中传递的“信件”。在OpenHands中，`Event`是最基本的信息单位，它是一个标准化的数据结构，用来记录系统中发生的任何重要事件。

通过将Agent的思考（由LLM生成的自然语言输出）与系统的实际执行（结构化的Action/Observation）分开，我们解决了意图与执行之间的隔离。LLM负责决定“要做什么”，而Action/Observation则详细说明了“怎样去做”和“结果如何”，这确保了系统的稳定性和可预测性。

### 2.1 Event

#### 2.1.1 定义

每一个 `Event` 对象都携带了一些元数据，就像信封上的信息：

*   `id`: 事件的唯一标识符。
*   `source`: 事件的来源，可以是 `AGENT`、`USER` 或 `ENVIRONMENT`。
*   `timestamp`: 事件发生的时间戳。
*   `cause`: 触发此事件的另一个事件的 `id`。

将系统中的所有互动都抽象为`Event`，我们得到了一种通用的语言。无论是Agent的决策、用户的消息还是环境的反馈，都可以统一处理、存储和分发。特别是`cause`字段，它像一条看不见的线，将Action和它引起的Observation紧密联系起来，形成了ReAct循环的因果链，这对于理解和调试Agent的行为至关重要。

部分代码如下：

    @dataclass
    class Event:
        INVALID_ID = -1
    
        @property
        def message(self) -> str | None:
            if hasattr(self, '_message'):
                msg = getattr(self, '_message')
                return str(msg) if msg is not None else None
            return ''
    
        @property
        def id(self) -> int:
            if hasattr(self, '_id'):
                id_val = getattr(self, '_id')
                return int(id_val) if id_val is not None else Event.INVALID_ID
            return Event.INVALID_ID
    

EventStream 对Event的处理过程为：

*   事件通过 add\_event 方法添加到流中
    
*   系统自动分配 ID 和时间戳
    
*   事件被存储到文件系统
    
*   事件被放入处理队列
    

系统通过 event\_to\_dict 和 event\_from\_dict 函数处理事件的序列化和反序列化，确保事件可以在不同组件间传输和存储。

#### 2.1.2 分类

按照功能分类，事件主要分为两类：

*   第一种是Action（行动），它代表了智能代理想要对环境执行的具体操作。这并不是模糊不清的自然语言描述，而是一个明确的指令。例如，如果代理想要列出某个目录下的所有文件，它会发送一个清晰的指令，如“执行命令'ls -l'”。这样的指令让系统能够准确无误地理解代理的意图并执行相应的操作。
*   第二种是Observation（观察），它代表了智能代理从环境中收集到的信息。这通常是在执行了某个行动之后，系统给予的反馈。例如，如果代理执行了一个列出文件的命令，观察就会包含执行结果的详细信息，如“输出内容为'...'，退出代码为0”。这些信息帮助代理了解其行动的结果，并为下一步行动提供依据。

按来源，事件分类如下：

*   EventSource.AGENT 来自代理的操作和观察结果
*   EventSource.USER 来自用户的操作
*   EventSource.ENVIRONMENT 来自环境的操作和观察结果，这些事件可能包括：
    *   系统状态变化
    *   环境初始化完成通知
    *   运行时状态更新
    *   系统级的观察结果

    class EventSource(str, Enum):
        AGENT = 'agent'
        USER = 'user'
        ENVIRONMENT = 'environment'
    

### 2.2 Action

#### 2.2.1 类型

总共有 13 种不同的 Action 类型。这些 Action 涵盖了代理执行的各种操作，包括文件操作、命令执行、消息传递、状态管理、代理委托等核心功能。

*   基础 Action 类型：
    
    *   Action – 抽象基类
*   具体 Action 实现：
    
    *   AgentDelegateAction – 委托代理执行任务
    *   AgentThinkAction：允许 Agent 添加纯文本到历史记录中的无操作。
    *   AgentFinishAction – 代理完成任务，停止控制循环，允许用户输入新任务。
    *   AgentRejectAction – 代理拒绝任务
    *   AgentRecallAction：搜索记忆（例如向量数据库）。
    *   BrowseInteractiveAction – 交互式浏览
    *   ChangeAgentStateAction – 更改代理状态
    *   CmdRunAction – 在沙盒终端中运行命令
    *   CmdKillAction：杀死后台命令。
    *   FileEditAction – 编辑文件
    *   FileReadAction – 读取文件
    *   IPythonRunCellAction – 交互式执行Python代码块（在Jupyter笔记本中）并接收`CmdOutputObservation`。
    *   MessageAction – 消息操作，表示来自代理或用户的消息
    *   AddTaskAction：向计划中添加子任务。
    *   ModifyTaskAction：更改子任务的状态。
    *   NullAction – 空操作
    *   SystemMessageAction – 系统消息操作
*   特殊 Agent 相关 Action：
    
    *   CondensationAction – 历史压缩操作
    *   CondensationRequestAction – 请求历史压缩操作
    *   RecallAction – 回忆操作

#### 2.2.2 流程

在 OpenHands 的架构中，总体的事件流如下：Agent -> Action -> Runtime-> Observation -> Agent

*   Agent生成Action事件并发送到环境
*   事件通过EventStream传递给Runtime执行
*   Runtime执行相应操作
*   Environment 执行 Action 并生成 Observation 作为响应
*   Observation 被发送回 Agent 作为下一步决策的输入

具体可以参见anthropic的图例。

[Building effective agents](https://www.anthropic.com/engineering/building-effective-agents)

即，为了解决线性工作流的脆弱性，引入了**闭环反馈**机制。现在，任务的每一步不再是一次性的调用，而是一个**可以自我纠错的 Agent**。这种 Agent 循环极大地提升了系统的鲁棒性和最终结果的质量，因为模型有机会从自己的错误中学习和恢复。

因此，我们引入了Observation。

### 2.3 Observation

Action是Agent对环境（Runtime）发出的指令或者操作，Observation是环境对这些操作的响应或者反馈。它代表了环境对 Agent 执行的 Action 的响应，包含了操作结果、环境状态变化等信息，供 Agent 进行下一步决策使用。这种设计符合典型的强化学习和智能体系统的模式，其中 Agent 通过与环境交互（执行 Action 并接收 Observation）来完成任务。

#### 2.3.1 类型

*   外部来源的 Observations，大部分 Observation 对象是从外部环境或运行时系统构建并传入的，这些 Observation 类型都代表了环境的不同状态，例如：
    
    *   命令执行结果（CmdRunObservation）
    *   文件读取结果（FileReadObservation）
    *   IPython 执行结果（IPythonRunCellObservation）
    *   浏览器交互结果（BrowserOutputObservation）
    *   RecallObservation: 记忆检索结果
    *   CmdOutputObservation：命令执行的输出。
    *   BrowserOutputObservation：浏览 URL 后的输出。
    *   FileReadObservation：文件读取操作的输出。
    *   AgentRecallObservation：Agent 回忆操作的输出。
    *   AgentErrorObservation：Agent 执行操作时发生错误的输出。
    
    这些通常由运行时系统创建并通过事件流传递给控制器。
    
*   AgentController 内部构建的 Observations。在 AgentController 类中，有几处会直接构建 Observation 对象：
    
    *   NullObservation：表示无操作或忽略的观察结果，用于过滤不需要处理的事件。
    *   ErrorObservation：表示执行过程中发生的错误，包含错误信息供代理处理。
    *   AgentStateChangedObservation：表示代理状态的变更，如加载、运行、错误等状态。比如，在AgentController的set\_agent\_state\_to函数中，当agent状态发生改变时会创建一个AgentStateChangedObservation事件，并将其来源设置为 EventSource.ENVIRONMENT。

#### 2.3.2 流程

Observation 在 Agent 中的处理流程如下：

    Runtime 执行 Action --> 产生 Observation --> EventStream 发布事件 --> AgentController.on_event 接收 --> 判断是否需要 step --> AgentController._step 处理 --> 调用 Agent.step --> Agent 基于历史事件（包括 Observation）决策
    

具体流程如下：

*   Runtime执行完action之后，生成observation事件。
*   事件通过EventStream.add\_event() 传回Agent，这些 Observations 通过事件流传递，用于更新代理的状态和历史记录。
*   AgentController 订阅 EventStream，在 on\_event() 方法中处理这些事件。
*   Agent基于observation决定下一步动作。

Observation 在 Agent 决策中的作用如下：

*   Agent 状态更新：AgentStateChangedObservation 会更新 Agent 的内部状态；错误 Observation 会触发错误处理流程。
*   历史记录：所有 Observations 都被存储在 State.history 中；Agent 在决策时会回顾整个历史记录，包括所有的 Actions 和 Observations。
*   决策依据：Agent（LLM）通过分析历史中的 Observations 来理解环境状态；例如 CmdOutputObservation 提供了命令执行结果，Agent 据此决定下一步行动。

#### 2.3.3 细节

主要的 Observation 构建位置包括：

*   运行时环境（执行命令、文件操作等）
*   AgentController.\_reset () 方法（构建 ErrorObservation）
*   AgentController.set\_agent\_state\_to () 方法（构建 AgentStateChangedObservation）
*   AgentController.end\_delegate () 方法（构建 AgentDelegateObservation）

### 2.4 Environment

针对 EventSource.ENVIRONMENT，本小节做特殊说明。

EventSource.ENVIRONMENT 通常表示由系统环境或者基础设施生成的事件，可能包括：

*   系统状态变化。
*   环境初始化完成通知。
*   运行时状态更新。
*   系统级的观察结果。

在代码中使用如下。

    # openhands\cli\commands.py
    def handle_exit_command(
        config: OpenHandsConfig,
        event_stream: EventStream,
        usage_metrics: UsageMetrics,
        sid: str,
    ) -> bool:
        if confirm_exit:
            event_stream.add_event(
                ChangeAgentStateAction(AgentState.STOPPED),
                EventSource.ENVIRONMENT,
            )
    
    # 在 Runtime 中        
        def maybe_run_setup_script(self):
            # setup scripts time out after 10 minutes
            action = CmdRunAction(
                f'chmod +x {setup_script} && source {setup_script}',
                blocking=True,
                hidden=True,
            )
            # Add the action to the event stream as an ENVIRONMENT event
            source = EventSource.ENVIRONMENT
            self.event_stream.add_event(action, source)
            
    # 在Memory类 _on_event 方法中，我们可以看到环境返回的 Observation 被重新标记为 Agent 事件发送到 UI:python
    async def _on_event(self, event: Event):   
        self.event_stream.add_event(workspace_obs, EventSource.ENVIRONMENT)
        
    # 在 AgentSession 中
                        self.event_stream.add_event(
                            ChangeAgentStateAction(AgentState.RUNNING),
                            EventSource.ENVIRONMENT,
                        )
    
    # 在 WebSession 中
            self.agent_session.event_stream.add_event(
                AgentStateChangedObservation('', AgentState.LOADING),
                EventSource.ENVIRONMENT,
            )
        
    # AgentController 中
        async def set_agent_state_to(self, new_state: AgentState) -> None:
            self.event_stream.add_event(
                AgentStateChangedObservation('', self.state.agent_state, reason),
                EventSource.ENVIRONMENT,
            )
    

虽然Runtime也会产生一些观察结果，但具体是 EventSource.ENVIRONMENT 或者 EventSource.AGENT，取决于上下文。

### 2.5 AgentThinkAction

我们来看看 AgentThinkAction，该Action允许 Agent 添加纯文本到历史记录中的无操作。

                # ================================================
                # AgentThinkAction
                # ================================================
                elif tool_call.function.name == ThinkTool['function']['name']:
                    action = AgentThinkAction(thought=arguments.get('thought', ''))
    

ThinkTool 是对Anthropic Think Tool设计理念的模仿或再实现。

#### Anthropic Think Tool

Anthropic Think Tool在执行复杂任务时为其创建专门用于结构化思考的空间。Think Tool发生在AI开始响应之后，像是在工作过程中主动停下来整理思路。通过“think”工具，Anthropic 赋予 Claude 在得出最终答案的过程中插入一个额外思考步骤的能力——该步骤拥有自己专属的思考空间，用以判断当前是否已掌握继续推进所需的全部信息。这一机制在执行长链条的工具调用或与用户进行多轮复杂对话时尤为有用。

尽管听起来与延伸思考（[extended thinking](https://www.anthropic.com/research/visible-extended-thinking)）类似，但二者概念不同：延伸思考发生在 Claude 开始生成回复**之前**，让模型深度思考并迭代方案；而“思考”工具用于 Claude**已开始生成回复后**，在遇到长链条工具调用或长对话时，主动暂停并思考是否已掌握足够信息。它尤其适用于模型无法仅凭用户查询获得全部信息，而需处理外部信息（如工具返回结果）的场景。

相比延伸思考，“思考”工具所进行的推理范围更窄，更聚焦于新发现的信息。

Anthropic 推荐：

*   对于非顺序工具调用或简单指令遵循，优先使用延伸思考；
*   对于复杂工具链、需仔细分析工具输出、策略密集型环境或代价高昂的序列决策，使用“思考”工具。

##### 何时使用“思考”工具

**适用场景**：

*   需深度分析前序工具输出，可能回溯方案；
*   策略密集型环境，需验证合规性；
*   序列决策，每步依赖前序结果且错误代价高。

**不适用场景**：

*   单次或并行工具调用即可完成任务；
*   约束简单，默认行为已足够。

##### 最佳实践

1.  **领域示例驱动的提示**  
    给出何时、如何调用思考工具，并提供贴合业务的推理示例（见原文航空域提示）。
2.  **将复杂指令放入系统提示**  
    长且复杂的思考指南放在系统提示而非工具描述中，效果更佳。
3.  **持续监控与迭代**  
    观察 Claude 实际调用模式，针对性调整提示，以强化有效思考路径。

#### 代码

ThinkTool 对应的代码如下。让模型在“内部独白”阶段把思考过程写入日志，不触发外部调用。

    _THINK_DESCRIPTION = """Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed.
    
    Common use cases:
    1. When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.
    2. After receiving test results, use this tool to brainstorm ways to fix failing tests.
    3. When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.
    4. When designing a new feature, use this tool to think through architecture decisions and implementation details.
    5. When debugging a complex issue, use this tool to organize your thoughts and hypotheses.
    
    The tool simply logs your thought process for better transparency and does not execute any code or make changes."""
    
    ThinkTool = ChatCompletionToolParam(
        type='function',
        function=ChatCompletionToolParamFunctionChunk(
            name='think',
            description=_THINK_DESCRIPTION,
            parameters={
                'type': 'object',
                'properties': {
                    'thought': {'type': 'string', 'description': 'The thought to log.'},
                },
                'required': ['thought'],
            },
        ),
    )
    
    class ThinkExecutor(ToolExecutor):
        def __call__(
            self,
            _: ThinkAction,
            conversation: "BaseConversation | None" = None,  # noqa: ARG002
        ) -> ThinkObservation:
            return ThinkObservation.from_text(text="Your thought has been logged.")
    
    
    class ThinkTool(ToolDefinition[ThinkAction, ThinkObservation]):
        """Tool for logging thoughts without making changes."""
    
        @classmethod
        def create(
            cls,
            conv_state: "ConversationState | None" = None,  # noqa: ARG003
            **params,
        ) -> Sequence[Self]:
            """Create ThinkTool instance.
    
            Args:
                conv_state: Optional conversation state (not used by ThinkTool).
                **params: Additional parameters (none supported).
    
            Returns:
                A sequence containing a single ThinkTool instance.
    
            Raises:
                ValueError: If any parameters are provided.
            """
            if params:
                raise ValueError("ThinkTool doesn't accept parameters")
            return [
                cls(
                    description=THINK_DESCRIPTION,
                    action_type=ThinkAction,
                    observation_type=ThinkObservation,
                    executor=ThinkExecutor(),
                    annotations=ToolAnnotations(
                        readOnlyHint=True,
                        destructiveHint=False,
                        idempotentHint=True,
                        openWorldHint=False,
                    ),
                )
            ]
    

0xFF 参考
-------

[https://docs.all-hands.dev/openhands/usage/architecture/backend](https://docs.all-hands.dev/openhands/usage/architecture/backend)

[当AI Agent从“玩具”走向“工具”，我们该关注什么？Openhands架构解析【第二篇：Agent 相关核心概念】](https://zhuanlan.zhihu.com/p/1936485868761257658) [克里](https://www.zhihu.com/people/dreamrenderx)

[当AI Agent从“玩具”走向“工具”，我们该关注什么？Openhands架构解析【第一篇：系列导读】](https://zhuanlan.zhihu.com/p/1936175201323825087) [克里](https://www.zhihu.com/people/dreamrenderx)

[Coding Agent之Openhands解析(含代码)](https://zhuanlan.zhihu.com/p/1940436682949244630) [Arrow](https://www.zhihu.com/people/wu-long-ming-cha-56)

[OpenHands 源码解读](https://zhuanlan.zhihu.com/p/1940824548485347192) [一力辉](https://www.zhihu.com/people/xiao-hui-66-72)

[Anthropic 官方教程：为 Agent 设计高效工具的最佳实践](https://zhuanlan.zhihu.com/p/1949931198932586886)

[The "think" tool: Enabling Claude to stop and think in complex tool use situations](https://www.anthropic.com/engineering/claude-think-tool)