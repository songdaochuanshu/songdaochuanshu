---
layout: post
title: 'CommonLang3-使用介绍'
date: "2025-02-19T00:36:17Z"
---
CommonLang3-使用介绍
================

**学习要带着目的，参照现实问题**

本次目标：

*   了解 CommonsLang3 API 文档，找对路后以后开发直接查询 API 文档，摈弃盲目的百度
*   掌握基础的字符串、日期、数值等工具方法，初步替代手搓的工具类

为什么要用 CommonsLang3？

*   比自己手写的工具方法安全性高，不易出 Bug
*   第三方工具包，便于携带，开箱即用，一通百通，再也不用收集各种工具方法了

介绍
--

[Common3Lang3官网](https://commons.apache.org/proper/commons-lang/index.html)

> The standard Java libraries fail to provide enough methods for manipulation of its core classes. Apache Commons Lang provides these extra methods.  
> Apache Commons Lang provides a host of helper utilities for the java.lang API, notably String manipulation methods, basic numerical methods, object reflection, concurrency, creation and serialization and System properties. Additionally it contains basic enhancements to java.util.Date and a series of utilities dedicated to help with building methods, such as hashCode, toString and equals.

意：Java 标准库没有提供足够的方法去操作核心类，于是 Apache Commons Lang 就补充了这些方法。  
Apache Commons Lang 为 java.lang 中的核心类提供了一系列辅助工具 API，尤其是字符串操作方法，基础数字方法，对象反射，并发，创建和序列化以及系统属性。另外它还包括对 java.util.Date 的基础增强，还有一系列实用工具用来辅助 building 方法，比如 hashCode，toString 和 equals。

_CommonsLang3 和 CommonsLang 的区别：Lang3 可以看做是 Lang 的高阶版本，二者同源不同库，使用上并不兼容。建议使用 Lang3 库_

[CommonsLang3 API 文档](https://commons.apache.org/proper/commons-lang/javadocs/api-release/index.html)

> 都是有些简单的英文，再加上翻译软件，有点耐心都能看懂。  
> ![](https://img2024.cnblogs.com/blog/753478/202502/753478-20250218113125649-187478526.png)

字符串
---

文档中写的非常非常非常清楚，一定要看文档，看源码也行！！

日期实践
----

    String[] datePatterns = new String[] {"yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd"};
    String dateStr = "2025-02-18 11:06:20";
    Date date = DateUtils.parseDate(dateStr, Locale.CHINESE, datePatterns);
    log.info("字符串转为日期:{}", date);
    
    String str = DateFormatUtils.format(date, datePatterns[0]);
    log.info("日期转为字符串:{}", str);
    

对象工具类
-----

在实际开发中，有大量嵌套属性的判空操作，比如以下：

    Employee employee = this.getEmployee();
    // 如果员工不空，且员工所属部门也不空，则 do something
    if (employee != null && employee.getDepartment() != null) {
    	log.info("!=null：all not null");
    }
    // 使用 Objects 
    if (Objects.nonNull(employee) && Objects.nonNull(employee.getDepartment())) {
    	log.info("Objects.nonNull：all not null");
    }
    // 使用 CommangsLang3 ObjectUitis，等同于以上两种写法，但是更加简洁明了
    if (ObjectUtils.allNotNull(employee, employee.getDepartment())) {
    	log.info("ObjectUtils.allNotNull：all not null");
    }
    

还有大量设置默认值的操作，比如【如果为空，则设置默认值】

     Employee emp = new Employee("张三");
    //emp.setDepartment(new Department("测试"));
    // 条件判断：如果员工对象部门为空，则默认创建一个部门
    Department depart0 = emp.getDepartment();
    if (Objects.isNull(depart0)) {
    	depart0 = new Department("开发0");
    }
    log.info("部门: {}", depart0.getName());
    // Optional 新写法1
    Department depart1 = Optional.ofNullable(emp.getDepartment()).orElse(new Department("开发1"));
    log.info("部门: {}", depart1.getName());
    // Optional 新写法2
    Department depart2 = Optional.ofNullable(emp.getDepartment()).orElseGet(() -> new Department("开发2"));
    log.info("部门: {}", depart2.getName());
    // Lang3 defaultIfNull 等同于 Optional 新写法1
    Department depart3 = ObjectUtils.defaultIfNull(emp.getDepartment(), new Department("开发3"));
    log.info("部门: {}", depart3.getName());
    // Lang3 getIfNull 等同于 Optional 新写法2
    Department depart4 = ObjectUtils.getIfNull(emp.getDepartment(), () -> new Department("开发4"));
    log.info("部门: {}", depart4.getName());
    

*   orElse 无论 Optional 的值是否为 null，都会计算 default 的值。
*   orElseGet 只有当 Optional 的值为 null 时，才会去计算函数表达式的值，类似于懒加载，功能上相当于短路。  
    所以建议使用 Optional.orElseGet() 或 ObjectUtils.getIfNull() 方法。

**StringUtils 中也有 defulatIfEmpty 这种带有简单逻辑判断的方法，这或许也是一种规律，将简单判断/逻辑封装为方法**