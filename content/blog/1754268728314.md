---
layout: post
title: 'MySQL 24 MySQL是怎么保证主备一致的？'
date: "2025-08-04T00:52:08Z"
---
MySQL 24 MySQL是怎么保证主备一致的？
=========================

### MySQL主备的基本原理

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727194947084-1614727565.png)

状态1中，客户端读写都是直接访问节点A，节点B只是将节点A的更新同步过来在本地执行。当需要主备切换时，就变成状态2。

状态1中没有直接访问节点B，但仍然建议把节点B设置成只读模式，原因如下：

*   有时一些运营类的查询语句会被放到备库上查看，设置为只读可以防止误操作；
    
*   防止切换逻辑出现双写等bug，造成主备不一致；
    
*   可以用readonly状态来判断节点角色。
    

把备库设置成只读，还怎么跟主库保持同步更新呢？这是由于readonly设置对超级权限的用户是无效的，而对于同步更新的线程，就拥有超级权限。

而一个update语句在节点A执行，然后同步到节点B的完整流程如下：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195207164-868764597.png)

主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。备库和主库之间维持了一个长连接，主库内部有一个线程专门服务该长连接。一个事务日志同步的完整过程为：

*   备库B通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，位置包含文件名和日志偏移量；
    
*   备考B上执行start slave，会启动两个线程io\_thread和sql\_thread，其中io\_thread负责与主库建立连接；
    
*   主库A校验完用户名、密码后，按照备库B传过来的位置，从本地读取binlog发给B；
    
*   备库B拿到binlog后，写到本地未见，称为中转日志relay log；
    
*   sql\_thread读取中转日志，解析出日志里的命令并执行。
    

由于多线程复制方案的引入，sql\_thread后来实际上演化成为了多个线程。

分析完长连接的逻辑，再来看一个问题：binlog里面到底是什么内容，为什么备库拿过去可以直接执行。

### binlog的三种格式对比

为了方便描述binlog的三种格式，以如下数据为例：

    mysql> CREATE TABLE `t` (
      `id` int(11) NOT NULL,
      `a` int(11) DEFAULT NULL,
      `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
      PRIMARY KEY (`id`),
      KEY `a` (`a`),
      KEY `t_modified`(`t_modified`)
    ) ENGINE=InnoDB;
    
    insert into t values(1,1,'2018-11-13');
    insert into t values(2,2,'2018-11-12');
    insert into t values(3,3,'2018-11-11');
    insert into t values(4,4,'2018-11-10');
    insert into t values(5,5,'2018-11-09');
    

假设要在表中删除一行：

    mysql> delete from t /*comment*/  where a>=4 and t_modified<='2018-11-10' limit 1;
    

可以用下面的命令查看binlog中的内容：

    mysql> show binlog events in 'master.000001';
    

当`binlog_format=statement`，binlog里记录的就是SQL语句的原文。statement格式的binlog内容：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195251186-459672322.png)

*   第二行的begin与第四行的commit对应，表示中间是一个事务；
    
*   第三行是真实执行的语句。在真实执行的delete命令前，MySQL根据当前要操作的表所在的数据库，自行添加了一个命令，这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能正确更新到test库的表t。
    

这条delete命令的执行效果图：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195318541-1988315615.png)

产生了一个warning，原因是当前binlog设置的是statement格式，且语句中有limit，因此该命令可能是unsafe的。具体来说，delete带limit，可能出现主备数据不一致情况，在上面的例子中：

*   如果delete用的是索引a，那么会根据索引a找到第一个满足条件的行`a=4`；
    
*   如果delete用的是索引t\_modified，那么删除的就是`t_modified='2018-11-09'`，是`a=5`。
    

由于statement格式下binlog记录语句原文，因此可能出现：主库用的是索引a，备库使用的是索引t\_modified，所以MySQL认为这样写是有风险的。

如果将binlog格式改为row，此时binlog内容：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195346791-88332019.png)

这时没有了sql原文，而是替换成了两个event：

*   Table\_map event：说明接下来要操作的表是test库的表t；
    
*   Delete\_rows event：用于定义删除的行为。
    

row格式下，通过binlog还看不到详细信息，还需要借助mysqlbinlog工具解析和查看binlog中的内容。从上面的binlog中可以看出，事务的binlog从8900位置开始，因此可以用start-position参数指定从该位置的日志开始解析：

    mysqlbinlog  -vv data/master.000001 --start-position=8900;
    

解析出的binlog详细内容：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195415675-1407175505.png)

对于解析结果：

*   server id 1，表示事务是在`server_id=1`库上执行的；
    
*   Table\_map event显示了接下来要打开的表，map到数字226。当前SQL语句只操作了一张表，如果要操作多张表，那么每个表都有一个对应的Table\_map event，都会map到一个单独的数字，用于区分对不同表的操作；
    
*   `@1=4, @2=4`这些表示各个字段的值，即`id=4,a=4`；
    
*   Xid event，用于表示事务被正确提交。
    

可以看到，binlog使用row格式时，会记录真实删除行的主键id，这样binlog传到备库时，肯定会删除`id=4`的行，不会有主备删除不同行的问题。

### 为什么会有mixed格式的binlog？

首先可以根据上面的分析来推一下：

*   因为某些statement格式的binlog可能导致主备不一致，所以要使用row格式；
    
*   row格式缺点是很占空间，比如delete语句删除10万行数据，用statement就是一个SQL语句，而row格式需要把10万条记录都写到binlog，这样会占用更大的空间，同时写binlog会耗费IO资源；
    
*   因此MySQL取折中方案，即mixed格式，MySQL自己判断SQL语句是否可能引起主备不一致，如果可能就用row，否则用statement。
    

可以看出，如果MySQL设置binlog为statement格式，基本可以认为是一个不合理的设置，至少可以设置为mixed。不过现在越来越多的场景要求把MySQL的binlog设置为row，理由有很多，其中有一点就是恢复数据。

从增删改来看数据恢复的问题：

*   delete语句，row格式的binlog会把删掉的行的整行信息保存起来，如果发现删错数据，可以直接把binlog中记录的delete语句转成insert，将错删的数据插入；
    
*   insert语句，row格式的binlog会记录所有字段信息，可以转成delete删掉误插入的数据；
    
*   update语句，row格式的binlog会记录修改前和修改后的整行数据，如果误执行，只需要把前后两行消息对调一下，再去数据库里执行。
    

### 循环复制问题

最开始的图中MySQL主备切换流程是M-S结构，实际生产上使用比较多的是双M结构：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195458326-1404936057.png)

对比两图，可以发现双M结构和M-S结构区别只是多了一条线，即节点A和B之间总是互为主备关系，这样切换时就不用再修改主备关系。

双M结构有一个问题。如果业务逻辑在节点A上更新一条语句，再把生成的binlog发给节点B，节点B执行完这条更新语句后也会生成binlog，会发送给节点A，相当于节点A又把节点B新生成的binlog拿过来执行了一次，然后两个节点会不断循环执行这个更新语句，即循环复制。

循环复制的解决：

*   规定两个库的server id必须不同，如果相同则它们之间不能设为主备关系；
    
*   一个备库在重放binlog的过程中，会生成与原binlog的server id相同的新binlog；
    
*   每个库在收到从自己的主库发过来的日志后，先判断server id，如果和自己的相同，表示该日志由自己生成，直接丢弃。
    

按这个逻辑，如果设置了双M结构，日志的执行流就为：

*   从节点A更新的事务，binlog里面记的都是A的server id；
    
*   传到节点B执行一次以后，节点B生成的binlog的server id也是A的server id；
    
*   再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志，死循环在这里就断掉了。