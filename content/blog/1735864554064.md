---
layout: post
title: 'gRPC编译与字段编号的细节探讨'
date: "2025-01-03T00:35:54Z"
---
gRPC编译与字段编号的细节探讨
================

上次我们专门通过一个简单的HelloWorld示例来了解了gRPC的基本概念和使用方法。今天，我们将继续深入探讨gRPC，重点讨论一些在实际应用中需要特别注意的要点。实际上，gRPC的核心目标是简化远程调用的过程，它通过定义清晰的接口，利用Protocol Buffers（简称proto协议）来生成不同编程语言的接口代码，从而实现跨语言、高效的通信。

在回顾了gRPC的基本工作原理之后，我们今天将进一步扩展视野，继续探讨一些更细节的部分。

gRPC
====

是否会覆盖
-----

今天，我特别添加了一个新的测试接口，目的是测试在进行重新编译时，系统是否会丢失之前定义的接口和相关业务逻辑。为了简化说明，实体类部分就不再重新编写了，它与之前定义的内容完全一致。具体细节请见下图：

![image](https://img2024.cnblogs.com/blog/1423484/202412/1423484-20241230212432039-951733750.png)

在我重新进行编译后，我发现除了这个特定的类需要单独手动编写之外，其他的内容都已经自动生成完毕。这意味着，我们不需要担心会因编译过程而导致已有内容被直接覆盖掉。

实际上，Maven 工具本身也可以配置，以控制在执行时是否删除目录中的某些内容并重新生成。虽然这里不作详细讨论，但从正常业务操作的角度来看，我们通常都不希望自己辛苦编写的代码在没有任何警告的情况下，因他人的误操作或一键执行而被完全删除。

![image](https://img2024.cnblogs.com/blog/1423484/202412/1423484-20241230212437106-515669221.png)

字段编号有何用
-------

在我们讨论实体类消息体中为何会出现数字时，首先要明确的是，虽然我们在定义字段时已经给它们起了具体的名字，但这远不够。特别是在使用 gRPC 进行服务通信时，你需要从传统的 JSON 格式（键值对结构）中跳脱出来，重新理解字段的表示方式。

在 gRPC 中，数据是通过 Protocol Buffers（Protobuf） 进行序列化和传输的，而 Protobuf 的一个关键概念就是 字段编号（Field Numbers）。如图所示：

![image](https://img2024.cnblogs.com/blog/1423484/202412/1423484-20241230212442491-726950642.png)

其实作用最主要的就是序列化和反序列化，当 Protobuf 序列化消息时，它并不直接存储字段名（如 name、age 等），而是存储字段编号和字段值的对应关系。这样，这使得数据传输时比使用 JSON 或 XML 更加紧凑。

我们简单看下后台输出的日志，你大概就能理解了，如图所示：

![image](https://img2024.cnblogs.com/blog/1423484/202412/1423484-20241230212446386-893934506.png)

我们把这些字节全拿出来看下。比如：

1.  **00 00 00 00**：这些是四个字节，通常是用来表示某个字段的填充数据，可能是某种标识符、长度或者预留字节。
2.  **07**：这个字节通常表示某种数据的长度或其他编码标识。
3.  **0a**：这个字节也有可能是长度或某种控制符号。
4.  **05**：又是一个字节，通常也表示控制信息。
5.  **57 6f 72 6c 64**：这些字节代表的是ASCII编码字符。它们对应的字符为：
    *   `57` → 'W'
    *   `6f` → 'o'
    *   `72` → 'r'
    *   `6c` → 'l'
    *   `64` → 'd'

因此，`57 6f 72 6c 64` 对应的字符串是 "World"。

同理，我们看下返回的数据也是一样的字节。然后反序列化成我们所需要的字段值，具体的我们就不探讨了。了解下他的优点即可。

这串字节 `00000000150a137869616f79753a2048656c6c6f20576f726c64` 可以被解释为：

*   一些前导字节（如 `00 00 00 00` 和 `15 0a 13`）可能是标识符、长度字段或者控制信息。
*   后面部分解码成了字符串 `"xiaoyu: Hello World"`

还有一个需要注意的就是，既然他有字段编号，所以你不要轻易去修改编号，就算不用了，也要去用新的编号进行标识处理。这是因为如果有老客户端仍在继续使用，会导致无法正确解析新版消息，会出现兼容性错误。

总结
==

通过今天的探讨，我们进一步加深了对gRPC和Protocol Buffers的理解，特别是在实际应用中可能遇到的一些细节和注意事项。我们了解了在重新编译时，系统如何自动生成接口代码并避免覆盖已有内容，从而减少了手动操作的风险。同时，深入探讨了Protocol Buffers中的字段编号机制，它不仅有助于数据的高效序列化和传输，也在版本兼容性上起到了至关重要的作用。尽管字段名称对开发者来说更具可读性，但最终传输的数据依赖于字段编号，而对编号的管理和修改必须小心谨慎，以确保不同版本之间的兼容性。

希望通过今天的讲解，大家能更好地理解gRPC的应用场景和实际操作中的细节。

* * *

我是努力的小雨，一名 Java 服务端码农，潜心研究着 AI 技术的奥秘。我热爱技术交流与分享，对开源社区充满热情。同时也是一位腾讯云创作之星、阿里云专家博主、华为云云享专家、掘金优秀作者。

💡 我将不吝分享我在技术道路上的个人探索与经验，希望能为你的学习与成长带来一些启发与帮助。

🌟 欢迎关注努力的小雨！🌟