---
layout: post
title: '用低成本FPGA实现FSMC接口的多串口（UART）缓冲控制器'
date: "2025-10-09T00:39:15Z"
---
用低成本FPGA实现FSMC接口的多串口（UART）缓冲控制器
===============================

![用低成本FPGA实现FSMC接口的多串口（UART）缓冲控制器](https://img2024.cnblogs.com/blog/1380455/202510/1380455-20251008150938800-1190691607.png) 介绍了基于低成本FPGA/CPLD的多路UART控制器的实现方法，为增加其实用性，该控制器具备FSMC（或EXMC）接口，以及可配置深度的接收和发送FIFO缓冲。

尽管目前工业以太网已经相当普及，但在工控领域仍然存在大量使用UART通过RS485和RS422组网的设备和控制器，导致含有多UART的嵌入式系统仍有较大市场需求。意法半导体和兆易创新等主流微控制器（MCU）厂商都有10个以上UART的器件，但在很多场景下仍然无法覆盖所有应用场景。另外，对于主控单元是微处理器（MPU，能运行Linux）的嵌入式系统，UART口一般较少，就不得不使用16C550/16C554这类扩展芯片来实现多UART。

用FPGA来实现可定制的多UART口扩展是一种不错的解决方案。其中，在Zynq上通过AXI总线扩展多个UART难度不高，但限制了主控单元的使用，且成本较高。我趁着这个国庆长假在低成本的国产FPGA/CPLD上实现了一种基于FSMC接口（GD32上称为EXMC接口）的多串口控制器，适用于所有兼容ISA总线接口的嵌入式MCU/MPU系统。可以根据应用场景任意裁剪UART的个数、FIFO缓冲的深度。

以下原创内容欢迎网友转载，但请注明出处： [https://www.cnblogs.com/helesheng](https://www.cnblogs.com/helesheng)

一、整体结构
------

我设计的多UART控制器采用外设地址映射模式思路，FPGA模拟成一个8位的FSMC设备和处理器（如STM32）通信。其中，每个UART口占用数据接收寄存器地址（UARTx\_RX\_Reg\_Addr，小写x可以代表任意串口编号的阿拉伯数字，下同）、接收缓冲长度寄存器地址（UART1\_RX\_LEN\_Reg\_Addr）、数据发送寄存器地址（UARTx\_TX\_Reg\_Addr）以及发送缓冲长度寄存器地址（UARTx\_TX\_LEN\_Reg\_Addr）共四个字节的地址；另外，每个UART口还占用了发送状态寄存器（STAT\_TX\_Addr）和接收状态寄存器（STAT\_RX\_Addr）中的各一个位，来表示该UART当前是否处于发送或接收状态。

其中，每个UART的数据发送和接收寄存器在逻辑概念上虽然只占用的一个字节的地址，但在物理上却映射到一组接收FIFO和发送FIFO的一个端口。以接收FIFO为例：每当UART口收到一个字节的数据A时，FPGA就会将该数据压入接收FIFO中，而处理器也不需要立即将刚收到的数据读走，因为即使处理器没有及时地在下次收到数据B之前读走该数据，FIFO还是能够缓存这个新数据。而当处理器腾出时间处理该UART口的接收数据时，还是能从同一个地址（UARTx\_RX\_Reg\_Addr）按照收到这些数据的顺序A->B->C....依次读取他们。这种方式的优势有二：

1、相对于嵌入式处理器，UART属于低速设备，对于接收而言，增加了FIFO缓冲的UART控制器无需处理器过于频繁的查询，只需要间隔相当一段时间查看一下FIFO中是否缓存了数据即可；对于发送而言，增加了FIFO缓冲的控制器也可以一次缓冲多个需要发送的字节，降低处理器关注的频率。

2、发送和接收缓冲分别都只占用一个字节的地址空间，即可实现任意长度数据包的收发。当然，代价是处理器只能顺序访问缓冲区，而无法实现随机访问，但这对于需要严格按顺序读写的UART口而言，这并不是问题。

下面的代码是我在作为处理器的STM32代码中定义的UART相关寄存器地址：

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

 1 #define STAT\_RX\_Addr    ((unsigned int)0x60000000)   //FPGA模拟的uart口接收状态寄存器地址
 2 #define STAT\_TX\_Addr    ((unsigned int)0x60010000)   //FPGA模拟的uart口接发送态寄存器地址
 3 #define UART1\_RX\_Reg\_Addr    ((unsigned int)0x60020000)   //fpga模拟的uart1口接收数据地址
 4 #define UART1\_TX\_Reg\_Addr    ((unsigned int)0x60030000)   //fpga模拟的uart1口发送数据地址
 5 #define UART1\_RX\_LEN\_Reg\_Addr    ((unsigned int)0x60040000)   //fpga模拟的uart1口接收缓冲区中数据长度的地址
 6 #define UART1\_TX\_LEN\_Reg\_Addr    ((unsigned int)0x60050000)   //fpga模拟的uart1口发送缓冲区中数据长度的地址
 7 #define UART2\_RX\_Reg\_Addr    ((unsigned int)0x60060000)   //fpga模拟的uart2口接收数据地址
 8 #define UART2\_TX\_Reg\_Addr    ((unsigned int)0x60070000)   //fpga模拟的uart2口发送数据地址
 9 #define UART2\_RX\_LEN\_Reg\_Addr    ((unsigned int)0x60080000)   //fpga模拟的uart2口接收缓冲区中数据长度的地址
10 #define UART2\_TX\_LEN\_Reg\_Addr    ((unsigned int)0x60090000)   //fpga模拟的uart2口发送缓冲区中数据长度的地址

UART寄存器地址（STM32侧）

FPGA代码中定义的UART相关寄存器地址：  

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

 1 // 定义地址
 2 parameter ADDR\_RX\_STATE = 5'd0;          //状态寄存器高字节地址，对应ARM地址0x60000000
 3 parameter ADDR\_TX\_STATE = 5'd1;          //状态寄存器低字节地址，对应ARM地址0x60010000
 4 parameter ADDR\_UART1\_RX = 5'd2;          //uart1接收数据端口地址，对应ARM地址0x60020000
 5 parameter ADDR\_UART1\_TX = 5'd3;          //uart1发送数据端口地址，对应ARM地址0x60030000                     
 6 parameter ADDR\_UART1\_RX\_LEN = 5'd4;          //uart1接收缓冲中待读取数据数量的读取端口地址，对应ARM地址0x60040000 
 7 parameter ADDR\_UART1\_TX\_LEN = 5'd5;          //uart1发送缓冲中待发送数据数量的读取端口地址，对应ARM地址0x60050000 
 8 parameter ADDR\_UART2\_RX = 5'd6;          //uart2接收数据端口地址，对应ARM地址0x60060000
 9 parameter ADDR\_UART2\_TX = 5'd7;          //uart2发送数据端口地址，对应ARM地址0x60070000 
10 parameter ADDR\_UART2\_RX\_LEN = 5'd8;          //uart1接收缓冲中待读取数据数量的读取端口地址，对应ARM地址0x60080000 
11 parameter ADDR\_UART2\_TX\_LEN = 5'd9;          //uart1发送缓冲中待发送数据数量的读取端口地址，对应ARM地址0x60090000 

UART寄存器地址（FPGA侧）

二、FPGA中八位并行接口（FSMC）设备端的实现
-------------------------

### 1、读写时钟控制信号的产生

下图是我在STM32手册中截取的配置成SRAM的读写模式时FSMC接口的读写时序。

![image](https://img2024.cnblogs.com/blog/1380455/202510/1380455-20251007085056742-383596756.png)

图1 FSMC(SRAM模式)读时序

![image](https://img2024.cnblogs.com/blog/1380455/202510/1380455-20251007085241499-698552043.png)

图2 FSMC(SRAM模式)写时序

 对于100pin的STM32而言，并不拥有全部26根地址线，而只有A16-A23共8根，以及一根自动产生的片选线NCE1/NCE2（控制地址范围达到全部4G寻址空间的四分之一）。

FPGA侧为了实现FSMC的设备端接口，核心要求是能够在写使能NWE和读使能NOE控制下在FPGA中实现数据的锁存和输出。有两种合理的技术路线：其一，使用NWE或NOE作为数据寄存器的锁存时钟；其二，用FPGA系统时钟作为数据寄存器的锁存时钟，NWE或NOE作锁存器读写的使能信号。

第一种思路最直接，但问题是缓冲FIFO的存储时钟只能由STM32的读、写动作产生，但一般FIFO IP在真正进行读写之前也需要时钟信号来完成初始化。如果采用第一种技术路线，势必需要STM32作几组无意义的“空读写”，以产生必要的初始化时钟。另外，也可能由于STM32到FPGA之间的PCB走线造成时序约束难度的增加，并提升外部高频信号干扰的可能，因此我没有选择这条技术路线。第二种思路的难点在于NWE或NOE信号低电平期间，可能产生多个FPGA的系统时钟，从而造成对同字节数据被缓冲FIFO看做多个数据，进而被多次读或写。

为实现第一种技术路线，我用如下代码将长度不确定的NWE或NOE信号转换为一个长度为1个系统时钟的正脉冲作为缓冲FIFO的读写使能控制信号。完美的解决了单次STM32读写造成多次缓冲FIFO读写的问题。

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

 1 /////读端口控制线//////
 2 assign en\_fsmc\_oe = (fsmc\_a\[21\] == 1'b0) && (rd\_n == 1'b0) && (cs\_n == 1'b0);
 3 wire rd\_uart1\_rx\_fifo;//用于mcu读取接收缓冲fifo的使能信号
 4 assign rd\_uart1\_rx\_fifo = (fsmc\_a\[20:16\] == ADDR\_UART1\_RX) && en\_fsmc\_oe;//MCU发出的读取uart1接收数据的使能信号
 5 reg\[1:0\] prv\_rd\_uart\_rx\_fifo\_reg;
 6 always @(posedge clk\_in\_50 or negedge rst\_n)//串口模块接收标志信号是个正脉冲，在下降沿数据才完全准备好。对其进行延迟
 7 begin
 8     if(!rst\_n)
 9         prv\_rd\_uart1\_rx\_fifo\_reg\[1:0\] <= 2'b00;
10     else begin
11         prv\_rd\_uart1\_rx\_fifo\_reg\[1:0\] <= {prv\_rd\_uart1\_rx\_fifo\_reg\[0\] , rd\_uart1\_rx\_fifo};
12     end
13 end
14 wire rd\_uart1\_rx\_fifo\_1ck;//MCU发出的读取uart接收数据的信号的第一个主频周期产生一个主频周期的高电平
15 assign rd\_uart1\_rx\_fifo\_1ck = prv\_rd\_uart1\_rx\_fifo\_reg\[0\] & (prv\_rd\_uart1\_rx\_fifo\_reg\[1\] ^ prv\_rd\_uart1\_rx\_fifo\_reg\[0\]);

读端口使能控制信号rd\_uart\_rx\_fifo\_1ck

上述代码的核心思路是检测NWE或NOE信号上出现的下降沿（此处被语句：assign en\_fsmc\_oe = (fsmc\_a\[21\] == 1'b0) && (rd\_n == 1'b0) && (cs\_n == 1'b0);变成了en\_fsmc\_oe和rd\_uart1\_rx\_fifo信号的上升沿），方法是用移位寄存器缓冲两个FPGA系统时钟有效边沿时刻的信号，并用异或判断二者是否相反，最后用与运算判断是上升沿还是下降沿。这种方法有效的避免了NWE和NOE持续时间超过一个FPGA系统时钟周期，以及上升、下降沿混淆的问题。但应注意：由于STM32产生的NWE或NOE信号与FPGA系统时钟不同步，wr\_data\_1ck信号上持续的1个时钟周期的高电平最早可能开始于NWE或NOE下降沿出现的瞬间，最迟可能开始于NWE或NOE下降沿出现一个时钟周期之后——因此由图1可知，读数据建立DATAST应该大于1或2（@72MHz HCLK）。

### 2、双向数据线数据输出及高阻态控制

 其核心思想是设计一个组合逻辑数据多路器，将不同地址输出的数据连接到out\_data\[7:0\]，并用输出使能信号en\_fsmc\_oe实现高阻态控制。

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

 1 reg\[7:0\] out\_data;//用于输出的数据线(由于要使用always语句这里被定义了reg类型，但实际是wire)
 2 assign fsmc\_d\[7:0\] = (en\_fsmc\_oe == 1'b1) ? out\_data : 8'bzzzz\_zzzz;//双向的数据总线
 3 always @(\*) begin
 4     case (fsmc\_a\[20:16\])
 5         ADDR\_RX\_STATE  : out\_data\[7:0\] = PERI\_UART\_RX\_STATE\[7:0\];
 6         ADDR\_TX\_STATE  : out\_data\[7:0\] = PERI\_UART\_TX\_STATE\[7:0\];
 7         ADDR\_UART1\_RX  : out\_data\[7:0\] = uart1\_rx\_fifo\_out\_wire\[7:0\];
 8     ADDR\_UART1\_RX\_LEN : out\_data\[7:0\] = uart1\_rx\_data\_len\[7:0\];
 9     ADDR\_UART1\_TX\_LEN : out\_data\[7:0\] = uart1\_tx\_data\_len\[7:0\];
10         ADDR\_UART2\_RX  : out\_data\[7:0\] = uart2\_rx\_fifo\_out\_wire\[7:0\];
11     ADDR\_UART2\_RX\_LEN : out\_data\[7:0\] = uart2\_rx\_data\_len\[7:0\];
12     ADDR\_UART2\_TX\_LEN : out\_data\[7:0\] = uart2\_tx\_data\_len\[7:0\];
13         // ... 其他地址 ...
14         default: out\_data\[7:0\] = 8'h00;  // 避免锁存器
15     endcase
16 end

读端口输出电路设计

### 3、收、发缓冲FIFO的实现

我使用了安路低成本的小精灵2（EF2系列）价格最低的一款CPLD/FPGA来实现我的设计，下图是TD（Tang Dynasty）开发环境中FIFO的图形化配置界面，每扩展一个深度为256字节的UART需要2个这样的FIFO各（分别作发送和接收缓冲）。选择用片上的9K块RAM资源来实现，而没有选择用LE中的DRAM（离散RAM），原因是为了降低应用对宝贵LE资源的占用，但由于258\*8的结构其实只使用了每个EMB9K中RAM资源的四分之一，后续复杂应用还有较大的缓冲深度升级余地。对资源最少的EF2L15而言，由于只有6个EMB9K，最多只能实现3个UART口。若需更多UART，需要选择更大的可编程芯片。

![image](https://img2024.cnblogs.com/blog/1380455/202510/1380455-20251007232907234-1936484254.png)

图3 256字节的缓冲FIFO

 下面是发送和接收FIFO的例化代码。

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

 1 UART\_RX\_FIFO uart\_rx\_fifo(
 2     .rst(!rst\_n),  //asynchronous port,active hight
 3     .clkw(clk\_in\_50),  //写时钟
 4     .clkr(clk\_in\_50),  //read clock
 5     .we(uart\_rx\_flag),  //write enable,active hight
 6     .di(uart\_rx\_fifo\_in\_wire\[7:0\]),  //write data
 7     .re(rd\_uart\_rx\_fifo\_1ck),  //read enable,active hight
 8     .dout(uart\_rx\_fifo\_out\_wire\[7:0\]),  //read data
 9     .valid(),  //read data valid flag
10     .full\_flag(),  //fifo full flag
11     .empty\_flag(uart\_rx\_fifo\_empty),  //fifo empty flag
12     .afull(),  //fifo almost full flag
13     .aempty(),  //fifo almost empty flag
14     .wrusedw(rx\_data\_len\[7:0\]),  //stored data number in fifo
15     .rdusedw() //available data number for read      
16 ) ;
17 UART\_TX\_FIFO uart\_tx\_fifo(
18     .rst(!rst\_n),  //asynchronous port,active hight
19     .clkw(clk\_in\_50),  //写时钟
20     .clkr(clk\_in\_50),  //read clock
21     .we(wr\_uart\_tx\_fifo\_1ck),  //write enable,active hight
22     .di(fsmc\_d\[7:0\]),  //write data直接将数据总线数据写入发送fifo
23     .re(uart\_tx\_fifo\_rd\_en\_1ck),//.re(!rst\_n),//  //read enable,active hight
24     .dout(uart\_tx\_data\_wire\[7:0\]),  //read data
25     .valid(),  //read data valid flag
26     .full\_flag(),  //fifo full flag
27     .empty\_flag(uart\_tx\_fifo\_empty),  //fifo empty flag
28     .afull(),  //fifo almost full flag
29     .aempty(),  //fifo almost empty flag
30     .wrusedw(tx\_data\_len\[7:0\]),  //stored data number in fifo
31     .rdusedw() //available data number for read      
32     ) ;

接收和发送缓冲FIFO例化 

### 4、UART模块的实现

TD自带UART的IP，配置界面如下图所示。其中模块时钟为50MHz，不建议大家为了省电使用更低频率：实验显示使用低频时钟后，UART连续接收多个字节数据包时可能出现少量字节识别错误。

![image](https://img2024.cnblogs.com/blog/1380455/202510/1380455-20251008090026713-1394341378.png)

图4 UART模块配置

 下面是UART的例化代码。 

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

 1 UART uart\_inst
 2   (
 3   .clk(clk\_in\_50),//UART时钟
 4   .rst\_n(rst\_n),
 5   .rxd(rxd),//rx管脚
 6   .tx\_data(uart\_tx\_data\_wire\[7:0\]),//要发送的数据
 7   .tx\_en(uart\_tx\_en\_1ck),//启动uart发送
 8   .rx\_data(uart\_rx\_fifo\_in\_wire\[7:0\]),//收到的数据
 9 .rx\_err(),
10   .rx\_vld(uart\_rx\_flag),//收到数据标志
11 .tx\_rdy(uart\_tx\_rdy\_wire),
12   .txd(txd)//tx管脚
13   );

例化UART IP代码

该模块收、发时序如下图所示。

![image](https://img2024.cnblogs.com/blog/1380455/202510/1380455-20251008093520590-1675480402.png)

图5 UART模块接收数据时序

![image](https://img2024.cnblogs.com/blog/1380455/202510/1380455-20251008093636358-975652755.png)

 图6 UART模块发送数据时序

 正确完成一个字节数据的接收后，模块将在rx\_vld上产生1个时钟周期的高电平，正好用于接收缓冲FIFO的写使能信号，嵌入式处理器可以在合适的时间从接收FIFO中读取之前收到的数据。发送控制信号tx\_en的生成逻辑比较麻烦，它需要在发送FIFO非空的情况下不断产生长度为1个时钟周期的正脉冲。我使用一个有限状态机FSM来产生所需的读取发送缓冲FIFO的信号和使能UART发送的tx\_en信号。

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

 1 always @(posedge clk\_in\_50 or negedge rst\_n) 2 begin
 3     if(!rst\_n)
 4         uart\_tx\_state\_reg\[2:0\] <= WAIT\_STATE; 5     else begin
 6         case(uart\_tx\_state\_reg\[2:0\])
 7             WAIT\_STATE:
 8                 begin
 9                     if((!uart\_tx\_fifo\_empty)&&(uart\_tx\_rdy\_wire))//发送缓冲区不为空，且串口准备好发送
10                         uart\_tx\_state\_reg\[2:0\] <= READ\_FIFO\_STATE;//就进入读取缓冲区状态
11                     else
12                         uart\_tx\_state\_reg\[2:0\] <= WAIT\_STATE;//否则继续等待
13                 end
14 READ\_FIFO\_STATE:
15                 begin
16                     uart\_tx\_state\_reg\[2:0\] <= WRITE\_UART\_REG\_STATE;
17                 end
18 WRITE\_UART\_REG\_STATE:
19                 begin
20                     uart\_tx\_state\_reg\[2:0\] <= WAIT\_STATE;
21                 end
22             default: begin
23                 uart\_tx\_state\_reg\[2:0\] <= WAIT\_STATE;
24             end
25         endcase
26     end
27 end
28 
29 wire uart\_tx\_fifo\_rd\_en\_1ck;//uart发送缓冲区读取使能信号，只能持续一个时钟周期
30 assign uart\_tx\_fifo\_rd\_en\_1ck = uart\_tx\_state\_reg\[1\];//状态寄存器的第二个位，对应从发送FIFO读取数据
31 wire uart\_tx\_en\_1ck;//启动uart发送信号，持续1个时钟周期
32 assign uart\_tx\_en\_1ck = uart\_tx\_state\_reg\[2\];//状态寄存器的第三个位刚好对应使能uart发送数据

读取发送缓冲和UART发送使能控制状态机

缺省状态为空闲状态WAIT\_STATE，只有当UART发送完成（uart\_tx\_rdy\_wire为1）且发送缓冲FIFO中有数据时（uart\_tx\_fifo\_empty为0），状态机才进入读取发送缓冲FIFO状态（READ\_FIFO\_STATE），以及启动UART发送状态（WRITE\_UART\_REG\_STATE），而后两个状态都只固定的停留1个时钟周期。对应的标志uart\_tx\_fifo\_rd\_en\_1ck和uart\_tx\_en\_1ck则被分别连接到了前文提到的发送缓冲FIFO模块和UART模块。 

### 5、状态寄存器内容的更新

状态寄存器中可以存放任何UART控制器想与嵌入式处理器沟通的内容。为防止不同状态位延迟不同造成的竞争和冒险，我采用一组寄存器来锁存状态，锁存时钟就是系统时钟。

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

 1 //更新状态寄存器
 2 always @(posedge clk\_50\_wire or negedge rst\_n) 3 begin
 4     if(!rst\_n) begin
 5         PERI\_UART\_RX\_STATE\[7:0\] <= 8'h00;
 6         PERI\_UART\_TX\_STATE\[7:0\] <= 8'h00;
 7     end
 8     else begin
 9         PERI\_UART\_RX\_STATE\[7:0\] <= {6'h00 , (!uart2\_rx\_fifo\_empty) , (!uart1\_rx\_fifo\_empty)};//将状态标志统一到状态寄存，接收状态寄存为1表示，缓冲区中有待读取的数据
10         PERI\_UART\_TX\_STATE\[7:0\] <= {6'h00 , uart2\_tx\_rdy , uart1\_tx\_rdy};
11     end
12 end

UART状态寄存器的实现

其中PERI\_UART\_RX\_STATE\[7:0\] 等寄存器地址，请参考本文开始阶段的定义。

### 6、FPGA时序约束

本文所述电路系统频率仅为50MHz，且作为UART模块外部IO接口频率在1MHz以下，基本不需要太严格的时序约束。我只对输入10MHz时钟和PLL派生出的50MHz时钟进行了简单约束如下：

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

1 create\_clock -name clk\_in\_10 -period 100 -waveform {0 50} \[get\_ports {clk\_in\_10}\]
2 #derive\_clocks -period 20
3 derive\_pll\_clocks
4 rename\_clock -name {clk\_50\_wire} -source \[get\_ports {clk\_in\_10}\] -master\_clock {clk\_in\_10} \[get\_pins {pll\_inst/pll\_inst.clkc\[0\]}\]

时钟约束

三、嵌入式处理器控制代码
------------

如果选择STM32作为嵌入式控制器，则需选择100pin以上的型号，方具备FSMC接口，起初始化代码如下。

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

 1     GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_0|GPIO\_Pin\_1|GPIO\_Pin\_4|GPIO\_Pin\_5|GPIO\_Pin\_7|GPIO\_Pin\_11|GPIO\_Pin\_12|GPIO\_Pin\_13|GPIO\_Pin\_14|GPIO\_Pin\_15;
 2                                 //D2            D3            NOE        NWE            NE1            A16            A17            A18            D0            D1
 3     GPIO\_InitStructure.GPIO\_Mode = GPIO\_Mode\_AF\_PP;    //推挽输出
 4     GPIO\_InitStructure.GPIO\_Speed = GPIO\_Speed\_50MHz;    //50M时钟速度
 5     GPIO\_Init(GPIOD, &GPIO\_InitStructure);
 6     //PE口大部分为FSMC接口
 7     GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_2|GPIO\_Pin\_3|GPIO\_Pin\_4|GPIO\_Pin\_5|GPIO\_Pin\_6|GPIO\_Pin\_7|GPIO\_Pin\_8|GPIO\_Pin\_9|GPIO\_Pin\_10;
 8                                 //A23            A19            A20            A21            A22        D4            D5            D6            D7
 9     GPIO\_InitStructure.GPIO\_Mode = GPIO\_Mode\_AF\_PP;    //推挽输出
10     GPIO\_InitStructure.GPIO\_Speed = GPIO\_Speed\_50MHz;    //50M时钟速度
11     GPIO\_Init(GPIOE, &GPIO\_InitStructure);
12     FSMC\_NORSRAMInitTypeDef  FSMC\_NORSRAMInitStructure; //定义NOR初始化数据结构体
13   FSMC\_NORSRAMTimingInitTypeDef  FSMC\_TimingInitStructure;//定义NOR初始化时间参数结构体
14 
15     RCC\_AHBPeriphClockCmd(RCC\_AHBPeriph\_FSMC, ENABLE);//使能FSMC总线
16 
17     FSMC\_TimingInitStructure.FSMC\_AddressSetupTime =0;//地址建立时间
18     FSMC\_TimingInitStructure.FSMC\_AddressHoldTime = 0;//地址保持时间
19     FSMC\_TimingInitStructure.FSMC\_DataSetupTime = 5;//数据建立时间
20     FSMC\_TimingInitStructure.FSMC\_BusTurnAroundDuration = 1;//总线恢复时间0
21     FSMC\_TimingInitStructure.FSMC\_CLKDivision = 0;//时钟分割系数0
22     FSMC\_TimingInitStructure.FSMC\_DataLatency = 0;//数据延时0
23     FSMC\_TimingInitStructure.FSMC\_AccessMode = FSMC\_AccessMode\_A;    //异步突发访问模式A
24 
25     FSMC\_NORSRAMInitStructure.FSMC\_Bank = FSMC\_Bank1\_NORSRAM1;//选择存储块1片选1
26      FSMC\_NORSRAMInitStructure.FSMC\_DataAddressMux = FSMC\_DataAddressMux\_Disable;//不使用总线复用
27      FSMC\_NORSRAMInitStructure.FSMC\_MemoryType = FSMC\_MemoryType\_SRAM;//扩展存储器类型为SRAM
28     FSMC\_NORSRAMInitStructure.FSMC\_MemoryDataWidth = FSMC\_MemoryDataWidth\_8b; //扩展总线宽度8位
29     FSMC\_NORSRAMInitStructure.FSMC\_BurstAccessMode = FSMC\_BurstAccessMode\_Disable;//
30     FSMC\_NORSRAMInitStructure.FSMC\_WaitSignalPolarity = FSMC\_WaitSignalPolarity\_Low;
31     FSMC\_NORSRAMInitStructure.FSMC\_WrapMode = FSMC\_WrapMode\_Disable;
32     FSMC\_NORSRAMInitStructure.FSMC\_WaitSignalActive = FSMC\_WaitSignalActive\_BeforeWaitState;
33     FSMC\_NORSRAMInitStructure.FSMC\_WriteOperation = FSMC\_WriteOperation\_Enable;
34     FSMC\_NORSRAMInitStructure.FSMC\_WaitSignal = FSMC\_WaitSignal\_Disable;
35     FSMC\_NORSRAMInitStructure.FSMC\_ExtendedMode = FSMC\_ExtendedMode\_Disable;
36     FSMC\_NORSRAMInitStructure.FSMC\_WriteBurst = FSMC\_WriteBurst\_Disable;
37     FSMC\_NORSRAMInitStructure.FSMC\_ReadWriteTimingStruct = &FSMC\_TimingInitStructure;
38     FSMC\_NORSRAMInitStructure.FSMC\_WriteTimingStruct = &FSMC\_TimingInitStructure;      
39 
40     FSMC\_NORSRAMInit(&FSMC\_NORSRAMInitStructure); 
41     FSMC\_NORSRAMCmd(FSMC\_Bank1\_NORSRAM1, ENABLE);   

FSMC初始化代码

 我在STM32中移植了RTOS，每个任务负责管理一个UART，定时查询接收状态寄存器STAT\_RX\_Addr在有数据时不断读取接收FIFO，随后将收到的数据再发给同一个串口。这样用PC和串口调试助手就可以观察每个串口的收发功能是否正确了。

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

 1 void TaskUART1(void \*pdata)
 2 {
 3     unsigned char state\_rx, rx\_len; 4     unsigned int i,j; 5     unsigned char rx\_buff\[20\];
 6     while(1)
 7     {
 8         OSTimeDly(30);    
 9         state\_rx = \*(volatile unsigned char \*) (STAT\_RX\_Addr);
10         if((state\_rx & 0x01) != 0x00)//UART有数据的情况下就读取数据
11 {
12             i = 0; 
13             rx\_len = \*(volatile unsigned char \*) (UART1\_RX\_LEN\_Reg\_Addr);//读取FPGA缓冲中数据长度寄存器
14             while((state\_rx & 0x01) != 0x00)//缓冲区不空就继续读取
15 {
16                 rx\_buff\[i\] = \*(volatile unsigned char \*) (UART1\_RX\_Reg\_Addr);
17                 i++;
18                 state\_rx = \*(volatile unsigned char \*) (STAT\_RX\_Addr);
19 }
20             \*(volatile unsigned char \*) UART1\_TX\_Reg\_Addr = i;//把读取到的数据量，发还给同一个串口
21             //把收到的数据再打印回来
22             for(j = 0 ; j < i ; j++)
23                 \*(volatile unsigned char \*) UART1\_TX\_Reg\_Addr = rx\_buff\[j\];
24 }
25 }
26 }     

管理单个UART口的任务代码举例

四、总结
----

为了验证功能的正确性，我在低成本的EF2L15上，用上述方法实现做了两个UART（每个UART约占用400-500个LE之外，还占用2个EMB9K），分别不间断运行modbus协议栈读取传感器数据测试，目前为止未发现问题。