---
layout: post
title: 'ZYNQ linux上使用 USB CDC ACM'
date: "2025-08-08T00:46:18Z"
---
ZYNQ linux上使用 USB CDC ACM
=========================

一、USB CDC ACM介绍
===============

USB CDC ACM 是 USB 通信设备类(CDC)中的一个子类，它提供了一种通过 USB 接口实现虚拟串行通信的标准方法。

1\. 基本概念
--------

CDC ACM 是 USB 规范中定义的一种设备类协议，它模拟传统的串行端口通信，提供双向数据传输通道，支持控制信号（如 RTS/CTS、DTR/DSR 等，是 USB 转串口设备的常用实现方式。

2\. 主要特点
--------

标准化：遵循 USB-IF 定义的 CDC 规范

兼容性：大多数操作系统内置驱动支持

灵活性：可以在不同硬件平台上实现

多功能：支持数据和控制通道分离

3\. 技术架构
--------

CDC ACM 包含两个主要接口：

### 3.1 通信接口(Communication Interface)

管理设备控制和状态

包含中断端点(Interrupt Endpoint)

处理线路编码、控制信号等

### 3.2 数据接口(Data Interface)

处理实际数据传输

包含批量输入和输出端点(Bulk In/Out Endpoints)

实现数据流传输

二、 Linux-USB Gadget驱动框架
=======================

在ZYNQ等ARM板卡上移植好linux内核后，就可以通过linux USB Gadget驱动框架实现USB CDC类。

USB Gadget 框架是 Linux 内核中实现 USB 设备功能的子系统，它允许嵌入式设备作为 USB 从设备(Peripheral)与主机通信。

在 ZYNQ 7000系列SOC上，存在两个USB2.0接口，支持USB HOST和USB OTG。

笔者板卡（正点原子 ZYNQ7035）上的 USB HOST 接口与 USB OTG 接口（也称 USB Slave 接口）共用了YNQ PS 端的 USB0 接口，所以在正常情况下，USB HOST 和 USB OTG 不能同时工作，所

以在 Z100 底板上有一组跳线帽端子 J15 用于控制 USB HOST 和 USB OTG 哪个接口工作。

对于USB OTG 接口工作：

需要通过两个跳线帽将 J15 端子的 DN 与 SN 相连、DP 与 SP 相连，注意先连接 DN 与SN。

三、vivado工程配置
============

在block design中，添加ZYNQ7 PS后使能USB0接口，并选择对应的MIO接口：  
  
  
设置完成后，重新生成xsa文件。

四、设备树配置
=======

在vivado中使能USB0配置后，在PCW.dtsi设备树文件中关于usb0的节点status 属性就被设置为"okay"了，

所以由此可以知道，其实 pcw.dtsi 文件中已经使能了 usb0，但是目前还是不能使用 usb0的，还需要为 usb0 节点添加一下属性内容，打开 arch/arm/boot/dts/system-user.dtsi 设备树文件，

添加相关内容。首先需要在 system-user.dtsi 设备树根节点下添加一个 usb\_phy0 节点，用于描述 USB phy相关信息，如下所示：

其中，dr\_mode可以是OTG，也可以为peripheral

system-user.dtsi 设备树文件修改完成之后，保存退出！然后在内核源码根文件目录下执行下面这条命令编译设备树文件：

`make dtbs`

将编译得到的 system-top.dtb 文件重命名为 system.dtb，将 system.dtb 文件拷贝到开发板SD 启动卡的第一个分区，替换掉就的设备树文件。

五、内核配置
======

USB 的HOST在linux内核中是默认配置的，但是CDC是没有默认开启的，因此需要配置内核相关配置。

在内核源码根文件夹下执行：

`make menuconfig`  
配置路径为：  
Device Drivers --->  
\[_\] USB support --->  
<_\> USB Gadget Support --->  
<\*> USB Gadget precomposed configurations --->  
勾选以下配置：  

配置好后， save 并退出，重新编译下内核：

`make -j8`  
编译成功后会在arch/arm/boot下生成zImage内核镜像，将该文件拷贝至U盘的vfat分区（boot）。

同时会生成相关驱动，目录如下：  
  
将以下驱动拷贝至vfat分区目录下：

`g_serial.ko, libcomposite.ko, usb_f_acm.ko, usb_f_obex.ko, usb_f_serial.ko, u_serial.ko.`

并启动Linux,按顺序加载前面生成的驱动模块：出现以下信息代表驱动挂载成功了：

此时打开设备文件发现多了/dev/ttyGS0设备，这个就是虚拟的串口设备。  

六、读写测试
======

将板卡上的usb slave接口链接电脑，这时候在windows的设备管理器中发现这个USB设备：  

6.1 终端写
-------

在电脑上通过串口工具（如xcom）打开该设备，并在ZYNQ终端中输入发送测试命令：  
echo hello，this is usb cdc acm device > /dev/ttyGS0\`

在串口工具成功接收到该信息：  

6.2 终端读
-------

在ZYNQ终端通过cat监听该USB的接收信息，在串口工具，发送任意字符，并勾选发送新行（这里笔者猜测是终端的内核缓冲区机制，\\n会让内核接收的信息刷新出来）。否则可能不会在终端打印出来