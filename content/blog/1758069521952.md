---
layout: post
title: '2025 年 PHP 常见面试题整理以及对应答案和代码示例'
date: "2025-09-17T00:38:41Z"
---
2025 年 PHP 常见面试题整理以及对应答案和代码示例
=============================

2025 年 PHP 常见面试题整理以及对应答案和代码示例
=============================

PHP 面试通常会考察基础知识（数组、OOP、错误处理）和现代特性（类型、属性、枚举）。关键是要展示你能写出简洁、可预测的代码，同时了解 PHP 8+ 的新变化。

我整理了以下一些常见 PHP 可能面试的。每个问题都有简洁的答案和可运行的代码示例，你可以直接复制去试试。

[原文链接- 2025 年 PHP 常见面试题整理以及对应答案和代码示例](https://catchadmin.com/post/2025-09/php-common-interview-questions-zh)

PHP 8+ 中有哪些面试官关心的变化？
--------------------

**类型系统**：联合类型（int|float）、mixed、never、true|false|null、交集类型，以及可空类型 ?T。

**OOP 改进**：构造器属性提升、readonly 属性/类、枚举、#\[\\Override\] 属性。

**控制流**：match（表达式，无穿透）、nullsafe 操作符 ?->。

**开发体验优化**：命名参数、属性/注解、JIT（性能提升）、array\_is\_list()。

**错误处理更合理**：字符串和数字比较的方式改进了（比如 0 == "foo" 现在返回 false）。

如果你能清楚地解释这些特性，面试就会顺利很多。

PHP 中 == 和 === 的区别是什么？
----------------------

\== 执行类型转换；=== 要求相同类型和相同值。

    var_dump(42 == "42");   // true  (宽松比较)
    var_dump(42 === "42");  // false (严格比较)
    
    // 从 PHP 8 开始：
    var_dump(0 == "foo");   // false (旧版本中曾经是 true)
    

**要点**：默认使用 ===，除非有非常具体的理由不这样做。

联合类型、可空类型和交集类型如何工作？
-------------------

    function area(int|float $w, int|float $h): float {
        return $w * $h;
    }
    
    function greet(?string $name): string { // 可空类型
        return "Hello, " . ($name ?? "stranger");
    }
    
    interface A { public function foo(): void; }
    interface B { public function bar(): void; }
    
    class C implements A, B {
        public function foo(): void {}
        public function bar(): void {}
    }
    
    function needsAandB(A&B $x): void { /* ... */ } // 交集类型
    

*   `int|float` 表示两者之一
*   `?string` 表示 `string|null`
*   `A&B` 表示必须实现 A 和 B 两个接口

nullsafe 操作符是什么，何时应该使用？
-----------------------

当左侧为 null 时，它会自动停止后续的方法/属性访问。

    $user = null;
    echo $user?->profile?->company?->name ?? 'No company'; // "No company"
    

无需嵌套 if——简洁且安全。

什么时候应该使用 match 而不是 switch？
--------------------------

match 是表达式（可以返回值），必须处理所有情况，不会像 switch 那样穿透执行。

    $status = 404;
    $message = match ($status) {
        200, 201 => 'OK',
        404      => 'Not Found',
        500      => 'Server Error',
        default  => 'Unknown',
    };
    

这减少了因遗忘 `break;` 引起的错误。

用 60 秒解释 Composer 自动加载和 PSR-4
-----------------------------

1.  在 composer.json 中添加命名空间
2.  将文件放在正确的文件夹中
3.  让 Composer 生成自动加载器

    {
      "autoload": {
        "psr-4": {
          "App\\": "src/"
        }
      }
    }
    

    // src/Service/Pinger.php
    namespace App\Service;
    
    class Pinger {
        public function ping(): string { return 'pong'; }
    }
    

    // index.php
    require __DIR__ . '/vendor/autoload.php';
    
    use App\Service\Pinger;
    echo (new Pinger())->ping(); // "pong"
    

修改后运行 `composer dump-autoload`。

include 和 require 的区别（及 \_once 变体）？
-----------------------------------

*   **require** → 失败时产生致命错误（停止脚本）
*   **include** → 失败时产生警告（继续执行）
*   **\*\_once** → 只加载文件一次

应用必须的文件使用 require（如 bootstrap），可选部分使用 include。

PHP 引用实际如何工作？
-------------

赋值是写时复制。大部分时候不需要用引用，只有在 API 必须修改参数值时才用。

    function bump(int &$n): void { $n++; }
    $x = 5;
    bump($x);
    echo $x; // 6
    

避免为"微优化"使用引用。它们往往损害清晰度。

解释异常与错误（Throwable）
------------------

所有可抛出的都实现 Throwable。Exception 和 Error 是兄弟类。

    try {
        throw new RuntimeException('Oops');
    } catch (\Throwable $e) { // 捕获 Exception 和 Error
        error_log($e->getMessage());
    } finally {
        // 清理工作
    }
    

在应用的边界层（比如控制器）捕获 Throwable 很方便，但在库的内部应该捕获更具体的异常类型。

PDO 预处理语句防止 SQL 注入
------------------

    $pdo = new PDO($dsn, $user, $pass, [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    ]);
    $stmt = $pdo->prepare('SELECT * FROM users WHERE email = :email');
    $stmt->execute(['email' => $email]);
    $user = $stmt->fetch(PDO::FETCH_ASSOC);
    

**经验法则**：始终使用预处理语句；永不插入不可信输入。

如何正确存储密码？
---------

使用 `password_hash()` 和 `password_verify()`。不要自己选择算法——让 PHP 选择默认的。

    $hash = password_hash($plainPassword, PASSWORD_DEFAULT);
    if (password_verify($loginPassword, $hash)) {
        // 通过验证
    }
    

PASSWORD\_DEFAULT 会随着 PHP 版本更新而演进，当 `password_needs_rehash()` 返回 true 时需要重新哈希。

属性（Attributes）是什么，如何读取？
-----------------------

属性是原生注解。你可以装饰类、方法等，并通过反射读取。

    #[Attribute(Attribute::TARGET_METHOD)]
    class Route {
        public function __construct(public string $path) {}
    }
    
    class BlogController {
        #[Route('/posts')]
        public function index() {}
    }
    
    // 读取：
    $ref = new ReflectionMethod(BlogController::class, 'index');
    $attrs = $ref->getAttributes(Route::class);
    $path  = $attrs[0]->newInstance()->path; // '/posts'
    

框架会用属性来处理路由、验证、依赖注入等功能。

枚举是什么，为什么有用？
------------

枚举用真正的类型替换"字符串化"的常量。

    enum Status: string {
        case Draft = 'draft';
        case Published = 'pub';
    }
    
    function publish(Status $s): bool {
        return $s === Status::Published;
    }
    
    publish(Status::Draft); // false
    

带值的枚举保证了比较的安全性，也能让 IDE 的自动完成更好用。

readonly 属性和不可变对象
-----------------

用来创建值对象或 DTO 非常合适。

    final class Money {
        public function __construct(
            public readonly int $cents,
            public readonly string $currency,
        ) {}
    }
    
    $m = new Money(100, 'USD');
    // $m->cents = 200; // 错误
    

也可以用 readonly 类来让全部属性都变成只读。

Trait vs 抽象类 vs 接口
------------------

*   **接口**：仅契约（无实现）
*   **抽象类**：共享基类 + 部分实现
*   **Trait**：跨不相关类的水平复用（混入方法）

    trait LoggerTrait {
        public function log($m){ echo $m; }
    }
    
    interface Reportable {
        public function report(): string;
    }
    
    abstract class BaseReport {
        abstract public function data(): array;
    }
    
    class SalesReport extends BaseReport implements Reportable {
        use LoggerTrait;
        public function data(): array { return [1,2,3]; }
        public function report(): string { return json_encode($this->data()); }
    }
    

延迟静态绑定（static:: vs self::）
--------------------------

`self::` 绑定到写代码的类；`static::` 延迟到运行时类。

    class A {
        public static function who(): string { return __CLASS__; }
        public static function call(): string { return static::who(); }
    }
    
    class B extends A {
        public static function who(): string { return __CLASS__; }
    }
    
    echo B::call(); // "B" (延迟静态绑定)
    

基类如果要被继承的话，应该用 `static::`。

生成器（yield）处理大数据集
----------------

生成器采用懒加载——特别适合处理大量数据流。

    function lines(string $file): iterable {
        $fh = fopen($file, 'r');
        try {
            while (($line = fgets($fh)) !== false) {
                yield rtrim($line, "\n");
            }
        } finally {
            fclose($fh);
        }
    }
    
    foreach (lines('huge.txt') as $line) {
        // 处理而不加载所有内容到内存
    }
    

闭包、"use" 和箭头函数
--------------

    $total = 0;
    $add = function(int $n) use (&$total) { $total += $n; };
    
    array_map($add, [1,2,3]);
    echo $total; // 6
    
    $double = fn($x) => $x * 2; // 箭头函数自动按值捕获
    

箭头函数写起来简洁，普通闭包能让你精确控制变量捕获（use）。

会话和 Cookie：安全默认检查清单
-------------------

    session_set_cookie_params([
        'httponly' => true,
        'samesite' => 'Lax',
        'secure' => isset($_SERVER['HTTPS']),
    ]);
    session_start();
    $_SESSION['user_id'] = 123;
    

*   登录时重新生成 ID（`session_regenerate_id(true)`）
*   设置 secure 和 httponly
*   优先使用 SameSite=Lax 或 Strict，除非第三方流程需要 None

处理日期：优先使用 DateTimeImmutable
---------------------------

    $start = new DateTimeImmutable('2025-03-01 09:00', new DateTimeZone('UTC'));
    $meeting = $start->modify('+1 hour');
    
    echo $start->format('c');   // 未改变
    echo $meeting->format('c'); // 新实例
    

不可变日期可以防止意外修改。记得要明确设置时区，或者早期用 default\_timezone\_set 设置。

OPcache 和性能基础
-------------

*   生产环境启用 OPcache——它缓存编译的字节码
*   避免过早的微优化；用专门的工具来测量性能（比如 Blackfire、Xdebug profiler）
*   使用正确的数据结构；对大数字列表，SplFixedArray 比常规数组更节省内存

PHP 的垃圾收集器如何工作
--------------

PHP 使用引用计数 + 循环收集器的方式管理内存。大部分情况下不用操心这个问题。但如果是长时间运行的进程（比如 worker 或 daemon），又有大量数据结构或循环引用（父子对象互相引用），就需要手动 unset 引用并打破循环，这样能更早释放内存。

常见数组陷阱和高级技巧
-----------

    $a = ['x' => 1, 'y' => 2];
    $b = ['y' => 3, 'z' => 4];
    $merge = $a + $b;           // 按键联合：['x'=>1,'y'=>2,'z'=>4]
    $replace = array_merge($a, $b); // ['x'=>1,'y'=>3,'z'=>4]
    
    $list = ['a','b','c'];
    array_splice($list, 1, 1); // 在索引1处移除：['a','c']
    array_is_list(['a','b']);   // true（连续数字键）
    array_is_list(['1'=>'a']);  // false
    

知道何时需要联合（+）vs 合并（array\_merge）。

如何快速测试代码？
---------

*   将逻辑放入小函数或方法
*   使用 PHPUnit 或 Pest；模拟外部服务
*   快速检查，添加简单的 CLI 脚本：

    if (PHP_SAPI === 'cli') {
        assert(area(3, 4) === 12.0);
        echo "All good\n";
    }
    

CLI 断言能让你快速验证代码的正确性，即使只是小示例也很有用。

关于 PHP 中的异步
-----------

PHP 本身是同步的请求-响应模式，但 Fiber（PHP 8.1）让 AMPHP 或 ReactPHP 等库能实现用户空间的并发处理。面试中不会要求你手写异步代码，只要能说明白什么时候需要用（比如 worker 中有大量 I/O 操作）就行。

快速问答
----

**$\_POST vs php://input？** $\_POST 解析表单编码数据；php://input 读取原始请求体（对 JSON 有用）。

\***\*get/**set？\*\* 重载属性访问的魔术方法——谨慎使用。

**\_\_toString()？** 对象的字符串表示（必须返回字符串）。

**require\_once 慢？** 有 OPcache 时可忽略；为了正确性使用，不是"速度"。

**到处都是静态方法？** 对纯函数很方便；为了可测试性/可配置性优先使用 DI。

**常量 vs 枚举？** 枚举给你一个类型；常量只是值。

一个现代的 PHP 例子
------------

    <?php
    declare(strict_types=1);
    
    enum Role: string {
        case User = 'user';
        case Admin = 'admin';
    }
    
    final class User {
        public function __construct(
            public readonly int $id,
            public readonly string $email,
            public readonly Role $role,
        ) {}
    }
    
    #[Attribute(Attribute::TARGET_METHOD)]
    class RequiresRole {
        public function __construct(public Role $role) {}
    }
    
    final class UserController {
        #[RequiresRole(Role::Admin)]
        public function delete(User $actor, int $userId): string {
            if ($actor->role !== Role::Admin) {
                throw new RuntimeException('Forbidden');
            }
            // 假设我们在这里删除
            return "Deleted user #{$userId}";
        }
    }
    
    // 小型反射驱动的守卫：
    $ref = new ReflectionMethod(UserController::class, 'delete');
    $attr = $ref->getAttributes(RequiresRole::class)[0] ?? null;
    $required = $attr?->newInstance()->role ?? null;
    
    $controller = new UserController();
    $admin = new User(1, 'a@ex.com', Role::Admin);
    $guest = new User(2, 'g@ex.com', Role::User);
    
    echo $controller->delete($admin, 99), PHP_EOL; // "Deleted user #99"
    
    try {
        echo $controller->delete($guest, 99);
    } catch (RuntimeException $e) {
        echo $e->getMessage(), PHP_EOL; // "Forbidden"
    }
    

这个小片段展示了：严格类型、枚举、readonly 属性、属性和普通异常——所有"8.x 时代"的优点。

总结
--

如果你只记住一点：

*   优先使用严格类型、预处理语句和 password\_hash
*   使用 match、nullsafe、枚举和 readonly 让意图明显
*   保持代码可测试、小巧和朴实（以最好的方式）

面试看重的是思路清晰：要说明某个特性为什么存在，而不只是怎么用。如果你能为这些代码例子配上简洁的解释，答案就会很有说服力。