---
layout: post
title: '[设计模式/Java] 设计模式之工厂方法模式【11】'
date: "2025-04-06T00:42:07Z"
---
\[设计模式/Java\] 设计模式之工厂方法模式【11】
=============================

概述：工厂方法模式 := Factory Method Pattern
===================================

工厂模式的3种细分模式： 简单工厂模式 / 工厂方法模式 / 抽象工厂模式
-------------------------------------

*   **工厂模式**（`Factory Pattern`）是 `Java` 中**最常用的设计模式**之一

> *   其提供了一种**创建对象的方式**，使得**创建对象的过程**与**使用对象的过程**分离。
> *   **工厂模式**提供了一种**创建对象的方式**，而无需指定要创建的具体类。
> *   通过使用**工厂模式**，可以将**对象的创建逻辑**封装在一个工厂类中，而不是在**客户端代码**中**直接实例化对象**，这样可以提高代码的**可维护性**和**可扩展性**。

> *   **简单工厂模式**（Simple Factory Pattern）：
> 
> > **简单工厂模式**不是一个**正式的设计模式**，但它是**工厂模式的基础**。  
> > 它使用一个**单独的工厂类**来**创建不同的对象**，根据**传入的参数**决定创建哪种类型的对象。

![](https://img2024.cnblogs.com/blog/1173617/202504/1173617-20250405215903527-353650677.png)

> *   **工厂方法模式**（Factory Method Pattern）：
> 
> > 工厂方法模式定义了一个**创建对象的接口**，但由**子类**决定实例化哪个类。  
> > 工厂方法将**对象的创建**延迟到子类。

![](https://img2024.cnblogs.com/blog/1173617/202504/1173617-20250405215917383-4036252.png)

> *   **抽象工厂模式**（Abstract Factory Pattern）：
> 
> > **抽象工厂模式**提供一个创建一系列相关的产品 或 互相依赖对象的接口，而无需指定它们具体的产品类。

![](https://img2024.cnblogs.com/blog/1173617/202504/1173617-20250405215937977-1862205611.png)

模式定义 : 工厂方法模式
-------------

*   **工厂方法模式**定义了一个创建对象的接口，但由子类决定实例化哪个类。工厂方法将对象的创建延迟到子类。

模式分析
----

*   主要解决

> 接口选择的问题。

*   如何解决

> 通过让**子类**实现**工厂接口**，返回一个**抽象的产品**。

*   关键代码

> **对象的创建过程**在**子类**中实现。

适用场景
----

*   何时使用

> 当我们需要在**不同条件**下创建不同实例时。

模型特点
----

### 优点

*   **扩展性高**、更符合**开-闭原则**

> *   如果需要增加新产品，只需扩展一个工厂类即可。
> *   新增一种产品时，只需要增加相应的**具体产品类**和**相应的工厂子类**即可

    相比【简单工厂模式】: 需要修改工厂类的判断逻辑
    

*   符合**单一职责**原则 / **屏蔽实现** : 每个具体工厂类只负责创建对应的产品

> *   屏蔽了产品的具体实现

    相比【简单工厂模式】：其工厂类存在复杂的switch逻辑判断
    

*   不使用**静态工厂方法**，可形成**基于继承的等级结构**

> 相比【简单工厂模式】：其工厂类使用**静态工厂方法**

> **工厂(方法)模式**可以说是**简单工厂模式**的进一步抽象和拓展，在保留了**简单工厂**的封装优点的同时，让**扩展**变得简单，让**继承**变得可行，增加了**多态性**的体现。

### 缺点

*   每次增加一个产品时，都需要增加一个**具体类**和**对应的工厂**，使系统中类的数量成倍增加，增加了**系统的复杂度**和**具体类的依赖**。

> 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；  
> 同时，有更多的类需要**编译**和**运行**，会给系统带来一些**额外的开销**；

*   系统的实现难度、理解难度：有所上升

> 由于考虑到**系统的可扩展性**，需要引入**抽象层**，在**客户端代码**中均使用**抽象层**进行定义，增加了**系统的抽象性**和**理解难度**，且在实现时可能需要用到`DOM`、**反射**等技术，增加了**系统的实现难度**。

*   更换产品时，客户端仍然需要通过**修改代码**来实现

> 虽然保证了**工厂方法**内的**对修改关闭**，但对于**使用工厂方法的类(Client)**，如果要**更换另外一种产品**，仍然需要修改实例化的具体工厂类；

*   一个**具体工厂**只能创建一种**具体产品**

适用场景
----

*   当一个类**不知道它所需要的对象的类**时

> 在**工厂方法模式**中，客户端不需要知道具体产品类的类名，**只需要知道所对应的工厂**即可；

*   当一个类希望通过其**子类**来指定创建对象时

> 在**工厂方法模式**中，对于**抽象工厂类**只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用**面向对象**的多态性和**里氏代换原则**，在程序运行时，**子类对象**将覆盖父类对象，从而使得**系统更容易扩展**。

*   将**创建对象的任务**委托给多个工厂子类中的某一个，**客户端**在使用时可以无须关心是**哪一个工厂子类**创建**产品子类**，需要时再**动态指定**，可将具体工厂类的类名存储在**配置文件**或**数据库**中。

模式的组成
-----

![](https://img2024.cnblogs.com/blog/1173617/202504/1173617-20250405212901167-1005830277.png)

*   **抽象产品**（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。
*   **具体产品**（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。
*   **抽象工厂**（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。
*   **具体工厂**（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。

模式实现
----

参见本文档: | 案例：不同工厂生产不同品类的产品

案例实践
====

案例：不同工厂生产不同品类的产品
----------------

### 需求描述

背景：小成有一间**塑料加工厂**（仅生产A类产品）；随着客户需求的变化，客户需要**生产B类产品**；  
冲突：改变**原有塑料加工厂的配置和变化**非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；  
解决方案：小成决定置办**塑料分厂B**来生产B类产品；

> 即 工厂方法模式

### 源码 | Factory : 抽象工厂类

> 创建**抽象工厂类**，定义具体工厂的公共接口

    abstract class Factory {
        public abstract Product Manufacture();
    }
    

### 源码 | Product : 抽象产品

> 创建**抽象产品类** ，定义具体产品的公共接口；

    abstract class Product {
        public abstract void Show();
    }
    

### 源码 | ProductA / ProductB / ... : 多个具体产品类

> 创建**具体产品类**（继承抽象产品类）， 定义生产的具体产品；

*   ProductA

    //具体产品A类
    class ProductA extends  Product {
        @Override
        public void Show() {
            System.out.println("生产出了产品A");
        }
    }
    

*   ProductB

    //具体产品B类
    class  ProductB extends  Product {
        @Override
        public void Show() {
            System.out.println("生产出了产品B");
        }
    }
    

### 源码 | ProductA / ProductB : 具体工厂类

> 创建**具体工厂类**（继承**抽象工厂类**），定义创建对应具体产品实例的方法；

*   FactoryA

    //工厂A类 - 生产A类产品
    class  FactoryA extends Factory{
        @Override
        public Product Manufacture() {
            return new ProductA();
        }
    }
    

*   FactoryB

    //工厂B类 - 生产B类产品
    class  FactoryB extends Factory{
        @Override
        public Product Manufacture() {
            return new ProductB();
        }
    }
    

### 源码 | Client

> 外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例

    //生产工作流程
    public class Client {
        public static void main(String[] args){
            //客户要产品A
            FactoryA mFactoryA = new FactoryA();
            mFactoryA.Manufacture().Show();
     
            //客户要产品B
            FactoryB mFactoryB = new FactoryB();
            mFactoryB.Manufacture().Show();
        }
    }
    

> out

    生产出了产品A
    生产出了产品C
    

Y 推荐文献
======

*   [设计模式之总述 - 博客园/千千寰宇](https://www.cnblogs.com/johnnyzen/p/17189752.html)

X 参考文献
======

*   [工厂方法模式（Factory Method）-最易懂的设计模式解析 - CSDN](https://blog.csdn.net/varyall/article/details/82355964)
*   [java工厂模式：简单工厂、工厂方法、抽象工厂（通俗易懂） - CSDN](https://blog.csdn.net/qq_42804736/article/details/115168313) 【推荐】
*   [工厂模式 - 菜鸟教程](https://www.runoob.com/design-pattern/factory-pattern.html) 【不推荐/内容质量差】

![QQ沟通交流群](https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148)

本文作者： **[千千寰宇](https://github.com/Johnny-ZTSD)**  
本文链接： [https://www.cnblogs.com/johnnyzen](https://www.cnblogs.com/johnnyzen)  
关于博文：评论和私信会在第一时间回复，或[直接私信](https://msg.cnblogs.com/msg/send/johnnyzen)我。  
版权声明：本博客所有文章除特别声明外，均采用 [BY-NC-SA](http://blog.sina.com.cn/s/blog_896327b90102y6c6.html "https://creativecommons.org/licenses/by-nc-nd/4.0/") 许可协议。转载请注明出处！  
日常交流：大数据与软件开发-QQ交流群: 774386015 **【[入群二维码](javascript:void\(0\);)】**参见左下角。您的支持、鼓励是博主技术写作的重要动力！