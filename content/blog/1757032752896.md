---
layout: post
title: 'CMake构建学习笔记25-SpatiaLite库的构建'
date: "2025-09-05T00:39:12Z"
---
CMake构建学习笔记25-SpatiaLite库的构建
============================

详细记录了在Windows下使用nmake构建SpatiaLite及其依赖库（如freexl、librttopo等）的过程，指出了nmake缺乏动态配置能力的缺陷，并提倡未来项目迁移至CMake以实现跨平台统一构建。

1\. 引言
======

尝试使用CMake构建SpatiaLite及其依赖库，但是没有成功。因为SpatiaLite及其依赖库很多都是老牌的C库，这种库由于年代的原因一般都不提供CMake的构建方式，在Windows下提供的构建方式一般是基于nmake的。这意味着难以实现通过一个配置来实现跨平台构建，不过笔者也没有纠结这个问题，这种问题只能交给时间来解决，比如GDAL、GEOS这样库最开始都是nmake构建，后来陆续都升级为使用CMake构建。在这里就记录一下笔者使用nmake构建SpatiaLite库的过程。

> SpatiaLite是一个为SQLite数据库引擎扩展空间数据存储与分析功能的开源库，使其能够支持地理信息系统（GIS）操作。

2\. nmake构建
===========

在具体总结SpatiaLite库的构建之前，最好需要了解下Windows下使用namke构建的一般步骤。  
在Windows下构建程序最方便的当然是直接使用Visual Studio，通过GUI界面来构建程序。不过GUI方式也有很麻烦的地方，比如CICD需要通过脚本来实现代码到产品的过程，而从终端批处理的方式就是通过nmake来提供的。

2.1 步骤
------

具体来说，就是在安装Visual Studio之后，开始菜单中打开相应的开发命令行环境。以Visual Studio 2019为例，就是x64 Native Tools Command Prompt for VS 2019工具。这个工具本质上就是一个CMD，只不过已经内置了开发命令行环境，如下所示：

打开这个VS终端之后，通常输入如下指令来构建程序：

    nmake -f makefile.vc
    

这个`makefile.vc`就是代码项目的主构建脚本，定义了这个项目如何编译、链接。为了找到这个文件，需要先通过`CD`指令跳转到代码项目包含这个文件的目录下。除了`makefile.vc`这个文件之外，还可能有`nmake.opt`这个文件；这是一个自定义的配置文件，用于覆盖默认编译选项（如宏定义、包含路径、库路径、优化选项等）。通常`makefile.vc`中的内容不用修改，通过修改`nmake.opt`中的内容来实现自定义配置。

除了上述指令之外，为了区分构建步骤，以下步骤也很常见，例如清理构建过程的文件：

    nmake -f makefile.vc clean
    

将构建结果进行安装：

    nmake -f makefile.vc install
    

不过`clean`和`install`需要看`makefile.vc`和`nmake.opt`中是否提供了这个构建目标。如果没有提供，那么上述指令就不起作用。类似的构建还有DEBUG和RELEASE版本，也需要看`makefile.vc`和`nmake.opt`中是否存在相关的参数。

2.2 缺点
------

了解了上述指令之后，大概感觉跟CMake的构建指令差不多。其实差别还是很大的，跟现代构建系统相比，nmake还缺失一个关键的步骤——配置。nmake其实只是一个简单的make系统，对应的就是Linux下的Makefile，可以进行编译、链接，也可以把构建参数提取出来，但是无法动态去生成构建参数。具体来说，nmake的配置参数文件是`nmake.opt`，但是只有这个文件还不够，还需要根据构建环境不同，动态生成这个`nmake.opt`文件。

所以使用nmake构建项目的麻烦就在这里，无法根据需要动态地生成项目配置文件，只能手动去修改它。比如在之前的文章[《CMake构建学习笔记19-OpenSSL库的构建》](https://charlee44.com/post.html?id=063a34037a424a57a4f13e03eb09265b)中就是如此，也是通过nmake来构建OpenSSL库，但是不能动态生成配置怎么办呢？OpenSSL的维护者引入了perl来解决这个问题。嗯，不得不说，C/C++项目的构建系统太混乱了，简直是各显神通；希望以后的项目都能升级成CMake的构建方式吧，不是CMake有多好，先把构建的行为统一了再说。

3\. 构建SpatiaLite
================

3.1 主项目
-------

在理解了使用nmake构建的一般步骤之后，构建具体的SpatiaLite项目反而比较简单了。从[官网](https://www.gaia-gis.it/fossil/libspatialite/index)上下载最新的5.1.0版本，解压到本地，可以看到SpatiaLite提供了四个版本的构建配置，如下图所示：

其中：

1.  `makefile.vc`是32位构建配置。
2.  `makefile64.vc`是64位构建配置。
3.  `makefile_mod.vc`是32位模块化构建配置。
4.  `makefile_mod64.vc`是64位模块化构建配置。

这里也可以看到使用nmake构建的缺陷，应对不同的构建需求，需要提供多个配置文件。如果是使用CMake构建，使用一个CMakeList.txt即可。现在一般都是64位系统，选择`makefile64.vc`和`nmake64.opt`进行构建。不过为了能正确构建，修改`nmake64.opt`中的内容如下：

    # Directory tree where SpatiaLite will be installed.
    INSTDIR=C:\Work\3rdparty
    
    # Uncomment the first for an optimized build, or the second for debug.
    OPTFLAGS=	/source-charset:windows-1252 /nologo /Ox /fp:precise /W4 /MD /D_CRT_SECURE_NO_WARNINGS \
    		/DDLL_EXPORT /DYY_NO_UNISTD_H
    #OPTFLAGS=	/nologo /Zi /MD /Fdspatialite.pdb /DDLL_EXPORT
    
    # Set the version number for the DLL.  Normally we leave this blank since
    # we want software that is dynamically loading the DLL to have no problem
    # with version numbers.
    VERSION=
    

主要修改了两点：

1.  INSTDIR表示构建后安装的目录，按需进行修改。
2.  /source-charset:windows-1252是额外增加的编译选项，用于设置代码文件的数据集。

修改`makefile64.vc`中的内容为：

    # $Id: $
    #
    # NMAKE Makefile to build libspatialite on Windows
    #
    !INCLUDE nmake64.opt
    
    LIBOBJ = src\gaiaaux\gg_sqlaux.obj src\gaiaaux\gg_utf8.obj \
    	src\gaiaexif\gaia_exif.obj src\gaiageo\gg_advanced.obj \
    	src\gaiageo\gg_endian.obj src\gaiageo\gg_ewkt.obj \
    	src\gaiageo\gg_geodesic.obj src\gaiageo\gg_geoJSON.obj \
    	src\gaiageo\gg_geometries.obj src\gaiageo\gg_geoscvt.obj \
    	src\gaiageo\gg_gml.obj src\gaiageo\gg_kml.obj \
    	src\gaiageo\gg_relations.obj src\gaiageo\gg_shape.obj \
    	src\gaiageo\gg_transform.obj src\gaiageo\gg_vanuatu.obj \
    	src\gaiageo\gg_wkb.obj src\gaiageo\gg_wkt.obj \
    	src\gaiageo\gg_extras.obj src\gaiageo\gg_xml.obj \
    	src\gaiageo\gg_voronoj.obj src\gaiageo\gg_matrix.obj \
    	src\gaiageo\gg_relations_ext.obj src\gaiageo\gg_rttopo.obj \
    	src/connection_cache/alloc_cache.obj src/connection_cache/gg_sequence.obj \
    	src\spatialite\mbrcache.obj src\shapefiles\shapefiles.obj \
    	src\spatialite\spatialite.obj src\spatialite\virtualdbf.obj \
    	src\spatialite\virtualfdo.obj src\spatialite\virtualnetwork.obj \
    	src\spatialite\virtualshape.obj src\spatialite\virtualspatialindex.obj \
    	src\spatialite\statistics.obj src\spatialite\metatables.obj \
    	src\spatialite\virtualXL.obj src\spatialite\extra_tables.obj \
    	src\spatialite\virtualxpath.obj src\spatialite\virtualbbox.obj \
    	src\spatialite\spatialite_init.obj src\spatialite\se_helpers.obj \
    	src\spatialite\srid_aux.obj src\spatialite\table_cloner.obj \
    	src\spatialite\virtualelementary.obj src\spatialite\virtualgeojson.obj \
    	src\spatialite\virtualrouting.obj src\spatialite\create_routing.obj \
    	src\spatialite\dbobj_scopes.obj src\spatialite\pause.obj \
    	src\wfs\wfs_in.obj src\srsinit\srs_init.obj src\spatialite\virtualgpkg.obj \
    	src\dxf\dxf_parser.obj src\dxf\dxf_loader.obj src\dxf\dxf_writer.obj \
    	src\dxf\dxf_load_distinct.obj src\dxf\dxf_load_mixed.obj \
    	src\shapefiles\validator.obj src\md5\md5.obj src\md5\gaia_md5.obj \
    	src\srsinit\epsg_inlined_00.obj src\srsinit\epsg_inlined_01.obj \
    	src\srsinit\epsg_inlined_02.obj src\srsinit\epsg_inlined_03.obj \
    	src\srsinit\epsg_inlined_04.obj src\srsinit\epsg_inlined_05.obj \
    	src\srsinit\epsg_inlined_06.obj src\srsinit\epsg_inlined_07.obj \
    	src\srsinit\epsg_inlined_08.obj src\srsinit\epsg_inlined_09.obj \
    	src\srsinit\epsg_inlined_10.obj src\srsinit\epsg_inlined_11.obj \
    	src\srsinit\epsg_inlined_12.obj src\srsinit\epsg_inlined_13.obj \
    	src\srsinit\epsg_inlined_14.obj src\srsinit\epsg_inlined_15.obj \
    	src\srsinit\epsg_inlined_16.obj src\srsinit\epsg_inlined_17.obj \
    	src\srsinit\epsg_inlined_18.obj src\srsinit\epsg_inlined_19.obj \
    	src\srsinit\epsg_inlined_20.obj src\srsinit\epsg_inlined_21.obj \
    	src\srsinit\epsg_inlined_22.obj src\srsinit\epsg_inlined_23.obj \
    	src\srsinit\epsg_inlined_24.obj src\srsinit\epsg_inlined_25.obj \
    	src\srsinit\epsg_inlined_26.obj src\srsinit\epsg_inlined_27.obj \
    	src\srsinit\epsg_inlined_28.obj src\srsinit\epsg_inlined_29.obj \
    	src\srsinit\epsg_inlined_30.obj src\srsinit\epsg_inlined_31.obj \
    	src\srsinit\epsg_inlined_32.obj src\srsinit\epsg_inlined_33.obj \
    	src\srsinit\epsg_inlined_34.obj src\srsinit\epsg_inlined_35.obj \
    	src\srsinit\epsg_inlined_36.obj src\srsinit\epsg_inlined_37.obj \
    	src\srsinit\epsg_inlined_38.obj src\srsinit\epsg_inlined_39.obj \
    	src\srsinit\epsg_inlined_40.obj src\srsinit\epsg_inlined_41.obj \
    	src\srsinit\epsg_inlined_42.obj src\srsinit\epsg_inlined_43.obj \
    	src\srsinit\epsg_inlined_44.obj src\srsinit\epsg_inlined_45.obj \
    	src\srsinit\epsg_inlined_46.obj src\srsinit\epsg_inlined_47.obj \
    	src\srsinit\epsg_inlined_48.obj src\srsinit\epsg_inlined_49.obj \
    	src\srsinit\epsg_inlined_50.obj src\srsinit\epsg_inlined_51.obj \
    	src\srsinit\epsg_inlined_52.obj src\srsinit\epsg_inlined_53.obj \
    	src\srsinit\epsg_inlined_54.obj src\srsinit\epsg_inlined_55.obj \
    	src\srsinit\epsg_inlined_56.obj src\srsinit\epsg_inlined_57.obj \
    	src\srsinit\epsg_inlined_58.obj src\srsinit\epsg_inlined_59.obj \
    	src\srsinit\epsg_inlined_60.obj src\srsinit\epsg_inlined_61.obj \
    	src\srsinit\epsg_inlined_62.obj src\srsinit\epsg_inlined_63.obj \
    	src\srsinit\epsg_inlined_extra.obj src\srsinit\epsg_inlined_prussian.obj \
    	src\srsinit\epsg_inlined_wgs84_00.obj src\srsinit\epsg_inlined_wgs84_01.obj \
    	src\versioninfo\version.obj src\virtualtext\virtualtext.obj \
    	src\cutter\gaia_cutter.obj \
    	src\spatialite\virtualknn.obj src\spatialite\virtualknn2.obj \
    	src\control_points\gaia_control_points.obj \
    	src\control_points\grass_crs3d.obj src\control_points\grass_georef_tps.obj \
    	src\control_points\grass_georef.obj src\stored_procedures\stored_procedures.obj \
    	src\geopackage\gaia_cvt_gpkg.obj \
    	src\geopackage\gpkgAddGeometryColumn.obj \
    	src\geopackage\gpkg_add_geometry_triggers.obj \
    	src\geopackage\gpkg_add_spatial_index.obj \
    	src\geopackage\gpkg_add_tile_triggers.obj \
    	src\geopackage\gpkgBinary.obj \
    	src\geopackage\gpkgCreateBaseTables.obj \
    	src\geopackage\gpkgCreateTilesTable.obj \
    	src\geopackage\gpkgCreateTilesZoomLevel.obj \
    	src\geopackage\gpkgGetImageType.obj \
    	src\geopackage\gpkg_get_normal_row.obj \
    	src\geopackage\gpkg_get_normal_zoom.obj \
    	src\geopackage\gpkgInsertEpsgSRID.obj \
    	src\geopackage\gpkgMakePoint.obj \
    	src\topology\gaia_auxnet.obj src\topology\gaia_auxtopo.obj \
    	src\topology\gaia_auxtopo_table.obj src\topology\gaia_netstmts.obj \
    	src\topology\gaia_network.obj src\topology\gaia_topology.obj \
    	src\topology\gaia_topostmts.obj src\topology\lwn_network.obj \
    	src\topology\net_callbacks.obj src\topology\topo_callbacks.obj
    
    SPATIALITE_DLL = spatialite$(VERSION).dll
    
    CFLAGS = /nologo -I.\src\headers -I.\src\topology \
    	-I. -IC:\Work\3rdparty\include -IC:\Work\3rdparty\include\libxml2 $(OPTFLAGS)
    
    default:	all
    
    all: spatialite.lib spatialite_i.lib
    #$(EXIF_LOADER_EXE)
    
    spatialite.lib:	$(LIBOBJ)
    	if exist spatialite.lib del spatialite.lib
    	lib /out:spatialite.lib $(LIBOBJ)
    
    $(SPATIALITE_DLL):	spatialite_i.lib
    
    spatialite_i.lib:     $(LIBOBJ)
    	link /dll /out:$(SPATIALITE_DLL) \
    		/implib:spatialite_i.lib $(LIBOBJ) \
    		C:\Work\3rdparty\lib\proj.lib C:\Work\3rdparty\lib\geos_c.lib \
    		C:\Work\3rdparty\lib\freexl_i.lib C:\Work\3rdparty\lib\iconv.lib \
    		C:\Work\3rdparty\lib\sqlite3.lib C:\Work\3rdparty\lib\zlib.lib \
    		C:\Work\3rdparty\lib\libxml2.lib C:\Work\3rdparty\lib\librttopo.lib
    	if exist $(SPATIALITE_DLL).manifest mt -manifest \
    		$(SPATIALITE_DLL).manifest -outputresource:$(SPATIALITE_DLL);2
    		
    .c.obj:
    	$(CC) $(CFLAGS) /c $*.c /Fo$@
    	
    clean:
    	del *.dll
    	del *.exp
    	del *.manifest
    	del *.lib
    	del src\connection_cache\*.obj
    	del src\cutter\*.obj
    	del src\gaiaaux\*.obj
    	del src\gaiaexif\*.obj
    	del src\gaiageo\*.obj
    	del src\shapefiles\*.obj
    	del src\spatialite\*.obj
    	del src\srsinit\*.obj
    	del src\versioninfo\*.obj
    	del src\virtualtext\*.obj
    	del src\wfs\*.obj
    	del src\dxf\*.obj
    	del src\md5\*.obj
    	del src\topology\*.obj
    	del src\stored_procedures\*.obj
    	del *.pdb
    
    install: all
    	-mkdir $(INSTDIR)
    	-mkdir $(INSTDIR)\bin
    	-mkdir $(INSTDIR)\lib
    	-mkdir $(INSTDIR)\include
    	-mkdir $(INSTDIR)\include\spatialite
    	copy *.dll $(INSTDIR)\bin
    	copy *.lib $(INSTDIR)\lib
    	copy src\headers\spatialite.h $(INSTDIR)\include
    	copy src\headers\spatialite\*.h $(INSTDIR)\include\spatialite
    

主要修改了以下两点：

1.  修改include文件：

    CFLAGS = /nologo -I.\src\headers -I.\src\topology \
    	-I. -IC:\Work\3rdparty\include -IC:\Work\3rdparty\include\libxml2 $(OPTFLAGS)
    

2.  修改依赖库文件：

    spatialite_i.lib:     $(LIBOBJ)
    	link /dll /out:$(SPATIALITE_DLL) \
    		/implib:spatialite_i.lib $(LIBOBJ) \
    		C:\Work\3rdparty\lib\proj.lib C:\Work\3rdparty\lib\geos_c.lib \
    		C:\Work\3rdparty\lib\freexl_i.lib C:\Work\3rdparty\lib\iconv.lib \
    		C:\Work\3rdparty\lib\sqlite3.lib C:\Work\3rdparty\lib\zlib.lib \
    		C:\Work\3rdparty\lib\libxml2.lib C:\Work\3rdparty\lib\librttopo.lib
    	if exist $(SPATIALITE_DLL).manifest mt -manifest \
    		$(SPATIALITE_DLL).manifest -outputresource:$(SPATIALITE_DLL);2
    

都修改完成之后，执行：

    nmake -f makefile.vc  #构建
    nmake -f makefile.vc install  #安装
    nmake -f makefile.vc clean	#清理
    

3.2 依赖项
-------

需要注意的是，`makefile64.vc`中的内容需要根据依赖库的安装地址来进行修改。SpatiaLite的依赖项有：proj、geos、freexl、iconv、sqlite3、zlib、libxml2以及librttopo，这些依赖项都需要提前安装好，笔者是安装到`C:\Work\3rdparty`目录中。至于具体的构建安装过程，大部分依赖库可参看如下文章：

1.  [《CMake构建学习笔记24-使用通用脚本构建PROJ和GEOS》](https://charlee44.com/post.html?id=8c8a0de027bd4b2ea08c238ab2cc6931)
2.  [《CMake构建学习笔记20-iconv库的构建》](https://charlee44.com/post.html?id=79759dac638b4f4c9eaa0642f97af3d7)
3.  [《CMake构建学习笔记23-SQLite库的构建》](https://charlee44.com/post.html?id=d5f3c74d4f6f4bd493cda842240746a9)
4.  [《CMake构建学习笔记2-zlib库的构建》](https://charlee44.com/post.html?id=22be62bbb76047da9a3489eb470bab8c)
5.  [《CMake构建学习笔记22-libxml2库的构建》](https://charlee44.com/post.html?id=4ed62c995d144bc1bf3751ac2d021e7d)

剩下的就只有freexl和librttopo两个依赖性的构建了，正好这两个也是依赖于nmake构建的库。

### 3.2.1 构建libexpat

在构建freexl之前，需要先构建libexpat库。libexpat是一个用C语言编写的、开源的、高效的XML解析库，已经支持使用CMake构建。那么可以使用以下脚本：

    param(    
        [string]$Name = "libexpat-R_2_7_0",
        [string]$SourceDir = "../Source",
        [string]$Generator,
        [string]$MSBuild,
        [string]$InstallDir,  
        [string]$SymbolDir 
    )
    
    # 根据 $Name 动态构建路径
    $zipFilePath = Join-Path -Path $SourceDir -ChildPath "$Name.zip"
    $SourcePath = Join-Path -Path $SourceDir -ChildPath $Name
    $BuildDir = Join-Path -Path "." -ChildPath $Name
    
    # 检查是否已经安装（通过目标 DLL）
    $TargetDll = "$InstallDir/bin/libexpat.dll"
    if (-not $Force -and $TargetDll -and (Test-Path $TargetDll)) {
        Write-Output "Library already installed: $TargetDll"
        exit 0
    }
    
    # 确保源码目录存在：解压 ZIP
    if (!(Test-Path $SourcePath)) {
        if (!(Test-Path $zipFilePath)) {
            Write-Error "Archive not found: $zipFilePath"
            exit 1
        }
        Write-Output "Extracting $zipFilePath to $SourceDir..."
        Expand-Archive -LiteralPath $zipFilePath -DestinationPath $SourceDir -Force
    }
    
    # 如果是强制构建，且构建目录已存在，先删除旧的构建目录（确保干净构建）
    if ($Force -and (Test-Path $BuildDir)) {
        Write-Output "Force mode enabled. Removing previous build directory: $BuildDir"
        Remove-Item $BuildDir -Recurse -Force -ErrorAction SilentlyContinue
    }
    
    # # 复制符号库
    $PdbFiles = @(
         "$BuildDir/RelWithDebInfo/libexpat.pdb"
    ) 
    
    # 额外构建参数
    $CMakeCacheVariables = @{
        EXPAT_BUILD_DOCS = "OFF"
        EXPAT_BUILD_EXAMPLES = "OFF"
        EXPAT_BUILD_TESTS = "OFF"
    }
    
    # 调用通用 CMake 构建脚本
    $cmakeSourcePath = Join-Path -Path $SourcePath -ChildPath "expat"
    Write-Output "Starting build for $Name..."
    . ./cmake-build.ps1 -SourceLocalPath $cmakeSourcePath `
        -BuildDir $BuildDir `
        -Generator $Generator `
        -InstallDir $InstallDir `
        -SymbolDir $SymbolDir `
        -PdbFiles $PdbFiles `
        -CMakeCacheVariables $CMakeCacheVariables `
        -MultiConfig $true  
    
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Build failed for $Name."
        exit $LASTEXITCODE
    }
    
    # 构建成功后，根据 Cleanup 开关决定是否删除
    if ($Cleanup) {
        Write-Output "Build succeeded. Cleaning up temporary directories..."
        if (Test-Path $SourcePath) { 
            Remove-Item $SourcePath -Recurse -Force -ErrorAction SilentlyContinue 
            Write-Output "Removed source directory: $SourcePath"
        }
        if (Test-Path $BuildDir) { 
            Remove-Item $BuildDir -Recurse -Force -ErrorAction SilentlyContinue 
            Write-Output "Removed build directory: $BuildDir"
        }
    }
    
    Write-Output "Build completed for $Name."
    

脚本`cmake-build.ps1`笔者已经在[《CMake构建学习笔记21-通用的CMake构建脚本》](https://charlee44.com/post.html?id=b968d5152f914d6689c3aebb5facce39)这篇文章中介绍过。

### 3.2.1 freexl构建

freexl是一个开源库，主要用于读取Microsoft Excel的.xls文件格式。构建freexl与前面介绍nmake构建的一般方法基本一致：

    nmake -f makefile.vc  #构建
    nmake -f makefile.vc install  #安装
    nmake -f makefile.vc clean	#清理
    

当然`nmake64.opt`和`makefile64.vc`中的内容需要根据自己的情况按需修改。对于`nmake64.opt`，修改的内容为：

    #INSTDIR=C:\OSGeo4W64
    INSTDIR=C:\OSGeo4W64
    

而对于`makefile64.vc`，修改的内容为：

    # CFLAGS	=	/nologo -I. -Iheaders -IC:\OSGeo4W64\include $(OPTFLAGS)
    CFLAGS	=	/nologo -I. -Iheaders -IC:\Work\3rdparty\include $(OPTFLAGS)
    
    #freexl_i.lib:	$(LIBOBJ)
    #	link /debug /dll /out:$(FREEXL_DLL) \
    #		/implib:freexl_i.lib $(LIBOBJ) \
    #		C:\Work\3rdparty\lib\iconv.lib \
    #		C:\Work\3rdparty\lib\libexpat.lib \
    #		C:\Work\3rdparty\lib\minizip.lib \
    #		C:\Work\3rdparty\lib\zlib.lib
    #	if exist $(FREEXL_DLL).manifest mt -manifest \
    #		$(FREEXL_DLL).manifest -outputresource:$(FREEXL_DLL);2 
    freexl_i.lib:	$(LIBOBJ)
    	link /debug /dll /out:$(FREEXL_DLL) \
    		/implib:freexl_i.lib $(LIBOBJ) \
    		C:\OSGeo4w64\lib\iconv.lib \
    		C:\OSGeo4W64\lib\libexpat.lib \
    		C:\OSGeo4W64\lib\libminizip.lib \
    		C:\OSGeo4w64\lib\zlib.lib
    	if exist $(FREEXL_DLL).manifest mt -manifest \
    		$(FREEXL_DLL).manifest -outputresource:$(FREEXL_DLL);2
    

### 3.2.1 librttopo构建

librttopo是一个开源的地理空间操作库，是PostGIS项目的一部分，提供了一系列用于处理和分析地理数据的功能，比如几何图形的操作、空间关系判断、坐标转换等。librttopo使用nmake构建有点麻烦，主要原因就是跨平台兼容性有点问题，在Windows下有些文件没有生成导致编译出错。

可以使用这篇[文章](https://www.gaia-gis.it/gaia-sins/msvc_how_to.html)中提供了一个源代码版本，然后按需修改`nmake64.opt`：

    #INSTDIR=C:\OSGeo4W64
    INSTDIR=C:\Work\3rdparty
    

同样修改`makefile64.vc`：

    #CFLAGS	=	/nologo -IC:\OSGeo4W64\include -I. -Iheaders $(OPTFLAGS)
    CFLAGS	=	/nologo -IC:\Work\3rdparty\include -I. -Iheaders $(OPTFLAGS)
    
    #librttopo_i.lib:	$(LIBOBJ)
    #	link /debug /dll /out:$(LIBRTTOPO_DLL) \
    #		/implib:librrttopo_i.lib $(LIBOBJ) \
    #		C:\OSGeo4W64\lib\geos_c.lib
    #	if exist $(LIBRTTOPO_DLL).manifest mt -manifest \
    #		$(LIBRTTOPO_DLL).manifest -outputresource:$(LIBRTTOPO_DLL);2
    librttopo_i.lib:	$(LIBOBJ)
    	link /debug /dll /out:$(LIBRTTOPO_DLL) \
    		/implib:librrttopo_i.lib $(LIBOBJ) \
    		C:\Work\3rdparty\lib\geos_c.lib
    	if exist $(LIBRTTOPO_DLL).manifest mt -manifest \
    		$(LIBRTTOPO_DLL).manifest -outputresource:$(LIBRTTOPO_DLL);2
    

三个nmake构建库修改的配置文件内容大致差不多，都是修改安装目录，修改依赖库include目录，修改链接的库文件，然后执行：

    nmake -f makefile.vc  #构建
    nmake -f makefile.vc install  #安装
    nmake -f makefile.vc clean	#清理
    

4\. 问题
======

如文中所说，这种nmake构建的方式有个很大的问题就是总是需要临时修改`nmake64.opt`和`makefile64.vc`来应对不同的环境，这对于使用脚本自动批处理的方式来说不太友好。说白了Windows下所有的逻辑都是基于GUI的，nmake不过是个临时补丁。不过理论上也可以考虑使用环境变量的方式来避免这个问题，就留待后续解决了。