---
layout: post
title: 'LLM调用的最佳数据格式：TOON，成本直降50%｜附Java使用指南'
date: "2025-11-15T00:41:26Z"
---
LLM调用的最佳数据格式：TOON，成本直降50%｜附Java使用指南
===================================

在大模型逐渐融入业务系统的阶段，结构化数据输入/输出已成为落地应用的必需：RAG 检索结果、Agent 工具调用参数、业务查询结果、批处理列表等都需要让自然语言与“可机读”的结构化格式互通。事实标准是 JSON，但在高频调用、海量数据场景下，JSON 的标点开销会显著推高 token 成本。

如下JSON格式的例子：

    {
      "users": [
        {"id": 1, "name": "Alice", "role": "admin"},
        {"id": 2, "name": "Bob", "role": "user"}
      ]
    }
    

Tokens 为 **47**:

采用 TOON 格式之后，内容明显减少：

    users[2]{id,name,role}:
      1,Alice,admin
      2,Bob,user
    

Tokens 为：**24**

差异的核心在于：TOON 用“缩进 + 一次性字段声明”的方式消除了绝大部分语法标点的冗余；当你在生产环境每天传输成千上万条记录时，冗余标点的累计开销会直接转化为可观的 API 费用。实践表明，TOON 在输入侧常带来 40–60% 的 token 节省。

基准测试：TOKEN减少、准确率上升
------------------

TOON格式在LLM调用时候除了在Token数量上的优化之外，不可忽略的是LLM检索准确率。如果单纯Token数量减少了，而准确率下降了，那意义就不大了。

以下是TOON官方仓库给出的综合效率排名：

    TOON           ████████████████████   26.9  │  73.9% acc  │  2,744 tokens
    JSON compact   █████████████████░░░   22.9  │  70.7% acc  │  3,081 tokens
    YAML           ██████████████░░░░░░   18.6  │  69.0% acc  │  3,719 tokens
    JSON           ███████████░░░░░░░░░   15.3  │  69.7% acc  │  4,545 tokens
    XML            ██████████░░░░░░░░░░   13.0  │  67.1% acc  │  5,167 tokens
    

TOON 的准确率达到 73.9% （JSON 的准确率为 69.7%），同时使用的标记数减少了 39.6% 。可以看到TOON不仅在Token数量上有优势，在准确率上也有明显优势，更多基准测试结果请参考TOON官方仓库。

什么时候不用 TOON
-----------

TOON 格式在处理统一类型的对象数组时表现出色，但在某些情况下，其他格式更为合适：

*   嵌套过深或结构不规则 （表格适用性 ≈ 0%）：JSON-compact 通常使用较少的标记。例如：具有多个嵌套层的复杂配置对象。
*   半均匀数组 （约 40-60% 符合表格格式）：Token节省量减少。如果您的pipline已经依赖于 JSON，则建议优先使用 JSON。
*   纯表格数据 ：对于平面表格，CSV 比 TOON 格式文件更小。TOON 格式仅需少量额外开销（约 5-10%）即可提供结构信息（数组长度声明、字段头、分隔符作用域），从而提高 LLM 的可靠性。
*   对延迟要求严格的应用 ：如果端到端响应时间是您的首要考虑因素，请在您的实际环境中进行基准测试。某些部署（尤其是像 Ollama 这样的本地/量化模型）即使 TOON 的Token数量较少，处理紧凑型 JSON 的速度也可能更快。请测量两种格式的 TTFT、每秒Token数和总时间，并使用速度更快的格式。

Java 中如何使用 TOON
---------------

对于数据格式转换，各主流语言都有好用的SDK可以直接拿来使用。以Java为例，可以使用：

    <dependency>
        <groupId>com.felipestanzani</groupId>
        <artifactId>jtoon</artifactId>
        <version>0.1.2</version>
    </dependency>
    

用法也是非常简单，核心API如下：

    // Java 对象 → TOON 字符串
    String toon = JToon.encode(object);
    
    // JSON 字符串 → TOON
    String toon = JToon.encodeJson(jsonString);
    
    // TOON → Java 对象
    Object obj = JToon.decode(toonString);
    
    // TOON → JSON 字符串
    String json = JToon.decodeToJson(toonString);
    

小结
--

本文介绍了LLM调用时JSON格式调用在Token消耗的劣势，从而引出TOON格式。对于合适场景，如果目前Token消耗量偏高的应用，可以考虑在数据格式上进行优化，从而实现成本的优化。目前你都用什么格式呢？是否有用过TOON呢？留言区可以聊一聊。

> 更多技术干货分享可以关注[我的代码世界](https://didispace.com/)