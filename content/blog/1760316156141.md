---
layout: post
title: '一生一芯学习：多道程序 yield-os.c'
date: "2025-10-13T00:42:36Z"
---
一生一芯学习：多道程序 yield-os.c
======================

随着处理器主频的越来越高，每次读写一次磁盘要耗费很多个时钟周期来等待磁盘操作的完成，与其傻傻等待，在这等待的过程中我们可以做更多有意义的事情，如当第一个程序需要等待输入输出的时候，切换到第二个程序来运行，第二个程序也等待输入输出的时候就可以切换到第三个程序，以此类推。

这就是**多道程序**的思想，要实现一个多道程序操作系统, 我们只需要实现以下两点就可以了:

1.  `在内存中可以同时存在多个进程`
2.  `在满足某些条件的情况下, 可以让执行流在这些进程之间切换`

什么是进程？ 进程 = 程序 + 执行

进程是执行中的程序，除了可执行代码外还包含进程的活动信息和数据，比如用来存放函数变量、局部变量、返回值的用户栈，存放进程相关数据的数据段，内核中进程间切换的内核栈，动态分配的堆。

**上下文切换**

在`yield-os.c`中构建了两个执行流，不断交替输出A和B，基本原理就是进程A运行的时候触发了系统调用，通过自陷指令陷入到内核中，根据`__am_asm_trap()`,A的上下文结构(Context)将会被保存在A的栈上。系统调用完后通过`__am_asm_trap()`恢复A的上下文，如果此时不恢复A的上下文，而是恢复B的上下文，那么执行完`__am_asm_trap()`

来看下`yield-os.c`执行流是如何进行进程切换的。首先贴出它的代码。

这个`PCB`是`union`类型的，而不是`struct`类型的，原因如下：定义数据的时候把PCB的`stack`栈空间和`cp` 记录上下文指针的元数据存放在同一块内存上。即pcb.stack占满整个PCB内存,然后PCB.CP放在内存的栈底。这样在上下文恢复时用 cp 指向的地址就能直接恢复栈上保存的 Context。

    #define STACK_SIZE (4096 * 8)
    typedef union {
      uint8_t stack[STACK_SIZE];
      struct { Context *cp; };  //(context pointer)来记录上下文结构的位置
    } PCB;
    
    int main() {
     
      cte_init(schedule);
      pcb[0].cp = kcontext((Area) { pcb[0].stack, &pcb[0] + 1 }, f, (void *)1L);
      pcb[1].cp = kcontext((Area) { pcb[1].stack, &pcb[1] + 1 }, f, (void *)2L);
      yield();
      panic("Should not reach here!");
    }
    

第一件事先初始化一下CTE  
cte\_init`的作用是定义了待会跳转去异常处理的地址传给mtvec，然后注册回调函数`shedule\`

    bool cte_init(Context*(*handler)(Event, Context*)) {
     // initialize exception entry
     asm volatile("csrw mtvec, %0" : : "r"(__am_asm_trap));  //把amasmtrap的地址传给mtvec
    
     user_handler = handler;
    
     return true;
    }
    

这个

    static Context *schedule(Event ev, Context *prev) {
      current->cp = prev; 
      current = (current == &pcb[0] ? &pcb[1] : &pcb[0]);
      return current->cp;
    }
    

然后把执行完`cte_init(schedule)`之后到了

      pcb[0].cp = kcontext((Area) { pcb[0].stack, &pcb[0] + 1 }, f, (void *)1L);
      pcb[1].cp = kcontext((Area) { pcb[1].stack, &pcb[1] + 1 }, f, (void *)2L);
    

先来看下`kcontext()`的代码。第一个参数`{ pcb[0].stack, &pcb[0] + 1 }`就是栈空间，随后将函数名当成指针，函数f 会自动“退化”为指向该函数的指针。于是此时entry就是f了。如果指针后面赋值为mepc=(uintptr\_t)entry，那么就会自动执行函数f，带上参数1。  
下一行同理

    Context *kcontext(Area kstack, void (*entry)(void *), void *arg) {
      Context *cp = (Context *)(kstack.end - sizeof(Context));
      cp->mepc = (uintptr_t)entry;
      cp->mstatus = 0x1800;
      cp->gpr[10] = (uintptr_t)arg;   //a0传参
      return cp;
    }
    

随后陷入`yield()`

    void yield() {
    #ifdef __riscv_e
      asm volatile("li a5, -1; ecall");
    #else
      asm volatile("li a7, -1; ecall");
      
    #endif
    }
    

于是进行`ecall`指令

      INSTPAT("0000000 00000 00000 000 00000 11100 11", ecall  , I, s->dnpc = isa_raise_intr(11,s->pc);etrace());
    

然后调用`isa_raise_intr(11,s->pc)`函数。

    word_t isa_raise_intr(word_t NO, vaddr_t epc) {
      /* TODO: Trigger an interrupt/exception with ``NO''. 待办事项：使用“NO”触发中断/异常。
       * Then return the address of the interrupt/exception vector. 然后返回中断/异常向量的地址
       */
      cpu.mstatus = 0x00001800; 
      cpu.mepc = epc; 
      cpu.mcause = NO;
      return cpu.mtvec;
    }
    

此时PC会跳转到之前定义的`mtvec`中，也就是`cte_init`中的`__am_asm_trap`函数。

    __am_asm_trap:
      addi sp, sp, -CONTEXT_SIZE
    
      MAP(REGS, PUSH)
    
      csrr t0, mcause
      csrr t1, mstatus
      csrr t2, mepc
    
      STORE t0, OFFSET_CAUSE(sp)
      STORE t1, OFFSET_STATUS(sp)
      STORE t2, OFFSET_EPC(sp)
    
      # set mstatus.MPRV to pass difftest
      li a0, (1 << 17)
      or t1, t1, a0
      csrw mstatus, t1
    
      mv a0, sp
      call __am_irq_handle
    
      mv sp, a0
      LOAD t1, OFFSET_STATUS(sp)
      LOAD t2, OFFSET_EPC(sp)
      csrw mstatus, t1
      csrw mepc, t2
    
      MAP(REGS, POP)
    
      addi sp, sp, CONTEXT_SIZE
      mret
    

这个函数作用之前讲过了，将上下文保存在栈上，然后调用`handler`之后还原现场，但此时我们把a0作为参数给sp，那就能做到线程切换，具体来看代码。会跳转到`__am_irq_handle`这个函数，看看他的源码。

    Context* __am_irq_handle(Context *c) {
      if (user_handler) {
        Event ev = {0};
        switch (c->mcause) {
          case 11:
                ev.event=EVENT_YIELD;
                if(c->GPR1!=-1)
                    ev.event = EVENT_SYSCALL;
                c->mepc += 4;
                break;
          default: ev.event = EVENT_ERROR; break;
        }
        //printf("mcause = %s\n",c->mcause);
        c = user_handler(ev, c);    //调用之前注册的handler
         assert(c != NULL);
      }
      return c;
    }
    

目前识别出是yield之后然后调用之前注册的回调函数。也就是`shedule`

    static Context *schedule(Event ev, Context *prev) {
      current->cp = prev; 
      current = (current == &pcb[0] ? &pcb[1] : &pcb[0]);
      return current->cp;
    }
    

可以看到`cte_init()`在trace中是这么传递参数的。

意思就是根据riscv地abi切换a0的值，也就是切换线程，随后

      mv sp, a0
      LOAD t1, OFFSET_STATUS(sp)
      LOAD t2, OFFSET_EPC(sp)
      csrw mstatus, t1
      csrw mepc, t2
    
      MAP(REGS, POP)
    
      addi sp, sp, CONTEXT_SIZE
      mret
    

恢复现场，切换为B线程，也就是所有寄存器，什么通用寄存器堆，mepc,mcause, mstatus, mepc都一模一样。

然后调用`mret`，pc变成cpu.mepc，于是跳到刚刚kcontext定义的entry中，也就是f函数里面，然后判断参数是多少进行对应的输出之后又陷入到`yield`，一直循环。