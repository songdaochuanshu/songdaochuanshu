---
layout: post
title: 'auipc指令在NEMU中的执行过程'
date: "2025-10-17T00:40:08Z"
---
auipc指令在NEMU中的执行过程
==================

auipc指令在NEMU中的执行过程

假设
--

1.  指令集为RV64I
    
2.  内存地址开始于`0x8000 0000`
    
3.  使用如下的代码：
    
        static const uint32_t img [] = {
            0x00000297,  // auipc t0,0
            0x00028823,  // sb  zero,16(t0)
            0x0102c503,  // lbu a0,16(t0)
            0x00100073,  // ebreak (used as nemu_trap)
            0xdeadbeef,  // some data
        };
        
    
4.  `Decode`的定义如下
    
        typedef struct Decode {
            uint64_t pc;
            uint64_t snpc; // static next pc
            uint64_t dnpc; // dynamic next pc
            struct {
                uint32_t inst;
            } isa;
        } Decode;
        
    
5.  `cpu.pc`初始值为`0x8000 0000`
    
6.  从调用`exec_once()`并开始执行`auipc`开始考虑
    
7.  忽略trace和difftest相关的操作
    

exec\_once(&s, cpu.pc);
-----------------------

调用`exec_once(&s, cpu.pc)`，当前`cpu.pc`值为`0x8000 0000`

进入`exec_once()`后，更新`s`：

    s->pc = 0x80000000;
    s->snpc = 0x80000000;
    

调用`isa_exec_once(s)`

isa\_exec\_once(s)
------------------

利用`inst_fetch(&s->snpc, 4)`更新`s`。`inst_fetch`返回`snpc`对应的指令地址（`uint32_t`类型）,并且更新`snpc`为下一条指令所在地址(`s->snpc += 4`, 即`0x8000 0004`)。  
更新后的`s`:

    s->pc = 0x80000000;
    s->snpc = 0x80000004;
    s->isa.inst = 0x80000000;
    

之后执行`decode_exec(s)`并将其结果返回.

decode\_exec(s)
---------------

更新`s->dnpc = s->snpc`, 此时`s`:

    s->pc = 0x80000000;
    s->snpc = 0x80000004;
    s->dnpc = 0x80000004;
    s->isa.inst = 0x80000000;
    

定义**标签地址**, 用于之后跳转:

    const void * __instpat_end = &&__instpat_end_;
    

指令匹配:

    INSTPAT("??????? ????? ????? ??? ????? 00101 11", auipc  , U, R(rd) = s->pc + imm);
    INSTPAT("??????? ????? ????? 100 ????? 00000 11", lbu    , I, R(rd) = Mr(src1 + imm, 1));
    INSTPAT("??????? ????? ????? 000 ????? 01000 11", sb     , S, Mw(src1 + imm, 1, src2));
    
    INSTPAT("0000000 00001 00000 000 00000 11100 11", ebreak , N, NEMUTRAP(s->pc, R(10))); // R(10) is $a0
    INSTPAT("??????? ????? ????? ??? ????? ????? ??", inv    , N, INV(s->pc));
    

### INSTPAT() 指令匹配宏

宏展开后, 匹配成功第一条规则:

    do {
        uint64_t key, mask, shift;
        pattern_decode("??????? ????? ????? ??? ????? 00101 11",
            (sizeof("??????? ????? ????? ??? ????? 00101 11") - 1), &key, &mask, &shift);
        if ((((uint64_t)((s)->isa.inst) >> shift) & mask) == key) {
            {
                int rd = 0;
                word_t src1 = 0, src2 = 0, imm = 0;
                decode_operand(s, &rd, &src1, &src2, &imm, TYPE_U);
                (cpu.gpr[check_reg_idx(rd)]) = s->pc + imm ;
            };
            goto *(__instpat_end);
        }
        } while (0)
    

其中`(sizeof("??????? ????? ????? ??? ????? 00101 11") - 1) == 38`

### pattern\_decode() 解码宏

进入`pattern_decode()`宏后, 定义临时变量`uint64_t __key = 0, __mask = 0, __shift = 0;`. 之后`pattern_decode()` 会利用辅助宏`macro(i)`.  
在`macro(i)`中:

1.  若`str[i]`是`'1'`, `__key`左移并且低位补1; 若不是, `__key`左移并且低位补0;
2.  若`str[i]`是`'?'`, `__mask`左移并且低位补0;  
    若不是, `__mask`左移并且低位补1
3.  若`str[i]`是`'?'`, `__shift`加1, 否则立刻清0

通过:

    #define macro2(i)  macro(i);   macro((i) + 1)
    #define macro4(i)  macro2(i);  macro2((i) + 2)
    #define macro8(i)  macro4(i);  macro4((i) + 4)
    #define macro16(i) macro8(i);  macro8((i) + 8)
    #define macro32(i) macro16(i); macro16((i) + 16)
    #define macro64(i) macro32(i); macro32((i) + 32)
      macro64(0);
    

处理指令掩码中的38个字符.  
本例中, `__key`最终为`0010111`, `__mask`最终为`000...00(共25个0)1111111`, `__shift`最终为`0`  
跳转到`finish`标签后执行:

    finish:
      *key = __key >> __shift;
      *mask = __mask >> __shift;
      *shift = __shift;
    

然后退出`pattern_decode()`宏, 进入`INSTPAT`宏的:

    if ((((uint64_t)INSTPAT_INST(s) >> shift) & mask) == key) { \
    INSTPAT_MATCH(s, ##__VA_ARGS__); \
    goto *(__instpat_end); \
    } \
    

`(uint64_t)INSTPAT_INST(s)`即执行的指令`inst`. `inst`被右移`shift`位, 然后和`mask`按位与, 判断是否和`key`完全相等  
如果相等, 则执行:

    INSTPAT_MATCH(s, ##__VA_ARGS__); \
    goto *(__instpat_end); \
    

### ISNT\_MATCH() 执行指令宏

在这个宏里, 会利用`decode_operand()`函数来译码出`rd`, `src`, `src2`, `imm`. 然后执行`__VA_ARGS__ ;`. `__VA_ARGS__`就是在`INSTPAT()`中传入的指令的具体操作. 对于`auipc`这条指令, `__VA_ARGS`就是`R(rd) = s->pc + imm`.