---
layout: post
title: 'LLVM Pass快速入门(四)：代码插桩'
date: "2026-02-05T00:57:51Z"
---
LLVM Pass快速入门(四)：代码插桩
=====================

从0到1，快速入门 LLVM pass 编写

代码插桩
====

项目需求：在函数运行时打印出运行的函数名

项目目录如下
======

    /MyProject
    ├── CMakeLists.txt # CMake 配置文件
    ├── build/ #构建目录
    │   └── test.c #测试编译代码
    └── mypass3.cpp # pass 项目代码
    

### 一，测试代码示例

**test.c**

    #include <stdio.h>
    
    void func_A() {
        int a = 1;
    }
    
    void func_B() {
        func_A();
    }
    
    int main() {
        printf("hello world!\n");
        func_A();
        func_B();
        return 0;
    }
    

### 二，编写Pass

其他的固定的模板之前文章注释有，这里我只注释当前项目重要的部分  
**代码流程：** 遍历指令并匹配`ADD`指令->替换为`sub`指令

    #include "llvm/IR/PassManager.h"
    #include "llvm/Passes/PassBuilder.h"
    #include "llvm/Passes/PassPlugin.h"
    #include "llvm/Support/raw_ostream.h"
    #include "llvm/IR/Function.h"
    #include "llvm/IR/BasicBlock.h"
    #include "llvm/IR/Instruction.h"
    #include "llvm/IR/Instructions.h"
    #include "llvm/IR/IRBuilder.h" 
    
    using namespace llvm;
    
    namespace {
    
    struct mypass3 : public PassInfoMixin<mypass3> {
        
        PreservedAnalyses run(Function &F, FunctionAnalysisManager &) {
            //过滤函数
            //过滤掉printf和printf有关的函数，防止在printf中插入printf造成递归（死循环）
            if(F.isDeclaration() || F.getName().starts_with("_") || F.getName().contains("printf")){
                return PreservedAnalyses::all();
            }
            errs() << "handle func:" << F.getName() << "\n";
    		
    		//获取模块
            Module *M = F.getParent();
            //获取模块上下文
            //上下文中包含了数据的类型
            LLVMContext &Ctx = M->getContext();
            
            //下面是创建函数，类比java反射，或者frida的hook
            //定义printf的参数类型，相当于函数括号中的内容，这里的PointerType是指针类型
            std::vector<Type*> printfArgs = {PointerType::getUnqual(Ctx)};
    		//定义函数类型，这里相当于定义：int (void*, ...)
            FunctionType *printfType = FunctionType::get(
                Type::getInt32Ty(Ctx),//函数返回值类型
                printfArgs,//函数的参数类型(vector)
                true//是否是可变参数
            );
    		//如果printf存在则引用，如果不存在，则创建一个新的printf
            FunctionCallee printfFunc = M->getOrInsertFunction("printf", printfType);
    		
    		//下面是插入函数
    		//将修改的位置定位到要插桩函数的头部
            IRBuilder<> builder(&F.getEntryBlock().front());
            //声明全局变量（这里是要传给printf的格式化字符串）
            Value* formatStr = builder.CreateGlobalStringPtr(">> enter function %s <<\n", "my_format");
            //声明全局变量，这里定义了函数名称的字符串变量
            Value* funcName = builder.CreateGlobalStringPtr(F.getName(), "my_func_name");
            //将上面定义的实际参数传入
            std::vector<Value*> printfArgsVec = {formatStr, funcName};
            //创建函数调用
            builder.CreateCall(printfFunc, printfArgsVec);
            
            return PreservedAnalyses::none();
        }
    };
    
    } 
    
    extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo
    llvmGetPassPluginInfo() {
        return {
            LLVM_PLUGIN_API_VERSION,
            "mypass3",
            "v0.1",
            [](PassBuilder &PB) {
                PB.registerPipelineParsingCallback(
                    [](StringRef Name, FunctionPassManager &FPM,
                       ArrayRef<PassBuilder::PipelineElement>) {
                        if (Name == "mypass3") {
                            FPM.addPass(mypass3());
                            return true;
                        }
                        return false;
                    });
            }};
    }
    

### 三，Pass的构建

**下面引用的是之前文章的内容**  
构建LLVM Pass需要写`CMakeLists.txt`构建声明

##### 1\. 配置CMake配置文件

**CMakeLists.txt**  
下面的`cmake`配置可以直接拿去用，我已经标注好需要修改的位置

    #cmake 版本，可通过 cmake --version 判断
    cmake_minimum_required(VERSION 4.1.1) #---->修改 cmake版本号
    #项目名字
    project(mypass3) #---->修改 项目名称
    
    #导入项目的 LLVM cmake 配置文件路径(如果根据我之前文章安装这里就相同)
    set(LLVM_DIR "D:/LLVM/llvm-project/build/lib/cmake/llvm")#---->修改 llvm cmake配置路径
    #寻找 LLVM 的包文件
    #REQUIRED 找不到 LLVM 则停止构建
    #强制使用 LLVM 安装时生成的配置文件进行定位
    find_package(LLVM REQUIRED CONFIG)
    #将 LLVM 的 CMake 模块路径添加到当前 CMake 搜索路径中，以便后续使用 include(AddLLVM)。
    list(APPEND CMAKE_MODULE_PATH "${LLVM_CMAKE_DIR}")
    
    #引入 LLVM 提供的专用 CMake 宏
    include(AddLLVM)
    #将 LLVM 的头文件目录（如 llvm/IR/Function.h）加入编译器的搜索路径
    include_directories(${LLVM_INCLUDE_DIRS})
    #导入 LLVM 编译时使用的宏定义
    add_definitions(${LLVM_DEFINITIONS})
    #设置 C++ 标准为 C++17。(这里如果不用17编译会报错)
    set(CMAKE_CXX_STANDARD 17)
    #强制要求必须支持 C++17，如果编译器不支持则失败。
    set(CMAKE_CXX_STANDARD_REQUIRED ON)
    
    #创建一个模块化的库(.dll)
    add_library(mypass3 MODULE mypass3.cpp) #---->修改 项目名称，文件名
    #windows不用会报错：导出符号
    #LLVM Pass 需要暴露一些特定的入口点（如 getAnalysisUsage）给 opt 工具调用。
    set_target_properties(mypass3 PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS ON) #---->修改 项目名称
    # 指定该 Pass 需要链接的 LLVM 核心组件。 
    # LLVMCore: 提供 IR、Function、Module 等核心类。 
    # LLVMSupport: 提供各种辅助工具类（如 errs() 输出）。
    target_link_libraries(mypass3 LLVMCore LLVMSupport) #---->修改 项目名称，文件名  
    # 为该目标设置特定的编译器选项。 
    # /utf-8: 告诉 MSVC 编译器使用 UTF-8 编码处理源代码，防止中文注释引起的乱码或编译错误。  
    target_compile_options(mypass3 PRIVATE /utf-8)#---->修改 项目名称，文件名
    

##### 2.编译并构建Pass

**打开visual studio`的工作台，我这里是`x64 Native Tools Command Prompt for VS 2022\`**

进到`build`目录

    #构建项目
    #其中-DCMAKE_BUILD_TYPE=RelWithDebInfo不选会报错，由于我之前编译的是带符号的relase版本
    cmake -G "Ninja"  -DCMAKE_BUILD_TYPE=RelWithDebInfo ..
    #编译
    ninja
    

最后出现下面提示，即为编译成功

    [2/2] Linking CXX shared module mypass3.dll
    

### 四，使用插桩Pass对源码进行插桩

进到`build`目录

    #把.c文件编译为.ll
    #-O1 使用O1优化（这里我尝试-O0不优化，会导致我的pass无法应用）
    #-Xclang -disable-llvm-passes 不使用默认的pass优化
    clang -S -emit-llvm -O1 -Xclang -disable-llvm-passes test.c -S -o test.ll
    
    #使用pass
    opt -load-pass-plugin=mypass3.dll -passes=mypass3  test.ll -S -o test_opt.ll
    
    #编译使用pass后的exe
    clang test_opt.ll -o test_opt.exe
    #编译使用pass前的exe
    clang test.ll -o test.exe
    

**输出结果**  
`运行test.exe`：**不使用**pass，输出结果如下：

    hello world!
    

`运行test_opt.exe`：**使用**pass后，输出结果如下：

    >> enter function main <<
    hello world!
    >> enter function func_A <<
    >> enter function func_B <<
    >> enter function func_A <<
    

**我们成功在我们调用函数之前插桩，打印出调用的函数**

**如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~**

本文来自博客园，作者：[ClownLMe](https://www.cnblogs.com/ClownLMe/)，转载请注明原文链接：[https://www.cnblogs.com/ClownLMe/p/19575719](https://www.cnblogs.com/ClownLMe/p/19575719)