---
layout: post
title: 'WxPython跨平台开发框架之主从表展示和录入的界面处理--产品报价单和明细记录的处理'
date: "2025-10-17T00:40:09Z"
---
WxPython跨平台开发框架之主从表展示和录入的界面处理--产品报价单和明细记录的处理
--------------------------------------------

我们在前面随笔《Vue3+ElementPlus的BS端主从表的快速开发》了解了Vue3+ElementPlus的BS端主从表的实现，了解了大概的设计和界面设计方式，我们现在切换一下，看看如何结合FastAPI+WxPython实现主从表界面的展示和编辑处理的。 FastAPI的后端采用控制器基类继承方式提供标准化接口，SqlALchemy提供的数据ORM管理，相关代码通过代码生成工具快速生成，包括后端的API接口定义类，SqlALchemy模型类、DTO对象类，以及前端的界面生成等工作。本篇随笔主要介绍WxPython跨平台开发框架之主从表展示和录入的界面处理--产品报价单和明细记录的处理。

我们在前面随笔《[Vue3+ElementPlus的BS端主从表的快速开发](https://www.cnblogs.com/wuhuacong/p/19138263)》了解了Vue3+ElementPlus的BS端主从表的实现，了解了大概的设计和界面设计方式，我们现在切换一下，看看如何结合FastAPI+WxPython实现主从表界面的展示和编辑处理的。

FastAPI的后端采用控制器基类继承方式提供标准化接口，SqlALchemy提供的数据ORM管理，相关代码通过代码生成工具快速生成，包括后端的API接口定义类，SqlALchemy模型类、DTO对象类，以及前端的界面生成等工作。本篇随笔主要介绍WxPython跨平台开发框架之主从表展示和录入的界面处理--产品报价单和明细记录的处理。

### 1、FastAPI实现主从表数据接口和SqlAlchemy的数据处理

WxPython跨平台开发框架全部采用Python语言进行开发，包括后端的内容，采用 基于SqlAlchemy+Pydantic+FastApi 的后端框架，FastAPI启动后，进入Swagger页面如下所示，列出每个业务表的相关接口。

![](https://img2024.cnblogs.com/blog/8867/202409/8867-20240924130101025-2019486625.png)

以上就是常规化的接口，包括单个获取、ID存在、条件查询、分页查询、数量查询、增加、删除、更新等标准化接口，这些基础类接口一般封装在API的控制器基类中。

该后端接口采用统一的接口协议，标准协议如下所示。

{
  "success": false,
  "result":  T ,
  "targetUrl": "string",
  "UnAuthorizedRequest": false,
  "errorInfo": {
    "code": 0,
    "message": "string",
    "details": "string"
  }
}

常规化的接口是结合泛型的方式，这样定义可以很好的抽象不同的业务类接口到基类控制器中，如下是FastApi 后端的基类控制器定义。

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251016094657253-1511663754.png)

 有了上面基类定义好的常规化接口，子类只需要继承基类控制器即可获得强大的功能接口了。

一般API控制器的子类，只需要继承基类就可以了，额外增加的接口按常规化的设计函数即可，可以参考基类的做法来写各种（GET、PUT、DELETE、POST）的处理函数。

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251016095108239-1440935466.png)

我们来看看对于产品报价单和明细记录的处理，这两个代表不同的业务表，我们可以分开管理，通过约束他们的记录关系实现主从表弹性化的管理。

如对于主表，我们在基类接口外定义多两个函数，主要就是删除主表的时候，同时移除明细记录的关联操作。

from fastapi import APIRouter, Depends, HTTPException, Query, Request, Path, Body

..................  
# 创建路由，用于处理自定义接口
router = APIRouter()

@router.get(
    "byorderno/{orderno}",
    response\_model\=AjaxResponse\[QuotationDto | None\],
    summary\="根据报价单编号获取对象信息",
    dependencies\=\[DependsJwtAuth\],
)
async def find\_by\_orderno(
    orderno: Annotated\[str | None, Path(description="订单编号")\],
    request: Request,
    db: AsyncSession \= Depends(get\_db),
):
    # ip = await get\_request\_ip(request)
    item = await quotation\_crud.get\_by\_column(db, "handno", orderno)
    item \= QuotationDto.model\_validate(item) if item else None
    return AjaxResponse(item)

@router.delete(
    "quotation-related/{id}",
    response\_model\=AjaxResponse\[bool | None\],
    summary\="删除报价单及明细信息",
    dependencies\=\[DependsJwtAuth\],
)
async def delete\_quotation\_related(
    id: Annotated\[str | None, Path(description="报价单ID")\],
    request: Request,
    db: AsyncSession \= Depends(get\_db),
):
    # ip = await get\_request\_ip(request)
    #获取记录信息
    item = await quotation\_crud.get(db, id)
    if not item:
        return AjaxResponse(False)

    # 删除相关的明细记录
    res = await quotationdetail\_crud.delete\_by\_column(db, "orderno", item.handno)
    if res:       
        # 再删除报价单
        await quotation\_crud.delete\_byid(db, id)
    return AjaxResponse(res)

# 使用基类控制器，可以继承常规CRUD的接口，并自动生成路由，依赖注入，数据库连接等功能 ——构建方式2
controller = BaseController\[Quotation, str, QuotationPageDto, QuotationDto\](
    quotation\_crud,
    pagedto\_class\=QuotationPageDto,
    dto\_class\=QuotationDto,
    router\=router,
)
controller.init\_router()  # 初始化常规CRUD等接口的路由

而报价单明细业务控制器，主要需要根据报价单号（订单号）获取明细的接口

from fastapi import APIRouter, Depends, HTTPException, Query, Request, Path, Body

from typing import Type, TypeVar, Generic, List, Dict, Any, Optional, Annotated
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession

from schemas.base import AjaxResponse, ErrorInfo, ListResult, PagedResult
from api.base\_controller import BaseController
from db.session\_async import get\_db
from common.jwt import DependsJwtAuth

from models.quotationdetail import QuotationDetail
from schemas.quotationdetail import QuotationDetailDto, QuotationDetailPageDto
from crud.quotationdetail import quotationdetail as quotationdetail\_crud
from crud.operationlog import operationlog as operationlog\_crud
from utils.request\_parse import get\_request\_ip

# 创建路由，用于处理自定义接口
router = APIRouter()

@router.get(
    "/by-orderno",
    response\_model\=AjaxResponse\[List\[QuotationDetailDto\] | None\],
    summary\="根据订单编号获取记录",
    dependencies\=\[DependsJwtAuth\],
)
async def get\_by\_orderno(
    orderno: Annotated\[str | None, Query(description="订单编号")\],
    request: Request,
    db: AsyncSession \= Depends(get\_db),
):
    # ip = await get\_request\_ip(request)
    items = await quotationdetail\_crud.get\_by\_orderno(db, orderno)
    # print(len(items))
    items = \[QuotationDetailDto.model\_validate(item) for item in items\]
    return AjaxResponse(items)

@router.delete(
    "/by-orderno/{orderno}",
    response\_model\=AjaxResponse\[bool | None\],
    summary\="根据订单编号删除所有明细记录",
    dependencies\=\[DependsJwtAuth\],
)
async def delete\_by\_orderno(
    orderno: Annotated\[str | None, Path(description="订单编号")\],
    request: Request,
    db: AsyncSession \= Depends(get\_db),
):
    res \= await quotationdetail\_crud.delete\_by\_attributes(db, QuotationDetail.orderno == orderno)
    return AjaxResponse(res)

# 使用基类控制器，可以继承常规CRUD的接口，并自动生成路由，依赖注入，数据库连接等功能 
controller = BaseController\[QuotationDetail, str, QuotationDetailPageDto, QuotationDetailDto\](
    quotationdetail\_crud,
    pagedto\_class\=QuotationDetailPageDto,
    dto\_class\=QuotationDetailDto,
    router\=router,
)
controller.init\_router()  # 初始化常规CRUD等接口的路由

由于基类控制器接口的标准化，我们根据框架后端的接口进行前端API调用类的封装处理，从而实现业务基类调用接口的统一封装，简化代码。这样增删改查等处理的接口都可以抽象到BaseApi里面了。

如对于权限模块，我们涉及到的用户管理、机构管理、角色管理、菜单管理、功能管理、操作日志、登录日志等业务类，那么这些类继承BaseApi，就会具有相关的接口了，如下所示继承关系。

![](https://img2020.cnblogs.com/blog/8867/202007/8867-20200713152737929-890201160.png)

### 2、基于SqlAlchemy实现的业务模型

FastAPI负责提供数据的API接口，底层的数据处理，通过SqlAlchemy + MongoDB 实现多种数据库的数据管理，如对于MySQL、Postgresql、SQLite、Oracle、MongoDB等进行接入和数据交换处理。

对于常规的业务表，我们采用SqlAlchemy实现数据库的ORM管理的，SqlAlchemy也是Python领域中非常强大的ORM管理模块之一, 它让你用 **Python 对象来操作数据库**，而不是手写 SQL 语句。

一般我们先定义好模型的基类，提供简单的封装

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251016101144230-1883745931.png)

 然后在业务类里面继承它即可

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251016100647277-339660946.png)

 报价单的明细表也是类似的

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251016101327015-2048136472.png)

这些模型类和对应接口的DTO类只需要在代码生成工具中进行一键生成就可以了，不用编写。

 在代码生成工具 [Database2Sharp](https://www.iqidi.com/database2sharp.htm)  打开数据库列表后，右键菜单可以选择生成对应的Python+FastApi后端项目，如下界面所示。

![](https://img2024.cnblogs.com/blog/8867/202412/8867-20241203105942996-1920544172.png)

选中相关的表后，一键可以生成各层的类文件，其中包括最为繁琐的Model映射类信息。如下是生成的相关类的界面效果。

![](https://img2024.cnblogs.com/blog/8867/202409/8867-20240924132826926-1882542884.png)

### 2、WxPthon实现基于Python桌面端主从表的数据处理

我们知道，一般对于单表来说，业务和界面会相对比较简单，如下面的界面效果，在Windows下客户信息的列表管理和数据编辑界面如下所示。

![](https://img2024.cnblogs.com/blog/8867/202412/8867-20241203120302214-463232027.png)

而对于主从表，一般除了主业务表外，会关联一个到多个的明细表，对于报价单来说，就只有一个明细表，如下所示是具体的界面列表展示。

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251015161712585-317398086.png)

对于列表的主从表关联关系，没有太多好说的，就是增加了一个明细表的处理展示

对于主从表编辑界面来说，就需要复杂处理一些，在表格需要直接编辑录入并保存明细的操作处理，如下是主从表的编辑界面的实现效果。

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251015161911167-1840409017.png)

其主要就是在第一次创建的时候，对表格数据类进行设置

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251016104543810-1687839480.png)

表格的数据直接录入，一般不是仅仅的通过文本框的录入，一般录入有选择表的记录，下拉类表、复选框、图像、数值、颜色等等特殊的录入的。

 如自定义数据列表选择界面，我通过定义一个产品的数据列表展示供选择，单击产品编码处，弹出一个选择框进行选择。

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251015162218443-1590695835.png)

为了实现对表格数据单元格的单击监控，我们绑定了对应的事件。

**AsyncBind**(wx.grid.EVT\_GRID\_CELL\_LEFT\_CLICK, self.on\_cell\_left\_click, self.sub\_grid)

然后对事件进行实现即可。

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251016105037344-164921934.png)

 下拉列表则是通过绑定固定列表，或者字典类型的方式实现字典下拉列表选择

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251015162347832-235980690.png)

初始化字典列表很容易，如下代码所示。

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251016104356263-1431900218.png)

 其他案例可以参考测试效果，支持多种数据输入处理，测试界面效果如下所示。

![image](https://img2024.cnblogs.com/blog/8867/202510/8867-20251015162715390-1980915131.png)

以上就是对于WxPython应用，结合前后端的处理，实现了主从表展示和录入的界面处理--产品报价单和明细记录的处理。

![](http://www.cnblogs.com/Images/OutliningIndicators/None.gif) 专注于代码生成工具、.Net/Python 框架架构及软件开发，以及各种Vue.js的前端技术应用。著有Winform开发框架/混合式开发框架、微信开发框架、Bootstrap开发框架、ABP开发框架、SqlSugar开发框架、Python开发框架等框架产品。  
  转载请注明出处：撰写人：伍华聪  [http://www.iqidi.com](http://www.iqidi.com/)     

posted on 2025-10-16 10:52  [伍华聪](https://www.cnblogs.com/wuhuacong)  阅读(221)  评论(0)    [收藏](javascript:void\(0\))  [举报](javascript:void\(0\))