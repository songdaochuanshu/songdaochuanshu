---
layout: post
title: '变量名越怪，JVM 越快？'
date: "2025-10-20T00:44:06Z"
---
变量名越怪，JVM 越快？
=============

在软件工程的共识里，变量命名越清晰越好——意图明确、语义完整、见名知意，这能降低沟通成本、减少误解、提升可维护性。几乎所有风格指南都把“有意义的命名”视为第一原则。

但今天读到的一篇文章[《Java Performs Better When You Misspell Variable Names》](https://medium.com/javarevisited/java-performs-better-when-you-misspell-variable-names-5b9709893121)，把这条铁律里的“性能部分”掀了桌：在 Java 的某些栈中，刻意缩短、甚至“错拼”的变量名，可能真的让服务更快。不是业务逻辑的变化，而是更短、更“随机”的名字在字符串常量池、哈希和反射路径上更省。在作者的压测里，吞吐提升最高接近 49%。这听起来反常识，但他用微基准、压测与分析器把它变成了一个严肃命题。

这事是怎么被发现的
---------

故事开始于一次“事故”。作者重构时不小心把 `customerEmail`、`orderHistory`、`totalAmount` 之类的变量写成了 `custEmil`、`ordrHstry`、`totlAmnt`。

    // 本来要写：
    private String customerEmail;
    private List<Order> orderHistory;
    private BigDecimal totalAmount;
    
    // 实际上线的是
    private String custEmil;
    private List<Order> ordrHstry;
    private BigDecimal totlAmnt;
    

结果第二天监控显示：平均延迟从 127ms 直接降到 80ms。作者起初怀疑是缓存偶然命中、网络波动或者测量误差，回滚到“整洁命名”，延迟又回到 127ms。这一来一回，逼着他把这件事当真。

于是他系统化地做了验证。用 JMH 写对照实验，两个版本代码逻辑完全一致，唯一变量是“命名长度与形态”：一个版本用规范、完整、可读的名字，另一个版本把元音删掉、前缀缩短、偶尔把名字变得更随机。然后是更接近生产的验证：把同样的策略应用到一个 Spring Boot 服务，在 1000 并发、60 秒的 JMeter 压测下对比两版吞吐和延迟。最后用分析器（如 YourKit）去看字符串相关热点到底是不是在下降。

数据与分析：不是“玄学”，而是成本栈里的一段被忽视的路
---------------------------

在微基准里，作者报告仅删除元音就能带来约 26% 的提升；而当名字更短、更“乱”（比如三四个字符的缩写或无意义组合），提升更明显。在压测里，平均响应从 143ms 降到 91ms，吞吐从 6847 req/s 到 10234 req/s，错误率不变。分析器则显示 `String.hashCode()` 的总耗时显著下降（调用次数一样），但短名字的总耗时少了近一秒（按 60 秒窗口）。

为什么可能成立？因为 JVM 的字符串常量池（String Table）是哈希表结构，反射、调试、堆栈、框架内省都会不断地触发对这些字符串的查找和哈希。长且前缀相似的名字更容易发生哈希碰撞，查找链更长，缓存局部性更差，GC 在标记-清除阶段扫描保留这批字符串的成本也更高。JIT 能优化计算，但它优化不掉字符串表、反射和 GC 的固定成本。短且更“随机”的名字，往往有更好的哈希分布，更低的碰撞率，更友好的缓存命中。

这也解释了一个让人不适的现实：**在反射密集的栈中（Spring、Hibernate、Jackson 等），名字并非“运行时免费”。在某些路径上，名字的长度与分布会成为可测的成本**。

我们该怎么办：命名，不再只是风格问题
------------------

知道这个结论之后，我们应该调整命名策略吗？我觉得应该，但只在该用的地方用，并且给它加上清晰的边界。

*   先剖析再动刀：用分析器定位字符串相关热点（例如反射入口、序列化/反序列化、框架内省、`StringTable`），确认它们确实在吃掉你的时间。
*   只在热点处调命名：把策略限定在高频反射和序列化的类型、字段、方法上；领域模型和业务规则保持可读性，别把团队协作变成解谜游戏。
*   保守优先、激进试点：
    *   保守档：删除明显元音、缩短前缀（`customerEmailAddress → cstmrEmlAdr`），目标增益 8–12%。
    *   激进档：更积极地缩短并弱化相似前缀（`orderHistoryList → ordrHstryLst`），目标增益 18–24%。
    *   极端档：三四字符的强缩写（`totalAmountPaid → tAP`），增益可能更高，但不建议用于生产的核心业务域。
*   搭配替代方案：能用代码生成/注解处理器替代反射就替代；序列化层选择更高效的实现；必要时微调 `-XX:StringTableSize` 并做对照验证。
*   工程化验证：设置可靠的基准（JIT 预热、固定参数、屏蔽 I/O 干扰），看 p95/p99 与吞吐的变化，再决定是否推广。

思考：数据与教条，谁该让步？
--------------

*   如果命名在某些栈里是成本，我们是否应该建立一份“热点命名策略”，像性能预算一样，允许在少数关键路径牺牲一点可读性来换取吞吐？
*   不同 JVM 版本、不同 GC 策略、不同框架组合下，这个效果是否一致？是否可以用工具链（重命名器、lint 规则、基准套件）把它做成可重复的实验？
*   当团队规模变大，命名的“可读性收益”和性能的“吞吐收益”如何折算到同一张成本表上？这是否应该由数据驱动，而不是由风格统一驱动？

小结
--

这篇文章让我重新审视了一个多年未变的前提：命名只是可读性问题。作者用微基准、压测和分析器把它变成了一个性能问题。在需要极致吞吐的系统里，名字可能不再只是“给人看的”，它也在影响“给机器跑的”。我的答案是：策略性地调整命名，但只在热点路径，并用数据而不是直觉做决定。毕竟，在工程世界里，漂亮的代码不一定是最快的代码，而我们有时需要的，是能顶住流量的那一段真实提升。