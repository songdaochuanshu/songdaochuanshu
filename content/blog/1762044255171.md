---
layout: post
title: 'PHP 组件未来：Livewire 4 正式发布，性能更快，功能更完整'
date: "2025-11-02T00:44:15Z"
---
PHP 组件未来：Livewire 4 正式发布，性能更快，功能更完整
===================================

PHP 组件未来：Livewire 4 正式发布，性能更快，功能更完整
===================================

盼了许久的 `Livewire 4` 终于发布，而且这次升级诚意十足，日常开发过程中的顺滑度会立刻感受到。如果你已经习惯了 `Livewire 3`，此刻正好可以迎接更轻盈的交互体验与显著提升的执行效率。

> ⚠️ **Beta 提示**：Livewire v4 目前仍处于 beta 阶段，官方正密集迭代。建议先在开发或测试环境评估，再决定是否升级生产环境。期间可能出现破坏性变更，记得同步关注更新日志，也欢迎向 Livewire 团队提交反馈。

[原文 PHP 组件未来：Livewire 4 正式发布，性能更快，功能更完整](https://catchadmin.com/post/2025-10/livewire-4-officially-released)

为什么值得升级到 Livewire 4？
--------------------

先聊最核心的性能。Livewire 4 重写了请求调度逻辑，尤其是并发交互的处理方式。以表单中的 `wire:model.live` 为例，如今每一次输入都会独立并行发送请求，彼此互不阻塞，打字和响应都更顺畅。

同样的优化也落在了 `wire:poll` 上。轮询再也不会卡住其他请求，因此即便是几秒刷新一次的数据看板，页面交互依旧流畅，不会因为后台轮询而拖慢前端体验。

单文件组件
-----

这是最能立刻提速的功能之一。Livewire 4 引入 **Single-File Components (SFC)**，把 PHP 逻辑和 Blade 模板合并到一个文件，简单任务不再需要来回切换。

    php artisan make:livewire create-post
    

运行后会得到一个包含逻辑与模板的组件。如果项目仍需更明确的分层，你也可以保留 Multi-File Components：

    php artisan make:livewire create-post --mfc
    

另外，基于视图的组件文件默认会加上 ⚡ 前缀，在编辑器里一眼就能分辨它们与普通 Blade 文件；如果不习惯，也能在配置中关闭。

Islands
-------

**Islands** 带来一次粒度更细的性能提升。你可以在组件内部圈出小岛，让它们各自更新，而不用再拆分成额外的子组件。

    @island(name: 'stats', lazy: true)
        <div>{{ $this->expensiveStats }}</div><div>{{ $this->expensiveStats }}</div>
    @endisland
    

想象一个包含多个小挂件的 dashboard：过去更新一个部分时常常要重渲整个页面，如今通过 Islands，仅有实际变化的挂件会刷新，性能更好、结构更干净。

wire:sort
---------

拖拽排序以往要靠额外的前端库，现在一条 `wire:sort` 指令就搞定：

    <ul wire:sort="updateOrder">
        @foreach ($items as $item)
            <li wire:sort:item="{{ $item->id }}">
                {{ $item->name }}
            </li>
        @endforeach
    </ul>
    

几行代码即可拥有可拖拽的列表，不用再手写复杂的 JavaScript。

wire:intersect
--------------

`wire:intersect` 能在元素进入或离开视口时触发动作，非常适合做无限滚动或惰性加载：

    <div wire:intersect="loadMore">...</div>
    

还可以用修饰符精细控制触发时机：

    <!-- 只触发一次 -->
    <div wire:intersect.once="trackView">...</div>
    
    <!-- 至少显示一半再触发 -->
    <div wire:intersect.half="loadMore">...</div>
    
    <!-- 自定义阈值 -->
    <div wire:intersect.threshold.50="trackScroll">...</div>
    

Async Actions
-------------

给动作加上 `.async` 修饰符，就能在后台并行处理，不再阻塞其他请求：

    <button wire:click.async="logActivity">Track</button>
    

也可以直接在方法上使用属性：

    #[Async]
    public function logActivity() {
        // 处理不需要即时回传 UI 的任务
    }
    

适合各种追踪、日志或后台操作，界面与数据可同时推进。

更优雅的 Loading 状态
---------------

触发网络请求的元素会自动带上 `data-loading` 属性，可用 Tailwind 等工具轻松统一 Loading 样式：

    <button wire:click="save" 
        class="data-[loading]:opacity-50 
               data-[loading]:pointer-events-none">
        Save Changes
    </button>
    

无需再到处写 `wire:loading`，风格集中、维护更容易。

Deferred Loading
----------------

除了懒加载（进入视口才加载），现在还有 **deferred loading**，会在首屏渲染完成后立即加载组件：

    <livewire:revenue defer />
    

也能将多个组件打包一起加载：

    <livewire:revenue lazy lazy:bundle />
    <livewire:expenses defer defer:bundle />
    

多种策略任你搭配，既兼顾首屏速度，也保留完整内容。

更强大的 JavaScript 集成
------------------

Livewire 4 与 JavaScript 更亲和：基于视图的组件可直接写 `<script>`，无需再包 `@script`。

    <div>
        <!-- 组件模板 -->
    </div>
    
    <script>
        // $wire 会自动以 this 绑定
        this.count++
    
        // 当然也能直接调 $wire
        $wire.save()
    </script>
    

脚本会自动缓存，并拆分成独立文件，加载更高效。

此外还新增了几个实用的“魔法”属性：

*   `$errors`：在 JavaScript 里直接访问错误集合。
*   `$intercept`：拦截并修改 Livewire 请求。

    <div x-show="$wire.$errors.has('email')">
        <span x-text="$wire.$errors.first('email')"></span>
    </div>
    
    <script>
      $wire.$intercept('save', ({ proceed }) => {
          if (confirm('Save changes?')) {
              proceed()
          }
      })
    </script>
    

路由更一致
-----

v4 推荐用 `Route::livewire()` 来注册**全页面组件**：

    // v4 推荐写法
    Route::livewire('/dashboard', Dashboard::class);
    
    // 基于视图的组件也适用
    Route::livewire('/dashboard', 'pages::dashboard');
    

这是目前的标准写法，也是让单文件、多文件组件当作全页面组件运行的前提。

从 v3 升级
-------

别被满屏新功能吓退。开发团队对向后兼容做了很多功课，多数项目仅需小范围调整即可升级，主要需关注配置文件与少量进阶 API 的签名变化。

### 必做的更新步骤

先升级依赖：

    composer require livewire/livewire:^4.0@beta
    

清理缓存，避免旧配置残留：

    php artisan config:clear
    php artisan view:clear
    

然后检查 `config/livewire.php`，几个键名或默认值有改动：

    // 布局设定
    'component_layout' => 'layouts::app', // 原为 'layout'
    
    // 占位视图
    'component_placeholder' => 'livewire.placeholder', // 原为 'lazy_placeholder'
    
    // smart wire:key 改为默认开启
    'smart_wire_keys' => true,
    

进阶功能
----

### 更细粒度的拦截器系统

过去的 `commit`、`request` 钩子已经由新的 **interceptor** 机制取代：

    Livewire.interceptMessage(({ component, message, onFinish, onSuccess, onError }) => {
        onFinish(() => {
            // 请求结束后
        })
    
        onSuccess(({ payload }) => {
            // 返回成功时
        })
    
        onError(() => {
            // 出现错误
        })
    })
    

新系统能区分网络故障与服务端错误，支持取消请求，也可针对指定组件启用。

### CSP Safe 模式

若应用启用了严格的 Content Security Policy，可开启：

    'csp_safe' => true,
    

Livewire 会切换到 Alpine 的 CSP 版本，避免 `unsafe-eval`；不过复杂的内联表达式会受到限制。

### wire:ref

    @foreach ($comments as $comment)
        <div wire:ref="comment-{{ $comment->id }}">
            {{ $comment->body }}
        </div>
    @endforeach
    
    <button wire:click="$refs['comment-123'].scrollIntoView()">
        Scroll to Comment
    </button>
    

一行 `wire:ref` 即可建立引用，再通过 `$refs` 调用原生浏览器 API。

### 更多顺手的修饰符

*   `.renderless`：在模板层阻止组件重新渲染，适合纯动作。
*   `.preserve-scroll`：更新时保留滚动位置，避免页面跳跃。

    <button wire:click.renderless="trackClick">Track</button>
    <button wire:click.preserve-scroll="loadMore">Load More</button>
    

上线前的测试清单
--------

v4 仍处于 beta，上线前不妨按以下步骤打个底：

1.  **准备独立测试环境**，别直接在生产上实验。
2.  **重点验证核心功能**，尤其是业务依赖最深的模块。
3.  **留意版本公告**，beta 之间可能伴随破坏性调整。
4.  **积极反馈问题**，帮助官方更快收敛问题。
5.  **保留回滚方案**，随时能够切回 v3。

总结
--

Livewire 4 不是例行升级，而是一场全面进化：性能更快、开发体验更顺手、扩展性更强。从单文件组件、Islands，到 async actions、全新的指令生态，都在帮你把精力集中在业务问题，而非样板代码。

更值得一提的是，这套能力可以循序渐进地引入，不必一次性重构现有系统。官方文档与社区资源也已经到位，遇到问题随时有人能帮忙。

趁着 beta 阶段探索、提意见，等稳定版发布时，你的团队也已掌握这些新工具，随时可以投入生产。