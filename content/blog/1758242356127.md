---
layout: post
title: 'OpenCvSharp基于颜色反差规避FBA面单贴标'
date: "2025-09-19T00:39:16Z"
---
OpenCvSharp基于颜色反差规避FBA面单贴标
==========================

**0****1**

规避原理

1.抠图，根据色差或者根据固定包裹位置以及包裹尺寸抠出纸箱图片

2.色差，获取纸箱上所有背景色的灰度值

3.采图，采集大量视野相同，光源相同面单的色差灰度值，整理区间

4.取反，所有非面单灰度值区间的，都认为是纸箱背景色

**0****2**

1.  根据DPI计算1mm对应像素点。
    
2.  获取吸取的颜色，计算灰度值
    

    // 300 DPI 计算：每毫米像素数 = 300 / 25.4 ≈ 11.81private const double PixelsPerMm = 300.0 / 25.4 ;private static int LabelSizePixels = Convert.ToInt32(Math.Ceiling((int)(95 * PixelsPerMm) / 1.7)); // 100mm × 100mm// 面单颜色列表（十六进制格式）private static readonly List<string> LabelColors = new List<string>{	"#E2E2E0", "#DEDEDC", "#E0E0DE", "#CCCCCA", "#B2B2B0", "#C2C2C0","#FFFFFF","#FEFEFE","#FCFCFC" ,"#ADADAD"};// 计算出的面单灰度范围private static int MinLabelGray;private static int MaxLabelGray;

    // 加载图像var originalImage = Cv2.ImRead(@"D:\Users\steph\Pictures\1分4\Image_20250913210539498.jpg", OpenCvSharp.ImreadModes.Grayscale);// 计算面单灰度范围CalculateLabelGrayRange();Console.WriteLine($"计算出的面单灰度范围: {MinLabelGray}-{MaxLabelGray}");if (originalImage.Empty()){	Console.WriteLine("无法加载图像");	return;}

此处用第二种最简单方式演示，视野固定包裹位置，根据计算包裹的尺寸，扣除原箱外观

    // 从右下角裁剪图像private static OpenCvSharp.Mat CropImageFromBottomRight(OpenCvSharp.Mat image, double widthMm, double heightMm){	// 将毫米转换为像素	int widthPixels = (int)(widthMm * PixelsPerMm/1.7);	int heightPixels = (int)(heightMm * PixelsPerMm/1.7);	// 获取图像尺寸	int imgWidth = image.Cols;	int imgHeight = image.Rows;	// 计算裁剪区域的左上角坐标	int x = Math.Max(0, imgWidth - widthPixels);	int y = Math.Max(0, imgHeight - heightPixels);	// 确保裁剪区域不超出图像边界	widthPixels = Math.Min(widthPixels, imgWidth - x);	heightPixels = Math.Min(heightPixels, imgHeight - y);	// 检查裁剪区域是否有效	if (widthPixels <= 0 || heightPixels <= 0)	{		Console.WriteLine($"无效的裁剪区域: x={x}, y={y}, width={widthPixels}, height={heightPixels}");		return image.Clone(); // 返回原始图像的副本	}	Console.WriteLine($"裁剪区域: x={x}, y={y}, width={widthPixels}, height={heightPixels}");	// 裁剪图像	return new OpenCvSharp.Mat(image, new Rect(x, y, widthPixels, heightPixels));}

根据裁切后的原箱外观，以及灰度值区间，定位原厂面单位置

    // 检测所有原厂面单位置public static List<LabelPosition> DetectOriginalLabelPositions(OpenCvSharp.Mat image){	var labelPositions = new List<LabelPosition>();	// 二值化图像以分离面单区域	var binary = new OpenCvSharp.Mat();	Cv2.Threshold(image, binary, MinLabelGray, 255, ThresholdTypes.Binary);	// 形态学操作去除噪声	var kernel = Cv2.GetStructuringElement(MorphShapes.Rect, new OpenCvSharp.Size(5, 5));	Cv2.MorphologyEx(binary, binary, MorphTypes.Open, kernel);	// 查找轮廓	Cv2.FindContours(binary, out var contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);	// 过滤轮廓（按面积）	var filteredContours = contours.Where(c => Cv2.ContourArea(c) > 1000).ToList();	// 处理每个轮廓	foreach (var contour in filteredContours)	{		// 获取轮廓的边界矩形		var rect = Cv2.BoundingRect(contour);		// 转换为网格坐标		string gridCoordinate = ConvertToGridCoordinate(rect, image.Rows, image.Cols);		// 计算实际尺寸（毫米）		double widthMm = rect.Width / PixelsPerMm;		double heightMm = rect.Height / PixelsPerMm;		// 添加到结果列表		labelPositions.Add(new LabelPosition		{			Rect = rect,			GridCoordinate = gridCoordinate,			WidthMm = widthMm,			HeightMm = heightMm		});	}	return labelPositions;}

  

检查可贴标签位置是否与原厂标签有交集，检查可贴区域是否超过原箱尺寸，此处我们以新帖面单大小100mm\*100mm为例。没有可贴标签位置默认选择1-1位置贴标

    // 检测所有原厂面单位置public static List<LabelPosition> DetectOriginalLabelPositions(OpenCvSharp.Mat image){	var labelPositions = new List<LabelPosition>();	// 二值化图像以分离面单区域	var binary = new OpenCvSharp.Mat();	Cv2.Threshold(image, binary, MinLabelGray, 255, ThresholdTypes.Binary);	// 形态学操作去除噪声	var kernel = Cv2.GetStructuringElement(MorphShapes.Rect, new OpenCvSharp.Size(5, 5));	Cv2.MorphologyEx(binary, binary, MorphTypes.Open, kernel);	// 查找轮廓	Cv2.FindContours(binary, out var contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);	// 过滤轮廓（按面积）	var filteredContours = contours.Where(c => Cv2.ContourArea(c) > 1000).ToList();	// 处理每个轮廓	foreach (var contour in filteredContours)	{		// 获取轮廓的边界矩形		var rect = Cv2.BoundingRect(contour);		// 转换为网格坐标		string gridCoordinate = ConvertToGridCoordinate(rect, image.Rows, image.Cols);		// 计算实际尺寸（毫米）		double widthMm = rect.Width / PixelsPerMm;		double heightMm = rect.Height / PixelsPerMm;		// 添加到结果列表		labelPositions.Add(new LabelPosition		{			Rect = rect,			GridCoordinate = gridCoordinate,			WidthMm = widthMm,			HeightMm = heightMm		});	}	return labelPositions;}

可视化结果，以绿色网格铺满原箱，以红色区域标定原厂标签位置，以蓝色网格标定可贴标签位置，返回可视化结果

    // 检测所有原厂面单位置public static List<LabelPosition> DetectOriginalLabelPositions(OpenCvSharp.Mat image){	var labelPositions = new List<LabelPosition>();	// 二值化图像以分离面单区域	var binary = new OpenCvSharp.Mat();	Cv2.Threshold(image, binary, MinLabelGray, 255, ThresholdTypes.Binary);	// 形态学操作去除噪声	var kernel = Cv2.GetStructuringElement(MorphShapes.Rect, new OpenCvSharp.Size(5, 5));	Cv2.MorphologyEx(binary, binary, MorphTypes.Open, kernel);	// 查找轮廓	Cv2.FindContours(binary, out var contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);	// 过滤轮廓（按面积）	var filteredContours = contours.Where(c => Cv2.ContourArea(c) > 1000).ToList();	// 处理每个轮廓	foreach (var contour in filteredContours)	{		// 获取轮廓的边界矩形		var rect = Cv2.BoundingRect(contour);		// 转换为网格坐标		string gridCoordinate = ConvertToGridCoordinate(rect, image.Rows, image.Cols);		// 计算实际尺寸（毫米）		double widthMm = rect.Width / PixelsPerMm;		double heightMm = rect.Height / PixelsPerMm;		// 添加到结果列表		labelPositions.Add(new LabelPosition		{			Rect = rect,			GridCoordinate = gridCoordinate,			WidthMm = widthMm,			HeightMm = heightMm		});	}	return labelPositions;}

看看效果1，运行看看效果.（如下图纸箱长400，高190）白色原厂面单占据了前面6个网格，最后两个网格超过原箱尺寸无效，默认返回第一个网格(视情况自定义)

![image.png](https://bexp.135editor.com/files/users/813/8134288/202509/sTcNIDLT_IvB4.png?auth_key=1758470399-0-0-4db6332523a178387cc69136046900a4)

保持期待 奔赴山海KEEP LOOKING FORWARD TO GOING

效果2.原厂标签占据第一个和中间4个网格，可贴标签区域蓝色网格标识，并返回可贴坐标

![image.png](https://bexp.135editor.com/files/users/813/8134288/202509/HNsy3HwQ_UaMe.png?auth_key=1758470399-0-0-2ca6918774fee100d8e40ba72029c54a)

  
作者：[Stephen-kzx](http://www.cnblogs.com/axing/)  
出处：[http://www.cnblogs.com/axing/](http://www.cnblogs.com/axing/)  
公众号：会定时分享写工作中或者生活中遇到的小游戏和小工具源码。有兴趣的帮忙点下关注！感恩！  
本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。