---
layout: post
title: 'DVWA靶场XSS漏洞通关教程及源码审计'
date: "2025-01-23T00:35:39Z"
---
DVWA靶场XSS漏洞通关教程及源码审计
====================

XSS漏洞
=====

**XSS**（跨站脚本攻击，Cross-Site Scripting）是一种安全漏洞，通常发生在Web应用程序中。XSS漏洞允许攻击者把恶意脚本注入到内容中, 这会在其他用户的浏览器中执行。这种攻击可能导致用户会话被劫持、网站内容被修改、用户敏感信息被窃取等多种安全问题。常见的XSS类型包括：

1.  **存储型XSS**：恶意脚本被存储在目标服务器上，比如在数据库中。比如当用户在一个留言板上输入代码，代码被存储下来了，访问该页面的其他用户就会受到影响。
2.  **反射型XSS**：恶意脚本通过URL等手段被“反射”到用户的浏览器中，常在带有查询参数的链接中实施。用户点击恶意链接时，会立即执行该脚本。
3.  **DOM型XSS**：基于文档对象模型（DOM）的变化，在客户端执行的XSS。DOM型XSS攻击不会涉及到服务器端内容改变。

防御XSS攻击的方法包括：

*   对用户输入进行严格的验证和过滤。
*   对输出进行编码，确保浏览器不能将其错误地解释为可执行代码。
*   使用安全的HTTP头，如Content Security Policy（CSP）。

DOM型XSS
-------

### low

直接尝试

![](https://track123.oss-cn-beijing.aliyuncs.com/20250101155617257.png)

#### 源码审计

没有任何过滤情况

    <?php
    //没有保护，什么都没有
    # No protections, anything goes
    ?>
    

### medium

查看源码发现过滤掉了**“<script”**，当函数匹配到 <script 字符串的时候就会将URL后面的参数修正为 ?default=English

绕过

![](https://track123.oss-cn-beijing.aliyuncs.com/20250101160140858.png)

#### 源码审计

过滤了**<script** 字段，可以双写绕过，或者大小写绕过

    <?php
    // 检查是否有输入
    if ( array_key_exists( "default", $_GET ) && !is_null ($_GET[ 'default' ]) ) {
        $default = $_GET['default']; // 获取查询参数 'default' 的值并赋给变量 $default
    
        # 不允许含有 script 标签
        if (stripos ($default, "<script") !== false) {
            header ("location: ?default=English"); // 如果检测到 <script> 标签，则重定向到 ?default=English
            exit; // 终止脚本执行
        }
    }
    ?>
    

### high

这里设置了白名单，如果default的值不为”French”、”English”、”German”、”Spanish”的话就重置URL为:?default=English ，这里只是对 default 的变量进行了过滤

可以考虑后面加 **#** 或 **&**

![](https://track123.oss-cn-beijing.aliyuncs.com/20250101160348438.png)

![](https://track123.oss-cn-beijing.aliyuncs.com/20250101160412624.png)

#### 源码审计

首先确保有输入数据，设置了白名单允许的语言，可以利用白名单语言进行绕过

    <?php
    // 检查是否有输入
    if ( array_key_exists( "default", $_GET ) && !is_null ($_GET[ 'default' ]) ) {
        
        # 白名单允许的语言
        switch ($_GET['default']) {
            case "French":  // 法语
            case "English": // 英语
            case "German":  // 德语
            case "Spanish": // 西班牙语
                # 合法的语言
                break;
            default:
                header ("location: ?default=English"); // 如果输入的语言不在白名单内，则重定向到 ?default=English
                exit; // 终止脚本执行
        }
    }
    ?>
    

### impossible

#### 源码审计

将防护移到客户端，更加安全

    <?php
    # 不需要做任何事情，保护措施在客户端处理
    ?>
    

反射型XSS (Reflected）
------------------

**反射型XSS**，顾名思义在于“反射”这个一来一回的过程。反射型XSS的触发有后端的参与，而之所以触发XSS是因为后端解析用户在前端输入的带有XSS性质的脚本或者脚本的data URI编码，后端解析用户输入处理后返回给前端，由浏览器解析这段XSS脚本，触发XSS漏洞。因此如果要避免反射性XSS，则必须需要后端的协调，在后端解析前端的数据时首先做相关的字串检测和转义处理；同时前端同样也许针对用户的数据做excape转义，保证数据源的可靠性

*   基本原理就是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特定的代码参数会被HTML解析，执行，如此就可以获取用户的COOIKE，进而盗号登陆。
    
*   特点：非持久化 必须用户点击带有特定参数的链接才能引起。
    
*   XSS反射型攻击，恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。
    

### low

并没有任何过滤

![](https://track123.oss-cn-beijing.aliyuncs.com/20250101161854180.png)

#### 源码审计

    <?php
    header ("X-XSS-Protection: 0"); // 设置 HTTP 头部，关闭 XSS 攻击防护
    // 检查是否有输入
    // array_key_exists() 函数：判断 $_GET 的值中是否存在 “name” 键名，并且 $_GET[‘name’] 的值是否不为空，满足这些条件，直接输出下面的输出语句。
    if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {
        // 给最终用户的反馈
        echo '<pre>Hello ' . $_GET[ 'name' ] . '</pre>'; // 输出问候信息，包含用户输入的名称
    }
    ?>
    

### medium

这里过滤了**<script**标签，这里使用了**str\_replace**函数，它是区分大小写的，因此可以使用大小写绕过

![](https://track123.oss-cn-beijing.aliyuncs.com/20250101162128655.png)

也可以使用双写绕过

![](https://track123.oss-cn-beijing.aliyuncs.com/20250101162307003.png)

#### 源码审计

过滤了