---
layout: post
title: '回顾一下WPF原生实现命令'
date: "2025-08-21T00:39:25Z"
---
回顾一下WPF原生实现命令
=============

前言
--

最近在学习Stylet中`Command="{s:Action 方法名}"`的设计与实现，但要弄明白这个之前，必须对原生实现命令比较熟悉，一想我也很久没有自己实现原生的命令了，之前都是用`Community.Mvvm`库来实现，所以今天先来回顾一下，在WPF中如何实现原生的命令。

借助AI使用原生的WPF写法实现了一个跟Stylet例子Hello一样的效果：

WPF中如何使用命令
----------

WPF命令是实现用户界面交互的核心机制，通过实现`ICommand`接口来封装可执行的操作。命令支持松耦合的UI设计，可以绑定到按钮、菜单等控件，实现统一的执行逻辑。WPF提供了丰富的内置命令如`ApplicationCommands`、`NavigationCommands`等，同时也支持自定义命令，便于实现撤销/重做、数据绑定等复杂功能。

现在先来看看这个例子中是如何使用命令的吧！！

     public class RelayCommand : ICommand
     {
         private readonly Action<object?> _execute;
         private readonly Predicate<object?>? _canExecute;
    
         public RelayCommand(Action<object?> execute, Predicate<object?>? canExecute = null)
         {
             _execute = execute ?? throw new ArgumentNullException(nameof(execute));
             _canExecute = canExecute;
         }
    
         public event EventHandler? CanExecuteChanged
         {
             add => CommandManager.RequerySuggested += value;
             remove => CommandManager.RequerySuggested -= value;
         }
    
         public bool CanExecute(object? parameter)
         {
             return _canExecute == null || _canExecute(parameter);
         }
    
         public void Execute(object? parameter)
         {
             _execute(parameter);
         }
    
         public void RaiseCanExecuteChanged()
         {
             CommandManager.InvalidateRequerySuggested();
         }
     }
    

这个例子中自己实现了一个实现`ICommand`接口的`RelayCommand`类。

先来看看`ICommand`接口：

        public interface ICommand
        {
            event EventHandler? CanExecuteChanged;
            bool CanExecute(object? parameter); 
            void Execute(object? parameter);
        }
    

这个`ICommand`接口起到了什么作用呢？

*   统一命令规范：定义了命令的标准结构，包含执行方法Execute和状态判断方法CanExecute
*   实现命令绑定：允许UI控件（如Button、MenuItem）通过Command属性绑定到具体命令实现
*   控制可用性：CanExecute方法动态控制控件的启用/禁用状态，CanExecuteChanged事件通知UI更新状态
*   参数传递：通过parameter参数在UI和命令逻辑间传递数据
*   解耦UI与业务逻辑：将界面操作与具体实现分离，提高代码的可维护性和可测试性

在`RelayCommand`中：

     private readonly Action<object?> _execute;
     private readonly Predicate<object?>? _canExecute;
    

`_execute (Action<object?>)`: 存储要执行的操作委托

`_canExecute (Predicate<object?>?)`: 存储判断命令是否可执行的谓词委托，可为 null

     public event EventHandler? CanExecuteChanged
     {
         add => CommandManager.RequerySuggested += value;
         remove => CommandManager.RequerySuggested -= value;
     }
    

这里出现了一个`CommandManager`：

WPF 中的 `CommandManager` 是一个帮助类，位于`System.Windows.Input`命名空间。它并不负责“执行命令”，而是为整个命令系统`（RoutedCommand / RoutedUICommand）`提供基础支撑，核心职责可以概括为四类：

**1、处理路由命令的 4 个附加事件**

CommandManager 预定义了 4 个 static 的 RoutedEvent，都是附加事件，所有 UIElement 都可以通过它们监听或引发命令相关路由事件：

附加事件

触发时机

典型用途

PreviewCanExecuteEvent

准备询问某命令能否执行时触发（隧道）

用于全局或父级拦截“能否执行”判断

CanExecuteEvent

同上，但为冒泡阶段

本地逻辑判断命令当前是否可用

PreviewExecutedEvent

准备执行命令时触发（隧道）

做执行前的统一拦截，例如日志、撤销栈

ExecutedEvent

同上，但为冒泡阶段

实际执行业务逻辑（如 Save、Cut、Paste）

这里出现了`隧道`与`冒泡`两个概念，该如何理解呢？

在 WPF 路由事件体系中，`隧道（Tunneling）`与`冒泡（Bubbling）`是指事件在可视化树上传递的**两个方向**，想象成“从上到下”还是“从下到上”即可。与命令系统结合时，理解这两个方向就等于知道“谁先被通知”、“谁可以打断谁”。

树结构：

`Window → Grid → StackPanel → Button`

这是典型的一棵可视化树。

**隧道（Preview……）→ 从根向叶**

PreviewCanExecute / PreviewExecuted 这类以 Preview 开头的事件，先由 Window 收到，再依次 Grid、StackPanel，最后才到达实际声明 CommandBinding / 声明 InputBindings 的那个 Button。

作用：你可以在高层（例如 Window 一级）拦截事件，做“统一处理”或“统一否决”，比如给所有按钮加日志、在全局禁止某些快捷键等。只要沿途某级标记 e.Handled = true，它就终止继续向下传递。

**冒泡（……无 Preview）→ 从叶向根**

隧道阶段结束后如果仍然 Handled == false，则进入冒泡阶段。方向反过来：Button 先收到，再依次 StackPanel、Grid、Window。

作用：一般在最具体元素（Button）里决定命令是否可用或执行，而父容器只做辅助行为，如更新状态栏、刷新菜单对勾等。同样可以用 e.Handled = true 阻止再向上传。

**2、提供 4 组 Add xxx Handler / Remove xxx Handler 的快捷方法**

这些只是对 UIElement.AddHandler、RemoveHandler 的二次封装，方便挂接或注销上述 4 种附加事件，省去记忆事件标识符或强制转换类型的麻烦。

**3、维护全局命令“有效性”通知：RequerySuggested**

事件定义：public static event EventHandler RequerySuggested;

作用：当系统条件变化（键盘焦点变化、文本被修改、网络状态变更等）时，所有命令需要重新询问“是否能执行”。WPF 内部的按钮、菜单项等在订阅此事件后，就会再次调用 ICommand.CanExecute 来决定 IsEnabled。

手动触发：CommandManager.InvalidateRequerySuggested(); 会立即引发该事件，从而强制刷新所有绑定命令的可执行状态。

**4、提供“类级别” CommandBinding / InputBinding 注册**

`RegisterClassCommandBinding(Type type, CommandBinding commandBinding)`

为指定类型（而不仅是某个实例）注册 CommandBinding，在所有实例共享同一组绑定逻辑，等同于在静态构造函数里写：

    CommandManager.RegisterClassCommandBinding(
          typeof(MyControl),
          new CommandBinding(ApplicationCommands.Save, OnSaveExecuted, OnSaveCanExecute));
    RegisterClassInputBinding(Type type, InputBinding inputBinding)
    

同样道理，为某个控件类统一注册快捷键：

    CommandManager.RegisterClassInputBinding(
          typeof(MyWindow),
          new KeyBinding(ApplicationCommands.Save, Key.S, ModifierKeys.Control));
    

现在来看看整体流程：

      <Button Content="Say Hello" 
              Command="{Binding SayHelloCommand}"
              Height="30"
              FontSize="14"/>
    

在View中绑定这个命令。

刚开始这个命令不可执行：

是因为在ViewModel中是这样写的，首先在构造函数中这样写：

      public ShellViewModel()
      {
          SayHelloCommand = new RelayCommand(
              execute: _ => ShowHelloMessage(),
              canExecute: _ => CanSayHello
          );
      }
    

其中控制是否能执行的，设置了一个属性来管理：

     public bool CanSayHello => !string.IsNullOrEmpty(Name);
    

命令执行的方法为：

      private void ShowHelloMessage()
      {
          MessageBox.Show($"Hello, {Name}", "Hello, Native WPF", MessageBoxButton.OK, MessageBoxImage.Information);
      }
    

刚开始Name属性为空，所以CanSayHello为false，所以命令不能执行。

为什么输入东西就可以变成执行了呢？

     public string Name
     {
         get => _name;
         set
         {
             if (SetProperty(ref _name, value))
             {
                 ((RelayCommand)SayHelloCommand).RaiseCanExecuteChanged();
             }
         }
     }
    

在`RelayCommand`中有一个`RaiseCanExecuteChanged`方法：

       public void RaiseCanExecuteChanged()
       {
           CommandManager.InvalidateRequerySuggested();
       }
    

`CommandManager.InvalidateRequerySuggested();` 是 WPF 中用于**强制刷新命令的可执行状态**的方法。所有绑定了`ICommand`的控件（如 Button、MenuItem 等）马上重新评估自己的 CanExecute 状态。

然后因为Name不为空，CanSayHello为True，这个命令就可以执行了。

点击按钮就会触发`RelayCommand`中的`Execute`方法：

在ViewModel的构造函数中。实例化了一个`RelayCommand`对象，并且将`_ => ShowHelloMessage()`这个委托赋值给了`execute`，所以触发命令之后就会执行`ShowHelloMessage`方法。

以上就是使用WPF原生的方法实现的一个使用命令的例子。