---
layout: post
title: 'ä»Žè½¦é“æ£€æµ‹é¡¹ç›®å…¥é—¨open cv'
date: "2025-04-30T00:40:30Z"
---
ä»Žè½¦é“æ£€æµ‹é¡¹ç›®å…¥é—¨open cv
================

ä»Žè½¦é“æ£€æµ‹é¡¹ç›®å…¥é—¨open cv
================

> å‰æå£°æ˜Žï¼šéžå¸¸æ„Ÿè°¢bç«™upä¸» **å˜‰ç„¶ä»Šå¤©åƒå¸¦å˜**ï¼Œæ„Ÿè°¢å…¶è§†é¢‘çš„å¸®åŠ©ã€‚åŒæ—¶å¸Œæœ›å„ä½å¤§ä½¬ç§¯ç§¯æžæå‡ºå®è´µçš„æ„è§ã€‚ðŸ˜ŠðŸ˜ŠðŸ˜Š(âÂ´â—¡\`â)(â—'â—¡'â—)â•°(_Â°â–½Â°_)â•¯
> 
> githubåœ°å€ï¼š[https://github.com/lizhongzheng13/openCV\_Lane\_Detection/tree/main](https://github.com/lizhongzheng13/openCV_Lane_Detection/tree/main)
> 
> è§†é¢‘åœ°å€ï¼š[ä»Žè½¦é“æ£€æµ‹é¡¹ç›®å…¥é—¨open cv](https://www.bilibili.com/video/BV1qk4y1r7jw/?spm_id_from=333.1391.0.0&p=10&vd_source=3c58a56884ef40ab5aa99f8a00685d85)

### åŸºç¡€çŸ¥è¯†

#### cv2.imread & cv2.imshow & cv2.imwrite

     import cv2 as cv
     
     img = cv.imread("img.png", cv.IMREAD_GRAYSCALE) #å°†å›¾ç‰‡è½¬ä¸ºç°åº¦å›¾
    

> ä½†æ˜¯å½“å‰ä¼šå­˜åœ¨ä¸€äº›é—®é¢˜ï¼Œå›¾ç‰‡ä¼šé—ªä¸€ä¸‹ï¼Œçœ‹ä¸æ¸…æ¥šï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åŠ ä¸Šé˜»å¡ž `cv2.waitKey()`å‡½æ•°

    #å®Œæ•´ç‰ˆ
    import cv2 as cv
    
    img = cv.imread("img.png", cv.IMREAD_GRAYSCALE)
    print(type(img))
    print(img.shape)
    cv.imshow('image', img)
    k = cv.waitKey(0)  # é˜»å¡ž #kç›¸å½“äºŽæ£€æµ‹ä½ çš„è¾“å…¥çš„asciiå€¼
    print(k)
    # while True:
    #     if cv.waitKey(0) == ord('q'):
    #         cv.destroyAllWindows()
    #     else:
    #         img = cv.imread("img.png", cv.IMREAD_GRAYSCALE)
    
    cv.imwrite("img_gray.png", img)#ç”Ÿæˆimgå›¾ç‰‡ï¼Œä¿å­˜åˆ°å½“å‰ç›®å½•ä¸­~
    

æ•ˆæžœå±•ç¤º

> åŽŸå§‹å›¾åƒï¼š
> 
> ![image-20250428092853043](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250428092853043.png)
> 
> ç°åº¦å›¾ï¼š
> 
> ![image-20250428092929086](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250428092929086.png)

* * *

### Cannyè¾¹ç¼˜æ£€æµ‹

> é€šè¿‡æ±‚å–å›¾åƒä¸Šæ¯ä¸€ä¸ªåƒç´ ç‚¹å‘¨è¾¹å›¾åƒåƒç´ å˜åŒ–çš„æ¢¯åº¦ï¼Œæ¥ç¡®å®šè¿™ä¸ªç‚¹æ˜¯å¦æ˜¯è¾¹ç¼˜ã€‚

![image-20250428102959222](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250428102959222.png)

æ¢¯åº¦çš„æ–¹å‘ä¸€èˆ¬æ€»æ˜¯ä¸Žè¾¹ç•Œåž‚ç›´ï¼Œæ¢¯åº¦çš„æ–¹å‘è¢«å½’ä¸ºå››ç±»ï¼šåž‚ç›´ã€æ°´å¹³å’Œä¸¤ä¸ªå¯¹è§’çº¿ï¼ˆå³ï¼Œ0åº¦ã€45åº¦ã€90åº¦å’Œ135åº¦å››ä¸ªæ–¹å‘ï¼‰ã€‚

![image-20250428104012729](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250428104012729.png)

æˆ‘ä»¬çŽ°åœ¨çš„æƒ³æ³•æ˜¯è®¾ç½®ä¸€ä¸ªé˜ˆå€¼ï¼Œå½“æ¢¯åº¦å¤§äºŽé˜ˆå€¼æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºè¯¥ç‚¹æ˜¯è¾¹ç¼˜ã€‚ä½†æ˜¯éšä¹‹è€Œæ¥çš„æ˜¯ï¼Œå›¾ç‰‡ä¼šäº§ç”Ÿä¸€äº›æ¯›è¾¹æˆ–è€…å…‰çº¿ï¼Œè§’åº¦ç­‰é—®é¢˜ï¼Œå¯¼è‡´å¯èƒ½ä¼šè¯¯åˆ¤ã€‚

![image-20250428105216769](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250428105216769.png)

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬é‡‡ç”¨åŒé˜ˆå€¼çš„æ–¹æ³•ï¼Œä¸€ä¸ªä¸Šé˜ˆå€¼ï¼Œä¸€ä¸ªä¸‹é˜ˆå€¼ã€‚

![image-20250428105314881](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250428105314881.png)

> æˆ‘ä»¬è®¤ä¸ºé«˜äºŽä¸Šé˜ˆå€¼çš„ç‚¹ä¸ºå¼ºè¾¹ç¼˜ï¼Œåœ¨ä¸Šé˜ˆå€¼å’Œä¸‹é˜ˆå€¼ä¹‹é—´çš„æˆ‘ä»¬è®¤ä¸ºæ˜¯å¼±è¾¹ç¼˜ã€‚
> 
> æˆ‘ä»¬è®¤ä¸ºåªæœ‰å¼±è¾¹ç¼˜ä¸Žå¼ºè¾¹ç¼˜ç›¸è¿žçš„è¯ï¼Œæ‰æ˜¯è¾¹ç¼˜ã€‚Bä¸è®¤ä¸ºæ˜¯è¾¹ç¼˜ï¼Œå¯èƒ½æ˜¯å™ªå£°ï¼›Cä¸ŽAå¼ºè¾¹ç¼˜ç›¸è¿žï¼Œæˆ‘ä»¬è®¤ä¸ºCæ˜¯è¾¹ç¼˜ã€‚

    import cv2
    
    img = cv2.imread("img.png", cv2.IMREAD_GRAYSCALE)
    
    edge_img = cv2.Canny(img, 190, 350)  # ä¸‹è¾¹ç¼˜å’Œä¸Šè¾¹ç¼˜çš„é˜ˆå€¼è®¾å®š #éœ€è¦è‡ªè¡Œæ›´æ”¹
    cv2.imshow("edge", edge_img)
    cv2.waitKey(0)
    
    

![image-20250429203018189](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250429203018189.png)

> å½“ä¸Šè¾¹ç¼˜å’Œä¸‹è¾¹ç¼˜éƒ½å‡é«˜æ—¶ï¼Œè¾¹ç¼˜æ˜¾ç¤ºä¼šè¶Šæ¥è¶Šå°‘ã€‚

* * *

### ROI mask

ç®€å•æ¥è®²å°±æ˜¯ç±»ä¼¼äºŽæŠ å›¾ï¼Œå°±æ˜¯å‰”é™¤æ— å…³ä¿¡æ¯çš„è¾¹ç¼˜ã€‚

roi : region of interest æ„Ÿå…´è¶£çš„åŒºåŸŸ

â€‹ æ•°ç»„åˆ‡ç‰‡

â€‹ å¸ƒå°”è¿ç®—ï¼ˆä¸Žè¿ç®—ï¼‰

![image-20250428111139930](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250428111139930.png)

*   `cv2.fillPoly` æ˜¯ OpenCV ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºŽåœ¨å›¾åƒä¸­å¡«å……å¤šè¾¹å½¢åŒºåŸŸã€‚å®ƒå¸¸ç”¨äºŽç»˜åˆ¶ã€é®ç½©æˆ–æ ‡è®°å›¾åƒä¸­çš„ç‰¹å®šåŒºåŸŸã€‚é€šè¿‡æŒ‡å®šå¤šè¾¹å½¢çš„é¡¶ç‚¹ï¼Œ`cv2.fillPoly` å¯ä»¥å°†è¿™äº›åŒºåŸŸå¡«å……ä¸ºæŒ‡å®šçš„é¢œè‰²ã€‚
    
*   `cv2.bitwise_and` æ˜¯ OpenCV ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºŽå¯¹ä¸¤ä¸ªå›¾åƒæˆ–æ•°ç»„è¿›è¡ŒæŒ‰ä½ä¸Žï¼ˆbitwise ANDï¼‰æ“ä½œã€‚æŒ‰ä½ä¸Žæ“ä½œæ˜¯é€åƒç´ è¿›è¡Œçš„ï¼Œåªæœ‰å½“ä¸¤ä¸ªå›¾åƒçš„å¯¹åº”åƒç´ éƒ½ä¸ºéžé›¶å€¼æ—¶ï¼Œç»“æžœå›¾åƒçš„è¯¥åƒç´ æ‰ä¸ºéžé›¶å€¼ã€‚
    
    *   **å›¾åƒé®ç½©**ï¼š
        
        *   ä½¿ç”¨æŽ©ç æå–å›¾åƒçš„ç‰¹å®šåŒºåŸŸã€‚ä¾‹å¦‚ï¼Œå°†ä¸€ä¸ªå½¢çŠ¶ï¼ˆå¦‚çŸ©å½¢ã€åœ†å½¢æˆ–å¤šè¾¹å½¢ï¼‰ä½œä¸ºæŽ©ç ï¼Œåªä¿ç•™æŽ©ç å†…çš„å›¾åƒå†…å®¹ã€‚
    *   **å›¾åƒåˆæˆ**ï¼š
        
        *   å°†ä¸¤ä¸ªå›¾åƒçš„ç‰¹å®šéƒ¨åˆ†ç»„åˆåœ¨ä¸€èµ·ã€‚
    *   **å›¾åƒå¤„ç†**ï¼š
        
        *   åœ¨å›¾åƒå¤„ç†ä¸­ï¼ŒæŒ‰ä½ä¸Žæ“ä½œå¸¸ç”¨äºŽå¯¹å›¾åƒè¿›è¡ŒåŒºåŸŸé€‰æ‹©æˆ–åŒºåŸŸé®æŒ¡ã€‚

å›¾åƒä»¥çŸ©é˜µnp.arrayå½¢å¼å­˜å‚¨åœ¨å†…å­˜ä¸­

â€‹ np.zeros\_like : `np.zeros_like` æ˜¯ NumPy åº“ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºŽåˆ›å»ºä¸€ä¸ªä¸Žç»™å®šæ•°ç»„å½¢çŠ¶å’Œæ•°æ®ç±»åž‹ç›¸åŒçš„æ•°ç»„ï¼Œä½†æ‰€æœ‰å…ƒç´ éƒ½åˆå§‹åŒ–ä¸ºé›¶ã€‚

    # @Author : LiZhongzheng
    # å¼€å‘æ—¶é—´  ï¼š2025-04-28 17:30
    import cv2
    import numpy as np
    
    edge_img = cv2.imread("edge_img.png", cv2.IMREAD_GRAYSCALE)
    mask = np.zeros_like(edge_img)  # èŽ·å–ä¸€ä¸ªä¸Žedge_imgå¤§å°ç›¸åŒçš„æ•°ç»„
    mask = cv2.fillPoly(mask, np.array([[[0, 569], [661, 195], [914, 248], [979, 592]]]),
                        color=255)  # arrayä¸­çš„å­˜æ”¾çš„æ˜¯æƒ³è¦è¯†åˆ«åŒºåŸŸçš„å››ä¸ªé¡¶ç‚¹ #é¡ºåºä¸ºå·¦ä¸‹ã€å·¦ä¸Šã€å³ä¸Šã€å³ä¸‹
    
    masked_edge_img = cv2.bitwise_and(edge_img, mask)
    # cv2.imshow('mask', mask)
    # cv2.waitKey(0)
    cv2.imshow("edged", masked_edge_img)
    cv2.waitKey(0)
    
    

![image-20250429202953080](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250429202953080.png)

* * *

### éœå¤«å˜æ¢

æå–å›¾ç‰‡ä¸­çš„ç›´çº¿ã€‚

æ³¨æ„ï¼šéœå¤«å˜æ¢æ˜¯**é’ˆå¯¹ç°åº¦å›¾**çš„ã€‚

![image-20250428191915811](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250428191915811.png) ![image-20250428192232916](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250428192232916.png) ![image-20250428192253353](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250428192253353.png)

> minæ˜¯æœ€çŸ­çº¿æ®µçš„é•¿åº¦ï¼Œmaxæ˜¯ä¸¤ç‚¹ä¹‹é—´çš„æœ€å¤§è·ç¦»ï¼Œè¶…è¿‡è¿™ä¸ªè·ç¦»å°±ä¸è®¤ä¸ºæ˜¯çº¿æ®µäº†ã€‚

*   é¦–å…ˆç»è¿‡ cv2.HoughLinesP()å‡½æ•°èŽ·å–åˆ°æ‰€æœ‰çš„çº¿æ¡ï¼Œç„¶åŽè®¡ç®—çº¿æ¡çš„æ–œçŽ‡ï¼Œæ ¹æ®æ–œçŽ‡çš„æ­£è´Ÿåˆ¤æ–­æ˜¯å·¦è½¦é“çº¿è¿˜æ˜¯å³è½¦é“çº¿ã€‚
    
    *       # @Author : LiZhongzheng
            # å¼€å‘æ—¶é—´  ï¼š2025-04-29 8:54
            import cv2
            import numpy as np
            
            
            def calculate_slope(line):
                """
                è®¡ç®—çº¿æ®µlineçš„æ–œçŽ‡
                :param line: np.array([[x_1, y_1, x_2, y_2]])
                :return:
                """
                x_1, y_1, x_2, y_2 = line[0]
                return (y_2 - y_1) / (x_2 - x_1)
            
            
            edge_img = cv2.imread('masked_edge_img.jpg', cv2.IMREAD_GRAYSCALE)
            # èŽ·å–æ‰€æœ‰çº¿æ®µ
            lines = cv2.HoughLinesP(edge_img, 1, np.pi / 180, 15, minLineLength=40,
                                    maxLineGap=20)
            # æŒ‰ç…§æ–œçŽ‡åˆ†æˆè½¦é“çº¿
            left_lines = [line for line in lines if calculate_slope(line) > 0]
            right_lines = [line for line in lines if calculate_slope(line) < 0]
            
            print("left_lines =", len(left_lines))
            print("right_lines =", len(right_lines))
            
        

* * *

### ç¦»ç¾¤å€¼è¿‡æ»¤

å‰”é™¤å‡ºå› ä¸ºè¯¯å·®è€Œè¢«è¯†åˆ«å‡ºçš„ç›´çº¿ã€‚

**å¦‚ä½•åˆ†è§£å‡ºå™ªç‚¹å’Œè½¦é“çº¿é‚£ï¼Ÿ**

*   æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œè½¦é“çº¿çš„æ–œçŽ‡å¤§è‡´æ˜¯ç›¸åŒçš„ï¼Œè¿›è€Œå¯ä»¥åˆ†è¾¨å‡ºå™ªç‚¹å’Œè½¦é“çº¿ã€‚

    # @Author : LiZhongzheng
    # å¼€å‘æ—¶é—´  ï¼š2025-04-29 9:01
    import cv2
    import numpy as np
    
    """
    å‰”é™¤å‡ºå› ä¸ºè¯¯å·®è€Œè¢«è¯†åˆ«å‡ºçš„ç›´çº¿ã€‚
    å¦‚ä½•åˆ†è§£å‡ºå™ªç‚¹å’Œè½¦é“çº¿é‚£ï¼Ÿ
        æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œè½¦é“çº¿çš„æ–œçŽ‡å¤§è‡´æ˜¯ç›¸åŒçš„ï¼Œè¿›è€Œå¯ä»¥åˆ†è¾¨å‡ºå™ªç‚¹å’Œè½¦é“çº¿ã€‚
    """
    
    
    def calculate_slope(line):
        """
        è®¡ç®—çº¿æ®µlineçš„æ–œçŽ‡
        :param line: np.array([[x_1, y_1, x_2, y_2]])
        :return:
        """
        x_1, y_1, x_2, y_2 = line[0]
        return (y_2 - y_1) / (x_2 - x_1)
    
    
    edge_img = cv2.imread('masked_edge_img.jpg', cv2.IMREAD_GRAYSCALE)
    
    # èŽ·å–æ‰€æœ‰çº¿æ®µ
    lines = cv2.HoughLinesP(edge_img, 1, np.pi / 180, 15, minLineLength=40, maxLineGap=20)
    
    # æŒ‰ç…§æ–œçŽ‡åˆ†æˆè½¦é“çº¿
    left_lines = [line for line in lines if calculate_slope(line) > 0]
    right_lines = [line for line in lines if calculate_slope(line) < 0]
    
    
    def reject_abnormal_lines(lines, threshold):
        """
        å‰”é™¤æ–œçŽ‡ä¸ä¸€è‡´çš„çº¿æ®µ
        :param lines: çº¿æ®µé›†åˆ, [np.array([[x_1, y_1, x_2, y_2]]),np.array([[x_1, y_1, x_2, y_2]]),...,np.array([[x_1, y_1, x_2, y_2]])]
        """
        slopes = [calculate_slope(line) for line in lines]
        while len(lines) > 0:
            mean = np.mean(slopes)  # ä½¿ç”¨ NumPy çš„ np.mean å‡½æ•°è®¡ç®—å½“å‰æ‰€æœ‰æ–œçŽ‡çš„å¹³å‡å€¼
            diff = [abs(s - mean) for s in slopes]  # éåŽ† slopes åˆ—è¡¨ï¼Œè®¡ç®—æ¯ä¸ªæ–œçŽ‡ä¸Žå¹³å‡æ–œçŽ‡çš„ç»å¯¹å·®å€¼ï¼Œå¹¶å°†ç»“æžœå­˜å‚¨åœ¨ diff åˆ—è¡¨ä¸­
            idx = np.argmax(diff)  # ä½¿ç”¨ NumPy çš„ np.argmax å‡½æ•°æ‰¾åˆ° diff åˆ—è¡¨ä¸­æœ€å¤§å€¼çš„ç´¢å¼•ï¼Œå³æ–œçŽ‡å·®å¼‚æœ€å¤§çš„çº¿æ®µã€‚
            if diff[idx] > threshold:  # å¦‚æžœæœ€å¤§å·®å¼‚å¤§äºŽé˜ˆå€¼ thresholdï¼Œåˆ™è®¤ä¸ºè¯¥çº¿æ®µæ˜¯å¼‚å¸¸çš„ï¼Œå°†å…¶ä»Ž slopes å’Œ lines åˆ—è¡¨ä¸­ç§»é™¤ã€‚
                slopes.pop(idx)
                lines.pop(idx)
            else:  # å¦‚æžœæœ€å¤§å·®å¼‚å°äºŽæˆ–ç­‰äºŽé˜ˆå€¼ï¼Œåˆ™è®¤ä¸ºæ‰€æœ‰çº¿æ®µçš„æ–œçŽ‡å·²ç»è¶³å¤Ÿä¸€è‡´ï¼Œé€€å‡ºå¾ªçŽ¯ã€‚
                break
        return lines  # å¦‚æžœæœ€å¤§å·®å¼‚å°äºŽæˆ–ç­‰äºŽé˜ˆå€¼ï¼Œåˆ™è®¤ä¸ºæ‰€æœ‰çº¿æ®µçš„æ–œçŽ‡å·²ç»è¶³å¤Ÿä¸€è‡´ï¼Œé€€å‡ºå¾ªçŽ¯ã€‚
    
    
    print('before filter:')
    print('left lines number=')
    print(len(left_lines))
    print('right lines number=')
    print(len(right_lines))
    
    reject_abnormal_lines(left_lines, threshold=0.2)
    reject_abnormal_lines(right_lines, threshold=0.2)
    
    print('after filter:')
    print('left lines number=')
    print(len(left_lines))
    print('right lines number=')
    print(len(right_lines))
    
    

* * *

### æœ€å°äºŒä¹˜æ‹Ÿåˆ

å°†linesçš„çº¿æ®µæ‹Ÿåˆæˆä¸€æ¡ç›´çº¿ã€‚

np.ravel å°†é«˜ç»´æ•°ç»„æ‹‰æˆä¸€ç»´

np.polyfit å¤šé¡¹å¼æ‹Ÿåˆ

np.polyval å¤šé¡¹å¼æ±‚å€¼

*   ç»è¿‡ä¸Šè¿°çš„æ­¥éª¤ï¼Œè¿›è€Œæˆ‘ä»¬å¯ä»¥æ±‚å‡ºè½¦é“çº¿çš„æ•°é‡ç­‰ä¿¡æ¯ï¼ŒåŒæ—¶åˆå‰”é™¤äº†å™ªç‚¹ã€‚ç„¶åŽæˆ‘ä»¬å°±å¯ä»¥å°†åœ¨åŒä¸€ä¸ªåŒºåŸŸçš„çº¿æ®µæ‹Ÿåˆä¸€æ¡ç›´çº¿
    
    *       # @Author : LiZhongzheng
            # å¼€å‘æ—¶é—´  ï¼š2025-04-29 15:58
            import cv2
            import numpy as np
            
            
            def calculate_slope(line):
                """
                è®¡ç®—çº¿æ®µlineçš„æ–œçŽ‡
                :param line: np.array([[x_1, y_1, x_2, y_2]])
                :return:
                """
                x_1, y_1, x_2, y_2 = line[0]
                return (y_2 - y_1) / (x_2 - x_1)
            
            
            edge_img = cv2.imread("masked_edge_img.jpg", cv2.IMREAD_GRAYSCALE)
            # èŽ·å–æ‰€æœ‰çº¿æ®µ
            lines = cv2.HoughLinesP(edge_img, 1, np.pi / 180, 15, minLineLength=40, maxLineGap=20)
            
            # æŒ‰ç…§æ–œçŽ‡åˆ†æˆè½¦é“çº¿
            left_lines = [line for line in lines if calculate_slope(line) > 0]
            right_lines = [line for line in lines if calculate_slope(line) < 0]
            
            
            def reject_abnormal_lines(lines, threshold):
                """
                å‰”é™¤æ–œçŽ‡ä¸ä¸€è‡´çš„çº¿æ®µ
                :param lines: çº¿æ®µé›†åˆ, [np.array([[x_1, y_1, x_2, y_2]]),np.array([[x_1, y_1, x_2, y_2]]),...,np.array([[x_1, y_1, x_2, y_2]])]
                """
                slopes = [calculate_slope(line) for line in lines]
                while len(lines) > 0:
                    mean = np.mean(slopes)
                    diff = [abs(s - mean) for s in slopes]
                    idx = np.argmax(diff)
                    if (diff[idx] > threshold):
                        slopes.pop(idx)
                        lines.pop(idx)
                    else:
                        break
                    return lines
            
            
            left_lines = reject_abnormal_lines(left_lines, threshold=0.2)
            right_lines = reject_abnormal_lines(right_lines, threshold=0.2)
            
            
            def least_squares_fit(lines):
                """
                å°†linesä¸­çš„çº¿æ®µæ‹Ÿåˆæˆä¸€æ¡çº¿æ®µ
                :param lines: çº¿æ®µé›†åˆ, [np.array([[x_1, y_1, x_2, y_2]]),np.array([[x_1, y_1, x_2, y_2]]),...,np.array([[x_1, y_1, x_2, y_2]])]
                :return: çº¿æ®µä¸Šçš„ä¸¤ç‚¹,np.array([[xmin, ymin], [xmax, ymax]])
                """
                # 1. å–å‡ºæ‰€æœ‰åæ ‡ç‚¹
                """
                åœ¨ OpenCV ä¸­ï¼Œçº¿æ®µé€šå¸¸ç”¨ä¸€ä¸ªå½¢çŠ¶ä¸º (1, 4) çš„ NumPy æ•°ç»„è¡¨ç¤ºï¼Œå…¶ä¸­åŒ…å«çº¿æ®µçš„ä¸¤ä¸ªç«¯ç‚¹çš„åæ ‡ã€‚
                å…·ä½“æ¥è¯´ï¼Œæ•°ç»„çš„æ ¼å¼ä¸º [x1, y1, x2, y2]ï¼Œåˆ†åˆ«è¡¨ç¤ºèµ·ç‚¹ (x1, y1) å’Œç»ˆç‚¹ (x2, y2)ã€‚
                """
                x_coords = np.ravel([[line[0][0], line[0][2]] for line in lines])  # np.ravel å°†äºŒç»´åˆ—è¡¨å±•å¹³ä¸ºä¸€ç»´æ•°ç»„
                y_coords = np.ravel([[line[0][1], line[0][3]] for line in lines])
                # 2. è¿›è¡Œç›´çº¿æ‹Ÿåˆ.å¾—åˆ°å¤šé¡¹å¼ç³»æ•°
                poly = np.polyfit(x_coords, y_coords, deg=1)
                # 3. æ ¹æ®å¤šé¡¹å¼ç³»æ•°,è®¡ç®—ä¸¤ä¸ªç›´çº¿ä¸Šçš„ç‚¹,ç”¨äºŽå”¯ä¸€ç¡®å®šè¿™æ¡ç›´çº¿
                point_min = (np.min(x_coords), np.polyval(poly, np.min(x_coords)))
                point_max = (np.max(x_coords), np.polyval(poly, np.max(x_coords)))
                return np.array([point_min, point_max], dtype=np.int32)
            
            
            print("left lane")
            print(least_squares_fit(left_lines))
            print("right lane")
            print(least_squares_fit(right_lines))
            
            
        

* * *

### ç›´çº¿ç»˜åˆ¶

ç»˜åˆ¶è½¦é“çº¿ cv2.line

    # @Author : LiZhongzheng
    # å¼€å‘æ—¶é—´  ï¼š2025-04-29 16:23
    import cv2
    import numpy as np
    
    
    def calculate_slope(line):
        """
        è®¡ç®—çº¿æ®µlineçš„æ–œçŽ‡
        :param line: np.array([[x_1, y_1, x_2, y_2]])
        :return:
        """
        x_1, y_1, x_2, y_2 = line[0]
        return (y_2 - y_1) / (x_2 - x_1)
    
    
    edge_img = cv2.imread('masked_edge_img.jpg', cv2.IMREAD_GRAYSCALE)
    # èŽ·å–æ‰€æœ‰çº¿æ®µ
    lines = cv2.HoughLinesP(edge_img, 1, np.pi / 180, 15, minLineLength=40,
                            maxLineGap=20)
    # æŒ‰ç…§æ–œçŽ‡åˆ†æˆè½¦é“çº¿
    left_lines = [line for line in lines if calculate_slope(line) > 0]
    right_lines = [line for line in lines if calculate_slope(line) < 0]
    
    
    def reject_abnormal_lines(lines, threshold):
        """
        å‰”é™¤æ–œçŽ‡ä¸ä¸€è‡´çš„çº¿æ®µ
        :param lines: çº¿æ®µé›†åˆ, [np.array([[x_1, y_1, x_2, y_2]]),np.array([[x_1, y_1, x_2, y_2]]),...,np.array([[x_1, y_1, x_2, y_2]])]
        """
        slopes = [calculate_slope(line) for line in lines]
        while len(lines) > 0:
            mean = np.mean(slopes)
            diff = [abs(s - mean) for s in slopes]
            idx = np.argmax(diff)
            if diff[idx] > threshold:
                slopes.pop(idx)
                lines.pop(idx)
            else:
                break
        return lines
    
    
    left_lines = reject_abnormal_lines(left_lines, threshold=0.2)
    right_lines = reject_abnormal_lines(right_lines, threshold=0.2)
    
    
    def least_squares_fit(lines):
        """
        å°†linesä¸­çš„çº¿æ®µæ‹Ÿåˆæˆä¸€æ¡çº¿æ®µ
        :param lines: çº¿æ®µé›†åˆ, [np.array([[x_1, y_1, x_2, y_2]]),np.array([[x_1, y_1, x_2, y_2]]),...,np.array([[x_1, y_1, x_2, y_2]])]
        :return: çº¿æ®µä¸Šçš„ä¸¤ç‚¹,np.array([[xmin, ymin], [xmax, ymax]])
        """
        # 1. å–å‡ºæ‰€æœ‰åæ ‡ç‚¹
        x_coords = np.ravel([[line[0][0], line[0][2]] for line in lines])
        y_coords = np.ravel([[line[0][1], line[0][3]] for line in lines])
        # 2. è¿›è¡Œç›´çº¿æ‹Ÿåˆ.å¾—åˆ°å¤šé¡¹å¼ç³»æ•°
        poly = np.polyfit(x_coords, y_coords, deg=1)
        # 3. æ ¹æ®å¤šé¡¹å¼ç³»æ•°,è®¡ç®—ä¸¤ä¸ªç›´çº¿ä¸Šçš„ç‚¹,ç”¨äºŽå”¯ä¸€ç¡®å®šè¿™æ¡ç›´çº¿
        point_min = (np.min(x_coords), np.polyval(poly, np.min(x_coords)))
        point_max = (np.max(x_coords), np.polyval(poly, np.max(x_coords)))
        return np.array([point_min, point_max], dtype=np.int32)
    
    
    left_line = least_squares_fit(left_lines)
    right_line = least_squares_fit(right_lines)
    
    img = cv2.imread('img.jpg', cv2.IMREAD_COLOR)
    cv2.line(img, tuple(left_line[0]), tuple(left_line[1]), color=(0, 255, 255), thickness=5)
    cv2.line(img, tuple(right_line[0]), tuple(right_line[1]), color=(0, 255, 255), thickness=5)
    
    cv2.imshow('lane', img)
    cv2.waitKey(0)
    
    

![image-20250429205831425](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250429205831425.png)

##### **é‡éš¾ç‚¹è®²è§£ï¼šleast\_squares\_fitï¼ˆï¼‰å‡½æ•°è®²è§£**

è¯¥å‡½æ•°ä¸»è¦åšäº†ä¸‰ä¸ªéƒ¨åˆ†ï¼šæå–åæ ‡ç‚¹ã€è¿›è¡Œç›´çº¿æ‹Ÿåˆã€è®¡ç®—ç›´çº¿ä¸Šçš„ä¸¤ä¸ªç‚¹ã€‚

###### 1\. æå–æ‰€æœ‰åæ ‡ç‚¹

    x_coords = np.ravel([[line[0][0], line[0][2]] for line in lines])
    y_coords = np.ravel([[line[0][1], line[0][3]] for line in lines])
    

*   **`lines`**ï¼š
    *   è¾“å…¥çš„çº¿æ®µé›†åˆï¼Œæ¯ä¸ªçº¿æ®µæ˜¯ä¸€ä¸ªå½¢çŠ¶ä¸º `(1, 4)` çš„ NumPy æ•°ç»„ï¼Œè¡¨ç¤ºçº¿æ®µçš„ä¸¤ä¸ªç«¯ç‚¹åæ ‡ \[_x_1,_y_1,_x_2,_y_2\]ã€‚
*   **`x_coords`**ï¼š
    *   æå–æ‰€æœ‰çº¿æ®µçš„ _x_ åæ ‡ã€‚`line[0][0]` æ˜¯èµ·ç‚¹çš„ _x_ åæ ‡ï¼Œ`line[0][2]` æ˜¯ç»ˆç‚¹çš„ _x_ åæ ‡ã€‚
    *   ä½¿ç”¨åˆ—è¡¨æŽ¨å¯¼å¼ `[[line[0][0], line[0][2]] for line in lines]` ç”Ÿæˆä¸€ä¸ªäºŒç»´åˆ—è¡¨ï¼ŒåŒ…å«æ‰€æœ‰çº¿æ®µçš„èµ·ç‚¹å’Œç»ˆç‚¹çš„ _x_ åæ ‡ã€‚
    *   ä½¿ç”¨ `np.ravel` å°†äºŒç»´åˆ—è¡¨å±•å¹³ä¸ºä¸€ç»´æ•°ç»„ã€‚
*   **`y_coords`**ï¼š
    *   æå–æ‰€æœ‰çº¿æ®µçš„ _y_ åæ ‡ã€‚`line[0][1]` æ˜¯èµ·ç‚¹çš„ _y_ åæ ‡ï¼Œ`line[0][3]` æ˜¯ç»ˆç‚¹çš„ _y_ åæ ‡ã€‚
    *   ä½¿ç”¨åˆ—è¡¨æŽ¨å¯¼å¼ `[[line[0][1], line[0][3]] for line in lines]` ç”Ÿæˆä¸€ä¸ªäºŒç»´åˆ—è¡¨ï¼ŒåŒ…å«æ‰€æœ‰çº¿æ®µçš„èµ·ç‚¹å’Œç»ˆç‚¹çš„ _y_ åæ ‡ã€‚
    *   ä½¿ç”¨ `np.ravel` å°†äºŒç»´åˆ—è¡¨å±•å¹³ä¸ºä¸€ç»´æ•°ç»„ã€‚

###### 2\. è¿›è¡Œç›´çº¿æ‹Ÿåˆ

    poly = np.polyfit(x_coords, y_coords, deg=1)
    

*   **`np.polyfit`**ï¼š
    *   è¿™æ˜¯ NumPy ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºŽå¯¹ç»™å®šçš„æ•°æ®ç‚¹è¿›è¡Œå¤šé¡¹å¼æ‹Ÿåˆã€‚
    *   å‚æ•°ï¼š
        *   `x_coords`ï¼šè‡ªå˜é‡ _x_ çš„å€¼ã€‚
        *   `y_coords`ï¼šå› å˜é‡ _y_ çš„å€¼ã€‚
        *   `deg=1`ï¼šæŒ‡å®šæ‹Ÿåˆå¤šé¡¹å¼çš„æ¬¡æ•°ä¸º 1ï¼Œå³**çº¿æ€§æ‹Ÿåˆ**ã€‚
    *   è¿”å›žå€¼ï¼š
        *   è¿”å›žæ‹Ÿåˆå¤šé¡¹å¼çš„ç³»æ•°ï¼Œä»Žæœ€é«˜æ¬¡é¡¹åˆ°å¸¸æ•°é¡¹ã€‚å¯¹äºŽçº¿æ€§æ‹Ÿåˆï¼Œè¿”å›žä¸¤ä¸ªå€¼ `[slope, intercept]`ï¼Œåˆ†åˆ«è¡¨ç¤ºç›´çº¿çš„æ–œçŽ‡å’Œæˆªè·ã€‚

###### 3\. è®¡ç®—ç›´çº¿ä¸Šçš„ä¸¤ä¸ªç‚¹

    point_min = (np.min(x_coords), np.polyval(poly, np.min(x_coords)))
    point_max = (np.max(x_coords), np.polyval(poly, np.max(x_coords)))
    

*   **`np.min(x_coords)`** å’Œ **`np.max(x_coords)`**ï¼š
    *   åˆ†åˆ«è®¡ç®— _x_ åæ ‡ä¸­çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ã€‚
*   **`np.polyval(poly, x)`**ï¼š
    *   è¿™æ˜¯ NumPy ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºŽè®¡ç®—å¤šé¡¹å¼åœ¨ç»™å®šçš„ _x_ å€¼å¤„çš„ _y_ å€¼ã€‚
    *   å‚æ•°ï¼š
        *   `poly`ï¼šæ‹Ÿåˆå¤šé¡¹å¼çš„ç³»æ•°æ•°ç»„ã€‚
        *   `x`ï¼šè¾“å…¥çš„ _x_ å€¼ã€‚
    *   è¿”å›žå€¼ï¼š
        *   è¿”å›žå¤šé¡¹å¼åœ¨ _x_ å¤„çš„ _y_ å€¼ã€‚
*   **`point_min`** å’Œ **`point_max`**ï¼š
    *   `point_min` æ˜¯ç›´çº¿ä¸Šçš„ä¸€ä¸ªç‚¹ï¼Œå…¶ _x_ åæ ‡ä¸ºæœ€å°å€¼ï¼Œ_y_ åæ ‡é€šè¿‡å¤šé¡¹å¼è®¡ç®—å¾—åˆ°ã€‚
    *   `point_max` æ˜¯ç›´çº¿ä¸Šçš„ä¸€ä¸ªç‚¹ï¼Œå…¶ _x_ åæ ‡ä¸ºæœ€å¤§å€¼ï¼Œ_y_ åæ ‡é€šè¿‡å¤šé¡¹å¼è®¡ç®—å¾—åˆ°ã€‚

###### 4\. è¿”å›žå€¼

    return np.array([point_min, point_max], dtype=np.int32)
    

*   è¿”å›žä¸€ä¸ªå½¢çŠ¶ä¸º `(2, 2)` çš„ NumPy æ•°ç»„ï¼Œè¡¨ç¤ºç›´çº¿ä¸Šçš„ä¸¤ä¸ªç‚¹çš„åæ ‡ã€‚è¿™ä¸¤ä¸ªç‚¹å¯ä»¥å”¯ä¸€ç¡®å®šä¸€æ¡ç›´çº¿ã€‚

* * *

### è§†é¢‘æµè¯»å†™

cv2.VideoCapture

â€‹ capture.read

*   åŸºç¡€ä»£ç ä»‹ç»ï¼š

    # @Author : LiZhongzheng
    # å¼€å‘æ—¶é—´  ï¼š2025-04-29 17:06
    import cv2
    
    capture = cv2.VideoCapture('video.mp4')
    # capture = cv2.VideoCapture(0) #è¯»å–å½“å‰è®¾å¤‡ç¬¬0ä¸ªæ‘„åƒå¤´
    while True:
        ret, frame = capture.read()  # ret è§†é¢‘æµçš„çŠ¶æ€ï¼Œframe å½“å‰å¸§çš„å›¾åƒ
        cv2.imshow('frame', frame)
        cv2.waitKey(20)  # ç›¸å½“äºŽæ’­æ”¾é€ŸçŽ‡
    
    

cv2.VideoWriter

æœ€åŽæˆ‘ä»¬ä¸ä»…å¯ä»¥è¯†åˆ«å›¾ç‰‡çš„è½¦é“çº¿è¿˜å¯ä»¥è¯†åˆ«è§†é¢‘çš„è½¦é“çº¿ï¼ŒåŽŸç†ç›¸åŒï¼Œå› ä¸ºè§†é¢‘æ˜¯ä¸€å¸§ä¸€å¸§çš„ï¼Œæ¯ä¸€å¸§å°±æ˜¯ä¸€ä¸ªå›¾ç‰‡ã€‚

    # @Author : LiZhongzheng
    # å¼€å‘æ—¶é—´  ï¼š2025-04-29 17:12
    import cv2
    import numpy as np
    
    
    def get_edge_img(color_img, gaussian_ksize=5, gaussian_sigmax=1, canny_threshold1=50, canny_threshold2=100):
        """
        ç°åº¦åŒ–,æ¨¡ç³Š,cannyå˜æ¢,æå–è¾¹ç¼˜
        :param color_img: å½©è‰²å›¾,channels=3
        """
        """
        cv2.GaussianBlur() å‡½æ•°å‚æ•°
        color_imgï¼š
        è¾“å…¥çš„å½©è‰²å›¾åƒï¼Œå¿…é¡»æ˜¯ 3 é€šé“çš„ BGR å›¾åƒã€‚
        gaussian_ksizeï¼ˆå¯é€‰ï¼‰ï¼š
        é«˜æ–¯æ¨¡ç³Šçš„æ ¸å¤§å°ã€‚å¿…é¡»æ˜¯æ­£å¥‡æ•°ï¼Œé»˜è®¤å€¼ä¸º 5ã€‚
        gaussian_sigmaxï¼ˆå¯é€‰ï¼‰ï¼š
        é«˜æ–¯æ¨¡ç³Šçš„ X æ–¹å‘æ ‡å‡†å·®ï¼Œé»˜è®¤å€¼ä¸º 1ã€‚
        """
        gaussian = cv2.GaussianBlur(color_img, (gaussian_ksize, gaussian_ksize),
                                    gaussian_sigmax)  # ä½¿ç”¨ cv2.GaussianBlur å¯¹è¾“å…¥å›¾åƒè¿›è¡Œé«˜æ–¯æ¨¡ç³Šå¤„ç†ã€‚é«˜æ–¯æ¨¡ç³Šå¯ä»¥å‡å°‘å›¾åƒä¸­çš„å™ªå£°ï¼Œä½¿è¾¹ç¼˜æ£€æµ‹æ›´åŠ ç¨³å®šã€‚
        gray_img = cv2.cvtColor(gaussian, cv2.COLOR_BGR2GRAY)
        edges_img = cv2.Canny(gray_img, canny_threshold1, canny_threshold2)
        return edges_img
    
    
    def roi_mask(gray_img):
        """
        å¯¹gray_imgè¿›è¡ŒæŽ©è†œ
        :param gray_img: ç°åº¦å›¾,channels=1
        """
        poly_pts = np.array([[[0, 368], [300, 210], [340, 210], [640, 368]]])
        mask = np.zeros_like(gray_img)
        mask = cv2.fillPoly(mask, pts=poly_pts, color=255)
        img_mask = cv2.bitwise_and(gray_img, mask)
        return img_mask
    
    
    def get_lines(edge_img):
        """
        èŽ·å–edge_imgä¸­çš„æ‰€æœ‰çº¿æ®µ
        :param edge_img: æ ‡è®°è¾¹ç¼˜çš„ç°åº¦å›¾
        """
    
        def calculate_slope(line):
            """
            è®¡ç®—çº¿æ®µlineçš„æ–œçŽ‡
            :param line: np.array([[x_1, y_1, x_2, y_2]])
            :return:
            """
            x_1, y_1, x_2, y_2 = line[0]
            return (y_2 - y_1) / (x_2 - x_1)
    
        def reject_abnormal_lines(lines, threshold=0.2):
            """
            å‰”é™¤æ–œçŽ‡ä¸ä¸€è‡´çš„çº¿æ®µ
            :param lines: çº¿æ®µé›†åˆ, [np.array([[x_1, y_1, x_2, y_2]]),np.array([[x_1, y_1, x_2, y_2]]),...,np.array([[x_1, y_1, x_2, y_2]])]
            """
            slopes = [calculate_slope(line) for line in lines]
            while len(lines) > 0:
                mean = np.mean(slopes)
                diff = [abs(s - mean) for s in slopes]
                idx = np.argmax(diff)
                if (diff[idx] > threshold):
                    slopes.pop(idx)
                    diff.pop(idx)
                else:
                    break
            return lines
    
        def least_squares_fit(lines):
            """
            å°†linesä¸­çš„çº¿æ®µæ‹Ÿåˆæˆä¸€æ¡çº¿æ®µ
            :param lines: çº¿æ®µé›†åˆ, [np.array([[x_1, y_1, x_2, y_2]]),np.array([[x_1, y_1, x_2, y_2]]),...,np.array([[x_1, y_1, x_2, y_2]])]
            :return: çº¿æ®µä¸Šçš„ä¸¤ç‚¹,np.array([[xmin, ymin], [xmax, ymax]])
            """
            """
            np.polyfit æ˜¯ NumPy åº“ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºŽå¯¹ç»™å®šçš„æ•°æ®ç‚¹è¿›è¡Œå¤šé¡¹å¼æ‹Ÿåˆã€‚
            å®ƒé€šè¿‡æœ€å°äºŒä¹˜æ³•æ‰¾åˆ°ä¸€ä¸ªå¤šé¡¹å¼ï¼Œä½¿å¾—è¿™ä¸ªå¤šé¡¹å¼åœ¨ç»™å®šæ•°æ®ç‚¹ä¸Šçš„å€¼ä¸Žå®žé™…å€¼ä¹‹é—´çš„è¯¯å·®å¹³æ–¹å’Œæœ€å°ã€‚
            """
            x_coords = np.ravel([[line[0][0], line[0][2]] for line in lines])
            y_coords = np.ravel([[line[0][1], line[0][3]] for line in lines])
            poly = np.polyfit(x_coords, y_coords, deg=1)
            point_min = (np.min(x_coords), np.polyval(poly, np.min(
                x_coords)))  # è¿™è¡Œä»£ç çš„ä½œç”¨æ˜¯è®¡ç®—æ‹Ÿåˆç›´çº¿ï¼ˆæˆ–å¤šé¡¹å¼æ›²çº¿ï¼‰ä¸Šçš„ä¸€ä¸ªç‰¹å®šç‚¹çš„åæ ‡ã€‚å…·ä½“æ¥è¯´ï¼Œå®ƒè®¡ç®—çš„æ˜¯å½“ x å–æœ€å°å€¼æ—¶ï¼Œå¯¹åº”çš„ y å€¼ï¼Œå¹¶å°†è¿™ä¸ªç‚¹çš„åæ ‡å­˜å‚¨ä¸ºä¸€ä¸ªå…ƒç»„ (x_min, y_min)ã€‚
            point_max = (np.max(x_coords), np.polyval(poly, np.max(x_coords)))
            return np.array([point_min, point_max], dtype=np.int32)
    
        # èŽ·å–æ‰€æœ‰çº¿æ®µ
        lines = cv2.HoughLinesP(edge_img, 1, np.pi / 180, 15, minLineLength=40,
                                maxLineGap=20)
        # æŒ‰ç…§æ–œçŽ‡åˆ†æˆè½¦é“çº¿
        left_lines = [line for line in lines if calculate_slope(line) > 0]
        right_lines = [line for line in lines if calculate_slope(line) < 0]
        # å‰”é™¤ç¦»ç¾¤çº¿æ®µ
        left_lines = reject_abnormal_lines(left_lines)
        right_lines = reject_abnormal_lines(right_lines)
    
        return least_squares_fit(left_lines), least_squares_fit(right_lines)
    
    
    def draw_lines(img, lines):
        """
        åœ¨imgä¸Šç»˜åˆ¶lines
        :param img:
        :param lines: ä¸¤æ¡çº¿æ®µ: [np.array([[xmin1, ymin1], [xmax1, ymax1]]), np.array([[xmin2, ymin2], [xmax2, ymax2]])]
        :return:
        """
        left_line, right_line = lines
        cv2.line(img, tuple(left_line[0]), tuple(left_line[1]), color=(0, 255, 255),
                 thickness=5)
        cv2.line(img, tuple(right_line[0]), tuple(right_line[1]),
                 color=(0, 255, 255), thickness=5)
    
    
    def show_lane(color_img):  # å°è£…
        """
        åœ¨color_imgä¸Šç”»å‡ºè½¦é“çº¿
        :param color_img: å½©è‰²å›¾,channels=3
        :return:
        """
        edge_img = get_edge_img(color_img)
        mask_gray_img = roi_mask(edge_img)
        lines = get_lines(mask_gray_img)
        draw_lines(color_img, lines)
        return color_img
    
    
    if __name__ == '__main__':
        capture = cv2.VideoCapture('video.mp4')
        while True:
            ret, frame = capture.read()
            frame = show_lane(frame)
            cv2.imshow('frame', frame)
            cv2.waitKey(10)
    
    

![image-20250429195914415](https://lzz-1340752507.cos.ap-shanghai.myqcloud.com/lzz/image-20250429195914415.png)

* * *

ä»¥ä¸Šå°±æ˜¯æˆ‘å¯¹è¿™ä¸ªé¡¹ç›®çš„æ€»ç»“ã€‚

åŒæ—¶å†æ¬¡è¯´æ˜Žæˆ‘å·²ç»å°†é¡¹ç›®ä¸Šä¼ åˆ°[githubé¡¹ç›®](https://github.com/lizhongzheng13/openCV_Lane_Detection/tree/main)ä¸­ï¼Œæ¬¢è¿Žå¤§å®¶å¤šå¤šæ”¯æŒï¼Œä½ ä»¬çš„æ”¯æŒæ˜¯æˆ‘æœ€å¤§çš„å‰è¿›åŠ¨åŠ›~~~

å†æ¬¡æ„Ÿè°¢bç«™upä¸» **å˜‰ç„¶ä»Šå¤©åƒå¸¦å˜**ï¼Œä»¥åŠå„ä½å¤§ä½¬çš„å®è´µæ„è§ã€‚

ç¥å¥½~