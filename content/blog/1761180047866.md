---
layout: post
title: '虚拟地址到应物理地址与FEAT_VIPT'
date: "2025-10-23T00:40:47Z"
---
虚拟地址到应物理地址与FEAT\_VIPT
=====================

**简短**  
本文是我读ARM手册时根据自己的理解做的一些记录  
虚拟地址（VA）到物理地址（PA）的转换是由 MMU（内存管理单元） 和 页表机制完成的。具体过程如何我举例分享一下我的理解

**ARM64 虚拟地址结构（假设 4KB 页大小）**  
介绍转换过程之前先来介绍虚拟地址构成  
虚拟地址一般使用四级页表结构，通常是 48 位，分段如下：

VA\[47:39\]

VA\[38:30\]

VA\[29:21\]

VA\[20:12\]

VA\[11:0\]

PGD（Page Global Directory）一级页表

PUD（Page Upper Directory）二级页表

PMD（Page Middle Directory）：三级页表

PTE（Page Table Entry）：四级页表/物理页

Offset 页内偏移/页内具体地址

比如地址 0x01234567  
VA\[47:39\] = 0x0 → PGD 索引  
VA\[38:30\] = 0x0 → PUD 索引  
VA\[29:21\] = 0x91 → PMD 索引  
VA\[20:12\] = 0x1A → PTE 索引  
VA\[11:0\] = 0x567 → 页内偏移

**MMU（Memory Management Unit）介绍**

*   MMU是处理器中的一个硬件模块，主要负责：
*   虚拟地址 → 物理地址转换
*   访问权限检查（如只读、用户/内核态）
*   缓存控制（决定哪些地址可缓存）
*   触发异常（如页错误、权限错误）  
    本文其实就是在讲它的一部分工作过程。

**TLB（Translation Lookaside Buffer）介绍**  
介绍转换过程之前先来介绍TLB，TLB是一个硬件缓存，缓存最近的 VA→PA 映射，用来加速地址转换，物理上在 MMU 内部或旁边。  
TLB 存储的内容包括

*   键（Key）：虚拟页号（VPN）即虚拟地址高位
*   值（Value）：物理页帧地址（PPN）+ 权限等信息

**转换过程**

1.  比如CPU 触发指令访问请求，使用虚拟地址 0x01234567，以linux为例
    
2.  MMU 会自动查询TLB，它问TLB有没有现成的转换好的物理地址？具体是指用地址的高位（如 47–12位）作为键去查找是否有对应的物理页帧地址  
    如果TLB 命中则返回物理地址结果，否则触发下面将要提及的页表遍历。
    
3.  MMU 启动页表遍历：
    
    *   从 TTBR（Translation Table Base Register）获取页表基地址
    *   使用 VA 的各段索引依次访问 PGD → PUD → PMD → PTE
4.  PTE 中记录了物理页的起始地址
    
5.  将页内偏移加到物理页地址上，即物理页帧地址 + 页内偏移，得到最终物理地址
    
6.  权限检查：MMU 检查该页是否允许读/写， 如果如果允许访问，继续执行并更新TLB，否则触发异常。
    

**VIPT拓展**  
如果是要获取这个地址对应的指令内容，则需要提及ARM 架构中的 FEAT\_VIPT（Virtually Indexed, Physically Tagged）指令缓存策略,  
从ARM8.0开始是强制性要求，指的是用虚拟地址索引+物理地址标记来加速访问。  
ARM 兼容处理器为了兼顾性能与灵活性，在指令缓存中采用 VIPT 策略，主要原因及说明如下：

1.  性能优化：使用虚拟地址索引可以在地址转换完成前就开始缓存查找，提升速度。

*   索引使用虚拟地址：用于定位缓存行（Cache Line）
*   标记Tag使用物理地址：用于验证缓存行是否匹配
*   CPU 可以立刻用虚拟地址的部分位（通常是页内偏移）来定位缓存集合（Cache Set），不需要等待 MMU 完成地址转换（VA → PA）
*   这就允许缓存查找和 TLB 查询并行进行，节省时间

2.  硬件简化：VIPT 可以减少 TLB（Translation Lookaside Buffer）访问延迟。

*   如果缓存查找必须等 TLB 返回结果（如 PIPT 策略），就会引入延迟。而 VIPT 策略允许：
*   先用虚拟地址索引缓存
*   同时启动 TLB 查询以获取物理地址用于标签匹配
*   如果缓存命中，TLB 查询结果可以用于验证
*   如果缓存未命中，TLB 结果用于访问主存
*   这种并行机制显著减少了等待 TLB 的时间，从而提升了指令访问速度。

3.  兼容性考虑：ARM 架构支持多种内存管理单元（MMU）配置，VIPT 更适合嵌入式系统或高性能场景。

我们以一个指令访问为例，  
假设虚拟地址为 VA = 0x12345678，页大小为 4KB，缓存大小为 32KB，采用 VIPT 策略。  
步骤 1：使用虚拟地址索引缓存集合（Cache Set）

*   页大小为 4KB → 页内偏移为 12 位（VA\[11:0\]）
*   假设缓存有 64 个集合（sets），需要 6 位索引 → 通常从 VA\[11:6\] 提取
*   CPU 立即用 VA 的这部分位定位到某个缓存集合，这一步不需要地址转换，速度快！

步骤 2：并行启动 TLB 查询

*   同时，MMU 使用虚拟地址启动页表查询或 TLB 查询
*   如果 TLB 命中，直接返回物理地址（PA）
*   如果 TLB 未命中，走页表遍历流程
*   这一步可能慢，但可以与索引并行进行.

步骤 3：查询缓存集合

*   缓存集合中一般有多个缓存行，每个缓存行都有一个 tag代表物理地址的高位，
*   我们用 TLB 返回的物理地址与缓存行的 tag 做比较，只有 tag 匹配才命中缓存。
*   tag 必须用物理地址？因为虚拟地址可能存在别名（aliasing）问题 - 两个不同的虚拟地址可能映射到同一个物理地址。
*   一个 64B 的缓存行大概是长这样

Tag

Valid

Dirty

LRU bits

Data\[0..63\]

物理地址的高 20 位

该行无/有效

数据被修改后是否已写回主存

决定哪个缓存行最久未使用

实际存储的数据块

步骤 4：命中则读取，未命中则访问主存

*   如果 tag 匹配 → 命中 → 直接读取缓存数据
*   如果 tag 不匹配 → 未命中 → 访问主存并更新缓存