---
layout: post
title: '微服务项目中基于 Servlet 的业务模块与 WebFlux 网关模块的 Redis 统一化配置教程'
date: "2025-08-14T00:43:09Z"
---
微服务项目中基于 Servlet 的业务模块与 WebFlux 网关模块的 Redis 统一化配置教程
===================================================

微服务项目中Servlet模块与WebFlux网关的Redis使用指南
===================================

在微服务架构的蓬勃发展浪潮中，Redis凭借其超高的性能、丰富的功能，已然成为缓存、分布式锁、会话存储等场景下的核心支撑技术。然而，在微服务项目里，基于Servlet的普通业务模块和基于WebFlux的网关模块，由于它们底层的技术架构存在显著差异，在使用Redis时也呈现出不同的特点和实现方式。下面，我们就深入探讨这两种场景下Redis的使用之道。

一、技术架构差异简析
----------

在微服务的技术生态中，基于Servlet的普通业务模块和基于WebFlux的网关模块，在处理请求的方式上有着本质区别。

基于Servlet的普通模块，遵循的是**同步阻塞**的I/O模型。这就意味着当一个请求进入模块后，线程会一直等待I/O操作完成，在这个过程中，线程无法去处理其他请求，容易造成线程资源的浪费，尤其是在高并发场景下，可能会出现线程池耗尽的情况。

而基于WebFlux的网关模块，则采用了**异步非阻塞**的I/O模型。它能够在一个线程上处理多个请求，当遇到I/O操作时，线程不会阻塞等待，而是会去处理其他请求，待I/O操作完成后再回来继续处理，极大地提高了线程的利用率，非常适合高并发、I/O密集型的网关场景。

这种底层技术架构的差异，直接影响了Redis在这两种模块中的使用方式。

二、基于Servlet的普通模块使用Redis
-----------------------

在基于Servlet的普通模块中，我们通常会选择**Spring Data Redis**作为操作Redis的框架，它对Redis的各种操作进行了友好封装，让开发者能够更便捷地使用Redis。

### （一）引入依赖

在 Maven 项目中，需要在`pom.xml`文件中引入相关依赖：

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
    </dependency>
    

其中，`spring-boot-starter-data-redis`是Spring Data Redis的 starter 依赖，`commons-pool2`为Redis连接池提供支持，有助于提高Redis连接的管理效率。

### （二）配置Redis连接

在`application.properties`或`application.yml`中进行Redis连接信息的配置：

    spring:
      redis:
        host: localhost
        port: 6379
        password: 123456
        lettuce:
          pool:
            max-active: 8
            max-idle: 8
            min-idle: 2
            max-wait: -1ms
    

这里配置了Redis的主机地址、端口、密码以及连接池参数。采用Lettuce作为Redis客户端，它是一个高性能的异步Redis客户端，在Spring Boot 2.x及以上版本中成为了默认的客户端。

### （三）Redis操作模板

Spring Data Redis提供了`RedisTemplate`和`StringRedisTemplate`两种模板类用于操作Redis。`StringRedisTemplate`是`RedisTemplate`的子类，专门用于处理键和值都是字符串的情况，使用起来更加便捷。

    @Component
    @RequiredArgsConstructor
    public class RedisUtils {
    
        private final RedisTemplate<String, Object> redisTemplate;
    
        public void set(String key, Object value) {
            redisTemplate.opsForValue().set(key, value);
        }
    
        public void set(String key, Object value, long timeout, TimeUnit unit) {
            redisTemplate.opsForValue().set(key, value, timeout, unit);
        }
    
        public void set(String key, Object value, long seconds) {
            redisTemplate.opsForValue().set(key, value, seconds, TimeUnit.SECONDS);
        }
    
        public Object get(String key) {
            return redisTemplate.opsForValue().get(key);
        }
    
        public String getString(String key) {
            Object obj = redisTemplate.opsForValue().get(key);
            return obj == null ? null : obj.toString();
        }
    
        public Boolean delete(String key) {
            return redisTemplate.delete(key);
        }
    
        public Boolean hasKey(String key) {
            return redisTemplate.hasKey(key);
        }
    
        public Boolean setNx(String key, Object value) {
            return redisTemplate.opsForValue().setIfAbsent(key, value);
        }
    
        public Boolean tryLock(String lockKey, String requestId, long seconds) {
            return redisTemplate.opsForValue().setIfAbsent(lockKey, requestId, seconds, TimeUnit.SECONDS);
        }
    
        public Boolean tryLock(String lockKey, String requestId, long timeout, TimeUnit unit) {
            return redisTemplate.opsForValue().setIfAbsent(lockKey, requestId, timeout, unit);
        }
    
        public Boolean releaseLock(String lockKey, String requestId) {
            DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
            redisScript.setScriptText(RELEASE_SCRIPT);
            redisScript.setResultType(Long.class);
            Long result = redisTemplate.execute(redisScript, Collections.singletonList(lockKey), requestId);
            return RELEASE_SUCCESS.equals(result);
        }
    }
    

在上述代码中，通过Lombok中热`@RequireArgsConstructor`注入`StringRedisTemplate`，然后利用其`opsForValue()`方法获取操作字符串类型数据的`ValueOperations`对象，进而实现对Redis中字符串数据的增、删、查等操作。

### （四）缓存注解的使用

Spring还提供了缓存注解，如`@Cacheable`、`@CachePut`、`@CacheEvict`等，可以更方便地实现缓存功能。

首先，需要在配置类上添加`@EnableCaching`注解开启缓存功能：

    @Configuration
    @EnableCaching
    public class RedisCacheConfig {
    
        @Bean
        public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
            RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                    .entryTtl(Duration.ofMinutes(10))
                    .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
                    .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()))
                    .disableCachingNullValues();
    
            return RedisCacheManager.builder(connectionFactory)
                    .cacheDefaults(config)
                    .build();
        }
    }
    

在这个配置中，定义了Redis缓存的默认配置，包括缓存过期时间、键和值的序列化方式等。使用`GenericJackson2JsonRedisSerializer`对值进行序列化，能够将对象转换为JSON格式存储，方便读取和解析。

然后在Service层的方法上使用缓存注解：

    @Service
    public class UserService {
    
        @Autowired
        private UserMapper userMapper;
    
        @Cacheable(value = "user", key = "#id")
        public User getUserById(Long id) {
            return userMapper.selectById(id);
        }
    
        @CachePut(value = "user", key = "#user.id")
        public User updateUser(User user) {
            userMapper.updateById(user);
            return user;
        }
    
        @CacheEvict(value = "user", key = "#id")
        public void deleteUser(Long id) {
            userMapper.deleteById(id);
        }
    }
    

`@Cacheable`表示在调用方法之前，会先从缓存中查询，如果缓存中存在，则直接返回缓存中的数据，不执行方法体；如果缓存中不存在，则执行方法体，并将方法的返回值存入缓存。`@CachePut`会将方法的返回值存入缓存，无论缓存中是否已存在该数据。`@CacheEvict`用于删除缓存中的数据。

三、基于WebFlux的Gateway中使用Redis
---------------------------

在基于WebFlux的Gateway中，由于WebFlux是异步非阻塞的，所以需要使用**响应式的Redis客户端**来操作Redis，以契合其异步非阻塞的特性。Spring提供了`spring-boot-starter-data-redis-reactive`来支持响应式Redis操作。

### （一）引入依赖

在`pom.xml`中引入响应式Redis的依赖：

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
    </dependency>
    

`spring-boot-starter-data-redis-reactive`提供了响应式的Redis操作支持，同样需要`commons-pool2`来支持连接池。

### （二）配置Redis连接

与基于Servlet的模块类似，在`application.yml`中配置Redis连接信息：

    spring:
      redis:
        host: localhost
        port: 6379
        password: 123456
        lettuce:
          pool:
            max-active: 8
            max-idle: 8
            min-idle: 2
            max-wait: -1ms
    

这里的配置与Servlet模块中的配置基本一致，因为连接Redis的基本信息是相同的。

### （三）响应式Redis操作

响应式Redis操作主要通过`ReactiveRedisTemplate`和`ReactiveStringRedisTemplate`来实现，它们返回的是`Mono`或`Flux`类型的结果，契合WebFlux的响应式编程模型。

    @Service
    public class ReactiveRedisService {
    
        @Autowired
        private ReactiveStringRedisTemplate reactiveStringRedisTemplate;
    
        // 设置字符串类型数据
        public Mono<Boolean> setString(String key, String value) {
            return reactiveStringRedisTemplate.opsForValue().set(key, value);
        }
    
        // 获取字符串类型数据
        public Mono<String> getString(String key) {
            return reactiveStringRedisTemplate.opsForValue().get(key);
        }
    
        // 设置带过期时间的字符串数据
        public Mono<Boolean> setStringWithExpire(String key, String value, long timeout, TimeUnit unit) {
            return reactiveStringRedisTemplate.opsForValue().set(key, value, timeout, unit);
        }
    
        // 删除数据
        public Mono<Long> delete(String key) {
            return reactiveStringRedisTemplate.delete(key);
        }
    }
    

在响应式操作中，每个方法返回的都是`Mono`类型，`Mono`表示一个包含0或1个元素的异步序列。当调用这些方法时，并不会立即执行Redis操作，而是返回一个操作的承诺，只有当订阅这个`Mono`时，操作才会真正执行。

### （四）在Gateway过滤器中使用Redis

在Gateway中，经常需要在过滤器中使用Redis来实现一些功能，如限流、令牌验证等。下面以一个简单的令牌验证过滤器为例：

    @Component
    public class TokenValidateFilter implements GlobalFilter, Ordered {
    
        @Autowired
        private ReactiveRedisService reactiveRedisService;
    
        @Override
        public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
            String token = exchange.getRequest().getHeaders().getFirst("token");
            if (token == null || token.isEmpty()) {
                exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                return exchange.getResponse().setComplete();
            }
    
            return reactiveRedisService.getString("token:" + token)
                    .flatMap(userId -> {
                        if (userId != null) {
                            // 令牌有效，继续执行后续过滤器
                            return chain.filter(exchange);
                        } else {
                            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                            return exchange.getResponse().setComplete();
                        }
                    })
                    .switchIfEmpty(Mono.defer(() -> {
                        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                        return exchange.getResponse().setComplete();
                    }));
        }
    
        @Override
        public int getOrder() {
            return -100;
        }
    }
    

在这个过滤器中，首先从请求头中获取令牌`token`，然后通过`ReactiveRedisService`从Redis中查询该令牌对应的用户ID。如果查询到结果，说明令牌有效，继续执行后续的过滤器；如果未查询到结果或令牌不存在，则返回未授权的响应。

这里充分利用了响应式编程的特性，通过`flatMap`、`switchIfEmpty`等操作符来处理异步流，保证了整个操作的异步非阻塞性。

四、两种场景下Redis使用的对比
-----------------

### （一）编程模型

基于Servlet的普通模块采用的是**同步阻塞**的编程模型，使用`RedisTemplate`进行Redis操作时，方法的调用会阻塞当前线程，直到操作完成。

基于WebFlux的Gateway采用的是**异步非阻塞**的编程模型，使用`ReactiveRedisTemplate`进行Redis操作时，方法返回`Mono`或`Flux`对象，不会阻塞线程，开发者通过订阅这些对象来处理操作结果。

### （二）性能表现

在高并发场景下，基于WebFlux的Gateway使用响应式Redis客户端能够更高效地利用线程资源，减少线程切换的开销，从而表现出更好的性能。

而基于Servlet的普通模块由于采用同步阻塞的方式，在面对大量并发请求时，可能会因为线程阻塞而导致性能瓶颈。

### （三）适用场景

基于Servlet的普通模块的Redis使用方式适用于**业务逻辑相对复杂、对响应时间要求不是特别高**的场景。

基于WebFlux的Gateway的Redis使用方式适用于**高并发、I/O密集型**的场景，如网关的限流、令牌验证等，能够更好地应对大量的并发请求。

五、总结
----

在微服务项目中，基于Servlet的普通模块和基于WebFlux的Gateway在使用Redis时，由于底层技术架构的不同，选择的Redis操作方式也有所差异。

普通模块通过`Spring Data Redis`的`RedisTemplate`进行同步操作，简单直观，适合处理复杂的业务逻辑；Gateway则通过`spring-boot-starter-data-redis-reactive`的`ReactiveRedisTemplate`进行异步非阻塞操作，能够更好地应对高并发场景。