---
layout: post
title: 'C# 中的 Span 和内存：.NET 中的高性能内存处理'
date: "2026-02-25T01:02:51Z"
---
C# 中的 Span 和内存：.NET 中的高性能内存处理
=============================

引言
--

现代 .NET 应用对性能的要求越来越高，尤其是在处理大数据、文件处理、网络通信和实时系统等场景下。传统的基于数组和字符串的内存处理方式常常会产生不必要的内存分配，这不仅增加了内存使用量，还会显著降低应用性能。

为了解决这些问题，C# 引入了 Span 和 Memory 这两种类型，它们提供了一种快速高效的内存处理方式，无需进行额外的内存分配。这些类型允许开发者安全高效地操作数据切片，既提升了性能，又减轻了垃圾回收器的压力。

本文将深入探讨 Span 和 Memory 的工作原理、关键特性、使用场景以及性能优势，帮助 .NET 开发者更好地理解和运用这些高性能内存处理工具。

### 什么是 Span？

Span 是一种轻量级的值类型，它表示一段连续的内存区域。与传统的数组操作不同，Span 允许开发者直接访问和操作内存中的数据，而无需进行数据复制。

Span 可以指向多种内存来源：

*   数组
*   栈内存
*   原生内存(非托管内存)
*   字符串

Span 的关键优势在于它避免了不必要的内存分配。传统的数组或字符串操作通常会创建新的对象并复制数据，而 Span 直接在现有内存上工作，这使得应用程序更加高效。

    // 示例：使用 Span 操作数组
    int[] array = new int[100];
    Span<int> span = array.AsSpan();
    
    // 直接修改原始数组
    span[0] = 10;
    span.Slice(10, 20).Fill(1); // 填充部分数据
    

### Span 的重要性

传统操作如获取子字符串或数组切片通常会在内存中创建新的对象。这些额外的内存分配不仅增加了垃圾回收器的工作负担，还会降低应用性能。

Span 通过创建对现有内存的"视图"而非复制数据来解决这个问题，这带来了以下优势：

*   更快的执行速度
*   减少内存使用量
*   提升整体性能
*   减少垃圾回收频率

Span 特别适用于高性能应用场景，如：

*   Web 服务器
*   数据解析器
*   实时系统
*   大规模数据处理

### Span 的主要特性

Span 提供了多项重要特性，使其成为高性能内存处理的理想选择：

1.  **堆外分配**：Span 不在堆上分配内存，从而提升性能
2.  **切片支持**：允许直接操作数组的部分数据而无需复制
3.  **类型和内存安全**：提供安全的访问方式，防止内存越界等问题
4.  **减轻GC压力**：减少垃圾回收器的工作负担
5.  **大数据处理**：在大型数据处理场景中表现优异

    // 示例：Span 的切片操作
    byte[] buffer = new byte[1024];
    Span<byte> bufferSpan = buffer.AsSpan();
    
    // 处理前512字节
    ProcessData(bufferSpan.Slice(0, 512));
    
    // 处理后512字节
    ProcessData(bufferSpan.Slice(512));
    

### 什么是 Memory？

Memory 类型与 Span 类似，但它设计用于更广泛的场景，特别是异步编程。关键区别在于：

*   Span 只能用于同步方法(栈上分配)
*   Memory 可用于异步方法并存储在字段中
*   Memory 代表可以存在于堆上的内存，能在异步操作间传递

虽然 Memory 比 Span 稍慢，但它提供了更大的灵活性，同时仍保持良好的性能。

    // 示例：在异步方法中使用 Memory
    async Task ProcessDataAsync(Memory<byte> dataMemory)
    {
        // 异步处理数据
        await Task.Run(() => ProcessData(dataMemory.Span));
        
        // 可以存储 Memory 供后续使用
        _storedMemory = dataMemory;
    }
    

### Span 与 Memory 的区别

理解 Span 和 Memory 的区别对正确使用它们至关重要^[\[1\]](#fn1)：

特性

Span

Memory

分配位置

栈上

堆上

使用场景

同步方法

同步/异步方法

存储位置

不能存储在类字段

可存储在类字段

性能

更高

稍低但更灵活

生命周期

短时操作

长期存在

选择原则：

*   对短生命期、高性能的同步操作使用 Span
*   对异步或需要长期存在的内存操作使用 Memory

### 何时使用 Span

在以下场景中，Span 是最佳选择：

1.  **同步代码**中处理数组、缓冲区或字符串
2.  **数据解析**：如解析协议、文件格式等
3.  **文件处理**：高效读写大文件
4.  **大规模数据集**：需要高性能处理时
5.  **性能关键**部分：当内存优化至关重要时

    // 示例：使用 Span 解析字符串
    string s = "127.0.0.1:8080";
    ReadOnlySpan<char> span = s.AsSpan();
    
    int colonPos = span.IndexOf(':');
    if (colonPos > 0)
    {
        var ipSpan = span.Slice(0, colonPos);
        var portSpan = span.Slice(colonPos + 1);
        
        // 处理IP和端口
    }
    

### 何时使用 Memory

在以下场景中，应该选择 Memory：

1.  **异步方法**中处理内存数据
2.  需要**存储和传递**内存引用时
3.  **异步文件操作**：如后台文件处理
4.  **管道处理**：如数据流水线
5.  **后台处理**：需要长时间持有数据时

    // 示例：使用 Memory 进行异步文件处理
    async Task<Memory<byte>> ReadFileAsync(string path)
    {
        byte[] buffer = await File.ReadAllBytesAsync(path);
        return new Memory<byte>(buffer);
    }
    

### 实际应用场景

Span 和 Memory 已被广泛应用于各种高性能场景：

1.  **高性能Web API**：ASP.NET Core 内部使用 Span 提升性能
2.  **文件处理系统**：高效处理大文件
3.  **网络应用**：协议解析和数据包处理
4.  **实时系统**：低延迟数据处理
5.  **游戏开发**：高效内存操作
6.  **解析器和序列化器**：快速数据转换

例如，ASP.NET Core 在其内部管道中大量使用 Span 来优化请求处理性能，特别是在以下方面：

*   请求头解析
*   URL 解码
*   JSON 序列化/反序列化
*   响应写入

### 性能优势

使用 Span 和 Memory 能带来显著的性能提升：

1.  **减少内存分配**：避免不必要的内存分配和复制
2.  **提升执行速度**：直接操作内存，减少中间步骤
3.  **降低GC压力**：减少垃圾回收频率和停顿时间
4.  **高效资源利用**：更适合高负载应用

测试数据显示，在某些场景下使用 Span 可以带来：

*   内存分配减少 90% 以上
*   执行速度提升 2-5 倍
*   GC 停顿时间显著缩短

    // 性能对比示例：字符串处理
    // 传统方式 - 产生新字符串
    string substring = bigString.Substring(start, length);
    
    // 使用 Span - 无额外分配
    ReadOnlySpan<char> span = bigString.AsSpan().Slice(start, length);
    

### 最佳实践

为了充分发挥 Span 和 Memory 的优势，应遵循以下最佳实践：

1.  **生命周期匹配**：
    
    *   短生命期操作使用 Span
    *   长生命期或异步操作使用 Memory
2.  **避免过度使用**：
    
    *   仅在性能关键部分使用
    *   简单场景不必过度优化
3.  **内存管理**：
    
    *   处理大数据时避免不必要的分配
    *   注意内存边界和安全性
4.  **API选择**：
    
    *   优先使用接受 Span/Memory 的 API
    *   如 `Stream.Read(Span<byte>)` 而非 `Stream.Read(byte[], int, int)`
5.  **类型转换**：
    
    *   必要时在 Span 和 Memory 间转换
    *   注意转换时的生命周期约束

    // 最佳实践示例：高效读取流
    async Task<int> ReadStreamAsync(Stream stream, Memory<byte> buffer)
    {
        // 同步部分使用 Span
        int bytesRead = stream.Read(buffer.Span);
        
        // 异步处理
        await ProcessDataAsync(buffer.Slice(0, bytesRead));
        
        return bytesRead;
    }
    

结论
--

Span 和 Memory 是 C# 中强大的内存处理工具，它们使开发者能够编写高性能且内存高效的应用程序。通过安全地操作内存而无需额外分配，这些类型显著提升了 .NET 应用的性能表现。

Span 特别适合快速、同步的内存操作，而 Memory 则更适合异步和长期存在的场景。正确理解并使用这些工具可以带来：

*   显著的性能提升
*   内存使用量减少
*   资源管理优化

对于现代 .NET 开发者而言，掌握 Span 和 Memory 是构建可扩展、高性能应用程序的关键技能。随着 .NET 生态对高性能的持续追求，这些工具将在更多场景中发挥重要作用。

* * *

1.  Difference Between Span and Memory 部分参考内容 [↩︎](#fnref1)
    

* * *

  

本文是由葡萄城技术开发团队发布，转载请注明出处：[葡萄城官网](https://www.grapecity.com.cn/)