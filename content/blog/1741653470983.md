---
layout: post
title: '【设计模式】从火车站卖票看代理模式的实际应用'
date: "2025-03-11T00:37:50Z"
---
【设计模式】从火车站卖票看代理模式的实际应用
======================

概述
--

由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。

结构
--

代理（Proxy）模式分为三种角色：

*   抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。
    
*   真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
    
*   代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
    

静态代理
----

我们通过案例来感受一下静态代理。

【例】火车站卖票

如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271755120.png)

代码如下：

    //卖票接口
    public interface SellTickets {
        void sell();
    }
    
    //火车站  火车站具有卖票功能，所以需要实现SellTickets接口
    public class TrainStation implements SellTickets {
    
        public void sell() {
            System.out.println("火车站卖票");
        }
    }
    
    //代售点
    public class ProxyPoint implements SellTickets {
    
        private TrainStation station = new TrainStation();
    
        public void sell() {
            System.out.println("代理点收取一些服务费用");
            station.sell();
        }
    }
    
    //测试类
    public class Client {
        public static void main(String[] args) {
            ProxyPoint pp = new ProxyPoint();
            pp.sell();
        }
    }
    

从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。

JDK动态代理
-------

接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。

代码如下：

    //卖票接口
    public interface SellTickets {
        void sell();
    }
    
    //火车站  火车站具有卖票功能，所以需要实现SellTickets接口
    public class TrainStation implements SellTickets {
    
        public void sell() {
            System.out.println("火车站卖票");
        }
    }
    
    //代理工厂，用来创建代理对象
    public class ProxyFactory {
    
        private TrainStation station = new TrainStation();
    
        public SellTickets getProxyObject() {
            //使用Proxy获取代理对象
            /*
                newProxyInstance()方法参数说明：
                    ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可
                    Class<?>[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口
                    InvocationHandler h ： 代理对象的调用处理程序
             */
            SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),
                    station.getClass().getInterfaces(),
                    new InvocationHandler() {
                        /*
                            InvocationHandler中invoke方法参数说明：
                                proxy ： 代理对象
                                method ： 对应于在代理对象上调用的接口方法的 Method 实例
                                args ： 代理对象调用接口方法时传递的实际参数
                         */
                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    
                            System.out.println("代理点收取一些服务费用(JDK动态代理方式)");
                            //执行真实对象
                            Object result = method.invoke(station, args);
                            return result;
                        }
                    });
            return sellTickets;
        }
    }
    
    //测试类
    public class Client {
        public static void main(String[] args) {
            //获取代理对象
            ProxyFactory factory = new ProxyFactory();
            
            SellTickets proxyObject = factory.getProxyObject();
            proxyObject.sell();
        }
    }
    

使用了动态代理，我们思考下面问题：

*   ProxyFactory是代理类吗？

ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：

    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;
    import java.lang.reflect.UndeclaredThrowableException;
    
    public final class $Proxy0 extends Proxy implements SellTickets {
        private static Method m1;
        private static Method m2;
        private static Method m3;
        private static Method m0;
    
        public $Proxy0(InvocationHandler invocationHandler) {
            super(invocationHandler);
        }
    
        static {
            try {
                m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
                m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
                m3 = Class.forName("com.itheima.proxy.dynamic.jdk.SellTickets").getMethod("sell", new Class[0]);
                m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
                return;
            }
            catch (NoSuchMethodException noSuchMethodException) {
                throw new NoSuchMethodError(noSuchMethodException.getMessage());
            }
            catch (ClassNotFoundException classNotFoundException) {
                throw new NoClassDefFoundError(classNotFoundException.getMessage());
            }
        }
    
        public final boolean equals(Object object) {
            try {
                return (Boolean)this.h.invoke(this, m1, new Object[]{object});
            }
            catch (Error | RuntimeException throwable) {
                throw throwable;
            }
            catch (Throwable throwable) {
                throw new UndeclaredThrowableException(throwable);
            }
        }
    
        public final String toString() {
            try {
                return (String)this.h.invoke(this, m2, null);
            }
            catch (Error | RuntimeException throwable) {
                throw throwable;
            }
            catch (Throwable throwable) {
                throw new UndeclaredThrowableException(throwable);
            }
        }
    
        public final int hashCode() {
            try {
                return (Integer)this.h.invoke(this, m0, null);
            }
            catch (Error | RuntimeException throwable) {
                throw throwable;
            }
            catch (Throwable throwable) {
                throw new UndeclaredThrowableException(throwable);
            }
        }
    
        public final void sell() {
            try {
                this.h.invoke(this, m3, null);
                return;
            }
            catch (Error | RuntimeException throwable) {
                throw throwable;
            }
            catch (Throwable throwable) {
                throw new UndeclaredThrowableException(throwable);
            }
        }
    }
    

从上面的类中，我们可以看到以下几个信息：

*   代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。
    
*   代理类（$Proxy0）将我们提供的匿名内部类对象传递给了父类。
    

动态代理的执行流程是什么样？下面是摘取的重点代码：

    //程序运行过程中动态生成的代理类
    public final class $Proxy0 extends Proxy implements SellTickets {
        private static Method m3;
    
        public $Proxy0(InvocationHandler invocationHandler) {
            super(invocationHandler);
        }
    
        static {
            m3 = Class.forName("com.itheima.proxy.dynamic.jdk.SellTickets").getMethod("sell", new Class[0]);
        }
    
        public final void sell() {
            this.h.invoke(this, m3, null);
        }
    }
    
    //Java提供的动态代理相关类
    public class Proxy implements java.io.Serializable {
        protected InvocationHandler h;
         
        protected Proxy(InvocationHandler h) {
            this.h = h;
        }
    }
    
    //代理工厂类
    public class ProxyFactory {
    
        private TrainStation station = new TrainStation();
    
        public SellTickets getProxyObject() {
            SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),
                    station.getClass().getInterfaces(),
                    new InvocationHandler() {
                        
                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    
                            System.out.println("代理点收取一些服务费用(JDK动态代理方式)");
                            Object result = method.invoke(station, args);
                            return result;
                        }
                    });
            return sellTickets;
        }
    }
    
    
    //测试访问类
    public class Client {
        public static void main(String[] args) {
            //获取代理对象
            ProxyFactory factory = new ProxyFactory();
            SellTickets proxyObject = factory.getProxyObject();
            proxyObject.sell();
        }
    }
    

执行流程如下：

1.  在测试类中通过代理对象调用sell()方法
2.  根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法
3.  代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法
4.  invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法

CGLIB动态代理
---------

同样是上面的案例，我们再次使用CGLIB代理实现。

如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。

CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。

CGLIB是第三方提供的包，所以需要引入jar包的坐标：

    <dependency>
        <groupId>cglib</groupId>
        <artifactId>cglib</artifactId>
        <version>2.2.2</version>
    </dependency>
    

代码如下：

    //火车站
    public class TrainStation {
    
        public void sell() {
            System.out.println("火车站卖票");
        }
    }
    
    //代理工厂
    public class ProxyFactory implements MethodInterceptor {
    
        private TrainStation target = new TrainStation();
    
        public TrainStation getProxyObject() {
            //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数
            Enhancer enhancer =new Enhancer();
            //设置父类的字节码对象
            enhancer.setSuperclass(target.getClass());
            //设置回调函数
            enhancer.setCallback(this);
            //创建代理对象
            TrainStation obj = (TrainStation) enhancer.create();
            return obj;
        }
    
        /*
            intercept方法参数说明：
                o ： 代理对象
                method ： 真实对象中的方法的Method实例
                args ： 实际参数
                methodProxy ：代理对象中的方法的method实例
         */
        public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
            System.out.println("代理点收取一些服务费用(CGLIB动态代理方式)");
            TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);
            return result;
        }
    }
    
    //测试类
    public class Client {
        public static void main(String[] args) {
            //创建代理工厂对象
            ProxyFactory factory = new ProxyFactory();
            //获取代理对象
            TrainStation proxyObject = factory.getProxyObject();
    
            proxyObject.sell();
        }
    }
    

三种代理的对比
-------

*   jdk代理和CGLIB代理

使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。

在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。

*   动态代理和静态代理

动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。

如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题

优缺点
---

**优点：**

*   代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
    
*   代理对象可以扩展目标对象的功能；
    
*   代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；
    

**缺点：**

*   增加了系统的复杂度；

使用场景
----

*   远程（Remote）代理

本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。

*   防火墙（Firewall）代理

当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。

*   保护（Protect or Access）代理

控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。

往期推荐
----

*   [《SpringBoot》EasyExcel实现百万数据的导入导出](https://mp.weixin.qq.com/s/qb4XACLMRNgsNdi5DdevhA)
*   [《SpringBoot》史上最全SpringBoot相关注解介绍](https://mp.weixin.qq.com/s/MgC_iK536FxTLgm7CJMlqQ)
*   [Spring框架IoC核心详解](https://mp.weixin.qq.com/s/-3H6VyhKfl9byf6ifnk1ug)
*   [万字长文带你窥探Spring中所有的扩展点](https://mp.weixin.qq.com/s/O0W6vCuqQfeAH0UB7elpeA)
*   [如何实现一个通用的接口限流、防重、防抖机制](https://mp.weixin.qq.com/s/tATN-g66NyW5BzyiHWoRkA)
*   [万字长文带你深入Redis底层数据结构](https://mp.weixin.qq.com/s/gg6N6e90ZtbA0MH4KIEHlg)
*   [volatile关键字最全原理剖析](https://mp.weixin.qq.com/s/QhOFMEJWjIJM0jVFsCfJdA)

本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top