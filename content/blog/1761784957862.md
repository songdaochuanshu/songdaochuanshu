---
layout: post
title: 'ã€URPã€‘Unity[æŠ—é”¯é½¿]åŸç†å®ç°ä¸å¯¹æ¯”'
date: "2025-10-30T00:42:37Z"
---
ã€URPã€‘Unity\[æŠ—é”¯é½¿\]åŸç†å®ç°ä¸å¯¹æ¯”
========================

![ã€URPã€‘Unity[æŠ—é”¯é½¿]åŸç†å®ç°ä¸å¯¹æ¯”](https://img2024.cnblogs.com/blog/3685400/202510/3685400-20251030082614211-1881306615.png) å†å²å‘å±•èŠ‚ç‚¹ â€Œ2001å¹´â€Œï¼šMSAAæˆä¸ºDirectX 8æ ‡å‡†é…ç½®ï¼Œé€šè¿‡ç¡¬ä»¶å¤šé‡‡æ ·è§£å†³å‡ ä½•é”¯é½¿ â€Œ2009å¹´â€Œï¼šNVIDIAæ¨å‡ºFXAAï¼Œå¼€åˆ›åå¤„ç†æŠ—é”¯é½¿æ—¶ä»£ â€Œ2011å¹´â€Œï¼šSMAA 1.0å‘å¸ƒï¼Œ

> [ã€ä»UnityURPå¼€å§‹æ¢ç´¢æ¸¸æˆæ¸²æŸ“ã€‘](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**ä¸“æ -ç›´è¾¾**

**å†å²å‘å±•èŠ‚ç‚¹**
==========

*   â€Œ**2001å¹´**â€Œï¼šMSAAæˆä¸ºDirectX 8æ ‡å‡†é…ç½®ï¼Œé€šè¿‡ç¡¬ä»¶å¤šé‡‡æ ·è§£å†³å‡ ä½•é”¯é½¿
*   â€Œ**2009å¹´**â€Œï¼šNVIDIAæ¨å‡ºFXAAï¼Œå¼€åˆ›åå¤„ç†æŠ—é”¯é½¿æ—¶ä»£
*   â€Œ**2011å¹´**â€Œï¼šSMAA 1.0å‘å¸ƒï¼Œå¹³è¡¡æ€§èƒ½ä¸ç”»è´¨
*   â€Œ**2014å¹´**â€Œï¼šTAAå¼€å§‹æ™®åŠï¼Œè§£å†³åŠ¨æ€åœºæ™¯æŠ—é”¯é½¿é—®é¢˜
*   â€Œ**2017å¹´**â€Œï¼šUnity URPé›†æˆå…¨ç³»åˆ—æŠ—é”¯é½¿æ–¹æ¡ˆ

**æŠ—é”¯é½¿æŠ€æœ¯å®ç°åŸç†**
=============

**å¿«é€Ÿè¿‘ä¼¼æŠ—é”¯é½¿(FXAA)**
-----------------

é€šè¿‡å…¨å±åå¤„ç†æ£€æµ‹è¾¹ç¼˜åƒç´ å¹¶è¿›è¡Œé¢œè‰²æ··åˆï¼Œé‡‡ç”¨äº®åº¦å¯¹æ¯”åº¦é˜ˆå€¼è¯†åˆ«é”¯é½¿åŒºåŸŸï¼Œä½¿ç”¨ä½é€šæ»¤æ³¢å™¨å¹³æ»‘è¾¹ç¼˜ã€‚å…¶æ ¸å¿ƒæ˜¯ç‰ºç‰²å°‘é‡é”åº¦æ¢å–æ€§èƒ½ä¼˜åŠ¿ï¼Œå¤„ç†è¿‡ç¨‹å®Œå…¨åœ¨åƒç´ ç©ºé—´è¿›è¡Œï¼Œä¸ä¾èµ–å‡ ä½•ä¿¡æ¯ã€‚

### â€Œ**å®ç°åŸç†**â€Œï¼š

é€šè¿‡å…¨å±åå¤„ç†æ£€æµ‹åƒç´ é—´äº®åº¦å·®å¼‚ï¼ˆå¦‚RGBé€šé“å¯¹æ¯”åº¦ï¼‰ï¼Œå¯¹è¶…è¿‡é˜ˆå€¼çš„è¾¹ç¼˜åŒºåŸŸè¿›è¡Œä½é€šæ»¤æ³¢æ··åˆã€‚ä¾‹å¦‚ï¼Œå½“æ£€æµ‹åˆ°æ–œçº¿è¾¹ç¼˜æ—¶ï¼Œä¼šæ¨¡ç³Šç›¸é‚»åƒç´ ä»¥æ¶ˆé™¤é˜¶æ¢¯çŠ¶é”¯é½¿â€Œã€‚

### **æ ¸å¿ƒæµç¨‹**â€Œï¼š

*   äº®åº¦è®¡ç®—ï¼šä½¿ç”¨RGBè½¬äº®åº¦å…¬å¼`luma = dot(rgb, float3(0.299, 0.587, 0.114))` é‡‡ç”¨ITU-R BT.709æ ‡å‡†æƒé‡.
    
*   è¾¹ç¼˜æ£€æµ‹ï¼šå¯¹æ¯”3x3åŒºåŸŸå†…åƒç´ äº®åº¦å·®ï¼Œè¶…è¿‡é˜ˆå€¼åˆ™æ ‡è®°ä¸ºè¾¹ç¼˜
    
*   æ–¹å‘åˆ¤å®šï¼šè®¡ç®—æ°´å¹³/å‚ç›´äº®åº¦æ¢¯åº¦ï¼Œç¡®å®šè¾¹ç¼˜èµ°å‘ï¼ˆNW-SEæˆ–NE-SWï¼‰
    
*   æ··åˆæ‰§è¡Œï¼šæ²¿è¾¹ç¼˜æ–¹å‘è¿›è¡Œ5-tapæ»¤æ³¢ï¼ŒåŠ æƒå¹³å‡ç›¸é‚»åƒç´ é¢œè‰²
    
*   FXAA.shader
    
    *   **å…³é”®å‚æ•°è¯´æ˜**
        *   â€Œ**äº®åº¦è®¡ç®—**â€Œï¼šé‡‡ç”¨`0.2126729, 0.7151522, 0.0721750`æƒé‡ç¬¦åˆsRGBæ ‡å‡†
        *   â€Œ**è¾¹ç¼˜é˜ˆå€¼**â€Œï¼š`edgeThresholdMin`é˜²æ­¢è¿‡åº¦å¤„ç†å¹³æ»‘åŒºåŸŸï¼Œ`edgeThreshold`åŠ¨æ€é€‚åº”é«˜äº®åº¦åŒºåŸŸ
        *   â€Œ**æ–¹å‘åˆ¤å®š**â€Œï¼šé€šè¿‡æ°´å¹³å’Œå‚ç›´æ–¹å‘çš„äºŒé˜¶å·®åˆ†ç¡®å®šä¸»è¾¹ç¼˜æ–¹å‘
        *   â€Œ**å­åƒç´ æ··åˆ**â€Œï¼š`subpixelBlend`æ§åˆ¶äºšåƒç´ çº§æ··åˆå¼ºåº¦ï¼Œæ”¹å–„ç»†çº¿è¡¨ç°
    *   **URPé›†æˆè¦ç‚¹**
        *   é€šè¿‡`RenderFeature`æ·»åŠ åˆ°URPæ¸²æŸ“ç®¡çº¿
        *   éœ€åœ¨ç›¸æœºè®¾ç½®ä¸­ç¦ç”¨MSAA/TAAç­‰å†²çªæŠ—é”¯é½¿
        *   çº¹ç†é‡‡æ ·ä½¿ç”¨URPæ ‡å‡†çš„`SAMPLE_TEXTURE2D`å®
    
        Shader "Hidden/Universal Render Pipeline/FXAA"
        {
            HLSLINCLUDE
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        
            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            float4 _MainTex_TexelSize;
        
            // ITU-R BT.709äº®åº¦ç³»æ•°
            float Luminance(float3 rgb)
            {
                return dot(rgb, float3(0.2126729, 0.7151522, 0.0721750));
            }
        
            // è¾¹ç¼˜æ£€æµ‹ç»“æ„ä½“
            struct EdgeData {
                float m, n, e, s, w;
                float highest, lowest, contrast;
            };
        
            EdgeData SampleLumaNeighborhood(float2 uv)
            {
                EdgeData ed;
                float2 offset = _MainTex_TexelSize.xy;
        
                ed.m = Luminance(SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv).rgb);
                ed.n = Luminance(SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv + float2(0,  offset.y)).rgb);
                ed.e = Luminance(SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv + float2(offset.x, 0)).rgb);
                ed.s = Luminance(SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv - float2(0,  offset.y)).rgb);
                ed.w = Luminance(SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv - float2(offset.x, 0)).rgb);
        
                ed.highest = max(max(max(max(ed.n, ed.e), ed.s), ed.w), ed.m);
                ed.lowest = min(min(min(min(ed.n, ed.e), ed.s), ed.w), ed.m);
                ed.contrast = ed.highest - ed.lowest;
                return ed;
            }
        
            float4 FXAA_Pass(float2 uv)
            {
                // å‚æ•°é…ç½®
                float edgeThresholdMin = 0.03125;
                float edgeThreshold = 0.125;
                float subpixelBlend = 0.75;
        
                EdgeData ed = SampleLumaNeighborhood(uv);
        
                // è¾¹ç¼˜æ£€æµ‹æ¡ä»¶
                if(ed.contrast < max(edgeThresholdMin, ed.highest * edgeThreshold))
                    return SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv);
        
                // è®¡ç®—æ··åˆæ–¹å‘
                float horizontal = abs(ed.n + ed.s - 2.0 * ed.m) * 2.0 + 
                                  abs(ed.e + ed.w - 2.0 * ed.m);
                float vertical = abs(ed.e + ed.w - 2.0 * ed.m) * 2.0 + 
                                abs(ed.n + ed.s - 2.0 * ed.m);
        
                bool isHorizontal = horizontal >= vertical;
        
                // è¾¹ç¼˜ç«¯ç‚¹æ£€æµ‹
                float2 edgeDir = isHorizontal ? 
                    float2(0, _MainTex_TexelSize.y) : 
                    float2(_MainTex_TexelSize.x, 0);
        
                // 5-tapæ··åˆ
                float3 rgbA = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv - edgeDir * 0.5).rgb;
                float3 rgbB = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv + edgeDir * 0.5).rgb;
                float3 rgbC = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv - edgeDir).rgb;
                float3 rgbD = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv + edgeDir).rgb;
        
                // åŠ æƒæ··åˆ
                float blendFactor = 0.5 * (Luminance(rgbA) + Luminance(rgbB)) - Luminance(ed.m);
                blendFactor = saturate(blendFactor / ed.contrast) * subpixelBlend;
        
                float3 finalColor = lerp(
                    lerp(rgbC, rgbD, 0.5),
                    lerp(rgbA, rgbB, 0.5),
                    blendFactor
                );
        
                return float4(finalColor, 1.0);
            }
        
            ENDHLSL
        
            SubShader
            {
                Pass
                {
                    Name "FXAA"
                    HLSLPROGRAM
                    #pragma vertex Vert
                    #pragma fragment Frag
        
                    struct Attributes {
                        float4 positionOS : POSITION;
                        float2 uv : TEXCOORD0;
                    };
        
                    struct Varyings {
                        float4 positionCS : SV_POSITION;
                        float2 uv : TEXCOORD0;
                    };
        
                    Varyings Vert(Attributes input)
                    {
                        Varyings output;
                        output.positionCS = TransformObjectToHClip(input.positionOS.xyz);
                        output.uv = input.uv;
                        return output;
                    }
        
                    float4 Frag(Varyings input) : SV_Target
                    {
                        return FXAA_Pass(input.uv);
                    }
                    ENDHLSL
                }
            }
        }
        
    

### â€Œ**ä¼˜åŠ¿**â€Œï¼š

*   æ€§èƒ½æ¶ˆè€—æœ€ä½ï¼ˆä»…éœ€1æ¬¡å…¨å±é‡‡æ ·ï¼‰
*   å…¼å®¹æ‰€æœ‰GPUæ¶æ„â€Œ

### **åŠ£åŠ¿**â€Œï¼š

*   å¯¼è‡´ç”»é¢æ•´ä½“æ¨¡ç³Šï¼ˆå°¤å…¶å½±å“é«˜å…‰åŒºåŸŸï¼‰
*   æ— æ³•å¤„ç†æ—¶é—´æ€§é”¯é½¿ï¼ˆå¦‚åŠ¨æ€ç‰©ä½“ï¼‰â€Œ

### **é™åˆ¶**â€Œï¼š

*   ä¸é€‚ç”¨äºHDRPçš„å»¶è¿Ÿæ¸²æŸ“ç®¡çº¿â€Œ

**å­åƒç´ å½¢æ€æŠ—é”¯é½¿(SMAA)**
------------------

åˆ†ä¸‰é˜¶æ®µå®ç°ï¼šè¾¹ç¼˜æ£€æµ‹ï¼ˆåŸºäºé¢œè‰²/æ·±åº¦å·®ï¼‰ã€æƒé‡è®¡ç®—ï¼ˆåˆ†æè¾¹ç¼˜æ¨¡å¼ï¼‰ã€æ··åˆæ‰§è¡Œï¼ˆæ²¿è¾¹ç¼˜æ–¹å‘æ’å€¼ï¼‰ã€‚ç›¸æ¯”FXAAèƒ½ä¿ç•™æ›´å¤šé«˜é¢‘ç»†èŠ‚ï¼Œé€šè¿‡å½¢æ€å­¦å¤„ç†è¯†åˆ«åƒç´ çº§è¾¹ç¼˜èµ°å‘ã€‚

### **æ ¸å¿ƒåŸç†æµç¨‹**

*   â€Œ**è¾¹ç¼˜æ£€æµ‹é˜¶æ®µ**â€Œï¼šä½¿ç”¨Sobelç®—å­åˆ†æåƒç´ äº®åº¦æ¢¯åº¦ï¼Œç”Ÿæˆè¾¹ç¼˜çº¹ç†ï¼ˆåˆ†ä¸ºæ°´å¹³å’Œå‚ç›´è¾¹ç¼˜ï¼‰
    
*   â€Œ**æƒé‡è®¡ç®—é˜¶æ®µ**â€Œï¼šé€šè¿‡AreaTexå’ŒSearchTexåˆ†æè¾¹ç¼˜å½¢æ€ï¼ˆLå½¢/Tå½¢/å¯¹è§’çº¿ï¼‰ï¼Œè®¡ç®—æ··åˆæƒé‡
    
*   â€Œ**æ··åˆæ‰§è¡Œé˜¶æ®µ**â€Œï¼šæ ¹æ®æƒé‡å¯¹è¾¹ç¼˜åƒç´ è¿›è¡ŒåŒçº¿æ€§æ’å€¼æ··åˆï¼Œä¿ç•™é«˜é¢‘ç»†èŠ‚
    
*   SMAA.hlsl
    
    *   **å…³é”®å®ç°è§£æ**
        *   â€Œ**ä¸‰é˜¶æ®µæ¶æ„**â€Œï¼šéœ€åˆ›å»ºä¸‰ä¸ªç‹¬ç«‹Passåˆ†åˆ«å¯¹åº”è¾¹ç¼˜æ£€æµ‹ã€æƒé‡è®¡ç®—å’Œæ··åˆé˜¶æ®µ
        *   â€Œ**çº¹ç†èµ„æº**â€Œï¼šä¾èµ–é¢„è®¡ç®—çš„AreaTexï¼ˆå­˜å‚¨æ··åˆæ¨¡å¼ï¼‰å’ŒSearchTexï¼ˆå­˜å‚¨æœç´¢æ–¹å‘ï¼‰ï¼Œéœ€å¯¼å…¥ä¸ºTexture2Dèµ„æº
        *   â€Œ**åŠ¨æ€é˜ˆå€¼**â€Œï¼šé‡‡ç”¨ç›¸å¯¹äº®åº¦å·®ï¼ˆ0.1é˜ˆå€¼ï¼‰æ£€æµ‹è¾¹ç¼˜ï¼Œé¿å…å›ºå®šé˜ˆå€¼å¯¼è‡´çš„è¿‡æ£€æµ‹
    *   **URPé›†æˆè¦ç‚¹**
        *   â€Œ**RenderPassé…ç½®**â€Œï¼šåœ¨URP Rendererä¸­æŒ‰é¡ºåºæ·»åŠ ä¸‰ä¸ªRenderFeature
        *   â€Œ**çº¹ç†ç»‘å®š**â€Œï¼šé€šè¿‡`_AreaTex`å’Œ`_SearchTex`å‚æ•°ä¼ é€’é¢„è®¡ç®—çº¹ç†
        *   â€Œ**æ€§èƒ½ä¼˜åŒ–**â€Œï¼šä½¿ç”¨`linear_clamp_sampler`å‡å°‘çº¹ç†é‡‡æ ·å¼€é”€
    
        // è¾¹ç¼˜æ£€æµ‹é˜¶æ®µ
        Texture2D _MainTex;
        Texture2D _BlendTex;
        SamplerState linear_clamp_sampler;
        
        // é¢„è®¡ç®—çº¹ç†
        Texture2D _AreaTex; // å­˜å‚¨æ··åˆæ¨¡å¼(512x512)
        Texture2D _SearchTex; // å­˜å‚¨æœç´¢æ–¹å‘(64x16)
        
        struct EdgeData {
            float2 uv;
            float4 offsets[3];
        };
        
        EdgeData SMAAEdgeDetectionVS(float4 position : POSITION, float2 uv : TEXCOORD0) {
            EdgeData output;
            output.uv = uv;
            float4 texelSize = _MainTex_TexelSize.xyxy * float4(1.0, 1.0, -1.0, -1.0);
            output.offsets[0] = uv.xyxy + texelSize.xyxy * float4(-1.0, 0.0, 0.0, -1.0);
            output.offsets[1] = uv.xyxy + texelSize.xyxy * float4(1.0, 0.0, 0.0, 1.0);
            output.offsets[2] = uv.xyxy + texelSize.xyxy * float4(-2.0, 0.0, 0.0, -2.0);
            return output;
        }
        
        float4 SMAAColorEdgeDetectionPS(EdgeData input) : SV_Target {
            float L = Luminance(_MainTex.Sample(linear_clamp_sampler, input.uv).rgb);
            float delta1 = Luminance(_MainTex.Sample(linear_clamp_sampler, input.offsets[0].xy).rgb) - L;
            float delta2 = L - Luminance(_MainTex.Sample(linear_clamp_sampler, input.offsets[0].zw).rgb);
            float2 edges = step(float2(0.1, 0.1), abs(float2(delta1, delta2)));
            return float4(edges, 0.0, 1.0);
        }
        
        // æƒé‡è®¡ç®—é˜¶æ®µ
        float4 SMAABlendingWeightCalculationPS(EdgeData input) : SV_Target {
            float2 area = _AreaTex.Sample(linear_clamp_sampler, input.uv).rg;
            float2 search = _SearchTex.Sample(linear_clamp_sampler, input.uv).rg;
            float4 weights = float4(area.r, area.g, search.r, search.g);
            return weights;
        }
        
        // æ··åˆé˜¶æ®µ
        float4 SMAANeighborhoodBlendingPS(EdgeData input) : SV_Target {
            float4 weights = _BlendTex.Sample(linear_clamp_sampler, input.uv);
            float3 color = _MainTex.Sample(linear_clamp_sampler, input.uv).rgb;
            float3 color1 = _MainTex.Sample(linear_clamp_sampler, input.uv + float2(weights.r, 0.0)).rgb;
            float3 color2 = _MainTex.Sample(linear_clamp_sampler, input.uv + float2(0.0, weights.g)).rgb;
            return float4(lerp(color, (color1 + color2) * 0.5, weights.b), 1.0);
        }
        
    

### â€Œ**å®ç°åŸç†**â€Œï¼š

åˆ†ä¸‰é˜¶æ®µå¤„ç†ï¼š

*   â€Œ**è¾¹ç¼˜æ£€æµ‹**â€Œï¼šåŸºäºé¢œè‰²/æ·±åº¦æ¢¯åº¦è¯†åˆ«é”¯é½¿è¾¹ç¼˜
*   â€Œ**æ¨¡å¼åˆ†æ**â€Œï¼šé€šè¿‡å½¢æ€å­¦ç®—æ³•ï¼ˆå¦‚è…èš€/è†¨èƒ€ï¼‰ç¡®å®šè¾¹ç¼˜èµ°å‘
*   â€Œ**åƒç´ æ··åˆ**â€Œï¼šæ²¿æ£€æµ‹åˆ°çš„è¾¹ç¼˜æ–¹å‘æ’å€¼ï¼ˆå¦‚æ–œçº¿è¾¹ç¼˜æŒ‰45Â°æ–¹å‘æ··åˆï¼‰â€Œ

### **ä¼˜åŠ¿**â€Œï¼š

*   ä¿ç•™æ›´å¤šé«˜é¢‘ç»†èŠ‚ï¼ˆå¦‚UIæ–‡å­—é”åº¦ï¼‰
*   æ€§èƒ½æ¶ˆè€—ä»…ä¸ºMSAAçš„1/3â€Œ

### **åŠ£åŠ¿**â€Œï¼š

*   å¯¹å¤æ‚å…‰ç…§é”¯é½¿ï¼ˆå¦‚SSRåå°„ï¼‰æ•ˆæœæœ‰é™â€Œ

### **é™åˆ¶**â€Œï¼š

*   éœ€URP 12.0+ç‰ˆæœ¬æ”¯æŒâ€Œ

**å¤šé‡é‡‡æ ·æŠ—é”¯é½¿(MSAA)**
-----------------

åœ¨å…‰æ …åŒ–é˜¶æ®µå¯¹æ¯ä¸ªåƒç´ è¿›è¡Œå¤šé‡é‡‡æ ·ï¼ˆ2x/4x/8xï¼‰ï¼Œè®¡ç®—è¦†ç›–ç‡å’Œæ·±åº¦å€¼ååˆå¹¶æ ·æœ¬ã€‚ä»…å¯¹å‡ ä½•è¾¹ç¼˜æœ‰æ•ˆï¼Œé€šè¿‡ç¡¬ä»¶åŠ é€Ÿå®ç°ç‰©ç†çº§æŠ—é”¯é½¿ï¼Œä½†å¯¹ç€è‰²é”¯é½¿æ— æ•ˆä¸”æ¶ˆè€—æ˜¾å­˜å¸¦å®½ã€‚

### **å®ç°åŸç†**â€Œï¼š

åœ¨å…‰æ …åŒ–é˜¶æ®µå¯¹æ¯ä¸ªåƒç´ è¿›è¡Œå¤šé‡é‡‡æ ·ï¼ˆå¦‚4x MSAAé‡‡æ ·4ä¸ªæ·±åº¦/é¢œè‰²å€¼ï¼‰ï¼Œåˆå¹¶æ—¶é€šè¿‡æƒé‡è®¡ç®—å¹³æ»‘è¾¹ç¼˜ã€‚ä¾‹å¦‚ï¼Œä¸‰è§’å½¢è¾¹ç¼˜åƒç´ ä¼šæ··åˆéƒ¨åˆ†è¦†ç›–çš„æ ·æœ¬â€Œã€‚

### **æ ¸å¿ƒåŸç†æµç¨‹**

*   â€Œ**å¤šé‡é‡‡æ ·é˜¶æ®µ**â€Œï¼šç¡¬ä»¶åœ¨å…‰æ …åŒ–æ—¶å¯¹æ¯ä¸ªåƒç´ ç”Ÿæˆå¤šä¸ªå­æ ·æœ¬ï¼ˆ2x/4x/8xï¼‰ï¼Œåˆ†åˆ«è®¡ç®—æ·±åº¦å’Œæ¨¡æ¿å€¼
    
*   â€Œ**æ ·æœ¬åˆå¹¶é˜¶æ®µ**â€Œï¼šé€šè¿‡åŠ æƒå¹³å‡å­æ ·æœ¬é¢œè‰²å€¼ç”Ÿæˆæœ€ç»ˆåƒç´ è¾“å‡ºï¼Œå¹³æ»‘å‡ ä½•è¾¹ç¼˜é”¯é½¿
    
*   â€Œ**æ·±åº¦ä¸€è‡´æ€§æ£€æµ‹**â€Œï¼šè‡ªåŠ¨å¤„ç†å­æ ·æœ¬é—´çš„æ·±åº¦å·®å¼‚ï¼Œä¿ç•™é”åˆ©å‡ ä½•è½®å»“
    
*   MSAA\_URP.shader
    
    *   **å®ç°è§£æ**
        *   â€Œ**ç¡¬ä»¶çº§é›†æˆ**â€Œï¼šMSAAé€šè¿‡`#pragma multi_compile`æŒ‡ä»¤æ¿€æ´»GPUç¡¬ä»¶æ”¯æŒï¼Œæ— éœ€æ‰‹åŠ¨å®ç°é‡‡æ ·é€»è¾‘
        *   â€Œ**æ·±åº¦å¤„ç†ä¼˜åŒ–**â€Œï¼šè‡ªåŠ¨å¤„ç†å­æ ·æœ¬é—´çš„æ·±åº¦å·®å¼‚ï¼Œä¿ç•™å‡ ä½•è¾¹ç¼˜é”åº¦
        *   â€Œ**å…‰ç…§å…¼å®¹æ€§**â€Œï¼šæ¼”ç¤ºä¸URPå…‰ç…§ç³»ç»Ÿçš„æ— ç¼é›†æˆï¼Œé˜´å½±è®¡ç®—åŒæ ·å—ç›ŠäºMSAA
    *   **URPé…ç½®è¦ç‚¹**
        *   â€Œ**è´¨é‡è®¾ç½®**â€Œï¼šåœ¨URP Assetä¸­å¯ç”¨MSAAï¼ˆ2x/4x/8xï¼‰
        *   â€Œ**æ¸²æŸ“ç›®æ ‡**â€Œï¼šéœ€ä½¿ç”¨æ”¯æŒMSAAçš„RenderTextureæ ¼å¼ï¼ˆå¦‚`RenderTextureFormat.DefaultHDR`ï¼‰
        *   â€Œ**æ€§èƒ½è€ƒé‡**â€Œï¼š4x MSAAåœ¨ç§»åŠ¨ç«¯TBRæ¶æ„ä¸Šæ€§èƒ½æŸè€—è¾ƒä½ï¼Œé€‚åˆé«˜ç«¯ç§»åŠ¨è®¾å¤‡
    
        Shader "Universal Render Pipeline/MSAA"
        {
            Properties
            {
                _MainTex ("Base (RGB)", 2D) = "white" {}
            }
        
            SubShader
            {
                Tags { "RenderType"="Opaque" "RenderPipeline"="UniversalPipeline" }
        
                Pass
                {
                    Name "MSAA_Pass"
                    HLSLPROGRAM
                    #pragma vertex vert
                    #pragma fragment frag
                    #pragma multi_compile _ _MAIN_LIGHT_SHADOWS
                    #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
                    #pragma multi_compile _ _ADDITIONAL_LIGHTS
                    #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
                    #pragma multi_compile _ _SHADOWS_SOFT
        
                    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
                    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
        
                    struct Attributes
                    {
                        float4 positionOS : POSITION;
                        float2 uv : TEXCOORD0;
                    };
        
                    struct Varyings
                    {
                        float4 positionCS : SV_POSITION;
                        float2 uv : TEXCOORD0;
                        float3 positionWS : TEXCOORD1;
                    };
        
                    TEXTURE2D(_MainTex);
                    SAMPLER(sampler_MainTex);
        
                    Varyings vert(Attributes input)
                    {
                        Varyings output;
                        VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz);
                        output.positionCS = vertexInput.positionCS;
                        output.uv = input.uv;
                        output.positionWS = vertexInput.positionWS;
                        return output;
                    }
        
                    half4 frag(Varyings input) : SV_Target
                    {
                        // ç¡¬ä»¶è‡ªåŠ¨å¤„ç†MSAAé‡‡æ ·
                        half4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, input.uv);
        
                        // å…‰ç…§è®¡ç®—ï¼ˆæ¼”ç¤ºMSAAä¸å…‰ç…§çš„å…¼å®¹æ€§ï¼‰
                        Light mainLight = GetMainLight();
                        float3 N = normalize(cross(ddy(input.positionWS), ddx(input.positionWS)));
                        float diffuse = saturate(dot(N, mainLight.direction));
                        return color * (diffuse * mainLight.color + mainLight.shadowAttenuation);
                    }
                    ENDHLSL
                }
            }
        }
        
    

### â€Œ**ä¼˜åŠ¿**â€Œï¼š

*   ç‰©ç†çº§æŠ—é”¯é½¿ï¼ˆå¯¹å‡ ä½•è¾¹ç¼˜æ•ˆæœæœ€ä½³ï¼‰
*   æ”¯æŒç¡¬ä»¶åŠ é€Ÿï¼ˆå¦‚DX12çš„MSAAä¼˜åŒ–ï¼‰â€Œ

### **åŠ£åŠ¿**â€Œï¼š

*   æ˜¾å­˜å¸¦å®½æ¶ˆè€—é«˜ï¼ˆ8x MSAAå¢åŠ 50%å¸¦å®½ï¼‰
*   å¯¹ç€è‰²å™¨é”¯é½¿æ— æ•ˆï¼ˆå¦‚çº¹ç†è¿‡æ»¤ï¼‰â€Œ

### **é™åˆ¶**â€Œï¼š

*   éœ€å…³é—­URPçš„å»¶è¿Ÿæ¸²æŸ“åŠŸèƒ½â€Œ
    
    | ç‰¹æ€§ | MSAA | FXAA/SMAA |  
    | --- | --- | --- |  
    | å¤„ç†é˜¶æ®µ | å…‰æ …åŒ–é˜¶æ®µ | åå¤„ç†é˜¶æ®µ |  
    | æ•ˆæœèŒƒå›´ | ä»…å‡ ä½•è¾¹ç¼˜ | å…¨å›¾åƒ |  
    | æ€§èƒ½æ¶ˆè€— | ä¸­-é«˜ï¼ˆå–å†³äºé‡‡æ ·æ•°ï¼‰ | ä½-ä¸­ |  
    | å…¼å®¹æ€§ | éœ€ç¡¬ä»¶æ”¯æŒ | å…¨å¹³å°é€šç”¨ |
    

**æ—¶é—´æŠ—é”¯é½¿(TAA)**
--------------

åˆ©ç”¨å†å²å¸§æ•°æ®å’Œè¿åŠ¨å‘é‡ï¼Œå°†å½“å‰å¸§ä¸å‰ä¸€å¸§æŠ—é”¯é½¿ç»“æœè¿›è¡Œæ—¶åŸŸæ··åˆã€‚é€šè¿‡é‡æŠ•å½±æŠ€æœ¯è§£å†³åŠ¨æ€ç‰©ä½“é—®é¢˜ï¼Œéœ€é…åˆåŠ¨æ€æ¨¡ç³ŠæŠ‘åˆ¶é‡å½±ç°è±¡ï¼Œå¯¹åŠ¨æ€åœºæ™¯æ•ˆæœæœ€ä½³ã€‚

### â€Œ**å®ç°åŸç†**â€Œï¼š

åˆ©ç”¨å†å²å¸§æ•°æ®ï¼ˆè¿åŠ¨å‘é‡+æ·±åº¦ç¼“å†²ï¼‰è¿›è¡Œæ—¶åŸŸæ··åˆï¼š

*   â€Œ**é‡æŠ•å½±**â€Œï¼šå°†å½“å‰å¸§ä¸å†å²å¸§å¯¹é½
*   â€Œ**æŠ–åŠ¨è¡¥å¿**â€Œï¼šé€šè¿‡éšæœºæŠ–åŠ¨å‡å°‘é‡å½±
*   â€Œ**ç´¯ç§¯æ»¤æ³¢**â€Œï¼šåŠ æƒèåˆå¤šå¸§ç»“æœâ€Œ

### **æ ¸å¿ƒåŸç†æµç¨‹**

*   â€Œ**å¸§é—´æŠ–åŠ¨é‡‡æ ·**â€Œï¼šé€šè¿‡Haltonåºåˆ—å¯¹æŠ•å½±çŸ©é˜µæ–½åŠ å¾®å°åç§»ï¼Œä½¿é‡‡æ ·ç‚¹åœ¨æ—¶é—´ç»´åº¦ä¸Šå‡åŒ€åˆ†å¸ƒ
*   â€Œ**è¿åŠ¨å‘é‡è¿½è¸ª**â€Œï¼šåˆ©ç”¨\_CameraMotionVectorsTextureè®°å½•åƒç´ ä½ç§»ï¼Œç»“åˆæ·±åº¦çº¹ç†å¤„ç†è¾¹ç¼˜è¿åŠ¨
*   â€Œ**å†å²å¸§æ··åˆ**â€Œï¼šé€šè¿‡çº¿æ€§æ’å€¼ï¼ˆlerpï¼‰å°†å½“å‰å¸§ä¸å†å²ç¼“å†²æ•°æ®èåˆï¼ŒåŠ¨æ€è°ƒæ•´æ··åˆæƒé‡
*   TAA.shader
    *   **å…³é”®æŠ€æœ¯è§£æ**
        
        *   â€Œ**è¿åŠ¨å‘é‡å¤„ç†**â€Œï¼šé€šè¿‡\_CameraMotionVectorsTextureè·å–åƒç´ ä½ç§»ï¼Œç¡®ä¿å†å²å¸§é‡‡æ ·ä½ç½®å‡†ç¡®
        *   â€Œ**åŠ¨æ€æ··åˆç­–ç•¥**â€Œï¼šåŸºäºè¿åŠ¨å‘é‡é•¿åº¦è°ƒæ•´æ··åˆæƒé‡ï¼Œé™æ€åŒºåŸŸæƒé‡ä½ï¼ˆä¿ç•™æ›´å¤šå†å²æ•°æ®ï¼‰ï¼ŒåŠ¨æ€åŒºåŸŸæƒé‡é«˜ï¼ˆå‡å°‘æ‹–å½±ï¼‰
        *   â€Œ**æŠ•å½±çŸ©é˜µæŠ–åŠ¨**â€Œï¼šåœ¨C#è„šæœ¬ä¸­ä¿®æ”¹ç›¸æœºæŠ•å½±çŸ©é˜µå®ç°Haltonåºåˆ—åç§»ï¼Œéœ€é…åˆUNITY\_MATRIX\_PREV\_VPçŸ©é˜µä½¿ç”¨
    *   **URPé›†æˆè¦ç‚¹**
        
        *   â€Œ**RenderFeatureé…ç½®**â€Œï¼šéœ€åˆ›å»ºTAARenderFeatureå¹¶è®¾ç½®æ‰§è¡Œæ—¶æœºä¸º`RenderPassEvent.BeforeRenderingPostProcessing`
        *   â€Œ**åŒç¼“å†²å†å²çº¹ç†**â€Œï¼šä½¿ç”¨ä¸¤ä¸ªRenderTextureäº¤æ›¿å­˜å‚¨å†å²å¸§æ•°æ®ï¼Œé¿å…è¯»å†™å†²çª
        *   â€Œ**è¿åŠ¨å‘é‡ç”Ÿæˆ**â€Œï¼šéœ€ä¸ºåŠ¨æ€ç‰©ä½“æ·»åŠ MotionVector Passï¼Œé™æ€ç‰©ä½“å¯ç›´æ¥ä½¿ç”¨ç›¸æœºè¿åŠ¨çŸ©é˜µ
    *   **æ€§èƒ½ä¼˜åŒ–å»ºè®®**
        
        *   â€Œ**åˆ†è¾¨ç‡é™é‡‡æ ·**â€Œï¼šå¯¹å†å²ç¼“å†²ä½¿ç”¨åŠåˆ†è¾¨ç‡çº¹ç†ï¼ˆéœ€é…åˆåŒçº¿æ€§æ»¤æ³¢ï¼‰
        *   â€Œ**è¾¹ç¼˜é”åŒ–åå¤„ç†**â€Œï¼šåœ¨TAAåæ·»åŠ FXAAæˆ–è‡ªå®šä¹‰é”åŒ–Passè¡¥å¿è¿‡åº¦æ¨¡ç³Š
        *   â€Œ**ç§»åŠ¨ç«¯é€‚é…**â€Œï¼šå°†è¿åŠ¨å‘é‡è®¡ç®—ç§»è‡³é¡¶ç‚¹ç€è‰²å™¨ï¼Œå‡å°‘Fragmentè®¡ç®—é‡
        *   è¯¥æ–¹æ¡ˆç›¸æ¯”SMAAèƒ½æœ‰æ•ˆå‡å°‘æ¬¡åƒç´ é—ªçƒï¼Œç‰¹åˆ«é€‚åˆå¤„ç†åŠ¨æ€æ¤è¢«å’Œç»†å°ç½‘æ ¼çš„é”¯é½¿é—®é¢˜ã€‚å®é™…éƒ¨ç½²æ—¶éœ€æ³¨æ„å¤„ç†é€æ˜ç‰©ä½“çš„è¿åŠ¨å‘é‡ç”Ÿæˆé—®é¢˜
        
            Shader "Universal Render Pipeline/TAA"
            {
                Properties
                {
                    _MainTex("Base (RGB)", 2D) = "white" {}
                    _HistoryTex("History Buffer", 2D) = "black" {}
                }
            
                HLSLINCLUDE
                #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
                TEXTURE2D(_MainTex);
                TEXTURE2D(_HistoryTex);
                TEXTURE2D(_CameraMotionVectorsTexture);
                SAMPLER(sampler_linear_clamp);
            
                struct Varyings
                {
                    float4 positionCS : SV_POSITION;
                    float2 uv : TEXCOORD0;
                };
            
                // Haltonåºåˆ—ç”ŸæˆæŠ–åŠ¨åç§»
                float2 GetJitterOffset(uint frameIndex)
                {
                    const float2 seq = float2(
                        0.5f * (frameIndex % 8 + 1) / 8.0f,
                        0.5f * (frameIndex % 16 + 1) / 16.0f
                    );
                    return (seq - 0.5f) * _ScreenParams.zw;
                }
            
                Varyings Vert(uint vertexID : SV_VertexID)
                {
                    Varyings output;
                    output.positionCS = GetFullScreenTriangleVertexPosition(vertexID);
                    output.uv = GetFullScreenTriangleTexCoord(vertexID);
                    return output;
                }
            
                float4 Frag(Varyings input) : SV_Target
                {
                    // è·å–è¿åŠ¨å‘é‡
                    float2 motion = SAMPLE_TEXTURE2D(_CameraMotionVectorsTexture, sampler_linear_clamp, input.uv).xy;
            
                    // é‡‡æ ·å½“å‰å¸§å’Œå†å²å¸§
                    float3 current = SAMPLE_TEXTURE2D(_MainTex, sampler_linear_clamp, input.uv).rgb;
                    float3 history = SAMPLE_TEXTURE2D(_HistoryTex, sampler_linear_clamp, input.uv - motion).rgb;
            
                    // åŠ¨æ€æ··åˆæƒé‡ï¼ˆåŸºäºè¿åŠ¨å‘é‡é•¿åº¦ï¼‰
                    float blendFactor = saturate(length(motion) * 10.0f);
                    return float4(lerp(history, current, blendFactor), 1.0);
                }
                ENDHLSL
            
                SubShader
                {
                    Pass
                    {
                        Name "TAA_Pass"
                        HLSLPROGRAM
                        #pragma vertex Vert
                        #pragma fragment Frag
                        ENDHLSL
                    }
                }
            }
            
        

### **ä¼˜åŠ¿**â€Œï¼š

*   åŠ¨æ€åœºæ™¯æŠ—é”¯é½¿æ•ˆæœæœ€ä½³ï¼ˆå¦‚å¿«é€Ÿç§»åŠ¨çš„ç‰©ä½“ï¼‰
*   æ”¯æŒå¤æ‚å…‰ç…§ï¼ˆå¦‚HDRPçš„å…¨å±€å…‰ç…§ï¼‰â€Œ

### **åŠ£åŠ¿**â€Œï¼š

*   æç«¯æƒ…å†µä¸‹å‡ºç°é‡å½±ï¼ˆå¦‚å¿«é€Ÿåˆ‡æ¢åœºæ™¯ï¼‰â€Œ

### **é™åˆ¶**â€Œï¼š

*   éœ€å¯ç”¨è¿åŠ¨å‘é‡ï¼ˆMotion Vectorsï¼‰
*   ä¸å…¼å®¹åŠ¨æ€åˆ†è¾¨ç‡â€Œ

**URPä¸­çš„é€‰æ‹©ç­–ç•¥**
=============

**æ€§èƒ½ä¼˜å…ˆåœºæ™¯**
----------

é€‰æ‹©FXAAï¼šç§»åŠ¨ç«¯æˆ–VRé¡¹ç›®éœ€ä¿æŒ60FPSæ—¶ï¼Œå…¶æ€§èƒ½æ¶ˆè€—ä»…ä¸ºSMAAçš„60%ã€‚

**ç”»è´¨ä¼˜å…ˆåœºæ™¯**
----------

*   é™æ€åœºæ™¯ï¼šMSAA 4x/8xï¼ˆéœ€å…³é—­å»¶è¿Ÿæ¸²æŸ“ï¼‰
*   åŠ¨æ€åœºæ™¯ï¼šTAAï¼ˆéœ€å¯ç”¨è¿åŠ¨å‘é‡ï¼‰
*   é£æ ¼åŒ–æ¸²æŸ“ï¼šSMAAï¼ˆä¿ç•™æ¸…æ™°è¾¹ç¼˜ï¼‰

**ç‰¹æ®Šé…ç½®å»ºè®®**
----------

*   WebGLé¡¹ç›®ï¼šé¿å…MSAAï¼ˆå†…å­˜é™åˆ¶ï¼‰ï¼Œæ¨èSMAA
*   VRé¡¹ç›®ï¼šFXAA+TAAç»„åˆå‡å°‘åŠ¨æ€æ¨¡ç³Š
*   HDRPç®¡çº¿ï¼šä¼˜å…ˆTAAè§£å†³å¤æ‚å…‰ç…§é”¯é½¿

æŠ€æœ¯å†³ç­–çŸ©é˜µï¼š

æŒ‡æ ‡

FXAA

SMAA

MSAA

TAA

å‡ ä½•è¾¹ç¼˜

ä¸­

è‰¯

ä¼˜

ä¼˜

ç€è‰²é”¯é½¿

å·®

ä¸­

æ— æ•ˆ

è‰¯

åŠ¨æ€åœºæ™¯

ä¸­

ä¸­

ä¼˜

ä¼˜

GPUæ¶ˆè€—

1x

1.5x

3-8x

2x

æ˜¾å­˜å ç”¨

ä½

ä½

é«˜

ä¸­

æ³¨ï¼šæ¶ˆè€—åŸºå‡†ä»¥FXAAä¸º1xè®¡ç®—

* * *

> [ã€ä»UnityURPå¼€å§‹æ¢ç´¢æ¸¸æˆæ¸²æŸ“ã€‘](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**ä¸“æ -ç›´è¾¾**  
> ï¼ˆæ¬¢è¿_ç‚¹èµç•™è¨€_æ¢è®¨ï¼Œæ›´å¤šäººåŠ å…¥è¿›æ¥èƒ½æ›´åŠ å®Œå–„è¿™ä¸ªæ¢ç´¢çš„è¿‡ç¨‹ï¼ŒğŸ™ï¼‰