---
layout: post
title: 'MCPå®˜æ–¹Go SDKå°é²œ'
date: "2026-02-03T00:58:39Z"
---
MCPå®˜æ–¹Go SDKå°é²œ
=============

MCPå®˜æ–¹Go SDKä¸Šæ‰‹ä½“éªŒï¼Œå¼€å‘ä¸€ä¸ªç®€å•çš„MCP Serverå’ŒMCP Client

å‰è¨€
--

æ­¤å‰åœ¨ MCP å®˜ç½‘å°±æ³¨æ„åˆ°å®˜æ–¹æä¾›äº† Go SDKï¼Œè¿‘æœŸç”±äºåœ¨ Python ç¯å¢ƒä¸‹å¼€å‘ MCP Server æœ‰ç‚¹"å®¡ç¾ç–²åŠ³"ï¼Œå› æ­¤å†³å®šä½¿ç”¨ Go è¯­è¨€å°å°é²œã€‚

ä»ä¸ªäººå®é™…ä½“éªŒæ¥çœ‹ï¼ŒGo è¯­è¨€åœ¨å¹¶å‘å¤„ç†æ–¹é¢ç¡®å®å…·æœ‰æ˜¾è‘—ä¼˜åŠ¿ï¼šæ— éœ€çº ç»“äºåŒæ­¥é˜»å¡ã€å¼‚æ­¥äº‹ä»¶å¾ªç¯ã€å¤šè¿›ç¨‹å¤šçº¿ç¨‹é€šä¿¡ç­‰å¤æ‚çš„å¹¶å‘é—®é¢˜ï¼Œgoroutine ä¸€æŠŠæ¢­å“ˆã€‚åŒæ—¶ï¼ŒGo è¯­è¨€çš„éƒ¨ç½²ä¹Ÿéå¸¸ä¾¿æ·ï¼Œç¼–è¯‘åç”Ÿæˆçš„é™æ€äºŒè¿›åˆ¶æ–‡ä»¶å…·æœ‰è‰¯å¥½çš„å¯ç§»æ¤æ€§ï¼Œå¯ä»¥åœ¨ä¸åŒç¯å¢ƒä¸­ç›´æ¥è¿è¡Œã€‚

ç„¶è€Œï¼Œè¿™ç§ä¾¿åˆ©æ€§ä¹Ÿä¼´éšç€ä¸€å®šçš„ä»£ä»·ã€‚ç›¸è¾ƒäº Pythonï¼Œä½¿ç”¨ Go è¯­è¨€å®ç° MCP åŠŸèƒ½ç›¸å¯¹å¤æ‚ä¸€äº›ï¼Œå¼€å‘æ•ˆç‡ç•¥ä½ã€‚è¿™å°±æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­çš„ç»å…¸æƒè¡¡äº†ï¼šè¿è¡Œæˆæœ¬ä¸å¼€å‘æˆæœ¬å¾€å¾€éš¾ä»¥å…¼å¾—ï¼Œéœ€è¦æ ¹æ®å…·ä½“åœºæ™¯è¿›è¡Œå–èˆã€‚

MCP åè®®ç®€ä»‹
--------

_å¯èƒ½éƒ½è€³ç†Ÿèƒ½è¯¦äº†ï¼Œä½†ä»¥é˜²è¿˜æœ‰ä¸ç†Ÿæ‚‰çš„æœ‹å‹ï¼Œå…ˆç®€å•ä»‹ç»ä¸‹MCP_

Model Context Protocol (MCP) æ˜¯ä¸€ç§æ ‡å‡†åŒ–çš„åè®®ï¼Œæ—¨åœ¨ä¸º AI æ¨¡å‹æä¾›ç»Ÿä¸€çš„å·¥å…·è°ƒç”¨æ¥å£ã€‚é€šè¿‡ MCPï¼Œå¼€å‘è€…å¯ä»¥å°†å„ç§å·¥å…·ã€æœåŠ¡å’Œæ•°æ®æºæš´éœ²ç»™ AI æ¨¡å‹ï¼Œä½¿å…¶èƒ½å¤Ÿæ‰§è¡Œè¶…å‡ºåŸºç¡€è¯­è¨€æ¨¡å‹èƒ½åŠ›èŒƒå›´çš„æ“ä½œã€‚MCP æ”¯æŒå¤šç§ä¼ è¾“åè®®ï¼ŒåŒ…æ‹¬ HTTP å’Œ Stdioï¼Œä¸ºä¸åŒåœºæ™¯ä¸‹çš„é›†æˆæä¾›äº†çµæ´»æ€§ã€‚

ä¸€ä¸ªç®€å•çš„ MCP Server ç¤ºä¾‹
-------------------

MCP å®˜æ–¹ Go SDK åœ¨å®šä¹‰å·¥å…·ï¼ˆToolï¼‰æ—¶ï¼Œè¦æ±‚æ˜ç¡®æŒ‡å®šè¾“å…¥å‚æ•°å’Œè¾“å‡ºç»“æœçš„æ•°æ®ç»“æ„ã€‚å¯¹äºåŠŸèƒ½è¾ƒä¸ºç®€å•çš„å·¥å…·ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ `any` ç±»å‹ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªå®Œæ•´çš„ MCP Server ç¤ºä¾‹ï¼Œæä¾›äº†ä¸‰ä¸ªå®ç”¨å·¥å…·ï¼š

1.  **`getCurrentDatetime`**ï¼šè·å–å½“å‰æ—¶é—´ï¼Œè¿”å› RFC3339 æ ¼å¼ï¼ˆ`2006-01-02T15:04:05Z07:00`ï¼‰çš„æ—¶é—´æˆ³å­—ç¬¦ä¸²ã€‚ç”±äºä¸éœ€è¦è¾“å…¥å‚æ•°ï¼Œå› æ­¤å‚æ•°ç±»å‹å®šä¹‰ä¸º `any`ï¼Œè¾“å‡ºåŒæ ·ä½¿ç”¨ `any` ç±»å‹ã€‚
    
2.  **`getComputerStatus`**ï¼šè·å–å½“å‰ç³»ç»Ÿçš„å…³é”®ä¿¡æ¯ï¼ŒåŒ…æ‹¬ CPU ä½¿ç”¨ç‡ã€å†…å­˜ä½¿ç”¨æƒ…å†µã€ç³»ç»Ÿç‰ˆæœ¬ç­‰ã€‚è¯¥å·¥å…·æ¥å—ä¸€ä¸ª `CPUSampleTime` å‚æ•°ï¼Œå¯¹åº”çš„è¾“å…¥ç»“æ„ä½“ä¸º `GetComputerStatusIn`ï¼Œè¾“å‡ºç»“æ„ä½“ä¸º `GetComputerStatusOut`ï¼ˆGo SDK çš„ç¤ºä¾‹ä¸­é€šå¸¸é‡‡ç”¨ `xxxIn` å’Œ `xxxOut` çš„å‘½åçº¦å®šæ¥åŒºåˆ†å·¥å…·çš„è¾“å…¥è¾“å‡ºç»“æ„ä½“ï¼‰ã€‚
    
3.  **`getDiskInfo`**ï¼šè·å–æ‰€æœ‰ç¡¬ç›˜åˆ†åŒºçš„ä½¿ç”¨ä¿¡æ¯å’Œæ–‡ä»¶ç³»ç»Ÿè¯¦æƒ…ã€‚è¯¥å·¥å…·æ— éœ€è¾“å…¥å‚æ•°ï¼Œä»…å®šä¹‰äº†è¾“å‡ºç»“æ„ä½“ `GetDiskInfoOut`ã€‚
    

åœ¨å®Œæˆæ‰€æœ‰å·¥å…·é€»è¾‘çš„å®ç°åï¼Œæœ€åä¸€æ­¥æ˜¯å¯åŠ¨æœåŠ¡ã€‚ä»¥ä¸‹ç¤ºä¾‹é‡‡ç”¨ Streamable HTTP æ¨¡å¼å¯åŠ¨ï¼ŒåŒæ—¶ä¹Ÿä¿ç•™äº† Stdio Transport æ¨¡å¼çš„æ³¨é‡Šä»£ç ä¾›å‚è€ƒã€‚

    package main
    
    import (
    	"context"
    	"fmt"
    	"log"
    	"net"
    	"net/http"
    	"time"
    
    	"github.com/modelcontextprotocol/go-sdk/mcp"
    	"github.com/shirou/gopsutil/v4/cpu"
    	"github.com/shirou/gopsutil/v4/disk"
    	"github.com/shirou/gopsutil/v4/host"
    	"github.com/shirou/gopsutil/v4/mem"
    )
    
    func getCurrentDatetime(ctx context.Context, req *mcp.CallToolRequest, arg any) (*mcp.CallToolResult, any, error) {
    	now := time.Now().Format(time.RFC3339)
    	return nil, now, nil
    }
    
    type GetComputerStatusIn struct {
    	CPUSampleTime time.Duration `json:"cpu_sample_time" jsonschema:"the sample time of cpu usage. Default is 1s"`
    }
    
    type GetComputerStatusOut struct {
    	Hostinfo    string `json:"host info" jsonschema:"the hostinfo of the computer"`
    	TimeZone    string `json:"time_zone" jsonschema:"the time zone of the computer"`
    	IPAddress   string `json:"ip_address" jsonschema:"the ip address of the computer"`
    	CPUUsage    string `json:"cpu_usage" jsonschema:"the cpu usage of the computer"`
    	MemoryUsage string `json:"memory_usage" jsonschema:"the memory usage of the computer"`
    }
    
    func getComputerStatus(ctx context.Context, req *mcp.CallToolRequest, args GetComputerStatusIn) (*mcp.CallToolResult, GetComputerStatusOut, error) {
    	if args.CPUSampleTime == 0 {
    		args.CPUSampleTime = time.Second
    	}
    	hInfo, err := host.Info()
    	if err != nil {
    		return nil, GetComputerStatusOut{}, err
    	}
    
    	var resp GetComputerStatusOut
    	resp.Hostinfo = fmt.Sprintf("%+v", *hInfo)
    
    	name, offset := time.Now().Zone()
    	resp.TimeZone = fmt.Sprintf("Timezone: %s (UTC%+d)\n", name, offset/3600)
    
    	// CPU Usage
    	percent, err := cpu.Percent(time.Second, false)
    	if err != nil {
    		return nil, GetComputerStatusOut{}, err
    	}
    	resp.CPUUsage = fmt.Sprintf("CPU Usage: %.2f%%\n", percent[0])
    
    	// Memory Usage
    	v, err := mem.VirtualMemory()
    	if err != nil {
    		return nil, GetComputerStatusOut{}, err
    	}
    	resp.MemoryUsage = fmt.Sprintf("Mem Usage: %.2f%% (Used: %vMB / Total: %vMB)\n",
    		v.UsedPercent, v.Used/1024/1024, v.Total/1024/1024)
    
    	// Ip Address
    	conn, err := net.Dial("udp", "8.8.8.8:80")
    	if err != nil {
    		return nil, GetComputerStatusOut{}, err
    	}
    	defer conn.Close()
    	localAddr := conn.LocalAddr().(*net.UDPAddr)
    	resp.IPAddress = localAddr.IP.String()
    
    	return nil, resp, nil
    }
    
    type DiskInfo struct {
    	Device     string   `json:"device" jsonschema:"the device name"`
    	Mountpoint string   `json:"mountpoint" jsonschema:"the mountpoint"`
    	Fstype     string   `json:"fstype" jsonschema:"the filesystem type"`
    	Opts       []string `json:"opts" jsonschema:"the mount options"`
    	DiskTotal  uint64   `json:"disk_total" jsonschema:"the total disk space in GiB"`
    	DiskUsage  float64  `json:"disk_usage" jsonschema:"the disk usage percentage"`
    }
    
    type GetDiskInfoOut struct {
    	PartInfos []DiskInfo `json:"part_infos" jsonschema:"the disk partitions"`
    }
    
    func getDiskInfo(ctx context.Context, req *mcp.CallToolRequest, args any) (*mcp.CallToolResult, GetDiskInfoOut, error) {
    	partInfos, err := disk.Partitions(false)
    	if err != nil {
    		return nil, GetDiskInfoOut{}, err
    	}
    
    	var resp []DiskInfo
    	for _, part := range partInfos {
    		diskUsage, err := disk.Usage(part.Mountpoint)
    		if err != nil {
    			continue
    		}
    		resp = append(resp, DiskInfo{
    			Device:     part.Device,
    			Mountpoint: part.Mountpoint,
    			Fstype:     part.Fstype,
    			Opts:       part.Opts,
    			DiskTotal:  diskUsage.Total / 1024 / 1024 / 1024,
    			DiskUsage:  diskUsage.UsedPercent,
    		})
    	}
    	return nil, GetDiskInfoOut{PartInfos: resp}, nil
    }
    
    func main() {
    	// ctx := context.Background()
    
    	server := mcp.NewServer(&mcp.Implementation{Name: "MCP_Demo", Version: "0.0.1"}, &mcp.ServerOptions{
    		Instructions: "æ—¥æœŸæ—¶é—´ç›¸å…³çš„ Server",
    	})
    	mcp.AddTool(server, &mcp.Tool{
    		Name:        "get_current_datetime",
    		Description: "Get current datetime in RFC3339 format",
    	}, getCurrentDatetime)
    
    	mcp.AddTool(server, &mcp.Tool{
    		Name:        "get_computer_status",
    		Description: "Get computer status",
    	}, getComputerStatus)
    
    	mcp.AddTool(server, &mcp.Tool{
    		Name:        "get_disk_info",
    		Description: "Get disk information",
    	}, getDiskInfo)
    
    	// if err := server.Run(ctx, &mcp.StdioTransport{}); err != nil {
    	// 	log.Fatalln(err)
    	// }
    	//
    	handler := mcp.NewStreamableHTTPHandler(func(req *http.Request) *mcp.Server {
    		path := req.URL.Path
    		switch path {
    		case "/api/mcp":
    			return server
    		default:
    			return nil
    		}
    	}, nil)
    	url := "127.0.0.1:18001"
    	if err := http.ListenAndServe(url, handler); err != nil {
    		log.Fatalln(err)
    	}
    }
    

MCP Server ä»£ç ç¼–è¯‘é€šè¿‡åï¼Œå¯ä»¥åœ¨æ”¯æŒ MCP åè®®çš„å¼€å‘å·¥å…·ï¼ˆå¦‚ VS Codeï¼‰ä¸­è¿›è¡Œæµ‹è¯•éªŒè¯ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªå…¸å‹çš„ `.vscode/mcp.json` é…ç½®ç¤ºä¾‹ï¼š

    {
        "servers": {
            "demo-http": {
                // "command": "/home/rainux/Documents/workspace/go-dev/mcp-dev/mcp-server-dev/mcp-server-dev"
                "type": "http",
                "url": "http://127.0.0.1:18001/api/mcp"
            }
        }
    }
    

å¯åŠ¨ MCP Server åï¼Œå¯ä»¥é€šè¿‡å‘ LLM æå‡ºç›¸å…³é—®é¢˜æ¥éªŒè¯å·¥å…·æ˜¯å¦èƒ½å¤Ÿè¢«æ­£ç¡®è°ƒåº¦å’Œæ‰§è¡Œã€‚

ä¸€ä¸ªå®Œæ•´çš„ MCP Client å®ç°
-------------------

ä¸ºäº†æ„å»ºç«¯åˆ°ç«¯çš„ MCP åº”ç”¨ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å®ç°ä¸€ä¸ª MCP Clientï¼Œä½¿å…¶èƒ½å¤Ÿä¸ LLM ååŒå·¥ä½œï¼Œè‡ªåŠ¨é€‰æ‹©å¹¶è°ƒç”¨åˆé€‚çš„å·¥å…·ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„ MCP Client å®ç°ï¼Œå…¶ä¸­åŒ…å«äº†ä¸ OpenAI å…¼å®¹ API çš„é›†æˆç¤ºä¾‹ï¼ˆ`callOpenAI` å‡½æ•°ï¼‰ã€‚

    package main
    
    import (
    	"context"
    	"encoding/json"
    	"flag"
    	"fmt"
    	"log"
    	"net/http"
    	"os/exec"
    	"time"
    
    	"github.com/modelcontextprotocol/go-sdk/mcp"
    	"github.com/openai/openai-go/v3"
    	"github.com/openai/openai-go/v3/option"
    	"github.com/openai/openai-go/v3/packages/param"
    )
    
    var (
    	FLAG_ModelName     string
    	FLAG_BaseURL       string
    	FLAG_APIKEY        string
    	FLAG_MCP_TRANSPORT string
    	FLAG_MCP_URI       string
    	FLAG_QUESTION      string
    	FLAG_STREAM        bool
    )
    
    func main() {
    	// Parse command-line flags
    	flag.StringVar(&FLAG_BaseURL, "base-url", "https://dashscope.aliyuncs.com/compatible-mode/v1", "llm base url")
    	flag.StringVar(&FLAG_ModelName, "model", "qwen-plus", "LLM Model Name")
    	flag.StringVar(&FLAG_MCP_TRANSPORT, "mcp-transport", "http", "MCP transport protocol (stdio or http)")
    	flag.StringVar(&FLAG_MCP_URI, "mcp-uri", "", "MCP server address")
    	flag.StringVar(&FLAG_APIKEY, "api-key", "", "llm api key")
    	flag.StringVar(&FLAG_QUESTION, "q", "Hi", "question")
    	flag.BoolVar(&FLAG_STREAM, "s", false, "stream response")
    
    	flag.Parse()
    
    	// Get configuration from environment variables with flag overrides
    	if FLAG_APIKEY == "" {
    		log.Fatalln("api key is empty")
    	}
    
    	if FLAG_QUESTION == "" {
    		log.Fatalln("question is empty")
    	}
    
    	// Configure OpenAI client
    	// config :=
    	ctx := context.Background()
    
    	// question := "Write me a haiku about computers"
    	if FLAG_MCP_URI != "" {
    		callOpenAIWithTools(ctx, FLAG_QUESTION)
    	} else {
    		callOpenAI(ctx, FLAG_QUESTION, FLAG_STREAM)
    	}
    }
    
    // callOpenAI è°ƒç”¨ OpenAI API æ¥å£å¤„ç†ç”¨æˆ·é—®é¢˜
    // è¯¥å‡½æ•°æ”¯æŒæµå¼ï¼ˆstreamï¼‰å’Œéæµå¼ï¼ˆnon-streamï¼‰ä¸¤ç§å“åº”æ–¹å¼
    //
    // å‚æ•°:
    //   - ctx: æ§åˆ¶æ“ä½œç”Ÿå‘½å‘¨æœŸçš„ä¸Šä¸‹æ–‡
    //   - question: ç”¨æˆ·æå‡ºçš„é—®é¢˜å­—ç¬¦ä¸²
    //   - stream: å¸ƒå°”å€¼ï¼ŒæŒ‡å®šæ˜¯å¦ä½¿ç”¨æµå¼å“åº”
    func callOpenAI(ctx context.Context, question string, stream bool) {
    	client := openai.NewClient(option.WithAPIKey(FLAG_APIKEY), option.WithBaseURL(FLAG_BaseURL))
    	systemPrompt := "è¯·ç”¨äº²åˆ‡çƒ­æƒ…çš„é£æ ¼å›ç­”ç”¨æˆ·çš„é—®é¢˜"
    
    	if stream {
    		// åˆ›å»ºæµå¼å“åº”è¯·æ±‚
    		streamResp := client.Chat.Completions.NewStreaming(ctx, openai.ChatCompletionNewParams{
    			Messages: []openai.ChatCompletionMessageParamUnion{
    				openai.SystemMessage(systemPrompt),
    				openai.UserMessage(question),
    			},
    			Model: FLAG_ModelName,
    		})
    		// defer streamResp.Close()
    		defer func() {
    			err := streamResp.Close()
    			if err != nil {
    				log.Fatalln(err)
    			}
    		}()
    		// éå†æµå¼å“åº”å¹¶é€å—è¾“å‡ºå†…å®¹
    		for streamResp.Next() {
    			data := streamResp.Current()
    			fmt.Print(data.Choices[0].Delta.Content)
    
    			if err := streamResp.Err(); err != nil {
    				log.Fatalln(err)
    			}
    		}
    
    	} else {
    		// åˆ›å»ºéæµå¼å“åº”è¯·æ±‚
    		chatCompletion, err := client.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{
    			Messages: []openai.ChatCompletionMessageParamUnion{
    				openai.SystemMessage(systemPrompt),
    				openai.UserMessage(question),
    			},
    			Model: FLAG_ModelName,
    		})
    		if err != nil {
    			log.Fatalln(err)
    		}
    		// è¾“å‡ºéæµå¼å“åº”å†…å®¹
    		fmt.Println(chatCompletion.Choices[0].Message.Content)
    	}
    }
    
    // callOpenAIWithTools ä½¿ç”¨ OpenAI API å’Œ MCP å·¥å…·è°ƒç”¨æ¥å¤„ç†ç”¨æˆ·é—®é¢˜
    // è¯¥å‡½æ•°åˆ›å»ºä¸€ä¸ª OpenAI å®¢æˆ·ç«¯å’Œ MCP å®¢æˆ·ç«¯ï¼Œå°† MCP å·¥å…·è½¬æ¢ä¸º OpenAI å¯ä½¿ç”¨çš„æ ¼å¼ï¼Œ
    // å¹¶æ‰§è¡Œå®Œæ•´çš„å·¥å…·è°ƒç”¨æµç¨‹ï¼ŒåŒ…æ‹¬åˆå§‹è°ƒç”¨å’Œå¯èƒ½çš„åç»­è°ƒç”¨
    //
    // å‚æ•°:
    //   - ctx: æ§åˆ¶æ“ä½œç”Ÿå‘½å‘¨æœŸçš„ä¸Šä¸‹æ–‡
    //   - question: ç”¨æˆ·æå‡ºçš„é—®é¢˜å­—ç¬¦ä¸²
    func callOpenAIWithTools(ctx context.Context, question string) {
    	// åˆ›å»º OpenAI å®¢æˆ·ç«¯ï¼Œä½¿ç”¨ API å¯†é’¥å’ŒåŸºç¡€ URL é…ç½®
    	llmClient := openai.NewClient(option.WithAPIKey(FLAG_APIKEY), option.WithBaseURL(FLAG_BaseURL))
    	// åˆ›å»º MCP å®¢æˆ·ç«¯ï¼ŒæŒ‡å®šåç§°å’Œç‰ˆæœ¬
    	mcpClient := mcp.NewClient(&mcp.Implementation{Name: "mcp-client", Version: "0.0.1"}, nil)
    	var transport mcp.Transport
    	// æ ¹æ®å‘½ä»¤è¡Œæ ‡å¿—é€‰æ‹©ä¼ è¾“åè®®ï¼ˆstdio æˆ– httpï¼‰
    	switch FLAG_MCP_TRANSPORT {
    	case "stdio":
    		transport = &mcp.CommandTransport{Command: exec.Command(FLAG_MCP_URI)}
    	case "http":
    		transport = &mcp.StreamableClientTransport{HTTPClient: &http.Client{Timeout: time.Second * 10}, Endpoint: FLAG_MCP_URI}
    	default:
    		log.Fatalf("unknown transport, %s", FLAG_MCP_TRANSPORT)
    	}
    	// å»ºç«‹ä¸ MCP æœåŠ¡å™¨çš„è¿æ¥
    	session, err := mcpClient.Connect(ctx, transport, nil)
    	if err != nil {
    		log.Fatalf("MCP client connects to mcp server failed, err: %v", err)
    	}
    	defer func() {
    		err := session.Close()
    		if err != nil {
    			log.Fatalln(err)
    		}
    	}()
    
    	// è·å–å¯ç”¨çš„ MCP å·¥å…·åˆ—è¡¨
    	mcpTools, err := session.ListTools(ctx, &mcp.ListToolsParams{})
    	if err != nil {
    		log.Fatalf("List mcp tools failed, err: %v", err)
    	}
    
    	var legacyTools []openai.ChatCompletionToolUnionParam
    	// éå†æ‰€æœ‰ MCP å·¥å…·å¹¶å°†å…¶è½¬æ¢ä¸º OpenAI å…¼å®¹çš„å·¥å…·æ ¼å¼
    	for _, tool := range mcpTools.Tools {
    		// å°† MCP å·¥å…·è¾“å…¥æ¨¡å¼è½¬æ¢ä¸º OpenAI å‡½æ•°å‚æ•°
    		if inputSchema, ok := tool.InputSchema.(map[string]any); ok {
    			legacyTools = append(legacyTools, openai.ChatCompletionFunctionTool(
    				openai.FunctionDefinitionParam{
    					Name:        tool.Name,
    					Description: openai.String(tool.Description),
    					Parameters:  openai.FunctionParameters(inputSchema),
    				},
    			))
    		} else {
    			// å¦‚æœ InputSchema ä¸æ˜¯ map[string]anyï¼Œä½¿ç”¨ç©ºå‚æ•°
    			legacyTools = append(legacyTools, openai.ChatCompletionFunctionTool(
    				openai.FunctionDefinitionParam{
    					Name:        tool.Name,
    					Description: openai.String(tool.Description),
    					Parameters:  openai.FunctionParameters{},
    				},
    			))
    		}
    	}
    
    	// è®¾ç½®åˆå§‹èŠå¤©æ¶ˆæ¯ï¼ŒåŒ…æ‹¬ç³»ç»Ÿæç¤ºå’Œç”¨æˆ·é—®é¢˜
    	messages := []openai.ChatCompletionMessageParamUnion{
    		openai.SystemMessage("è¯·ç”¨äº²åˆ‡çƒ­æƒ…çš„é£æ ¼å›ç­”ç”¨æˆ·çš„é—®é¢˜ã€‚ä½ å¯ä»¥ä½¿ç”¨å¯ç”¨çš„å·¥å…·æ¥è·å–ä¿¡æ¯ã€‚"),
    		openai.UserMessage(question),
    	}
    
    	// è°ƒç”¨ LLM è·å–åˆæ­¥å“åº”
    	chatCompletion, err := llmClient.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{
    		Messages: messages,
    		Model:    FLAG_ModelName,
    		Tools:    legacyTools,
    		ToolChoice: openai.ChatCompletionToolChoiceOptionUnionParam{
    			OfAuto: param.Opt[string]{
    				Value: "auto",
    			},
    		},
    	})
    	if err != nil {
    		log.Fatalf("LLM call failed, err: %v", err)
    	}
    
    	choice := chatCompletion.Choices[0]
    	fmt.Printf("LLM response: %s\n", choice.Message.Content)
    
    	// æ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒç”¨å·¥å…·
    	if choice.FinishReason == "tool_calls" && len(choice.Message.ToolCalls) > 0 {
    		// éå†æ‰€æœ‰éœ€è¦è°ƒç”¨çš„å·¥å…·
    		for _, toolCall := range choice.Message.ToolCalls {
    			if toolCall.Type != "function" {
    				continue
    			}
    
    			fmt.Printf("Executing tool: %s with args: %s\n", toolCall.Function.Name, toolCall.Function.Arguments)
    
    			// è§£æ JSON å‚æ•°
    			var argsObj map[string]any
    			args := toolCall.Function.Arguments
    
    			if args != "" {
    				if err := json.Unmarshal([]byte(args), &argsObj); err != nil {
    					log.Printf("Failed to parse tool arguments: %v", err)
    					argsObj = make(map[string]any)
    				}
    			} else {
    				argsObj = make(map[string]any)
    			}
    
    			fmt.Printf("Executing tool: %s with parsed args: %v\n", toolCall.Function.Name, argsObj)
    
    			// æ‰§è¡Œ MCP å·¥å…·è°ƒç”¨
    			result, err := session.CallTool(ctx, &mcp.CallToolParams{
    				Name:      toolCall.Function.Name,
    				Arguments: argsObj,
    			})
    			if err != nil {
    				log.Printf("Tool call failed: %v", err)
    				continue
    			}
    
    			// å°† MCP å†…å®¹è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    			var toolResult string
    			if len(result.Content) > 0 {
    				if textContent, ok := result.Content[0].(*mcp.TextContent); ok {
    					toolResult = textContent.Text
    				} else {
    					// å¦‚æœä¸æ˜¯ TextContentï¼Œè½¬æ¢ä¸º JSON
    					if jsonBytes, err := json.Marshal(result.Content[0]); err == nil {
    						toolResult = string(jsonBytes)
    					} else {
    						toolResult = "Tool executed successfully"
    					}
    				}
    			}
    
    			fmt.Printf("Tool result: %s\n", toolResult)
    
    			// æ·»åŠ å·¥å…·è°ƒç”¨æ¶ˆæ¯å’Œå·¥å…·å“åº”æ¶ˆæ¯
    			messages = append(messages, openai.ChatCompletionMessageParamUnion{
    				OfAssistant: &openai.ChatCompletionAssistantMessageParam{
    					Role: "assistant",
    					ToolCalls: []openai.ChatCompletionMessageToolCallUnionParam{
    						{
    							OfFunction: &openai.ChatCompletionMessageFunctionToolCallParam{
    								ID: toolCall.ID,
    								Function: openai.ChatCompletionMessageFunctionToolCallFunctionParam{
    									Name:      toolCall.Function.Name,
    									Arguments: toolCall.Function.Arguments,
    								},
    							},
    						},
    					},
    				},
    			})
    
    			messages = append(messages, openai.ToolMessage(
    				toolResult,
    				toolCall.ID,
    			))
    
    			// è¿›è¡Œåç»­è°ƒç”¨ä»¥è·å¾—æœ€ç»ˆå“åº”
    			chatCompletion, err = llmClient.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{
    				Messages: messages,
    				Model:    FLAG_ModelName,
    			})
    			if err != nil {
    				log.Fatalf("LLM follow-up failed, err: %v", err)
    			}
    
    			fmt.Printf("Final response: %s\n", chatCompletion.Choices[0].Message.Content)
    		}
    	}
    }
    

### è¿è¡Œæµ‹è¯•éªŒè¯

ç¼–è¯‘å®Œæˆåï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œå¤šè½®æµ‹è¯•æ¥éªŒè¯åŠŸèƒ½çš„æ­£ç¡®æ€§ã€‚

**æ™®é€šé—®ç­”æµ‹è¯•**ï¼š

    ./mcp-client-dev -api-key "sk-xxx" -q "how are you"
    

è¿˜å¯ä»¥åŠ ä¸Š `-s` å‚æ•°å¯ç”¨æµå¼è¾“å‡ºï¼š

    ./mcp-client-dev -api-key "sk-xxx" -q "how are you" -s
    

é¢„æœŸè¾“å‡ºï¼š

    Hi there! ğŸ˜Š I'm absolutely wonderfulâ€”energized, curious, and *so* happy to be chatting with you! ğŸŒŸ How about you? I'd love to hear how your day's goingâ€”or what's on your heart or mind right now! ğŸ’« (Bonus points if you share a fun fact, a tiny win, or even just your favorite emoji today! ğŸ¦âœ¨)
    

**MCP å·¥å…·è°ƒç”¨æµ‹è¯•**ï¼š

    ./mcp-client-dev -api-key "sk-xxx" -mcp-uri "http://127.0.0.1:18001/api/mcp" -q "å½“å‰æ—¶é—´æ˜¯ä»€ä¹ˆ"
    

é¢„æœŸè¾“å‡ºï¼š

    LLM response: 
    Executing tool: get_current_datetime with args: {}
    Executing tool: get_current_datetime with parsed args: map[]
    Tool result: "2026-02-02T23:12:54+08:00"
    Final response: ç°åœ¨æ˜¯ **2026 å¹´ 2 æœˆ 2 æ—¥ æ™šä¸Š 11:12**ï¼ˆåŒ—äº¬æ—¶é—´ï¼ŒUTC+8ï¼‰âœ¨
    æ–°å¹´çš„æ°”æ¯è¿˜æš–æš–çš„ï½ä½ æ˜¯åœ¨è§„åˆ’ä»€ä¹ˆç‰¹åˆ«çš„äº‹æƒ…å—ï¼ŸğŸ˜Š æˆ‘å¾ˆä¹æ„å¸®ä½ å®‰æ’ã€æé†’æˆ–ä¸€èµ·ç•…æƒ³å“¦ï¼
    

æœ€ä½³å®è·µä¸æ³¨æ„äº‹é¡¹
---------

åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨ Go è¯­è¨€å®ç° MCP Server æ—¶ï¼Œå»ºè®®è€ƒè™‘ä»¥ä¸‹æœ€ä½³å®è·µï¼š

1.  **é”™è¯¯å¤„ç†**ï¼šç¡®ä¿æ‰€æœ‰å·¥å…·å‡½æ•°éƒ½æœ‰å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œé¿å…å› å•ä¸ªå·¥å…·å¤±è´¥å¯¼è‡´æ•´ä¸ªæœåŠ¡å´©æºƒã€‚
2.  **æ€§èƒ½ä¼˜åŒ–**ï¼šå¯¹äºè€—æ—¶è¾ƒé•¿çš„æ“ä½œï¼ˆå¦‚ç³»ç»Ÿä¿¡æ¯é‡‡é›†ï¼‰ï¼Œè€ƒè™‘æ·»åŠ è¶…æ—¶æ§åˆ¶å’Œç¼“å­˜æœºåˆ¶ã€‚(åœ¨MCPå®˜æ–¹æ–‡æ¡£çœ‹åˆ°æœ‰ Tasks å’Œ progress è¿™ä¸¤ä¸ªæ–°çš„åŸè¯­, è€—æ—¶ä»»åŠ¡ä¹Ÿå¯ä»¥è¯•è¯•è¿™ä¸¤ä¸ª)
3.  **å®‰å…¨æ€§**ï¼šéªŒè¯æ‰€æœ‰è¾“å…¥å‚æ•°ï¼Œé˜²æ­¢æ¶æ„è¾“å…¥å¯¼è‡´çš„å®‰å…¨é—®é¢˜ã€‚å¯¹äºæ¶‰åŠç³»ç»Ÿæ“ä½œçš„å·¥å…·ï¼Œéœ€è¦ç‰¹åˆ«æ³¨æ„æƒé™æ§åˆ¶ã€‚
4.  **æ—¥å¿—è®°å½•**ï¼šæ·»åŠ è¯¦ç»†çš„æ—¥å¿—è®°å½•ï¼Œä¾¿äºè°ƒè¯•å’Œç›‘æ§å·¥å…·çš„ä½¿ç”¨æƒ…å†µã€‚
5.  **é…ç½®ç®¡ç†**ï¼šå°†æœåŠ¡é…ç½®ï¼ˆå¦‚ç›‘å¬åœ°å€ã€ç«¯å£ç­‰ï¼‰æå–åˆ°é…ç½®æ–‡ä»¶ä¸­ï¼Œæé«˜å¯ç»´æŠ¤æ€§ã€‚

æ€»ç»“
--

æœ¬æ–‡é€šè¿‡ä¸€ä¸ªç®€å•çš„ä»£ç ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ Go è¯­è¨€å¼€å‘ MCP Server å’Œ Clientã€‚è™½ç„¶ Go è¯­è¨€åœ¨ MCP å¼€å‘æ–¹é¢ç›¸æ¯” Python ç•¥æ˜¾å¤æ‚ï¼Œä½†å…¶åœ¨å¹¶å‘å¤„ç†ã€æ€§èƒ½å’Œéƒ¨ç½²ä¾¿åˆ©æ€§æ–¹é¢çš„ä¼˜åŠ¿ä½¿å…¶æˆä¸ºç”Ÿäº§ç¯å¢ƒçš„ç†æƒ³é€‰æ‹©ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæœ¬æ–‡ç¤ºä¾‹ä»…æ¶µç›–äº† MCP å·¥å…·è°ƒç”¨çš„åŸºæœ¬åŠŸèƒ½ã€‚åœ¨å®é™…ä¸šåŠ¡é¡¹ç›®ä¸­ä½¿ç”¨ Go è¯­è¨€å®ç° MCP Server æ—¶ï¼Œè¿˜éœ€è¦æ·±å…¥ç ”ç©¶ MCP åè®®çš„å…¶ä»–ç‰¹æ€§ï¼Œå¦‚ Prompt ç®¡ç†ã€èº«ä»½è®¤è¯ï¼ˆAuthï¼‰ã€ä¼šè¯ç®¡ç†ç­‰é«˜çº§åŠŸèƒ½çš„å®ç°æ–¹æ¡ˆã€‚

é€šè¿‡åˆç†çš„è®¾è®¡å’Œå®ç°ï¼ŒåŸºäº Go è¯­è¨€çš„ MCP æœåŠ¡å¯ä»¥ä¸º AI åº”ç”¨æä¾›ç¨³å®šã€é«˜æ•ˆã€å®‰å…¨çš„å·¥å…·è°ƒç”¨èƒ½åŠ›ï¼Œå……åˆ†å‘æŒ¥ Go è¯­è¨€åœ¨ç³»ç»Ÿç¼–ç¨‹å’Œç½‘ç»œæœåŠ¡æ–¹é¢çš„ä¼˜åŠ¿ã€‚

å‚è€ƒ
--

*   MCP å®˜æ–¹é¡µé¢: [https://modelcontextprotocol.io/docs/getting-started/intro](https://modelcontextprotocol.io/docs/getting-started/intro)
*   MCP å®˜æ–¹ Go SDK: [https://github.com/modelcontextprotocol/go-sdk](https://github.com/modelcontextprotocol/go-sdk)

æœ¬æ–‡æ¥è‡ªåšå®¢å›­ï¼Œä½œè€…ï¼š[èŠ±é…’é”„ä½œç”°](https://www.cnblogs.com/XY-Heruo/)ï¼Œè½¬è½½è¯·æ³¨æ˜åŸæ–‡é“¾æ¥ï¼š[https://www.cnblogs.com/XY-Heruo/p/19566770](https://www.cnblogs.com/XY-Heruo/p/19566770)