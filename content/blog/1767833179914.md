---
layout: post
title: 'Java中String类（StringBuffer、StringBuilder）相关'
date: "2026-01-08T00:46:19Z"
---
Java中String类（StringBuffer、StringBuilder）相关
==========================================

### String是Java中用于表示字符串的类，位于java.lang包下（无需手动导入）。

##### 两个核心特性：

1.  不可变性（Immutable）：String 对象一旦创建，其内部的字符序列就无法被修改。看似修改字符串的操作（如拼接、替换），本质都是创建了一个新的String对象。
2.  字符串常量池：直接赋值创建的String对象会存入JVM的字符串常量池，目的是复用相同内容的字符串，节省内存。

##### String对象的两种创建方式

    public class StringCreateDemo {
        public static void main(String[] args) {
            // 方式1：直接赋值（推荐）—— 从常量池获取/创建对象
            String s1 = "Hello";
            String s2 = "Hello";
            // == 比较的是对象的内存地址，s1和s2指向常量池同一个对象
            System.out.println(s1 == s2); // 输出：true
    
            // 方式2：new关键字 —— 每次new都会在堆内存创建新对象
            String s3 = new String("Hello");
            String s4 = new String("Hello");
            System.out.println(s3 == s4); // 输出：false
    
            // 正确比较字符串内容：用equals()方法（String重写了Object的equals）
            System.out.println(s1.equals(s3)); // 输出：true
        }
    }
    

##### String类的常用方法

    public class StringMethodsDemo {
        public static void main(String[] args) {
            String str = "  Hello Java!  ";
    
            // 1. 获取字符串长度：length()
            int len = str.length();
            System.out.println("长度：" + len); // 输出：14（包含首尾空格）
    
            // 2. 获取指定索引的字符：charAt(int index)（索引从0开始）
            char c = str.charAt(3);
            System.out.println("索引3的字符：" + c); // 输出：l
    
            // 3. 去除首尾空格：trim()（JDK11+可用strip()）
            String trimStr = str.trim();
            System.out.println("去空格后：" + trimStr); // 输出：Hello Java!
    
            // 4. 大小写转换
            String upperStr = trimStr.toUpperCase(); // 转大写
            String lowerStr = trimStr.toLowerCase(); // 转小写
            System.out.println("大写：" + upperStr); // 输出：HELLO JAVA!
            System.out.println("小写：" + lowerStr); // 输出：hello java!
    
            // 5. 判断是否包含指定子串：contains(CharSequence s)
            boolean hasJava = trimStr.contains("Java");
            System.out.println("包含Java？" + hasJava); // 输出：true
    
            // 6. 截取子串：substring(int beginIndex[, int endIndex])
            // 注意：endIndex是结束索引（不包含），左闭右开
            String sub1 = trimStr.substring(6); // 从索引6截取到末尾
            String sub2 = trimStr.substring(0, 5); // 截取0-4索引的字符
            System.out.println("sub1：" + sub1); // 输出：Java!
            System.out.println("sub2：" + sub2); // 输出：Hello
    
            // 7. 分割字符串：split(String regex)
            String[] splitArr = trimStr.split(" "); // 按空格分割
            System.out.println("分割后数组：" + Arrays.toString(splitArr)); // 输出：[Hello, Java!]
    
            // 8. 替换字符/子串：replace(CharSequence old, CharSequence new)
            String replaceStr = trimStr.replace("Java", "World");
            System.out.println("替换后：" + replaceStr); // 输出：Hello World!
    
            // 9. 判断字符串是否为空/空白：isEmpty()、isBlank()（JDK11+）
            String emptyStr = "";
            String blankStr = "   ";
            System.out.println(emptyStr.isEmpty()); // 输出：true
            System.out.println(blankStr.isBlank()); // 输出：true（JDK11+）
        }
    }
    

##### String不可变性的影响

*   因为String不可变，频繁拼接字符串（如循环中str += "xxx"）会创建大量临时对象，效率极低。此时应使用StringBuilder（非线程安全，效率高）或StringBuffer（线程安全，效率稍低）

* * *

### StringBuffer和StringBuilder

*   它们是可变的字符序列，底层基于可扩容的字符数组实现，修改（拼接、插入、删除）时不会创建新对象，而是直接操作底层数组，效率大幅提升。

##### StringBuffer和StringBuilder的核心区别

特性

StringBuffer

StringBuilder

线程安全

线程安全（方法加了synchronized锁）

非线程安全（无同步锁）

执行效率

稍低（锁的开销）

更高（无锁的开销）

适用场景

多线程环境（如多线程拼接字符串）

单线程环境（日常开发绝大多数场景）

诞生版本

JDK 1.0

JDK 1.5（为弥补 StringBuffer 效率问题）

##### 常用方法

    import java.util.Arrays;
    
    public class StringBuildBufferDemo {
        public static void main(String[] args) {
            // 1. 创建StringBuilder对象（初始容量16，可指定容量减少扩容次数）
            StringBuilder sb = new StringBuilder(); // 空构造，初始容量16
            // StringBuilder sb = new StringBuilder(32); // 指定初始容量，避免频繁扩容
    
            // 2. 拼接内容：append()（核心方法，支持所有数据类型）
            sb.append("Hello");
            sb.append(" ");
            sb.append("Java");
            sb.append(8); // 拼接数字
            System.out.println("拼接后：" + sb); // 输出：Hello Java8
    
            // 3. 插入内容：insert(int offset, 内容)
            sb.insert(6, "My "); // 在索引6的位置插入"My "
            System.out.println("插入后：" + sb); // 输出：Hello My Java8
    
            // 4. 替换内容：replace(int start, int end, String str)（左闭右开）
            sb.replace(6, 9, "New"); // 替换索引6-8的内容为"New"
            System.out.println("替换后：" + sb); // 输出：Hello New Java8
    
            // 5. 反转字符串：reverse()
            sb.reverse();
            System.out.println("反转后：" + sb); // 输出：8avaJ weN olleH
    
            // 6. 删除内容：delete(int start, int end)
            sb.delete(0, 1); // 删除索引0的字符（8）
            System.out.println("删除后：" + sb); // 输出：avaJ weN olleH
    
            // 7. 转为String（最终使用时一般要转成String）
            String finalStr = sb.toString();
            System.out.println("最终String：" + finalStr); // 输出：avaJ weN olleH
    
            // 8. 获取长度：length()
            System.out.println("当前长度：" + sb.length()); // 输出：13
    
            // ================== StringBuffer用法（仅创建方式不同） ==================
            StringBuffer sbf = new StringBuffer("多线程场景");
            sbf.append("使用StringBuffer");
            System.out.println("StringBuffer结果：" + sbf); // 输出：多线程场景使用StringBuffer
        }
    }
    

##### 三者对比

特性

String

StringBuffer

StringBuilder

可变性

不可变

可变

可变

线程安全

是

是

否

性能

低（频繁操作时）

中

高

引入版本

JDK 1.0

JDK 1.0

JDK 1.5

* * *

### 总结

*   操作少量数据：用 String。
*   单线程下操作大量字符串：用 StringBuilder。
*   多线程下操作大量字符串：用 StringBuffer。
*   判断内容相等：务必使用 equals() 而不是 ==。