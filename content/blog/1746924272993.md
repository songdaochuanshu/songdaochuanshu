---
layout: post
title: 'K8s新手系列之Service资源'
date: "2025-05-11T00:44:32Z"
---
K8s新手系列之Service资源
=================

概述
--

官方文档：[https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)

在kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是pod的ip地址不是固定的，这也就意味着不方便直接采用pod的ip对服务进行访问。

为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。  
![image](https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504124541547-1490456237.png)

Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后它会将最新的Service信息转换成对应的访问规则。  
![image](https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504124614237-722412312.png)

**简单点说就是：Service可以实现pod的负载均衡和服务发现功能，为访问Pod提供了统一的访问入口。**

Service的类型
----------

Service的类型有四类：分别是以下四类

### ClusterIP

这是svc默认的类型，是k8s集群内部分配的虚拟IP，适用于集群内部进行访问，外部访问不到，但是可以使用 Ingress 或者 Gateway API 来公开服务。创建svc时会自动关联endpoints资源。  
![image](https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504125042139-1730108600.png)

### NodePort

在ClusterIP基础之上，多添加了对所有Worker节点实现端口映射的功能。NodePort的工作原理其实就是将service的端口映射到Node的一个端口上，然后就可以通过NodeIp:NodePort来访问service了。  
![image](https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504125023986-1940989601.png)

### LoadBalancer

实现负载均衡的服务，主要应用场景是云厂商环境，它能够为服务提供外部可访问的 IP 地址。这种类型的服务通过云服务提供商的负载均衡器实现，允许外部流量进入集群中的 Pod。  
![image](https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504125113794-1197540018.png)

### ExternalName

ExternalName类型的Service用于引入集群外部的服务，它通过ExternalName属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。  
![image](https://img2024.cnblogs.com/blog/3468887/202505/3468887-20250504125148444-1191004622.png)

Service的作用
----------

### 服务发现与负载均衡

*   服务发现：Kubernetes 中的 Pod 是动态创建和销毁的，它们的 IP 地址也是动态分配的。Service 为一组具有相同功能的 Pod 提供了一个固定的虚拟 IP 地址和 DNS 名称。其他组件可以通过这个固定的地址来访问这些 Pod，而无需关心具体 Pod 的 IP 地址变化。
    
*   负载均衡：Service 可以将流量均匀地分发到后端的多个 Pod 上，实现负载均衡的功能。这样可以确保应用能够处理大量的并发请求，提高系统的性能和可靠性。例如，一个 Web 应用可能由多个 Pod 组成，通过 Service 可以将用户的请求均衡地分配到这些 Pod 上，避免单个 Pod 因负载过高而出现性能问题。
    

### 应用解耦

*   解耦客户端与服务端：Service 使得客户端与后端服务的 Pod 之间实现了解耦。客户端只需要知道 Service 的地址，而不需要了解后端具体有哪些 Pod 以及它们的状态。当后端 Pod 发生变化（如扩容、缩容或升级）时，客户端无需进行任何修改，仍然可以通过 Service 正常访问服务。
    
*   支持微服务架构：在微服务架构中，不同的微服务之间通常需要相互调用。Service 为每个微服务提供了独立的访问入口，使得各个微服务可以独立地进行部署、扩展和升级，而不会影响到其他微服务。这种解耦方式提高了整个系统的可维护性和可扩展性。
    

### 提供稳定的网络端点

*   外部访问入口：对于需要对外提供服务的应用，Service 可以作为外部访问的入口点。通过将 Service 设置为 NodePort 类型或 LoadBalancer 类型，可以将服务暴露到集群外部，让外部用户能够访问到 Kubernetes 集群中的应用。
    
*   内部网络隔离：在 Kubernetes 集群内部，Service 还可以用于实现网络隔离。通过定义不同的 Service 和相应的访问规则，可以限制哪些 Pod 能够访问特定的服务，从而提高集群的安全性和稳定性。
    

### 方便应用管理与维护

*   统一管理：通过 Service，可以对一组相关的 Pod 进行统一的管理和配置。例如，可以通过 Service 来设置访问策略、监控指标收集等，而无需对每个 Pod 单独进行配置。
    
*   简化运维操作：当需要对应用进行升级、回滚或其他运维操作时，只需要对 Service 进行相应的配置修改，Kubernetes 会自动根据 Service 的定义来调整后端 Pod 的状态，从而简化了运维操作的复杂度。
    

Service的工作原理
------------

Service 通过 `Label Selector` 来选择对应的 Pods，当 Service 接收到请求时，它会根据负载均衡算法将请求转发到后端的某个 Pod 上。K8s 中的 `kube - proxy` 组件负责在节点上维护网络规则，确保 Service 能够正确地将流量路由到后端 Pods。

Service的资源配置文件
--------------

    apiVersion: v1          # API版本，Service属于核心API组，固定使用v1
    kind: Service           # 资源类型为Service
    
    metadata:               # 元数据，定义Service的标识信息
      name: my-service      # Service名称，必须符合DNS标签规范
      namespace: default    # 命名空间，默认为default
      labels:               # 标签，用于组织和选择资源
        app: my-app
        tier: backend
      annotations:          # 注解，用于存储非标识性元数据（如配置信息）
        service.beta.kubernetes.io/aws-load-balancer-type: nlb
    
    spec:                   # 服务规范，定义Service的行为和关联的Pod
      type: ClusterIP       # Service类型（ClusterIP/NodePort/LoadBalancer/ExternalName）
      
      selector:             # 标签选择器，用于确定哪些Pod属于此服务
        app: my-app
        tier: backend
      
      ports:                # 端口配置，定义服务如何接收流量
      - name: http          # 端口名称，必须符合DNS标签规范
        protocol: TCP       # 协议类型，支持TCP/UDP/SCTP，默认为TCP
        port: 80            # 服务暴露的端口（集群内部访问使用）
        targetPort: 8080    # 后端Pod接收流量的端口
        nodePort: 30080     # NodePort类型时，节点上暴露的端口（30000-32767）
      
      externalIPs:          # 外部IP列表，允许通过这些IP访问服务
      - 80.11.12.10
      
      sessionAffinity: None # 会话亲和性（None/ClientIP），默认为None
      sessionAffinityConfig:  # 会话亲和性配置（仅当sessionAffinity为ClientIP时有效）
        clientIP:
          timeoutSeconds: 10800  # 客户端IP会话保持时间（秒）
      
      loadBalancerIP: 70.42.103.12  # LoadBalancer类型时，指定负载均衡器的IP
      loadBalancerSourceRanges:    # 限制访问LoadBalancer的客户端IP范围
      - 10.0.0.0/8
      
      externalName: my.database.example.com  # ExternalName类型时，指定外部域名
      
      publishNotReadyAddresses: false  # 是否发布未就绪的端点，默认为false
    

Service之ClusterIP实战
-------------------

这是svc默认的类型，是k8s集群内部分配的虚拟IP，适用于集群内部进行访问，外部访问不到，但是可以使用 Ingress 或者 Gateway API 来公开服务。创建svc时会自动关联endpoints资源。

### 创建一个Deployment

    [root@master01 ~/deploy]# cat deploy-nginx.yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: deployment-nginx
      namespace: default
    spec:
      # 设置Pod的副本数量
      replicas: 3
      selector:
        # 标签匹配规则
        matchLabels:
          app: nginx
      template:
        metadata:
          name: pod-nginx
          labels:
            app: nginx
        spec:
          containers:
          - name: container-nginx
            image: nginx:1.14.1
          restartPolicy: Always
    
    # 创建deploy
    [root@master01 ~/deploy]# kubectl apply -f deploy-nginx.yaml
    deployment.apps/deployment-nginx created
    

### 创建Service

    # 定义service
    [root@master01 ~/service]# cat service-clusterip.yaml
    apiVersion: v1
    kind: Service
    metadata:
      # 需要和pod在一个命名空间内
      namespace: default
      name: nginx-svc-clusterip
    spec:
      # 定义service的类型
      type: ClusterIP
      # 标签选择器，选择pod的标签，而不是deploy的标签
      selector:
        app: nginx
      # 定义端口映射
      ports:
      - name: clusterip-nginx
        # 访问service的端口
        port: 6789
        # 容器的端口
        targetPort: 80
        protocol: TCP
    
    # 创建service
    [root@master01 ~/service]# kubectl apply -f service-clusterip.yaml
    service/nginx-svc-clusterip created
    

### 查看service的详情

    # 查看service
    [root@master01 ~/service]# kubectl get svc -o wide
    NAME                  TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE   SELECTOR
    nginx-svc-clusterip   ClusterIP   10.96.3.77   <none>        6789/TCP   91s   app=nginx
    
    # 查看详情
    [root@master01 ~/service]# kubectl describe svc nginx-svc-clusterip
    Name:              nginx-svc-clusterip
    Namespace:         default
    Labels:            <none>
    Annotations:       <none>
    Selector:          app=nginx
    Type:              ClusterIP
    IP Family Policy:  SingleStack
    IP Families:       IPv4
    IP:                10.96.3.77
    IPs:               10.96.3.77
    Port:              clusterip-nginx  6789/TCP
    TargetPort:        80/TCP
    Endpoints:         100.117.144.188:80,100.117.144.189:80,100.95.185.217:80
    Session Affinity:  None
    Events:            <none>
    

注意看Endpoints字段，该字段对应的是关联的所有的pod的`IP:PORT`地址，service和pod之间的联系是通过endpoints实现的。

### 访问service

访问clusterip的service需要通过分配给service的IP和PORT进行访问

    # 可以看到CLUSTER-IP字段分配的值是10.96.3.77，PORT(S)字段的值是6789（我们在资源配置文件中定义的）
    [root@master01 ~/service]# kubectl get svc -o wide
    NAME                  TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE   SELECTOR
    nginx-svc-clusterip   ClusterIP   10.96.3.77   <none>        6789/TCP   91s   app=nginx
    
    # 访问service
    [root@master01 ~/service]# curl 10.96.3.77:6789
    <!DOCTYPE html>
    <html>
    <body>
    <h1>Welcome to nginx!</h1>
    # 省略部分内容
    
    <p><em>Thank you for using nginx.</em></p>
    </body>
    </html>
    

Service之NodePort实战
------------------

ClusterIP只能在K8s集群内部访问，外部无法访问，而NodePort在ClusterIP基础之上，多添加了对所有Worker节点实现端口映射的功能。实现了外部访问Pod。  
NodePort的工作原理其实就是将service的端口映射到Node的一个端口上，然后就可以通过NodeIp:NodePort来访问service了。

### 创建deployment

    # 定义资源文件
    [root@master01 ~/deploy]# cat deploy-tomcat.yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: deployment-tomcat
      namespace: default
    spec:
      # 定义更新策略
      strategy:
        type: RollingUpdate
        rollingUpdate:
          maxSurge: 1
          maxUnavailable: 1
      replicas: 3
      selector:
        matchLabels:
          app: tomcat
      template:
        metadata:
          name: pod-tomcat
          labels:
            app: tomcat
        spec:
          containers:
          - name: container-tomcat
            image: tomcat:9.0
          restartPolicy: Always
    # 创建deployment
    [root@master01 ~/deploy]# kubectl apply -f deploy-tomcat.yaml
    deployment.apps/deployment-tomcat created
    

### 创建service

    # 定义资源文件
    [root@master01 ~/service]# cat service-nodeport.yaml
    apiVersion: v1
    kind: Service
    metadata:
      # 需要和pod在一个命名空间内
      namespace: default
      name: tomcat-svc-nodeport
    spec:
      # 定义service的类型
      type: NodePort
      # 标签选择器，选择pod的标签，而不是deploy的标签
      selector:
        app: tomcat
      # 定义端口映射
      ports:
      - name: nodeport-tomcat
        # 访问service的端口
        port: 16789
        # 容器的端口
        targetPort: 8080
        # nodePort的取值是30000-32767，会随机生成，但建议配置
        nodePort: 31180
        protocol: TCP
    # 创建service
    [root@master01 ~/service]# kubectl apply -f service-nodeport.yaml
    service/tomcat-svc-nodeport created
    

### 查看service

    ## 查看service
    [root@master01 ~/service]# kubectl get svc -o wide
    NAME                  TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)           AGE     SELECTOR
    tomcat-svc-nodeport   NodePort    10.96.0.110   <none>        16789:31180/TCP   54s     app=tomcat
    
    # 查看详情
    [root@master01 ~/service]# kubectl describe svc tomcat-svc-nodeport
    Name:                     tomcat-svc-nodeport
    Namespace:                default
    Labels:                   <none>
    Annotations:              <none>
    Selector:                 app=tomcat
    Type:                     NodePort
    IP Family Policy:         SingleStack
    IP Families:              IPv4
    IP:                       10.96.0.110
    IPs:                      10.96.0.110
    Port:                     nodeport-tomcat  16789/TCP
    TargetPort:               8080/TCP
    NodePort:                 nodeport-tomcat  31180/TCP
    Endpoints:                <none>
    Session Affinity:         None
    External Traffic Policy:  Cluster
    Events:                   <none>
    

### 访问service

访问nodeport的service可以通过集群内部的`IP:PORT`进行访问，也可以通过node节点的`IP:PORT`进行访问

通过所有node节点均可访问

    ## 查看service
    [root@master01 ~/service]# kubectl get svc -o wide
    NAME                  TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)           AGE     SELECTOR
    tomcat-svc-nodeport   NodePort    10.96.0.110   <none>        16789:31180/TCP   54s     app=tomcat
    
    # 通过集群内部
    curl 10.96.0.110:16789
    
    # 通过node节点进行访问
    curl 10.0.0.30:31180
    curl 10.0.0.31:31180
    curl 10.0.0.32:31180
    

Service之ExternalName实战
----------------------

ExternalName类型的Service用于引入集群外部的服务，它通过ExternalName属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。

### 创建service

    # 定义配置文件
    [root@master01 ~/service]# cat service-externalname.yaml
    apiVersion: v1
    kind: Service
    metadata:
        name: baidu-externalname
    spec:
        type: ExternalName
        externalName: www.baidu.com
        #ports:
        #- name: baidu-name
        #  port: 443            # 服务端口（集群内部使用）
        #  targetPort: 443      # 外部服务实际端口
        #  protocol: TCP
    # 创建service
    [root@master01 ~/service]# kubectl apply -f service-externalname.yaml
    service/baidu-externalname created
    

### 查看详情

    # 查看service
    [root@master01 ~/service]# kubectl get svc
    NAME                  TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)           AGE
    baidu-externalname    ExternalName   <none>        www.baidu.com   <none>            47s
    # 查看service详情
    [root@master01 ~/service]# kubectl describe svc baidu-externalname
    Name:              baidu-externalname
    Namespace:         default
    Labels:            <none>
    Annotations:       <none>
    Selector:          <none>
    Type:              ExternalName
    IP Families:       <none>
    IP:
    IPs:               <none>
    External Name:     www.baidu.com
    Session Affinity:  None
    Events:            <none>
    

### 验证集群内部访问

    # 创建busybox容器进行访问测试
    [root@master01 ~/service]# kubectl run -it --rm dns-test --image=busybox:1.28
    If you don't see a command prompt, try pressing enter.
    
    # nslookup 验证
    / # nslookup baidu-externalname
    Server:    10.96.0.10
    Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local
    
    Name:      baidu-externalname
    Address 1: 2409:8c00:6c21:118b:0:ff:b0e8:f003
    Address 2: 2409:8c00:6c21:11eb:0:ff:b0bf:59ca
    Address 3: 39.156.70.239
    Address 4: 39.156.70.46
    
    # ping进行访问
    / # ping  baidu-externalname
    PING baidu-externalname (39.156.70.239): 56 data bytes
    64 bytes from 39.156.70.239: seq=0 ttl=127 time=15.301 ms
    64 bytes from 39.156.70.239: seq=1 ttl=127 time=14.258 ms
    64 bytes from 39.156.70.239: seq=2 ttl=127 time=29.040 ms
    

Service之LoadBalancer（省略）
------------------------

LoadBalancer目前没有云环境，在这儿先省略

Service的管理
----------

### 查看Service

语法：

    kubectl get svc <svc-name> -n <namespace>
    

示例：

    [root@master01 ~/service]# kubectl get svc
    NAME                  TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)           AGE
    baidu-externalname    ExternalName   <none>        www.baidu.com   <none>            23m
    kubernetes            ClusterIP      10.96.0.1     <none>          443/TCP           13d
    nginx-svc-clusterip   ClusterIP      10.96.3.77    <none>          6789/TCP          4d20h
    tomcat-svc-nodeport   NodePort       10.96.0.110   <none>          16789:31180/TCP   49m
    

### 修改Service

有两种方式，一种是通过`kubectl edit svc <svc-name>`来进行修改，会打开一个类似vim的界面，修改其对应的值即可，最后wq保存即可应用你的配置.  
另一种方式则是修改对应的资源文件，最后使用`kubectl apply -f <file>`即可。

### 删除Service

语法：

    kubectl delete svc <svc-name> -n <namespace>
    

本文来自博客园，作者：[huangSir-devops](https://www.cnblogs.com/huangSir-devops/)，转载请注明原文链接：[https://www.cnblogs.com/huangSir-devops/p/18859122](https://www.cnblogs.com/huangSir-devops/p/18859122)，微信Vac666666，欢迎交流