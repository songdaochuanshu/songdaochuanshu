---
layout: post
title: 'Rust多线程中安全的使用变量'
date: "2025-01-27T00:36:38Z"
---
Rust多线程中安全的使用变量
===============

在Rust语言中，一个既引人入胜又可能带来挑战的特性是**闭包**如何从其所在环境中捕获变量，尤其是在涉及**多线程**编程的情境下。

如果尝试在不使用`move`关键字的情况下创建新线程并传递数据至闭包内，编译器将很可能返回一系列与**生命周期**、**借用规则**及**所有权**相关的复杂错误信息。

不过，这种机制虽然增加了学习曲线，但也确保了内存安全与并发执行中的数据一致性。

本文我们将探讨如何在线程的闭包中安全的使用变量，包括共享变量和修改变量。

1\. 向线程传递变量
===========

首先，我们构造一个简单的示例，在线程中正常使用一个外部的变量，看看Rust中能否正常编译运行。

    use std::thread;
    
    fn main() {
        let msg = String::from("Hello World!");
    
        let handle = thread::spawn(|| {
            // msg 是主线中定义的变量
            println!("{}", msg);
        });
    
        handle.join().unwrap();
    }
    

例子非常简单，看着写法也没什么问题，在其他编程语言中类似的写法是没有问题的。

但是，使用`cargo run`运行时，却有如下的错误：

![](https://img2024.cnblogs.com/blog/83005/202501/83005-20250126142136743-57104095.png)

为什么会有这样的错误？这就是`Rust`在内存方面更加严谨的原因。

上面`Rust`的错误信息中也给出了原因，总结起来主要有两点：

1.  **线程的生命周期**：新创建的线程的生命周期有可能超出主函数 `main` 的执行范围。当 `main` 函数终止时，与之相关的局部变量（也就是`msg`）将超出作用域。
2.  **不符合借用规则**：在 `Rust` 中，引用的生命周期不会超过其所指向数据的生命周期，以避免出现**悬空引用**。如果main提前结束，那么线程中的msg将成为**悬空引用**。

修复的方法很简单，使用`move`关键字，将变量的所有权转移到线程中就可以了。

        let handle = thread::spawn(move || {
            // msg 是主线中定义的变量
            println!("{}", msg);
        });
    

这样就可以正常运行了。

![](https://img2024.cnblogs.com/blog/83005/202501/83005-20250126142136710-1468240084.png)

不过，这样，主线程中就无法使用变量`msg`了，比如在`main`函数的最后打印`msg`，会报错，因为它的所有权已经转移到线程中了。

2\. 多线程共享变量引用
=============

如果我们只把**变量的引用**转移给线程，是不是可以在主线程`main`中继续使用变量`msg`呢？

    use std::thread;
    
    fn main() {
        let msg = String::from("Hello World!");
        let msg_ref = &msg;
    
        let handle = {
    
            thread::spawn(move || {
                // msg 是主线中定义的变量
                println!("{}", msg_ref);
            })
        };
    
        handle.join().unwrap();
    
        println!("msg in main : {}", msg_ref);
    }
    

很遗憾，依然有错误：

![](https://img2024.cnblogs.com/blog/83005/202501/83005-20250126142136742-65722617.png)

错误的原因仍然是传入线程中的变量引用`msg_ref`生命周期的不够长。

虽然我们使用了`move`，将`msg_ref`转移到线程中，但`main`中仍然拥有底层的数据`msg`，

一旦`main`函数结束（或者数据在线程完成之前超出范围），该引用（msg\_ref）指向数据将失去有效的内存，成为**悬空引用**。

总的来说就是：

1.  **移动引用**并不移动原始数据-只转移引用本身的所有权
2.  实际数据（`msg`）仍然由原始范围拥有，并具有自己的生命周期约束

为了修复这个错误，就要用到`Rust`中提供的并发原语`Arc`（一种自动引用计数的智能指针）。

先看看使用`Arc`修改后的例子。

    use std::sync::Arc;
    use std::thread;
    
    fn main() {
        let msg = String::from("Hello World!");
        // 通过Arc来创建变量的引用
        let msg_ref = Arc::new(msg);
    
        // 线程1
        let handle_1 = {
            // move 之前，先使用Arc clone 变量
            let msg_thread = Arc::clone(&msg_ref);
    
            thread::spawn(move || {
                println!("Thread 1: {}", msg_thread);
            })
        };
    
        // 线程2
        let handle_2 = {
            let msg_thread = Arc::clone(&msg_ref);
    
            thread::spawn(move || {
                println!("Thread 2: {}", msg_thread);
            }) 
        };
    
        handle_1.join().unwrap();
        handle_2.join().unwrap();
    
        // 主线程中依然可以使用变量
        println!("msg in main : {}", msg_ref);
    }
    

使用`Arc`修改之后，变量不仅可以在多个线程中共享，主线程中也可以使用。

![](https://img2024.cnblogs.com/blog/83005/202501/83005-20250126142136712-1387787481.png)

3\. 多线程中修改变量
============

上面的示例是在多个线程中共享变量，如果想要修改变量的话，那么就会出现数据竞争的情况。

这时，就要用到`Rust`的另一个并发原语`Mutex`。

    use std::sync::{Arc, Mutex};
    use std::thread;
    
    fn main() {
        // 创建一个被Mutex保护的共享数据，这里是一个i32类型的数字
        let shared_number = Arc::new(Mutex::new(0));
    
        // 定义一个线程向量，用于存储创建的线程
        let mut threads = Vec::new();
    
        // 创建10个线程，每个线程对共享数据进行1000次递增操作
        for _ in 0..10 {
            // 克隆Arc，使得每个线程都拥有一个指向共享数据的引用
            let num_clone = Arc::clone(&shared_number);
            let handle = thread::spawn(move || {
                // 尝试获取Mutex的锁，这是一个阻塞操作，如果锁不可用，线程会等待
                let mut num = num_clone.lock().unwrap();
                for _ in 0..1000 {
                    *num += 1;
                }
            });
            threads.push(handle);
        }
    
        // 等待所有线程完成操作
        for handle in threads {
            handle.join().unwrap();
        }
    
        // 获取最终的共享数据值并打印
        let final_num = shared_number.lock().unwrap();
        println!("最终10个线程的累加结果: {}", final_num);
    }
    

在这个示例中：

1.  首先创建了一个`Arc<Mutex<i32>>`类型的共享数据，`Arc`用于在多个线程间共享`Mutex`，`Mutex`用于保护内部的`i32`数据。
2.  循环创建`10`个线程，每个线程都克隆了`Arc`并尝试获取`Mutex`的锁。一旦获取到锁，线程就可以安全地对共享数据进行递增操作。
3.  主线程使用`join`方法等待所有子线程完成操作。
4.  最后，主线程获取并打印共享数据的最终值。由于Mutex的保护，多个线程对共享数据的操作不会产生数据竞争，保证了数据的一致性。

运行结果：

![](https://img2024.cnblogs.com/blog/83005/202501/83005-20250126142136726-338449892.png)

`10`个线程，每个累加`1000`，所以最后结果是`1000*10=10000`。

4\. 总结
======

从上面的例子可以看出，`Rust`的闭包捕获规则最初可能感觉很严格，但它们在确保**内存安全**和**数据竞争自由**方面至关重要。

总之，

如果需要在另一个线程中拥有数据，考虑使用`move`；

如果需要跨线程共享数据，考虑使用`Arc`；

如果需要跨线程共享和修改数据，考虑使用`Arc+Mutex`；