---
layout: post
title: 'JVM 堆内存分代'
date: "2026-01-09T00:45:40Z"
---
JVM 堆内存分代
=========

不同存活周期的对象放在不同区域，用不同算法回收，保证 GC 效率，这就是 "分代回收" 的核心思想。

​今天我们一起来聊一聊 **JVM 堆内存**。

![Java Heap1](https://img2024.cnblogs.com/blog/1171560/202601/1171560-20260108182258403-1042762825.png)

**Java Heap**（堆内存）由 **Young Generation**（新生代，约占 **1/3** ）和 **Old Generation**（老年代，约占 **2/3** ）组成。

**Young Generation** 又由 **Eden Space**（伊甸园区，占新生代 **80%** ）、**Survivor Space 0**（幸存者区0，占新生代 **10%** ）和 **Survivor Space 1**（幸存者区1，占新生代 **10%** ）组成。

**对象的生命周期**：

![对象生命周期](https://img2024.cnblogs.com/blog/1171560/202601/1171560-20260108182353974-1428015339.png)

**Young Generation**（新生代）：

*   存储 **新创建**、**存活周期极短** 的对象，比如方法内的局部变量、临时对象。默认占堆总容量 **1/3** 。
*   触发 **Minor GC**（新生代 GC），频率极高（毫秒 / 秒级），但耗时极短（几十毫秒）。
*   Eden 区是 Minor GC 的 "触发源头"，调大 Eden 区可减少 Minor GC 次数。

**Eden Space**（伊甸园区）：新对象的 "默认出生地"，**99% 的新对象** 都会优先分配到 Eden 区（除非是超大对象直接进入老年代）。占新生代 **80%** 。

**Survivor Space 0/1**（幸存者区 0/1，简称 S0/S1，也叫 From 区 / To 区）：

*   新生代 GC 后存活对象的 **"临时中转站"**，避免存活对象直接进入老年代。**两个区会动态互换角色**。各占新生代 **10%**，合计 20%。
*   S0 和 S1 **永远有一个是空的**（这是 JVM 的设计巧思）。
*   每经历一次 Minor GC，存活对象的 **"年龄 + 1"**。

**S0/S1 的交互** 示例：

*   ① 初始状态：Eden 有对象，S0 有对象，S1 为空；
*   ② Eden 触发 Minor GC → 回收 Eden+S0 的垃圾对象，存活对象复制到 S1，清空 Eden+S0；
*   ③ 此时 S1 非空、S0 为空，两者角色互换（S0=To 区，S1=From 区）；
*   ④ 下次 Minor GC 重复上述过程，存活对象在 S0/S1 之间 **"来回复制"**。

**Old Generation**（老年代）：

*   存储 **长期存活、体积较大** 的对象，比如单例对象、缓存对象、经历多次 Minor GC 仍存活的对象。默认占堆总容量 **2/3**。
*   触发 **Major GC / Full GC**，频率极低，但耗时极长。
*   老年代大小决定 Full GC 频率 —— 老年代越大，Full GC 频率越低，但单次 Full GC 耗时越长。

**对象进入老年代的条件**：

*   **年龄达标**：对象在 S0/S1 之间复制次数达到阈值（默认 15 次，`-XX:MaxTenuringThreshold`调整）；
*   **大对象**：超过阈值的对象（`-XX:PretenureSizeThreshold`）直接进入老年代；
*   **空间担保失败**：Minor GC 后 Survivor 区放不下存活对象，多余对象直接晋升老年代；
*   **动态年龄判断**：Survivor 区中相同年龄对象总和超过 50%，该年龄及以上对象直接进入老年代。

不同存活周期的对象放在不同区域，用不同算法回收，保证 **GC** 效率，这就是 **"分代回收"** 的核心思想。

努力的意义，不在于追逐别人的高度，而是拼尽全力，为自己创造一个绝地反击的故事。-- 烟沙九洲