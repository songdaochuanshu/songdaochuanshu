---
layout: post
title: 'React+Three.js å®ç° Apple 2025 çƒ­æˆåƒ logo'
date: "2025-10-20T00:44:07Z"
---
React+Three.js å®ç° Apple 2025 çƒ­æˆåƒ logo
=====================================

![React+Three.js å®ç° Apple 2025 çƒ­æˆåƒ logo](https://img2024.cnblogs.com/blog/772544/202510/772544-20251019183629972-1938115929.png) æœ¬æ–‡å°†åŸºäº React + Three.js + GLSL çš„ç›¸å…³çŸ¥è¯†ï¼Œå®ç° Apple 2025 åŠ¨æ€çƒ­æˆåƒ logo æ•ˆæœã€‚é€šè¿‡æœ¬æ–‡çš„é˜…è¯»å’Œå­¦ä¹ ï¼Œä½ å°†å­¦ä¹ åˆ°çš„çŸ¥è¯†ç‚¹åŒ…æ‹¬ï¼šç¦»å±æ¸²æŸ“æŠ€æœ¯ FBOã€äº¤äº’äº‹ä»¶ä¸åŠ¨æ€å‚æ•°æ§åˆ¶ã€Leva æ§åˆ¶é¢æ¿çš„åº”ç”¨ã€è§†é¢‘çº¹ç†ã€é®ç½©çº¹ç†ã€ç€è‰²å™¨æè´¨çš„ä½¿ç”¨ã€çƒ­æˆåƒåŠ¨ç”»ç€è‰²å™¨å®ç°å’Œåº”ç”¨ç­‰

> `Apple 2025` å¹´åº¦å‘å¸ƒä¼š `LOGO` ä»¥æ ‡å¿—æ€§çš„è‹¹æœå›¾å½¢è¢«æ³¨å…¥ç‚½çƒ­çš„ç«ç„°è´¨æ„Ÿï¼Œè‰²å½©ä»æš–è°ƒæ©™é»„å‘å†·è°ƒæ¹›è“è‡ªç„¶è¿‡æ¸¡ï¼Œä¼¼é«˜æ¸©ç¼çƒ§ä¸‹çš„é‡‘å±è¡¨é¢ï¼Œè¿¸å‘å‡ºç†”èçš„å…‰æ³½ï¼›åˆè‹¥æ— å½¢çš„èƒ½é‡åœ¨æµåŠ¨ï¼Œå‹¾å‹’å‡ºç§‘æŠ€çš„è„‰æä¸å¾‹åŠ¨ï¼Œå°† â€œç§‘æŠ€â€ ä¸ â€œåŠ›é‡â€ çš„ç¢°æ’æ„Ÿå…·è±¡åŒ–ï¼Œå…‰å½±çš„æ˜æš—äº¤é”™å‰Šå¼±äº†å¹³é¢çš„å•è–„æ„Ÿï¼Œèµ‹äºˆå…¶è¿‘ä¹è§¦æ‰‹å¯åŠçš„è´¨æ„Ÿï¼ŒåŒæ—¶è¥é€ å‡ºæµ“éƒçš„æœªæ¥æ„Ÿä¸æœªçŸ¥æ„Ÿã€‚

æ‘˜è¦
--

å¦‚ä¸Šè¿°å¼•ç”¨å†…å®¹ï¼Œæœ¬æ–‡å°†åŸºäº `React + Three.js + GLSL` çš„ç›¸å…³çŸ¥è¯†ï¼Œå®ç° `Apple 2025` åŠ¨æ€çƒ­æˆåƒ `logo` æ•ˆæœã€‚é€šè¿‡æœ¬æ–‡çš„é˜…è¯»å’Œå­¦ä¹ ï¼Œä½ å°†å­¦ä¹ åˆ°çš„çŸ¥è¯†ç‚¹åŒ…æ‹¬ï¼šç¦»å±æ¸²æŸ“æŠ€æœ¯ `FBO`ã€äº¤äº’äº‹ä»¶ä¸åŠ¨æ€å‚æ•°æ§åˆ¶ã€`Leva` æ§åˆ¶é¢æ¿çš„åº”ç”¨ã€è§†é¢‘çº¹ç†ã€é®ç½©çº¹ç†ã€ç€è‰²å™¨æè´¨çš„ä½¿ç”¨ã€çƒ­æˆåƒåŠ¨ç”»ç€è‰²å™¨å®ç°å’Œåº”ç”¨ç­‰ã€‚

æ•ˆæœ
--

æœ¬æ–‡é¡µé¢å®ç°æ•ˆæœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œé¡µé¢é¡µé¢ä¸­å¿ƒç”± `Apple` çƒ­æˆåƒåŠ¨æ€å›¾æ ‡æ„æˆï¼Œå›¾æ ‡ä¸Šé¢ç”±æ©™è‰²å’Œè“è‰²æ¸å˜è‰²åŠ¨æ€æµåŠ¨ï¼Œé¡µé¢åº•éƒ¨ä¸ºè“è‰²æ¸å˜æ–‡æ¡ˆã€‚

å½“ä½¿ç”¨é¼ æ ‡ `ğŸ–±ï¸` æˆ–è§¦æ§æ¿ `ğŸ‘‹` ç½‘é¡µä¸ŠæŒ‰å‹æˆ–æ‹–åŠ¨ `Logo` æ—¶ï¼Œå¯ä»¥çœ‹åˆ°é¢œè‰²éšæ‰‹åŠ¿å±•å¼€å˜åŒ–ï¼Œçœ‹èµ·æ¥åƒæ˜¯æ¨¡æ‹ŸçœŸå®çƒ­é‡è½¨è¿¹ã€‚

æœ¬ä¸“æ ç³»åˆ—ä»£ç æ‰˜ç®¡åœ¨ `Github` ä»“åº“[ã€threejs-odesseyã€‘](https://github.com/dragonir/threejs-odessey)ï¼Œ**åç»­æ‰€æœ‰ç›®å½•ä¹Ÿéƒ½å°†åœ¨æ­¤ä»“åº“ä¸­æ›´æ–°**ã€‚

> `ğŸ”—` ä»£ç ä»“åº“åœ°å€ï¼šgit@github.com:dragonir/threejs-odessey.git

å®ç°
--

æœ¬æ–‡ä»£ç å®ç°æ•ˆæœå‚è€ƒè‡ªï¼š[https://github.com/vladmdgolam/apple-event-2025](https://github.com/vladmdgolam/apple-event-2025)ï¼Œå®ç°å†…å®¹æ¨¡å—æ—¨åœ¨å¯¹å…¶æ ¸å¿ƒçŸ¥è¯†ç‚¹è¿›è¡Œæ±‡æ€»å½’çº³å­¦ä¹ ï¼Œé€šè¿‡ç›¸åŒçš„åŸç†å¹¶ä¸¾ä¸€åä¸‰ï¼Œå®ç°ä¸“å±è‡ªå·±çš„çƒ­æˆåƒåŠ¨æ€ `logo` `ğŸ˜`ã€‚

### â‘  èµ„æºå¼•å…¥

ä»¥ä¸‹æ˜¯å®ç°è‹¹æœçƒ­æˆåƒæ‰€éœ€çš„ä¸»è¦ä¾èµ–èµ„æºï¼Œå…¶ä¸­ï¼š`OrthographicCamera`ç”¨äºåˆ›å»ºå¹³è¡ŒæŠ•å½±ç›¸æœºã€`LinearFilter` æ˜¯çº¹ç†é‡‡æ ·è¿‡æ»¤æ–¹å¼çš„å¸¸é‡ï¼Œç”¨äºåœ¨æ§åˆ¶çº¹ç†åœ¨æ”¾å¤§ç¼©å°æ—¶çš„å¹³æ»‘è¿‡æ¸¡æ•ˆæœã€`ShaderMaterial` ç”¨äºé€šè¿‡ `GLSL`åˆ›å»ºè‡ªå®šä¹‰çš„ç€è‰²å™¨æè´¨ï¼Œæ˜¯å®ç°æœ¬æ¡ˆä¾‹æ•ˆæœçš„å…³é”®ã€`VideoTexture`å¯ä»¥å°†è§†é¢‘å…ƒç´ ä½œä¸ºæ•°æ®æºåˆ›å»ºåŠ¨æ€çš„è§†é¢‘çº¹ç†ã€`Leva` æ˜¯ä¸€ä¸ªè½»é‡çº§çš„å‰ç«¯è°ƒè¯•å·¥å…·åº“ï¼Œä¸»è¦ç”¨äºå¿«é€Ÿåˆ›å»ºäº¤äº’å¼æ§åˆ¶é¢æ¿ï¼Œæ–¹ä¾¿å¼€å‘è€…åœ¨å¼€å‘è¿‡ç¨‹ä¸­å®æ—¶è°ƒè¯•çƒ­æˆåƒçš„å„ç§å‚æ•°ç­‰ã€‚å…¶ä»–çš„ä¾èµ–éƒ½æ˜¯åˆ›å»ºä¸‰ç»´åœºæ™¯å¿…é¡»çš„ä¸€äº›å†…å®¹ï¼Œå…·ä½“ä½œç”¨å¯è‡ªè¡ŒæŸ¥é˜…ã€‚

    import { OrthographicCamera, DoubleSide, LinearFilter, Mesh, RGBFormat, RepeatWrapping, ShaderMaterial, Texture, TextureLoader, VideoTexture, } from "three"
    import { Leva, levaStore, useControls } from "leva"
    

### â‘¡ é¡µé¢åœºæ™¯åˆå§‹åŒ– HeatmapScene

ä½¿ç”¨ `React Three Fiber` åˆå§‹åŒ–åœºæ™¯ã€ç›¸æœºç­‰ï¼Œå…¶ä¸­ `Leva` ç»„ä»¶ç”¨äºåŠ¨æ€å¯è§†åŒ–è°ƒè¯•ç€è‰²å™¨çš„å¤šç§å‚æ•°ï¼Œ`Scene` ç»„ä»¶ç”¨äºæ¸²æŸ“ `logo` åœºæ™¯ï¼Œæ˜¯æ•´ä¸ªäº¤äº’å¯è§†åŒ–æ•ˆæœçš„æ ¸å¿ƒç»Ÿç­¹å±‚ã€‚

    return (
      <div>
      <Leva hidden={levaHidden} />
        <InfoPanel onToggleControls={() => setLevaHidden((p) => !p)} onRandomizeColors={randomizeColors} />
        <div ref={containerRef} className="w-[560px] h-[560px] touch-none select-none">
          <Canvas
            orthographic
            camera={{ position: [0, 0, 1], left: -2, right: 2, top: 2, bottom: -2, near: -1, far: 1, }}
            gl={{ antialias: true, alpha: true, outputColorSpace: "srgb" }}
            flat
          >
            <Scene containerRef={containerRef} />
          </Canvas>
          </div>
        <div className="dragonir">@dragonir</div>
      </div>
    )
    

### â‘¢ å®ç°åŠ¨æ€çƒ­åŠ›å›¾ç½‘æ ¼ HeatMesh

`HeatMesh` ç»„ä»¶ï¼Œå®ƒä¸»è¦é€šè¿‡è§†é¢‘çº¹ç† `VideoTexture`ã€ç»˜åˆ¶çº¹ç† `drawTexture` å’Œé®ç½©çº¹ç† `maskTexture` ä½œä¸ºæ•°æ®æºï¼Œä½¿ç”¨ç€è‰²å™¨æè´¨ `ShaderMaterial` æ¸²æŸ“ä¸€ä¸ªå¹³é¢ç½‘æ ¼ `planeGeometr`ï¼Œå®ç°äº†å¯å®æ—¶è°ƒæ•´çš„çƒ­åŠ›å›¾æ•ˆæœã€‚`ShaderMaterial` é€šè¿‡ä¼ å…¥è‡ªå®šä¹‰é¡¶ç‚¹ç€è‰²å™¨å’Œç‰‡å…ƒç€è‰²å™¨å®ç°å¤æ‚çš„çƒ­åŠ›å›¾è‰²å½©æ˜ å°„å’ŒåŠ¨æ€æ•ˆæœã€‚

    export const HeatMesh = ({ drawTexture }: { drawTexture: Texture | null }) => {
      const timeRef = useRef(0)
      const videoRef = useRef<HTMLVideoElement | null>(null)
      const [videoTexture, setVideoTexture] = useState<VideoTexture | null>(null)
      // Leva æ§åˆ¶é¢æ¿ç€è‰²å™¨å‚æ•°ï¼špowerï¼ˆå¼ºåº¦ï¼‰ã€opacityï¼ˆé€æ˜åº¦ï¼‰ã€é¢œè‰²æ˜ å°„ã€æ··åˆä¸è¿‡æ¸¡ç­‰å‚æ•°å¯å®æ—¶è°ƒæ•´ã€‚
      const { power, opacity, color1, blend1, fade1,maxBlend4 ...} = useControls("Heat Map", {})
      // é®ç½©çº¹ç†
      const maskTexture = useLoader(TextureLoader, "/logo.png")
      useEffect(() => {
        if (maskTexture) {
          maskTexture.wrapS = maskTexture.wrapT = RepeatWrapping
          maskTexture.needsUpdate = true
        }
      }, [maskTexture])
      // è§†é¢‘çº¹ç†
      useEffect(() => {
        const video = document.createElement("video")
        video.src = "/apple.mp4"
        video.loop = true
        video.playsInline = true
        video.autoplay = true
        video.preload = "auto"
        const onVideoLoad = () => {
          const texture = new VideoTexture(video)
          texture.minFilter = LinearFilter
          texture.magFilter = LinearFilter
          texture.format = RGBFormat
          setVideoTexture(texture)
        }
      }, [])
      // ç€è‰²å™¨æè´¨
      const material = useMemo(() => {
        return new ShaderMaterial({
          uniforms: {
            blendVideo: { value: 1.0 },
            drawMap: { value: drawTexture },
            textureMap: { value: videoTexture || maskTexture },
            maskMap: { value: maskTexture },
            opacity: { value: opacity },
            amount: { value: 1.0 },
            color1: { value: color1 },
            blend: { value: [blend1, blend2, blend3, blend4] },
            fade: { value: [fade1, fade2, fade3, fade4] },
            power: { value: power },
            rnd: { value: 0 },
            maxBlend: { value: [maxBlend1, maxBlend2, maxBlend3, maxBlend4] },
            heat: { value: [0, 0, 0, 1.02] },
            stretch: { value: [1, 1, 0, 0] },
          },
          vertexShader: heatVertexShader,
          fragmentShader: heatFragmentShader,
          transparent: true,
          side: DoubleSide,
        })
      }, [...])
      // åŠ¨æ€æ›´æ–°ä¸æ¸²æŸ“,é€šè¿‡ useFrame é’©å­æ¯å¸§æ›´æ–°æ—¶é—´å’Œéšæœºå€¼ï¼Œä½¿çƒ­åŠ›å›¾å‘ˆç°åŠ¨æ€å˜åŒ–
      useFrame((_, delta) => {
        timeRef.current += delta
        if (material) {
          material.uniforms.rnd.value = Math.random()
          material.uniforms.amount.value = 1.0
        }
      })
      // æ¸²æŸ“ä¸€ä¸ªå¹³é¢ç½‘æ ¼ï¼Œåº”ç”¨è‡ªå®šä¹‰ç€è‰²å™¨æè´¨ï¼Œä½œä¸ºçƒ­åŠ›å›¾çš„è½½ä½“
      return (
        <mesh>
          <planeGeometry />
          <primitive object={material} />
        </mesh>
      )
    }
    

å…¶ä¸­ `heatVertexShader` å’Œ `heatFragmentShader` æ˜¯ç€è‰²å™¨æè´¨çš„é¡¶ç‚¹ç€è‰²å™¨å’Œç‰‡å…ƒç€è‰²å™¨ï¼Œå®ƒä»¬çš„è¯¦ç»†å†…å®¹è§æ–‡ç« æœ€åçš„**ç€è‰²å™¨**æ¨¡å—ã€‚

*   é¡¶ç‚¹ç€è‰²å™¨ `heatVertexShader`ï¼šå¤„ç†ç½‘æ ¼é¡¶ç‚¹çš„ä½ç½®å˜æ¢
*   ç‰‡å…ƒç€è‰²å™¨ `heatFragmentShader`ï¼šæ ¹æ®è¾“å…¥çº¹ç†çš„åƒç´ å€¼ï¼Œç»“åˆé¢œè‰²æ˜ å°„å‚æ•°ï¼Œè®¡ç®—æ¯ä¸ªåƒç´ çš„æœ€ç»ˆé¢œè‰²ï¼Œå®ç°çƒ­åŠ›å›¾æ•ˆæœã€‚

é®ç½©çº¹ç†å›¾ç‰‡é¢„è§ˆ

### â‘£ å®ç°ç»˜åˆ¶æ¸²æŸ“å™¨ç»„ä»¶ DrawRenderer

`DrawRenderer` ç»„ä»¶çš„ä¸»è¦ä½œç”¨æ˜¯å®æ—¶å¤„ç†åŠ¨æ€ç»˜åˆ¶è¾“å…¥ï¼Œé€šè¿‡åŒ `FBO`äº¤æ›¿æ¸²æŸ“æœºåˆ¶ï¼Œé€šè¿‡ç¼“å†²å’Œè‡ªå®šä¹‰ç€è‰²å™¨å®ç°æ¸²æŸ“ç´¯ç§¯ä¸æ¸éšæ•ˆæœï¼Œå¹¶æ¥æ”¶å¤–éƒ¨è¾“å…¥çš„ç»˜åˆ¶ä½ç½®ã€æ–¹å‘ã€å¼ºåº¦ç­‰å‚æ•°ï¼Œé€šè¿‡è‡ªå®šä¹‰ç€è‰²å™¨å®æ—¶æ›´æ–°ç»˜åˆ¶çº¹ç†ï¼Œå¹¶å°†ç»“æœä¼ é€’ç»™å¤–éƒ¨ä½¿ç”¨ã€‚

    // é€šè¿‡å¼•å…¥ useFBO åˆ›å»ºå¸§ç¼“å†²å¯¹è±¡ï¼Œç”¨äºåœ¨GPUä¸Šå­˜å‚¨å’Œå¤„ç†ç»˜åˆ¶çº¹ç†ã€‚
    import { useFBO } from "@react-three/drei"
    const fboParams = {
      type: FloatType,
      format: RGBAFormat,
      minFilter: LinearFilter,
      magFilter: LinearFilter,
    }
    export const DrawRenderer = ({ size = 256, position, direction, drawAmount, onTextureUpdate, sizeDamping, fadeDamping, radiusSize }) => {
      const { size: canvasSize } = useThree()
      const dynamicRadius = radiusSize
      const fboA = useFBO(size, size, fboParams)
      const fboB = useFBO(size, size, fboParams)
      const renderTargets = useMemo(() => ({
        current: fboA,
        previous: fboB
      }), [fboA, fboB])
      const { drawScene, drawCamera, material } = useMemo(() => {
        const drawScene = new Scene()
        const drawCamera = new OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0.1, 10)
        drawCamera.position.z = 1
        // é€šè¿‡ ShaderMaterial å®šä¹‰ç»˜åˆ¶çš„æ ¸å¿ƒé€»è¾‘ï¼Œç€è‰²å™¨æ¥æ”¶å¤–éƒ¨å‚æ•°å¹¶æ›´æ–° FBO çº¹ç†
        const material = new ShaderMaterial({
          uniforms: {
            uRadius: { value: [-8, 0.9, dynamicRadius] },
            uPosition: { value: [0, 0] },
            uDirection: { value: [0, 0, 0, 0] },
            uResolution: { value: [canvasSize.width, canvasSize.height, 1] },
            uTexture: { value: renderTargets.previous.texture },
            uSizeDamping: { value: sizeDamping },
            uFadeDamping: { value: fadeDamping },
            uDraw: { value: 0 },
          },
          // å¤„ç†å¹³é¢é¡¶ç‚¹çš„åæ ‡è½¬æ¢ï¼Œç¡®ä¿ä¸ FBO çº¹ç†åæ ‡å¯¹é½
          vertexShader: drawVertexShader,
          // æ ¹æ®è¾“å…¥çš„ uPosition uRadiusç­‰å‚æ•°ï¼Œåœ¨ä¸Šä¸€å¸§çº¹ç†uTextureçš„åŸºç¡€ä¸Šç»˜åˆ¶æ–°çš„æ¸å˜ï¼Œå¹¶åº”ç”¨è¡°å‡uFadeDampingä½¿æ—§æ¸å˜æ¸æ¶ˆå¤±ï¼Œå®ç°åŠ¨æ€æµåŠ¨æ•ˆæœ
          fragmentShader: drawFragmentShader,
          depthTest: false,
          transparent: true,
        })
        // åˆ›å»ºä¸€ä¸ªå¹³é¢ç½‘æ ¼ï¼Œä½œä¸ºç»˜åˆ¶çš„ç”»å¸ƒ
        const mesh = new Mesh(new PlaneGeometry(1, 1), material)
        drawScene.add(mesh)
        return { drawScene, drawCamera, material }
      }, [renderTargets, dynamicRadius, sizeDamping, fadeDamping, canvasSize])
      // Update ç€è‰²å™¨å˜é‡å‚æ•°åŒæ­¥ï¼šé€šè¿‡ useEffect å°†å¤–éƒ¨ä¼ å…¥çš„ positionã€directionã€drawAmountç­‰å‚æ•°å®æ—¶æ›´æ–°åˆ°ç€è‰²å™¨çš„ uniforms ä¸­
      useEffect(() => {
        material.uniforms.uRadius.value[2] = dynamicRadius
        material.uniforms.uPosition.value = position
        material.uniforms.uDirection.value = direction
        material.uniforms.uDraw.value = drawAmount
      }, [material, dynamicRadius, position, direction, drawAmount])
      // å¸§å¾ªç¯ï¼šæ¯å¸§æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼šå°†ä¸Šä¸€å¸§çš„FBOçº¹ç†previousä½œä¸ºè¾“å…¥ä¼ é€’ç»™ç€è‰²å™¨ï¼›åˆ‡æ¢æ¸²æŸ“ç›®æ ‡åˆ°å½“å‰FBO currentï¼Œæ¸²æŸ“ç»˜åˆ¶åœºæ™¯ï¼›äº¤æ¢currentå’Œpreviousçš„è§’è‰²ï¼Œå‡†å¤‡ä¸‹ä¸€å¸§çš„ç´¯ç§¯ï¼›
      useFrame(({ gl }) => {
        const currentTarget = renderTargets.current
        const previousTarget = renderTargets.previous
        material.uniforms.uTexture.value = previousTarget.texture
        const originalTarget = gl.getRenderTarget()
        gl.setRenderTarget(currentTarget)
        gl.clear()
        gl.render(drawScene, drawCamera)
        gl.setRenderTarget(originalTarget)
        const temp = renderTargets.current
        renderTargets.current = renderTargets.previous
        renderTargets.previous = temp
        // é€šè¿‡ onTextureUpdateå›è°ƒï¼Œå°†å½“å‰ FBO çš„çº¹ç†ä¼ é€’ç»™å¤–éƒ¨
        onTextureUpdate(currentTarget.texture)
      })
      // ç»„ä»¶æœ¬èº«ä¸æ¸²æŸ“ä»»ä½•å¯è§å…ƒç´ ï¼Œä»…è´Ÿè´£åå°å¤„ç†ç»˜åˆ¶çº¹ç†
      return null
    }
    

#### `ğŸ’¡` å¸§ç¼“å†²å¯¹è±¡ `FBO` ä¸åŒç¼“å†²æœºåˆ¶

*   `FBO` ä½œç”¨ï¼š`FBO` æ˜¯ `GPU` ä¸Šçš„ç¦»å±æ¸²æŸ“ç›®æ ‡ï¼Œç”¨äºå­˜å‚¨ä¸­é—´ç»˜åˆ¶ç»“æœ,é¿å…ç›´æ¥æ¸²æŸ“åˆ°å±å¹•ï¼Œæé«˜æ•ˆç‡ï¼›
*   åŒç¼“å†²è®¾è®¡ï¼šåˆ›å»ºä¸¤ä¸ª `FBO`ï¼ˆ`fboA` å’Œ `fboB`ï¼‰ï¼Œé€šè¿‡ `renderTargets` ç®¡ç†å½“å‰å¸§ `current` å’Œä¸Šä¸€å¸§`previous`
*   æ¯å¸§å°†ä¸Šä¸€å¸§çš„ `FBO` çº¹ç†ä½œä¸ºè¾“å…¥ï¼Œç»˜åˆ¶æ–°å†…å®¹åˆ°å½“å‰ `FBO`ï¼Œç„¶åäº¤æ¢ä¸¤è€…çš„è§’è‰²ï¼Œå®ç°ç»˜åˆ¶æ•ˆæœçš„çƒ­åŠ›å›¾çš„æ¸éšæ•ˆæœã€‚

### â‘¤ åˆ›å»ºæ¸²æŸ“åœºæ™¯ç»„ä»¶ `Scene`

`Scene` ç»„ä»¶æ˜¯æ•´ä¸ªäº¤äº’å¯è§†åŒ–æ•ˆæœçš„æ ¸å¿ƒç»Ÿç­¹ç»„ä»¶ï¼Œå®ƒä¸»è¦å®ç°çš„åŠŸèƒ½åŒ…æ‹¬ï¼šæ•´åˆé¼ æ ‡äº¤äº’ã€å‚æ•°æ§åˆ¶ã€ç»˜åˆ¶æ¸²æŸ“`DrawRenderer` ä¸çƒ­åŠ›å›¾æ¸²æŸ“ `HeatMesh`ï¼Œå®ç°é¼ æ ‡ `hover` æˆ–è€… `ç§»åŠ¨`æ—¶ç”ŸæˆåŠ¨æ€çƒ­åŠ›å›¾ã€‚æœ€ç»ˆå®ç°çš„æ•ˆæœæ˜¯ï¼šç”¨æˆ·åœ¨ç”»å¸ƒä¸Šç§»åŠ¨é¼ æ ‡ï¼Œé¼ æ ‡è½¨è¿¹ä¼šå®æ—¶ç”Ÿæˆå¸¦æœ‰çƒ­åŠ›æ¸å˜çš„åŠ¨æ€æ•ˆæœï¼Œä¸”æ•ˆæœå¯é€šè¿‡ `Leva` é¢æ¿å‚æ•°å¯ä»¥å®æ—¶è°ƒæ•´ã€‚

    import { DrawRenderer } from "./DrawRenderer"
    import { HeatMesh } from "./HeatMesh"
    
    export const Scene = ({ containerRef, }: { containerRef: React.RefObject<HTMLDivElement | null> }) => {
      const [mouse, setMouse] = useState<[number, number]>([0, 0])
      const [heatAmount, setHeatAmount] = useState(0)
      const [drawTexture, setDrawTexture] = useState<Texture | null>(null)
      const heatRef = useRef(0)
      const lastMousePos = useRef<[number, number]>([0, 0])
      const lastTime = useRef(performance.now())
      const holdRef = useRef(false)
      const { camera, size } = useThree((state) => ({ camera: state.camera, size: state.size }))
      // Leva æ§åˆ¶å‚æ•°å¢åŠ 
      const { sizeDamping, fadeDamping, heatSensitivity, heatDecay, radiusSize } = useControls("Hover Heat",{
          // æ§åˆ¶ç²—ç»†çš„å˜åŒ–å¹³æ»‘åº¦
          sizeDamping: { value: 0.8, min: 0.0, max: 1.0, step: 0.01 },
          // æ§åˆ¶æ¶ˆå¤±çš„é€Ÿåº¦
          fadeDamping: { value: 0.98, min: 0.9, max: 1.0, step: 0.001 },
          // é¼ æ ‡ç§»åŠ¨æ—¶çƒ­åº¦ç´¯ç§¯çš„å¿«æ…¢
          heatSensitivity: { value: 0.25, min: 0.1, max: 2.0, step: 0.05 },
          // é¼ æ ‡åœæ­¢åçƒ­åº¦ä¸‹é™çš„å¿«æ…¢
          heatDecay: { value: 0.92, min: 0.8, max: 0.99, step: 0.01 },
          // æ§åˆ¶å•æ¬¡ç»˜åˆ¶çš„èŒƒå›´å¤§å°
          radiusSize: { value: 75, min: 20, max: 300, step: 5 },
        }
      )
      // æ ¹æ®ç”»å¸ƒå°ºå¯¸è®¡ç®—ç›¸æœºçš„å®½é«˜æ¯”ï¼ŒåŠ¨æ€è®¾ç½® ç­‰å‚æ•°ï¼›ç¡®ä¿ç›¸æœºçš„æŠ•å½±çŸ©é˜µå®æ—¶æ›´æ–°
      useEffect(() => {
        if (camera && camera instanceof OrthographicCamera) {
          const aspect = size.width / size.height
          let width, height
          if (aspect >= 1) {
            height = 1
            width = aspect
          } else {
            width = 1
            height = 1 / aspect
          }
          camera.left = -width / 2
          camera.right = width / 2
          camera.top = height / 2
          camera.bottom = -height / 2
          camera.near = -1
          camera.far = 1
          camera.updateProjectionMatrix()
        }
      }, [camera, size])
      // é€šè¿‡pointermove/pointerleaveäº‹ä»¶ç›‘å¬é¼ æ ‡åœ¨å®¹å™¨å†…çš„ä½ç½®ï¼Œè®¡ç®—é¼ æ ‡ç›¸å¯¹äºå®¹å™¨çš„å½’ä¸€åŒ–åæ ‡
      const handleDOMPointerMove = useCallback(
        (e: PointerEvent) => {
          if (containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect()
            const clientX = e.clientX - rect.x
            const clientY = e.clientY - rect.y
            const normalizedX = clientX / rect.width
            const normalizedY = clientY / rect.height
            const x = 2 * (normalizedX - 0.5)
            const y = 2 * -(normalizedY - 0.5)
            holdRef.current = true
            setMouse([x, y])
            lastMousePos.current = [x, y]
            lastTime.current = performance.now()
          }
        },
        [containerRef]
      )
      const handleDOMPointerLeave = useCallback(() => {
        holdRef.current = false
      }, [])
      // é¼ æ ‡äº‹ä»¶ç›‘å¬
      useEffect(() => {
        const canvas = containerRef.current
        if (!canvas) return
        canvas.addEventListener("pointermove", handleDOMPointerMove)
        canvas.addEventListener("pointerleave", handleDOMPointerLeave)
        return () => {
          canvas.removeEventListener("pointermove", handleDOMPointerMove)
          canvas.removeEventListener("pointerleave", handleDOMPointerLeave)
        }
      }, [handleDOMPointerMove, handleDOMPointerLeave, containerRef])
      useFrame((_, delta) => {
        // çƒ­åº¦ç´¯ç§¯ï¼šå½“é¼ æ ‡åœ¨å®¹å™¨å†…ç§»åŠ¨holdRef.current = trueæ—¶ï¼Œæ ¹æ®heatSensitivityå’Œå¸§é—´éš”deltaè®¡ç®—çƒ­åº¦å¢é‡ï¼ŒheatRef.currentæŒç»­ç´¯ç§¯æœ€å¤§é™åˆ¶ä¸º1.3ï¼Œé¿å…å¼ºåº¦æº¢å‡º
        if (holdRef.current) {
          const heatIncrease = heatSensitivity * delta * 60
          heatRef.current += heatIncrease
          heatRef.current = Math.min(1.3, heatRef.current)
          setHeatAmount(heatRef.current)
        // çƒ­åº¦è¡°å‡ï¼šå½“é¼ æ ‡ç¦»å¼€å®¹å™¨pointerleaveæˆ–åœæ­¢ç§»åŠ¨æ—¶ï¼Œçƒ­åº¦å€¼æŒ‰ heatDecayè¡°å‡ç³»æ•°é€æ­¥é™ä½ï¼Œç›´åˆ°ä½äº0.001æ—¶æ¸…é›¶ï¼›
        } else if (heatRef.current > 0) {
          heatRef.current *= heatDecay
          heatRef.current = heatRef.current < 0.001 ? 0 : heatRef.current
          setHeatAmount(heatRef.current)
        }
        // å»¶è¿Ÿé‡ç½®ï¼šé¼ æ ‡åœæ­¢ç§»åŠ¨åï¼Œé€šè¿‡50mså»¶è¿Ÿå°† holdRefè®¾ä¸ºfalseï¼Œé¿å…å› çŸ­æš‚åœé¡¿å¯¼è‡´çƒ­åº¦çªç„¶ä¸­æ–­ï¼Œæ¨¡æ‹Ÿè‡ªç„¶æ®‹ç•™æ„Ÿ
        if (holdRef.current) {
          setTimeout(() => {
            holdRef.current = false
          }, 50)
        }
      })
      const direction = useMemo<[number, number, number, number]>(() => {
        return [0, 0, 0, 100]
      }, [])
      const drawPosition = useMemo<[number, number]>(() => {
        const x = 0.5 * mouse[0] + 0.5
        const y = 0.5 * mouse[1] + 0.5
        return [x, y]
      }, [mouse])
      // å‘ DrawRenderer ä¼ é€’ç»˜åˆ¶æ•°æ®ï¼Œæ¥æ”¶ç»˜åˆ¶ç»“æœå¹¶ä¼ é€’ç»™ HeatMesh
      return (
        <>
          <DrawRenderer
            size={256}
            position={drawPosition}
            direction={direction}
            drawAmount={heatAmount}
            onTextureUpdate={setDrawTexture}
            sizeDamping={sizeDamping}
            fadeDamping={fadeDamping}
            radiusSize={radiusSize}
          />
          <HeatMesh drawTexture={drawTexture} />
        </>
      )
    }
    

é€šè¿‡ `Leva` æ§åˆ¶é¢æ¿åŠ¨æ€è°ƒèŠ‚ç€è‰²å™¨å‚æ•°ã€‚

### â‘¥ è‡ªå®šä¹‰é¢œè‰²åŠŸèƒ½å®ç°

å¯ä»¥é€šè¿‡å¦‚ä¸‹çš„æ–¹æ³•ï¼Œç”Ÿæˆéšæœºè‰²å½©å¹¶å°†ç”Ÿæˆçš„å‚æ•°ä¼ é€’åˆ°ç€è‰²å™¨ï¼Œå¯ä»¥å®ç°çƒ­åŠ›å›¾ `logo` é¢œè‰²çš„åŠ¨æ€åˆ‡æ¢ã€‚

    const randomizeColors = useCallback(() => {
      const hslToHex = (h: number, s: number, l: number) => {
        s /= 100
        l /= 100
        const k = (n: number) => (n + h / 30) % 12
        const a = s * Math.min(l, 1 - l)
        const f = (n: number) => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)))
        const toHex = (x: number) => Math.round(255 * x).toString(16).padStart(2, "0")
        return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))}`
      }
      // ç”Ÿæˆ6ç§éšæœºé¢œè‰² color2..color7ï¼Œcolor1ä¿æŒé»‘è‰²
      const base = Math.floor(Math.random() * 360)
      const steps = [15, 35, 55, 85, 140, 200]
      const palette = steps.map((step, i) => hslToHex((base + step) % 360, 80 - i * 4, 50 + (i - 3) * 3))
      const keys = ["color2", "color3", "color4", "color5", "color6", "color7"] as const
      keys.forEach((key, i) => {
        levaStore.setValueAtPath(`Heat Map.${key}`, palette[i], false)
      })
    }, [])
    

### â‘¦ ç€è‰²å™¨

#### `ğŸ“¦` draw.frag

    precision highp float;
    uniform float uDraw;
    uniform vec3 uRadius;
    uniform vec3 uResolution;
    uniform vec2 uPosition;
    uniform vec4 uDirection;
    uniform float uSizeDamping;
    uniform float uFadeDamping;
    uniform sampler2D uTexture;
    varying vec2 vUv;
    
    void main() {
      float aspect = uResolution.x / uResolution.y;
      vec2 pos = uPosition;
      pos.y /= aspect;
      vec2 uv = vUv;
      uv.y /= aspect;
      float dist = distance(pos, uv) / (uRadius.z / uResolution.x);
      dist = smoothstep(uRadius.x, uRadius.y, dist);
      vec3 dir = uDirection.xyz * uDirection.w;
      vec2 offset = vec2((-dir.x) * (1.0-dist), (dir.y) * (1.0-dist));
      vec2 uvt = vUv;
      vec4 color = texture2D(uTexture, uvt + (offset * 0.01));
      color *= uFadeDamping;
      color.r += offset.x;
      color.g += offset.y;
      color.rg = clamp(color.rg, -1.0, 1.0);
      float d = uDraw;
      color.b += d * (1.0-dist);
      gl_FragColor = vec4(color.rgb, 1.0);
    }
    

#### `ğŸ“¦` heat.frag

    precision highp isampler2D;
    precision highp usampler2D;
    uniform sampler2D drawMap;
    uniform sampler2D textureMap;
    uniform sampler2D maskMap;
    uniform float amount;
    uniform float opacity;
    uniform vec3 color1;
    uniform vec3 color2;
    uniform vec3 color3;
    uniform vec3 color4;
    uniform vec3 color5;
    uniform vec3 color6;
    uniform vec3 color7;
    uniform vec4 blend;
    uniform vec4 fade;
    uniform vec4 maxBlend;
    uniform float power;
    varying vec2 vUv;
    varying vec4 vClipPosition;
    vec3 linearRgbToLuminance(vec3 linearRgb){
      float finalColor = dot(linearRgb, vec3(0.2126729, 0.7151522, 0.0721750));
      return vec3(finalColor);
    }
    vec3 saturation(vec3 color, float saturation){
      return mix(linearRgbToLuminance(color), color, saturation);
    }
    vec3 gradient(float t) {
      float p1 = blend.x;
      float p2 = blend.y;
      float p3 = blend.z;
      float p4 = blend.w;
      float p5 = maxBlend.x;
      float p6 = maxBlend.y;
      float f1 = fade.x;
      float f2 = fade.y;
      float f3 = fade.z;
      float f4 = fade.w;
      float f5 = maxBlend.z;
      float f6 = maxBlend.w;
      float blend1 = smoothstep(p1 - f1 * 0.5, p1 + f1 * 0.5, t);
      float blend2 = smoothstep(p2 - f2 * 0.5, p2 + f2 * 0.5, t);
      float blend3 = smoothstep(p3 - f3 * 0.5, p3 + f3 * 0.5, t);
      float blend4 = smoothstep(p4 - f4 * 0.5, p4 + f4 * 0.5, t);
      float blend5 = smoothstep(p5 - f5 * 0.5, p5 + f5 * 0.5, t);
      float blend6 = smoothstep(p6 - f6 * 0.5, p6 + f6 * 0.5, t);
      vec3 color = color1;
      color = mix(color, color2, blend1);
      color = mix(color, color3, blend2);
      color = mix(color, color4, blend3);
      color = mix(color, color5, blend4);
      color = mix(color, color6, blend5);
      color = mix(color, color7, blend6);
      return color;
    }
    void main() {
      vec2 duv = vClipPosition.xy/vClipPosition.w;
      duv = 0.5 + duv * 0.5;
      vec2 uv = vUv;
      uv -= 0.5;
      uv += 0.5;
      float o = clamp(opacity, 0.0, 1.0);
      float a = clamp(amount, 0.0, 1.0);
      float v = o * a;
      vec4 tex = texture2D(maskMap, uv);
      float mask = tex.g;
      float logo = smoothstep(0.58, 0.6, 1.0-tex.b);
      vec2 wuv = uv;
      vec3 draw = texture2D(drawMap, duv).rgb;
      float heatDraw = draw.b;
      heatDraw *= mix(0.1, 1.0, mask);
      vec2 offset2 = draw.rg * 0.01;
      vec3 video = textureLod(textureMap, wuv + offset2, 0.0).rgb;
      float h = mix(pow(1.0-video.r, 1.5), 1.0, 0.2) * 1.25;
      heatDraw *= h;
      float map = video.r;
      map = pow(map, power);
      float msk = smoothstep(0.2, 0.5, uv.y);
      map = mix( map * 0.91, map, msk);
      map = mix(0.0, map, v);
      float fade2 = distance(vUv, vec2(0.5, 0.52));
      fade2 = smoothstep(0.5, 0.62, 1.0-fade2);
      vec3 finalColor = gradient(map + heatDraw);
      finalColor = saturation(finalColor, 1.3);
      finalColor *= fade2;
      finalColor = mix(vec3(0.0), finalColor, a);
      gl_FragColor = vec4(finalColor, 1.0);
    }
    

æ€»ç»“
--

`ğŸ“Œ` æœ¬é¡¹ç›®ä»£ç ä¸»è¦ç”± `4` ä¸ªæ ¸å¿ƒç»„ä»¶æ„æˆï¼Œå…¶ä¸­ï¼š

*   **HeatmapScene**ï¼šæ˜¯å…¨å±€å®¹å™¨ï¼Œä½œä¸ºé¡¶å±‚ç»„ä»¶ï¼Œç®¡ç† `Three.js` ã€Leva æ§åˆ¶é¢æ¿å’Œå…¶ä»–é¡µé¢ä¿¡æ¯ï¼›é€šè¿‡ `levaStore` å…¨å±€ç®¡ç†çƒ­åŠ›å›¾é¢œè‰²å‚æ•°ï¼Œä¼ é€’å®¹å™¨å¼•ç”¨ç»™å­ç»„ä»¶ã€‚
*   **Scene**ï¼šäº¤äº’ä¸ç»Ÿç­¹ï¼Œå¤„ç†é¼ æ ‡äº¤äº’ï¼Œè®¡ç®—çƒ­åº¦å€¼ï¼Œæ¨¡æ‹Ÿé¼ æ ‡è½¨è¿¹çš„ç´¯ç§¯ä¸è¡°å‡ï¼Œä¸²è” `DrawRenderer` å’Œ `HeatMesh`ï¼Œä¼ é€’äº¤äº’å‚æ•°ã€‚
*   **DrawRenderer**ï¼šç»˜åˆ¶å¤„ç†ï¼Œä½¿ç”¨åŒå¸§ç¼“å†² `FBO` å®ç°ç¦»å±ç»˜åˆ¶ï¼Œé«˜æ•ˆç´¯ç§¯é¼ æ ‡è½¨è¿¹ï¼Œé€šè¿‡è‡ªå®šä¹‰ç€è‰²å™¨å¤„ç†è½¨è¿¹çš„ç»˜åˆ¶ã€æ¸éšä¸è¡°å‡ï¼Œè¾“å‡ºå¤„ç†åçš„ç»˜åˆ¶çº¹ç† `drawTexture` ç»™ `HeatMesh`ã€‚
*   **HeatMesh**ï¼šçƒ­åŠ›å›¾æ¸²æŸ“ï¼ŒåŸºäº `DrawRenderer`è¾“å‡ºçš„çº¹ç†ï¼Œç»“åˆè§†é¢‘çº¹ç†å’Œé®ç½©çº¹ç†ï¼Œé€šè¿‡è‡ªå®šä¹‰ç€è‰²å™¨ç”Ÿæˆçƒ­åŠ›å›¾æ•ˆæœã€‚

`ğŸ“Œ` æœ¬æ–‡ä¸­ä¸»è¦åŒ…å«çš„æ–°çŸ¥è¯†ç‚¹å¦‚ä¸‹ï¼š

*   `Three.js` ç¦»å±æ¸²æŸ“æŠ€æœ¯ `FBO`ï¼šé€šè¿‡ `useFBO` åˆ›å»ºå¸§ç¼“å†²å¯¹è±¡ï¼Œå®ç° `GPU` å±‚é¢çš„ç¦»å±ç»˜åˆ¶ï¼Œé¿å…ç›´æ¥æ“ä½œ `DOM` æå‡æ€§èƒ½ï¼›åŒç¼“å†²æœºåˆ¶ `fboA/fboB` äº¤æ›¿æ¸²æŸ“å®ç°ç»˜åˆ¶è½¨è¿¹çš„ç´¯ç§¯ä¸åŠ¨æ€æ›´æ–°ã€‚
*   `äº¤äº’äº‹ä»¶ä¸åŠ¨æ€å‚æ•°æ§åˆ¶`ï¼šé¼ æ ‡é”®ç›˜äº‹ä»¶ç›‘å¬ï¼šå°†ç”¨æˆ·è¾“å…¥è½¬æ¢ä¸ºå¯é‡åŒ–çš„å‚æ•°ã€‚
*   `Leva` æ§åˆ¶é¢æ¿ï¼šé€šè¿‡ `useControls` å®æ—¶è°ƒæ•´è§†è§‰å‚æ•°ï¼Œæå‡å¼€å‘çµæ´»æ€§ã€‚
*   è§†é¢‘çº¹ç†ã€é®ç½©çº¹ç†ã€ç€è‰²å™¨æè´¨çš„ä½¿ç”¨ç­‰ã€‚

> æƒ³äº†è§£å…¶ä»–å‰ç«¯çŸ¥è¯†æˆ–å…¶ä»–æœªåœ¨æœ¬æ–‡ä¸­è¯¦ç»†æè¿°çš„**Web 3D**å¼€å‘æŠ€æœ¯ç›¸å…³çŸ¥è¯†ï¼Œå¯é˜…è¯»æˆ‘å¾€æœŸçš„æ–‡ç« ã€‚å¦‚æœæœ‰ç–‘é—®å¯ä»¥åœ¨è¯„è®ºä¸­**ç•™è¨€**ï¼Œå¦‚æœè§‰å¾—æ–‡ç« å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦å¿˜äº†**ä¸€é”®ä¸‰è¿å“¦ ğŸ‘**ã€‚

é™„å½•
--

*   \[1\]. [ğŸŒ´ Three.js æ‰“é€ ç¼¤çº·å¤æ—¥3Dæ¢¦ä¸­æƒ…å²›](https://juejin.cn/post/7102215670477094925)
*   \[2\]. [ğŸ”¥ Three.js å®ç°ç‚«é…·çš„èµ›åšæœ‹å…‹é£æ ¼3Dæ•°å­—åœ°çƒå¤§å±](https://juejin.cn/post/7124116814937718797)
*   \[3\]. [ğŸ¼ Three.js å®ç°2022å†¬å¥¥ä¸»é¢˜3Dè¶£å‘³é¡µé¢ï¼Œå«å†°å¢©å¢©](https://juejin.cn/post/7060292943608807460)
*   \[4\]. [ğŸ¦Š Three.js å®ç°3Då¼€æ”¾ä¸–ç•Œå°æ¸¸æˆï¼šé˜¿ç‹¸çš„å¤šå…ƒå®‡å®™](https://juejin.cn/post/7081429595689320478)
*   \[5\]. [ğŸ¡ Three.js è¿›é˜¶ä¹‹æ—…ï¼šå…¨æ™¯æ¼«æ¸¸-é«˜é˜¶ç‰ˆåœ¨çº¿çœ‹æˆ¿](https://juejin.cn/post/7220075270664634428)
*   `...`
*   [ã€Three.js è¿›é˜¶ä¹‹æ—…ã€‘ç³»åˆ—ä¸“æ è®¿é—® ğŸ‘ˆ](https://juejin.cn/column/7140122697622618119)
*   [æ›´å¤šå¾€æœŸã€3Dã€‘ä¸“æ è®¿é—® ğŸ‘ˆ](https://juejin.cn/column/7049923956257587213)
*   [æ›´å¤šå¾€æœŸã€å‰ç«¯ã€‘ä¸“æ è®¿é—® ğŸ‘ˆ](https://juejin.cn/column/7021076460089638926)

å‚è€ƒ
--

*   \[1\]. [https://github.com/vladmdgolam/apple-event-2025](https://github.com/vladmdgolam/apple-event-2025)
*   \[2\]. [https://www.apple.com/apple-events/](https://www.apple.com/apple-events/)

> æœ¬æ–‡åœ°å€ï¼š[https://www.cnblogs.com/dragonir/p/19151231](https://www.cnblogs.com/dragonir/p/19151231) æœ¬æ–‡ä½œè€…ï¼šdragonir