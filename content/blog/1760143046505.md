---
layout: post
title: '软件加壳和脱壳的基础原理'
date: "2025-10-11T00:37:26Z"
---
软件加壳和脱壳的基础原理

目录

*   [加壳原理](#加壳原理)
*   [脱壳原理](#脱壳原理)
*   [对抗与演进](#对抗与演进)

* * *

> 加壳和脱壳在安全领域非常常见，但原理是什么？

软件加壳、脱壳是两种不同的技术手段，也是两类人通过这个技术进行对抗的战场，加壳是程序开发者所考虑的，用来保护他的程序。脱壳是攻击者所考虑的，用来窃取程序里面的信息（或改变程序原来功能...）。不管是加壳还是脱壳都挺专业（直白点：麻烦且复杂），下文只从宏观的视角来理解其中的运行原理即可，只是科普了解。

复杂是因为，不同的系统在加载程序的流程不同，且流程链条环节非常长。

* * *

加壳原理
====

“壳”的具象理解就类似花生壳，用来保护里面的花生仁。人想吃到里面果实，就需要将其剥掉。

软件也存在这样类似的东西，这种东西我们也称之为“壳”，两者的目标都是一样的，都是用来保护，而“壳”用来保护**可执行程序资源**，避免被其他人窥探。

无论哪种原理都是大致是相同的。我们给自身软件加壳后，就会产生出一个新程序，新程序是由**壳**和**原程序**两部分组成。

系统在执行这个新程序的时候，先执行壳，由壳对原程序进行解密并还原到内存中去，接着在执行原来的程序。

由此，了解的壳的定义：  
新程序（已加壳） = 壳程序 + 加壳流程 + 原程序

壳根据加密和非加密的技术手段来作分类，一般分为两类：

*   压缩壳（非加密）
*   加密壳

![image](https://img2024.cnblogs.com/blog/1552062/202510/1552062-20251010133708630-266611934.png)

**开发人员对原程序加壳的工作流程（加壳原理）：**

1.  压缩/加密：对原始程序的代码段、数据段等关键部分进行压缩或加密，使其变成一堆“乱码”。
    
2.  植入外壳：生成一个外壳程序，并将加密/压缩后的原始程序数据作为一部分附加在这个外壳程序后面。
    
3.  修改入口点：修改生成的可执行文件的“程序入口点”（OEP, Original Entry Point），使其指向外壳程序的代码，而不是原始程序的代码。
    

**加壳后的程序，在系统里的执行流程：**

1.  用户双击加壳后的程序。
    
2.  操作系统加载器将程序读入内存。此时，内存中的代码是外壳的代码，原始程序部分仍是加密/压缩状态。
    
3.  CPU 开始执行外壳代码。
    
4.  外壳程序开始工作：
    
    *   检查自身是否被调试。
    *   **解密** 或 **解压缩** 内存中的原始程序数据。
    *   进行必要的环境修复（如重建导入表）。
5.  外壳程序将 CPU 的执行流跳转到原始程序的真正入口点（OEP）。
    
6.  至此，原始程序开始正常运行，和执行原程序一样效果。
    

* * *

脱壳原理
====

理解了加壳后，脱壳就很好理解了，就是逆回来操作一次。

**什么是脱壳？**  
摘掉壳程序，将加密/压缩后可执行文件还原出来。

**脱壳的基本原理：**  
脱壳的核心思想是 “内存转储”。**因为无论外壳多么复杂（加密多完好），它最终都必须在内存中将原始程序完整地、可执行地还原出来。** 脱壳就是要抓住这个瞬间。

**脱壳的方法：**  
![image](https://img2024.cnblogs.com/blog/1552062/202510/1552062-20251010133730105-736974973.png)

* * *

对抗与演进
=====

加壳与脱壳就像是一场永无休止的“**军备竞赛**”。

壳的进化：出现了 VMProtect, Themida 等“强壳”。它们使用虚拟机保护技术，将原始代码翻译成自定义的指令集，极大地增加了分析和脱壳的难度。

脱壳技术的进化：出现了自动脱壳机、脚本、以及更高级的动态和静态分析技术，专门研究VMProtect, Themida 等虚拟机保护技术的人员。