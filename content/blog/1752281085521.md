---
layout: post
title: 'Rust修仙之道 第十二章：宽度境 · 类型尺寸认知与不定形之术'
date: "2025-07-12T00:44:45Z"
---
Rust修仙之道 第十二章：宽度境 · 类型尺寸认知与不定形之术
================================

第十二章：宽度境 · 类型尺寸认知与不定形之术
-----------------------

> _“形有大小，道有边界。不能测其尺者，不可轻控其灵。”_

当顾行云修炼 Trait 技法至高阶，试图为“无定形灵体”设下术式时，Rust 编译灵印忽然警告：

> “此灵不可确定尺寸：未满足 `Sized` 契约。”

他惊觉自己踏入了 Rust 类型系统的**边界之门**。

### 一、`Sized` 灵印：能否知其尺寸

Rust 编译术默认：

*   所有术体类型都需满足 `Sized` 约定；
    
*   即：**类型大小在编译时可知，堆栈空间可定。**
    

基础类型如 `i32`, `struct`, `enum` 都是 `Sized`；  
而“接口灵体”如 `dyn Trait` 或 `[T]` 由于大小未知，默认 **非** `Sized`。

### 二、`?Sized`：宽容印·允许未定形灵体

顾行云阅读灵术古卷，发现可使用 `?Sized` 解除默认 `Sized` 限制：

    fn log_info<T: ?Sized>(item: &T) {
        // 可接受 T 为 [str], [u8], dyn Trait 等非定长灵体
    }
    

他首次领悟：`?Sized` **并非要你接受“不规则”，而是提醒你“不要做无法保证的事”。**

示例：

    struct BoxedInfo<T: ?Sized> {
        value: Box<T>,
    }
    

> 他成功构建可容纳“任意形状灵气”的容器！

### 三、动态大小类型（DST）示例

类型

`Sized`?

备注

`str`

❌

必须通过引用或 `Box<str>` 使用

`[T]`

❌

切片，如 `[i32]`，需用 `&[T]` 或 `Box<[T]>` 包装

`dyn Trait`

❌

Trait 对象，用于运行时多态

顾行云感悟：“无定形灵体并非不可控，而是需用封印器器皿辅助承载。”

### 四、裸指术（`*const T` / `*mut T`）：禁术之边

修炼至此，他误入“原生指针殿”，看见一行禁术铭文：

    let p: *const i32 = &10 as *const i32;
    

他意识到这是超越 Borrow Checker 审核的灵指术，需手动保障：

*   无借用检查！
    
*   可发生悬挂、错误访问、甚至灵链崩塌！
    

于是他铭记于心：**“裸指慎用，除非跨界。”**

### 心诀 · 尺寸之道

> _有形可测者，皆可控；无形需封者，慎托之；知其大小，乃入混元之门。_

* * *

⬅️ [上一章](https://www.cnblogs.com/niceWk/p/18978194)　　　　　　　　　　　　[下一章➡️](https://www.cnblogs.com/niceWk/p/18980134)
-----------------------------------------------------------------------------------------------------------------