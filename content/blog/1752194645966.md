---
layout: post
title: 'Rust 修仙之道 第十章 链灵境 · 构筑灵链之道'
date: "2025-07-11T00:44:05Z"
---
Rust 修仙之道 第十章 链灵境 · 构筑灵链之道
==========================

第十章：链灵境 · 构筑灵链之道
----------------

> _“灵链相接如脉络，错一节则断万法；唯指向明晰、层次分明者，方可汇聚长流。”_

顾行云接下了云隐派的一道秘术任务：**重塑断裂的灵气传输通道**。此通道呈现“链式结构”，每一灵节点连接前后，疏通即通达，紊乱则全线崩塌。

他意识到，这正是典型的数据结构——**链表（Linked List）**。

### 一、术式构型：节点即灵阶

他首先构建基础灵节结构：

    use std::boxed::Box;
    
    enum List {
        Node(i32, Box<List>),
        Nil,
    }
    

解析：

*   `Node(i32, Box<List>)`：存储灵气数值与“下一节点”的链接；
    
*   `Nil`：链尾终止之符，相当于“空灵”。
    

> “为何要用 `Box`？”——他悟出：因链表为**递归结构**，需堆上分配，`Box` 使其大小在编译期可定！

### 二、创建灵链：施术连接节点

    use List::{Node, Nil};
    
    let chain = Node(10,
        Box::new(Node(20,
            Box::new(Node(30, Box::new(Nil)))
        ))
    );
    

这便构造出一个三节灵链：10 → 20 → 30 → 终止

### 三、遍历术：逐步引灵

    fn traverse(list: &List) {
        match list {
            Node(val, next) => {
                println!("灵节：{}", val);
                traverse(next);
            }
            Nil => println!("灵链终止 🧘"),
        }
    }
    

他以递归调用唤醒每一节点，确保灵气贯通。掌中法印如链，光流不绝。

### 四、进阶挑战：灵链增删变动（需可变性）

他随后挑战“动态修改灵链”——这要求他引入更高级的控制工具如：

*   `Rc<T>`：共享所有权；
    
*   `RefCell<T>`：运行时可变借用。
    

示例：

    use std::rc::Rc;
    use std::cell::RefCell;
    
    enum Chain {
        Node(i32, Rc<RefCell<Chain>>),
        Nil,
    }
    

这样他即可在灵链中共享控制节点，并在运行中“热更新”其流向。

> “灵链虽深，控制权不可分散；结构虽绕，思路须直。”

### 心法口诀 · 链灵之理

> _节节可动，指指不乱；知其前后，控其流向；不必强索所有权，只需掌控传承。_

* * *

⬅️ [上一章](https://www.cnblogs.com/niceWk/p/18976128)　　　　　　　　　　　　[下一章➡️](https://www.cnblogs.com/niceWk/p/18978194)
-----------------------------------------------------------------------------------------------------------------