---
layout: post
title: '什么是流密码？'
date: "2025-04-29T00:40:19Z"
---
什么是流密码？

目录

*   [流密码的定义](#流密码的定义)
*   [流密码的原理](#流密码的原理)
*   [为什么需要一次一密？](#为什么需要一次一密)
*   [流密码如何防止恢复密钥流？](#流密码如何防止恢复密钥流)
*   [RC4算法的简介](#rc4算法的简介)
    *   [**S盒是什么？**](#s盒是什么)
    *   [**取模介绍**](#取模介绍)
    *   [**加密、解密**](#加密解密)
    *   [**复用库的RC4用法**](#复用库的rc4用法)
    *   [**总结**](#总结)
*   [Reference](#reference)

* * *

流密码的定义
======

流密码是一种对称密钥加密算法，它将明文消息按字符或比特逐位进行加密。加密方式基于异或的加密算法。

流密码的原理
======

首先，通信双方需要协商并确定一个共享的密钥。这个密钥是保密的，只有通信双方知道。同时，可能还会选择一个初始化向量，它通常是公开的，但要保证每次加密时使用的初始化向量不同，以增加密码的安全性。

将明文消息与密钥流进行逐位的异或运算，得到密文。由于密钥流是伪随机的，且与明文消息长度相同，所以对于每一位明文，加密时都使用了不同的密钥流位，从而增加了密码的安全性。

![image](https://img2024.cnblogs.com/blog/1552062/202504/1552062-20250424180215910-389445293.png)

将明文消息逐位与生成的密钥流进行异或运算。例如，对于明文比特流P = p1p2p3...pn和密钥流K = k1k2k3...kn，密文C = c1c2c3...cn，其中ci = pi ⊕ ki（⊕表示异或运算）。这样，每一位明文都与对应的密钥流位进行异或，得到密文。

加密流程如下图所示：  
![image](https://img2024.cnblogs.com/blog/1552062/202504/1552062-20250424180236250-1239228807.png)

* * *

为什么需要一次一密？
==========

流密码常见的问题如果多次使用相同秘钥进行加密，攻击者可以不使用密码也可以获得密文。

流密码如何防止恢复密钥流？
=============

流密码的安全性依赖于密钥流的随机性和不可预测性。如果密钥流能够被攻击者预测或分析出来，那么密文就很容易被破解。

* * *

RC4算法的简介
========

RC4 算法是一种流密码算法，是一种可变密钥长度的流密码，它的密钥长度可以在 1 到 256 字节之间变化。

加密流程用文字说明太绕，直接跟着调试器看代码吧！  
**CODE:**

    def crypt(data, key):  # data为明文或密文，key为密钥
        """RC4 algorithm"""
        x = 0
        # box = range(256)   #初始化S盒
        box = list(range(256))  # 使用 list(range(256)) 创建可修改的列表
        for i in range(256):
            x = (x + box[i] + ord(key[i % len(key)])) % 256
            box[i], box[x] = box[x], box[i]
        x = y = 0
        out = []
        for char in data:
            x = (x + 1) % 256
            y = (y + box[x]) % 256
            box[x], box[y] = box[y], box[x]
            out.append(chr(ord(char) ^ box[(box[x] + box[y]) % 256]))
            # 对称密码，加密解密算法一样
        return ''.join(out)
    
    # 加密
    encrypted_str = crypt("Hello", "123")  # 假设返回字符串
    encrypted_bytes = encrypted_str.encode("latin-1")  # 转字节（确保无损）
    hex_result = encrypted_bytes.hex()  #转16进制 .hex()
    print("加密结果:", hex_result)
    
    # 解密
    decrypted = crypt(bytes.fromhex(hex_result).decode("latin-1"), "123")
    print("解密结果:", decrypted)
    
    

**S盒是什么？**
----------

在 RC4 算法中，S 盒是一个长度为 256 的字节数组，用于存储和操作加密过程中的数据。

**作用：**

*   **打乱数据顺序**：S 盒的主要作用是通过特定的初始化过程，将其内部的元素顺序打乱。这个打乱过程基于密钥进行，使得 S 盒的状态与密钥相关联。这样，不同的密钥会导致 S 盒具有不同的初始状态，从而为加密提供了不同的 “混淆” 方式，增加了密码的安全性。
    
*   **生成密钥流**：在密钥流生成阶段，通过对 S 盒的操作来生成伪随机的密钥流字节。算法根据特定的规则对 S 盒进行索引和元素交换，然后根据 S 盒的状态计算出密钥流字节。由于 S 盒的状态是由密钥决定的，所以生成的密钥流也与密钥紧密相关，并且具有一定的随机性和不可预测性。
    
*   **纯线性操作易被破解**（如线性密码分析），**非线性变换（如 S 盒）可增加复杂度**。
    

**初始化代码**：

        for i in range(256):
            x = (x + box[i] + ord(key[i % len(key)])) % 256
            box[i], box[x] = box[x], box[i]
    

初始化的S盒：  
![image](https://img2024.cnblogs.com/blog/1552062/202504/1552062-20250428155535537-1961684889.png)

规律：基于秘钥生成，同一个秘钥所生成的S盒都是一样的。

**取模介绍**
--------

取模运算，也叫取余运算，其原理是在整数除法中，被除数不能被除数整除时，就会产生余数，这个余数就是取模运算的结果。

被除数 小于 除数时，余数是被除数。

代码: `x = (x + box[i] + ord(key[i % len(key)])) % 256` 中，`% 256` 是 取模运算，它的核心目的是确保计算结果 x 的值始终落在 0 到 255 的范围内。

**加密、解密**
---------

![image](https://img2024.cnblogs.com/blog/1552062/202504/1552062-20250428162233595-1234391662.png)

![image](https://img2024.cnblogs.com/blog/1552062/202504/1552062-20250428162939106-58257825.png)

**复用库的RC4用法**
-------------

python中Crypto库中有该算法，具体用法如下：

    from Crypto.Cipher import *
    data = "kangel"
    key = "key"
    cipher = ARC4.new(key)    #加载密钥
    m = cipher.decrypt(key)   #用该密钥解密
    print m
    

**总结**
------

总而言之就是**两个步骤**：

1.  基于秘钥生成一个256位的S盒；
2.  逐个将明文与S盒内的某位数做异或操作。

* * *

Reference
=========

逆向踩坑之RC4  
[https://j-kangel.github.io/2019/04/09/RC4/#简介](https://j-kangel.github.io/2019/04/09/RC4/#%E7%AE%80%E4%BB%8B)

[https://www.cnblogs.com/huangming-zzz/p/10725295.html](https://www.cnblogs.com/huangming-zzz/p/10725295.html)

[https://www.cnblogs.com/cyssmile/p/12829098.html](https://www.cnblogs.com/cyssmile/p/12829098.html)