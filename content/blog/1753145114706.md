---
layout: post
title: '[深度学习] 大模型学习3上-模型训练与微调'
date: "2025-07-22T00:45:14Z"
---
\[深度学习\] 大模型学习3上-模型训练与微调
========================

在文章[大语言模型基础知识](https://blog.csdn.net/LuohenYJ/article/details/144858528)里，模型训练与微调作为大语言模型（Large Language Model，LLM）应用构建的主要方式被简要提及，本系列文章将从技术原理、实施流程及应用场景等维度展开深度解析。相关知识的进一步参考见：[LLM训练理论和实战](https://modelscope.cn/learn/399?pid=342)。本文作为系列的上半部分，内容涵盖第1章大语言模型概览和第2章大语言模型结构介绍。下半部分将聚焦于大语言模型的构建实践。

目录

*   [1 大语言模型概览](#1-大语言模型概览)
    *   [1.1 深度学习模型概览](#11-深度学习模型概览)
        *   [1.1.1 什么是模型](#111-什么是模型)
        *   [1.1.2 模型训练的原理](#112-模型训练的原理)
    *   [1.2 大语言模型训练方式概览](#12-大语言模型训练方式概览)
        *   [1.2.1 模型预训练与微调的一般过程](#121-模型预训练与微调的一般过程)
        *   [1.2.2 大语言模型训练流程概览](#122-大语言模型训练流程概览)
    *   [1.3 大语言模型推理的一般过程](#13-大语言模型推理的一般过程)
*   [2 大语言模型结构介绍](#2-大语言模型结构介绍)
    *   [2.1 Transformer结构](#21-transformer结构)
        *   [2.1.1 注意力机制](#211-注意力机制)
        *   [2.1.2 Transformer结构介绍](#212-transformer结构介绍)
    *   [2.2 大语言模型基础结构介绍](#22-大语言模型基础结构介绍)
*   [4 参考](#4-参考)

1 大语言模型概览
=========

1.1 深度学习模型概览
------------

### 1.1.1 什么是模型

在深度学习领域，模型是一个核心概念。它本质上是由大量数学公式构成的计算系统，虽然听起来复杂，但我们可以通过一个简化的比喻来理解它的基本原理。更通俗易懂的解释可参考：[深入浅出地理解神经网络](https://zhuanlan.zhihu.com/p/61492295)。

**线性模型**

假设你有一个**魔法盒子**，它能根据输入的数字生成新的数字。最初的盒子遵循简单规则："将输入数字乘以1，再加上1"，用数学公式表示即为线性模型：

    y = 1*x + 1
    

这个过程类似模型的**推理阶段**：

*   输入1时：`y = 1×1 + 1 = 2`
*   输入2时：`y = 1×2 + 1 = 3`

**线性模型的局限性**

这种魔法盒子，也就是简单的线性模型只能做简单的运算，遇到复杂问题就会卡壳。例如提问"安徽的省会城市是哪里？"，它无法处理的原因在于：

1.  输入单一：仅能处理数值计算，无法理解文本、图像等复杂信息；
2.  规则僵化：公式逻辑固定，无法学习非线性的复杂关系（如"城市-属性"的映射）。

![https://medium.com/data-science-at-microsoft/how-large-language-models-work-91c362f5b78f](https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/Python-Study-Notes/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A03-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/img/img00.jpg)

**复杂模型**

为了让魔法盒子具备"理解复杂问题"的能力，需要引入**非线性变换**。这种方式即在原来的公式后面加上一个特殊的 "开关"，这个开关可以把直线变成曲线。用符号`σ`表示：

    y = σ(1*x + 1)
    

这个曲线有什么用呢？它可以让魔法盒子"理解"复杂的问题。比如：

*   当输入x很小时，输出y几乎是0;
*   当输入x很大时，输出y几乎是1;
*   当输入x在中间时，输出y会从0慢慢变成1。

这种特性让魔法盒子可以学习到 "阈值" 的概念。它让简单的盒子变得更加智能，能够处理复杂的问题！比如：

*   当学习时间很短时，成绩几乎没有提高;
*   当学习时间足够长时，成绩会快速提高;
*   当学习时间已经很长时，再增加时间对成绩的提升就很小了。

通过这种单一非线性变换可拟合简单的分段规律（如学习时间与成绩的关系），而多层非线性变换（如深度神经网络）可通过叠加多个 "开关"，拟合任意复杂的函数关系（如图像中的边缘识别、语音中的语义理解等）。大语言模型（如GPT-4）则由数千亿个神经元相互连接构成。

![https://link.springer.com/article/10.1007/s10845-022-01963-8](https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/Python-Study-Notes/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A03-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/img/img01.jpg)

### 1.1.2 模型训练的原理

模型的学习过程可类比学生备考，分为三个核心步骤：

1.  喂数据：海量题库输入  
    提供大量"问题-答案"对，例如：
    
        训练数据：
        [
          {"问题": "安徽的省会城市是哪里?", "答案": "合肥"},
          {"问题": "23+20等于多少？", "答案": "43"},
          {"问题": "苹果的英文?", "答案": "apple"}
        ]
        
    
2.  调参数  
    模型用当前参数预测答案，若出错（如把"合肥"猜成"南京"），就通过**梯度下降算法**调整参数，类似走山路时根据坡度（梯度）调整方向，逐步找到误差最小的"最低点"。 这一过程在数学中被称为拟合。
    
3.  反复练习：百万次迭代优化  
    经过数百万次训练，模型能从"死记硬背"进化到"举一反三"。学会"合肥是安徽的省会"后，能推理出"安徽的省会是合肥"。
    

更多相关资料可参考[自然语言处理的深度学习模型综述](https://blog.csdn.net/qq_51580006/article/details/147456916)。人类思维与模型工作机制对比如下：

人类思维过程

模型工作机制

用眼睛看到"苹果" → 视网膜成像

输入层将图像转为像素级数字向量（如3×224×224的矩阵）

大脑皮层识别形状 → 提取轮廓特征

模型内部通过非线性变换（如卷积）提取边缘、颜色等特征

记忆中搜索"苹果"的含义 → 关联知识库

权重参数存储知识（如"苹果=apple"的映射关系）

说出"apple" → 声带肌肉协调输出

输出层将抽象特征转化为文本序列（如"a","p","p","l","e"）

![https://datascientest.com/en/natural-language-processing-definition-and-principles](https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/Python-Study-Notes/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A03-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/img/img02.jpg)

1.2 大语言模型训练方式概览
---------------

### 1.2.1 模型预训练与微调的一般过程

上述模型训练范式基于输入输出数据对驱动模型学习，属于经典的有监督学习方法。其核心是依赖预先标注的输出数据，通过构建输入与输出的映射关系，引导模型参数优化，以实现预期的预测性能。

随着互联网技术的快速发展，数据规模呈爆炸式增长，尤其是文本数据具有海量、易获取的特点。在此背景下，自监督学习范式应运而生并逐渐发展。自监督学习打破了有监督学习对标注数据的依赖，仅需输入数据即可进行模型训练。它借助大规模无标注文本数据，通过设计掩码语言建模、句子顺序预测等自监督任务，使模型从数据中挖掘潜在结构和规律，实现有效的特征学习。

在实际应用中，大语言模型普遍采用预训练和微调的两阶段训练策略。这一策略的灵感可类比于人类的学习过程：首先，通过广泛阅读各类书籍，构建起通用的语言理解能力和知识体系；随后，针对特定学科进行专项训练，以深化对特定领域知识的掌握。

具体到大语言模型，在预训练阶段，模型会在海量互联网文本上进行无监督学习，捕捉语言的语法、语义、句法等通用规律，进而具备强大的语言表征能力。在微调阶段，则利用特定领域的标注数据对预训练模型进行针对性调整，使模型能够快速适应特定任务需求。关于大语言模型的更进一步理解，详见：[轻松理解大模型](https://zhuanlan.zhihu.com/p/27724018379)。

### 1.2.2 大语言模型训练流程概览

前文提到的模型训练分为预训练和微调两个阶段，但实际大语言模型的训练流程更为复杂。这种复杂性源于现实训练数据的多样性，通常可分为以下三类：

1.  第一组（未标注答案的数据，无监督数据）：
    
    *   样本特征：原始文本语料，无人工标注
    *   示例：
        *   自然语言文本："白日依山尽，黄河入海流"
        *   日常对话："今天我看了电影"
        *   社交语境："我和她一起吃饭"
2.  第二组（已标注问题与答案的数据，监督数据）：
    
    *   样本特征：包含人工构造的输入-输出对
    *   示例：
        
        *   问答对：  
            问：如何保持健康的生活习惯？  
            答：规律作息结合均衡饮食
        
        *   解题指导：  
            问：计算正方形周长的公式是？A. 边长×4；B. 边长×边长  
            答：A
3.  第三组（包含正确与错误答案的数据，对比数据）：
    
    *   道德决策，发现他人遇到危险时该怎么做？
        *   正确答案：立即拨打急救电话并寻求专业帮助
        *   错误答案：围观拍照而不采取行动
    *   数字伦理：如何合理使用网络资源？
        *   正确答案：遵守网络礼仪，尊重知识产权
        *   错误答案：未经授权转载他人原创内容
        *   错误答案：随意转发

![https://docs.v1.argilla.io/en/v1.26.0/conceptual_guides/llm/rlhf.html](https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/Python-Study-Notes/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A03-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/img/img03.jpg)

这三类数据对应大语言模型训练的不同范式，按训练流程顺序分为：

1.  预训练阶段

*   数据：常见的无监督数据
*   方法：自监督学习（如掩码语言建模）
*   目标：让大语言模型掌握语言的统计规律、语法结构和基础语义理解能力，形成通用的语言表示能力
*   计算需求：通常需要数千张GPU，处理TB级数据

2.  微调阶段

*   数据：较为稀缺的监督数据
*   方法：指令微调
*   目标：使模型具备特定下游任务（如文本生成、分类等）的精确执行能力
*   计算需求：根据数据规模（从千级到千万级样本）需数十至数百张GPU

3.  人类对齐阶段

*   数据：最为稀缺的对比数据
*   方法：基于人类反馈的强化学习
*   目标：建立价值对齐机制，确保输出符合安全性、无害性、有用性标准
*   计算需求：通常需要数百张至数千张GPU，技术门槛显著高于微调

人类对齐通常包含奖励模型训练和强化学习优化两个阶段：

*   在奖励建模阶段，通过人类对同一提示下多模型回复的优劣排序，训练能够自动评估任意提示与回复对的奖励模型，其输出分数反映回复符合人类偏好的程度
*   强化学习阶段以指令监督微调（Supervised Fine-Tuning，SFT）模型为初始策略，输入多样化新提示生成回复，再由奖励模型评分，最终通过强化学习算法引导 SFT 模型优化策略，使其生成高奖励值的回复

类比于人类的语言学习，大语言模型的构建过程如下：

*   预训练 → 语言能力筑基（如词汇掌握、语法构建）
*   监督微调 → 专项技能训练（如数学解题、文本摘要）
*   人类对齐 → 价值观校准（如伦理判断、风险规避）

请注意，上述分类方式将奖励模型训练归入强化学习阶段，因为二者都服务于“人类偏好对齐”目标。但部分文章将该流程分为四个阶段，即将人类对齐拆分为奖励模型训练和强化学习两个独立阶段。

![](https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/Python-Study-Notes/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A03-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/img/img04.jpg)

一般我们将经过预训练，或结合通用数据微调的模型称作基座模型（base model），其特点是具备基础的语言理解与生成能力，但通常未针对具体应用场景进行优化。经过人类对齐的模型则被称为对话模型（chat model），这类模型可直接用于通用问答，也可通过少量数据微调适配特定领域场景。

1.3 大语言模型推理的一般过程
----------------

在大语言模型模型的推理过程中，核心任务是将输入序列（如一个句子）转化为输出序列（如另一个句子）。以处理输入句子`早上喝咖啡`为例，其核心步骤涉及文本的数字化表示与语义建模：

1.  词元化与索引映射（建立词表）：
    
    *   首先需构建一个包含常用语言单元（字、词或子词）的词表（Vocabulary），并为每个单元分配唯一索引。例如，一个30,000词的词表中，“早”、“上”、“喝”、“咖啡”可能分别对应索引 `[15, 28, 102, 3567]`
    *   类比理解：这类似于查阅字典时，每个词条对应一个唯一的页码编号和释义。词表索引相当于“页码”，而后续步骤将赋予其丰富的“语义释义”
2.  低维索引→高维语义向量映射（词嵌入）：
    
    *   单纯的数字索引（如 `[15, 28, 102, 3567]`）维度低且缺乏语义信息。模型通过**词嵌入层（Embedding Layer）** 将每个索引转换为稠密的高维向量（如1024维）
    *   **示例转换：**
        
            [15, 28, 102, 3567]  # 原始词元索引
            ↓ 词嵌入层
            [
              [0.21, -0.05, 0.87, ..., 0.33],  # “早”的1024维语义向量
              [0.45, 0.12, -0.91, ..., 0.18],  # “上”的1024维语义向量
              [-0.32, 0.76, 0.04, ..., -0.55], # “喝”的的1024维语义向量
              [0.67, -0.22, 0.11, ..., 0.79]   # “咖啡”的1024维语义向量
            ]  # 形成 4x1024 的语义矩阵
            
        
    *   这些高维向量（称为**词嵌入**）通过数值分布编码丰富的语义和语法关系（如“咖啡”与“茶”的向量距离通常比“咖啡”与“跑步”更近），是深度语言模型理解文本的基础
3.  语义建模与概率分布生成：
    
    *   获得词嵌入矩阵后，模型通过复杂的神经网络架构（如Transformer的注意力机制、多层感知机）进行深度计算
    *   最终输出层产生一个维度与词表大小（30,000）匹配的向量，每个位置对应词表中一个词元的未归一化得分（logits）
        
            [2.1, -1.5, 0.3, 5.8, ..., -0.7, 1.2]  # 30,000个logits
            
        
    *   为了生成可读的输出，模型应用Softmax函数 将这些logits转换为概率分布：
        *   Softmax确保所有输出值在(0,1)区间内，且总和为1
        *   选择概率最高的索引（如索引`735`对应“很”），通过词表反查得到输出词元
    *   示例推理：输入“早上喝咖啡”，模型可能输出概率最高的词元是“很”，形成“早上喝咖啡很”
4.  自回归生成：序列的迭代生成
    
    *   上述步骤仅生成单个词元。生成完整序列（如“早上喝咖啡很提神”）采用自回归（Autoregressive）方式：
        1.  输入扩展：将上一步生成的词元（如“很”）拼接到当前输入末尾，形成新输入序列“早上喝咖啡很”
        2.  迭代计算：将新序列输入模型，预测下一个词元的概率分布（如可能输出“提”）
        3.  终止条件：重复步骤2-3，直至模型生成特定的结束符（如 `<eos>`）
    *   类比理解：此过程类似于“传话游戏”，每次基于已生成的全部内容预测下一个最可能的词，直至传达结束信号

上述描述聚焦于模型的推理过程（即根据输入生成输出）。相比之下，模型的训练过程是：给定一个输入序列及其对应的目标序列（如下一个词或整个后续句子），通过调整模型参数，使模型预测目标序列的概率最大化。在训练数据中，`<eos>`等特殊标记也会被放置在句子末尾，以便模型学习识别序列结束的位置。关于大语言模型推理过程的详细介绍，可参见：[图解大模型的推理](https://zhuanlan.zhihu.com/p/23556533098)。

![https://blog.epsilla.com/unlocking-the-magic-of-large-language-models-llms-how-ai-understands-and-generates-text-3de89ccbb210](https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/Python-Study-Notes/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A03-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/img/img05.jpg)

2 大语言模型结构介绍
===========

2.1 Transformer结构
-----------------

### 2.1.1 注意力机制

在2017年之后，Transformer结构模型几乎横扫一切统治了NLP领域，后面的CV领域和Audio领域也大放异彩。

注意力机制的本质是模拟人类的选择性关注。想象你在嘈杂的咖啡馆里和朋友聊天：周围有音乐声、餐具碰撞声、其他人的谈话声，但你的大脑会自动聚焦在朋友的话语上，忽略其他无关信息。这种聚焦重要信息、过滤次要信息的能力，就是注意力机制的核心思想。

在自然语言处理中（比如翻译句子），传统模型可能逐字处理信息，难以区分词的重要性。而注意力机制让模型能计算句子中每个词（作为查询）与其他所有词（作为键）的「相关性分数」（注意力分数），给关键信息更高的关注度。举个例子：翻译句子I love Paris, the capital of France时，模型处理Paris时，会通过注意力机制关注到France，因为它们语义关联紧密，从而更准确地翻译出巴黎是法国的首都。

Transformer的自注意力机制具体实现如下：

1.  每个词的输入向量会通过三个不同的线性变换，生成对应的查询向量（Query）、键向量（Key）和值向量（Value）：
    *   Query：用来询问其他词是否重要
    *   Key：用来查询自己是否值得被关注
    *   Value：词本身的信息
2.  计算注意力分数，即相似度（关注度）：
    *   使用当前词的Query向量与序列中所有词的Key向量计算点积，得到原始注意力分数。结果越大说明关联越强（类似你和朋友说话时，对方的关键词会吸引你的注意力）
3.  加权求和：
    *   对原始注意力分数应用softmax函数进行归一化，得到和为1的注意力权重。用此权重对序列中所有词的Value向量进行加权求和，得到当前词的输出向量。该向量融合了全局信息，但重点突出相关信息（关注度高的词贡献更大）
4.  多层堆叠：
    *   多个包含自注意力机制和前馈神经网络的 Transformer 层依次堆叠。每一层的输出作为下一层的输入。通过多层处理，向量序列逐步提取并融合更复杂、更抽象的语义信息

为何大语言模型普遍采用Transformer？，对比CNN和LSTM主要以下区别:

1.  CNN:
    
    *   优势/原因: 强归纳偏置（局部连接、平移不变性）→ 擅长捕捉局部特征，小数据高效
    *   劣势/被取代原因: 难以建模长距离全局依赖 → 在大数据/复杂任务下成为瓶颈，性能被 Transformer 超越
2.  LSTM/RNN:
    
    *   优势/原因: 专为序列设计，能处理顺序信息
    *   劣势/被取代原因:
        *   存在长程依赖问题（早期信息易丢失）
        *   本质串行计算 → 训练效率极低，无法充分利用现代硬件并行能力，阻碍模型规模化
3.  Transformer:
    
    *   前提/原因: 弱归纳偏置 → 依赖海量数据才能发挥优势
    *   核心优势/被采用原因:
        *   强大的并行计算： 自注意力层可完全并行 → 极大加速训练和推理
        *   优秀的可扩展性： 结构规整 → 天然适合分布式训练和超大模型
        *   全局注意力机制： 直接建模序列中任意元素间的长距离依赖关系
        *   位置编码： 有效注入序列顺序信息，弥补注意力自身的位置不敏感性

在大数据与强大算力的支撑下，Transformer凭借极高的训练效率和强大的全局建模能力（即注意力机制），克服了CNN在全局依赖建模上的短板以及LSTM的串行计算瓶颈，成为构建超大规模语言模型的最优架构。关于注意力机制的更详细介绍，可参见：[Transform的注意力机制](https://zhuanlan.zhihu.com/p/1904841905101078831)。

![https://www.byhand.ai/p/8-can-you-calculate-a-transformer](https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/Python-Study-Notes/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A03-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/img/img06.gif)

### 2.1.2 Transformer结构介绍

**编码器和解码器**

Transformer核心由编码器（Encoder）和解码器（Decoder） 两部分组成。Transformer结构的具体介绍见：[transformer-explainer](https://poloclub.github.io/transformer-explainer/)。

编码器（Encoder）的作用：信息的“理解者”

*   核心目标： 将输入的信息理解并转化为机器能处理的语义向量。这个向量包含了输入内容的整体含义
*   工作流程（类比“翻译前的准备”）：
    *   第一步：分词与编码  
        输入句子（如“我喜欢苹果”）首先被拆分成词元（如“我”、“喜欢”、“苹果”），然后转化为机器可识别的数字编码（例如，通过嵌入层将词元映射为稠密向量）
    *   第二步：位置编码（Positional Encoding）  
        由于词语的顺序至关重要（例如“苹果喜欢我”与原句意思截然不同），位置编码会给每个词元添加其在句子中位置的信息（类似于为每个单词标记序号）
    *   第三步：自注意力机制（Self-Attention）  
        让模型学习“哪些词元之间是相关的”。例如，在处理“我喜欢苹果”时，模型会计算“我”与“喜欢”、“喜欢”与“苹果”之间的关联强度，就像人在阅读时会自然地将主语、谓语、宾语联系起来
    *   第四步：前馈神经网络（Feed Forward Network）  
        对经过自注意力处理的信息进行进一步加工和非线性变换，强化关键语义（例如突出“喜欢”这个动作），最终输出一个代表整句话含义的“语义向量”

解码器 (Decoder)：信息的 “生成者”。

*   核心目标  
    根据编码器输出的 “语义向量”，逐步生成目标内容（如翻译成另一种语言的句子）
    
*   工作流程 (按时间步 `t` 分解)：
    
    1.  初始化 (时间步 `t=1`):
        
        *   输入 1 (解码器自身输入): 起始标记 `<start>` + 对应的位置编码
        *   输入 2 (外部上下文)：编码器输出的完整语义向量 (Encoder Output)
        *   处理:
            *   解码器首先对 `<start>` + 位置编码进行掩码自注意力 (Masked Self-Attention)。因为是第一步，只有 `<start>` 自己，掩码确保它只能关注自己（无未来信息可掩蔽）
            *   然后进行交叉注意力 (Cross-Attention)：将掩码自注意力层的输出作为 _Query_，将 _Encoder Output_ 同时作为 _Key_ 和 _Value_。这允许解码器聚焦于输入序列中与生成第一个目标词最相关的部分
            *   交叉注意力的输出经过前馈神经网络 (FFN)
            *   FFN 的输出送入输出层 (线性层 + Softmax)，生成一个概率分布，预测第一个目标词 (如翻译中的 "I")
        *   输出: 预测出的第一个词 `Y₁` ("I")
    2.  后续时间步 (`t=2, 3, ..., T`):
        
        *   输入 1 (解码器自身输入):之前所有已生成的词 (`<start>`, `Y₁`, `Y₂`, ..., `Y_{t-1}`) + 对应的位置编码。这就是所谓的"自回归"：把上一步的输出作为下一步输入的一部分
        *   输入 2 (外部上下文): 编码器输出的完整语义向量 (Encoder Output)。(与 `t=1` 时相同，在整个解码过程中保持不变)
        *   处理:
            *   掩码自注意力 (Masked Self-Attention): 对当前输入序列 (`<start>`, `Y₁`, ..., `Y_{t-1}` + 位置编码) 进行处理。关键：掩码 (`Look-Ahead Mask`) 在此阶段严格生效。 当计算位置 `t` 的表示时，掩码会阻止模型“看到”位置 `t` 及之后的所有位置（即未来的词）。它只能关注 `<start>` 和 `Y₁` 到 `Y_{t-1}` 这些已经生成出来的词。这确保了生成过程的因果性
            *   交叉注意力 (Cross-Attention): 将掩码自注意力层的输出作为 _Query_，将 _Encoder Output_ 作为 _Key_ 和 _Value_。这一步是解码器的核心。它让解码器在考虑当前已生成的目标序列上下文 (`Query`) 的同时，动态地、有选择性地去“回顾”和“查询”编码器提供的源序列信息 (`Key/Value`)
            *   交叉注意力的输出经过前馈神经网络 (FFN)
            *   FFN 的输出送入输出层 (线性层 + Softmax)，生成一个概率分布，预测当前时间步 `t` 的目标词 `Y_t` (例如 `t=2` 时预测 "like"，`t=3` 时预测 "apple")
        *   输出: 预测出的当前词 `Y_t`
    3.  终止条件:
        
        *   重复步骤 2，将新预测出的词 `Y_t` 加入到输入序列中，预测下一个词 `Y_{t+1}`
        *   这个过程一直持续，直到输出层预测出结束标记 `<end>`，或者达到预设的最大生成长度

![https://towardsdatascience.com/transformers-explained-visually-part-1-overview-of-functionality-95a6dd460452/](https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/Python-Study-Notes/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A03-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/img/img07.jpg)

假设我们要将英语句子 "I like apple" 翻译成中文 "我喜欢苹果"。下面是 Transformer 解码器的工作流程：

1.  初始化 (t=1)
    
    *   输入 1：`<start>` + 位置编码（表示这是序列的第一个位置）
    *   输入 2：编码器输出的语义向量（包含 "I like apple" 的完整信息）
    *   处理：
        *   掩码自注意力：`<start>` 只能关注自己
        *   交叉注意力：解码器查询编码器输出，发现最相关的是表示 "I" 的部分
        *   FFN 和输出层：生成概率分布，预测第一个中文词 "我"
    *   输出：`Y₁` = "我"
2.  时间步 t=2
    
    *   输入 1：`<start>` + "我" + 对应的位置编码
    *   输入 2：与 t=1 相同的编码器输出
    *   处理：
        *   掩码自注意力："我" 可以关注 `<start>`，但不能关注未来的词
        *   交叉注意力：解码器根据已生成的 "我"，查询编码器输出中与 "like" 相关的部分
        *   FFN 和输出层：预测第二个中文词 "喜欢"
    *   输出：`Y₂` = "喜欢"
3.  时间步 t=3
    
    *   输入 1：`<start>` + "我" + "喜欢" + 位置编码
    *   输入 2：编码器输出
    *   处理：
        *   掩码自注意力："喜欢" 可以关注 `<start>` 和 "我"
        *   交叉注意力：解码器根据 "我喜欢"，查询编码器输出中与 "apple" 相关的部分
        *   FFN 和输出层：预测第三个中文词 "苹果"
    *   输出：`Y₃` = "苹果"
4.  时间步 t=4
    
    *   输入 1：`<start>` + "我" + "喜欢" + "苹果" + 位置编码
    *   处理：
        *   掩码自注意力和交叉注意力处理整个序列
        *   输出层：预测出结束标记 `<end>`
    *   输出：`Y₄` = `<end>`

结果：解码器生成的完整序列是 "我 喜欢 苹果 "，成功完成了翻译任务。

编码器与解码器的配合：以机器翻译为例：

1.  编码器先“理解”原句：
    *   输入“我喜欢苹果”，输出一个包含其语义的向量。
    *   编码器的作用类似于“读者”：它“读懂”输入语句，并将其核心含义浓缩成一个“含义包”。
2.  解码器根据语义“生成”译文：
    *   解码器接收这个语义向量，并逐个词地生成目标语言句子（如“I like apples”）。
    *   在生成过程中，解码器会持续参考编码器提供的语义信息以及自身已生成的词语。
    *   解码器的作用类似于“作者”：它基于“含义包”，用目标语言“写出”句子。在“写作”时，它需要一边思考前面已经“写”了什么（自回归），一边对照原句的语义。

**Transformer模型变体**

可以看出，Transformer这种编码器-解码器结构非常适合一类任务：这类任务需要借助编码器理解完整输入，并通过解码器生成完整输出。解码器中的掩码自注意力与交叉注意力是生成任务的核心。但该结构相对复杂，参数量较大，对于仅需理解输入（如分类任务）或仅需生成输出（如语言建模）的场景而言，部分结构显得冗余。因此，模型结构开始从Encoder-Decoder向单一结构演变。

1.  纯编码器模型（Encoder-only）

*   代表模型：BERT、RoBERTa
*   任务需求：主要用于语言理解任务，如文本分类、命名实体识别、情感分析、抽取式问答、自然语言推理等。这类任务的核心是对输入文本进行深度理解并做出判断或抽取特定信息，通常无需生成新的文本序列
*   结构：移除解码器简化了模型结构，通过双向自注意力机制（用于同时考虑该位置之前和之后的所有 token 信息）减少了参数量和计算量
*   缺陷：
    *   不适合生成任务：缺乏自回归生成机制和单向掩码自注意力，无法直接用于文本生成（如翻译、摘要、对话）
    *   预训练任务限制：典型预训练任务（如MLM）是破坏输入再重建，而非预测下一个词，其学习目标与生成任务存在差异
*   任务适应方式：基于编码器输出，通过在编码器顶部添加任务特定的输出层，并针对下游任务进行微调，实现对不同理解类任务的适配
*   任务执行流程（以文本分类为例）
    1.  输入处理：将文本转换为token序列（如“这部电影很精彩”→\[CLS, 这部，电影，很，精彩，SEP\]），并添加位置编码和段编码（若有多个文本输入）
    2.  编码器层处理：通过多层双向自注意力和前馈神经网络，逐层融合全局上下文信息，生成每个token的语义向量
    3.  特征提取与预测：取特殊token\[CLS\]的向量作为整个文本的表征，输入分类层（如全连接层+Softmax），输出类别概率（如“积极”“消极”情感标签）

2.  纯解码器模型（Decoder-only）

*   代表模型：GPT系列、Llama系列等
*   任务需求：核心优势在于自回归文本生成，例如续写、创意写作、机器翻译、摘要生成、对话生成等
*   结构：移除编码器，仅保留解码器模块（保留或等效实现带掩码的自注意力），通过前文预测下一个token，天然适配文本生成场景
*   缺陷：
    *   单向上下文局限（标准模型）：标准带掩码的自注意力为单向（仅能关注左侧），对当前词的理解不如双向编码器全面。（注意：大语言模型通过极长上下文窗口和模型规模部分弥补了这一局限，理解能力随训练逐渐增强。）
    *   生成时的计算效率问题：自回归生成需串行处理（逐词生成），无法像编码器那样并行处理整个输入序列，解码速度可能较慢
    *   幻觉风险：强大的生成能力可能伴随生成事实性不准确但逻辑自洽内容的风险
*   任务适应方式：通过提示工程或针对特定生成任务微调模型参数，实现对下游生成任务的适配，无需额外添加复杂结构
*   任务执行流程（以文本生成为例）
    1.  初始输入：给定提示词（如“请写一首关于春天的诗：”），转换为token序列，作为生成的初始上下文
    2.  自回归生成循环：
        *   输入当前token序列，通过解码器层计算每个位置的编码向量（仅关注左侧上下文）。
        *   对最后一个token的编码向量输入Softmax层，预测下一个token的概率分布（如“春”“天”“来”等），选择概率最高的token（或通过采样策略）添加到序列末尾
        *   重复上述过程，直到生成结束符（如“\[END\]”）或达到最大长度

![https://arxiv.org/abs/2306.11489](https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/Python-Study-Notes/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A03-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/img/img08.jpg)

总之，生成能力是大语言模型的核心能力。与完整的Encoder-Decoder结构相比，纯解码器结构更为简单，这不仅降低了设计的复杂性，还提高了效率。

纯编码器没有成为主流，主要是因为它存在生成能力缺失这一硬伤，同时通用性也有所不足：编码器模型通常需要针对特定的下游任务进行微调，缺乏纯解码器大语言模型那种仅通过提示就能解决众多任务的 “通用智能” 感。

不过，纯解码器结构的劣势也得到了弥补。在模型和数据规模不断扩大的过程中，纯解码器结构展现出了惊人的性能提升和涌现能力，借助规模优势，弥补了理论层面的理解劣势。与此同时，指令微调解锁了它的通用性，将其强大的生成基础能力转化为能够遵循指令、完成多样化任务的智能体。

关于这三种结构对比的详细内容，可参考：[LLM的3种架构](https://zhuanlan.zhihu.com/p/642923989)

2.2 大语言模型基础结构介绍
---------------

自GPT-3之后，OpenAI在其大语言模型的发展方向上转向了闭源策略，不再发布开源模型，例如GPT-3.5以及后续的GPT-4系列。因此，外界对于ChatGPT和GPT-4所采用的具体模型架构细节（如层数、隐藏层维度、注意力头数等）以及潜在的优化技术缺乏官方确认的清晰了解。在此背景下，Meta开源的大语言模型LLaMA系列成为了代表性的开源大语言模型。

LLaMA的整体架构依然基于Transformer解码器结构，但在具体实现细节上进行了多项关键改进：

1.  前置层归一化（Pre-Layer Normalization）：该策略旨在提高训练稳定性和收敛速度，缓解梯度问题
2.  RMSNorm归一化函数：替代了原始的LayerNorm。RMSNorm仅使用均方根进行缩放，计算更简单高效，效果接近LayerNorm，同时降低了计算开销
3.  SwiGLU激活函数：结合了门控机制和Swish激活函数的优势，被证明比标准ReLU或GeLU能提供更强的表达能力和性能，尤其在较大模型上
4.  旋转位置编码（RoPE）：用于更有效地编码序列位置信息。RoPE将位置信息通过旋转操作融入键（Key）和查询（Query）向量的点积运算中，能更好地建模相对位置关系，且对序列长度具有外推性，优于传统的绝对或相对位置编码

![https://zhuanlan.zhihu.com/p/1900694724261684865](https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/Python-Study-Notes/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A03-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E5%BE%AE%E8%B0%83/img/img09.jpg)

尽管在架构层面进行了这些优化，但LLaMA的核心训练机制（利用大规模文本数据以自回归方式完成语言建模任务）本质上仍与原始Transformer的训练流程相同。关于LLM结构改进的详细信息，可参考[LLM架构全景](https://zhuanlan.zhihu.com/p/1900694724261684865)。

4 参考
====

*   [大语言模型基础知识](https://blog.csdn.net/LuohenYJ/article/details/144858528)
*   [LLM训练理论和实战](https://modelscope.cn/learn/399?pid=342#4ever-bi-710)
*   [深入浅出地理解神经网络](https://zhuanlan.zhihu.com/p/61492295)
*   [自然语言处理的深度学习模型综述](https://blog.csdn.net/qq_51580006/article/details/147456916)
*   [轻松理解大模型](https://zhuanlan.zhihu.com/p/27724018379)
*   [图解大模型的推理](https://zhuanlan.zhihu.com/p/23556533098)
*   [Transform的注意力机制](https://zhuanlan.zhihu.com/p/1904841905101078831)
*   [transformer-explainer](https://poloclub.github.io/transformer-explainer/)
*   [LLM的3种架构](https://zhuanlan.zhihu.com/p/642923989)
*   [LLM架构全景](https://zhuanlan.zhihu.com/p/1900694724261684865)

本文来自博客园，作者：[落痕的寒假](https://www.cnblogs.com/luohenyueji/)，转载请注明原文链接：[https://www.cnblogs.com/luohenyueji/p/18996523](https://www.cnblogs.com/luohenyueji/p/18996523)

![](https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/wechat/content/%E5%8A%A0%E6%B2%B9%E9%B8%AD.gif)