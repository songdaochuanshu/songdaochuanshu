---
layout: post
title: '【踩坑系列】使用Comparator.comparing对中文字符串排序结果不对'
date: "2025-04-26T00:39:07Z"
---
【踩坑系列】使用Comparator.comparing对中文字符串排序结果不对
----------------------------------------

2025-04-25 13:18  [申城异乡人](https://www.cnblogs.com/zwwhnly)  阅读(87)  评论(0)    [收藏](javascript:void\(0\))  [举报](javascript:void\(0\))

使用Comparator.comparing对中文字符串排序结果不对解决方案。

1\. 踩坑经历
--------

假设有这样一个业务场景，需要对各个城市的订单量排序，排序规则为：

先根据订单量倒序排列，再根据城市名称正序排列。

示例代码：

    import lombok.Getter;
    import lombok.Setter;
    import lombok.ToString;
    
    @Getter
    @Setter
    @ToString
    public class OrderStatisticsInfo {
        private String cityName;
        private Integer orderCount;
    
        public OrderStatisticsInfo(String cityName, Integer orderCount) {
            this.cityName = cityName;
            this.orderCount = orderCount;
        }
    }
    

    public static void main(String[] args) {
        List<OrderStatisticsInfo> orderStatisticsInfoList = Arrays.asList(
                new OrderStatisticsInfo("上海", 1000),
                new OrderStatisticsInfo("北京", 1000),
                new OrderStatisticsInfo("成都", 700),
                new OrderStatisticsInfo("常州", 700),
                new OrderStatisticsInfo("广州", 900),
                new OrderStatisticsInfo("深圳", 800)
        );
    
        orderStatisticsInfoList.sort(Comparator.comparing(OrderStatisticsInfo::getOrderCount, Comparator.reverseOrder())
                .thenComparing(OrderStatisticsInfo::getCityName));
        orderStatisticsInfoList.forEach(System.out::println);
    }
    

预期结果：

> 北京 1000
> 
> 上海 1000
> 
> 广州 900
> 
> 深圳 800
> 
> 常州 700
> 
> 成都 700

实际结果：

> OrderStatisticsInfo(cityName=上海, orderCount=1000)  
> OrderStatisticsInfo(cityName=北京, orderCount=1000)  
> OrderStatisticsInfo(cityName=广州, orderCount=900)  
> OrderStatisticsInfo(cityName=深圳, orderCount=800)  
> OrderStatisticsInfo(cityName=常州, orderCount=700)  
> OrderStatisticsInfo(cityName=成都, orderCount=700)

从以上结果可以看出，根据订单量倒序排列没啥问题，但根据城市名称正序排列不符合预期：

上海竟然排到了北京的前面，但常州与成都的顺序又是对的。

2\. 原因分析
--------

`Comparator.comparing`对字符串类型进行排序时，默认使用的是字符串的自然排序，即`String`的`compareTo`方法，该方法是基于

Unicode编码值进行比较的，未考虑语言特定的字符顺序（如中文拼音）。

先看下`String`的`compareTo`方法的源码：

    public int compareTo(String anotherString) {
        int len1 = value.length;
        int len2 = anotherString.value.length;
        int lim = Math.min(len1, len2);
        char v1[] = value;
        char v2[] = anotherString.value;
    
        int k = 0;
        while (k < lim) {
            char c1 = v1[k];
            char c2 = v2[k];
            if (c1 != c2) {
                return c1 - c2;
            }
            k++;
        }
        return len1 - len2;
    }
    

以上海与北京的比较为例，先比较第一个字符，也就是字符上和字符北，字符上对应的Unicode编码值是19978，因此c1 = 19978，

字符北对应的Unicode编码值是21271，因此c2 = 21271，因为c1 != c2，所以返回值为-1293，

也就是说上海小于北京（要排在北京的前面），不符合预期。

以常州与成都的比较为例，先比较第一个字符，也就是字符常和字符成，字符常对应的Unicode编码值是24120，因此c1 = 24120，

字符成对应的Unicode编码值是25104，因此c2 = 25104，因为c1 != c2，所以返回值为-984，

也就是说常州小于成都（要排在成都的前面），符合预期。

可以通过`Character.codePointAt`方法获取字符的Unicode编码值：

    // 输出:19978
    System.out.println(Character.codePointAt("上海", 0));
    // 输出:21271
    System.out.println(Character.codePointAt("北京", 0));
    // 输出:24120
    System.out.println(Character.codePointAt("常州", 0));
    // 输出:25104
    System.out.println(Character.codePointAt("成都", 0));
    

3\. 解决方案
--------

Java提供了本地化的排序规则，可以按特定语言规则排序（如中文拼音），代码如下所示：

    orderStatisticsInfoList.sort(Comparator.comparing(OrderStatisticsInfo::getOrderCount, Comparator.reverseOrder())
                    .thenComparing(OrderStatisticsInfo::getCityName, Collator.getInstance(Locale.CHINA)));
    orderStatisticsInfoList.forEach(System.out::println);
    

此时的输出结果为：

> OrderStatisticsInfo(cityName=北京, orderCount=1000)  
> OrderStatisticsInfo(cityName=上海, orderCount=1000)  
> OrderStatisticsInfo(cityName=广州, orderCount=900)  
> OrderStatisticsInfo(cityName=深圳, orderCount=800)  
> OrderStatisticsInfo(cityName=常州, orderCount=700)  
> OrderStatisticsInfo(cityName=成都, orderCount=700)

可以看到，北京排到了上海的前面，符合预期。

上述代码指定了`Collator.getInstance(Locale.CHINA)`，在排序比较时不再执行`String`的`compareTo`方法，

而是执行`Collator`的`compare`方法，实际上是`RuleBasedCollator`的`compare`方法。

可以执行以下代码单独看下上海与北京的比较结果：

    Collator collator = Collator.getInstance(Locale.CHINA);
    // 输出:1，代表上海大于北京，也就是要排在北京的后面
    System.out.println(collator.compare("上海", "北京"));
    

> 文章持续更新，欢迎关注微信公众号「申城异乡人」第一时间阅读！