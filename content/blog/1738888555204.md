---
layout: post
title: 'VSCODE接入DeepSeek R1实现AI完成自动化脚本实战开发'
date: "2025-02-07T00:35:55Z"
---
VSCODE接入DeepSeek R1实现AI完成自动化脚本实战开发
==================================

大家好，我是六哥，今天还是我们喜爱的DeepSeek的玩法，今天来个实战案例，和大家分享一下如何将DeepSeek接入VS Code，结合AI Toolkit插件完成自动化脚本的实战开发。

一、准备
----

微软官方为我们提供了一个针对AI辅助的插件——AI Toolkit for Visual Studio Code。这个插件功能强大，可以利用各种开源或商用的大模型，目前已经集成了DeepSeek R1模型，能让我们在VS Code中方便地借助DeepSeek进行代码开发。

### 安装AI ToolKit插件并启用DeepSeek

在VS Code的插件中心找到AI Toolkit并完成安装。  
![](https://img2024.cnblogs.com/blog/718867/202502/718867-20250206234933210-913044255.png)

安装完成后，在插件页面选择Catalog中的Models模型页面，通过筛选条件“hosted by Github”以及“publisher DeepSeek”来使用DeepSeek - R1模型。

![](https://img2024.cnblogs.com/blog/718867/202502/718867-20250206234945523-1099217348.png)

二、使用AI帮助生成脚本
------------

有了DeepSeek模型后，我们就可以新建一个Playground让DeepSeek帮助我们生成自动化脚本。以下是我让DeepSeek生成的针对saucedemo的测试脚本的相关思考过程：

![](https://img2024.cnblogs.com/blog/718867/202502/718867-20250206235001746-1750631003.png)

### 1、项目结构确定

POM模式下，通常会有page对象、测试用例、配置文件、数据文件等。可能需要这样的目录结构：

    ├── data
    │   └── users.yml
    ├── pages
    │   ├── __init__.py
    │   ├── login_page.py
    │   ├── products_page.py
    │   └── checkout_page.py
    ├── tests
    │   └── test_saucedemo.py
    ├── conftest.py
    └── requirements.txt
    

### 2、用户数据处理

用户数据存放在user.yml里，里面应该有不同的用户类型，比如标准用户、锁定用户、错误密码用户、没有用户名或密码的用户等。测试用例要读取这些数据，可能用pyYAML库来读取user.yml文件，在测试时用`@pytest.mark.parametrize`参数化输入不同的用户数据。

    valid_user:
      username: "standard_user"
      password: "secret_sauce"
    
    invalid_users:
      - username: "locked_out_user"
        password: "secret_sauce"
        error: "Epic sadface: Sorry, this user has been locked out."
      - username: "invalid_user"
        password: "wrong_password"
        error: "Epic sadface: Username and password do not match any user in this service"
    

### 3、Page Object Model实现

每个页面比如登录页、商品页、结算页都有自己的类，封装元素和操作。例如，LoginPage有用户名、密码输入框，登录按钮，错误提示的方法。

**pages/login\_page.py**

    from playwright.sync_api import Page
    
    class LoginPage:
        def __init__(self, page: Page):
            self.page = page
            self.username = page.locator("#user-name")
            self.password = page.locator("#password")
            self.login_button = page.locator("#login-button")
            self.error_message = page.locator(".error-message-container")
    
        def navigate(self):
            self.page.goto("https://www.saucedemo.com/")
    
        def login(self, username: str, password: str):
            self.username.fill(username)
            self.password.fill(password)
            self.login_button.click()
    

**pages/products\_page.py**

    from playwright.sync_api import Page
    
    class ProductsPage:
        def __init__(self, page: Page):
            self.page = page
            self.title = page.locator(".title")
            self.inventory_items = page.locator(".inventory_item")
            self.cart_button = page.locator(".shopping_cart_link")
    
        def add_to_cart(self, index: int = 0):
            self.inventory_items.nth(index).locator("button").click()
    
        def go_to_cart(self):
            self.cart_button.click()
    

**pages/checkout\_page.py**

    from playwright.sync_api import Page
    
    class CheckoutPage:
        def __init__(self, page: Page):
            self.page = page
            self.first_name = page.locator("#first-name")
            self.last_name = page.locator("#last-name")
            self.postal_code = page.locator("#postal-code")
            self.continue_button = page.locator("#continue")
            self.finish_button = page.locator("#finish")
            self.complete_header = page.locator(".complete-header")
    
        def fill_info(self, first: str, last: str, zipcode: str):
            self.first_name.fill(first)
            self.last_name.fill(last)
            self.postal_code.fill(zipcode)
            self.continue_button.click()
    
        def complete_checkout(self):
            self.finish_button.click()
    

### 4、测试用例设计

测试用例应该使用pytest的参数化来覆盖不同的用户场景。比如正常登录成功、无效密码、锁定用户等。同时，checkout流程需要正常流程的测试，可能还有填写信息不完整的情况。

    import pytest
    import yaml
    from playwright.sync_api import Page
    
    with open("data/users.yml") as f:
        test_data = yaml.safe_load(f)
    
    @pytest.mark.parametrize("user", test_data["invalid_users"])
    def test_invalid_login(page: Page, user):
        login_page = LoginPage(page)
        login_page.navigate()
        login_page.login(user["username"], user["password"])
        assert login_page.error_message.is_visible()
        assert user["error"] in login_page.error_message.inner_text()
    
    def test_valid_login_and_checkout(page: Page):
        # Login
        login_page = LoginPage(page)
        login_page.navigate()
        login_page.login(test_data["valid_user"]["username"], 
                        test_data["valid_user"]["password"])
        
        # Add product
        products_page = ProductsPage(page)
        assert products_page.title.inner_text() == "Products"
        products_page.add_to_cart()
        products_page.go_to_cart()
    
        # Checkout
        page.click("#checkout")
        checkout_page = CheckoutPage(page)
        checkout_page.fill_info("John", "Doe", "12345")
        checkout_page.complete_checkout()
        
        assert checkout_page.complete_header.inner_text() == "THANK YOU FOR YOUR ORDER"
    

### 5、fixture设置

在conftest.py里面设置Playwright的fixture，比如browser、page，以及各个page对象的fixture。比如，每次测试前都转到登录页，登录后到库存页，这样可以处理前置条件。

    import pytest
    from playwright.sync_api import Playwright
    
    @pytest.fixture(scope="function")
    def page(playwright: Playwright):
        browser = playwright.chromium.launch(headless=False)
        context = browser.new_context()
        page = context.new_page()
        yield page
        context.close()
        browser.close()
    

### 6、依赖库

    pytest
    playwright
    PyYAML
    

**关键点说明：**

1.  POM模式分层清晰，每个页面封装对应的操作和元素定位
2.  使用YAML文件管理测试数据，便于维护和扩展
3.  参数化测试支持多种异常场景验证
4.  完整的端到端测试流程覆盖登录-加购-结账全流程
5.  使用Playwright的同步API简化测试编写
6.  通过conftest管理浏览器实例

三、整合项目步骤
--------

### 1、需要检查的测试场景

#### 登录

*   正确用户密码登录成功。
*   错误密码提示错误信息。
*   锁定用户无法登录。
*   空用户名或密码提示错误。

#### Checkout

*   正常填写所有信息，完成订单。
*   必填字段缺失（如first name为空）提示错误。
*   取消订单流程。

### 2、实施步骤

*   创建项目结构，安装依赖：pytest、playwright、pyyaml。
*   编写user.yml，包含不同类型的用户数据。
*   实现各个页面的Page类，包含元素定位和操作方法。
*   在conftest.py中定义fixture，例如初始化page，创建各page对象的实例。
*   编写测试用例，参数化用户数据，覆盖正常和异常流程。
*   处理测试中的等待和断言，确保元素的存在或文本正确。

### 3、关键点说明

*   POM模式分层清晰，每个页面封装对应的操作和元素定位
*   使用YAML文件管理测试数据，便于维护和扩展
*   参数化测试支持多种异常场景验证
*   完整的端到端测试流程覆盖登录-加购-结账全流程
*   使用Playwright的同步API简化测试编写
*   通过conftest管理浏览器实例

四、效果
----

![](https://img2024.cnblogs.com/blog/718867/202502/718867-20250206235020377-1378878650.png)

五、结论
----

参照DeepSeek给出的结果，基本不用做太大的微调就可以执行成功，确实极大提升了我们进行自动化实现的效率。最难能可贵的是，DeepSeek给出的思考过程，对于我们代码实现和用例设计的要点也有极大的参考价值！

**优秀不够，你是否无可替代**

**软件测试交流QQ群：721256703，期待你的加入！！**

**欢迎关注我的微信公众号：软件测试君**

![](https://www.cnblogs.com/images/cnblogs_com/longronglang/1061549/o_QQ%E6%88%AA%E5%9B%BE20190728134401.jpg)