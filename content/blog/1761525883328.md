---
layout: post
title: '磁盘格式化和LVM挂载'
date: "2025-10-27T00:44:43Z"
---
磁盘格式化和LVM挂载
===========

![磁盘格式化和LVM挂载](https://img2024.cnblogs.com/blog/3413000/202510/3413000-20251026192838739-458385033.png) 我发现生产项目上LVM的使用也是较为频繁的，本期出一个关于LVM使用的教程，方便大家参考

1、磁盘格式化
-------

（其实可以不分区直接格式化，为了系统操作安全使用先分区再格式化，直接格式化磁盘就固定只能使用一个文件系统，但是我们如果把所有空间都分配到了一个分区，那其实都一样的，所以分不分区其实无所谓，但是在某些旧的liunx中无分区表的话可能无法识别磁盘，如果是做LVM的话并不关注）

> 具体使用什么分区表（主要参考）：
> 
> ①**是否是系统盘？**，如果是系统盘则要结合硬件驱动程序来看（使用dmesg命令查看内核加载信息，如果有efi的输出，则该系统为新系统，传统系统一般以BIOS驱动），如果是BIOS启动推荐使用MBR，因为BIOS无法直接引导GPT分区，需要额外处理，如果是UEFI启动则使用GPT分区，**非系统盘推荐使用GPT**
> 
> ②**磁盘大小是否大于2T?**，大于2T使用GPT分区表（MBR使用32 位LBA 地址位，最大寻址2^32 - 1个扇区，传统扇区大小为 512 B，最大容量2199023255552 B 约 2.19TB，属于设计的硬限制），小于2T可以按需求MBR和GPT选择使用

    [root@localhost ~]# dmesg | grep -i efi
    [    0.000000] efi: Getting EFI parameters from FDT:
    [    0.000000] efi: EFI v2.70 by EDK II
    [    0.000000] efi:  SMBIOS 3.0=0x83f7e0000  MEMATTR=0x83e747018  ACPI 2.0=0x83c120000  MEMRESERVE=0x83c453a18 
    [    0.000000] Kernel command line: BOOT_IMAGE=/vmlinuz-4.19.90-89.11.v2401.ky10.aarch64 root=/dev/mapper/klas-root ro rd.lvm.lv=klas/root rd.lvm.lv=klas/swap video=VGA-1:640x480-32@60me rhgb quiet console=tty0 crashkernel=1024M,high smmu.bypassdev=0x1000:0x17 smmu.bypassdev=0x1000:0x15 video=efifb:off audit=0
    [    0.006853] Remapping and enabling EFI services.
    [    0.236395] Registered efivars operations
    [    0.996074] rtc-efi rtc-efi: registered as rtc0
    [    0.996170] rtc-efi rtc-efi: setting system clock to 2025-09-03T08:11:36 UTC (1756887096)
    [    0.997547] EFI Variables Facility v0.08 2004-May-17
    [root@localhost ~]# ls /sys/firmware/efi
    config_table  efivars  fw_platform_size  systab  vars
    

![image](https://img2024.cnblogs.com/blog/3413000/202510/3413000-20251026185746828-1980849916.png)

  ⚠️ 注意：分区后不要格式化（因为我们的目的是做逻辑卷，我们要在逻辑卷上格式化文件系统），如果已经格式化需要销毁文件系统 `wipefs -a /dev/vdb`

  gdisk的命令不一定有，但是parted命令大多数linux标准安装中都有

    [root@hexadb-master01 ~]# parted /dev/vdi
    GNU Parted 3.1
    Using /dev/vdi
    Welcome to GNU Parted! Type 'help' to view a list of commands.
    # 创建 GPT 分区表（适用于 >2TB 磁盘或现代系统）
    (parted) mklabel gpt 
    # 创建一个主分区使用全部空间，预期以后会被格式化成 ext4，1MB指定分区起始位置，目的是分区对齐，100%表示使用到磁盘末尾
    # parted是分区工具，只创建分区，不创建文件系统，这里的ext4只是期望标识，不影响你后续文件系统类型选择，甚至这里期望文件系统标识可以不写
    (parted) mkpart primary ext4 1MiB 100%          
    # 查看分区结果
    (parted) print                                                            
    Model: Virtio Block Device (virtblk)
    Disk /dev/vdi: 1074GB
    Sector size (logical/physical): 512B/512B
    Partition Table: gpt
    Disk Flags: 
    
    Number  Start   End     Size    File system  Name     Flags
     1      1049kB  1074GB  1074GB               primary
    # 退出交互窗口
    (parted) quit                                                             
    Information: You may need to update /etc/fstab.
    
    [root@hexadb-master01 ~]#
    

> gdisk 和 parted 的区别：
> 
>   gdisk是fdisk的升级版用于处理gpt磁盘分区格式简单灵活对新手操作友好，parted是专业的gpt分区工具，功能强大，除一般分区操作外还支持一些高级的操作如磁盘移动、复制、扩缩容等
> 
>   gdisk 的安全性高于parted, gdisk和fdisk一样他们都是"内存编辑---最后保存"的模式，即在交互操作页面上的操作都是在内存中执行的不会立即写入磁盘，直到你最后输入"w"，开始写入磁盘。parted在命令交互页面的命令部分是立即执行的比如mklabel、mkpart、rm等命令执行期间立即更新磁盘结构。
> 
> 对比维度
> 
> **fdisk**
> 
> **gdisk**
> 
> **parted**
> 
> **主要支持的分区表**
> 
> **MBR (Master Boot Record)** （对 GPT 支持有限且不推荐）
> 
> **GPT (GUID Partition Table)** （也支持 MBR，但主要用于 GPT）
> 
> **同时支持 MBR 和 GPT** （原生支持两种格式）
> 
> **最大磁盘容量**
> 
> **2TB** （MBR 的硬性限制）
> 
> **18EB (Exabytes)** （GPT 的理论极限）
> 
> **18EB** （受限于 GPT 规范）
> 
> **主分区数量限制**
> 
> **4 个主分区** （或 3 个主 + 1 个扩展分区，扩展分区下可创建多个逻辑分区）
> 
> **128 个主分区** （GPT 无扩展分区概念）
> 
> **128 个主分区** （使用 GPT 时）
> 
> **用户界面**
> 
> **交互式命令行** （输入单字母命令，如 `n`, `d`, `p`, `w`）
> 
> **交互式命令行** （操作逻辑与 `fdisk` 非常相似）
> 
> **交互式命令行** （也可用于脚本，命令更直观如 `mkpart`, `resizepart`）
> 
> **核心功能**
> 
> \- 创建/删除主/逻辑分区 - 修改分区类型 - 显示分区表 - 写入/放弃更改
> 
> \- 创建/删除 GPT 分区 - 修改分区类型 - 显示/验证分区表 - 备份/恢复分区表
> 
> \- 创建/删除/调整分区大小 - 创建 MBR/GPT 分区表 - 格式化分区（`mkfs`） - 移动分区 - 文件系统类型检查
> 
> **调整分区大小**
> 
> ❌ **不支持** （无法直接调整现有分区的大小）
> 
> ⚠️ **不直接支持** （`gdisk` 本身无 resize 命令，需配合其他工具）
> 
> ✅ **原生支持** （使用 `resizepart` 命令，是其核心优势之一）
> 
> **适用场景**
> 
> \- 管理小于 2TB 的磁盘 - 传统 BIOS (Legacy) 系统 - 需要精确控制 MBR 分区的场景 - 老旧系统或设备
> 
> \- 管理大于 2TB 的磁盘 - UEFI 启动系统 - 需要创建 EFI 系统分区 (ESP) - 需要超过 4 个主分区
> 
> \- **通用首选**，特别是大容量磁盘 - 需要调整分区大小（扩/缩容） - 脚本化自动化分区 - 无图形界面的服务器环境
> 
> **数据保护**
> 
> 单分区表，无冗余。
> 
> 支持主/备份分区表，有 CRC 校验。
> 
> 支持 GPT 的冗余和校验机制。
> 
> **最佳实践建议**
> 
> **磁盘 < 2TB 且使用 MBR 时使用**。
> 
> **磁盘 > 2TB 或使用 UEFI 时，首选 `gdisk` 来管理 GPT**。
> 
> **推荐作为日常管理工具**，尤其适合需要 `resize` 功能或处理大磁盘的场景。

2、磁盘做LVM
--------

    创建物理卷        pvcreate /dev/vdb1 
    展示物理卷信息     pvs
    创建卷组          vgcreate hexadb /dev/vdb1    #卷组名可自定义
    展示卷组信息       vgs
    创建逻辑卷        lvcreate -l 100%FREE -n data hexadb
    展示逻辑卷信息     lvs
    

3、格式化文件系统
---------

    格式化文件系统：     mkfs -t xfs /dev/mapper/hexadb-data
    

![image](https://img2024.cnblogs.com/blog/3413000/202510/3413000-20251026185901618-1874519633.png)

    创建挂载点：          mkdir /data
    

> 常用的文件系统为xfs和ext4：
> 
> **对比项**
> 
> **XFS**
> 
> **ext4**
> 
> **最大支持容量**
> 
> 非常大（最高 **16EB**）
> 
> 大（最高 **64TB**）
> 
> **单文件大小限制**
> 
> **8 EiB**
> 
> **16 TiB**
> 
> **性能表现**
> 
> **大文件读写**极快，高并发好
> 
> **小文件**和日常操作更均衡
> 
> **在线缩容？**
> 
> ❌ 不支持
> 
> ✅ 支持（需先卸载）
> 
> **支持快照？**
> 
> 支持（配合 LVM ）
> 
> 支持（配合 LVM ）
> 
> **碎片整理**
> 
> 支持在线整理
> 
> 基本只能离线整理
> 
> **稳定性兼容性**
> 
> 稳定，企业级常用
> 
> 极其稳定，Linux 默认首选之一
> 
> **修复工具**
> 
> `xfs_repair`（强大但风险略高）修复速度快但操作不可逆
> 
> `e2fsck`（业界标杆，修复能力强）修复速度慢但更细致可控
> 
> **适合场景**
> 
> 大型文件系统、大文件存储（如数据库、视频、虚拟机磁盘、NAS、企业数据盘）
> 
> 通用桌面、Web 服务器、小型数据库、系统盘、通用盘、容器主机等

4、挂载lVM
-------

    # 注意：磁盘唯一标识根据实际需要可更换为UUID更为准确，因为Linux 的设备名（如 /dev/sda, /dev/sdb, /dev/vdc1）是按探测顺序动态分配的，如果启动顺序变化或者添加/移除一块硬盘，设备名sda可能变成 sdb，此时这种用设备名是极不安全的（重启后设备名漂移，系统无法启动），在持久化、自动化、可靠性的场景中，必须使用 UUID，生产强烈建议全部使用UUID。如果是在临时调试、手动挂载测试那么设备名是比较方便的。
    echo "/dev/mapper/hexadb-data   /data   xfs    defaults     0 0" >> /etc/fstab
    cat   /etc/fstab
    mount -a 
    lsblk -f 
    

![image](https://img2024.cnblogs.com/blog/3413000/202510/3413000-20251026190139196-1960360092.png)

> 其他：
> 
> 销毁LVM方式，不可逆，注意数据安全
> 
> 展示逻辑卷信息 lvdisplay (或lvs)
> 
> 删除逻辑卷： lvremove /dev/vg\_data/lv\_data
> 
> 查看卷组： vgdisplay （或vgs）
> 
> 删除卷组： vgremove vg\_data
> 
> 查看物理卷： pvdisplay （或pvs）
> 
> 删除物理卷： pvremove /dev/sdbX