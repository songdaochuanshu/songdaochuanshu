---
layout: post
title: '中介者模式'
date: "2025-02-07T00:35:55Z"
---
中介者模式
=====

中介者模式的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。用一个中介对象来封装一系列的对象交互。这样，系统中的各个对象不直接互相引用，而是通过中介者进行交互，从而降低了系统的耦合度。

​中介者（Mediator）模式属于行为型模式的一种。

中介者模式的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。用一个中介对象来封装一系列的对象交互。这样，系统中的各个对象不直接互相引用，而是通过中介者进行交互，从而降低了系统的耦合度。

**MVC模式**以及**MVVM模式**都可以看作是中介者模式的扩展。中介者模式能减少对象之间混乱无序的依赖关系。类所拥有的依赖关系越少，就越易于修改、 扩展或复用。

在真实世界中，飞机驾驶员不会直接相互沟通来决定哪一架飞机先降落，而是通过**塔台**来进行沟通，此时的塔台就是一个中介者对象。

当多个类之间存在复杂的交互，而这些交互又不希望在各个类之间直接进行时；当系统中的对象之间需要有统一的协调，但不想让这些对象直接依赖彼此时，都可以使用中介者模式。

中介者模式通常有以下组成部分： 

*   Mediator（中介者接口）：定义了一个接口，用于与多个同事对象进行交互。
*   ConcreteMediator（具体中介者）：实现中介者接口，协调和管理多个同事对象的交互。
*   Colleague（同事类）：所有同事类都知道中介者对象，它们通过中介者与其他同事类进行交互。
*   ConcreteColleague（具体同事类）：每个具体同事类都向中介者发出请求并接收来自中介者的通知。

我们模拟一个简单的聊天室应用。聊天室相当于一个中介者。

1、Mediator: 中介者接口

    // Mediator: 中介者接口
    interface ChatRoom {
        void sendMessage(String message, User user);
    }

![](https://img2024.cnblogs.com/blog/1171560/202502/1171560-20250206233550787-2074026096.gif "点击并拖拽以移动")

2、ConcreteMediator: 具体中介者

    // ConcreteMediator: 具体中介者
    class ConcreteChatRoom implements ChatRoom {
        @Override
        public void sendMessage(String message, User user) {
            System.out.println(user.getName() + " sends message: " + message);
            // 中介者通知所有其他用户
            for (User u : users) {
                if (u != user) {
                    u.receiveMessage(message);
                }
            }
        }
    
        private List<User> users = new ArrayList<>();
        
        // 注册用户
        public void addUser(User user) {
            users.add(user);
        }
    }

![](https://img2024.cnblogs.com/blog/1171560/202502/1171560-20250206233550787-2074026096.gif "点击并拖拽以移动")

3、Colleague: 同事类

    // Colleague: 同事类
    abstract class User {
        protected ChatRoom chatRoom;
        protected String name;
    
        public User(ChatRoom chatRoom, String name) {
            this.chatRoom = chatRoom;
            this.name = name;
        }
    
        public String getName() {
            return name;
        }
    
        public abstract void sendMessage(String message);
        public abstract void receiveMessage(String message);
    }

![](https://img2024.cnblogs.com/blog/1171560/202502/1171560-20250206233550787-2074026096.gif "点击并拖拽以移动")

4、ConcreteColleague: 具体同事类

    // ConcreteColleague: 具体同事类
    class ConcreteUser extends User {
        public ConcreteUser(ChatRoom chatRoom, String name) {
            super(chatRoom, name);
        }
    
        @Override
        public void sendMessage(String message) {
            chatRoom.sendMessage(message, this);
        }
    
        @Override
        public void receiveMessage(String message) {
            System.out.println(name + " received: " + message);
        }
    }

![](https://img2024.cnblogs.com/blog/1171560/202502/1171560-20250206233550787-2074026096.gif "点击并拖拽以移动")

5、客户端

    // 客户端代码
    public class MediatorPatternDemo {
        public static void main(String[] args) {
            ConcreteChatRoom chatRoom = new ConcreteChatRoom();
    
            User user1 = new ConcreteUser(chatRoom, "Alice");
            User user2 = new ConcreteUser(chatRoom, "Bob");
            User user3 = new ConcreteUser(chatRoom, "Charlie");
    
            chatRoom.addUser(user1);
            chatRoom.addUser(user2);
            chatRoom.addUser(user3);
    
            user1.sendMessage("Hi everyone!");
            user2.sendMessage("Hello Alice!");
        }
    }

![](https://img2024.cnblogs.com/blog/1171560/202502/1171560-20250206233550787-2074026096.gif "点击并拖拽以移动")

中介者模式的**优缺点。**

优点：

*   降低耦合度：通过将对象的交互逻辑集中到中介者中，减少了对象之间的直接依赖。
*   易于扩展：如果需要添加新的同事类，只需让其继承User类并实现相关功能，而不需要修改其他对象的代码。
*   集中控制：所有交互逻辑都集中在中介者类中，便于管理和控制复杂的交互流程。

缺点：

*   中介者过于复杂：当系统中的对象过多时，中介者可能会变得非常复杂，甚至成为“上帝对象”。
*   不适用所有场景：对于简单的系统，使用中介者模式可能会过度设计，反而增加了不必要的复杂性。

坚持往前走，不回头、不放弃，冰封万里也能走到春暖花开。-- 烟沙九洲

◀