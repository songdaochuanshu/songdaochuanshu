---
layout: post
title: '【EDK2】在UDK2018中实现兼容Vscode中的Edk2Code插件'
date: "2025-08-19T00:42:03Z"
---
【EDK2】在UDK2018中实现兼容Vscode中的Edk2Code插件
=====================================

原理
==

**新版 EDK2** 的确把“生成编译信息（compile\_commands.json 等）”做在 **BaseTools/Source/Python/build/BuildReport.py** 里的 **BuildReport** 类里，并通过 `-Y COMPILE_INFO -y BuildReport.log` 开关触发。

官方 issue / 文档和扩展插件都在用这个开关（不是 REPORT\_INFO）来生成 `Build/…/CompileInfo/compile_commands.json` 等文件。

其中`-Y COMPILE_INFO -y BuildReport.log`编译选项是近期才加上的，不能兼容老版本的UDK2018，很多现有的项目是基于老版EDK2，因此，需要改动做一些兼容。

代码修改
====

改动一：BuildReport.py
------------------

> 文件：`BaseTools/Source/Python/build/BuildReport.py`

1）在文件顶部 import 区补充（如已有相同 import 可略过）：

    import json
    
    from Common.Misc import SaveFileOnChange
    from Common.DataType import TAB_COMPILER_MSFT
    

2）在 `class BuildReport():` 内添加方法：

       def GenerateCompileInfo(self):
           """
           生成供 IDE/clangd/vscode 使用的编译数据库，以及辅助文件。
           输出目录：<Build>/<BuildTarget>/<ToolChain>/CompileInfo/
           输出文件：compile_commands.json, cscope.files, module_report.json
           """
           try:
               compile_commands = []
               used_files = set()
               module_report = []
               # self.ReportList 由现有 BuildReport 逻辑维护（与原有报表一致）
               for (Wa, MaList) in self.ReportList:
                   # 工作区已处理文件（尽可能多地记录）
                   try:
                       for fp in Wa._GetMetaFiles(Wa.BuildTarget, Wa.ToolChain):
                           used_files.add(fp)
                   except Exception:
                       pass
                   for autogen in Wa.AutoGenObjectList:
                       # 遍历模块与库（与新版 EDK2 的思路一致）
                       for module in (autogen.LibraryAutoGenList + autogen.ModuleAutoGenList):
                           used_files.add(module.MetaFile.Path)
                           # —— 可选：模块摘要（用于 module_report.json）——
                           md = {
                               "Name": module.Name,
                               "Arch": module.Arch,
                               "Path": module.MetaFile.Path,
                               "Guid": getattr(module, "Guid", ""),
                               "BuildType": getattr(module, "BuildType", ""),
                               "IsLibrary": getattr(module, "IsLibrary", False),
                               "SourceDir": getattr(module, "SourceDir", ""),
                               "Files": [],
                               "Libraries": [],
                               "Packages": [],
                               "PPI": [],
                               "Protocol": [],
                               "Pcd": []
                           }
                           for sf in module.SourceFileList:
                               md["Files"].append({"Name": sf.Name, "Path": sf.Path})
                           for libag in getattr(module, "LibraryAutoGenList", []):
                               md["Libraries"].append({"Path": libag.MetaFile.Path})
                           for pkg in getattr(module, "PackageList", []):
                               entry = {"Path": pkg.MetaFile.Path, "Includes": []}
                               for inc in getattr(pkg, "Includes", []):
                                   entry["Includes"].append(inc.Path)
                               md["Packages"].append(entry)
                           for k in getattr(module, "PpiList", {}).keys():
                               md["PPI"].append({"Name": k, "Guid": module.PpiList[k]})
                           for k in getattr(module, "ProtocolList", {}).keys():
                               md["Protocol"].append({"Name": k, "Guid": module.ProtocolList[k]})
                           for pcd in getattr(module, "LibraryPcdList", []):
                               md["Pcd"].append({
                                   "Space": getattr(pcd, "TokenSpaceGuidCName", ""),
                                   "Name": getattr(pcd, "TokenCName", ""),
                                   "Value": getattr(pcd, "TokenValue", ""),
                                   "Guid": getattr(pcd, "TokenSpaceGuidValue", ""),
                                   "DatumType": getattr(pcd, "DatumType", ""),
                                   "Type": getattr(pcd, "Type", ""),
                                   "DefaultValue": getattr(pcd, "DefaultValue", "")
                               })
                           module_report.append(md)
                           # 生成 compile_commands 项（仅 C/C++ 源）
                           inc_flag = "/I" if module.BuildRuleFamily == TAB_COMPILER_MSFT else "-I"
                           for src in module.SourceFileList:
                               used_files.add(src.Path)
                               if src.Ext not in [".c", ".cc", ".cpp", ".cxx"]:
                                   continue
                               # 基于 BuildRules 获取单条编译命令模板
                               try:
                                   rule_cmd = module.BuildRules[src.Ext].CommandList[0]
                               except Exception:
                                   # 回退：无法解析就跳过该文件
                                   continue
                               # 展开 $(VAR) 变量（与新版实现思路一致，尽量保守）
                               def _expand_var(m):
                                   token = m.group(1)
                                   parts = token.split("_")
                                   try:
                                       if len(parts) == 1:
                                           return module.BuildOption[parts[0]]["PATH"]
                                       else:
                                           return module.BuildOption[parts[0]][parts[1]]
                                   except Exception:
                                       return ""
                               build_cmd = re.sub(r"\$\((.*?)\)", _expand_var, rule_cmd)
                               # 处理常见占位：${src}（包含路径列表），${dst}（输出目录）
                               try:
                                   incs = getattr(module, "IncludePathList", [])
                                   # 构造 “/Ipath1 /Ipath2 …”
                                   inc_blob = " ".join([(inc_flag + "\"" + inc + "\"") if " " in inc else (inc_flag + inc) for inc in incs])
                                    build_cmd = build_cmd.replace("${src}", inc_blob)
                                    build_cmd = build_cmd.replace("${dst}", getattr(module, "OutputDir", ""))
                                except Exception:
                                    pass
    
                                # 清理未展开残留形如 $(XXX) 的片段
                                build_cmd = re.sub(r"\$\((?:.*?)\)", "", build_cmd).strip()
    
                                # compilation database 条目
                                entry = {
                                    "file": src.Path,                 # 保持与 EDK2 新版一致：绝对路径
                                    "directory": src.Dir,             # 编译时工作目录
                                    "command": build_cmd              # MSVC 风格 cl.exe 命令
                                }
                                compile_commands.append(entry)
    
                # 输出目录：Build/.../CompileInfo
                compile_info_dir = os.path.join(Wa.BuildDir, "CompileInfo")
                if not os.path.isdir(compile_info_dir):
                    try:
                        os.makedirs(compile_info_dir)
                    except Exception:
                        pass
    
                # 排序并写出
                compile_commands.sort(key=lambda x: x["file"])
                SaveFileOnChange(os.path.join(compile_info_dir, "compile_commands.json"),
                                 json.dumps(compile_commands, indent=2), False)
                SaveFileOnChange(os.path.join(compile_info_dir, "cscope.files"),
                                 "\n".join(sorted(used_files)), False)
                module_report.sort(key=lambda x: x["Path"])
                SaveFileOnChange(os.path.join(compile_info_dir, "module_report.json"),
                                 json.dumps(module_report, indent=2), False)
    
            except Exception:
                from Common import EdkLogger
                import traceback, platform, sys
                EdkLogger.error("BuildReport", 0, "Unknown fatal error when generating compile information",
                                ExtraData=getattr(self, "ReportFile", None), RaiseError=False)
                EdkLogger.quiet("(Python %s on %s\n%s)" % (platform.python_version(), sys.platform, traceback.format_exc()))
    
    

**3）在生成报表的入口处挂钩调用（`GenerateReport` 里追加判断）：**  
找到 `def GenerateReport(self, BuildDuration, AutoGenTime, MakeTime, GenFdsTime):`在它写日志/报表的 try 块开头，加上：  

**4）在下图所示加入一行：**  

改动二：build.py（给 `-Y` 添加 `COMPILE_INFO` 选项）
-----------------------------------------

> 文件：`BaseTools/Source/Python/build/build.py`

找到命令行解析对 `-Y/--report-type` 的定义，把允许值里**加入** `COMPILE_INFO`。

        Parser.add_option("-Y", "--report-type", action="append", type="choice", choices=['PCD', 'LIBRARY', 'FLASH', 'DEPEX', 'BUILD_FLAGS', 'FIXED_ADDRESS', 'HASH', 'EXECUTION_ORDER', 'COMPILE_INFO'], dest="ReportType", default=[],
            help="Flags that control the type of build report to generate.  Must be one of: [PCD, LIBRARY, FLASH, DEPEX, BUILD_FLAGS, FIXED_ADDRESS, HASH, EXECUTION_ORDER, COMPILE_INFO].  "\
    

改动三：Common/Datatype.py
----------------------

> 文件：`BaseTools/Source/Python/Common/Datatype.py`

在最后一行加上

    TAB_COMPILER_MSFT = 'MSFT'
    

使用与验证
=====

使用python编译
----------

1.  `edksetup.bat`执行后，`build -h`查看`-Y` 选项下是否有`COMPILE_INFO`如果有，说明build使用的是python脚本。
2.  正常编译，但增加（注意要使用Python2.7编译UDK2018）：  
    `build -p <YourDsc> -a IA32 -t VS2015x86 -b DEBUG -Y COMPILE_INFO -y BuildReport.log` ^a359b1
3.  在你的 build 产物目录（例如 `Build/NT32IA32/DEBUG_VS2015x86/CompileInfo/`）应出现：

*   `compile_commands.json`
*   `cscope.files`
*   `module_report.json`

VS Code（MS 的 C/C++ 插件）设置 **C/C++: Compile Commands** 指向上面的 `compile_commands.json`。**我推荐使用clangd，因为生成的这个json文件很大，C/C++插件总是索引很慢，知道怎么解决的大佬请留言，感谢！**

安装了Edk2Code插件后，`ctrl + shift + p` 输入`EDK2: rebuild index database`，选择你编译后的`./EDK2/Build`目录，让 Edk2Code正确索引database。官方与社区都推荐用这个流程。

如果发现`build -h`的`-Y`没有`COMPILE_INFO`，则证明使用的是build.exe编译，可以将`EDK2/BaseTools/Bin/Win32/build.exe`重命名为`1build.exe`，这样EDK2会自动使用python编译。

使用build.exe编译
-------------

如果没有环境，无法使用python编译，则麻烦一些，需要将build.py 编译为build.exe。

1.  python注意版本是2.7.14，另外还需要安装`cx_Freeze-4.2.3.win-amd64-py2.7.msi`，这个版本的`cx_Freeze`不好找，如果需要可以联系我。
2.  备份一个`EDK2/Basetools`整个目录
3.  在`EDK2/Basetools/` 目录下，进入cmd，运行`nmake /f Makefile clean`，再运行`nmake /f Makefile`
4.  将编译好的`build.exe`以及`Genfds.exe`替换原来的，这样就可以使用`build.exe`
5.  按照[从这开始的操作步骤](#%5Ea359b1)，一步步也可以生成`Build/.../CompileInfo`整个文件夹。

**点个赞再走!!!!!**
--------------