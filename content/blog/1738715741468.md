---
layout: post
title: '六. Redis当中的“发布” 和 “订阅” 的详细讲解说明(图文并茂)'
date: "2025-02-05T00:35:41Z"
---
六. Redis当中的“发布” 和 “订阅” 的详细讲解说明(图文并茂)
====================================

七. Redis 当中 Jedis 的详细刨析与使用
==========================

@

目录

*   [七. Redis 当中 Jedis 的详细刨析与使用](#七-redis-当中-jedis-的详细刨析与使用)
*   [1\. Jedis 概述](#1-jedis-概述)
*   [2\. Java程序中使用Jedis 操作 Redis 数据](#2-java程序中使用jedis-操作-redis-数据)
    *   [2.1 Java 程序使用 Jedis 连接 Redis 的注意事项](#21-java-程序使用-jedis-连接-redis-的注意事项)
    *   [2.2 Java程序通过 Jedis当中操作 Redis 的 key 键值对](#22-java程序通过-jedis当中操作-redis-的-key-键值对)
    *   [2.3 Java程序通过 Jedis 当中操作 Redis 的 string 字符串](#23--java程序通过-jedis-当中操作-redis-的-string-字符串)
    *   [2.4 Java程序通过 Jedis 当中操作 Redis 的 list 列表](#24-java程序通过-jedis-当中操作-redis-的-list-列表)
    *   [2.5 Java程序通过 Jedis 当中操作 Redis 的 set 集合](#25-java程序通过-jedis-当中操作-redis-的-set-集合)
    *   [2.6 Java程序通过 Jedis 当中操作 Redis 的 hash 哈希表](#26-java程序通过-jedis-当中操作-redis-的-hash-哈希表)
    *   [2.7 Java程序通过 Jedis 当中操作 Redis 的 Zset 有序集合](#27-java程序通过-jedis-当中操作-redis-的-zset-有序集合)
*   [3\. 最后：](#3-最后)

* * *

1\. Jedis 概述
============

**Jedis 是 Java程序操作 Redis 的工具，就像Java操作MySQL时的JDBC一样的功能** 。

**Jedis 工作示意图：**

> ![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510225-480461558.png)

**Jedis 的API 文档：** [https://www.javadoc.io/doc/redis.clients/jedis/latest/index.html](https://www.javadoc.io/doc/redis.clients/jedis/latest/index.html)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211509927-1142474600.png)

**下面是来自一位网上网友总结的 Jedis中文文档：这里搬运了一下：** [https://blog.csdn.net/CYY941027/article/details/109110455](https://blog.csdn.net/CYY941027/article/details/109110455)

**创建 Jedis 对象，使用对应的构造器：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510077-1602289718.png)

**键值对的操作：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211509950-445264767.png)

**字符串操作：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510304-615778967.png)

**整数和浮点数操作：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510192-1415240512.png)

**列表List 操作：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510240-1626631739.png)

**集合(Set) 操作：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510202-1002186562.png)

**哈希表(Hash) 操作：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510105-1533726030.png)

**有序集合(Zsort) 操作：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510238-166764807.png)

**排序操作：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510115-115865499.png)

> **我们可以观察到上述 API 的方法，可以明显的发觉这些就是我们在 Redis 当中敲的命令，只不过是被替换成了Java当中的方法使用了。因为我们是要在Java程序当中操作 Redis 的，所以自然是要将命令转换为Java当中的方法来操作。**

2\. Java程序中使用Jedis 操作 Redis 数据
==============================

**快速入门：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510067-807617628.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510259-2045806107.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510047-722734845.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211509913-1433717997.png)

我们想要使用 jedis 需要在 pom.xml 文件当中引入相关的 jar 依赖。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510317-897735455.png)

    <dependencies>
            <!--        引入 jedis 依赖-->
            <dependency>
                <groupId>redis.clients</groupId>
                <artifactId>jedis</artifactId>
                <version>3.2.0</version>
            </dependency>
        </dependencies>
    

Java 程序通过 Jedis 连接数据库之前，需要先将 Linux 当中安装的 Redis 服务器启动起来。

    [root@localhost bin]# redis-server /etc/redis.conf # 启动 redis 服务器
    [root@localhost bin]# redis-cli # 进入到 Redis 客户端
    
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510245-1531430513.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510205-1020390979.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510302-257592859.png)

2.1 Java 程序使用 Jedis 连接 Redis 的注意事项
----------------------------------

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510326-1219028139.png)

    package com.rainbowsea.jedis;
    
    import org.junit.Test;
    import redis.clients.jedis.Jedis;
    
    public class JedisTest {
        // 连接 Redis
        @Test
        public void con() {
            // 使用 ip地址 + redis的端口的构造器方法
            Jedis jedis = new Jedis("192.168.76.145", 6379);
            String ping = jedis.ping();
            System.out.println("连接成功 ping 返回的结果 = " + ping);
    
            jedis.close();  // 关闭连接
    
        }
    }
    
    

> ip地址没错，我们是复制过来的。端口号也没错，是默认的6379 。可显示连接不上。同时还提示我们连接超时了。
> 
> ![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510231-1268674365.png)

**原因和解决方法：**

1.  第一个原因是：我们 Linux 当中的对于 6379 这个端口的防火墙是关闭的。如果防火墙是对于该 6379 端口是关闭，不是开放的。我们外界是无法连接上该端口的。所以我们需要在 Linux 当中将该 6379 端口打开开启。让我们外界(Java 程序)可以连接该 6379端口。

具体操作如下：

    [root@localhost bin]# firewall-cmd --list-all
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510218-112273380.png)

设置开放的端口号：

    [root@localhost bin]# firewall-cmd --add-port=6379/tcp --permanent
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510075-852736705.png)

> **注意：设置后开放端口以后，还得重启一下防火墙才能生效。**

重启防火墙：

    [root@localhost bin]# firewall-cmd --reload # 重启防火墙
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510139-741225428.png)

再次执行 `firewall-cmd --list-all` 命令查看是否，将 6379 端口打开成功。

    [root@localhost bin]# firewall-cmd --list-all
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510070-1998876060.png)

2.  第二个原因：在Redis 当中的 `/etc/redis.conf` 文件当中，存在一个 `bind` ，设置：我们需要将其设置为远程访问的设置。而不是本机设置。

使用 vim 打开该文件，进行修改。

    [root@localhost bin]# vim /etc/redis.conf
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510134-1007910760.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510032-1613347574.png)

    # bind 127.0.0.1 -::1
    

同样修改了配置之后，需要关闭 Redis 服务，再启动 Redis 服务，配置才能生效。

    [root@localhost ~]# redis-cli -p 6379 shutdown # 关闭 Redis 服务
    

    [root@localhost bin]# redis-server /etc/redis.conf # 重启Redis 服务器
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510137-289910093.png)

3.  第三个原因：我们还需要将 `protected-mode yes` 修改为 `no` 关闭保护模式，如下图所示

    protected-mode no
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510111-1444963063.png)

同样修改了配置之后，需要关闭 Redis 服务，再启动 Redis 服务，配置才能生效。

我们再次尝试在Java程序当中连接 Redis 。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510079-706486572.png)

4.  Redis 默认是没有配置密码的，但是，没有密码的话，我们 Jedis 会认为是不安全的。我们为 Redis 配置密码。在 `/etc/redis.conf` 文件当中的 `requirepass` 配置密码。如下图所示：

     requirepass rainbowsea
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510108-2046135072.png)

同样修改了配置之后，需要关闭 Redis 服务，再启动 Redis 服务，配置才能生效。

设置密码后：使用 `auth 密码` 登录。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510253-1958218017.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510228-2093156931.png)

我们再次尝试在Java程序当中连接 Redis 。

> **注意：** 这里我们 Redis 设置了密码，所以我们Java程序连接的时候，需要先执行 `auth()` 方法进行一个认证登录，才能连接上 Redis 服务。不然是无法连接数上的。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510101-403810123.png)

    package com.rainbowsea.jedis;
    
    import org.junit.Test;
    import redis.clients.jedis.Jedis;
    
    public class JedisTest {
        // 连接 Redis
        // 1. 如果Redis 设置了密码，则需要进行身份校验
        // 2. 因为需要连接到 redis端口，比如6379，就需要配置防火墙，放开端口
        // 3. 注意修改 bind ，支持远程连接
        // 4 注意关闭保护模式，protected-mode no ，no表示关闭
        // 5. 注意：设置了密码，需要执行 auth(密码)进行身份验证
        @Test
        public void con() {
            // 使用 ip地址 + redis的端口的构造器方法
            Jedis jedis = new Jedis("192.168.76.145", 6379);
    
            // 如果Redis 配置了密码，则需要进行身份校验
            jedis.auth("rainbowsea");
            String ping = jedis.ping();
            System.out.println("连接成功 ping 返回的结果 = " + ping);
    
            jedis.close();  // 关闭当前连接，注意并没有关闭 Redis
    
        }
    }
    
    

2.2 Java程序通过 Jedis当中操作 Redis 的 key 键值对
--------------------------------------

> 在 Redis 当中是什么命令操作 key的，那么在Java程序中就以该命令的方法操作 key

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510277-1696604569.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510189-1395340419.png)

    
    import org.junit.Test;
    import redis.clients.jedis.Jedis;
    
    import java.util.Set;
    
    public class JedisTest {
        // key 操作
        @Test
        public void key() {
            // 创建 jedis 连接对象
            Jedis jedis = new Jedis("192.168.76.145", 6379);
            // 密码身份登录
            jedis.auth("rainbowsea");
    
            jedis.set("k1", "v1");
            jedis.set("k2", "v2");
            jedis.set("k3", "v3");
    
            // 获取key
            Set<String> keys = jedis.keys("*");
            for (String key : keys) {
                System.out.println("key=>" + key);
            }
    
            // 判断 key 是否存在
            System.out.println("exists:" + jedis.exists("k1")); // True
            System.out.println("exists: " + jedis.exists("k99"));
            // ttl
            System.out.println("ttl:" + jedis.ttl("k2"));
    
            System.out.println("k3 = " + jedis.get("k3")); // v3
    
            jedis.close();// 关闭当前连接
    
        }
    }
    

2.3 Java程序通过 Jedis 当中操作 Redis 的 string 字符串
------------------------------------------

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510262-1308995900.png)

    
    import org.junit.Test;
    import redis.clients.jedis.Jedis;
    
    import java.util.List;
    import java.util.Set;
    
    public class JedisTest {
        // string 操作
    
        @Test
        public void string() {
            // 创建 jedis 连接对象
            Jedis jedis = new Jedis("192.168.76.145", 6379);
            // 密码身份登录
            jedis.auth("rainbowsea");
    
            // 批量设置k-v
            jedis.mset("s1","jack","s2","scott","s3","rainbow");
    
            // 批量获取
            List<String> mget = jedis.mget("s1", "s2");
            for (String s : mget) {
                System.out.println("s -> " + s);
            }
    
            jedis.close();
    
        }
    }
    

2.4 Java程序通过 Jedis 当中操作 Redis 的 list 列表
---------------------------------------

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510143-66291464.png)

    
    import org.junit.Test;
    import redis.clients.jedis.Jedis;
    
    import java.util.List;
    import java.util.Set;
    
    public class JedisTest {
        // list 操作
    
        @Test
        public void list() {
            // 创建 jedis 连接对象
            Jedis jedis = new Jedis("192.168.76.145", 6379);
            // 密码身份登录
            jedis.auth("rainbowsea");
    
            // 添加 list 数据
            jedis.lpush("name_list", "jack", "tom", "nono");
    
            List<String> nameList = jedis.lrange("name_list", 0, -1);
            for (String name : nameList) {
                System.out.println("name -->" + name);
            }
    
            jedis.close();
    
        }
    }
    

2.5 Java程序通过 Jedis 当中操作 Redis 的 set 集合
--------------------------------------

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510187-2010199208.png)

    
    import org.junit.Test;
    import redis.clients.jedis.Jedis;
    
    import java.util.List;
    import java.util.Set;
    
    public class JedisTest {
        // set 操作
        @Test
        public void set() {
            // 创建 jedis 连接对象
            Jedis jedis = new Jedis("192.168.76.145", 6379);
            // 密码身份登录
            jedis.auth("rainbowsea");
    
            jedis.sadd("city","北京","上海");
            jedis.sadd("city","广州");
            jedis.sadd("city","深圳");
    
            Set<String> smembers = jedis.smembers("city");
            for (String city : smembers) {
                System.out.println("city -->" + city);
            }
    
            jedis.close(); // 关闭连接
        }
    }
    

2.6 Java程序通过 Jedis 当中操作 Redis 的 hash 哈希表
----------------------------------------

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510073-2055638016.png)

    
    import org.junit.Test;
    import redis.clients.jedis.Jedis;
    
    import java.util.List;
    import java.util.Set;
    
    public class JedisTest {
        // hash操作
        @Test
        public void hash() {
            // 创建 jedis 连接对象
            Jedis jedis = new Jedis("192.168.76.145", 6379);
            // 密码身份登录
            jedis.auth("rainbowsea");
    
            jedis.hset("hash01", "name", "李白");
            jedis.hset("hash01", "age", "18");
    
            // 获取hash 的值
            String name = jedis.hget("hash01", "name");
            System.out.println("name - >" + name);
            jedis.close();
    
    
    
        }
    }
    

也可以先构建一个 Java的 map,然后再加入到 Redis 当中的 hash 值当中。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211509904-711204200.png)

    
    import org.junit.Test;
    import redis.clients.jedis.Jedis;
    
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
    import java.util.Set;
    
    public class JedisTest {
        // hash操作
    
        @Test
        public void hash2() {
            // 创建 jedis 连接对象
            Jedis jedis = new Jedis("192.168.76.145", 6379);
            // 密码身份登录
            jedis.auth("rainbowsea");
    
            // 先构建一个Java的map
            Map<String, String> maps = new HashMap<>();
    
            maps.put("job", "Java工程师");
            maps.put("name", "李华");
            maps.put("emial", "lihua@qq.com");
    
            jedis.hset("hash02", maps);
    
            // 获取hash 的值
            List<String> person = jedis.hmget("hash02", "name", "job", "emial");
            for (String s : person) {
                System.out.println("s = >" + s);
            }
    
            jedis.close();
    
    
        }
    }
    

2.7 Java程序通过 Jedis 当中操作 Redis 的 Zset 有序集合
-----------------------------------------

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510310-160267531.png)

    
    import org.junit.Test;
    import redis.clients.jedis.Jedis;
    
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
    import java.util.Set;
    
    public class JedisTest {
    
    
        // zset 有序集合操作
        @Test
        public void zset() {
            // 创建 jedis 连接对象
            Jedis jedis = new Jedis("192.168.76.145", 6379);
            // 密码身份登录
            jedis.auth("rainbowsea");
    
            jedis.zadd("heros", 1, "关羽");
            jedis.zadd("heros", 2, "张飞");
            jedis.zadd("heros", 3, "赵云");
            jedis.zadd("heros", 4, "马超");
            jedis.zadd("heros", 5, "黄忠");
    
    
            // 取出
            Set<String> heros = jedis.zrange("heros", 0, -1);  // 默认是升序(根据 score 评分值升序)
            for (String hero : heros) {
                System.out.println("hero = " + hero);
            }
            jedis.close();
        }
    }
    

> **注意：** 可以使用 `zrevrange()` 方法/命令，是个**降序(根据 score评分值进行降序)**
> 
>     Set<String> heros = jedis.zrevrange("heros", 0, -1);  // 降序(根据 score 评分值降序)
>     

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510160-1883785077.png)

    
    import org.junit.Test;
    import redis.clients.jedis.Jedis;
    
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
    import java.util.Set;
    
    public class JedisTest {
        // zset 有序集合操作
        @Test
        public void zset() {
            // 创建 jedis 连接对象
            Jedis jedis = new Jedis("192.168.76.145", 6379);
            // 密码身份登录
            jedis.auth("rainbowsea");
    
            jedis.zadd("heros", 1, "关羽");
            jedis.zadd("heros", 2, "张飞");
            jedis.zadd("heros", 3, "赵云");
            jedis.zadd("heros", 4, "马超");
            jedis.zadd("heros", 5, "黄忠");
    
    
            // 取出
            //Set<String> heros = jedis.zrange("heros", 0, -1);  // 默认是升序(根据 score 评分值升序)
            Set<String> heros = jedis.zrevrange("heros", 0, -1);  // 降序(根据 score 评分值降序)
            for (String hero : heros) {
                System.out.println("hero = " + hero);
            }
            jedis.close();
        }
    }
    

3\. 最后：
=======

感谢网友的总结：[https://blog.csdn.net/CYY941027/article/details/109110455](https://blog.csdn.net/CYY941027/article/details/109110455)

> “在这个最后的篇章中，我要表达我对每一位读者的感激之情。你们的关注和回复是我创作的动力源泉，我从你们身上吸取了无尽的灵感与勇气。我会将你们的鼓励留在心底，继续在其他的领域奋斗。感谢你们，我们总会在某个时刻再次相遇。”
> 
> ![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250203211510558-426034258.gif)