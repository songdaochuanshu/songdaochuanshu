---
layout: post
title: '分享二个实用正则'
date: "2025-10-26T00:43:58Z"
---
分享二个实用正则
========

正则表达式是一种用于匹配和操作文本的强大工具。它由一系列字符和特殊字符组成，用于描述要匹配的文本模式。最近看到二个我觉得很实用的正则使用方式，一起来看看吧

前言
--

**正则表达式**（Regular Expression，简称regex或regexp）是一种用于匹配和操作文本的强大工具。它由一系列字符和特殊字符（称为元字符）组成，用于描述要匹配的文本模式。正则表达式可以在文本中查找、替换、提取和验证特定的模式  
最近看到二个我觉得很实用的正则使用方式，特写文章记录下来

数字千分位处理
-------

功能：把数字1234567转为1,234,567  
代码如下：

    /**
     * 数字千分位处理（对于非数字返回null）
     * @param {number} value - 需要进行千分位格式化的数字
     * @returns {string | null} - 千分位格式化后的结果
     */
    function formatNumber(value) {
        if (isNaN(value)) return null;
        // 先将数字转为字符串，并分割整数和小数部分
        const [integerPart, decimalPart] = `${value}`.split('.');
        // 只对整数部分添加千位分隔符
        const formattedInteger = integerPart.replace(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/g, "$1,");
        // 如果有小数部分，重新组合
        return decimalPart ? `${formattedInteger}.${decimalPart}` : formattedInteger;
    }
    

正则表达式分解：

*   (\\d) - 捕获组1：匹配任意一个数字
*   (?=...) - 正向预查：匹配后面跟特定内容的位置
*   (\\d\\d\\d)+ - 捕获组2：匹配3个数字，可以重复一次或多次
*   (?!\\d) - 负向预查：确保后面没有其他数字
*   /g - 全局匹配标志

工作原理：

让我们用一个具体例子来说明，比如数字 "1234567"：  
分析正则匹配过程：

a. 第一次匹配：

    * (\\d) 匹配到 "1"
    * (?=(\\d\\d\\d)+(?!\\d)) 向前预查：
    发现后面有 "234567"
    符合 (\\d\\d\\d)+ 模式（"234" 和 "567"）
    最后一位后面没有数字（(?!\\d)）
    匹配成功，替换为 "1,"
    

b. 失败的匹配：

    * 逗号后继续
    * (\\d) 匹配到 "2"
    * 向前预查发现后面是 "34567"
    * 符合 (\\d\\d\\d)+ 模式（"345"）
    * 但后面还有 "67"，不符合 (?!\\d)
    * 匹配失败
    

c. 成功的匹配：

    * 继续向前
    * (\\d) 匹配到 "4"
    * 向前预查发现后面是 "567"
    * 符合 (\\d\\d\\d)+ 模式
    * 最后一位后面没有数字
    * 匹配成功，替换为 "4,"
    * 最终结果：
    * 原始数字 "1234567" → "1,234,567"
    

依次把所有数字匹配完成  
限制条件：

    不处理小数部分
    不处理负号
    只在正确的千分位位置添加逗号
    不会在数字开头添加逗号
    

强密码验证
-----

在做用户登录/注册的时候，有的要求用户的账号密码必须是强密码，如必须是有大小写字母数字加特殊字符  
代码如下：

    /**
     * 验证密码（所有验证逻辑整合到单个正则中）
     * @param {string} password - 需要验证的密码
     * @param {number} [minLength=8] - 最小长度
     * @param {number} [maxLength=32] - 最大长度
     * @param {string} [allowedSpecials='!@#$%^&*()'] - 允许的特殊字符集合
     * @returns {Object} - 验证结果和错误信息
     */
    function validatePassword(
      password,
      minLength = 8,
      maxLength = 32,
      allowedSpecials = '!@#$%^&*()'
    ) {
      const errors = [];
    
      // 特殊字符转义（处理正则元字符）
      const escapedSpecials = allowedSpecials.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');
    
      // 整合长度验证的正则表达式
      // 核心：在原正则基础上添加长度限制 {minLength, maxLength}
      const regex = new RegExp(
        `^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[${escapedSpecials}]).{${minLength},${maxLength}}$`
      );
    
      if (!regex.test(password)) {
        // 长度错误检查
        if (password.length < minLength) {
          errors.push(`密码长度不能少于${minLength}个字符`);
        }
        if (password.length > maxLength) {
          errors.push(`密码长度不能超过${maxLength}个字符`);
        }
    
        // 字符类型错误检查
        if (!/[a-z]/.test(password)) errors.push("必须包含至少一个小写字母");
        if (!/[A-Z]/.test(password)) errors.push("必须包含至少一个大写字母");
        if (!/\\d/.test(password)) errors.push("必须包含至少一个数字");
        if (!new RegExp(`[${escapedSpecials}]`).test(password)) {
          errors.push(`必须包含至少一个特殊字符（允许的字符：${allowedSpecials}）`);
        }
      }
    
      return {
        isValid: errors.length === 0,
        errors: errors
      };
    }
    

*   特殊字符转义，处理 allowedSpecials
    
    作用：将 allowedSpecials 中包含的「正则元字符」（如 \*、(、$ 等）转义为普通字符（如 \* → \*），避免破坏正则语法。
    
    例如：若 allowedSpecials 是 '$_()'，转义后变为 '$_()'（字符串中显示为 $\*()）。
    

    const escapedSpecials = allowedSpecials.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');
    

*   核心正则表达式详解  
    这里用 new RegExp() 动态生成正则，将转义后的特殊字符（escapedSpecials）和密码长度验证嵌入正则中。  
    假设 allowedSpecials 是默认的 '!@#$%^&\*()'，转义后 escapedSpecials 为 '!@#$%^&\*()'，假设minLength为8，maxLength为32，则生成的正则字符串为：
    
        ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#\\$%\\^&\\*\\(\\)]).{8,32}$
        
    
    这是一个包含4 个正向预查的正则，用于强制要求密码同时满足多种字符类型。我们逐个拆解：
    
    正则部分
    
    含义解释
    
    `^`
    
    匹配字符串的开始位置（确保从开头就检查，避免只匹配部分字符串）。
    
    `(?=.*[a-z])`
    
    正向预查：确保字符串中至少有一个小写字母（`[a-z]`）。  
    \- `.*` 表示任意字符（除换行）重复任意次（包括 0 次）。  
    \- 整体含义：“从当前位置开始，后面存在至少一个小写字母”。
    
    `(?=.*[A-Z])`
    
    正向预查：确保字符串中至少有一个大写字母（`[A-Z]`）。
    
    `(?=.*\\d)`
    
    正向预查：确保字符串中至少有一个数字（`\\d` 等价于 `[0-9]`）。
    
    `(?=.*[!@#$%^&*()])`
    
    正向预查：确保字符串中至少有一个允许的特殊字符（即 `allowedSpecials` 中指定的字符）。
    
    `.{8,32}`
    
    表示 “匹配任意字符（除换行），且长度在 minLength 到 maxLength 之间
    
    `$`
    
    匹配字符串的结束位置（确保检查到字符串末尾，避免遗漏）。
    

小结
--

正则又叫火星文，它的用法千千万，个人知识有限，如果你有一些更好的正则好用的方式，欢迎留言分享，一起学习一起进步

好好学习！天天向上！