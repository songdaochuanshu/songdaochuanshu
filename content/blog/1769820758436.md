---
layout: post
title: 'stable_baseline3 å¿«é€Ÿå…¥é—¨(äºŒ): è®­ç»ƒè‡ªå®šä¹‰æ¸¸æˆï¼Œæ„å»ºGymnasiumè®­ç»ƒç¯å¢ƒ'
date: "2026-01-31T00:52:38Z"
---
stable\_baseline3 å¿«é€Ÿå…¥é—¨(äºŒ): è®­ç»ƒè‡ªå®šä¹‰æ¸¸æˆï¼Œæ„å»ºGymnasiumè®­ç»ƒç¯å¢ƒ
==================================================

ç®€ä»‹
==

**Gymnasium** ä¸ºå¼ºåŒ–å­¦ä¹ æä¾›äº†ä¸€ä¸ªæ ‡å‡†åŒ–çš„APIï¼Œå®ƒå®šä¹‰äº† Agent åº”è¯¥å¦‚ä½•è§‚å¯Ÿä¸–ç•Œã€å¦‚ä½•åšå‡ºåŠ¨ä½œä»¥åŠå¦‚ä½•è·å¾—å¥–åŠ±ï¼Œä¸ç®¡æ˜¯æ¸¸æˆï¼Œè¿˜æ˜¯å·¥ä¸šè®¾å¤‡ï¼Œåªéœ€è¦æ»¡è¶³`Gymnasium`æ ‡å‡†éƒ½èƒ½ä½¿ç”¨åŒä¸€å¥—ä»£ç è¿›è¡Œè®­ç»ƒã€‚

è®¤è¯†Gymnasium
===========

ä½¿ç”¨`stable_baseline3`åªéœ€è¦å®šä¹‰å¥½`Gymnasium`ç¯å¢ƒï¼Œå…³æ³¨è®­ç»ƒçš„å¥–åŠ±æœºåˆ¶ï¼Œå°†é‡ç‚¹æ”¾åœ¨ä¸šåŠ¡çš„å¼€å‘ä¸Šè€Œä¸æ˜¯å¤æ‚çš„ç®—æ³•ã€‚

**Gymnasium**æä¾›äº†å‡ ä¸ªæ ¸å¿ƒçš„apiï¼š

**æ–¹æ³•**

**åŠŸèƒ½**

**è¿”å›å€¼**

**`reset()`**

å°†ç¯å¢ƒé‡ç½®ä¸ºåˆå§‹çŠ¶æ€ï¼Œå¼€å§‹æ–°å›åˆã€‚

`obs, info`

**`step(action)`**

ç¯å¢ƒå‘å‰æ¨è¿›ä¸€æ­¥ï¼Œæ‰§è¡ŒåŠ¨ä½œã€‚

`obs, reward, terminated, truncated, info`

**`render()`**

å¯è§†åŒ–ç¯å¢ƒï¼ˆæ ¹æ® `render_mode` æ¸²æŸ“å›¾åƒæˆ–å¼¹å‡ºçª—å£ï¼‰ã€‚

è§†é…ç½®è€Œå®šï¼ˆé€šå¸¸æ— æˆ–ä¸º `np.array`ï¼‰

**`close()`**

é‡Šæ”¾ç¯å¢ƒèµ„æºï¼ˆå…³é—­çª—å£ã€æ¸…ç†å†…å­˜ï¼‰ã€‚

æ— 

å…¶ä¸­çš„å„ä¸ªè¿”å›å€¼çš„å«ä¹‰ï¼š

*   **`observation` (Object)**: å½“å‰çŠ¶æ€çš„æè¿°ã€‚ä¾‹å¦‚æ•Œäººï¼Œç©å®¶çš„ä½ç½®ï¼Œç©å®¶çš„çŠ¶æ€ç­‰
*   **`reward` (Float)**: ä¸Šä¸€æ­¥åŠ¨ä½œè·å¾—çš„å¥–åŠ±
*   **`terminated` (Bool)**: æ˜¯å¦ç”±äº**ä»»åŠ¡é€»è¾‘**ç»“æŸã€‚ä¾‹å¦‚ï¼šåˆ°è¾¾ç»ˆç‚¹ã€æ‰è¿›å²©æµ†ç­‰
*   **`truncated` (Bool)**: æ˜¯å¦ç”±äº**å¤–éƒ¨é™åˆ¶**ç»“æŸã€‚ä¾‹å¦‚ï¼šè¾¾åˆ°æœ€å¤§æ­¥æ•° 500 æ­¥
*   **`info` (Dict)**: è¾…åŠ©è¯Šæ–­ä¿¡æ¯ï¼Œæ¨¡å‹è®­ç»ƒé€šå¸¸ä¸ç”¨ï¼Œç”¨äºç”¨æˆ·è‡ªå®šä¹‰è°ƒè¯•æˆ–è®°å½•é¢å¤–ç»Ÿè®¡ã€‚

æ‰‹åŠ¨æ„å»ºç¯å¢ƒ
======

### æ¡ˆä¾‹

æ¡ˆä¾‹æè¿°ï¼šåˆ©ç”¨pygameæ„å»ºä¸€ä¸ªç®€å•çš„æ¸¸æˆï¼Œèº²é¿æ‰è½æ–¹å—ï¼Œåˆ©ç”¨æ„å»ºçš„å¥–åŠ±æœºåˆ¶ï¼Œè¿›è¡Œå¼ºåŒ–å­¦ä¹ ã€‚

    import gymnasium as gym
    from gymnasium import spaces
    import numpy as np
    import pygame
    import random
    import cv2
    import os
    from stable_baselines3 import PPO
    from stable_baselines3.common.callbacks import CheckpointCallback
    from stable_baselines3.common.env_checker import check_env
    
    class MyEnv(gym.Env):
        def __init__(self, render_mode=None):
            super(MyEnv, self).__init__()
    
            #åˆå§‹åŒ–å‚æ•°
            self.width = 400
            self.height = 300
            self.player_size = 30
            self.enemy_size = 30
            self.render_mode = render_mode
    
            self.action_space = spaces.Discrete(3)
    
            self.observation_space = spaces.Box(
                low=0, high=255, shape=(84, 84, 3), dtype=np.uint8
            )
    
            pygame.init()
            if self.render_mode == "human":
                self.screen = pygame.display.set_mode((self.width, self.height))
            
            self.canvas = pygame.Surface((self.width, self.height))
            self.font = pygame.font.SysFont("monospace", 15)
    
        def reset(self, seed=None, options=None):
            super().reset(seed=seed)
    
            self.player_x = self.width // 2 - self.player_size // 2
            self.player_y = self.height - self.player_size - 10
            self.enemies = []
            self.score = 0
            self.frame_count = 0
    
            self.current_speed = 5
            self.spawn_rate = 30
    
            return self._get_obs(), {}
    
        def step(self, action):
            reward = 0
            terminated = False
            truncated = False
    
            move_speed = 8
            if action == 1 and self.player_x > 0: # 
                self.player_x -= move_speed
                reward -= 0.05
    
            if action == 2 and self.player_x < self.width - self.player_size:
                self.player_x += move_speed
                reward -= 0.05
    
            self.frame_count += 1
    
            level = self.score // 5
            self.current_speed = 5 + level
            self.spawn_rate = 30 - level * 2
            spawn_rate = max(10, 30 - level)
    
            if self.frame_count >= spawn_rate:
                self.frame_count = 0
                enemy_x = random.randint(0, self.width - self.enemy_size)
                self.enemies.append([enemy_x, 0]) # [x, y]
    
            for enemy in self.enemies:
                enemy[1] += self.current_speed
                
                player_rect = pygame.Rect(self.player_x, self.player_y, self.player_size, self.player_size)
                enemy_rect = pygame.Rect(enemy[0], enemy[1], self.enemy_size, self.enemy_size)
                
                if player_rect.colliderect(enemy_rect):
                    reward = -10 
                    terminated = True
    
                elif enemy[1] > self.height:
                    self.enemies.remove(enemy)
                    self.score += 1
                    reward = 1 
            
            if not terminated:
                if self.score > 100:
                    reward += 0.01
                reward += 0.01
    
            obs = self._get_obs()
    
            if self.render_mode == "human":
                self._render_window()
    
            return obs, reward, terminated, truncated, {}
    
        def _get_obs(self):
            self.canvas.fill((0, 0, 0))
            pygame.draw.rect(self.canvas, (50, 150, 255), (self.player_x, self.player_y, self.player_size, self.player_size))
            
            for enemy in self.enemies:
                pygame.draw.rect(self.canvas, (255, 50, 50), (enemy[0], enemy[1], self.enemy_size, self.enemy_size))
    
            img_array = pygame.surfarray.array3d(self.canvas)
            img_array = np.transpose(img_array, (1, 0, 2))
            obs = cv2.resize(img_array, (84, 84), interpolation=cv2.INTER_AREA)
    
            return obs.astype(np.uint8)
    
        def _render_window(self):
            self.screen.blit(self.canvas, (0, 0))
            text = self.font.render(f"Score: {self.score}", True, (255, 255, 255))
            self.screen.blit(text, (10, 10))
            pygame.display.flip()
    
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
    
    def train():
        log_dir = "logs/DodgeGame"
        os.makedirs(log_dir, exist_ok=True)
    
        env = MyEnv()
        check_env(env)
        print("ç¯å¢ƒæ£€æŸ¥é€šè¿‡...")
    
        model_path = "models/dodge_ai.zip"
        if not os.path.exists(model_path):
            print("ğŸ†• æœªå‘ç°æ—§æ¨¡å‹ï¼Œä»å¤´å¼€å§‹è®­ç»ƒ...")
            model = PPO(
                "CnnPolicy", 
                env, 
                verbose=1,
                tensorboard_log=log_dir,
                learning_rate=0.0001,
                n_steps=4096,
                batch_size=256,
                device="cuda")
            reset_timesteps = True
        else:
            print("å‘ç°æ—§æ¨¡å‹ï¼ŒåŠ è½½å¹¶ç»§ç»­è®­ç»ƒ...")
            model = PPO.load(
                model_path, 
                env=env,      
                device="cuda",
                custom_objects={"learning_rate": 0.0001, "n_steps": 4096, "batch_size": 256}
            )
            reset_timesteps = False
       
        print("å¼€å§‹è®­ç»ƒ...")
    
        model.learn(
            total_timesteps=50000,
            reset_num_timesteps=reset_timesteps
        )
    
        model.save("models/dodge_ai")
        print("æ¨¡å‹å·²ä¿å­˜ï¼")
        env.close()
    
    def prodict():
        env = MyEnv(render_mode="human")
        model = PPO.load("models/dodge_ai", env=env, device="cuda")
        obs, _ = env.reset()
    
        while True:
            action, _states = model.predict(obs, deterministic=True)
    
            obs, reward, terminated, truncated, info = env.step(action)
    
            if terminated or truncated:
                obs, _ = env.reset()
            
            pygame.time.Clock().tick(30)
    
    if __name__ == "__main__":
        train()
    
        prodict()
    
    

### ä»£ç è§£æ

ä»£ç æµç¨‹å¦‚ä¸‹ï¼š  
**æ„å»ºæ¸¸æˆç¯å¢ƒ->è®­ç»ƒæ¨¡å‹->æ¨¡å‹é¢„æµ‹**  
æœ¬ç¯‡é‡ç‚¹è®²æ„**å»ºæ¸¸æˆç¯å¢ƒ**ï¼Œå…¶ä¸­çš„`pygame`ç›¸å…³ä»£ç ç®€ç•¥ï¼Œå¦å¤–ä¸¤ä¸ªæµç¨‹å‚è€ƒä¹‹å‰æ–‡ç« ã€‚

#### æ„å»ºæ¸¸æˆç¯å¢ƒ

##### åˆå§‹åŒ–ç±»

è¯¥ç±»ç»§æ‰¿`gym.Env`ç±»

    class MyEnv(gym.Env):
    

##### æ„é€ å‡½æ•°\_\_init\_\_

    def __init__(self, render_mode=None):
            super(MyEnv, self).__init__()
    
            #åˆå§‹åŒ–å‚æ•°
            self.width = 400
            self.height = 300
            self.player_size = 30
            self.enemy_size = 30
            self.render_mode = render_mode
    
            self.action_space = spaces.Discrete(3)
    
            self.observation_space = spaces.Box(
                low=0, high=255, shape=(84, 84, 3), dtype=np.uint8
            )
    
            pygame.init()
            if self.render_mode == "human":
                self.screen = pygame.display.set_mode((self.width, self.height))
            
            self.canvas = pygame.Surface((self.width, self.height))
            self.font = pygame.font.SysFont("monospace", 15)
    

åœ¨æ„é€ å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦å®Œæˆçš„æ˜¯å£°æ˜è®­ç»ƒçš„ç»´åº¦ï¼Œå’Œè¾“å…¥ï¼š

*   è¾“å…¥ï¼š`self.action_space = spaces.Discrete(3)`å…¶ä¸­çš„`self.action_space`æ˜¯**å›ºå®šåç§°çš„çˆ¶ç±»å˜é‡**ã€‚`spaces.Discrete(3)`å£°æ˜è¾“å…¥çš„æ•°é‡ï¼Œä¾‹å¦‚ï¼š`å‘å·¦ å‘å³ å’Œ ä¸åŠ¨`3ä¸ªè¾“å…¥ã€‚
*   è§‚æµ‹ç»´åº¦ï¼š`self.observation_space`ä¹Ÿæ˜¯**å›ºå®šåç§°çš„çˆ¶ç±»å˜é‡**ã€‚`spaces.Box`å£°æ˜è§‚æµ‹ç»´åº¦ã€‚

    self.observation_space = spaces.Box(
        low=0, high=255, shape=(84, 84, 3), dtype=np.uint8
    )
    

1.  `low`ï¼šè§‚æµ‹å‚æ•°çš„æœ€å°å€¼
2.  `high`ï¼šè§‚æµ‹å‚æ•°çš„æœ€å¤§å€¼
3.  `shape`ï¼šå£°æ˜ç»´åº¦ã€‚ä¾‹å¦‚ï¼šè§‚æµ‹å›¾ç‰‡`shape(é«˜ï¼Œå®½ï¼ŒRGB)`ï¼Œè§‚æµ‹ä¸€ä¸ªå¹³é¢ï¼Œ`shape(é«˜,å®½)`
4.  `dtype`ï¼šæ¯ä¸ªå˜é‡ç±»å‹ï¼Œè¿™é‡Œé€‰`np.uint8`èƒ½å¤ŸèŠ‚çœè®­ç»ƒæˆæœ¬ï¼Œé»˜è®¤æ˜¯æµ®ç‚¹å‹çš„ã€‚

##### ä»»åŠ¡é‡ç½® reset

ç›¸å½“äºåˆå§‹åŒ–æ¸¸æˆçŠ¶æ€ï¼Œæ¸¸æˆçš„é‡æ–°å¼€å§‹ã€‚è¿”å›çš„æ˜¯**è§‚æµ‹å€¼**å’Œ**çŠ¶æ€ä¿¡æ¯ï¼ˆç”¨äºè°ƒè¯•æ—¥å¿—ï¼‰**

    def reset(self, seed=None, options=None):
            super().reset(seed=seed)
    
            self.player_x = self.width // 2 - self.player_size // 2
            self.player_y = self.height - self.player_size - 10
            self.enemies = []
            self.score = 0
            self.frame_count = 0
    
            self.current_speed = 5
            self.spawn_rate = 30
    
            return self._get_obs(), {}
    

**è§‚æµ‹å€¼ `_get_obs`ï¼š**  
é€šè¿‡`pygame`ç”»å‡ºçš„ç”»é¢ï¼Œç„¶åç”¨`opencv`è¿›è¡Œç®€å•å¤„ç†ï¼š

1.  è½¬æ¢åæ ‡è½´ï¼ˆç”±äº`opencv`åæ ‡xyè½´è·Ÿ`pygame`çš„xyæ˜¯é¢ å€’çš„ï¼‰
2.  å°†ç”»é¢ç¼©æ”¾åˆ°`84 * 84`ï¼ˆå¯ä»¥æé«˜è®­ç»ƒæ•ˆç‡ï¼‰

    def _get_obs(self):
            self.canvas.fill((0, 0, 0))
            pygame.draw.rect(self.canvas, (50, 150, 255), (self.player_x, self.player_y, self.player_size, self.player_size))
            
            for enemy in self.enemies:
                pygame.draw.rect(self.canvas, (255, 50, 50), (enemy[0], enemy[1], self.enemy_size, self.enemy_size))
    
            img_array = pygame.surfarray.array3d(self.canvas)
            img_array = np.transpose(img_array, (1, 0, 2))
            obs = cv2.resize(img_array, (84, 84), interpolation=cv2.INTER_AREA)
    
            return obs.astype(np.uint8)
    

##### æ­¥ stepï¼ˆé‡è¦ï¼‰

è¿™ä¸ªå‡½æ•°æ˜¯å¼ºåŒ–è®­ç»ƒçš„**æ ¸å¿ƒ**ï¼Œè§„å®šäº†åœ¨`ä¸€å¸§`æˆ–è€…`ä¸€æ­¥`ï¼Œæˆ‘ä»¬ç»™AIçš„åˆ†æ•°ã€‚  
åˆ†æ•°çš„è®¾ç½®è‡³å…³é‡è¦ï¼Œè¿™ç›´æ¥å†³å®šäº†è®­ç»ƒå‡ºæ¥AIçš„è´¨é‡  
æ ¹æ®ä¸‹é¢ä»£ç ï¼ˆå¤§éƒ¨åˆ†éƒ½æ˜¯æ¸¸æˆé€»è¾‘ï¼‰ï¼Œä¸»è¦è®²è®¾ç½®**å¥–åŠ±åˆ†æ•°**ï¼š

1.  åœ¨AIè¿›è¡Œç§»åŠ¨æ—¶ æƒ©ç½š 0.05 åˆ†
2.  åœ¨AIå­˜æ´»æ—¶ å¥–åŠ± 0.01åˆ†ï¼Œæ¸¸æˆåˆ†æ•°å¤§äº100æ—¶ å­˜æ´»å¥–åŠ± 0.02åˆ†
3.  åœ¨éšœç¢ç‰©å®Œå…¨ä¸‹è½æ—¶ å¥–åŠ± 1 åˆ†
4.  åœ¨ä¸éšœç¢ç‰©ç¢°æ’æ—¶ æƒ©ç½š 10 åˆ†

    def step(self, action):
            reward = 0
            terminated = False
            truncated = False
    
            move_speed = 8
            if action == 1 and self.player_x > 0: # 
                self.player_x -= move_speed
                reward -= 0.05
    
            if action == 2 and self.player_x < self.width - self.player_size:
                self.player_x += move_speed
                reward -= 0.05
    
            self.frame_count += 1
    
            level = self.score // 5
            self.current_speed = 5 + level
            self.spawn_rate = 30 - level * 2
            spawn_rate = max(10, 30 - level)
    
            if self.frame_count >= spawn_rate:
                self.frame_count = 0
                enemy_x = random.randint(0, self.width - self.enemy_size)
                self.enemies.append([enemy_x, 0]) # [x, y]
    
            for enemy in self.enemies:
                enemy[1] += self.current_speed
                
                player_rect = pygame.Rect(self.player_x, self.player_y, self.player_size, self.player_size)
                enemy_rect = pygame.Rect(enemy[0], enemy[1], self.enemy_size, self.enemy_size)
                
                if player_rect.colliderect(enemy_rect):
                    reward = -10 
                    terminated = True
    
                elif enemy[1] > self.height:
                    self.enemies.remove(enemy)
                    self.score += 1
                    reward = 1 
            
            if not terminated:
                if self.score > 100:
                    reward += 0.01
                reward += 0.01
    
            obs = self._get_obs()
    
            if self.render_mode == "human":
                self._render_window()
    
            return obs, reward, terminated, truncated, {}
    

##### å±•ç¤ºæ¸¸æˆç”»é¢

ä¸‹é¢å®Œå…¨æ˜¯`pygame`ä»£ç ï¼Œç”¨äºæ˜¾ç¤ºæ¸¸æˆç”»é¢ï¼Œè¿™é‡Œå°±ä¸è§£é‡Šäº†ã€‚

    def _render_window(self):
            self.screen.blit(self.canvas, (0, 0))
            text = self.font.render(f"Score: {self.score}", True, (255, 255, 255))
            self.screen.blit(text, (10, 10))
            pygame.display.flip()
    
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
    

**ä½ æˆåŠŸæˆä¸ºäº†ä¸€åè°ƒå‚ä¾ äº†ï¼Œå¿«æ¥è¯•è¯•å§ï¼**

**å¦‚æœâ¤å–œæ¬¢â¤æœ¬ç³»åˆ—æ•™ç¨‹ï¼Œå°±ç‚¹ä¸ªå…³æ³¨å§ï¼Œåç»­ä¸å®šæœŸæ›´æ–°~**