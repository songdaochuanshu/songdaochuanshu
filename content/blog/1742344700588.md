---
layout: post
title: 'halcon 入门教程（一） 预处理图像 （图像平滑，图像增强，二值化，形态学分析）'
date: "2025-03-19T00:38:20Z"
---
halcon 入门教程（一） 预处理图像 （图像平滑，图像增强，二值化，形态学分析）
==========================================

原文作者：aircraft

原文链接：[https://www.cnblogs.com/DOMLX/p/18779326](https://www.cnblogs.com/DOMLX/p/18779326)

 有兴趣可以多看其他的halcon教程

 halcon 学习教程目录

　　本来今天想写一下halcon深度学习教程（三）目标检测的，不过今天有显卡的那台电脑连不上，干脆总结一下halcon的学习入门中的一些知识好了，如果你想入门halcon图像处理，那么看完我这篇至少大概了解一些halcon的图像处理知识了，语法这里就不会写了。

　　因为学习这个之前你肯定有编程基础的比如c#.c++什么的，看到halcon的语句和例子自然就会使用了它的语法了，或者可以单独百度一下halcon语法。好多时候都是用halcon来测试算法，测试完自己在去转为c#或者c++语言编写一遍，通过halcon直接转换的数量少还好，数量一多，可读性和维护性就很差，毕竟也不是你的编程习惯写出来的，放一段时间你看的都懵逼。

**一.halcon简介**

　　HALCON是德国MVTec公司开发的一套完善的标准的[机器视觉](https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/7414484?fromModule=lemma_inlink)算法包，拥有应用广泛的机器视觉[集成开发环境](https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/298524?fromModule=lemma_inlink)。它节约了[产品成本](https://baike.baidu.com/item/%E4%BA%A7%E5%93%81%E6%88%90%E6%9C%AC/8719785?fromModule=lemma_inlink)，缩短了[软件开发](https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/3448966?fromModule=lemma_inlink)周期——HALCON灵活的架构便于机器视觉，医学图像和[图像分析](https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E5%88%86%E6%9E%90/4782592?fromModule=lemma_inlink)应用的快速开发。在欧洲以及日本的工业界已经是公认具有最佳效能的Machine Vision软件。

**二.halcon入门学习路线**

　　学习halcon最重要的是要会去看halcon提供的一个个官方的实例，里面基本把视觉算法常见的各个运用场景的例子都写出来了。实例就是最好的老师。

但是实例太多太多了，如果你是个刚开始学halcon的建议先学习下面halcon实例画线的部分。比如Blob分析，边缘提取，图像匹配定位，缺陷检测，量测，一，二维条码识别，OCR识别，特征提取等等最常见的先学习，后面我也会不断的补充教程，有兴趣可以关注一下。

　　掌握了这些后，你再去不断加深自己的halcon使用能力。其中Blob分析是入门中最重要的，也是最应该先花时间去掌握的，因为后面的各种实例里面都在疯狂的使用着Blob分析的各个知识，下面只略微介绍一下Blob分析。

　　Blob的定义：Blob是图像中具有相同或相似属性的连通区域（例如相同的灰度值、颜色或纹理）。

### **Blob分析的步骤**

1.  ​**预处理**：
    
    *   去噪（如高斯滤波、中值滤波）。
    *   增强对比度或调整光照不均。
2.  ​**二值化**：
    
    *   将图像转换为黑白二值图（例如通过阈值分割），使目标区域（Blob）与背景分离。
3.  ​**连通区域标记**：
    
    *   扫描图像，为每个连通区域分配唯一标签（如使用种子填充法或两次扫描算法）。
4.  ​**特征提取**：
    
    *   计算每个Blob的特征，例如：
        *   ​**几何特征**：面积、周长、质心、外接矩形、长宽比、圆形度。
        *   ​**灰度/颜色特征**：平均灰度、颜色分布。
        *   ​**高阶特征**：方向（主轴）、矩（用于形状描述）。
5.  ​**筛选与分析**：
    
    *   根据特征过滤无关区域（例如排除面积过小的噪声点）。
    *   分类或统计目标Blob的数量、位置、形状等。

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318142329296-290143972.png)

接下来进入正文。

**三.halcon图像预处理（图像平滑，图像增强）**

　　我们在进行一些图像识别定位，或者缺陷检测，目标识别分类等等工作任务的时候，最前面的第一个步骤就是图像预处理，图像预处理里面就包括了常见的图像变换和校正、平滑与去噪、以及增强处理，有了图像预处理后，我们才能更好的去进行后续的工作任务。

　　举个例子就是你分类垃圾，没有预处理这就是一堆杂乱的垃圾堆积在一起，各种品种都交错杂乱，预处理后，你可能要做的是把这边一样的垃圾和那边一样的垃圾选择一下他们的归类。

先从大家最喜欢看到的算子均值滤波开始（读取图像不用说吧，就是read\_image()算子直接读就行了哈。。。）：

**1.图像平滑之均值滤波算子：`mean_image(Image : ImageMean : MaskWidth, MaskHeight : ):`**

*   **输入参数**：
    *   `Image`：输入图像（单通道灰度图像）。
    *   `MaskWidth`, `MaskHeight`：滤波掩模的宽度和高度（需为奇数，如 3, 5, 7 等）。
*   ​**输出参数**：
    *   `ImageMean`：输出图像，滤波后的结果。

### **功能与原理**

1.  ​**均值滤波**：
    
    *   对图像中每个像素，取其周围 `MaskWidth × MaskHeight` 邻域内的所有像素灰度值，计算平均值后替换原像素值。通俗的话来讲就是把图像想象成一个二维的数组，你拿着一个5\*5的矩形框在数组上滑动，滑动到哪颗像素，就把这个像素在框内的周边像素的值全部加起来做个除法均值，在把均值放回这颗像素里作为他的值。
2.  ​**作用**：
    
    *   ​**平滑图像**：抑制高频噪声（如高斯噪声、椒盐噪声）。
    *   ​**模糊细节**：可用于预处理中降低纹理干扰（如 Blob 分析前去除细小噪声）。

实例代码：

\* 读取图像
read\_image(Image, 'particle.jpg')

\* 均值滤波（使用5×5掩模）
mean\_image(Image, ImageMean, 5, 5)

\* 显示结果
dev\_display(ImageMean)

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318145233792-814144828.png)

**2.图像平滑之高斯滤波算子：`` `gauss_filter(Image : ImageGauss : Size : )`: ``**

*   **输入参数**：
    *   `Image`：输入图像（单通道灰度图像）。
    *   `Size`：高斯核的尺寸（通常为奇数值，如 3, 5, 7 等）。
*   ​**输出参数**：
    *   `ImageGauss`：滤波后的输出图像。

### **高斯滤波原理：**

1.  ​**高斯核**：
    
    *   高斯滤波通过定义一个二维高斯函数（钟形曲线）作为卷积核，对图像进行加权平均。
    *   ​**高斯函数公式**：
    *   ![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318145535083-119347235.png)
        
    
    *   其中 σ 是标准差，控制滤波的平滑强度。
2.  ​**滤波过程**：
    
    *   对图像中每个像素，用高斯核覆盖其邻域，计算邻域内像素的加权平均值，权重由高斯函数决定。
    *   ​**特点**：
        *   ​**中心权重高**，边缘权重低，保留更多边缘信息。
        *   核尺寸（`Size`）越大或 σ 越大，平滑效果越强。

### **与均值滤波的对比**

特性

高斯滤波

均值滤波

​**权重分配**

中心高，边缘低（符合高斯分布）

邻域内均匀权重

​**边缘保留**

较好（边缘模糊程度低）

较差

​**抗噪能力**

对高斯噪声更有效

对均匀噪声有效

​**计算速度**

较慢（需计算高斯核）

快

实例代码：

\* 读取图像
read\_image(Image, 'defect.jpg')

\* 高斯滤波（核尺寸5×5，σ自动计算）
gauss\_filter(Image, ImageGauss, 5)

\* 显示结果
dev\_display(ImageGauss)

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318150136485-492226479.png)

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318150154716-1042854474.png)

**3.图像平滑之均值滤波算子：****`median_rect(Image : ImageMedian :MaskWidth,MaskHeight:)`**

*   **输入参数**：
    *   `Image`：输入图像（单通道灰度图像）。
    *   `MaskWidth`, `MaskHeight`：矩形掩模的宽度和高度（需为**奇数**，如 3, 5, 7 等）。
*   ​**输出参数**：
    *   `ImageMedian`：滤波后的输出图像。

### **中值滤波原理**

1.  ​**核心操作**：
    
    *   对图像中每个像素，取以该像素为中心的 `MaskWidth × MaskHeight` 邻域内所有像素的灰度值。
    *   将邻域内的像素值排序，取**中间值**​（中位数）作为当前像素的新值。
2.  ​**处理过程**：参考均值滤波，说白了就是把矩形框内所有像素值排序取中间值填入像素。
    
3.  ​**特点**：
    
    *   ​**非线性滤波**：不依赖线性运算，对极端噪声（如椒盐噪声）鲁棒。
    *   ​**边缘保留**：中位数对局部极值不敏感，能有效保护边缘信息。

### **功能与作用**

1.  ​**噪声去除**：
    
    *   特别适用于**椒盐噪声**​（随机出现的黑白点）或**脉冲噪声**。
    *   对**小面积孤立噪声**效果显著，但对高斯噪声效果有限。
2.  ​**细节保留**：
    
    *   相比均值滤波或高斯滤波，中值滤波在平滑噪声的同时，能更好地保留图像边缘和纹理。
3.  ​**应用场景**：
    
    *   工业检测：去除金属表面划痕检测中的噪声。
    *   医学成像：消除 X 光或显微镜图像中的随机噪声。
    *   文档处理：清理扫描文件中的斑点。

实例代码：

\* 读取图像
read\_image(Image, 'noisy\_parts.jpg')

\* 中值滤波（使用3×5矩形掩模）
median\_rect(Image, ImageMedian, 3, 5)

\* 显示结果
dev\_display(ImageMedian)

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318151214352-1296854683.png)

**4.图像增强之增强对比度算子：**emphasize(Image : ImageEmphasize : MaskWidth, MaskHeight, Factor : )主要用于增强边缘和细节

*   **输入参数**：
    *   `Image`：输入图像（单通道灰度图像）。
    *   `MaskWidth`, `MaskHeight`：定义局部邻域大小的掩模尺寸（需为**奇数**，如 3, 5, 7 等）。
    *   `Factor`：增强因子，控制细节增强的强度（通常 ≥ 0）。
*   ​**输出参数**：
    *   `ImageEmphasize`：处理后的输出图像。

**核心原理**

`emphasize` 的实现基于 ​**高频增强算法**，核心步骤如下：

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318151503747-1075078943.png)

 通俗的讲就是

1.使用 宽为 MaskWidth，高为MaskHeight的 mean\_image (均值滤波器) 进行均值滤波。滤波后的图像灰度记为 mean, 滤波前的灰度记为 orig  
2.将图像按如下公式进行计算得到结果图像  
res := round((orig - mean) \* Factor) + orig  
  

**功能与作用**

1.  ​**边缘增强**：
    *   锐化图像中的边缘和纹理，提升目标与背景的对比度。
2.  ​**细节突出**：
    *   增强微小结构（如划痕、文字、细胞边界）的可见性。
3.  ​**适用场景**：
    *   工业检测：强化产品表面缺陷（裂纹、凹陷）。
    *   医学成像：突出血管、组织边界。
    *   文档处理：改善低对比度文本的清晰度。

实例代码：

\* 读取图像
read\_image(Image, 'scratched\_surface.jpg')

\* 增强处理（掩模5×5，Factor=1.5）
emphasize(Image, ImageEmphasize, 5, 5, 1.5)

\* 显示结果
dev\_display(ImageEmphasize)

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318151806713-1981322979.png)

**5.图像增强之直方图均衡化算子：****equ\_histo\_image**([_Image_](#Image) : [_ImageEquHisto_](#ImageEquHisto) : : )

*   **输入参数**：
    *   `Image`：输入图像（单通道灰度图像）。
*   ​**输出参数**：
    *   `ImageEquHisto`：直方图均衡化后的输出图像。

### **核心原理**

直方图均衡化的目标是**拉伸图像的灰度分布**，使其覆盖更广的动态范围，从而增强对比度。具体步骤如下：

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318152400811-551259466.png)

说白了就是统计图像中的灰度出现的次数作为直方图，然后将主要的各个直方图的灰度区域和领域的区别增大增亮，让你可以清晰的看到各个灰度分布的成像

### **功能与作用**

1.  ​**对比度增强**：
    *   扩展图像的灰度范围，使暗区更亮、亮区更暗，提升整体对比度。
2.  ​**细节突出**：
    *   增强隐藏在高光或阴影中的细节（如医学图像中的组织、工业图像中的缺陷）。
3.  ​**适用场景**：
    *   低对比度图像（如背光拍摄、雾天图像）。
    *   医学成像（X光、MRI图像增强）。
    *   工业检测（表面缺陷的视觉增强）。

实例代码：

\* 读取图像
read\_image(Image, 'low\_contrast.jpg')

\* 直方图均衡化
equ\_histo\_image(Image, ImageEquHisto)

\* 显示结果
dev\_display(ImageEquHisto)

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318152532150-99121680.png)

**6.图像增强之按比例增强算子：****`scale_image_max(Image : ImageScaleMax : : )`**

*   **输入参数**：
    *   `Image`：输入图像（单通道灰度图像，支持8位、16位等数据类型）。
*   ​**输出参数**：
    *   `ImageScaleMax`：输出图像，灰度范围被拉伸到当前数据类型允许的最大值（如8位图像为0-255）。

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318153559497-689441507.png)

### **功能与作用**

1.  ​**对比度拉伸**：
    *   将狭窄的灰度范围扩展到全动态范围，增强图像的整体对比度。
2.  ​**适用场景**：
    *   低对比度图像（如背光拍摄、医学成像）。
    *   灰度范围未被充分利用的图像（例如传感器采集的原始数据）。
3.  ​**优势**：
    *   计算速度快，无需手动设置参数。
    *   保留像素值的相对分布，不改变直方图形状（仅拉伸）。

### **与直方图均衡化的对比**

​**特性**

`scale_image_max`

`equ_histo_image`（直方图均衡化）

​**原理**

线性拉伸灰度范围

非线性重分布直方图

​**对比度增强**

全局均匀拉伸

局部自适应增强

​**直方图形状**

保持原分布形状

近似均匀分布

​**噪声影响**

可能放大噪声

可能增强噪声或产生伪影

​**适用场景**

灰度范围狭窄的图像

直方图分布不均的图像

实例代码：

\* 读取低对比度图像
read\_image(Image, 'dark\_surface.jpg')

\* 自动拉伸灰度范围
scale\_image\_max(Image, ImageScaleMax)

\* 显示结果
dev\_display(ImageScaleMax)

**`而有时候常用的反而是自己调参的`**`scale_image([_Image_](#Image) : [_ImageScaled_](#ImageScaled) : [_Mult_](#Mult), [_Add_](#Add) : )`**`算子，缩放图像的灰度值，基本是让亮的区域更亮，暗的区域更暗来增强图像对比度。`**

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318155602505-1907468158.png)

公式截图放大点好看点

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318160711845-1137993559.png)

**7.图像增强之像素乘加操作算子：****mult\_image**([_Image1_](#Image1), [_Image2_](#Image2) : [_ImageResult_](#ImageResult) : [_Mult_](#Mult), [_Add_](#Add) : )作用也是都差不多，白的区域更白，黑的区域更黑

*   **输入参数**：
    *   `Image1`, `Image2`：输入图像（需尺寸相同且数据类型一致，如均为 `byte`、`uint2` 或 `real`）。
    *   `Mult`：乘法因子（缩放系数）。
    *   `Add`：加法因子（偏移量）。
*   ​**输出参数**：
    *   `ImageResult`：输出图像，计算公式为：

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318155910867-1723981558.png)

### **核心功能**

1.  ​**像素级运算**：
    *   对两幅图像的每个像素进行乘法和加法操作，生成新图像。
2.  ​**应用场景**：
    *   ​**图像融合**：通过乘法叠加掩模（如 ROI 区域提取）。
    *   ​**对比度增强**：结合乘法（调整对比度）和加法（调整亮度）。
    *   ​**传感器校准**：校正非线性响应或添加固定偏移量。

### **参数说明**

参数

作用

`Mult`

控制乘积结果的幅度，`Mult > 1` 放大对比度，`0 < Mult < 1` 降低对比度。

`Add`

调整输出图像的全局亮度，正值增亮，负值减暗。

### **与其他算子的对比**

算子

公式

适用场景

`mult_image`

I1×I2×M+A

图像融合、对比度与亮度调整

`add_image`

I1+I2

图像叠加、亮度叠加

`scale_image`

I×M+A

单图像对比度/亮度调整

实例代码：

\* 读取两幅图像（假设尺寸相同）
read\_image(Image1, 'part1.jpg')
read\_image(Image2, 'mask.jpg')

\* 图像乘法与加法：ImageResult = (Image1 \* Image2) \* 0.5 + 50
mult\_image(Image1, Image2, ImageResult, 0.5, 50)

\* 显示结果
dev\_display(ImageResult)

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318160629553-2015483964.png)

**四.halcon  二值化和形态学分析**

形态学分析也是图像处理中比较常用，又比较好理解的东西。主要针对[二值图像](https://so.csdn.net/so/search?q=%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%83%8F&spm=1001.2101.3001.7020)（图像中任何像素的灰度值不是0就是255）的膨胀，腐蚀，开运算和闭运算的操作。

在这之前就要了解一下二值化操作。我们通常处理图像大部分的场景都是先将彩色图像转为灰度图`rgb1_to_gray (Image, GrayImage)`，如果本身就是单通道图像就不用了。灰度图就是灰度值分布在0-255之间的图像，而二值化就是将图像中的灰度变成0和255，比如大于100以上的你就变成255，以下的就是0，这样的黑白分明了。主要用于分割图像的时候。

**1.图像二值化**

常用的比如：全局阈值分割算子**threshold**([_Image_](#Image) : [_Region_](#Region) : [_MinGray_](#MinGray), [_MaxGray_](#MaxGray) : )和局部阈值分割算子**dyn\_threshold**([_OrigImage_](#OrigImage), [_ThresholdImage_](#ThresholdImage) : [_RegionDynThresh_](#RegionDynThresh) : [_Offset_](#Offset), [_LightDark_](#LightDark) : )

**threshold**([_Image_](#Image) : [_Region_](#Region) : [_MinGray_](#MinGray), [_MaxGray_](#MaxGray) : )：

*   **输入参数**：
    *   `Image`：输入图像（单通道灰度图像）。
    *   `MinGray`, `MaxGray`：灰度阈值范围，闭区间 `[MinGray, MaxGray]`。
*   ​**输出参数**：
    *   `Region`：输出区域，包含所有灰度值在阈值范围内的像素。白话将就是提取灰度在`MinGray`到`MaxGray`之间的像素区域

实例代码：

\* 读取图像
read\_image(Image, 'metal\_part.jpg')

\* 设定阈值范围（假设目标灰度在120-220之间）
threshold(Image, Region, 120, 220)

\* 显示分割结果
dev\_display(Image)
dev\_display(Region)

**dyn\_threshold**([_OrigImage_](#OrigImage), [_ThresholdImage_](#ThresholdImage) : [_RegionDynThresh_](#RegionDynThresh) : [_Offset_](#Offset), [_LightDark_](#LightDark) : )：

*   **输入参数**：
    *   `OrigImage`：原始输入图像（单通道灰度图像）。
    *   `ThresholdImage`：参考图像（通常为模糊后的图像，如高斯滤波或均值滤波结果）。
    *   `Offset`：阈值偏移量（用于放宽或收紧比较条件）。
    *   `LightDark`：比较模式，可选 `'light'`、`'dark'` 或 `'equal'`。
*   ​**输出参数**：
    *   `RegionDynThresh`：满足条件的区域。

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318163526743-2041783742.png)

（解释的话这里假定参考图像就是做过均值滤波的图像，此函数适用于缺陷提取中总是存在图像灰度均匀区域中总有特别亮于此区域或者暗于此区域的瑕疵提取）

`LightDark`参数为`'light'`时意思就是：提取原图中相对于均值图像灰度值还要大`Offset`的灰度值像素区域。

`LightDark`参数为`'dark'`时意思就是：提取原图中相对于均值图像灰度值还要`小``Offset`的灰度值像素区域。

`LightDark`参数为`'equal'`时意思就是：提取原图中相对于均值图像灰度值灰度差值在`Offset范围内`的灰度值像素区域。

实例代码：

read\_image(OrigImage, 'scratched\_metal.jpg')
\* 生成参考图像（高斯模糊）
gauss\_filter(OrigImage, ThresholdImage, 15)
\* 动态阈值分割（提取暗缺陷）
dyn\_threshold(OrigImage, ThresholdImage, Scratches, 10, 'dark')
\* 显示结果
dev\_display(OrigImage)
dev\_display(Scratches)

主要的阈值二值化的算子：

1、threshold：全局阈值分割算子。它根据输入的阈值下限和上限，将图像中的像素分为两部分，满足条件的像素被归为一个区域。这种方法简单直接，但只适用于图像灰度分布较为均匀的情况。  
  
2、auto\_threshold：直方图阈值分割算子。它通过分析图像的直方图，自动确定一个或多个阈值来进行分割。这种方法对于具有明显双峰或多峰的直方图图像效果较好。  
  
3、bin\_threshold：已过时的算子，建议使用binary\_threshold替代。它使用自动确定的阈值分割单通道的灰度图像。首先确定输入图像的相对直方图，然后从直方图中提取相关的最小值作为阈值操作的参数。  
  
4、binary\_threshold：二值阈值分割算子。它使用自动确定的全局阈值分割单通道图像，并在输出区域中返回分割后的结果。适用于在均匀照明的背景下分割字符等对象。  
  
5、dyn\_threshold：局部阈值分割算子。它根据图像的局部特征来确定阈值，因此可以处理灰度分布不均匀的图像。通常，阈值图像是原始图像的平滑版本，通过比较原始图像和阈值图像来确定分割区域，该算子使用前一般会先使用平滑算子将图像平滑。  
  
6、fast\_threshold：fast\_threshold从输入图像中选取灰度值g满足以下条件的像素:MinGray<= G <=MaxGray，为了减少处理时间，选择分为两个步骤:首先，处理位于选定水平线上的所有点，这些点由它们的距离MinSize指定。在下一步中，处理所有先前选择点的邻域(size (2\*MinSize+1) x (2\*MinSize+1))。在支持SSE2指令集的多核计算机上，threshold很可能比fast\_threshold更快。只有在这些特性不可用的情况下(例如在嵌入式平台上)，才可能首选fast\_threshold而不是threshold。  
  
7、var\_threshold：可变阈值分割算子。它允许在每个像素位置使用不同的阈值进行分割，因此可以处理更复杂的图像。这种方法通常需要根据图像的局部特征来动态计算阈值。  
  
8、hysteresis\_threshold：滞后阈值分割算子。它使用两个阈值（高阈值和低阈值）来进行分割。像素值高于高阈值的被确定为前景，像素值低于低阈值的被确定为背景，而位于两者之间的像素则根据邻域关系来确定其归属。  
  
9、local\_threshold：按照官方文档介绍，本算子适合文本二值化。且经过验证，该算子对光照不均匀的图像分割有较好效果。  
  
10、histo\_to\_thresh：原理基于直方图统计方法，根据预设的阈值将直方图分为两部分，一部分为前景一部分为背景。为了确定最佳阈值，算法通常采用Otsu来自动选择阈值。  
  
11、char\_threshold：算子在HALCON中用于实现基于阈值的字符分割。它通过设定一个阈值来确定图像中的字符，并将其转变为二值图像。其基本原理是通过计算图像的灰度值，并将其与设定的阈值进行比较，以此来决定每个像素的新灰度值。  
  
12、dual\_threshold：算子将图像转换为两个区域，一个是低于DarkThreshold（参数）的区域（RegionDark），另一个是高于BrightThreshold（参数）的区域（RegionBright）。这种操作常用于图像的自适应阈值分割，特别是在图像的亮度变化较大的场景中。  
  
13、watersheds\_threshold：这个算子分为两步，第1步：通过分水岭算法watersheds（）获取图像的盆地。第2步：根据第一步分水岭算法分离结果，若盆地部分的灰度\*\*< threshold\*\*，则被合并到一起。设B1和B2分别为相邻盆地的最小灰度值，W为将盆地分割为两个盆地的最小灰度值  
  

**2.形态学分析**

形态学分析主要针对[二值图像](https://so.csdn.net/so/search?q=%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%83%8F&spm=1001.2101.3001.7020)（图像中任何像素的灰度值不是0就是255）的膨胀，腐蚀，开运算和闭运算的操作。

形态学的滤波核（就是在二维数组上遍历的一个固定大小的矩形或者圆形）可以有矩形的也可以圆形的，下面以圆形的算子作为举例

**（1）膨胀（Dilation）**

`dilation_circle(Region : RegionDilation : Radius : )：`

*   **输入参数**：
    *   `Region`：输入区域（待处理的二值化区域）。
    *   `Radius`：圆形结构元素的半径（单位：像素）。
*   ​**输出参数**：
    *   `RegionDilation`：膨胀后的区域。

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318165351735-103539107.png)

 说白了就是你的一个滤波核这里是个半径为R的圆形滤波核，你在对一个矩形区域进行膨胀的时候就是滤波核在这个二维的区域数组中滑动遍历，内部的时候没有变化，到边缘的时候你的圆形区域中心在矩形边界的时候，一半的圆形都会在矩形外，然后把矩形外填充上像素，不断滑动不断填充。后面的腐蚀也是一样的原理

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318165636109-1674731154.png)

### **功能与作用**

1.  ​**填充孔洞**：
    *   扩大区域以覆盖小孔或裂缝（如金属表面的微小缺陷）。
2.  ​**连接邻近区域**：
    *   使分离的相邻区域合并（需调整半径避免过度膨胀）。
3.  ​**边缘平滑**：
    *   平滑区域的锯齿状边缘，使其更接近圆形。
4.  ​**应用场景**：
    *   工业检测：增强目标区域的连通性。
    *   医学图像：连接断裂的血管或组织区域。
    *   文档处理：修复字符断裂。

### **与其他膨胀操作的对比**

操作

结构元素

适用场景

`dilation_circle`

圆形

各向同性扩展（无方向偏好）

`dilation_rectangle1`

矩形

水平/垂直方向扩展

`dilation2`

自定义结构元素

复杂形状或非对称扩展

实例代码：

read\_image(Image, 'metal\_part.jpg')
\* 二值化分割目标区域
threshold(Image, Region, 120, 255)
\* 膨胀处理（半径3像素）
dilation\_circle(Region, RegionDilation, 3)
\* 显示结果
dev\_display(Image)
dev\_display(RegionDilation)

**（2）腐蚀（Erosion）**

`erosion_circle(Region : RegionErosion : Radius : )`算子：  

*   **输入参数**：
    *   `Region`：输入区域（待处理的二值化区域）。
    *   `Radius`：圆形结构元素的半径（单位：像素）。
*   ​**输出参数**：
    *   `RegionErosion`：腐蚀后的区域。

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318170054483-193183895.png)

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318170320252-1152796434.png)

### **功能与作用**

1.  ​**去除细小噪声**：
    *   消除孤立的噪点或小区域（如金属表面的灰尘斑点）。
2.  ​**分离粘连区域**：
    *   收缩目标边界，使轻微粘连的物体分离（如细胞或工业零件）。
3.  ​**边缘平滑**：
    *   去除区域边缘的毛刺，使形状更规则。
4.  ​**应用场景**：
    *   工业检测：去除微小干扰，保留主要目标。
    *   医学成像：分离重叠的细胞或组织。
    *   文档处理：细化字符笔画。

### **与其他腐蚀操作的对比**

操作

结构元素

适用场景

`erosion_circle`

圆形

各向同性收缩（无方向偏好）

`erosion_rectangle1`

矩形

水平/垂直方向收缩

`erosion2`

自定义结构元素

复杂形状或非对称收缩

实例代码：

read\_image(Image, 'noisy\_parts.jpg')
\* 二值化分割目标区域
threshold(Image, Region, 200, 255)
\* 腐蚀处理（半径2像素）
erosion\_circle(Region, RegionErosion, 2)
\* 显示结果
dev\_display(Image)
dev\_display(RegionErosion)

**（3）开运算（opening）**

opening\_circle(Region : RegionOpening : Radius : )算子：先腐蚀后膨胀，主要就是将只有一点点藕断丝连的区域断开，比如两个岛之间有条短桥，把这个短桥给断开

*   **输入参数**：
    *   `Region`：输入区域（待处理的二值化区域）。
    *   `Radius`：圆形结构元素的半径（单位：像素）。
*   ​**输出参数**：
    *   `RegionOpening`：开运算处理后的区域。

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318170654386-2098021269.png)

### **功能与作用**

1.  ​**去噪与平滑**：
    *   消除小面积噪声（如灰尘、像素级干扰）。
    *   平滑目标边界，去除锯齿或毛刺。
2.  ​**保留主结构**：
    *   仅移除比结构元素小的干扰，保持目标主体形状和尺寸。
3.  ​**应用场景**：
    *   工业检测：去除金属表面的微小划痕或杂质。
    *   医学成像：消除细胞图像中的噪点。
    *   文档处理：清理扫描文件中的孤立黑点。

### **与其他开运算算子的对比**

操作

结构元素

适用场景

`opening_circle`

圆形

各向同性处理，均匀去噪

`opening_rectangle1`

矩形

水平/垂直方向去噪或分离目标

`opening`

自定义结构元素

复杂形状或非对称处理

实例代码：

read\_image(Image, 'noisy\_objects.jpg')
\* 阈值分割提取目标
threshold(Image, Region, 100, 255)
\* 开运算去噪（半径2像素）
opening\_circle(Region, RegionOpening, 2)
\* 显示结果
dev\_display(Image)
dev\_display(RegionOpening)

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318171025940-1344065731.png)

**（4）闭运算（closing）**

**closing\_circle**([_Region_](#Region) : [_RegionClosing_](#RegionClosing) : [_Radius_](#Radius) : )算子：先膨胀后腐蚀

*   **输入参数**：
    *   `Region`：输入区域（待处理的二值化区域）。
    *   `Radius`：圆形结构元素的半径（单位：像素）。
*   ​**输出参数**：
    *   `RegionClosing`：闭运算处理后的区域。

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318171301173-1707486373.png)

![](https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250318171501207-1578360813.png)

### **功能与作用**

1.  ​**填充孔洞**：
    *   闭合目标内部的微小孔洞（如金属表面的气孔、医学图像中的组织间隙）。
2.  ​**连接邻近区域**：
    *   桥接相邻的断裂区域（如断裂的字符笔画或零件边缘）。
3.  ​**平滑边界**：
    *   使锯齿状边缘更平滑，同时保持目标面积。
4.  ​**应用场景**：
    *   工业检测：填充零件内部孔洞，确保面积测量准确。
    *   医学成像：连接断裂的血管或组织区域。
    *   文档处理：修复断裂的印刷字符。

### **与其他闭运算算子的对比**

操作

结构元素

适用场景

`closing_circle`

圆形

各向同性处理，均匀填充孔洞

`closing_rectangle1`

矩形

水平/垂直方向连接断裂区域

`closing`

自定义结构元素

复杂形状或非对称处理

实例代码：

read\_image(Image, 'defective\_part.jpg')
\* 阈值分割提取目标
threshold(Image, Region, 80, 255)
\* 闭运算填充孔洞（半径3像素）
closing\_circle(Region, RegionClosing, 3)
\* 显示结果
dev\_display(Image)
dev\_display(RegionClosing)

　　OK，本篇就写这么多，后面再继续更新halcon入门教程

参考博客：https://blog.csdn.net/liuming1992/article/details/144377754

　　　　　https://blog.csdn.net/weixin\_46079046/article/details/135589576?spm=1001.2014.3001.5502

　　　　   https://www.cnblogs.com/ZHIZRL/p/18316077

　　　　   https://blog.csdn.net/m0\_37302966/article/details/140076055

转发和使用本文，请注明作者信息和原文地址---本文原作者为aircraft ---大家好我是徐飞机，有没有大佬们的公司招c++开发/图像处理/opengl/opencv/halcon实习的啊，带上我一个呗QAQ。。。hhhhhh 想要免费获取前端，后端，c/c++,matlab，Python，opencv，机器学习，深度学习，安卓，java，等等全套视频教程请关注机器视觉开发公众号，转发集赞28即可百度云获得hhhhhhhh