---
layout: post
title: 'STLï¼šè¿­ä»£å™¨ä¸å¸¸ç”¨ç®—æ³•'
date: "2025-06-24T00:43:15Z"
---
STLï¼šè¿­ä»£å™¨ä¸å¸¸ç”¨ç®—æ³•
============

è¿­ä»£å™¨
===

C++ STLï¼ˆStandard Template Libraryï¼Œæ ‡å‡†æ¨¡æ¿åº“ï¼‰ä¸­**è¿­ä»£å™¨**ä¸**å¸¸ç”¨ç®—æ³•**æ˜¯æ³›å‹ç¼–ç¨‹çš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ã€‚å®ƒä»¬é…åˆä½¿ç”¨ï¼Œå¯ä»¥å¯¹å®¹å™¨è¿›è¡Œé«˜æ•ˆã€ç»Ÿä¸€çš„æ“ä½œã€‚ä¸‹é¢æ˜¯å¯¹å®ƒä»¬çš„ç³»ç»Ÿæ€§æ€»ç»“ã€‚

* * *

ä¸€ã€ä»€ä¹ˆæ˜¯è¿­ä»£å™¨ï¼ˆIteratorï¼‰
------------------

**è¿­ä»£å™¨**æ˜¯ STL çš„æ ¸å¿ƒï¼Œç”¨äºè®¿é—®å®¹å™¨ä¸­çš„å…ƒç´ ã€‚è¿­ä»£å™¨æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ç§â€œå¹¿ä¹‰çš„æŒ‡é’ˆâ€ï¼Œå®ƒæä¾›äº†ç»Ÿä¸€çš„æ–¹å¼æ¥è®¿é—®å®¹å™¨ä¸­çš„å…ƒç´ ã€‚

### åŠŸèƒ½åŒ…æ‹¬ï¼š

*   **è®¿é—®**å…ƒç´ ï¼šé€šè¿‡ `*it` è¯»å–å…ƒç´ 
*   **éå†**å…ƒç´ ï¼šä½¿ç”¨ `++it`ã€`--it`ã€`it + n` ç­‰
*   **ä¿®æ”¹**å…ƒç´ ï¼ˆå¯¹äºé const è¿­ä»£å™¨ï¼‰

* * *

äºŒã€è¿­ä»£å™¨çš„åˆ†ç±»ï¼ˆäº”ç§ç±»å‹ï¼‰
--------------

STL ä¸­çš„è¿­ä»£å™¨æŒ‰åŠŸèƒ½åˆ†ä¸ºäº”ç§ç±»å‹ï¼Œå®šä¹‰åœ¨ `<iterator>` ä¸­ï¼š

1.  **è¾“å…¥è¿­ä»£å™¨ï¼ˆInput Iteratorï¼‰**ï¼šåªèƒ½è¿›è¡Œå•æ¬¡è¯»å–æ“ä½œï¼Œä¸èƒ½è¿›è¡Œå†™å…¥æ“ä½œã€‚
2.  **è¾“å‡ºè¿­ä»£å™¨ï¼ˆOutput Iteratorï¼‰**ï¼šåªèƒ½è¿›è¡Œå•æ¬¡å†™å…¥æ“ä½œï¼Œä¸èƒ½è¿›è¡Œè¯»å–æ“ä½œã€‚
3.  **æ­£å‘è¿­ä»£å™¨ï¼ˆForward Iteratorï¼‰**ï¼šå¯ä»¥è¿›è¡Œè¯»å–å’Œå†™å…¥æ“ä½œï¼Œå¹¶ä¸”å¯ä»¥å‘å‰ç§»åŠ¨ã€‚
4.  **åŒå‘è¿­ä»£å™¨ï¼ˆBidirectional Iteratorï¼‰**ï¼šé™¤äº†å¯ä»¥è¿›è¡Œæ­£å‘è¿­ä»£å™¨çš„æ‰€æœ‰æ“ä½œå¤–ï¼Œè¿˜å¯ä»¥å‘åç§»åŠ¨ã€‚
5.  **éšæœºè®¿é—®è¿­ä»£å™¨ï¼ˆRandom Access Iteratorï¼‰**ï¼šé™¤äº†å¯ä»¥è¿›è¡ŒåŒå‘è¿­ä»£å™¨çš„æ‰€æœ‰æ“ä½œå¤–ï¼Œè¿˜å¯ä»¥è¿›è¡Œéšæœºè®¿é—®ï¼Œä¾‹å¦‚é€šè¿‡ä¸‹æ ‡è®¿é—®å…ƒç´ ã€‚

ğŸ“Œ **è®°å¿†æŠ€å·§**ï¼šæ¯ç±»è¿­ä»£å™¨æ˜¯å¯¹ä¸Šä¸€çº§çš„æ‰©å±•ã€‚

ä¸‰ã€è¿­ä»£å™¨åŸºæœ¬æ“ä½œ
---------

ä»¥ `vector<int>` ä¸ºä¾‹ï¼š

    #include <iostream>
    #include <vector>
    #include <iterator>
    
    int main() {
        // åˆ›å»ºä¸€ä¸ª vector å®¹å™¨å¹¶åˆå§‹åŒ–
        std::vector<int> vec = {1, 2, 3, 4, 5};
    
        // ä½¿ç”¨è¿­ä»£å™¨éå† vector
        for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
            std::cout << *it << " ";
        }
        std::cout << std::endl;
    
        // ä½¿ç”¨ auto å…³é”®å­—ç®€åŒ–è¿­ä»£å™¨ç±»å‹
        for (auto it = vec.begin(); it != vec.end(); ++it) {
            std::cout << *it << " ";
        }
        std::cout << std::endl;
    
        // ä½¿ç”¨ C++11 èŒƒå›´ for å¾ªç¯
        for (int elem : vec) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    
        return 0;
    }
    

* * *

å››ã€const\_iterator ä¸ reverse\_iterator
-------------------------------------

`const_iterator` å’Œ `reverse_iterator` æ˜¯C++æ ‡å‡†åº“ä¸­æä¾›çš„ä¸¤ç§è¿­ä»£å™¨ç±»å‹ï¼Œå®ƒä»¬ç”¨äºéå†å®¹å™¨ï¼ˆå¦‚vectorã€listã€mapç­‰ï¼‰ä¸­çš„å…ƒç´ ï¼Œä½†å„è‡ªæœ‰ä¸åŒçš„ç”¨é€”å’Œè¡Œä¸ºã€‚

### const\_iterator

`const_iterator` æ˜¯ä¸€ç§ä¸èƒ½ç”¨æ¥ä¿®æ”¹å…¶æ‰€æŒ‡å‘å…ƒç´ å€¼çš„è¿­ä»£å™¨ã€‚

*   **å£°æ˜æ–¹å¼**ï¼šé€šå¸¸ï¼Œå®¹å™¨ç±»æä¾›äº†ä¸€ä¸ªåä¸º `cbegin()` å’Œ `cend()` çš„æˆå‘˜å‡½æ•°æ¥è¿”å›ä¸€ä¸ª `const_iterator`ï¼Œå³ä½¿åœ¨éconstå¯¹è±¡ä¸Šè°ƒç”¨è¿™äº›æ–¹æ³•ä¹Ÿæ˜¯å¦‚æ­¤ã€‚
    
        std::vector<int> vec = {1, 2, 3, 4};
        for (std::vector<int>::const_iterator it = vec.cbegin(); it != vec.cend(); ++it) {
            // *it = 10; // é”™è¯¯ï¼Œæ— æ³•é€šè¿‡ const_iterator ä¿®æ”¹å€¼
            std::cout << *it << " ";
        }
        
    

### reverse\_iterator

`reverse_iterator` åˆ™æ˜¯ä¸€ç§å…è®¸ä»å®¹å™¨æœ«å°¾å‘å¤´éƒ¨è¿›è¡Œéå†çš„è¿­ä»£å™¨ã€‚

*   **å£°æ˜æ–¹å¼**ï¼šå®¹å™¨ç±»æä¾›äº†åä¸º `rbegin()` å’Œ `rend()` çš„æˆå‘˜å‡½æ•°æ¥è·å– `reverse_iterator`ï¼Œåˆ†åˆ«æŒ‡å‘å®¹å™¨çš„æœ€åä¸€ä¸ªå…ƒç´ å’Œç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰çš„ä½ç½®ã€‚
    
        std::vector<int> vec = {1, 2, 3, 4};
        for (std::vector<int>::reverse_iterator rit = vec.rbegin(); rit != vec.rend(); ++rit) {
            std::cout << *rit << " "; // è¾“å‡ºå°†æ˜¯ 4 3 2 1
        }
        
        for (std::vector<int>::const_reverse_iterator rit = vec.rbegin(); rit != vec.rend(); ++rit) {
            std::cout << *rit << " "; // è¾“å‡ºå°†æ˜¯ 4 3 2 1
        }
        
    

### æ€»ç»“

*   ä½¿ç”¨ `const_iterator` æ¥ç¡®ä¿ä½ åªèƒ½è¯»å–è€Œä¸èƒ½ä¿®æ”¹å®¹å™¨ä¸­çš„æ•°æ®ã€‚
*   ä½¿ç”¨ `reverse_iterator` å½“ä½ éœ€è¦ä»¥é€†åºçš„æ–¹å¼éå†å®¹å™¨çš„å†…å®¹æ—¶ã€‚

æ­¤å¤–ï¼Œè¿˜æœ‰ `const_reverse_iterator` ç±»å‹ï¼Œå®ƒæ˜¯ `reverse_iterator` çš„å¸¸é‡ç‰ˆæœ¬ï¼Œæ—¢ä¸å…è®¸ä¿®æ”¹å®¹å™¨ä¸­çš„å…ƒç´ ä¹Ÿä¸å…è®¸é€šè¿‡å®ƒæ”¹å˜å®¹å™¨çš„å¤§å°ã€‚è¿™ç§ç±»å‹çš„è¿­ä»£å™¨å¯ä»¥é€šè¿‡å®¹å™¨çš„ `crbegin()` å’Œ `crend()` æˆå‘˜å‡½æ•°è·å¾—ã€‚

äº”ã€ä¸ STL ç®—æ³•ç»“åˆä½¿ç”¨
--------------

æ‰€æœ‰ `<algorithm>` ç®—æ³•éƒ½åŸºäºè¿­ä»£å™¨è®¾è®¡ï¼š

    #include <algorithm>
    std::vector<int> v = {5, 2, 8, 1};
    
    std::sort(v.begin(), v.end());  // ä»å°åˆ°å¤§æ’åº
    auto it = std::find(v.begin(), v.end(), 2);  // æŸ¥æ‰¾å€¼ä¸º2çš„å…ƒç´ 
    std::reverse(v.begin(), v.end());  // åè½¬
    

* * *

å…­ã€è¿­ä»£å™¨å¤±æ•ˆï¼ˆInvalidationï¼‰
---------------------

è¿­ä»£å™¨å¤±æ•ˆï¼ˆ**Iterator Invalidation**ï¼‰æ˜¯ C++ ç¼–ç¨‹ä¸­ä¸€ä¸ªéå¸¸é‡è¦ä½†å¸¸è¢«å¿½è§†çš„æ¦‚å¿µã€‚å¦‚æœå¯¹å®ƒä¸äº†è§£ï¼Œç¨‹åº**å¯èƒ½ç¼–è¯‘é€šè¿‡ä½†è¿è¡Œå´©æºƒæˆ–è¡Œä¸ºå¼‚å¸¸**ï¼Œæ˜¯è°ƒè¯•ä¸­éå¸¸æ£˜æ‰‹çš„ä¸€ç±»é”™è¯¯ã€‚**STL è¿­ä»£å™¨æ˜¯å¯¹åœ°å€çš„å°è£…ï¼Œåœ°å€å˜äº†ï¼Œè¿­ä»£å™¨å°±å¤±æ•ˆäº†**ï¼ï¼ï¼ï¼ï¼ï¼ï¼

### ä»€ä¹ˆæ˜¯è¿­ä»£å™¨å¤±æ•ˆ

> **è¿­ä»£å™¨å¤±æ•ˆ**æŒ‡çš„æ˜¯ï¼šå½“ä½ å¯¹å®¹å™¨åšæŸäº›æ“ä½œï¼ˆå¦‚æ’å…¥ã€åˆ é™¤ã€é‡æ’ï¼‰ä¹‹åï¼Œ**å·²æœ‰çš„è¿­ä»£å™¨ã€å¼•ç”¨æˆ–æŒ‡é’ˆå˜å¾—ä¸å†æœ‰æ•ˆ**ï¼Œå†ä½¿ç”¨å®ƒä»¬å°±ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼ˆUBï¼‰ã€‚
> 
> è¿­ä»£å™¨æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªâ€œå°è£…äº†è®¿é—®å®¹å™¨ä¸­æŸä¸ªå…ƒç´ ä¿¡æ¯â€çš„å¯¹è±¡ï¼Œå¯èƒ½æ˜¯ä¸€ä¸ªè£¸æŒ‡é’ˆã€ä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ªå°è£…æŒ‡é’ˆå’ŒçŠ¶æ€çš„ç±»ã€‚
> 
> å¦‚æœå…ƒç´ è¢«**é”€æ¯**äº†ï¼ˆå¦‚ `erase()`ï¼‰ é‚£ä¹ˆè¿­ä»£å™¨å°±æŒ‡å‘ä¸€å—**æ— æ•ˆå†…å­˜**ï¼›  
> å¦‚æœå…ƒç´ è¢«**æ¬ç§»äº†**ï¼ˆå¦‚ `vector::insert()`ï¼‰é‚£ä¹ˆè¿­ä»£å™¨é‡Œçš„åœ°å€å°±**è¿‡æ—¶äº†ï¼›**  
> å¦‚æœç»“æ„è¢«**é‡æ„**ï¼ˆå¦‚ `unordered_map` çš„ rehashï¼‰ é‚£ä¹ˆè¿­ä»£å™¨æŒ‡å‘çš„æ¡¶æˆ–èŠ‚ç‚¹è¢«æ¢æ‰äº†ï¼›
> 
> æ¢å¥è¯è¯´ï¼š
> 
> **å¤±æ•ˆçš„è¿­ä»£å™¨ = ä»ç„¶ä¿å­˜ç€åŸå§‹è®¿é—®ä¿¡æ¯ï¼Œä½†è¿™ä¸ªä¿¡æ¯å·²ç»ä¸å†ä¸å®¹å™¨åŒæ­¥**

### å“ªäº›å®¹å™¨å®¹æ˜“å¤±æ•ˆ

å®¹å™¨

å¢åˆ å…ƒç´ æ˜¯å¦å¯èƒ½å¯¼è‡´è¿­ä»£å™¨å¤±æ•ˆ

`vector`, `deque`, `string`

**æ’å…¥ã€åˆ é™¤ã€realloc åè¿­ä»£å™¨ä¼šå¤±æ•ˆ**

`list`, `forward_list`

æ’å…¥ä¸ä¼šå¤±æ•ˆï¼Œ**åˆ é™¤å¯¹åº”å…ƒç´ ä¼šå¯¼è‡´è¯¥å…ƒç´ çš„è¿­ä»£å™¨å¤±æ•ˆ**

`set`, `map`, `unordered_set`, `unordered_map`

æ’å…¥ä¸ä¼šä½¿å·²æœ‰è¿­ä»£å™¨å¤±æ•ˆï¼Œä½†**åˆ é™¤æŸä¸ªå…ƒç´ ä¼šä½¿è¯¥å…ƒç´ è¿­ä»£å™¨å¤±æ•ˆ**

### å„å®¹å™¨å¸¸è§æ“ä½œçš„è¿­ä»£å™¨å¤±æ•ˆè¡¨

å®¹å™¨

`insert`

`erase`

`push_back` / `push_front`

`clear`

`vector`

å¯èƒ½å¤±æ•ˆ reallocation å¯¼è‡´åœ°å€å˜æ›´

åˆ é™¤ç‚¹ä¹‹åå¤±æ•ˆ

å¯èƒ½å¤±æ•ˆ reallocation å¯¼è‡´åœ°å€å˜æ›´

æ‰€æœ‰å¤±æ•ˆ

`list`

ä¸å¤±æ•ˆ

ä»…åˆ é™¤ç‚¹å¤±æ•ˆ

ä¸å¤±æ•ˆ

æ‰€æœ‰å¤±æ•ˆ

`deque`

å¯èƒ½å¤±æ•ˆ

åˆ é™¤ç‚¹ä¹‹åå¤±æ•ˆ

å¯èƒ½å¤±æ•ˆ

æ‰€æœ‰å¤±æ•ˆ

`set` / `map`

ä¸å¤±æ•ˆ

åˆ é™¤ç‚¹å¤±æ•ˆ

ä¸é€‚ç”¨

æ‰€æœ‰å¤±æ•ˆ

`unordered_set` / `unordered_map`

æ’å…¥å¯èƒ½å¤±æ•ˆï¼ˆrehashï¼‰

åˆ é™¤ç‚¹å¤±æ•ˆ

æ’å…¥å¯èƒ½å¤±æ•ˆ

æ‰€æœ‰å¤±æ•ˆ

### å¸¸è§è¿­ä»£å™¨å¤±æ•ˆåœºæ™¯è¯¦è§£

#### 1\. `vector` æˆ– `string` çš„æ’å…¥/åˆ é™¤/æ‰©å®¹

*   æ‰©å®¹æ’å…¥ï¼š`vector` ä¼šåœ¨å®¹é‡ä¸è¶³æ—¶å‘ç”Ÿ**realloc**æ‰©å®¹ï¼ˆé‡æ–°åˆ†é…å†…å­˜ï¼‰ï¼Œåœ°å€å˜æ›´ï¼Œæ‰€æœ‰æ—§çš„è¿­ä»£å™¨/æŒ‡é’ˆ/å¼•ç”¨ä¼šå¤±æ•ˆã€‚
*   `vector::erase` ä¼šä½¿**è¢«åˆ é™¤ä½ç½®åŠå…¶åçš„æ‰€æœ‰è¿­ä»£å™¨å¤±æ•ˆ**ã€‚å› ä¸º `vector` çš„åº•å±‚å®ç°æ˜¯**è¿ç»­å†…å­˜æ•°ç»„**ï¼Œåˆ é™¤ä¸€ä¸ªå…ƒç´ åï¼š
    *   æ‰€æœ‰**åç»­å…ƒç´ **éƒ½ä¼š**å‘å‰æ¬ç§»ä¸€ä¸ªä½ç½®**
    *   æ‰€ä»¥è¿™äº›å…ƒç´ çš„åŸå§‹åœ°å€å…¨éƒ¨å˜åŒ–
    *   è€Œ STL è¿­ä»£å™¨æ˜¯å¯¹åœ°å€çš„å°è£…ï¼Œ**åœ°å€å˜äº†ï¼Œè¿­ä»£å™¨å°±å¤±æ•ˆäº†**

é”™è¯¯ç¤ºä¾‹ ï¼š

    std::vector<int> v = {1, 2, 3};
    auto it = v.begin();
    v.push_back(4);  // å¦‚æœè§¦å‘äº†æ‰©å®¹ï¼Œit å¤±æ•ˆ
    std::cout << *it;  // æœªå®šä¹‰è¡Œä¸ºï¼
    
    std::vector<int> v = {1,2,3,4};
    for (auto it = v.begin(); it != v.end(); ++it) {
        if (*it == 2) v.erase(it);  // âŒ ä¹‹åçš„ ++it å·²å¤±æ•ˆ
    }
    

âœ… **å®‰å…¨åšæ³•ï¼šæ¯æ¬¡æ“ä½œåé‡ç½®è¿­ä»£å™¨**

æ­£ç¡®ç”¨æ³•ï¼š

    std::vector<int> v = {1,2,3,4,5};
    for (auto it = v.begin(); it != v.end(); ) {
        if (*it % 2 == 0)
            it = v.erase(it);  // å®‰å…¨å†™æ³•ï¼šç”¨è¿”å›å€¼æ›´æ–° it
        else
            ++it;
    }
    

#### 2\. `list` çš„æ’å…¥æ˜¯å®‰å…¨çš„ï¼Œä½†**åˆ é™¤æŸå…ƒç´ åè¯¥è¿­ä»£å™¨å¤±æ•ˆ**

    std::list<int> l = {1, 2, 3};
    auto it = l.begin();
    l.erase(it);   // it å¤±æ•ˆ
    // std::cout << *it;  // âŒ UB
    

**ä¸ºä»€ä¹ˆ `std::list` çš„æ’å…¥æ˜¯â€œå®‰å…¨â€çš„ï¼Ÿ**

`std::list` æ˜¯ä¸€ä¸ª **åŒå‘é“¾è¡¨**ï¼Œå…¶å…ƒç´ åœ¨å†…å­˜ä¸­**ä¸è¿ç»­**ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹é€šè¿‡æŒ‡é’ˆé“¾æ¥ï¼šæ’å…¥æ—¶ï¼Œåªæ˜¯ä¿®æ”¹èŠ‚ç‚¹çš„ `next` / `prev` æŒ‡é’ˆï¼Œä¸éœ€è¦ç§»åŠ¨å·²æœ‰èŠ‚ç‚¹æˆ–é‡æ–°åˆ†é…å†…å­˜ã€‚

*   **å·²æœ‰è¿­ä»£å™¨ä»ç„¶æŒ‡å‘åŸèŠ‚ç‚¹**
*   æ’å…¥ä¸ä¼šç ´åæ—§èŠ‚ç‚¹ï¼Œä¹Ÿä¸ä¼šå¯¼è‡´åœ°å€å˜åŒ–

**ä¸ºä»€ä¹ˆåˆ é™¤æŸä¸ªå…ƒç´ åè¯¥è¿­ä»£å™¨ä¼šå¤±æ•ˆ**ï¼Ÿ

å½“ä½ è°ƒç”¨ `l.erase(it)` åˆ é™¤æŸä¸ªèŠ‚ç‚¹æ—¶ï¼š

*   è¯¥èŠ‚ç‚¹çš„å†…å­˜è¢«é‡Šæ”¾
*   è¯¥è¿­ä»£å™¨å†…éƒ¨çš„æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜è¢«é”€æ¯äº†

    std::list<int> l = {1, 2, 3};
    auto it = std::next(l.begin()); // æŒ‡å‘ 2
    l.erase(it); // åˆ é™¤ 2
    std::cout << *it << "\n"; // âŒ it å·²å¤±æ•ˆï¼ŒUB
    

åœ¨å¼€å¯è°ƒè¯•çš„ç¼–è¯‘å™¨ä¸­ï¼ˆå¦‚ `-D_GLIBCXX_DEBUG`ï¼‰ï¼Œè¿™å¥ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚

* * *

#### 4\. `set` / `map` çš„åˆ é™¤ä¼šä½¿**è¯¥å…ƒç´ çš„è¿­ä»£å™¨å¤±æ•ˆ**ï¼Œ`unordered_*` å®¹å™¨çš„æ’å…¥æˆ– rehash å¯èƒ½ä½¿æ‰€æœ‰è¿­ä»£å™¨å¤±æ•ˆ

æ“ä½œ

`std::set` / `std::map`

`std::unordered_set` / `unordered_map`

æ’å…¥æ˜¯å¦å¯¼è‡´è¿­ä»£å™¨å¤±æ•ˆï¼Ÿ

âŒ ä¸ä¼šå¤±æ•ˆ âœ…

âœ… å¯èƒ½å…¨éƒ¨å¤±æ•ˆï¼ˆrehashï¼‰

åˆ é™¤æ˜¯å¦å¯¼è‡´è¿­ä»£å™¨å¤±æ•ˆï¼Ÿ

âœ… è¢«åˆ çš„å¤±æ•ˆ

âœ… è¢«åˆ çš„å¤±æ•ˆ

##### åŸå› ï¼šå®¹å™¨åº•å±‚ç»“æ„ä¸åŒï¼š

**`std::set` / `std::map` åº•å±‚ç»“æ„ï¼šçº¢é»‘æ ‘ï¼ˆçº¢é»‘å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼‰**ï¼š

*   æ’å…¥/åˆ é™¤æ“ä½œéƒ½åªæ˜¯**å±€éƒ¨æ—‹è½¬æˆ–é“¾è°ƒæ•´**
*   **èŠ‚ç‚¹åœ°å€ä¸å˜**ï¼Œä¸æ¬å®¶ã€ä¸åˆ†æ¡¶
*   æ‰€ä»¥ï¼š**é™¤è¢«åˆ èŠ‚ç‚¹å¤–ï¼Œå…¶ä»–èŠ‚ç‚¹ä½ç½®ç¨³å®š**ï¼Œè¿­ä»£å™¨ä¸å¤±æ•ˆ

    std::set<int> s = {1,2,3};
    auto it = s.begin();  // æŒ‡å‘1
    s.insert(4);          // æ ‘ä¸­æ·»åŠ æ–°èŠ‚ç‚¹
    std::cout << *it;     // âœ… å®‰å…¨ï¼Œä»è¾“å‡º1
    

* * *

**`std::unordered_set` / `unordered_map` åº•å±‚ç»“æ„ï¼šå“ˆå¸Œè¡¨ï¼ˆå¸¦é“¾å¼æˆ–æ¡¶æ•°ç»„ï¼‰**ï¼š

*   æ’å…¥ä¼šå¯¼è‡´ **rehash**ï¼ˆå“ˆå¸Œæ¡¶é‡åˆ†é…ï¼‰
*   **æ‰€æœ‰å…ƒç´ ä¼šæ¬åˆ°æ–°æ¡¶ä¸­**ï¼Œåœ°å€å˜åŒ–
*   æ‰€ä»¥ï¼š**æ‰€æœ‰è¿­ä»£å™¨éƒ½å¤±æ•ˆ**
*   å¦‚æœä½ æå‰è°ƒç”¨ `.reserve(å®¹é‡)`ï¼Œå°±å¯ä»¥é¿å… rehashï¼Œä»è€Œä¿è¯æ’å…¥ä¸å¤±æ•ˆã€‚

> è¿™ä¸ªé—®é¢˜è§¦åŠäº† **å“ˆå¸Œè¡¨ç»“æ„çš„æœ¬è´¨**ï¼Œæˆ‘ä»¬æ¥æ·±å…¥è§£é‡Šï¼š
> 
> **`unordered_map` rehash ä¼šé‡æ–°åˆ†é…å“ˆå¸Œæ¡¶å¹¶æ¬ç§»å…ƒç´ ä½ç½®**ï¼Œæ‰€ä»¥æ‰€æœ‰è¿­ä»£å™¨ï¼ˆåŒ…æ‹¬æŒ‡å‘å…ƒç´ çš„ï¼‰éƒ½**å¤±æ•ˆ**ã€‚
> 
> **å“ˆå¸Œè¡¨ï¼ˆhash tableï¼‰** å…¸å‹ç»“æ„å¦‚ä¸‹ï¼š
> 
>     å“ˆå¸Œæ¡¶æ•°ç»„ï¼ˆbucket arrayï¼‰ï¼š
>     +--------+--------+--------+--------+--------+
>     | bucket0| bucket1| bucket2| bucket3| bucket4|
>     +--------+--------+--------+--------+--------+
>          |        |        |        |        |
>          â†“        â†“        â†“        â†“        â†“
>        nodeA    nodeB    NULL     nodeC     nodeD
>     
> 
> æ¯ä¸ªæ¡¶æ˜¯ä¸€ä¸ª**é“¾è¡¨ï¼ˆæˆ–é“¾å¼ç»“æ„ï¼‰**ï¼Œç”¨äºå­˜æ”¾å“ˆå¸Œå€¼è½åœ¨è¯¥æ¡¶çš„å…ƒç´ ã€‚
> 
> å½“æ’å…¥å¤ªå¤šå…ƒç´ ï¼Œ**è´Ÿè½½å› å­ Î± = å…ƒç´ æ•° / æ¡¶æ•°**è¶…è¿‡ä¸€å®šé˜ˆå€¼æ—¶ï¼š
> 
> STL ä¼š **è‡ªåŠ¨æ‰©å®¹æ¡¶æ•°ç»„ï¼ˆrehashï¼‰**ï¼Œæ¯”å¦‚å°†æ¡¶æ•°ç¿»å€ï¼Œä» 8 â†’ 16 â†’ 32...
> 
> * * *
> 
> rehash ä¼šï¼š
> 
> *   åˆ†é… **æ–°çš„æ¡¶æ•°ç»„**ï¼ˆæ–°çš„å†…å­˜ç©ºé—´ï¼‰
> *   éå†æ—§å…ƒç´ ï¼Œ**é‡æ–°è®¡ç®—å“ˆå¸Œå€¼ % æ–°æ¡¶æ•°**ï¼Œå°†å®ƒä»¬**é‡æ–°åˆ†é…åˆ°æ–°æ¡¶**ä¸­
> *   æ¯ä¸ªå…ƒç´ çš„ä½ç½®ã€æ‰€å±æ¡¶ã€é“¾è¡¨ç»“æ„éƒ½**å…¨éƒ¨å˜äº†**

    std::unordered_set<int> us = {1,2,3};
    auto it = us.begin();
    us.insert(1000);  // æ’å…¥è¿‡å¤šå…ƒç´ è§¦å‘ rehash
    std::cout << *it;  // âŒ UBï¼Œåœ°å€å¯èƒ½å·²å˜åŒ–
    

* * *

##### ä¸ºä»€ä¹ˆåˆ é™¤æ“ä½œä¸€å®šä¼šå¯¼è‡´è¯¥å…ƒç´ è¿­ä»£å™¨å¤±æ•ˆï¼Ÿ

ä¸ç®¡æ˜¯çº¢é»‘æ ‘ï¼ˆæœ‰åºå®¹å™¨ï¼‰è¿˜æ˜¯å“ˆå¸Œè¡¨ï¼ˆæ— åºå®¹å™¨ï¼‰ï¼Œ`erase(it)` éƒ½ä¼šé”€æ¯è¯¥èŠ‚ç‚¹ â†’ è¿™ä¸ªåœ°å€å¤±æ•ˆï¼Œ`it` å¤±æ•ˆï¼š

    std::set<int> s = {1, 2, 3};
    auto it = s.find(2);
    s.erase(it);
    std::cout << *it;  // âŒ it å¤±æ•ˆï¼ˆæŒ‡å‘è¢«é‡Šæ”¾çš„èŠ‚ç‚¹ï¼‰
    

* * *

##### è¡¥å……ï¼šæ’å…¥æ—¶ï¼Œä¸ºä»€ä¹ˆ `set/map` å¯ä»¥ä¿è¯å…¶ä»–è¿­ä»£å™¨ç¨³å®šï¼Ÿ

å› ä¸º **æ–°èŠ‚ç‚¹æ°¸è¿œæ˜¯â€œæ–°åˆ†é…çš„â€ï¼Œä¸ä¼šå¹²æ‰°æ—§èŠ‚ç‚¹ä½ç½®**ï¼Œè€Œè¿­ä»£å™¨åªè¦æŒ‡å‘æ—§èŠ‚ç‚¹ï¼Œå°±ä¸ä¼šå¤±æ•ˆã€‚

### å¦‚ä½•é¿å…è¿­ä»£å™¨å¤±æ•ˆé—®é¢˜ï¼Ÿ

1.  æ¯æ¬¡æ’å…¥/åˆ é™¤/å˜æ›´ç»“æ„å**ä¸è¦ç»§ç»­ä½¿ç”¨åŸè¿­ä»£å™¨**

*   ç‰¹åˆ«æ˜¯ `vector` çš„ `push_back`ã€`insert`ã€`erase` ç­‰æ“ä½œ

2.  è‹¥ç®—æ³•ä¸­è¦è¾¹éå†è¾¹ä¿®æ”¹ç»“æ„ï¼Œè¯·ç”¨ï¼š

    it = container.erase(it);  // ä½¿ç”¨è¿”å›å€¼
    

3.  è‹¥éœ€è¦ä¿æŒè¿­ä»£å™¨ç¨³å®šï¼Œå¯è€ƒè™‘ç”¨ï¼š

*   `std::list`ï¼ˆæ’å…¥å®‰å…¨ï¼‰
*   `std::map` / `std::set`ï¼ˆæ’å…¥å®‰å…¨ï¼‰

ä¸ƒã€è¿­ä»£å™¨é€‚é…å™¨ï¼ˆIterator Adapterï¼‰
--------------------------

C++ STL æä¾›äº†ä¸‰ç§éå¸¸å®ç”¨çš„**è¿­ä»£å™¨é€‚é…å™¨ï¼ˆiterator adaptersï¼‰**ï¼Œç”¨äºå°† STL ç®—æ³•çš„è¾“å‡ºâ€œé€‚é…â€åˆ°å®¹å™¨çš„ä¸åŒæ’å…¥æ–¹å¼ã€‚

* * *

### è¿­ä»£å™¨é€‚é…å™¨æ€»è§ˆ

åç§°

æ’å…¥æ–¹å¼

é€‚ç”¨å®¹å™¨

åŸç†

`std::back_inserter`

è°ƒç”¨ `push_back`

`vector`, `deque`, `list`

æœ«å°¾æ’å…¥

`std::front_inserter`

è°ƒç”¨ `push_front`

`deque`, `list`

å¤´éƒ¨æ’å…¥

`std::inserter`

è°ƒç”¨ `insert(pos, val)`

`set`, `map`, `list`, `vector`

åœ¨æŒ‡å®šä½ç½®æ’å…¥æˆ–æ ¹æ®è§„åˆ™

å®ƒä»¬éƒ½å®šä¹‰åœ¨å¤´æ–‡ä»¶ï¼š

    #include <iterator>
    

### 1\. `std::back_inserter`

    std::back_inserter(container)
    

é€‚ç”¨äºæ”¯æŒ `push_back()` çš„å®¹å™¨ï¼Œå¦‚ `vector`, `deque`, `list`ã€‚

#### ç¤ºä¾‹ï¼š

    std::vector<int> src = {1, 2, 3};
    std::vector<int> dst;
    
    std::copy(src.begin(), src.end(), std::back_inserter(dst));
    // dst = {1, 2, 3}
    

* * *

### 2\. `std::front_inserter`

    std::front_inserter(container)
    

é€‚ç”¨äºæ”¯æŒ `push_front()` çš„å®¹å™¨ï¼Œå¦‚ `list`, `deque`ï¼ˆâš ï¸ `vector` ä¸æ”¯æŒï¼‰ã€‚

#### ç¤ºä¾‹ï¼š

    std::vector<int> src = {1, 2, 3};
    std::vector<int> dst;
    
    std::copy(src.begin(), src.end(), std::front_inserter(dst));
    // dst = {3, 2, 1}ï¼Œç›¸å½“äºååºæ’å…¥
    

* * *

### 3\. `std::inserter`

    std::inserter(container, pos)
    

é€‚ç”¨äºæ”¯æŒ `insert(pos, val)` æˆ– `insert(val)` çš„å®¹å™¨ï¼Œæ¯”å¦‚ï¼š

*   é¡ºåºå®¹å™¨ï¼š`list`, `vector`, `deque`
*   å…³è”å®¹å™¨ï¼š`set`, `map`, `unordered_set`, `unordered_map`

å®ƒçš„å·¥ä½œæ–¹å¼æ˜¯ï¼šæ¯æ¬¡è°ƒç”¨ `*it = val`ï¼Œä¼šå˜æˆ `container.insert(pos, val)` æˆ– `container.insert(val)`ï¼Œæ ¹æ®å®¹å™¨ç±»å‹è‡ªåŠ¨å¤„ç†ã€‚

#### ç¤ºä¾‹ï¼ˆvectorï¼‰ï¼š

    std::vector<int> v = {1, 4, 5};
    std::vector<int> to_insert = {2, 3};
    
    std::copy(to_insert.begin(), to_insert.end(), std::inserter(v, v.begin() + 1));
    // v = {1, 2, 3, 4, 5}
    

#### ç¤ºä¾‹ï¼ˆsetï¼‰ï¼š

    std::set<int> s;
    std::vector<int> v = {3, 1, 4};
    
    std::copy(v.begin(), v.end(), std::inserter(s, s.begin()));
    // s = {1, 3, 4}ï¼ˆè‡ªåŠ¨å»é‡ + æ’åºï¼‰
    

* * *

ç¤ºä¾‹å¯¹æ¯”
----

    #include <vector>
    #include <list>
    #include <set>
    #include <iterator>
    #include <algorithm>
    #include <iostream>
    
    int main() {
        std::vector<int> src = {1, 2, 3};
    
        // back_inserter
        std::vector<int> v;
        std::copy(src.begin(), src.end(), std::back_inserter(v));  // v = 1 2 3
    
        // front_inserter
        std::list<int> l;
        std::copy(src.begin(), src.end(), std::front_inserter(l));  // l = 3 2 1
    
        // inserter (middle insert into vector)
        std::vector<int> a = {0, 4};
        std::copy(src.begin(), src.end(), std::inserter(a, a.begin() + 1));  // a = 0 1 2 3 4
    
        // inserter (into set)
        std::set<int> s;
        std::copy(src.begin(), src.end(), std::inserter(s, s.begin()));  // s = 1 2 3
    }
    

å…«ã€è¿­ä»£å™¨çš„ç°ä»£æ›¿ä»£å“
-----------

### C++11 èŒƒå›´ for å¾ªç¯ï¼ˆrange-based for loopï¼‰

åœ¨ C++11 ä¸­ï¼Œå¼•å…¥äº†â€œ**èŒƒå›´ for å¾ªç¯ï¼ˆrange-based for loopï¼‰**â€è¯­æ³•ï¼Œå®ƒæ˜¯å¯¹ä¼ ç»Ÿè¿­ä»£å™¨éå†çš„ä¸€ç§ç®€åŒ–å°è£…ã€‚å®ƒæœ¬è´¨ä¸Šä»ç„¶ä¾èµ–äº**è¿­ä»£å™¨æ¥å£**ï¼Œåªæ˜¯æŠŠç¼–å†™è¿­ä»£å™¨çš„æ¨¡æ¿ä»£ç è—åœ¨äº†è¯­æ³•ç³–åé¢ã€‚

* * *

#### 1ã€è¯­æ³•ç¤ºä¾‹

å†™æ³•

è¯´æ˜

`for (int x : v)`

æ‹·è´å…ƒç´ ï¼ˆæ— æ³•ä¿®æ”¹åŸå§‹å®¹å™¨ï¼‰

`for (int& x : v)`

å¼•ç”¨è®¿é—®å…ƒç´ ï¼ˆå¯ä¿®æ”¹ï¼‰

`for (const int& x : v)`

å¸¸é‡å¼•ç”¨ï¼ˆèŠ‚çœæ‹·è´æˆæœ¬ï¼Œæ— æ³•ä¿®æ”¹ï¼‰

    #include <iostream>
    #include <vector>
    
    int main() {
        std::vector<int> vec = {1, 2, 3, 4};
        // ä½¿ç”¨èŒƒå›´ for å¾ªç¯
        for (int x : vec) {
            std::cout << x << " ";
        }
        std::cout<< std::endl;
        // ç­‰ä»·äº
        for (auto it = vec.begin(); it != vec.end(); ++it) {
            int x = *it;
            std::cout << x << " ";
        }
    }
    
    

    #include <iostream>
    #include <vector>
    
    int main() {
        std::vector<int> vec1 = {1, 2, 3, 4};
        std::vector<int> vec2 = {1, 2, 3, 4};
    
        // å¦‚æœä½¿ç”¨å¼•ç”¨æˆ–å¼•ç”¨ä¿®æ”¹
        for (int& x : vec1) {
            x *= 2;  // ä¿®æ”¹å…ƒç´ å€¼
        }
        for (int x : vec1) {
            std::cout << x << " ";
        }
        
        std::cout<< std::endl;
        // ç­‰ä»·äº
        for (auto it = vec2.begin(); it != vec2.end(); ++it) {
            *it *= 2;
        }
        for (int x : vec2) {
            std::cout << x << " ";
        }
    }
    
    

#### 2ã€å·¥ä½œåŸç†ï¼šä½¿ç”¨ `begin()` å’Œ `end()`

ç¼–è¯‘å™¨åœ¨å¤„ç† `for (auto x : container)` æ—¶ä¼šï¼š

    {
        auto __begin = std::begin(container);
        auto __end = std::end(container);
        for (; __begin != __end; ++__begin) {
            auto x = *__begin;
            // å¾ªç¯ä½“
        }
    }
    

å³ï¼š

*   ä½¿ç”¨å®¹å™¨çš„ `begin()` å’Œ `end()` å‡½æ•°è·å–è¿­ä»£å™¨èŒƒå›´
*   ä½¿ç”¨è¿­ä»£å™¨ `*` è®¿é—®å…ƒç´ ï¼Œ`++` è¿›è¡Œéå†

æ”¯æŒ `range-based for` çš„å…³é”®ï¼šå®¹å™¨å¿…é¡»æœ‰ `begin()` å’Œ `end()` æ–¹æ³•ï¼ˆæˆå‘˜æˆ–éæˆå‘˜ï¼‰è¿”å›è¿­ä»£å™¨ã€‚

### C++20 Ranges

C++20 å¼•å…¥ `ranges`ï¼Œç®€åŒ–è¿­ä»£å™¨å’Œç®—æ³•ç»“åˆçš„å†™æ³•ï¼š

C++20 å¼•å…¥çš„ **Ranges** æ˜¯å¯¹ä¼ ç»Ÿ STL ç®—æ³•ä¸è¿­ä»£å™¨ä½“ç³»çš„é‡å¤§å‡çº§ï¼Œå®ƒè®©å®¹å™¨æ“ä½œæ›´åŠ **ç›´è§‚ã€å¯ç»„åˆã€å‡½æ•°å¼ã€æ‡’æƒ°ï¼ˆlazyï¼‰**ï¼Œæ˜¯ C++ æ³›å‹ç¼–ç¨‹çš„ä¸€å¤§è¿›æ­¥ã€‚

* * *

#### 1ã€ä»€ä¹ˆæ˜¯ Rangesï¼Ÿ

æ›´ **ç®€æ´**ï¼Œæ›´ **å¯è¯»** ï¼Œ**æ‡’æƒ°æ±‚å€¼**ï¼ˆåªæœ‰éå†æ—¶æ‰è®¡ç®—ï¼‰ï¼Œæ›´ **æ˜“ç»„åˆ**

å¯¹ä¸€ä¸ªvector**å–å¥‡æ•°ï¼Œä¹˜2ï¼Œå‰3ä¸ª**çš„æ“ä½œï¼š

    #include <algorithm>
    #include <iostream>
    #include <ranges>
    #include <vector>
    
    int main() {
        std::vector<int> v = {1, 2, 3, 4, 5};
    
        // å–å¥‡æ•°ï¼Œæ’åºï¼Œåªä¿ç•™å‰ä¸¤ä¸ªå…ƒç´ 
        // ç¬¬ä¸€æ­¥ï¼šfilter - ç­›é€‰å¥‡æ•°
        std::vector<int> filtered;
        std::copy_if(v.begin(), v.end(), std::back_inserter(filtered),
                     [](int x) { return x % 2 == 1; });
    
        // ç¬¬äºŒæ­¥ï¼štransform - ä¹˜2
        std::vector<int> transformed;
        std::transform(filtered.begin(), filtered.end(), std::back_inserter(transformed),
                       [](int x) { return x * 10; });
    
        // ç¬¬ä¸‰æ­¥ï¼štake 3 - å–å‰3ä¸ª
        std::vector<int> result;
        std::copy_n(transformed.begin(),
                    std::min<size_t>(3, transformed.size()),
                    std::back_inserter(result));
    
        // è¾“å‡ºç»“æœ
        for (int x : result) {
            std::cout << x << " ";
        }
    
        // c++20 ç®¡é“å¼ç»„åˆï¼šå–å¥‡æ•°ï¼Œä¹˜2ï¼Œå‰3ä¸ª
        auto view = v
                    | std::views::filter([](int x){ return x % 2 == 1; })
                    | std::views::transform([](int x){ return x * 10; })
                    | std::views::take(3);
    
        for (int x : view) {
            std::cout << x << " ";
        }
    
    }
    
    

#### 2ã€æ ¸å¿ƒç»„æˆ

Ranges å¤´æ–‡ä»¶

    #include <ranges>  // æ‰€æœ‰ ranges ç»„ä»¶
    

* * *

Viewsï¼ˆè§†å›¾ï¼‰ - æ ¸å¿ƒç‰¹æ€§

åç§°

è¯´æ˜

ç¤ºä¾‹

`views::filter`

è¿‡æ»¤å…ƒç´ 

`x % 2 == 0`

`views::transform`

å…ƒç´ å˜æ¢

`x * 2`

`views::take(n)`

å–å‰ n ä¸ªå…ƒç´ 

`take(5)`

`views::drop(n)`

è·³è¿‡å‰ n ä¸ªå…ƒç´ 

`drop(3)`

`views::reverse`

åè½¬è§†å›¾

`views::iota(start, end)`

ç”Ÿæˆæ•°åˆ—

`iota(1, 10)`

`views::enumerate`

å¸¦ç´¢å¼•

C++23 å¼•å…¥

#### 3ã€Range ä¸å®¹å™¨çš„åŒºåˆ«

é¡¹ç›®

å®¹å™¨ï¼ˆå¦‚ vectorï¼‰

Ranges View

æ˜¯å¦æŒæœ‰æ•°æ®

æ˜¯ï¼ˆæ‹¥æœ‰æ‰€æœ‰æƒï¼‰

å¦ï¼ˆå¼•ç”¨æˆ–åŒ…è£…ï¼‰

æ˜¯å¦æ‡’æƒ°æ±‚å€¼

å¦ï¼ˆç«‹å³è®¡ç®—ï¼‰

æ˜¯ï¼ˆæŒ‰éœ€è®¡ç®—ï¼‰

æ˜¯å¦å¯ç»„åˆ

éœ€è¦ä¸´æ—¶å˜é‡

å¯ä»¥é“¾å¼ç»„åˆ

å¼€é”€

å¤åˆ¶å†…å­˜

å‡ ä¹ä¸ºé›¶å¼€é”€ï¼ˆæŒ‰éœ€ç”Ÿæˆï¼‰

* * *

#### 4ã€ä¸ç®—æ³•ç»“åˆï¼ˆ`ranges::`ï¼‰

C++20 å¼•å…¥ `std::ranges::` ä¸‹çš„ç®—æ³•ï¼Œæ›¿ä»£ä¼ ç»Ÿ `<algorithm>` ç‰ˆæœ¬ï¼Œæ”¯æŒ**range** ä½œä¸ºè¾“å…¥ã€‚

    #include <ranges>
    #include <algorithm>
    
    std::vector<int> v = {3, 1, 4, 1, 5};
    
    // æ›´ç®€æ´çš„å†™æ³•ï¼š
    std::ranges::sort(v);  // ä¸éœ€è¦æ‰‹åŠ¨ä¼  begin/end
    

*   è®¸å¤šç®—æ³•æ¥å— range æˆ– iteratorï¼š
    *   `ranges::find(range, value)`
    *   `ranges::count(range, pred)`
    *   `ranges::for_each(range, fn)`
    *   `ranges::all_of(range, pred)`

STL å¸¸ç”¨ç®—æ³•
========

C++ STLï¼ˆæ ‡å‡†æ¨¡æ¿åº“ï¼‰æä¾›äº†å¤§é‡**æ³›å‹ç®—æ³•**ï¼Œä½äºå¤´æ–‡ä»¶ `<algorithm>` å’Œ `<numeric>` ä¸­ã€‚å®ƒä»¬åŸºäºè¿­ä»£å™¨è®¾è®¡ï¼Œæ”¯æŒå‡ ä¹æ‰€æœ‰ STL å®¹å™¨ï¼ˆå¦‚ `vector`, `list`, `set`, `map` ç­‰ï¼‰ã€‚

ä»¥ä¸‹æ˜¯å¯¹ STL **å¸¸ç”¨ç®—æ³•åˆ†ç±»åŠç”¨æ³•**çš„ç³»ç»Ÿæ€»ç»“ï¼Œå¹¶é™„ä¸Šç¤ºä¾‹ã€‚

* * *

ä¸€ã€å¤´æ–‡ä»¶è¯´æ˜
-------

    #include <algorithm>  // ç»å¤§å¤šæ•° STL ç®—æ³•
    #include <numeric>    // accumulate, inner_product ç­‰
    

* * *

äºŒã€STL ç®—æ³•åˆ†ç±»æ€»è§ˆ
------------

ç±»åˆ«

å¸¸ç”¨ç®—æ³•

åŠŸèƒ½æè¿°

éå†ç±»

`for_each`, `transform`

å¯¹æ¯ä¸ªå…ƒç´ æ‰§è¡Œæ“ä½œ

æŸ¥æ‰¾ç±»

`find`, `find_if`, `count`, `binary_search`

æŸ¥æ‰¾å…ƒç´ 

ä¿®æ”¹ç±»

`copy`, `replace`, `fill`, `remove`

ä¿®æ”¹æˆ–ç”Ÿæˆæ–°æ•°æ®

æ’åºç±»

`sort`, `stable_sort`, `reverse`, `partial_sort`

æ’åºä¸é‡æ’

æ¯”è¾ƒç±»

`equal`, `mismatch`, `lexicographical_compare`

æ¯”è¾ƒåŒºé—´å†…å®¹

æ•°å€¼ç±»

`accumulate`, `inner_product`, `iota`

æ•°å€¼è®¡ç®—

é›†åˆç±»

`set_union`, `set_intersection`, `set_difference`

éœ€è¦æ’åº

åˆ†åŒºç±»

`partition`, `stable_partition`, `is_partitioned`

åˆ†ç»„å…ƒç´ 

è¾…åŠ©ç±»

`min`, `max`, `swap`, `iter_swap`

è¾…åŠ©æ“ä½œ

* * *

ä¸‰ã€å¸¸ç”¨ç®—æ³•è¯¦è§£ä¸ç¤ºä¾‹
-----------

### 1\. éå†ç±»

`std::for_each` å’Œ `std::transform` æ˜¯ C++ STL ä¸­ä¸¤ä¸ªéå¸¸å¸¸ç”¨çš„ç®—æ³•å‡½æ•°ï¼Œå®ƒä»¬éƒ½ç”¨äº**éå†å®¹å™¨å…ƒç´ å¹¶å¯¹å…¶åº”ç”¨æŸç§æ“ä½œ**ï¼Œä½†ç”¨é€”ç•¥æœ‰ä¸åŒã€‚

#### `std::for_each`

å¯¹æŒ‡å®šèŒƒå›´å†…çš„**æ¯ä¸ªå…ƒç´ æ‰§è¡ŒæŸä¸ªæ“ä½œ**ï¼Œ**ä¸è¿”å›æ–°å®¹å™¨**ã€‚åŸå‹ï¼š

    template<class InputIterator, class Function>
    Function for_each(InputIterator first, InputIterator last, Function f);
    

*   å¯¹å®¹å™¨ä¸­å…ƒç´ åº”ç”¨ `f(x)`
*   å¸¸ç”¨äºæ‰“å°ã€ç´¯åŠ ç­‰å‰¯ä½œç”¨æ“ä½œ
*   ä¸ä¼šæ”¹å˜å®¹å™¨å†…å®¹ï¼ˆé™¤é `f` ä¿®æ”¹å¼•ç”¨ï¼‰

ğŸ“¦ ç¤ºä¾‹ï¼š

    #include <iostream>
    #include <vector>
    #include <algorithm>
    
    int main() {
        std::vector<int> v = {1, 2, 3, 4};
        std::for_each(v.begin(), v.end(), [](int x) {
            std::cout << x << " ";
        });
        std::cout << std::endl; 
        // ğŸ’¡ å¦‚æœä½ ç”¨å¼•ç”¨å‚æ•°ï¼Œå¯ä»¥ä¿®æ”¹å®¹å™¨å…ƒç´ ï¼š
        std::for_each(v.begin(), v.end(), [](int &x) { x *= 2; });
        std::for_each(v.begin(), v.end(), [](int x) {
            std::cout << x << " ";
        });
    }
    //è¾“å‡º
    1 2 3 4 
    2 4 6 8 
    Process finished with exit code 0
    

* * *

#### `std::transform`

å¯¹ä¸€ä¸ªï¼ˆæˆ–ä¸¤ä¸ªï¼‰åŒºé—´ä¸­çš„å…ƒç´ åº”ç”¨å‡½æ•°ï¼Œå¹¶å°†ç»“æœ**å†™å…¥å¦ä¸€ä¸ªåŒºé—´**ï¼Œ**è¿”å›çš„æ˜¯ç»“æœè¿­ä»£å™¨**ã€‚

åŸå‹ï¼ˆå•è¾“å…¥ï¼‰ï¼š

    template<class InputIterator, class OutputIterator, class UnaryOperation>
    OutputIterator transform(InputIterator first1, InputIterator last1,
                             OutputIterator result, UnaryOperation op);
    

ç‰¹ç‚¹ï¼š

*   è¾“å…¥ä¸€ä¸ªæˆ–ä¸¤ä¸ªåŒºé—´ï¼Œè¾“å‡ºä¸€ä¸ªæ–°ç»“æœåŒºé—´
*   ä¸ä¿®æ”¹åŸå§‹å®¹å™¨
*   å¸¸ç”¨äºâ€œæ˜ å°„â€ï¼ˆmapï¼‰æ“ä½œ

ç¤ºä¾‹ï¼ˆå•è¾“å…¥ï¼‰ï¼š

    std::vector<int> v = {1, 2, 3};
    std::vector<int> result;
    
    std::transform(v.begin(), v.end(), std::back_inserter(result),
                   [](int x){ return x * 2; });  // result = {2, 4, 6}
    

ç¤ºä¾‹ï¼ˆåŒè¾“å…¥ï¼‰ï¼š

    std::vector<int> a = {1, 2, 3};
    std::vector<int> b = {4, 5, 6};
    std::vector<int> result;
    
    std::transform(a.begin(), a.end(), b.begin(), std::back_inserter(result),
                   [](int x, int y){ return x + y; });  // result = {5, 7, 9}
    

* * *

#### æ€»ç»“å¯¹æ¯”

é¡¹ç›®

`std::for_each`

`std::transform`

æ˜¯å¦æœ‰è¾“å‡ºå®¹å™¨

å¦

æ˜¯ï¼Œç»“æœå†™å…¥æ–°å®¹å™¨

ç”¨é€”

éå†æ‰“å°/ä¿®æ”¹/ç»Ÿè®¡

æ˜ å°„ç”Ÿæˆæ–°æ•°æ®

æ˜¯å¦èƒ½ä¿®æ”¹åŸå®¹å™¨

æ˜¯ï¼ˆé€šè¿‡å¼•ç”¨ï¼‰

å¦ï¼ˆé»˜è®¤å†™å…¥æ–°å®¹å™¨ï¼‰

æ˜¯å¦æ‡’æƒ°æ±‚å€¼

å¦

å¦

ç­‰ä»·äº

Python çš„ `for x in`

Python çš„ `map()`

* * *

#### é€‰æ‹©å»ºè®®ï¼š

*   éœ€è¦**å¯¹å…ƒç´ è¿›è¡Œå¤„ç†æˆ–æ”¶é›†** â†’ ä½¿ç”¨ `std::transform`
*   åªæƒ³**å¯¹æ¯ä¸ªå…ƒç´ åšæ“ä½œï¼ˆå¦‚æ‰“å°ã€ä¿®æ”¹ï¼‰** â†’ ä½¿ç”¨ `std::for_each`

### 2\. æŸ¥æ‰¾ç±»

å½“ç„¶ï¼Œä¸‹é¢æ˜¯å¯¹ C++ STL ä¸­ **æŸ¥æ‰¾ç±»ç®—æ³•** çš„ç³»ç»Ÿæ•´ç†å’Œè¯¦ç»†è®²è§£ï¼ŒåŒ…æ‹¬åŠŸèƒ½ã€ä½¿ç”¨æ–¹å¼ã€é€‚ç”¨åœºæ™¯å’Œç¤ºä¾‹ä»£ç ã€‚ä½ å°†äº†è§£å¦‚ä½•ç”¨æ ‡å‡†åº“é«˜æ•ˆåœ°åœ¨å„ç§å®¹å™¨ä¸­æŸ¥æ‰¾ã€å®šä½å’Œåˆ¤æ–­å…ƒç´ ã€‚

* * *

#### æŸ¥æ‰¾ç±»ç®—æ³•æ€»è§ˆ

ç®—æ³•å

åŠŸèƒ½

ç‰¹ç‚¹

`std::find`

æŸ¥æ‰¾ç­‰äºæŸå€¼çš„å…ƒç´ 

çº¿æ€§æŸ¥æ‰¾

`std::find_if` / `find_if_not`

æŸ¥æ‰¾æ»¡è¶³ï¼ˆæˆ–ä¸æ»¡è¶³ï¼‰æŸæ¡ä»¶çš„å…ƒç´ 

å¯è‡ªå®šä¹‰è°“è¯

`std::count` / `count_if`

ç»Ÿè®¡ç­‰äºæŸå€¼ï¼ˆæˆ–æ»¡è¶³æ¡ä»¶ï¼‰çš„å…ƒç´ ä¸ªæ•°

çº¿æ€§ç»Ÿè®¡

`std::any_of` / `all_of` / `none_of`

åˆ¤æ–­æ˜¯å¦å­˜åœ¨ã€å…¨éƒ¨ã€å…¨éƒ¨ä¸æ»¡è¶³æŸæ¡ä»¶

å¿«é€Ÿåˆ¤æ–­

`std::search` / `search_n`

æŸ¥æ‰¾å­åºåˆ—æˆ–é‡å¤å€¼

åŒºé—´æŸ¥æ‰¾

`std::adjacent_find`

æŸ¥æ‰¾ç›¸é‚»é‡å¤å…ƒç´ 

è¿ç»­åˆ¤æ–­

`std::binary_search`

äºŒåˆ†æŸ¥æ‰¾

æœ‰åºåŒºé—´

`std::lower_bound` / `upper_bound`

æŸ¥æ‰¾ç¬¬ä¸€ä¸ªä¸å°äº / å¤§äºæŒ‡å®šå€¼çš„ä½ç½®

æœ‰åºåŒºé—´

`std::equal_range`

åŒæ—¶è¿”å› `lower_bound` å’Œ `upper_bound`

èŒƒå›´æŸ¥æ‰¾

* * *

#### 1\. `std::find`

åœ¨çº¿æ€§åºåˆ—ä¸­æŸ¥æ‰¾â€œç­‰äºæŸå€¼â€çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

    template<class InputIt, class T>
    InputIt find(InputIt first, InputIt last, const T& value);
    

ç¤ºä¾‹ï¼š

    std::vector<int> v = {1, 2, 3, 4};
    auto it = std::find(v.begin(), v.end(), 3);
    if (it != v.end()) std::cout << "Found: " << *it;
    

* * *

#### 2\. `std::find_if` / `find_if_not`

æŸ¥æ‰¾**æ»¡è¶³ï¼ˆæˆ–ä¸æ»¡è¶³ï¼‰è°“è¯æ¡ä»¶**çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

    template<class InputIt, class UnaryPredicate>
    InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
    

ç¤ºä¾‹ï¼š

    auto it = std::find_if(v.begin(), v.end(), [](int x){ return x % 2 == 0; });  // ç¬¬ä¸€ä¸ªå¶æ•°
    

* * *

#### 3\. `std::count` / `count_if`

ç»Ÿè®¡ç­‰äºæŸå€¼ï¼Œæˆ–æ»¡è¶³æŸæ¡ä»¶çš„å…ƒç´ ä¸ªæ•°ã€‚

ç¤ºä¾‹ï¼š

    int n1 = std::count(v.begin(), v.end(), 5);  // æœ‰å‡ ä¸ª 5
    int n2 = std::count_if(v.begin(), v.end(), [](int x){ return x > 3; });  // æœ‰å‡ ä¸ªå¤§äº3
    

* * *

#### 4\. `std::any_of` / `all_of` / `none_of`

å‡½æ•°

åŠŸèƒ½

`any_of`

æœ‰ä»»æ„ä¸€ä¸ªæ»¡è¶³

`all_of`

æ‰€æœ‰éƒ½æ»¡è¶³

`none_of`

å…¨éƒ¨éƒ½ä¸æ»¡è¶³

ç¤ºä¾‹ï¼š

    bool any_even = std::any_of(v.begin(), v.end(), [](int x){ return x % 2 == 0; });
    bool all_positive = std::all_of(v.begin(), v.end(), [](int x){ return x > 0; });
    bool none_negative = std::none_of(v.begin(), v.end(), [](int x){ return x < 0; });
    

* * *

#### 5\. `std::adjacent_find`

æŸ¥æ‰¾**ç›¸é‚»çš„ä¸¤ä¸ªç›¸ç­‰å…ƒç´ **æˆ–æ»¡è¶³æŸè‡ªå®šä¹‰æ¡ä»¶çš„ä¸€å¯¹ç›¸é‚»å…ƒç´ ã€‚

ç¤ºä¾‹ï¼š

    std::vector<int> v = {1, 2, 2, 3, 4};
    auto it = std::adjacent_find(v.begin(), v.end());  // æ‰¾åˆ°ç¬¬ä¸€ä¸ª 2,2
    

* * *

#### 6\. `std::search` / `search_n`

åœ¨åºåˆ—ä¸­æŸ¥æ‰¾æŸä¸ª**å­åºåˆ—** æˆ– **è¿ç»­ n ä¸ªå€¼** å‡ºç°çš„ä½ç½®ã€‚

ç¤ºä¾‹ï¼š

**`std::search` â€“ æŸ¥æ‰¾å­åºåˆ—**

    std::vector<int> v = {1,2,3,4,5};
    std::vector<int> pattern = {3,4};
    auto it = std::search(v.begin(), v.end(), pattern.begin(), pattern.end());
    

**`std::search_n` â€“ æŸ¥æ‰¾ n è¿ç»­å€¼**

    auto it = std::search_n(v.begin(), v.end(), 3, 7);  // è¿ç»­3ä¸ª7
    

* * *

#### 7\. äºŒåˆ†æŸ¥æ‰¾ç±»ï¼ˆâš  éœ€è¦å·²æ’åºï¼‰

å¸¸ç”¨äºï¼š`vector`, `array`, æˆ– `set` ä¸­ï¼Œå…ƒç´ æŒ‰å‡åºæ’åˆ—

**`std::binary_search`ï¼ˆåªè¿”å›æ˜¯å¦å­˜åœ¨ï¼‰**

    std::sort(v.begin(), v.end());  // å¿…é¡»æ’åº
    bool found = std::binary_search(v.begin(), v.end(), 5);
    

**`std::lower_bound` / `upper_bound`**

å‡½æ•°

è¿”å›

`lower_bound`

ç¬¬ä¸€ä¸ª â‰¥ val çš„ä½ç½®

`upper_bound`

ç¬¬ä¸€ä¸ª > val çš„ä½ç½®

    auto lb = std::lower_bound(v.begin(), v.end(), 5);
    auto ub = std::upper_bound(v.begin(), v.end(), 5);
    

**`std::equal_range`**

    auto [low, up] = std::equal_range(v.begin(), v.end(), 5);  // ä¸€æ¬¡æŸ¥ä¸¤ä¸ª
    

* * *

ç¤ºä¾‹ï¼šè®¡æ•°æœ‰å‡ ä¸ªç­‰äº 5 çš„å…ƒç´ ï¼ˆå·²æ’åºå®¹å™¨ï¼‰

    int count = std::upper_bound(v.begin(), v.end(), 5) -
                std::lower_bound(v.begin(), v.end(), 5);
    

* * *

#### æŸ¥æ‰¾ç±»ç®—æ³•ä½¿ç”¨å»ºè®®

åœºæ™¯

æ¨èç®—æ³•

ç²¾ç¡®æŸ¥æ‰¾

`std::find`

æ¡ä»¶æŸ¥æ‰¾

`std::find_if`

è®¡æ•°å€¼å‡ºç°æ¬¡æ•°

`std::count`

åˆ¤æ–­æ˜¯å¦æœ‰æŸç§å…ƒç´ 

`std::any_of`

ç›¸é‚»é‡å¤æŸ¥æ‰¾

`std::adjacent_find`

æŸ¥æ‰¾å­åºåˆ—

`std::search`

äºŒåˆ†æŸ¥æ‰¾ï¼ˆæœ‰åºï¼‰

`std::binary_search`, `lower_bound`

* * *

#### æ€§èƒ½

ç®—æ³•

æ—¶é—´å¤æ‚åº¦

è¦æ±‚

`find`, `count` ç­‰çº¿æ€§æŸ¥æ‰¾

O(n)

æ— éœ€æ’åº

`binary_search`, `lower_bound`

O(log n)

**å¿…é¡»æ’åº**ï¼Œæ”¯æŒéšæœºè®¿é—®è¿­ä»£å™¨

* * *

### 3\. ä¿®æ”¹ç±»

* * *

#### ä¿®æ”¹ç±»ç®—æ³•æ€»è§ˆ

ç±»åˆ«

ç®—æ³•å

åŠŸèƒ½

æ‹·è´ç±»

`std::copy`, `copy_n`, `copy_if`, `move`

æ‹·è´å…ƒç´ æˆ–ç§»åŠ¨å…ƒç´ 

æ›¿æ¢ç±»

`std::replace`, `replace_if`, `replace_copy`

æ›¿æ¢æ»¡è¶³æ¡ä»¶çš„å…ƒç´ 

å¡«å……ç±»

`std::fill`, `fill_n`, `generate`, `generate_n`, `iota`

å¡«å……æˆ–ç”Ÿæˆå…ƒç´ 

åˆ é™¤ç±»

`std::remove`, `remove_if`, `unique`

ç§»é™¤æˆ–å‹ç¼©å…ƒç´ ï¼ˆæƒ°æ€§ï¼‰

äº¤æ¢ç±»

`std::swap`, `iter_swap`, `swap_ranges`

äº¤æ¢å…ƒç´ æˆ–èŒƒå›´

åè½¬ç±»

`std::reverse`, `reverse_copy`, `rotate`, `shuffle`

è°ƒæ•´å…ƒç´ é¡ºåº

* * *

#### 1\. æ‹·è´ç±»

##### `std::copy` â€“ å¤åˆ¶æ•´ä¸ªåŒºé—´

    std::copy(src.begin(), src.end(), dest.begin());
    

*   æ³¨æ„ `dest` å¿…é¡»æœ‰è¶³å¤Ÿç©ºé—´ï¼Œæˆ–ç”¨ `back_inserter` å¢é•¿å®¹å™¨ã€‚

##### `std::copy_if` â€“ æ¡ä»¶å¤åˆ¶

    std::copy_if(v.begin(), v.end(), std::back_inserter(result),
                 [](int x){ return x % 2 == 0; });
    

##### `std::copy_n` â€“ å¤åˆ¶å›ºå®šæ•°é‡å…ƒç´ 

    std::copy_n(src.begin(), 5, std::back_inserter(result));
    

* * *

#### 2\. æ›¿æ¢ç±»

##### `std::replace` â€“ æ›¿æ¢å€¼

    std::replace(v.begin(), v.end(), 3, 99);  // æŠŠ 3 æ›¿æ¢æˆ 99
    

##### `std::replace_if` â€“ æ»¡è¶³æ¡ä»¶çš„å…ƒç´ è¢«æ›¿æ¢

    std::replace_if(v.begin(), v.end(), [](int x){ return x < 0; }, 0);
    

##### `std::replace_copy` â€“ æ›¿æ¢å¹¶å†™å…¥å¦ä¸€ä¸ªå®¹å™¨

    std::replace_copy(v.begin(), v.end(), std::back_inserter(result), 3, 100);
    

* * *

#### 3\. å¡«å……ç±»

##### `std::fill` â€“ å°†åŒºé—´å¡«å……ä¸ºæŸä¸ªå€¼

    std::fill(v.begin(), v.end(), 0);
    

##### `std::fill_n` â€“ ä»èµ·ç‚¹å¡«å…… n ä¸ªå€¼

    std::fill_n(v.begin(), 5, 1);
    

##### `std::generate` â€“ ç”¨å‡½æ•°å¡«å……åŒºé—´

    int n = 0;
    std::generate(v.begin(), v.end(), [&](){ return ++n; });  // v = {1,2,3,...}
    

##### `std::generate_n`

    std::generate_n(std::back_inserter(v), 5, [](){ return rand(); });
    

##### `std::iota`ï¼ˆåœ¨ `<numeric>` ä¸­ï¼‰â€“ é€’å¢å¡«å……

    std::iota(v.begin(), v.end(), 1);  // v = {1, 2, 3, ...}
    

* * *

#### 4\. åˆ é™¤ç±»ï¼ˆæƒ°æ€§åˆ é™¤ï¼Œéœ€è¦é…åˆ `erase`ï¼‰

##### `std::remove` â€“ ç§»é™¤æŸä¸ªå€¼ï¼ˆä¸æ”¹å˜å®¹å™¨å¤§å°ï¼‰

    auto it = std::remove(v.begin(), v.end(), 3);
    v.erase(it, v.end());  // ç‰©ç†åˆ é™¤
    

##### `std::remove_if` â€“ æŒ‰æ¡ä»¶ç§»é™¤å…ƒç´ 

    auto it = std::remove_if(v.begin(), v.end(), [](int x){ return x < 0; });
    v.erase(it, v.end());
    

##### `std::unique` â€“ ç§»é™¤ç›¸é‚»é‡å¤å…ƒç´ 

    std::sort(v.begin(), v.end());
    auto it = std::unique(v.begin(), v.end());
    v.erase(it, v.end());  // åªä¿ç•™å”¯ä¸€å€¼
    

* * *

#### 5\. äº¤æ¢ç±»

##### `std::swap` â€“ äº¤æ¢ä¸¤ä¸ªå˜é‡

    std::swap(a, b);
    

##### `std::iter_swap` â€“ äº¤æ¢ä¸¤ä¸ªè¿­ä»£å™¨æŒ‡å‘çš„å…ƒç´ 

    std::iter_swap(it1, it2);
    

##### `std::swap_ranges` â€“ äº¤æ¢ä¸¤ä¸ªåŒºé—´å…ƒç´ 

    std::swap_ranges(a.begin(), a.end(), b.begin());
    

* * *

#### 6\. åè½¬ç±» / é‡æ’ç±»

##### `std::reverse` â€“ åŸåœ°åè½¬åŒºé—´

    std::reverse(v.begin(), v.end());
    

##### `std::reverse_copy`

    std::reverse_copy(v.begin(), v.end(), std::back_inserter(result));
    

##### `std::rotate` â€“ å·¦æ—‹æˆ–å³æ—‹

    std::rotate(v.begin(), v.begin() + 2, v.end());  // å·¦æ—‹ 2 ä½
    

##### `std::shuffle`ï¼ˆC++11 èµ·ï¼‰

    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(v.begin(), v.end(), g);
    

* * *

#### ç¤ºä¾‹ï¼šä»å®¹å™¨ä¸­åˆ å»æ‰€æœ‰è´Ÿæ•°ï¼Œå¹¶å°†å‰©ä¸‹çš„æ•°å…¨éƒ¨ç¿»å€

    std::vector<int> v = {-1, 2, -3, 4, 5};
    
    // 1. åˆ é™¤è´Ÿæ•°
    v.erase(std::remove_if(v.begin(), v.end(), [](int x){ return x < 0; }), v.end());
    
    // 2. ç¿»å€ï¼ˆç”¨ transform ä¿®æ”¹åŸå®¹å™¨ï¼‰
    std::transform(v.begin(), v.end(), v.begin(), [](int x){ return x * 2; });
    

* * *

#### æ€»ç»“å¯¹æ¯”è¡¨

ç®—æ³•

åŠŸèƒ½

æ³¨æ„äº‹é¡¹

`copy`, `copy_if`, `copy_n`

æ‹·è´åŒºé—´å…ƒç´ 

è¾“å‡ºå®¹å™¨è¦é¢„ç•™ç©ºé—´

`replace`, `replace_if`

æ›¿æ¢å…ƒç´ 

æ”¹å˜åŸå®¹å™¨å†…å®¹

`fill`, `generate`, `iota`

æ‰¹é‡å¡«å……

å¸¸ç”¨äºåˆå§‹åŒ–å®¹å™¨

`remove`, `remove_if`

ç§»é™¤å…ƒç´ ï¼ˆæƒ°æ€§ï¼‰

éœ€ `erase` æ‰çœŸæ­£åˆ é™¤

`reverse`, `rotate`, `shuffle`

è°ƒæ•´é¡ºåº

å¯ç”¨äºæ‰“ä¹±ã€ç§»åŠ¨ã€ç¿»è½¬

`swap`, `iter_swap`

å…ƒç´ äº’æ¢

å¸¸ç”¨äºæ’åºå†…éƒ¨å®ç°

### 4\. æ’åºç±»

å½“ç„¶ï¼Œä¸‹é¢æ˜¯å¯¹ C++ STL ä¸­ **æ’åºç±»ç®—æ³•ï¼ˆSorting Algorithmsï¼‰** çš„**è¯¦ç»†ä»‹ç»**ï¼ŒåŒ…æ‹¬å¸¸ç”¨å‡½æ•°ã€åŠŸèƒ½å·®å¼‚ã€é€‚ç”¨åœºæ™¯ã€æ€§èƒ½ï¼Œä»¥åŠä½¿ç”¨ç¤ºä¾‹ã€‚

* * *

#### æ’åºç±»ç®—æ³•æ€»è§ˆ

ç®—æ³•åç§°

åŠŸèƒ½

ç‰¹ç‚¹

`std::sort`

å¿«é€Ÿæ’åºï¼Œé»˜è®¤å‡åº

**æœ€å¿«**ï¼Œä¸ç¨³å®šæ’åº

`std::stable_sort`

ç¨³å®šæ’åºï¼ˆå½’å¹¶ï¼‰

ä¿ç•™ç›¸ç­‰å…ƒç´ ç›¸å¯¹é¡ºåº

`std::partial_sort`

åªæ’åºå‰ `k` ä¸ªå…ƒç´ 

éƒ¨åˆ†æ’åº

`std::nth_element`

å°†ç¬¬ n å°å…ƒç´ æ”¾åˆ°ç¬¬ n ä½

éå®Œå…¨æ’åºï¼Œé€‚åˆæ‰¾ä¸­ä½æ•°

`std::is_sorted`

åˆ¤æ–­æ˜¯å¦æœ‰åº

å¸ƒå°”è¿”å›å€¼

`std::is_sorted_until`

æ‰¾åˆ°æœªæ’åºçš„ä½ç½®

è¿”å›è¿­ä»£å™¨

`std::reverse`

åè½¬åºåˆ—

éæ’åºï¼Œä½†å¸¸ç»“åˆä½¿ç”¨

* * *

#### 1\. `std::sort` â€“ å¿«é€Ÿæ’åºï¼ˆé»˜è®¤ï¼‰

å°†å®¹å™¨å†…çš„å…ƒç´ **æŒ‰å‡åº**æˆ–è‡ªå®šä¹‰è§„åˆ™**æ’åº**ï¼ŒåŸå‹ï¼š

    template <class RandomIt>
    void sort(RandomIt first, RandomIt last);
    
    template <class RandomIt, class Compare>
    void sort(RandomIt first, RandomIt last, Compare comp);
    

æ³¨æ„ï¼š

*   ä»…é€‚ç”¨äº**éšæœºè®¿é—®è¿­ä»£å™¨**ï¼šå¦‚ `vector`, `array`, `deque`
*   å¹³å‡æ—¶é—´å¤æ‚åº¦ **O(n log n)**ï¼Œæœ€å **O(nÂ²)**ï¼ˆä½†å®ç°åšäº†ä¼˜åŒ–ï¼‰
*   **ä¸ç¨³å®šæ’åº**ï¼ˆç›¸ç­‰å…ƒç´ ç›¸å¯¹ä½ç½®å¯èƒ½å˜åŒ–ï¼‰

ç¤ºä¾‹ï¼š

    std::vector<int> v = {5, 3, 1, 4};
    std::sort(v.begin(), v.end());  // å‡åº
    std::sort(v.begin(), v.end(), std::greater<>());  // é™åº
    

* * *

#### 2\. `std::stable_sort` â€“ ç¨³å®šæ’åº

æ’åºå**ä¿ç•™ç›¸ç­‰å…ƒç´ çš„åŸå§‹é¡ºåº**ï¼ŒåŸå‹

    template <class RandomIt>
    void stable_sort(RandomIt first, RandomIt last);
    
    template <class RandomIt, class Compare>
    void stable_sort(RandomIt first, RandomIt last, Compare comp);
    

ç‰¹ç‚¹ï¼š

*   **å½’å¹¶æ’åº**å®ç°ï¼Œæ—¶é—´å¤æ‚åº¦ **O(n logÂ² n)** æˆ– **O(n log n)**ï¼ˆéƒ¨åˆ†å®ç°ä¼˜åŒ–ï¼‰
*   å¯¹äºæ’åºåä»éœ€ä¾èµ–åŸå§‹é¡ºåºçš„æƒ…å†µéå¸¸æœ‰ç”¨

ç¤ºä¾‹ï¼š

    struct Person { std::string name; int age; };
    
    std::vector<Person> people = {{"Alice", 30}, {"Bob", 25}, {"Amy", 30}};
    std::stable_sort(people.begin(), people.end(), 
        [](const Person& a, const Person& b){ return a.age < b.age; });
    

* * *

#### 3\. `std::partial_sort` â€“ éƒ¨åˆ†æ’åº

åªå¯¹**å‰ k ä¸ªå…ƒç´ æ’åº**

    template <class RandomIt>
    void partial_sort(RandomIt first, RandomIt middle, RandomIt last);
    
    template <class RandomIt, class Compare>
    void partial_sort(RandomIt first, RandomIt middle, RandomIt last, Compare comp);
    

åŸç†ï¼š

*   å¯¹ `first` åˆ° `last` åŒºé—´æ’åº
*   æ’å¥½åºçš„å‰ `middle - first` ä¸ªå…ƒç´ æ”¾åœ¨ `[first, middle)`

ç¤ºä¾‹ï¼šæ‰¾å‰ 3 å°ï¼š

    std::vector<int> v = {9, 2, 7, 4, 1, 5};
    std::partial_sort(v.begin(), v.begin() + 3, v.end());  // v[0..2] æ˜¯æœ€å°çš„ 3 ä¸ªå…ƒç´ 
    

* * *

#### 4\. `std::nth_element` â€“ æ‰¾ç¬¬ n å°çš„å…ƒç´ 

å°†ç¬¬ `n` å°çš„å…ƒç´ æ”¾åˆ°æ­£ç¡®ä½ç½®ï¼Œå·¦è¾¹æ¯”å®ƒå°ï¼Œå³è¾¹æ¯”å®ƒå¤§ï¼Œä½†å·¦å³**ä¸ä¿è¯æ’åº**

    template <class RandomIt>
    void nth_element(RandomIt first, RandomIt nth, RandomIt last);
    
    template <class RandomIt, class Compare>
    void nth_element(RandomIt first, RandomIt nth, RandomIt last, Compare comp);
    

*   å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º **O(n)**ï¼ˆé€‚åˆå¤§æ•°æ®åœºæ™¯ï¼‰

ç¤ºä¾‹ï¼š

    std::vector<int> v = {7, 2, 4, 8, 1, 5};
    std::nth_element(v.begin(), v.begin() + 2, v.end());  // ç¬¬ 3 å°çš„æ•°æ”¾åœ¨ v[2]
    

* * *

#### 5\. `std::is_sorted` / `is_sorted_until`

`std::is_sorted`ï¼š

åˆ¤æ–­åŒºé—´æ˜¯å¦å·²ç»æ’åº

    bool ok = std::is_sorted(v.begin(), v.end());
    

`std::is_sorted_until`ï¼š

è¿”å›ç¬¬ä¸€ä¸ª**ä¸æ»¡è¶³æ’åºè§„åˆ™**çš„è¿­ä»£å™¨

    auto it = std::is_sorted_until(v.begin(), v.end());
    

* * *

#### 6\. `std::reverse` â€“ åè½¬

å°†å®¹å™¨å†…æ•°æ®åè½¬

    std::reverse(v.begin(), v.end());
    

    #include <iostream>
    #include <vector>
    #include <algorithm>
    
    int main() {
        std::vector<int> v = {9, 2, 7, 4, 1, 5};
        std::reverse(v.begin(), v.end());
        for (int v1: v) {
            std::cout << v1 << " ";
        }
        //è¾“å‡º 5 1 4 7 2 9
    }
    

#### åº”ç”¨å®ä¾‹å¯¹æ¯”

âœ” æ‰¾å‡ºå‰ 5 ä¸ªæœ€å¤§å€¼ï¼ˆé™åºï¼‰

    std::partial_sort(v.begin(), v.begin() + 5, v.end(), std::greater<>());
    

âœ” æ’åºè‡ªå®šä¹‰å¯¹è±¡ï¼ˆæŒ‰å¤šä¸ªå­—æ®µï¼‰

    struct Student { std::string name; int score; int age; };
    
    std::sort(v.begin(), v.end(), [](const Student& a, const Student& b){
        return std::tie(a.score, a.age) > std::tie(b.score, b.age);  // scoreä¼˜å…ˆé™åºï¼Œageé™åº
    });
    

* * *

#### é€‰æ‹©å»ºè®®

éœ€æ±‚

æ¨èç®—æ³•

å®Œæ•´æ’åºï¼Œé€Ÿåº¦ä¼˜å…ˆ

`std::sort`

å®Œæ•´æ’åºï¼Œé¡ºåºç¨³å®š

`std::stable_sort`

æ‰¾ç¬¬ n å°ï¼ˆæˆ–å‰ k å°ï¼‰

`std::nth_element`

æ’å‰å‡ é¡¹å³å¯

`std::partial_sort`

åˆ¤æ–­æ˜¯å¦å·²æ’åº

`std::is_sorted`

### 5\. æ¯”è¾ƒç±»

#### `std::equal`

åˆ¤æ–­ä¸¤ä¸ªåºåˆ—çš„æ‰€æœ‰å¯¹åº”å…ƒç´ æ˜¯å¦ç›¸ç­‰ã€‚

    // ç¬¬ä¸€ç§ï¼šä¸¤ä¸ªèŒƒå›´ [first1, last1) å’Œ ä» first2 å¼€å§‹çš„åºåˆ—
    template<class InputIt1, class InputIt2>
    bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2);
    
    // ç¬¬äºŒç§ï¼šè‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°
    template<class InputIt1, class InputIt2, class BinaryPredicate>
    bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p);
    
    

è‡ªå®šä¹‰æ¯”è¾ƒå™¨ï¼š

    #include <string>
    #include <algorithm>
    #include <cctype>
    
    bool char_equal_ignore_case(char a, char b) {
        return std::tolower(a) == std::tolower(b);
    }
    
    int main() {
        std::string s1 = "Hello";
        std::string s2 = "hELLo";
    
        if (std::equal(s1.begin(), s1.end(), s2.begin(), char_equal_ignore_case)) {
            std::cout << "Equal ignoring case\n";
        }
    }
    
    

#### `std::lexicographical_compare`

`std::lexicographical_compare` æ˜¯ä¸€ä¸ª STL ç®—æ³•ï¼Œç”¨äºåˆ¤æ–­ä¸¤ä¸ªåºåˆ—çš„**å­—å…¸åºï¼ˆlexicographical orderï¼‰å¤§å°å…³ç³»**ã€‚

    bool smaller = std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end());
    

* * *

### 6\. æ•°å€¼ç±»ï¼ˆéœ€ `<numeric>`ï¼‰

æ•°å€¼ç±»ç®—æ³•æ˜¯ `<numeric>` å¤´æ–‡ä»¶ä¸­å®šä¹‰çš„ STL ç®—æ³•ï¼Œä¸»è¦ç”¨äº**å¯¹å®¹å™¨ä¸­çš„æ•°å€¼æ•°æ®è¿›è¡Œæ•°å­¦è®¡ç®—**ã€‚è¿™äº›ç®—æ³•æ˜¯å¯¹â€œæ•°å€¼åºåˆ—â€çš„å¸¸è§å¤„ç†æ¨¡å¼çš„æŠ½è±¡ï¼Œä¾‹å¦‚æ±‚å’Œã€æ±‚ç§¯ã€ç”Ÿæˆæ•°åˆ—ç­‰ã€‚

ç®—æ³•

ä½œç”¨

å¸¸è§ç”¨é€”

`std::accumulate`

æ±‚åŒºé—´å…ƒç´ çš„ç´¯åŠ æˆ–å…¶ä»–äºŒå…ƒæ“ä½œçš„ç»“æœ

æ±‚å’Œã€æ‹¼æ¥å­—ç¬¦ä¸²ã€è‡ªå®šä¹‰ç´¯ç§¯

`std::inner_product`

æ±‚ä¸¤ä¸ªåŒºé—´çš„**å†…ç§¯**ï¼ˆç‚¹ç§¯ï¼‰

å‘é‡ç›¸ä¹˜ã€ç›¸ä¼¼åº¦è®¡ç®—ç­‰

`std::iota`

ç”¨é¡ºåºå€¼å¡«å……å®¹å™¨

åˆå§‹åŒ–ã€ç¼–å·ç­‰

* * *

#### `std::accumulate`ï¼šç´¯åŠ  / ç´¯ç§¯å€¼

*   å¯¹åŒºé—´ `[first, last)` ä¸­çš„å…ƒç´ è¿›è¡Œç´¯è®¡å¤„ç†
*   é»˜è®¤æ˜¯æ‰§è¡Œ `init + x1 + x2 + ...`

    template<class InputIt, class T>
    T accumulate(InputIt first, InputIt last, T init);
    
    // å¯è‡ªå®šä¹‰æ“ä½œ
    template<class InputIt, class T, class BinaryOperation>
    T accumulate(InputIt first, InputIt last, T init, BinaryOperation op);
    

ç¤ºä¾‹ï¼š

    std::vector<int> v = {1, 2, 3, 4};
    int sum = std::accumulate(v.begin(), v.end(), 0);  // 10
    
    std::string s = std::accumulate(v.begin(), v.end(), std::string(),
                                    [](std::string acc, int x) {
                                        return acc + std::to_string(x);
                                    });  // s = "1234"
    

* * *

#### `std::inner_product`ï¼šå†…ç§¯ / ç‚¹ç§¯

*   å¯¹ä¸¤ä¸ªåºåˆ—æ‰§è¡Œï¼š`init + a1*b1 + a2*b2 + ...`
*   å¯è‡ªå®šä¹‰åŠ æ³•å’Œä¹˜æ³•æ“ä½œ

    template<class InputIt1, class InputIt2, class T>
    T inner_product(InputIt1 first1, InputIt1 last1, InputIt2 first2, T init);
    
    // è‡ªå®šä¹‰æ“ä½œ
    template<class InputIt1, class InputIt2, class T,
             class BinaryOperation1, class BinaryOperation2>
    T inner_product(InputIt1 first1, InputIt1 last1,
                    InputIt2 first2, T init,
                    BinaryOperation1 add_op,
                    BinaryOperation2 mul_op);
    

ç¤ºä¾‹ï¼š

    std::vector<int> a = {1, 2, 3};
    std::vector<int> b = {4, 5, 6};
    
    int dot = std::inner_product(a.begin(), a.end(), b.begin(), 0);  // 1Ã—4 + 2Ã—5 + 3Ã—6 = 32
    

#### `std::iota`ï¼šå¡«å……é¡ºåºå€¼

*   å°†å®¹å™¨ä¸­çš„å…ƒç´ ä»èµ·å§‹å€¼å¼€å§‹ï¼Œé€ä¸ªé€’å¢å¡«å……ï¼ˆé»˜è®¤+1ï¼‰

    template<class ForwardIt, class T>
    void iota(ForwardIt first, ForwardIt last, T value);
    

ç¤ºä¾‹ï¼š

    std::vector<int> v(5);
    std::iota(v.begin(), v.end(), 100);  // v = {100, 101, 102, 103, 104}
    

### 7\. é›†åˆç±»ï¼ˆå®¹å™¨å¿…é¡»æœ‰åºï¼‰

#### `std::set_union`, `set_intersection`, `set_difference`

é›†åˆç±»ç®—æ³•æ˜¯ STL `<algorithm>` ä¸­ç”¨äº**å¤„ç†ä¸¤ä¸ªæœ‰åºå®¹å™¨ä¹‹é—´é›†åˆå…³ç³»**çš„ä¸€ç»„ç®—æ³•ã€‚å®ƒä»¬æ¨¡æ‹Ÿäº†é›†åˆçš„å¹¶é›†ã€äº¤é›†ã€å·®é›†ç­‰æ“ä½œã€‚

ç®—æ³•å

ä½œç”¨

è¿”å›èŒƒå›´

`std::set_union`

å¹¶é›†ï¼šA âˆª B

æ‰€æœ‰åœ¨ A æˆ– B ä¸­çš„å…ƒç´ 

`std::set_intersection`

äº¤é›†ï¼šA âˆ© B

åªå‡ºç°åœ¨ A å’Œ B ä¸­çš„å…ƒç´ 

`std::set_difference`

å·®é›†ï¼šA - B

åªå‡ºç°åœ¨ A ä¸­ã€ä¸åœ¨ B ä¸­çš„å…ƒç´ 

`std::set_symmetric_difference`

å¯¹ç§°å·®é›†ï¼šA â–³ B

A æˆ– B ä¸­å‡ºç°ä½†ä¸éƒ½å‡ºç°çš„å…ƒç´ 

*   **å®¹å™¨å¿…é¡»æœ‰åº**ï¼ˆå¦‚ `std::set`, `std::vector` æ’å¥½åºï¼‰
*   é€šå¸¸è¾“å‡ºç»“æœæ”¾åˆ°å¦ä¸€ä¸ªå®¹å™¨ï¼Œç”¨ `std::back_inserter`

* * *

#### ç¤ºä¾‹ä»£ç 

1.  å¹¶é›† `std::set_union`

    std::vector<int> a = {1, 2, 4};
    std::vector<int> b = {2, 3, 5};
    std::vector<int> result;
    
    std::set_union(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(result));
    // result = {1, 2, 3, 4, 5}
    

* * *

2.  äº¤é›† `std::set_intersection`

    std::set_intersection(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(result));
    // result = {2}
    

* * *

3.  å·®é›† `std::set_difference`ï¼ˆA - Bï¼‰

    std::set_difference(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(result));
    // result = {1, 4}
    

* * *

4.  å¯¹ç§°å·®é›† `std::set_symmetric_difference`

    std::set_symmetric_difference(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(result));
    // result = {1, 3, 4, 5}
    

### 8\. åˆ†åŒºç±»

#### `std::partition`, `stable_partition`

`std::partition` å’Œ `std::stable_partition` æ˜¯ STL ä¸­çš„**åˆ†åŒºç±»ç®—æ³•**ï¼Œç”¨äºæ ¹æ®æŸä¸ªæ¡ä»¶ï¼ˆè°“è¯ï¼‰å°†ä¸€ä¸ªåºåˆ—**åˆ’åˆ†æˆä¸¤éƒ¨åˆ†**ï¼š

> æŒ‰ç…§æŒ‡å®šæ¡ä»¶ï¼ŒæŠŠå®¹å™¨ä¸­çš„å…ƒç´ **åˆ†æˆä¸¤ç»„**ï¼šä¸€ç»„æ»¡è¶³æ¡ä»¶ï¼Œå¦ä¸€ç»„ä¸æ»¡è¶³ã€‚

*   `std::partition`ï¼š**ä¸ä¿è¯ç›¸å¯¹é¡ºåº**
*   `std::stable_partition`ï¼š**ä¿æŒç›¸å¯¹é¡ºåºç¨³å®š**

    // ä¸ç¨³å®šåˆ†åŒº
    template<class BidirIt, class UnaryPredicate>
    BidirIt partition(BidirIt first, BidirIt last, UnaryPredicate p);
    
    // ç¨³å®šåˆ†åŒº
    template<class BidirIt, class UnaryPredicate>
    BidirIt stable_partition(BidirIt first, BidirIt last, UnaryPredicate p);
    

è¿”å›å€¼éƒ½æ˜¯ **æ–°çš„â€œä¸­é—´â€è¿­ä»£å™¨**ï¼š

*   `[first, new_iter)` æ˜¯æ»¡è¶³æ¡ä»¶çš„éƒ¨åˆ†
*   `[new_iter, last)` æ˜¯ä¸æ»¡è¶³çš„éƒ¨åˆ†

* * *

#### ç¤ºä¾‹ä»£ç ï¼ˆåˆ†åŒºå¥‡å¶ï¼‰

    #include <iostream>
    #include <vector>
    #include <algorithm>
    
    bool is_odd(int x) { return x % 2 != 0; }
    
    int main() {
        std::vector<int> v = {1, 2, 3, 4, 5, 6};
    
        // std::partitionï¼ˆä¸ç¨³å®šï¼‰
        auto it = std::partition(v.begin(), v.end(), is_odd);
    
        std::cout << "Partition result: ";
        for (int n : v) std::cout << n << " ";
        std::cout << "\nFirst even: " << *it << "\n";
    }
    

**å¯èƒ½è¾“å‡ºï¼š**ï¼ˆé¡ºåºä¸ä¿è¯ï¼‰

    Partition result: 5 3 1 4 2 6
    First even: 4
    

* * *

#### ç¨³å®šç‰ˆæœ¬ï¼š`std::stable_partition`

    std::vector<int> v = {1, 2, 3, 4, 5, 6};
    
    auto it = std::stable_partition(v.begin(), v.end(), is_odd);
    
    // è¾“å‡ºï¼š1 3 5 2 4 6
    

ç¨³å®šåˆ†åŒº**ä¿ç•™äº†åŸå§‹é¡ºåº**ï¼Œå³å¥‡æ•°ä»ç„¶æ˜¯åŸæ¥çš„é¡ºåº 1, 3, 5ï¼Œå¶æ•°ä»ç„¶æ˜¯ 2, 4, 6ã€‚

### å››ã€å¸¸è§ç»„åˆç¤ºä¾‹

å–å¥‡æ•° â†’ ä¹˜2 â†’ æ’åº â†’ å–å‰ 3 ä¸ª

    std::vector<int> v = {1,2,3,4,5,6,7,8};
    std::vector<int> filtered, mapped, result;
    
    std::copy_if(v.begin(), v.end(), std::back_inserter(filtered),
                 [](int x){ return x % 2 == 1; });
    std::transform(filtered.begin(), filtered.end(), std::back_inserter(mapped),
                   [](int x){ return x * 2; });
    std::sort(mapped.begin(), mapped.end());
    std::copy_n(mapped.begin(), std::min<size_t>(3, mapped.size()), std::back_inserter(result));
    

æœªç»ä½œè€…åŒæ„è¯·å‹¿è½¬è½½

æœ¬æ–‡æ¥è‡ªåšå®¢å›­ä½œè€…ï¼š[aixueforever](https://www.cnblogs.com/aslanvon/)ï¼ŒåŸæ–‡é“¾æ¥ï¼š[https://www.cnblogs.com/aslanvon/p/18944922](https://www.cnblogs.com/aslanvon/p/18944922)