---
layout: post
title: 'Dart 中并发、异步编程'
date: "2025-11-23T00:48:13Z"
---
Dart 中并发、异步编程
=============

在写这篇文章之前，我一直在犹豫，要不要在这里讲解 Dart 的异步相关话题，因为这部分内容很容易让初学者望而却步。首先关于单线程和异步之间的关系，比较容易让人迷惑，虽然我一定会用自己的方式尽可能让你听懂。其次大量的异步操作方式（Future、await、async 等），目前你看不到具体的应用场景。（比如你学习过前端中的 Promise、await、async 可能会比较简单，但是我会假设你没有这样的基础）。

### 一. Dart 事件循环

#### 1.1 什么是事件循环

事件循环是什么呢？

事件循环本身是单线程内的异步调度机制，得异步编程变的可能。其本质就是将需要处理的一系列事件（包括点击事件、IO 事件、网络事件等）放在一个事件队列（Event Queue）或微任务队列（Microtask Queue 微任务优先级高于事件队列，会先被清空）中。然后不断的从队列中取出事件，并执行其对应的代码块，直到事件队列清空。其事件处理流程遵循：执行同步代码 -> 清空微任务队列 -> 处理一个事件队列任务 -> 重复前两步（行成循环）。

我们来写一个事件循环的伪代码：

    // 这里我使用数组模拟队列, 先进先出的原则
    List eventQueue = []; 
    var event;
    
    // 事件循环从启动的一刻，永远在执行
    while (true) {
      if (eventQueue.length > 0) {
        // 取出一个事件
        event = eventQueue.removeAt(0);
        // 执行该事件
        event();
      }
    }
    

当我们有一些事件时，比如点击事件、IO事件、网络事件时，它们就会被加入到 `eventLoop` 中，当发现事件队列不为空时发现，就会取出事件，并且执行。

如下图齿轮就是我们的事件循环，它会从队列中依次取出事件来执行。

#### 1.2 事件循环代码解析

这里我们来看一段伪代码，理解点击事件和网络请求的事件是如何被执行的：

*   这是一段 Flutter 代码，很多东西大家可能不是特别理解，但是耐心阅读你会读懂我们在做什么。
*   一个按钮 RaisedButton，当发生点击时执行 onPressed 函数。
*   onPressed 函数中，我们发送了一个网络请求，请求成功后会执行 then 中的回调函数。

    RaisedButton(
      child: Text('Click me'),
      onPressed: () {
        final myFuture = http.get('https://example.com');
        myFuture.then((response) {
          if (response.statusCode == 200) {
            print('Success!');
          }
        });
      },
    )
    

这些代码是如何放在事件循环中执行呢？

*   当用户发生点击的时候，onPressed 回调函数被放入事件循环中执行，执行的过程中发送了一个网络请求。
*   网络请求发出去后，该事件循环不会被阻塞，而是发现要执行的onPressed 函数已经结束，会将它丢弃掉。
*   网络请求成功后，会执行 then 中传入的回调函数，这也是一个事件，该事件被放入到事件循环中执行，执行完毕后，事件循环将其丢弃。

尽管 onPressed 和 then 中的回调有一些差异，但是它们对于事件循环来说，都是告诉它：**我有一段代码需要执行，快点帮我完成。**

### 二. Dart 的异步模型

事件循环本身是单线程内的异步调度机制。

#### 1.1. Dart 是单线程的

##### 1.1.1. 程序中的耗时操作

**开发中的耗时操作：**

*   在开发中，我们经常会遇到一些耗时的操作需要完成，比如网络请求、文件读取等等；
*   如果我们的主线程一直在等待这些耗时的操作完成，那么就会进行阻塞，无法响应其它事件，比如用户的点击；
*   显然，我们不能这么干！！

**如何处理耗时的操作呢？**

*   针对如何处理耗时的操作，不同的语言有不同的处理方式。
*   **处理方式一：** 多线程，比如 Java、C++，我们普遍的做法是开启一个新的线程（Thread），在新的线程中完成这些异步的操作，再通过线程间通信的方式，将拿到的数据传递给主线程。
*   **处理方式二：** 单线程+事件循环，比如 JavaScript、Dart 都是基于单线程加事件循环来完成耗时操作的处理。不过单线程如何能进行耗时的操作呢？

##### 1.1.2. 单线程的异步操作

我之前碰到很多开发者都对单线程的异步操作充满了问号？？？

其实它们并不冲突：

*   因为我们的一个应用程序大部分时间都是处于空闲的状态的，并不是无限制的在和用户进行交互。
*   比如等待用户点击、网络请求数据的返回、文件读写的 IO 操作，这些等待的行为并不会阻塞我们的线程；
*   这是因为类似于网络请求、文件读写的 IO，我们都可以基于非阻塞调用；

**阻塞式调用和非阻塞式调用**

如果想搞懂这个点，我们需要知道操作系统中的`阻塞式调用`和`非阻塞式调用`的概念。

*   阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态。**
*   **阻塞式调用：** 调用结果返回之前，当前线程会被挂起，调用线程只有在得到调用结果之后才会继续执行。
*   **非阻塞式调用：** 调用执行之后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。

我们用一个生活中的例子来模拟：

*   你中午饿了，需要点一份外卖，点外卖的动作就是我们的调用，拿到最后点的外卖就是我们要等待的结果。
*   **阻塞式调用：** 点了外卖，不再做任何事情，就是在傻傻的等待，你的线程停止了任何其他的工作。
*   **非阻塞式调用：** 点了外卖，继续做其他事情：继续工作、打把游戏，你的线程没有继续执行其他事情，只需要偶尔去看一下有没有人敲门，外卖有没有送到即可。

而我们开发中的很多耗时操作，都可以基于这样的 `非阻塞式调用`：

*   比如网络请求本身使用了 Socket 通信，而 Socket 本身提供了 select 模型，可以进行`非阻塞方式的工作`；
*   比如文件读写的 IO 操作，我们可以使用操作系统提供的基于事件的回调机制；

这些操作都不会阻塞我们单线程的继续执行，我们的线程在等待的过程中可以继续去做别的事情：喝杯咖啡、打把游戏，等真正有了响应，再去进行对应的处理即可。

这时，我们可能有两个问题：

*   **问题一：** 如果在多核 CPU 中，单线程是不是就没有充分利用 CPU 呢？这个问题，我会放在后面来讲解。
*   **问题二：** 单线程是如何来处理网络通信、IO 操作它们返回的结果呢？答案就是事件循环（Event Loop）。

#### 1.2 Dart 的异步操作

Dart 中的异步操作主要使用 Future 以及 async、await。如果你之前有过前端的ES6、ES7 编程经验，那么完全可以将 Future 理解成 Promise，async、await 和 ES7 中基本一致。但是如果没有前端开发经验，Future 以及 async、await 如何理解呢？

##### 1.2.1 认识 Future

`Future`：表示一个异步操作的最终结果（成功或失败）。其次 Dart 通过 `Future` 将耗时任务包装成非阻塞的异步任务来处理（如网络请求、文件读写），避免阻塞主线程，即对异步的操作进行封装。`Future` 的双重视角：（pending→resolved/rejected）

从结果视角：`Future` 是一个“盒子”，它最终会被填入异步操作的成功值或错误。你可以通过 `then` 和 `catchError` 访问这个结果。

从任务视角：`Future` 是一个“任务调度器”，它允许你将耗时任务包装成非阻塞操作，由 Dart 事件循环自动调度执行，避免阻塞主线程。

###### 1）同步的网络请求

我们先来看一个例子吧：

*   在这个例子中，我使用 getNetworkData 来模拟了一个网络请求；
*   该网络请求需要3秒钟的时间，之后返回数据；

    import "dart:io";
    
    main(List<String> args) {
      print("main function start");
      print(getNetworkData());
      print("main function end");
    }
    
    String getNetworkData() {
      sleep(Duration(seconds: 3));
      return "network data";
    }
    

这段代码会运行怎么的结果呢？

*   getNetworkData 会阻塞 main 函数的执行

    main function start
    // 等待3秒
    network data
    main function end
    

显然，上面的代码不是我们想要的执行效果，因为网络请求阻塞了 main 函数，那么意味着其后所有的代码都无法正常的继续执行。

###### 2） 异步的网络请求

我们来对我们上面的代码进行改进，代码如下：

和刚才的代码唯一的区别在于我使用了 Future 对象来将耗时的操作放在了其中传入的函数中；稍后，我们会讲解它具体的一些 API，我们就暂时知道我创建了一个 Future 实例即可；

    import "dart:io";
    
    main(List<String> args) {
      print("main function start");
      print(getNetworkData());
      print("main function end");
    }
    
    Future<String> getNetworkData() {
      return Future<String>(() {
        sleep(Duration(seconds: 3));
        return "network data";
      });
    }
    

我们来看一下代码的运行结果：

*   这一次的代码顺序执行，没有出现任何的阻塞现象；
*   和之前直接打印结果不同，这次我们打印了一个Future实例；
*   结论：我们将一个耗时的操作隔离了起来，这个操作不会再影响我们的主线程执行了。
*   问题：我们如何去拿到最终的结果呢？

    main function start
    Instance of 'Future<String>'
    main function end
    

有了 Future 之后，如何去获取请求到的结果：通过 .then 的回调：

    main(List<String> args) {
      print("main function start");
      // 使用变量接收getNetworkData返回的future
      var future = getNetworkData();
      // 当future实例有返回结果时，会自动回调then中传入的函数
      // 该函数会被放入到事件循环中，被执行
      future.then((value) {
        print(value);
      });
      print(future);
      print("main function end");
    }
    

上面代码的执行结果：

    main function start
    Instance of 'Future<String>'
    main function end
    // 3s后执行下面的代码
    network data
    

执行中出现异常：如果调用过程中出现了异常，拿不到结果，如何获取到异常的信息呢？

    import "dart:io";
    
    main(List<String> args) {
      print("main function start");
      var future = getNetworkData();
      future.then((value) {
        print(value);
      }).catchError((error) { // 捕获出现异常时的情况
        print(error);
      });
      print(future);
      print("main function end");
    }
    
    Future<String> getNetworkData() {
      return Future<String>(() {
        sleep(Duration(seconds: 3));
        // 不再返回结果，而是出现异常
        // return "network data";
        throw Exception("网络请求出现错误");
      });
    }
    

上面代码的执行结果：

    main function start
    Instance of 'Future<String>'
    main function end
    // 3s后没有拿到结果，但是我们捕获到了异常
    Exception: 网络请求出现错误
    

###### 3）Future 使用补充

**补充一：上面案例的小结**

我们通过一个案例来学习了一些 Future 的使用过程：

*   创建一个 Future（可能是我们创建的，也可能是调用内部 API 或者第三方 API 获取到的一个 Future，总之你需要获取到一个 Future 实例，Future 通常会对一些异步的操作进行封装）；
*   通过 .then（成功回调函数）的方式来监听 Future 内部执行完成时获取到的结果；
*   通过 .catchError（失败或异常回调函数）的方式来监听 Future 内部执行失败或者出现异常时的错误信息；

**补充二：Future 的两种状态**

事实上 Future 在执行的整个过程中，我们通常把它划分成了两种状态：

状态一：`未完成状态（uncompleted）`

*   执行 Future 内部的操作时（在上面的案例中就是具体的网络请求过程，我们使用了延迟来模拟），我们称这个过程为未完成状态。

状态二：**完成状态（completed）**

*   当 Future 内部的操作执行完成，通常会返回一个值，或者抛出一个异常。
*   这两种情况，我们都称 Future 为完成状态。

Dart 官网有对这两种状态解析，之所以贴出来是区别于 Promise 的三种状态

**补充三：Future 的链式调用**

上面代码我们可以进行如下的改进：我们可以在 then 中继续返回值，会在下一个链式的 then 调用回调函数中拿到返回的结果

    import "dart:io";
    
    main(List<String> args) {
      print("main function start");
    
      getNetworkData().then((value1) {
        print(value1);
        return "content data2";
      }).then((value2) {
        print(value2);
        return "message data3";
      }).then((value3) {
        print(value3);
      });
    
      print("main function end");
    }
    
    Future<String> getNetworkData() {
      return Future<String>(() {
        sleep(Duration(seconds: 3));
        // 不再返回结果，而是出现异常
         return "network data1";
      });
    }
    

打印结果如下：

    main function start
    main function end
    // 3s后拿到结果
    network data1
    content data2
    message data3
    

**补充四：Future 其他 API**

    Future.value(value)
    

直接获取一个完成的 Future，该 Future 会直接调用 then 的回调函数

    main(List<String> args) {
      print("main function start");
    
      Future.value("哈哈哈").then((value) {
        print(value);
      });
    
      print("main function end");
    }
    

打印结果如下：

    main function start
    main function end
    哈哈哈
    

疑惑：为什么立即执行，但是`哈哈哈`是在最后打印的呢？

这是因为 Future 中的 then 会作为新的任务会加入到事件队列中（Event Queue），加入之后你肯定需要排队执行了

    Future.error(object)
    

直接获取一个完成的 Future，但是是一个发生异常的 Future，该 Future 会直接调用 catchError 的回调函数

    main(List<String> args) {
      print("main function start");
    
      Future.error(Exception("错误信息")).catchError((error) {
        print(error);
      });
    
      print("main function end");
    }
    

打印结果如下：

    main function start
    main function end
    Exception: 错误信息
    

    Future.delayed(时间, 回调函数)
    

在延迟一定时间时执行回调函数，执行完回调函数后会执行 then 的回调；

之前的案例，我们也可以使用它来模拟，但是直接学习这个 API 会让大家更加疑惑；

    main(List<String> args) {
      print("main function start");
    
      Future.delayed(Duration(seconds: 3), () {
        return "3秒后的信息";
      }).then((value) {
        print(value);
      });
    
      print("main function end");
    }
    

##### 1.2.2 await、async

###### 1）理论概念理解

如果你已经完全搞懂了 Future，那么学习 await、async 应该没有什么难度。

await、async 是什么呢？

*   它们是 Dart 中的关键字（你这不是废话吗？废话也还是要强调的，万一你用它做变量名呢。）
*   await：修饰函数，表示该函数包含异步操作，执行时会立即返回一个`Future` 对象。它们可以让我们用同步的代码格式，去实现异步的调用过程。
*   `await`：暂停异步函数的执行，直到 `Future` 完成（成功或抛出异常），然后继续执行后续代码。

我们已经知道，Future 可以做到不阻塞我们的线程，让线程继续执行，并且在完成某个操作时改变自己的状态，并且回调 then 或者 errorCatch 回调。

如何生成一个 Future 呢？

*   通过我们前面学习的 Future 构造函数，或者后面学习的 Future 其他 API 都可以。
*   还有一种就是通过 async 的函数。

###### 2）案例代码演练

我们来对之前的 Future 异步处理代码进行改造，改成 await、async 的形式。我们知道，如果直接这样写代码，代码是不能正常执行的：

*   因为 Future.delayed 返回的是一个 Future 对象，我们不能把它看成同步的返回数据：`"network data"` 去使用
*   也就是我们不能把这个异步的代码当做同步一样去使用！

    import "dart:io";
    
    main(List<String> args) {
      print("main function start");
      print(getNetworkData());
      print("main function end");
    }
    
    String getNetworkData() {
      var result = Future.delayed(Duration(seconds: 3), () {
        return "network data";
      });
      return  "请求到的数据：" + result;
    }
    

现在我使用 await 修改下面这句代码：

*   你会发现，我在 `Future.delayed` 函数前加了一个 await。
*   一旦有了这个关键字，那么这个操作就会等待 `Future.delayed` 的执行完毕，并且等待它的结果。

    String getNetworkData() {
      var result = await Future.delayed(Duration(seconds: 3), () {
        return "network data";
      });
      return  "请求到的数据：" + result;
    }
    

修改后执行代码，会看到如下的错误：

*   错误非常明显：await 关键字必须存在于 async 函数中。
*   所以我们需要将 `getNetworkData` 函数定义成 async 函数。

继续修改代码如下：

*   也非常简单，只需要在函数的()后面加上一个async关键字就可以了

    String getNetworkData() async {
      var result = await Future.delayed(Duration(seconds: 3), () {
        return "network data";
      });
    
      return  "请求到的数据：" + result;
    }
    

运行代码，依然报错（心想：你妹啊）：

*   错误非常明显：使用 async 标记的函数，必须返回一个 Future 对象。
*   所以我们需要继续修改代码，将返回值写成一个 Future。

继续修改代码如下：

    Future<String> getNetworkData() async {
      var result = await Future.delayed(Duration(seconds: 3), () {
        return "network data";
      });
    
      return "请求到的数据：" + result;
    }
    

这段代码应该是我们理想当中执行的代码了

*   我们现在可以像同步代码一样去使用 Future 异步返回的结果；
*   等待拿到结果之后和其他数据进行拼接，然后一起返回；
*   返回的时候并不需要包装一个 Future，直接返回即可，但是返回值会默认被包装在一个 Future 中；

###### 3）读取 json 案例

我这里给出了一个在 Flutter 项目中，读取一个本地的 json 文件，并且转换成模型对象，返回出去的案例；

这个案例作为大家学习前面 Future 和 await、async 的一个参考，我并不打算展开来讲，因为需要用到 Flutter 的相关知识；

后面我会在后面的案例中再次讲解它在 Flutter 中我使用的过程中；

读取 json 案例代码（了解一下即可）

    import 'package:flutter/services.dart' show rootBundle;
    import 'dart:convert';
    import 'dart:async';
    
    main(List<String> args) {
      getAnchors().then((anchors) {
        print(anchors);
      });
    }
    
    class Anchor {
      String nickname;
      String roomName;
      String imageUrl;
    
      Anchor({
        this.nickname,
        this.roomName,
        this.imageUrl
      });
    
      Anchor.withMap(Map<String, dynamic> parsedMap) {
        this.nickname = parsedMap["nickname"];
        this.roomName = parsedMap["roomName"];
        this.imageUrl = parsedMap["roomSrc"];
      }
    }
    
    Future<List<Anchor>> getAnchors() async {
      // 1.读取json文件
      String jsonString = await rootBundle.loadString("assets/yz.json");
    
      // 2.转成List或Map类型
      final jsonResult = json.decode(jsonString);
    
      // 3.遍历List，并且转成Anchor对象放到另一个List中
      List<Anchor> anchors = new List();
      for (Map<String, dynamic> map in jsonResult) {
        anchors.add(Anchor.withMap(map));
      }
      return anchors;
    }
    

##### 1.2.3 Stream

在 Flutter 中，异步编程是非常重要的一部分，特别是在处理用户输入、网络请求或其他涉及时间的操作时。Flutter 提供了一种强大的工具，称为 Stream，用于简化异步编程的过程。

###### 1）什么是 Stream？

Stream 是一种用于处理异步数据的流式 API。它可以用于处理一系列事件，例如用户输入、网络请求的响应、定时器触发等。通过使用 Stream，我们能够更加轻松地管理和响应这些异步事件。

在 Flutter 中，Stream 由两个主要部分组成：流本身和监听器。流是事件序列的源头，而监听器则监听并在新事件到达时做出响应。

创建 Stream：可以使用 StreamController 类。以下是一个简单的例子：

    import 'dart:async';
    
    void main() {
      var controller = StreamController<String>();
      var stream = controller.stream;
    
      stream.listen((data) {
        print('Received data: $data');
      });
    
      controller.add('Hello');
      controller.add('World');
      controller.close();
    }
    

在上面的例子中，我们创建了一个 StreamController 并通过其 stream 属性获得了一个 Stream。然后，我们通过调用 `listen` 方法来监听 Stream 上的事件。最后，我们使用 `add` 方法向 Stream 中添加了两个事件，并通过 `close` 方法关闭了 Stream。

###### 2）用户输入示例：实时搜索框

**场景说明**：

*   用户输入时触发 `TextField` 的 `onChanged` 回调；
*   通过 `_controller.add()` 将输入值注入 Stream；
*   `StreamBuilder` 监听 Stream 并实时更新 UI，实现无延迟的实时搜索效果；

    import 'dart:async';
    import 'package:flutter/material.dart';
    
    class SearchPage extends StatefulWidget {
      @override
      _SearchPageState createState() => _SearchPageState();
    }
    
    class _SearchPageState extends State<SearchPage> {
      final _controller = StreamController<String>();
      String _searchResult = '';
    
      @override
      void dispose() {
        _controller.close(); // 必须关闭Stream避免内存泄漏
        super.dispose();
      }
    
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          body: Center(
            child: Column(
              children: [
                TextField(
                  onChanged: (value) {
                    //用户输入时通过 StreamController添加事件
                    _controller.add(value);
                  },
                  decoration: InputDecoration(labelText: '输入关键词'),
                ),
                StreamBuilder<String>(
                  stream: _controller.stream,
                  builder: (context, snapshot) {
                    // 根据 Stream 数据更新 UI
                    if (snapshot.hasData) {
                      _searchResult = snapshot.data!;
                      return Text('搜索结果: $_searchResult');
                    }
                    return Text('等待输入...');
                  },
                ),
              ],
            ),
          ),
        );
      }
    }
    

###### 3）网络请求示例：分页加载数据

**场景说明**：

*   使用 `async*` 生成器创建异步 Stream，模拟分页 API 请求；
*   每次 `yield` 返回一页数据，实现流式数据加载；
*   结合 `StreamBuilder` 自动处理加载状态、错误处理和数据渲染；

    import 'dart:async';
    import 'package:http/http.dart' as http;
    
    // 模拟网络请求的分页数据获取
    Stream<List<String>> fetchPaginatedData(int pageSize) async* {
      int page = 0;
      while (true) {
        final response = await http.get(
          Uri.parse('https://api.example.com/data?page=$page&size=$pageSize')
        );
        
        if (response.statusCode == 200) {
          final List<String> data = parseResponse(response.body);
          if (data.isEmpty) break; // 无更多数据时终止Stream
          yield data; // 每次yield生成一个数据块
          page++;
        } else {
          throw Exception('请求失败');
        }
      }
    }
    
    // 使用StreamBuilder实现分页加载
    StreamBuilder<List<String>>(
      stream: fetchPaginatedData(20),
      builder: (context, snapshot) {
        if (snapshot.hasData) {
          return ListView.builder(
            itemCount: snapshot.data!.length,
            itemBuilder: (context, index) => ListTile(title: Text(snapshot.data![index])),
          );
        } else if (snapshot.hasError) {
          return Text('加载失败');
        }
        return CircularProgressIndicator();
      },
    )
    

##### 1.2.4 StreamBuilder

Flutter 中的 `StreamBuilder` 是一个非常方便的小部件，它可以根据 Stream 的事件动态重构界面。以下是一个简单的例子：

    import 'dart:async';
    import 'package:flutter/material.dart';
    
    void main() {
      runApp(MyApp());
    }
    
    class MyApp extends StatelessWidget {
      final StreamController<String> _controller = StreamController<String>();
    
      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          home: Scaffold(
            appBar: AppBar(
              title: Text('StreamBuilder Example'),
            ),
            body: StreamBuilder<String>(
              stream: _controller.stream,
              builder: (context, snapshot) {
                return Center(
                  child: Text(snapshot.data ?? 'No data'),
                );
              },
            ),
            floatingActionButton: FloatingActionButton(
              onPressed: () {
                _controller.add('New data');
              },
              child: Icon(Icons.add),
            ),
          ),
        );
      }
    }
    

在上面的例子中，StreamBuilder 根据 Stream 中的数据动态更新了界面上的文本。当点击 FloatingActionButton 时，会向 Stream 中添加新的数据，StreamBuilder 会立即更新 UI。

除了上述基本用法外，Stream 还有许多其他强大的功能和用途，例如错误处理、广播事件等。通过深入学习 Stream 的高级特性，您可以更好地利用 Flutter 中的异步编程。

总的来说，Flutter 中的 Stream 是一个强大而灵活的工具，它使得异步编程变得更加容易和直观。通过合理使用 Stream，您可以更好地处理应用中的异步操作，提高用户体验。

### 三. 任务执行顺序

#### 3.1 认识微任务队列

在前面学习学习中，我们知道 Dart 中有一个事件循环（Event Loop）来执行我们的代码，里面存在一个事件队列（Event Queue），事件循环不断从事件队列中取出事件执行。

但是如果我们严格来划分的话，在 Dart 中还存在另一个队列：微任务队列（Microtask Queue）。

*   微任务队列的优先级要高于事件队列；
*   也就是说事件循环都是优先执行微任务队列中的任务，再执行事件队列中的任务；

那么在 Flutter 开发中，哪些是放在事件队列，哪些是放在微任务队列呢？

*   所有的外部事件任务都在事件队列中，如 IO、计时器、点击、以及绘制事件等；
*   而微任务通常来源于 Dart 内部，并且微任务非常少。这是因为如果微任务非常多，就会造成事件队列排不上队，会阻塞任务队列的执行（比如用户点击没有反应的情况）；

说道这里，你可能已经有点凌乱了，在 Dart 的单线程中，代码到底是怎样执行的呢？

*   Dart 的入口是 main 函数，所以 main 函数中的代码会优先执行；
*   main 函数执行完后，会启动一个事件循环（Event Loop），启动后开始执行队列中的任务；
*   首先，会按照先进先出的顺序，执行微任务队列（Microtask Queue）中的所有任务；
*   其次，会按照先进先出的顺序，执行事件队列（Event Queue）中的所有任务；

#### 3.2 如何创建微任务

在开发中，我们可以通过 Dart 中 async 下的 scheduleMicrotask 来创建一个微任务：

    import "dart:async";
    
    main(List<String> args) {
      scheduleMicrotask(() {
        print("Hello Microtask");
      });
    }
    

在开发中，如果我们有一个任务不希望它放在 Event Queue 中依次排队，那么就可以创建一个微任务了。

**Future 的代码是加入到事件队列还是微任务队列呢？**

Future 中通常有两个函数执行体：

*   Future 构造函数传入的函数体；
*   then 的函数体（catchError 等同看待）；

那么它们是加入到什么队列中的呢？

*   Future 构造函数中的函数体加入事件队列中，按声明顺序执行；
    
*   then 的函数体要分成三种情况：
    
*   情况一：Future 没有执行完成（如耗时操作未结束），那么 then 回调会被加入事件队列，与 Future 的执行体按顺序执行；
    
        Future(() => print('f1')).then(() => print('then1'));
        // 执行顺序：f1 → then1（均在事件队列）
        
    
*   情况二：如果 Future 执行完后调用 then，如已返回结果或抛出错误后调用 then，then 回调会被加入微任务队列，优先于事件队列执行；
    
        Future f = Future.value('done');
        f.then((v) => print('then2')); // 微任务队列
        print('main end');
        // 输出：main end → then2（微任务优先）
        
    
*   情况三：链式 then 回调按顺序执行，实际是在事件循环中依次处理。每个 then 回调必须等待前一个完成（包括其内部异步操作）；
    
        Future.value(1)
          .then((v) => v + 2)       // 同步操作
          .then((v) => Future.value(v + 3)) // 异步操作，加入事件队列
          .then((v) => print(v));   // 等待前一个Future完成
        // 执行顺序：1 → 3 → 6
        
    

#### 3.3 代码执行顺序

我们根据前面的规则来看下面代码执行顺序案例：

    import "dart:async";
    
    main(List<String> args) {
      print("main start");
      
      Future(() => print("task1"));
        
      final future = Future(() => null);
    
      Future(() => print("task2")).then((_) {
        print("task3");
        scheduleMicrotask(() => print('task4'));
      }).then((_) => print("task5"));
    
      future.then((_) => print("task6"));
      scheduleMicrotask(() => print('task7'));
    
      Future(() => print('task8'))
        .then((_) => Future(() => print('task9')))
        .then((_) => print('task10'));
    
      print("main end");
    }
    

代码执行的结果是：

    main start
    main end
    task7
    task1
    task6
    task2
    task3
    task5
    task4
    task8
    task9
    task10
    

代码分析：

*   1、main 函数先执行，所以 `main start` 和 `main end` 先执行，没有任何问题；
*   2、main 函数执行过程中，会将一些任务分别加入到 `EventQueue` 和 `MicrotaskQueue` 中；
*   3、task7 通过 `scheduleMicrotask` 函数调用，所以它被最早加入到`MicrotaskQueue`，会被先执行；
*   4、然后开始执行 `EventQueue`，task1 被添加到 `EventQueue` 中被执行；
*   5、通过 `final future = Future(() => null);` 创建的 future 的 then 被添加到微任务中，微任务直接被优先执行，所以会执行 task6；
*   6、依次在 `EventQueue` 中添加 task2、task3、task5 被执行；
*   7、task3 的打印执行完后，调用 `scheduleMicrotask`，那么在执行完这次的 `EventQueue` 后会执行，所以在 task5 后执行 task4（注意：`scheduleMicrotask` 的调用是作为 task3 的一部分代码，所以 task4 是要在 task5 之后执行的）
*   8、task8、task9、task10 依次添加到`EventQueue`被执行；

事实上，上面的代码执行顺序有可能出现在面试中，我们开发中通常不会出现这种复杂的嵌套，并且需要完全搞清楚它的执行顺序；

但是，了解上面的代码执行顺序，会让你对 EventQueue 和 microtaskQueue 有更加深刻的理解。

### 四. 多核 CPU 的利用

#### 4.1 隔离 Isolate 机制的理解

在 Dart 中，有一个隔离 Isolate 机制，它是什么呢？

Isolate 是一种轻量级的并发执行单元，可以在不同的线程中运行代码。每个 Isolate 都有自己的内存空间、Event Loop 与 Queue。Isolate 之间不共享任何资源，只能依靠消息机制通信，因此也就没有资源抢占问题。在 Dart 中本身是没有多进程概念的，但可以使用 Isolate 隔离机制来实现多进程效果。

比如 Flutter 中就有一个 Root Isolate，负责运行 Flutter 的代码，比如 UI 渲染、用户交互等等；但是，如果只有一个 Isolate，那么意味着我们只能永远利用一个线程，这对于多核 CPU 来说，是一种资源的浪费。如果在开发中，我们有非常多耗时的计算，完全可以自己创建 Isolate，在独立的Isolate 中完成想要的计算操作。

**如何创建 Isolate 呢？**

创建 Isolate 是比较简单的，我们通过 `Isolate.spawn` 就可以创建了：

    import "dart:isolate";
    
    main(List<String> args) {
      Isolate.spawn(foo, "Hello Isolate");
    }
    
    void foo(info) {
      print("新的isolate：$info");
    }
    

#### 4.2 Isolate 通信机制

但是在真实开发中，我们不会只是简单的开启一个新的 Isolate，而不关心它的运行结果：

*   我们需要新的 Isolate 进行计算，并且将计算结果告知 Main Isolate（也就是默认开启的 Isolate）；
*   Isolate 通过发送管道（SendPort/ReceivePort）实现消息通信机制；
*   我们可以在启动并发 Isolate 时将 Main Isolate 的发送管道作为参数传递给它；
*   并发在执行完毕时，可以利用这个管道给 Main Isolate 发送消息；

    import "dart:isolate";
    
    main(List<String> args) async {
      // 1.创建管道
      ReceivePort receivePort= ReceivePort();
    
      // 2.创建新的Isolate
      Isolate isolate = await Isolate.spawn<SendPort>(foo, receivePort.sendPort);
    
      // 3.监听管道消息
      receivePort.listen((data) {
        print('Data：$data');
        // 不再使用时，我们会关闭管道
        receivePort.close();
        // 需要将isolate杀死
        isolate?.kill(priority: Isolate.immediate);
      });
    }
    
    void foo(SendPort sendPort) {
      sendPort.send("Hello World");
    }
    

但是我们上面的通信变成了单向通信，如果需要双向通信呢？Isolate 隔离-双向通讯：这里主要通过 Isolate 机制构建了一个主线程和一个子线程并进行双向通信，主要使用 SendPort 和 ReceivePort。代码实现如下：

    import 'dart:isolate';
     
    var anotherIsolate;
     
    void startMainIsolate() async {
      var receivePort = ReceivePort();
      var sendPort;
     
      anotherIsolate = await Isolate.spawn(threadIsolateInit, receivePort.sendPort);
     
      receivePort.listen((date) {
        if (date is SendPort) {
          sendPort = date;
          print("双向通讯建立成功");
          return;
        }
        print("主线程 接收消息：data = $date");
        sendPort.send("XXXXX");
      });
    }
     
    void threadIsolateInit(SendPort sendPort) async {
     
      var receivePort = ReceivePort();
      print("子线程 接受到来自 主线程的port,尝试建立同主线程的双向通讯");
     
      receivePort.listen((date) {
        print("子线程接收消息:data = $date");
      });
     
      sendPort.send(receivePort.sendPort);
     
      for (var index = 0; index < 10; index++) {
        sendPort.send("子线程 发送消息：$index");
      }
    }
     
    void main() {
      startMainIsolate();
    }
    

#### 4.3 compute 封装

Flutter 提供了支持并发计算的 `compute` 函数，它内部封装了 Isolate 的创建和双向通信；利用它我们可以充分利用多核心 CPU，并且使用起来也非常简单；

注意：下面的代码不是 Dart 的 API，而是 Flutter 的 API，所以只有在 Flutter 项目中才能运行。

    main(List<String> args) async {
      int result = await compute(powerNum, 5);
      print(result);
    }
    
    int powerNum(int num) {
      return num * num;
    }