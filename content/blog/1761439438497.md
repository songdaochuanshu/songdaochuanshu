---
layout: post
title: '奶奶都能看懂的 C++ —— vector 与迭代器'
date: "2025-10-26T00:43:58Z"
---
奶奶都能看懂的 C++ —— vector 与迭代器
==========================

本文用通俗易懂的方式讲解C++中vector容器和迭代器的使用方法，包括vector的初始化、元素操作，以及如何用迭代器遍历序列。

迭代器 (iterator)，顾名思义就是能够遍历一组对象的东西。

但是在讲解它之前，我们需要先了解迭代的对象是什么。常见的一种，叫做 `vector`。

vector 类型
---------

### 使用可变有序序列

我们知道，数学里，`vector` 是向量的意思。但 C++ 里的向量和它不太一样。它的含义是，**具有可变元素个数的有序对象序列**。

之所以这里说的是**对象**序列，是因为 vector 可以存储**任意类型**的对象（我们通常称之为，**泛型**，即广泛的类型）。

    #include <vector> //先引入一下
    vector<int> v;
    vector<string> v2;
    vector<double> v3;
    

看看上面的代码，这下看懂了。先声明 `vector`，再用尖括号包裹 vector 存储的数据类型。

OK 现在我们有了空的对象序列。是时候向其中存入元素了。

    int i = 10;
    v.push_back(i);
    

使用 `.push_back()`，允许我们向对象序列的**末尾**加入元素。由于它是可变长度的，所以可以随意加入对象。

有一点需要注意，vector 永远不会存储引用。也就是说，它会**创建圆括号中的对象的拷贝**（或者移动该对象）。

你应该已经了解过 `string` 或者 `数组` 了。与它们类似，我们也可以用下标运算符，来获取其中**某个元素的[引用](https://blog.samhou.top/cpp-pointer-guide/)**（注意下标从 0 开始，且你不能超过已有元素的范围）。比如：

    v.push_back(i);
    ...
    v[5] = 10; // 修改第 6 个元素
    

要想知道一共有多少元素，避免超出，可以用 `size()`。不过它返回的是 `size_type`，你可以用 `auto` 自动判断类型。

    auto vsize = v.size(); // 自动判断返回值类型
    

### 初始化问题

我们之前都是先创建空的 `vector`，然后再装入对象。实际上，我们也可以直接初始化 `vector`。

    vector<int> v1{1, 2}; // 1,2
    vector<int> v2(2); // 0,0
    vector<int> v3(2,3); // 3,3
    

如上，初始化有花括号（列表初始化）和圆括号（值初始化）两种方式。如果是花括号，那么其中的对象列表就会被加入到 vector 中。比如第一行就初始化了一个包含 2 个数字的 vector。

而如果是圆括号，那么分两种情况：

*   如果只输入一个值，那么它会创建相应大小 vector，然后初始化所有值为对应对象的默认值（对于 int，这是 0）
*   如果输入两个值，那么会把**第二个值**_复制_，并根据**第一个值**确定元素个数，填充入 vector。比如第三行，**2 个 3**。

注意，初始化只是创建空白 `vector` 然后**存入**，**并非固定了大小**。也就是说，你还可以继续使用 `push_back()` 加入元素，来扩展其大小。

其实还有个特殊情况。如果花括号内的数据，无法用于初始化一个 vector，那么它会**自动作为圆括号处理**：

    vector<string> v{2}; // "",""
    vector<string> v1{2,"HELLO"}; // "HELLO","HELLO"
    

第一行创建了含有 2 个初始值的 string 对象的 vector，第二行则创建了含有 2 个 "HELLO" 的 string 对象的 vector。

实际上，如果你不需要快速创建多个相同的元素，你没有任何理由去用初始化。你可以创建空的 vector，然后随意动态添加元素。

还有一点需要注意。可以直接把一个 vector 复制到另一个：

    vector<int> v2;
    v2 = v1; //OK
    

迭代器
---

好了，既然我们已经有了一个对象的集合，让我们进入正题吧。

    vector<int> v1 = {1,2,3,4,5};
    for(auto it = v1.begin();it!=v1.end();it++){
        cout<<*it<<endl;
    }
    // 输出一行一个 v1 中的元素
    

等等等，上面的代码有些复杂，我们一点点解释，顺便说明什么是迭代器。

第一行，创建了一个含有 5 个元素的 `vector`。

然后用了一个 `for` 语句——

### 什么是迭代器？

首先是初始化：

    auto it = v1.begin();
    

这就是我们的主角，迭代器。我们用了自动类型判断，实际上 `it` 的类型是：`vector<int>::iterator`，也就是说，vector 有一个迭代器，而 vector 其中存储的对象是 int 类型的。

嗯，你应该能推测出来，`v1.begin()` 返回的是一个迭代器类型。顾名思义，它返回的是**指向第一个对象的迭代器**。

你或许注意到了**指向**这个词，我们在[指针](https://blog.samhou.top/cpp-pointer-guide/#%E6%8C%87%E9%92%88)那里曾经提到过。比较相似，迭代器也是“**一次指向一个对象**”，只不过该对象**必须存在于一个 vector 中**。

什么意思呢？你可以理解为，迭代器是和一组对象结合使用的“指针”，在一个时刻，指向其中的一个对象。比如上面那行，就创建了指向第一个对象 `1` 的迭代器。

那么这样有什么好处呢？我们先来看 for 的第三部分。

    it++;
    

居然对一个迭代器用了自增运算符！这就是迭代器和指针的区别了——由于它指向一组对象，所以可以随意调整，让它指向其它对象，只要目标对象存在于组内。

我们之前提到，vector 是有序的，所以才能使用下标运算符。而正是这种有序性，使自增自减成为可能。

**如果增加迭代器，就是让它指向当前对象之后的元素；如果减少迭代器，就是让它指向当前对象之前的元素。**

看看下面的例子：

    vector<int> v = {233,234,114,432,534};
    auto it = v.begin(); // index = 0,*it = 233
    it++; // index = 1,*it = 234
    it += 2; //index = 3,*it = 432
    it -= 3; //index = 0,*it = 233
    

`index` 表示当前指向对象的下标。`*it` 表示指向对象的值。

_先不用管那个星号，我们下面会涉及。_

好的，第二部分：

    it != v1.end();
    

条件判断，用的是不等号。`v1.end()` 返回的是指向 `vector` 列表**最后一个元素**的**下一地址**的迭代器。（之所以不使用比较符号，是因为并不是所有迭代器都可以比较，但是它们都支持不等号/等号，使用不等号更加通用。）

也就是说，它并不指向任何元素，但是如果你有一个指向最后一个元素的迭代器，那么再加一，就指向该位置。

回忆一下 `for` 的使用方法。当这个不等号条件**不满足**时，大括号内的语句**不会**被执行。即，当完成最后一个元素的处理后（在这个例子里，输出了 `5` 这个数），条件判断为假，循环结束。

综上，上面代码的输出是：

    1
    2
    3
    4
    5
    

也就是说，这样编写代码，允许我们遍历序列中的所有元素，而不会漏掉最后一个。

**注意，任何使用迭代器的场景，都不能涉及更改序列大小，否则迭代器会失效。**（这是因为，vector 大小是动态扩展的，更改大小可能会自动移动位置来保证充足内存空间，导致迭代器指向的序列失效）

### 算术运算

实际上，我们可以计算_指向同一序列_的两个迭代器的**差值**：

    vector<int> v(10);
    auto it = v.begin();
    auto it2 = v.end();
    cout<<it2-it<<endl; // output: 10
    

输出结果是 10。可视化一下，实际上是这样的（数字表示下标）：

### 解引用

你或许注意到了，我们在上面的代码和注释里里用了同样在指针那一节介绍的 `*` 解引用符。

这是因为，迭代器也和指针一样，指向一个_位置_，用解引用符可以获取**位置对应的对象**。

但是等等。如果你好奇心比较旺盛，可能会尝试这个：

    cout<<it<<endl; // Error
    cout<<*it<<endl;
    

> 你看，我不解引用，不就能看看迭代器指向对象的地址了吗？

然而现实是，这个第一行无法通过编译。

为什么？因为迭代器不是指针，而是一个其它的类型。它只是和指针很像罢了。你可以认为它指向一个地址，从而可以使用解引用运算符，但是你不能把它直接当作指针来用。

当然，既然解引用得到的是一个对象，那么当然可以做许多事情：比如调用函数。

但是要小心，注意优先级，你应该先解引用，再调用函数：

    vector<string> v{"Hello","World"};
    auto it = v.begin();
    cout << (*it).substr(2) << endl; // output: llo
    cout << *it.substr(2) << endl; // Error
    

范围 for 语句
---------

上面我们用三个元素的 for 语句，进行了遍历的操作，其实我们可以简化。

    vector<int> v{1,2,3,4};
    for(auto i:v){
        cout<<i<<endl;
    }
    

这个语句叫做，`范围 for` 语句。它会一个一个取出序列中的元素。

和迭代器不同，它返回对象并**拷贝赋值**给冒号前的变量（这里是 `i`），而非其本身。即，修改 `i` 时，不会修改 `v` 序列中的任何内容。

如果你想修改，可以把变量创建为引用：

    vector<int> v{1,2,3,4};
    for(auto &i:v){
        i = 3;
    }
    for(auto i:v){
        cout<<i<<endl;
    }
    // 3 3 3 3
    

如果你不想改，但不想拷贝防止性能损耗，可以创建[常量引用](https://blog.samhou.top/cpp-pointer-const-guide/#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8)。

    for(const auto &i:v){
        cout<<i<<endl;
        // 禁止修改。
    }
    

不止 vector
---------

我们一直在探讨 `vector`，但实际上，迭代器对于其它的序列也能使用，比如 `string`。你可以在使用的时候，去查一下是否实现了迭代器。写法都一样，这里省略。

那么范围 for 呢？实际上，实现了 `begin` 和 `end` 的类型，都是可以使用的，满足以下条件即可：

*   begin,end 返回的是一个迭代器
*   迭代器可以自增

也就是说，范围 for 只是一种缩写，只要能用迭代器，就能用。在遍历时推荐使用，可以使代码更易读。

好了，这就是 vector 和迭代器的全部内容，我们下次再继续拆解 C++，奶奶级。

本文作者：[SamHou0](https://www.cnblogs.com/samhou/)。原文链接：[https://www.cnblogs.com/samhou/p/19165012/cpp-vector-iterator-guide](https://www.cnblogs.com/samhou/p/19165012/cpp-vector-iterator-guide)

本文的所有发布平台：[About](https://blog.samhou.top/about)

本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明来源 SamHou's blog！