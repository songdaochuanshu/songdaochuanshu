---
layout: post
title: 'NetCore+Webå®¢æˆ·ç«¯å®ç°gRPCå®æ—¶æ¨é€'
date: "2025-09-24T00:39:42Z"
---
NetCore+Webå®¢æˆ·ç«¯å®ç°gRPCå®æ—¶æ¨é€
========================

ä¹‹å‰å‡ºè¿‡websocketæ¨é€ï¼Œsseæ¨é€ï¼Œgrpcçš„æ¨é€åº”è¯¥æ›´å…·æ€§ä»·æ¯”ï¼Œè™½ç„¶å‰ç«¯è¦æ±‚å¤æ‚äº†ä¸€ç‚¹ç‚¹ã€‚ä¸‹é¢å¿«é€Ÿçš„ä¸€æ­¥ä¸€æ­¥å®Œæˆä¸€ä¸ªnetcoreæœåŠ¡ç«¯+webå®¢æˆ·ç«¯çš„æ¨é€ã€‚

åç«¯é¡¹ç›®ç»“æ„

GrpcRealtimePush/  
â”œâ”€â”€ Services/  
â”‚ â””â”€â”€ ChatService.cs # gRPCæœåŠ¡å®ç°  
â”œâ”€â”€ Protos/  
â”‚ â””â”€â”€ chat.proto # Protocol Bufferså®šä¹‰  
â”œâ”€â”€ Program.cs # æœåŠ¡å¯åŠ¨é…ç½®  
â”œâ”€â”€ GrpcRealtimePush.csproj # é¡¹ç›®æ–‡ä»¶  
â””â”€â”€ appsettings.json # é…ç½®æ–‡ä»¶

1.å®‰è£…å¿…è¦çš„grpcåŒ…

<Project Sdk="Microsoft.NET.Sdk.Web"\>
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <Protobuf Include="Protos\\chat.proto" GrpcServices="Server" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Grpc.AspNetCore" Version="2.64.0" />
    <PackageReference Include="Grpc.AspNetCore.Web" Version="2.64.0" />
  </ItemGroup>
</Project>

2.åˆ›å»ºå¥½protoæ–‡ä»¶

syntax = "proto3";

package chat;

option csharp\_namespace \= "GrpcRealtimePush";

// æœåŠ¡å®šä¹‰
service ChatService {
  // æœåŠ¡ç«¯æµå¼æ¨é€æ–¹æ³•
  rpc StartRealtimePush(RealtimePushRequest) returns (stream RealtimePushResponse);
}

// è¯·æ±‚æ¶ˆæ¯
message RealtimePushRequest {
  string client\_id = 1;    // å®¢æˆ·ç«¯ID
  int64 timestamp = 2;      // æ—¶é—´æˆ³
}

// å“åº”æ¶ˆæ¯
message RealtimePushResponse {
  string data = 1;          // æ¨é€æ•°æ®
  int64 timestamp = 2;      // æ—¶é—´æˆ³
  string data\_type = 3;     // æ•°æ®ç±»å‹
}

protoæ–‡ä»¶å®šä¹‰å°±è¿™æ ·ï¼š

\- \*\*\`service ChatService\`\*\*: å®šä¹‰gRPCæœåŠ¡  
\- \*\*\`rpc StartRealtimePush\`\*\*: æœåŠ¡ç«¯æµå¼æ–¹æ³•ï¼Œè¿”å› \`stream\`è¡¨ç¤ºæŒç»­æ¨é€  
\- \*\*\`message\`\*\*: å®šä¹‰è¯·æ±‚å’Œå“åº”çš„æ•°æ®ç»“æ„  
\- \*\*å­—æ®µç¼–å·\*\*: 1, 2, 3ç­‰æ˜¯å­—æ®µçš„å”¯ä¸€æ ‡è¯†ï¼Œç”¨äºåºåˆ—åŒ–

3.å®ç°ä¸Šé¢çš„æ–¹æ³•

using Grpc.Core;

namespace GrpcRealtimePush.Services;

public class ChatService : GrpcRealtimePush.ChatService.ChatServiceBase
{
    private readonly ILogger<ChatService> \_logger;

    public ChatService(ILogger<ChatService> logger)
    {
        \_logger \= logger;
    }

    public override async Task StartRealtimePush(RealtimePushRequest request, 
        IServerStreamWriter<RealtimePushResponse> responseStream, ServerCallContext context)
    {
        \_logger.LogInformation("ğŸš€ å®æ—¶æ¨é€å·²å¯åŠ¨! å®¢æˆ·ç«¯: {ClientId}", request.ClientId);
        
        try
        {
            // å¼€å§‹è¿ç»­æ•°æ®æ¨é€
            var counter = 1;
            var random = new Random();
            var dataTypes = new\[\] { "ç³»ç»ŸçŠ¶æ€", "ç”¨æˆ·æ´»åŠ¨", "æ•°æ®æ›´æ–°", "é€šçŸ¥æ¶ˆæ¯", "æ€§èƒ½æŒ‡æ ‡" };
            
            \_logger.LogInformation("ğŸ”„ å¼€å§‹è¿ç»­æ•°æ®æ¨é€å¾ªç¯...");
            
            while (!context.CancellationToken.IsCancellationRequested && counter <= 100)
            {
                // æ¨¡æ‹Ÿä¸åŒç±»å‹çš„å®æ—¶æ•°æ®
                var dataType = dataTypes\[random.Next(dataTypes.Length)\];
                var value = random.Next(1, 1000);
                var timestamp = DateTime.UtcNow;
                
                var response = new RealtimePushResponse
                {
                    Data \= $"#{counter:D4} - æ•°å€¼: {value} | æ—¶é—´: {timestamp:HH:mm:ss.fff}",
                    Timestamp \= DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
                    DataType \= dataType
                };

                await responseStream.WriteAsync(response);
                \_logger.LogInformation("ğŸ“¡ æ¨é€æ•°æ® #{Counter}: \[{DataType}\] = {Value} at {Time}", 
                    counter, dataType, value, timestamp.ToString("HH:mm:ss.fff"));
                
                counter++;
                
                // ç­‰å¾…2ç§’åå‘é€ä¸‹ä¸€æ¡æ•°æ®
                await Task.Delay(2000, context.CancellationToken);
            }
            
            // å‘é€å®Œæˆæ¶ˆæ¯
            await responseStream.WriteAsync(new RealtimePushResponse
            {
                Data \= "å®æ—¶æ¨é€æµ‹è¯•å®Œæˆï¼",
                Timestamp \= DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
                DataType \= "ç³»ç»Ÿæ¶ˆæ¯"
            });
            
        }
        catch (OperationCanceledException)
        {
            \_logger.LogInformation("å®æ—¶æ¨é€ä¼šè¯å·²å–æ¶ˆï¼Œå®¢æˆ·ç«¯: {ClientId}", request.ClientId);
        }
        catch (Exception ex)
        {
            \_logger.LogError(ex, "å®æ—¶æ¨é€ä¼šè¯å‡ºé”™: {Error}", ex.Message);
            
            // å°è¯•å‘å®¢æˆ·ç«¯å‘é€é”™è¯¯æ¶ˆæ¯
            try
            {
                await responseStream.WriteAsync(new RealtimePushResponse
                {
                    Data \= $"æœåŠ¡å™¨é”™è¯¯: {ex.Message}",
                    Timestamp \= DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
                    DataType \= "é”™è¯¯æ¶ˆæ¯"
                });
            }
            catch (Exception sendError)
            {
                \_logger.LogError(sendError, "å‘é€é”™è¯¯æ¶ˆæ¯å¤±è´¥");
            }
        }
        
        \_logger.LogInformation("å®æ—¶æ¨é€ä¼šè¯ç»“æŸï¼Œå®¢æˆ·ç«¯: {ClientId}", request.ClientId);
    }
}

4.Programæ–‡ä»¶

using GrpcRealtimePush.Services;

var builder = WebApplication.CreateBuilder(args);

// æ·»åŠ gRPCæœåŠ¡
builder.Services.AddGrpc();

// é…ç½®CORSç­–ç•¥ï¼Œæ”¯æŒgRPC-Web
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader()
              .WithExposedHeaders("Grpc-Status", "Grpc-Message", "Grpc-Encoding", "Grpc-Accept-Encoding", "Content-Type");
    });
});

var app = builder.Build();

// é…ç½®HTTPè¯·æ±‚ç®¡é“

// å¯ç”¨CORS
app.UseCors("AllowAll");

// å¯ç”¨gRPC-Webä¸­é—´ä»¶
app.UseGrpcWeb();

// é…ç½®HTTPSé‡å®šå‘ï¼ˆgRPC-Webéœ€è¦ï¼‰
app.UseHttpsRedirection();

// æ˜ å°„gRPCæœåŠ¡å¹¶å¯ç”¨gRPC-Webæ”¯æŒ
app.MapGrpcService<ChatService>().EnableGrpcWeb();

app.MapGet("/", () => "Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909");

app.Run();

ä»¥ä¸Šä»£ç å¯¹äºåç«¯æ¥è¯´åº”è¯¥è½»è½¦ç†Ÿè·¯ï¼Œåç«¯æœåŠ¡å°±è¿™æ ·èµ·æ¥äº†ã€‚

å…ˆæµ‹è¯•ä¸€ä¸‹åç«¯æœåŠ¡æ˜¯å¦æ­£å¸¸ï¼Œæˆ‘è¿™é‡Œæœ‰goç¯å¢ƒï¼Œç›´æ¥å®‰è£…grpcurlå·¥å…·ã€‚

\# å®‰è£…grpcurlå·¥å…·
go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest

# æµ‹è¯•æœåŠ¡
grpcurl -insecure localhost:5201 list

grpcurl -insecure -d "{\\"client\_id\\":\\"test-client\\",\\"timestamp\\":1234567890}" localhost:5201 chat.ChatService/StartRealtimePush

ä¸‹é¢å°±æ˜¯å®Œæˆå‰ç«¯ä»£ç äº†ï¼Œè¿™é‡Œä½¿ç”¨js+htmlã€‚

  
å‰ç«¯çš„ç»“æ„å¦‚ä¸‹ï¼š

client/  
â”œâ”€â”€ generated/ # ç”Ÿæˆçš„ä»£ç   
â”‚ â”œâ”€â”€ chat\_pb\_browser.js # Protocol Buffersæ¶ˆæ¯ç±»  
â”‚ â””â”€â”€ chat\_grpc\_web\_pb\_browser.js # gRPCæœåŠ¡å®¢æˆ·ç«¯  
â”œâ”€â”€ grpc-web-shim.js # gRPC-Webå…¼å®¹å±‚  
â”œâ”€â”€ client.js # ä¸»è¦ä¸šåŠ¡é€»è¾‘  
â”œâ”€â”€ index.html # ç”¨æˆ·ç•Œé¢  
  
å‰ç«¯å‡†å¤‡å·¥ä½œå®‰è£…protocå’Œæ’ä»¶ã€‚protocæŠŠåç«¯çš„protoæ–‡ä»¶è½¬æˆä¸¤ä¸ªjsæ–‡ä»¶ï¼Œæ’ä»¶å°±æ˜¯grpcé“¾æ¥éœ€è¦çš„ã€‚

\# å®‰è£…Protocol Buffersç¼–è¯‘å™¨
# Windows: ä¸‹è½½ https://github.com/protocolbuffers/protobuf/releases
\# macOS: brew install protobuf
# Linux: apt\-get install protobuf-compiler

# éªŒè¯å®‰è£…
protoc \--version

# å®‰è£…gRPC\-Webæ’ä»¶
npm install \-g grpc-web

æ ¸å¿ƒè½¬æ¢ä»£ç è„šæœ¬å¦‚ä¸‹ï¼š

protoc -I=GrpcRealtimePush\\Protos \`
  \--js\_out=import\_style=commonjs:client\\generated \`
  \--grpc-web\_out=import\_style=commonjs,mode=grpcwebtext:client\\generated \`
  GrpcRealtimePush\\Protos\\chat.proto

æ‰§è¡Œäº†protocåä¼šç”Ÿæˆä¸‹é¢2ä¸ªjsæ–‡ä»¶

  
1\. \`chat\_pb\_browser.js\`

// Browser-compatible version of chat\_pb.js
(function () {
    'use strict';

    // ç¡®ä¿å‘½åç©ºé—´å­˜åœ¨
    if (!window.proto) window.proto = {};
    if (!window.proto.chat) window.proto.chat = {};

    // RealtimePushRequestç±»
    window.proto.chat.RealtimePushRequest = function (opt\_data) {
        jspb.Message.initialize(this, opt\_data, 0, -1, null, null);
    };

    // ç»§æ‰¿jspb.Message
    if (jspb.Message) {
        window.proto.chat.RealtimePushRequest.prototype \= Object.create(jspb.Message.prototype);
        window.proto.chat.RealtimePushRequest.prototype.constructor \= window.proto.chat.RealtimePushRequest;
    }

    // RealtimePushRequestæ–¹æ³•
    window.proto.chat.RealtimePushRequest.prototype.getClientId = function () {
        return jspb.Message.getFieldWithDefault(this, 1, "");
    };

    window.proto.chat.RealtimePushRequest.prototype.setClientId \= function (value) {
        return jspb.Message.setProto3StringField(this, 1, value);
    };

    window.proto.chat.RealtimePushRequest.prototype.getTimestamp \= function () {
        return jspb.Message.getFieldWithDefault(this, 2, 0);
    };

    window.proto.chat.RealtimePushRequest.prototype.setTimestamp \= function (value) {
        return jspb.Message.setProto3IntField(this, 2, value);
    };

    // åºåˆ—åŒ–æ–¹æ³•
    window.proto.chat.RealtimePushRequest.prototype.serializeBinary = function () {
        const writer \= new jspb.BinaryWriter();
        window.proto.chat.RealtimePushRequest.serializeBinaryToWriter(this, writer);
        return writer.getResultBuffer();
    };

    window.proto.chat.RealtimePushRequest.serializeBinaryToWriter \= function (message, writer) {
        const f \= message.getClientId();
        if (f.length > 0) {
            writer.writeString(1, f);
        }
        const f2 \= message.getTimestamp();
        if (f2 !== 0) {
            writer.writeInt64(2, f2);
        }
    };

    window.proto.chat.RealtimePushRequest.deserializeBinary \= function (bytes) {
        const reader \= new jspb.BinaryReader(bytes);
        const msg \= new window.proto.chat.RealtimePushRequest();
        return window.proto.chat.RealtimePushRequest.deserializeBinaryFromReader(msg, reader);
    };

    window.proto.chat.RealtimePushRequest.deserializeBinaryFromReader \= function (msg, reader) {
        while (reader.nextField()) {
            if (reader.isEndGroup()) {
                break;
            }
            const field \= reader.getFieldNumber();
            switch (field) {
                case 1:
                    const value \= reader.readString();
                    msg.setClientId(value);
                    break;
                case 2:
                    const value2 \= reader.readInt64();
                    msg.setTimestamp(value2);
                    break;
                default:
                    reader.skipField();
                    break;
            }
        }
        return msg;
    };

    // RealtimePushResponseç±»
    window.proto.chat.RealtimePushResponse = function (opt\_data) {
        jspb.Message.initialize(this, opt\_data, 0, -1, null, null);
    };

    // ç»§æ‰¿jspb.Message
    if (jspb.Message) {
        window.proto.chat.RealtimePushResponse.prototype \= Object.create(jspb.Message.prototype);
        window.proto.chat.RealtimePushResponse.prototype.constructor \= window.proto.chat.RealtimePushResponse;
    }

    // RealtimePushResponseæ–¹æ³•
    window.proto.chat.RealtimePushResponse.prototype.getData = function () {
        return jspb.Message.getFieldWithDefault(this, 1, "");
    };

    window.proto.chat.RealtimePushResponse.prototype.setData \= function (value) {
        return jspb.Message.setProto3StringField(this, 1, value);
    };

    window.proto.chat.RealtimePushResponse.prototype.getTimestamp \= function () {
        return jspb.Message.getFieldWithDefault(this, 2, 0);
    };

    window.proto.chat.RealtimePushResponse.prototype.setTimestamp \= function (value) {
        return jspb.Message.setProto3IntField(this, 2, value);
    };

    window.proto.chat.RealtimePushResponse.prototype.getDataType \= function () {
        return jspb.Message.getFieldWithDefault(this, 3, "");
    };

    window.proto.chat.RealtimePushResponse.prototype.setDataType \= function (value) {
        return jspb.Message.setProto3StringField(this, 3, value);
    };

    // åºåˆ—åŒ–æ–¹æ³•
    window.proto.chat.RealtimePushResponse.prototype.serializeBinary = function () {
        const writer \= new jspb.BinaryWriter();
        window.proto.chat.RealtimePushResponse.serializeBinaryToWriter(this, writer);
        return writer.getResultBuffer();
    };

    window.proto.chat.RealtimePushResponse.serializeBinaryToWriter \= function (message, writer) {
        const f \= message.getData();
        if (f.length > 0) {
            writer.writeString(1, f);
        }
        const f2 \= message.getTimestamp();
        if (f2 !== 0) {
            writer.writeInt64(2, f2);
        }
        const f3 \= message.getDataType();
        if (f3.length > 0) {
            writer.writeString(3, f3);
        }
    };

    window.proto.chat.RealtimePushResponse.deserializeBinary \= function (bytes) {
        const reader \= new jspb.BinaryReader(bytes);
        const msg \= new window.proto.chat.RealtimePushResponse();
        return window.proto.chat.RealtimePushResponse.deserializeBinaryFromReader(msg, reader);
    };

    window.proto.chat.RealtimePushResponse.deserializeBinaryFromReader \= function (msg, reader) {
        while (reader.nextField()) {
            if (reader.isEndGroup()) {
                break;
            }
            const field \= reader.getFieldNumber();
            switch (field) {
                case 1:
                    const value \= reader.readString();
                    msg.setData(value);
                    break;
                case 2:
                    const value2 \= reader.readInt64();
                    msg.setTimestamp(value2);
                    break;
                case 3:
                    const value3 \= reader.readString();
                    msg.setDataType(value3);
                    break;
                default:
                    reader.skipField();
                    break;
            }
        }
        return msg;
    };

    console.log('chat\_pb\_browser.js loaded successfully');
})();

2\. \`chat\_grpc\_web\_pb\_browser.js\`

// Browser-compatible version of chat\_grpc\_web\_pb.js
(function () {
    'use strict';

    // ç¡®ä¿å‘½åç©ºé—´å­˜åœ¨
    if (!window.proto) window.proto = {};
    if (!window.proto.chat) window.proto.chat = {};

    // ChatServiceClientç±»
    window.proto.chat.ChatServiceClient = function (hostname, credentials, options) {
        if (!options) options = {};
        options\['format'\] = options\['format'\] || 'text';

        // ä½¿ç”¨gRPC-WebåŸºç±»
        window.grpc.web.GrpcWebClientBase.call(this, options);

        this.hostname\_ = hostname;
        this.credentials\_ = credentials;
        this.options\_ = options;
    };

    // ç»§æ‰¿åŸºç±»
    if (window.grpc && window.grpc.web && window.grpc.web.GrpcWebClientBase) {
        window.proto.chat.ChatServiceClient.prototype \= Object.create(window.grpc.web.GrpcWebClientBase.prototype);
        window.proto.chat.ChatServiceClient.prototype.constructor \= window.proto.chat.ChatServiceClient;
    }

    // æ–¹æ³•æè¿°ç¬¦
    const methodDescriptor\_StartRealtimePush = new window.grpc.web.MethodDescriptor(
        '/chat.ChatService/StartRealtimePush',
        window.grpc.web.MethodType.SERVER\_STREAMING,
        window.proto.chat.RealtimePushRequest,
        window.proto.chat.RealtimePushResponse,
        function (request) { 
            return request.serializeBinary(); 
        },
        function (bytes) { 
            return window.proto.chat.RealtimePushResponse.deserializeBinary(bytes); 
        }
    );

    // StartRealtimePushæ–¹æ³•
    window.proto.chat.ChatServiceClient.prototype.startRealtimePush = function (request, metadata) {
        const url \= this.hostname\_ + '/chat.ChatService/StartRealtimePush';
        return this.serverStreaming(url, request, metadata || {}, methodDescriptor\_StartRealtimePush);
    };

    console.log('chat\_grpc\_web\_pb\_browser.js loaded successfully');
})();

ä¸‹é¢å°±éœ€è¦åˆ›å»ºè¿æ¥å±‚ä»£ç ï¼Œè¯¥ä»£ç æ‰‹åŠ¨åˆ›å»º,æœ‰éœ€è¦å¯ä»¥æ‹·è´æ›´æ”¹å¤ç”¨ã€‚

\`grpc-web-shim.js\`

// gRPC-Web compatibility shim
(function() {
    'use strict';

    // åˆ›å»ºgrpcå‘½åç©ºé—´
    if (typeof window.grpc === 'undefined') {
        window.grpc \= {};
    }

    if (typeof window.grpc.web === 'undefined') {
        window.grpc.web \= {};
    }

    // æ–¹æ³•ç±»å‹æšä¸¾
    window.grpc.web.MethodType = {
        UNARY: 'unary',
        SERVER\_STREAMING: 'server\_streaming',
        CLIENT\_STREAMING: 'client\_streaming',
        BIDIRECTIONAL\_STREAMING: 'bidirectional\_streaming'
    };

    // æ–¹æ³•æè¿°ç¬¦
    window.grpc.web.MethodDescriptor = function(path, methodType, requestType, responseType, requestSerializeFn, responseDeserializeFn) {
        this.path = path;
        this.methodType = methodType;
        this.requestType = requestType;
        this.responseType = responseType;
        this.requestSerializeFn = requestSerializeFn;
        this.responseDeserializeFn = responseDeserializeFn;
    };

    // åŸºç¡€å®¢æˆ·ç«¯ç±»
    window.grpc.web.GrpcWebClientBase = function(options) {
        this.options = options || {};
        this.format = this.options.format || 'text';
    };

    // æœåŠ¡ç«¯æµå¼æ–¹æ³•
    window.grpc.web.GrpcWebClientBase.prototype.serverStreaming = function(url, request, metadata, methodDescriptor) {
        const self \= this;
        
        // åˆ›å»ºç®€å•çš„äº‹ä»¶å‘å°„å™¨
        const stream = {
            listeners: {},
            
            on: function(event, callback) {
                if (!this.listeners\[event\]) {
                    this.listeners\[event\] = \[\];
                }
                this.listeners\[event\].push(callback);
            },
            
            emit: function(event, data) {
                if (this.listeners\[event\]) {
                    this.listeners\[event\].forEach(callback => callback(data));
                }
            }
        };

        try {
            // åºåˆ—åŒ–è¯·æ±‚
            const serializedRequest = methodDescriptor.requestSerializeFn(request);
            
            // åˆ›å»ºgRPC-Webå¸§
            const frameHeader = new Uint8Array(5);
            frameHeader\[0\] = 0; // å‹ç¼©æ ‡å¿—
            
            const messageLength \= serializedRequest.length;
            frameHeader\[1\] = (messageLength >>> 24) & 0xFF;
            frameHeader\[2\] = (messageLength >>> 16) & 0xFF;
            frameHeader\[3\] = (messageLength >>> 8) & 0xFF;
            frameHeader\[4\] = messageLength & 0xFF;
            
            const framedMessage \= new Uint8Array(5 + messageLength);
            framedMessage.set(frameHeader, 0);
            framedMessage.set(serializedRequest, 5);
            
            const base64Request \= btoa(String.fromCharCode.apply(null, framedMessage));
            
            const headers \= {
                'Content-Type': 'application/grpc-web-text',
                'X-Grpc-Web': '1',
                'Accept': 'application/grpc-web-text'
            };
            
            // æ·»åŠ å…ƒæ•°æ®
            if (metadata) {
                Object.keys(metadata).forEach(key \=> {
                    if (key.toLowerCase() !== 'content-type') {
                        headers\[key\] \= metadata\[key\];
                    }
                });
            }
            
            const fetchOptions \= {
                method: 'POST',
                headers: headers,
                body: base64Request
            };

            fetch(url, fetchOptions)
                .then(response \=> {
                    if (!response.ok) {
                        throw new Error(\`HTTP ${response.status}: ${response.statusText}\`);
                    }
                    
                    console.log('å¼€å§‹è¯»å–æµå¼å“åº”...');
                    
                    // ä½¿ç”¨ReadableStreamè¯»å–gRPC-Webæµå¼å“åº”
                    const reader = response.body.getReader();
                    const decoder \= new TextDecoder();
                    let buffer \= '';
                    let messageCount \= 0;
                    
                    function readStreamChunk() {
                        return reader.read().then(({ done, value }) => {
                            if (done) {
                                console.log('ğŸ“¡ æµè¯»å–å®Œæˆï¼Œæ€»å…±å¤„ç†æ¶ˆæ¯:', messageCount);
                                if (buffer.length > 0) {
                                    console.log('ğŸ“¦ å¤„ç†æµç»“æŸæ—¶çš„å‰©ä½™ç¼“å†²åŒº');
                                    processStreamBuffer();
                                }
                                stream.emit('end');
                                return;
                            }
                            
                            // å°†æ–°æ•°æ®æ·»åŠ åˆ°ç¼“å†²åŒº
                            const chunk = decoder.decode(value, { stream: true });
                            buffer += chunk;
                            console.log('ğŸ“¦ æ”¶åˆ°æµæ•°æ®å—:', chunk.length, 'å­—ç¬¦ï¼Œç¼“å†²åŒºæ€»è®¡:', buffer.length);
                            
                            // å¤„ç†ç¼“å†²åŒºä¸­çš„å®Œæ•´æ¶ˆæ¯
                            processStreamBuffer();
                            
                            // ç»§ç»­è¯»å–
                            return readStreamChunk();
                        }).catch(error => {
                            console.error('âŒ æµè¯»å–é”™è¯¯:', error);
                            stream.emit('error', error);
                        });
                    }
                    
                    function processStreamBuffer() {
                        console.log('ğŸ” å¤„ç†ç¼“å†²åŒºï¼Œé•¿åº¦:', buffer.length);
                        
                        while (buffer.length > 0) {
                            try {
                                // æŸ¥æ‰¾å®Œæ•´çš„base64å—
                                let messageBase64 = buffer;
                                
                                // æ£€æŸ¥æ˜¯å¦åŒ…å«traileræ ‡è®°
                                const trailerMarkers = \['gAAAA', 'gAAA', 'gAA', 'gA'\];
                                let trailerIndex \= -1;
                                
                                for (const marker of trailerMarkers) {
                                    const index \= messageBase64.indexOf(marker);
                                    if (index > 0) {
                                        trailerIndex \= index;
                                        break;
                                    }
                                }
                                
                                if (trailerIndex > 0) {
                                    messageBase64 \= messageBase64.substring(0, trailerIndex);
                                    console.log('ğŸ“¦ åœ¨ç´¢å¼•å¤„æ‰¾åˆ°trailer:', trailerIndex);
                                }
                                
                                // æ¸…ç†base64å­—ç¬¦ä¸²
                                const cleanBase64 = messageBase64.replace(/\[^A-Za-z0-9+/=\]/g, '');
                                
                                // ç¡®ä¿base64å­—ç¬¦ä¸²é•¿åº¦æ˜¯4çš„å€æ•°
                                let paddedBase64 = cleanBase64;
                                const padding \= paddedBase64.length % 4;
                                if (padding > 0) {
                                    paddedBase64 += '='.repeat(4 - padding);
                                }
                                
                                if (paddedBase64.length === 0) {
                                    console.log('âŒ æ¸…ç†åbase64ä¸ºç©º');
                                    buffer \= '';
                                    break;
                                }
                                
                                // è§£ç base64
                                const binaryString = atob(paddedBase64);
                                const responseBytes \= new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    responseBytes\[i\] \= binaryString.charCodeAt(i);
                                }
                                
                                console.log('ğŸ“¦ è§£ç å­—èŠ‚é•¿åº¦:', responseBytes.length);
                                
                                // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ•°æ®æ¥è¯»å–gRPCå¸§å¤´
                                if (responseBytes.length >= 5) {
                                    const compressionFlag \= responseBytes\[0\];
                                    const frameMsgLength \= (responseBytes\[1\] << 24) | (responseBytes\[2\] << 16) | (responseBytes\[3\] << 8) | responseBytes\[4\];
                                    
                                    console.log(\`ğŸ“¡ æµå¸§: å‹ç¼©\=${compressionFlag}, é•¿åº¦=${frameMsgLength}, æ€»è®¡=${responseBytes.length}\`);
                                    
                                    // æ£€æŸ¥æ˜¯å¦æœ‰å®Œæ•´çš„æ¶ˆæ¯æ•°æ®
                                    if (responseBytes.length >= 5 + frameMsgLength && frameMsgLength > 0) {
                                        const messageBytes \= responseBytes.slice(5, 5 + frameMsgLength);
                                        
                                        try {
                                            const response \= methodDescriptor.responseDeserializeFn(messageBytes);
                                            messageCount++;
                                            console.log(\`âœ… æˆåŠŸè§£ææ¶ˆæ¯ #${messageCount}ï¼Œå‘å°„æ•°æ®\`);
                                            stream.emit('data', response);
                                            
                                            // å¤„ç†å®Œæˆåï¼Œç§»é™¤å·²å¤„ç†çš„æ•°æ®
                                            if (trailerIndex > 0) {
                                                buffer \= buffer.substring(trailerIndex);
                                                console.log('ğŸ“¦ ç§»åŠ¨ç¼“å†²åŒºè¶Šè¿‡trailerï¼Œå‰©ä½™é•¿åº¦:', buffer.length);
                                            } else {
                                                buffer \= '';
                                                console.log('ğŸ“¦ å®Œå…¨æ¸…ç©ºç¼“å†²åŒº');
                                            }
                                            
                                        } catch (deserializeError) {
                                            console.error('âŒ ååºåˆ—åŒ–é”™è¯¯:', deserializeError);
                                            buffer \= '';
                                            break;
                                        }
                                    } else {
                                        console.log('âŒ å¸§æ•°æ®ä¸å®Œæ•´æˆ–é•¿åº¦æ— æ•ˆ');
                                        if (buffer.length < 200) {
                                            break;
                                        } else {
                                            buffer \= '';
                                            break;
                                        }
                                    }
                                } else {
                                    console.log('âŒ å¸§å¤ªçŸ­ï¼Œç­‰å¾…æ›´å¤šæ•°æ®');
                                    break;
                                }
                                
                            } catch (parseError) {
                                console.error('âŒ å¤„ç†æµæ¶ˆæ¯é”™è¯¯:', parseError);
                                buffer \= '';
                                break;
                            }
                        }
                        
                        console.log('ğŸ” å‰©ä½™ç¼“å†²åŒºé•¿åº¦:', buffer.length);
                    }
                    
                    // å¼€å§‹è¯»å–æµ
                    return readStreamChunk();
                })
                .catch(error => {
                    console.error('æµè·å–é”™è¯¯:', error);
                    stream.emit('error', error);
                });
                
        } catch (error) {
            setTimeout(() \=> stream.emit('error', error), 0);
        }

        return stream;
    };

    console.log('gRPC-Web shim loaded successfully');
})();

ä¸‹é¢å°±æ˜¯ç®€å•çš„è·å–å®æ—¶æ•°æ®çš„ä¸šåŠ¡é€»è¾‘äº†

\`client.js\`

// gRPC-Web Chat Client Implementation
class RealtimePushClient {
    constructor() {
        this.client = null;
        this.isConnected = false;
        this.serverUrl = 'https://localhost:5201';
        
        // æµå¼ä¼ è¾“ç›¸å…³å±æ€§
        this.currentStream = null;
        this.streamMessageCount = 0;
        this.streamStartTime = null;
        
        this.initializeUI();
    }

    initializeUI() {
        const streamButton \= document.getElementById('streamButton');
        const stopStreamButton \= document.getElementById('stopStreamButton');
        const clearButton \= document.getElementById('clearButton');

        streamButton.addEventListener('click', () => this.startStreamingChat());
        stopStreamButton.addEventListener('click', () => this.stopStreaming());
        clearButton.addEventListener('click', () => this.clearMessages());

        // åˆå§‹åŒ–è¿æ¥çŠ¶æ€
        this.updateConnectionStatus(false, 'æ­£åœ¨åˆå§‹åŒ–...');

        // é¡µé¢åŠ è½½æ—¶å°è¯•è¿æ¥
        this.connect();
    }

    connect() {
        try {
            // åˆå§‹åŒ–gRPC-Webå®¢æˆ·ç«¯
            console.log('æ­£åœ¨åˆå§‹åŒ–å®æ—¶æ¨é€å®¢æˆ·ç«¯...');
            
            // æ£€æŸ¥å¿…è¦çš„ä¾èµ–æ˜¯å¦å¯ç”¨
            if (typeof jspb === 'undefined') {
                throw new Error('google-protobuf åº“æœªåŠ è½½');
            }
            
            if (typeof grpc === 'undefined' || !grpc.web) {
                console.warn('grpc-web åº“æœªå®Œå…¨åŠ è½½ï¼Œç­‰å¾…é‡è¯•...');
                setTimeout(() \=> this.connect(), 1000);
                return;
            }
            
            if (typeof proto === 'undefined' || !proto.chat || !proto.chat.ChatServiceClient) {
                throw new Error('gRPC ç”Ÿæˆçš„å®¢æˆ·ç«¯ä»£ç æœªåŠ è½½');
            }

            // åˆ›å»ºgRPC-Webå®¢æˆ·ç«¯
            this.client = new proto.chat.ChatServiceClient(this.serverUrl, null, {
                format: 'text',
                withCredentials: false
            });
            
            console.log('å®æ—¶æ¨é€å®¢æˆ·ç«¯åˆ›å»ºæˆåŠŸ');
            this.updateConnectionStatus(true, 'å·²è¿æ¥');
            this.addMessage('ç³»ç»Ÿ', 'ğŸš€ å®æ—¶æ¨é€å®¢æˆ·ç«¯å·²å°±ç»ª', 'system');
            
        } catch (error) {
            console.error('è¿æ¥åˆå§‹åŒ–å¤±è´¥:', error);
            this.updateConnectionStatus(false, 'åˆå§‹åŒ–å¤±è´¥');
            this.addMessage('ç³»ç»Ÿ', 'åˆå§‹åŒ–å¤±è´¥: ' + this.getErrorMessage(error), 'error');
        }
    }

    startStreamingChat() {
        if (!this.isConnected) {
            this.addMessage('ç³»ç»Ÿ', 'æœªè¿æ¥åˆ°æœåŠ¡å™¨ï¼Œæ— æ³•å¯åŠ¨å®æ—¶æ¨é€', 'error');
            return;
        }

        if (!this.client) {
            this.addMessage('ç³»ç»Ÿ', 'gRPCå®¢æˆ·ç«¯æœªåˆå§‹åŒ–', 'error');
            return;
        }

        // æ£€æŸ¥æ˜¯å¦å·²åœ¨æµå¼ä¼ è¾“
        if (this.currentStream) {
            this.addMessage('ç³»ç»Ÿ', 'å®æ—¶æ¨é€å·²åœ¨è¿è¡Œä¸­', 'system');
            return;
        }

        try {
            // åˆ›å»ºå®æ—¶æ¨é€è¯·æ±‚
            const pushRequest = new proto.chat.RealtimePushRequest();
            pushRequest.setClientId('web-client-' + Date.now());
            pushRequest.setTimestamp(Math.floor(Date.now() / 1000));

            console.log('å¯åŠ¨å®æ—¶æ¨é€:', {
                clientId: pushRequest.getClientId(),
                timestamp: pushRequest.getTimestamp()
            });

            // æ·»åŠ æµå¼ä¼ è¾“çš„å…ƒæ•°æ®
            const metadata = {
                'x-user-agent': 'grpc-web-realtime-client'
            };

            // å¼€å§‹æµå¼ä¼ è¾“
            const stream = this.client.startRealtimePush(pushRequest, metadata);
            
            if (!stream) {
                throw new Error('æ— æ³•åˆ›å»ºå®æ—¶æ¨é€è¿æ¥');
            }

            // å­˜å‚¨æµå¼•ç”¨
            this.currentStream = stream;
            this.streamMessageCount = 0;
            this.streamStartTime = Date.now();

            // æ›´æ–°UIæ˜¾ç¤ºæµå¼ä¼ è¾“å·²æ¿€æ´»
            this.updateStreamingUI(true);

            stream.on('data', (response) => {
                if (response && typeof response.getData === 'function') {
                    this.streamMessageCount++;
                    
                    // æ·»åŠ å¸¦æœ‰å®æ—¶æ•°æ®ç‰¹æ®Šæ ·å¼çš„æ¶ˆæ¯
                    this.addRealtimeMessage(
                        \`\[${response.getDataType()}\] ${response.getData()}\`, 
                        this.streamMessageCount
                    );
                    
                    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                    this.updateStreamStats();
                }
            });

            stream.on('error', (error) => {
                console.error('å®æ—¶æ¨é€é”™è¯¯:', error);
                this.addMessage('ç³»ç»Ÿ', 'å®æ—¶æ¨é€é”™è¯¯: ' + this.getErrorMessage(error), 'error');
                this.stopStreaming();
            });

            stream.on('end', () => {
                console.log('å®æ—¶æ¨é€ç»“æŸ');
                this.addMessage('ç³»ç»Ÿ', 'å®æ—¶æ¨é€å·²ç»“æŸ', 'system');
                this.stopStreaming();
            });

            this.addMessage('ç³»ç»Ÿ', 'ğŸš€ å®æ—¶æ•°æ®æ¨é€å·²å¯åŠ¨', 'system');
            
        } catch (error) {
            console.error('å¯åŠ¨å®æ—¶æ¨é€å¤±è´¥:', error);
            this.addMessage('ç³»ç»Ÿ', 'å¯åŠ¨å®æ—¶æ¨é€å¤±è´¥: ' + this.getErrorMessage(error), 'error');
        }
    }

    // å…¶ä»–æ–¹æ³•å®ç°...
    updateConnectionStatus(connected, message = '') {
        const statusDiv \= document.getElementById('status');
        const streamButton \= document.getElementById('streamButton');
        
        this.isConnected = connected;
        
        if (connected) {
            statusDiv.textContent \= 'çŠ¶æ€: å·²è¿æ¥' + (message ? ' - ' + message : '');
            statusDiv.className \= 'status connected';
            streamButton.disabled \= false;
        } else {
            statusDiv.textContent \= 'çŠ¶æ€: æœªè¿æ¥' + (message ? ' - ' + message : '');
            statusDiv.className \= 'status disconnected';
            streamButton.disabled \= true;
        }
    }

    addMessage(sender, content, type) {
        const chatContainer \= document.getElementById('chatContainer');
        const messageDiv \= document.createElement('div');
        messageDiv.className \= \`message ${type}\`;
        
        const timestamp \= new Date().toLocaleTimeString();
        messageDiv.innerHTML \= \`
            <div><strong>${sender}</strong> <small>${timestamp}</small></div>
            <div>${content}</div>
        \`;

        chatContainer.appendChild(messageDiv);
        chatContainer.scrollTop \= chatContainer.scrollHeight;
    }

    addRealtimeMessage(content, count) {
        const chatContainer \= document.getElementById('chatContainer');
        const messageDiv \= document.createElement('div');
        messageDiv.className \= 'message realtime';
        
        const timestamp \= new Date().toLocaleTimeString();
        messageDiv.innerHTML \= \`
            <div class="realtime-header">
                <strong>ğŸ“¡ å®æ—¶æ•°æ® #${count}</strong> 
                <small>${timestamp}</small>
            </div>
            <div class="realtime-content">${content}</div>
        \`;

        chatContainer.appendChild(messageDiv);
        chatContainer.scrollTop \= chatContainer.scrollHeight;

        // ä¿æŒæœ€å100æ¡æ¶ˆæ¯ä»¥é˜²æ­¢å†…å­˜é—®é¢˜
        const messages = chatContainer.querySelectorAll('.message');
        if (messages.length > 100) {
            for (let i = 0; i < messages.length - 100; i++) {
                messages\[i\].remove();
            }
        }
    }

    getErrorMessage(error) {
        if (!error) return 'æœªçŸ¥é”™è¯¯';
        
        // å¤„ç†gRPC-Webç‰¹å®šé”™è¯¯
        if (error.code !== undefined) {
            const grpcErrorCodes \= {
                0: 'OK',
                1: 'CANCELLED - æ“ä½œè¢«å–æ¶ˆ',
                2: 'UNKNOWN - æœªçŸ¥é”™è¯¯',
                3: 'INVALID\_ARGUMENT - æ— æ•ˆå‚æ•°',
                4: 'DEADLINE\_EXCEEDED - è¯·æ±‚è¶…æ—¶',
                5: 'NOT\_FOUND - æœªæ‰¾åˆ°',
                6: 'ALREADY\_EXISTS - å·²å­˜åœ¨',
                7: 'PERMISSION\_DENIED - æƒé™è¢«æ‹’ç»',
                8: 'RESOURCE\_EXHAUSTED - èµ„æºè€—å°½',
                9: 'FAILED\_PRECONDITION - å‰ç½®æ¡ä»¶å¤±è´¥',
                10: 'ABORTED - æ“ä½œè¢«ä¸­æ­¢',
                11: 'OUT\_OF\_RANGE - è¶…å‡ºèŒƒå›´',
                12: 'UNIMPLEMENTED - æœªå®ç°',
                13: 'INTERNAL - å†…éƒ¨é”™è¯¯',
                14: 'UNAVAILABLE - æœåŠ¡ä¸å¯ç”¨',
                15: 'DATA\_LOSS - æ•°æ®ä¸¢å¤±',
                16: 'UNAUTHENTICATED - æœªè®¤è¯'
            };
            
            const codeDescription \= grpcErrorCodes\[error.code\] || \`æœªçŸ¥é”™è¯¯ä»£ç : ${error.code}\`;
            return \`gRPCé”™è¯¯: ${codeDescription}\`;
        }
        
        return error.message || error.toString();
    }
}

// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–å®æ—¶æ¨é€å®¢æˆ·ç«¯
document.addEventListener('DOMContentLoaded', () => {
    window.realtimePushClient \= new RealtimePushClient();
});

æœ€ååˆ›å»ºä¸€ä¸ªhtmlç•Œé¢

\`â€‹index.html\`

<!DOCTYPE html\>
<html lang\="zh-CN"\>
<head\>
    <meta charset\="UTF-8"\>
    <meta name\="viewport" content\="width=device-width, initial-scale=1.0"\>
    <title\>gRPC-Web å®æ—¶æ•°æ®æ¨é€</title\>
    <style\>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .chat-container {
            border: 1px solid #ccc;
            height: 400px;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
            border-left: 4px solid #ddd;
        }

        .system {
            background-color: #fff3e0;
            border-left-color: #ff9800;
            text-align: center;
            font-style: italic;
        }
        
        .error {
            background-color: #ffebee;
            border-left-color: #f44336;
            color: #c62828;
            text-align: center;
        }
        
        .realtime {
            background-color: #e8f5e8;
            border-left-color: #4caf50;
            animation: fadeIn 0.3s ease-in;
        }
        
        .realtime-header {
            font-weight: bold;
            color: #2e7d32;
            margin-bottom: 5px;
        }
        
        .realtime-content {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #1b5e20;
        }
        
        .input-container {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        #streamButton {
            background-color: #4caf50;
            color: white;
        }
        
        #streamButton:hover:not(:disabled) {
            background-color: #388e3c;
        }
        
        #streamButton:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        #stopStreamButton {
            background-color: #f44336;
            color: white;
        }
        
        #stopStreamButton:hover {
            background-color: #d32f2f;
        }
        
        #clearButton {
            background-color: #757575;
            color: white;
        }
        
        #clearButton:hover {
            background-color: #616161;
        }
        
        .status {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
            font-weight: bold;
            text-align: center;
        }
        
        .connected {
            background-color: #c8e6c9;
            color: #2e7d32;
            border: 1px solid #4caf50;
        }
        
        .disconnected {
            background-color: #ffcdd2;
            color: #c62828;
            border: 1px solid #f44336;
        }
        
        .stream-stats {
            background-color: #f3e5f5;
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
            font-size: 0.9em;
            color: #4a148c;
            border: 1px solid #9c27b0;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style\>
</head\>
<body\>
    <h1\>ğŸš€ gRPC-Web å®æ—¶æ•°æ®æ¨é€ç³»ç»Ÿ</h1\>
    
    <div id\="status" class\="status disconnected"\>
        çŠ¶æ€: æœªè¿æ¥
    </div\>
    
    <div id\="chatContainer" class\="chat-container"\>
        <div class\="loading"\>æ­£åœ¨åˆå§‹åŒ–å®¢æˆ·ç«¯...</div\>
    </div\>
    
    <div class\="input-container"\>
        <button id\="streamButton"\>ğŸš€ å¯åŠ¨å®æ—¶æ¨é€</button\>
        <button id\="stopStreamButton" style\="display: none;"\>â¹ï¸ åœæ­¢æ¨é€</button\>
        <button id\="clearButton"\>ğŸ—‘ï¸ æ¸…ç©ºæ¶ˆæ¯</button\>
    </div\>

    <!-- å¼•å…¥ä¾èµ–åº“ \-->
    <script src\="https://unpkg.com/google-protobuf@3.21.2/google-protobuf.js"\></script\>
    
    <!-- æœ¬åœ°gRPC-Webå…¼å®¹å±‚ \-->
    <script src\="./grpc-web-shim.js"\></script\>
    
    <!-- æµè§ˆå™¨å…¼å®¹çš„gRPC-Webæ–‡ä»¶ \-->
    <script src\="./generated/chat\_pb\_browser.js"\></script\>
    <script src\="./generated/chat\_grpc\_web\_pb\_browser.js"\></script\>
    
    <!-- ä¸»è¦å®¢æˆ·ç«¯è„šæœ¬ \-->
    <script src\="./client.js"\></script\>
</body\>
</html\>

ç›´æ¥åŒå‡»index.html,æˆ–è€…é€šè¿‡http.serverå¯åŠ¨æœåŠ¡å°±èƒ½æ„‰å¿«çš„æ¥æ”¶æ¨é€çš„å®æ—¶æ•°æ®äº†

è·Ÿå…¶ä»–æ¨é€é€ç›¸æ¯”ï¼Œç±»å‹å®‰å…¨ï¼Œæ€§èƒ½é«˜ï¼Œå‹ç¼©ä¼ è¾“ç­‰ç­‰ï¼Œä½†æ˜¯å‰ç«¯æ”¯æŒç›¸å¯¹æ²¡é‚£ä¹ˆå‹å¥½ã€‚

[![Fork me on GitHub](https://github.blog/wp-content/uploads/2008/12/forkme_left_darkblue_121621.png?resize=149%2C149)](https://github.com/liuzhixin405)