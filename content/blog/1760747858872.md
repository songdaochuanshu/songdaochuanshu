---
layout: post
title: 'ysyx学习：移植rt-thread'
date: "2025-10-18T00:37:38Z"
---
ysyx学习：移植rt-thread
==================

**OS中的上下文切换**

上一期我们搞懂了`yield-os.c`的原理如何，我们理解 玩上下文切换的核心细节之后，我们可以把这些原理迁移到RT-Thread这个更大的操作系统中。  
RT-Thread中有两个抽象层, 一个是BSP(Board Support Package), 另一个是libcpu。

负责把 RT-Thread 的线程结构（PCB）和抽象机器（AM）的上下文切换接口连接起来：调用处把目标/来源上下文地址临时放到线程的 user\_data，触发 yield()，AM 回调读出这些信息并完成实际的上下文切换；另外还准备线程首次运行时的栈/参数（通过 kcontext）。

对于上下文的创建，需要先实现`rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit)`函数。

    rt_uint8_t* rt_hw_stack_init(void* tentry, void* parameter, rt_uint8_t* stack_addr, void* texit) {
    
        stack_addr = (rt_uint8_t*)(((uintptr_t)stack_addr + sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1));
    
        stack_addr -= sizeof(temp_args); 
        temp_args* args = (temp_args*)stack_addr; // 在栈上保存 入口 参数 出口 等信息
    
        // 设置参数
        args->tentry = (void (*)(void*))tentry;   // tentry是“接受一个 void* 参数、返回 void 的函数指针”
        args->parameter = parameter;
        args->texit = (void (*)(void))texit;      // texit是“不接受参数、返回 void 的函数指针”
    
        rt_uint8_t* c = (rt_uint8_t*)kcontext((Area){ stack_addr - sizeof(Area) , stack_addr }, (void*)wrap, args);
    
        return c;
    }
    

一开始先对齐，然后拉出栈的位置，在栈上保存 入口 参数 出口 等信息，然后使用`kcontext`函数(详情见之前的随笔)，将控制状态寄存器`mepc`设置为函数的地址，当你执行mret指令的时候就会跳转到该函数中去，因此会跳转到wrap中，附带参数args。

这个`wrap()`函数如下,这个是包裹函数，讲义中提到`让包裹函数来调用tentry, 并在tentry返回后调用texit，T-Thread会保证代码不会从texit中返回`，因此我这个代码这么写。  
执行入口函数，并附带上参数，执行完之后执行退出函数。

    void wrap(temp_args* args) {
        args->tentry(args->parameter);
        args->texit();
    
        // 不应该执行于此，RT-Thread会保证代码不会从texit中返回
        while (1);
    }
    

接下来来看`main`函数，`main`函数代码如下：

    int main() {
      ioe_init();
    #ifdef __ISA_NATIVE__
      // trigger the real initialization of IOE to
      // perform SDL initialization int this main thread with large stack
      io_read(AM_TIMER_CONFIG);
    #endif
      extern void __am_cte_init();
      __am_cte_init();
      extern int entry(void);
      entry();
      return 0;
    }
    

先初始化一下ioe外设，在调用`__am_cte_init()`函数初始化cte。

    void __am_cte_init() {
      cte_init(ev_handler); 
    } 
    

意思就是把`__am_asm_trap`赋值给mtvec，方便后面ecall的时候直接跳进去`__am_asm_trap`函数。  
然后把`ev_handler`函数注册进回调函数中。

`ev_handler`函数如下：定义一个当前的线程，可以通过`rt_thread_self()`这个函数获取当前线程，再使用这个线程中的`user_data`，可以用`current->user_data`来使用他，为什么用这个呢，因为这个`user_data`它用于存放线程的私有数据, 这意味着RT-Thread中调度相关的代码必定不会使用这个成员, 因此它很适合我们用来传递`from`和`to`的信息，这里的`from`是当前线程，这个`to`是你要跳往的线程，这里的`ev_handler`是回调函数，当系统陷入`yield`的时候，执行完一些列操作(看以前的随笔)后会执行这个回调函数了。这个函数主要作用就是把当前上下文保存到`from`中然后利用`to`作为下一个上下文进行跳转。

    static Context* ev_handler(Event e, Context* c) {
        rt_thread_t current;
        rt_ubase_t* para;
    
        switch (e.event) {
            case EVENT_YIELD:
                current = rt_thread_self();
                para = (rt_ubase_t*)current->user_data;
    
                rt_ubase_t from = para[0];
                rt_ubase_t to = para[1];
    
                if (from) {
                    *((Context**)from) = c; //保存上下文到from中
                }
                c = *(Context**)to;  // 返回to作为下一个上下文
                break;
            case EVENT_IRQ_TIMER:
                return c;
            default:
                printf("Unhandled event ID = %d\n", e.event);
                assert(0);
        }
    
        return c;
    }
    

具体怎么上下文的切换呢，看这两个函数`void rt_hw_context_switch_to(rt_ubase_t to)`//切换到to的上下文  
`void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to)`//切换到to的上下文，又要保存当前上下文到from上。

    void rt_hw_context_switch_to(rt_ubase_t to) {
        rt_ubase_t data[2];
        rt_thread_t current = rt_thread_self();
        rt_ubase_t temp_ud = current->user_data;   //保存原来的 from 和 to
    
        data[1] = to;
        current->user_data = (rt_ubase_t)data;
        
        yield();
    
        current->user_data = temp_ud;
    }
    

    void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to) {
        rt_ubase_t data[2];
        rt_thread_t current = rt_thread_self();
        rt_ubase_t temp_ud = current->user_data;   //保存原来的 from 和 to
    
        data[0] = from;
        data[1] = to;
    
        current->user_data = (rt_ubase_t)data;
    
        yield();
    
        current->user_data = temp_ud;
    }
    

这两个函数实现起来基本差不多，使用刚刚的`user_data`保存完`from`和`to`之后将，切换线程，然后切换完之后再将原先的`user_data`数据还回去。

然后启动rt-thread，成功！！！

但是很奇怪，我每次输入完一行命令，下次那一行命令会多一个`/>`，之前貌似不会，不知道改了什么之后就会了。