---
layout: post
title: 'spring-事务管理'
date: "2026-02-11T01:06:48Z"
---
spring-事务管理
===========

事务支持
====

什么是事务？
------

在一个业务流程中，需要多条DML（insert、delete、update）语句联合才能完成。这些语句必须同时成功或者同时失败。这样才能保证数据安全。

多条DML同时成功或者同时失败，叫做事务。

### 事务处理的四个过程

1.  开启事务
2.  执行业务代码
3.  提交事务（没出现异常，提交成功。commit transaction）
4.  回滚事务（出现异常。执行回滚事务. rollback transaction）

### 事务的四个特性（ACID）

1.  A原子性：事务是最小的工作单元，不可分
2.  C一致性：事务要么同时成功，要么同时失败
3.  I隔离性：事务与事务之间保证和互不干扰
4.  D持久性：持久性是事务结束的标志。

spring对事务的支持
------------

spring实现事务的2种方式：

1.  编程式事务：通过编写代码的方式来实现事务管理
2.  声明式事务：基于注解方式和基于xml方式（推荐使用）

### spring事务管理api

spring对事务的管理是基于aop实现的。所以spring专门针对事务开发了一套api，其核心接口如下：PlatformTransactionManager 接口。

### 声明式事务基于注解方式实现

需要配置xml文件

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xmlns:tx="http://www.springframework.org/schema/tx"
           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                               http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd" >
    
    <!--    组件扫描-->
        <context:component-scan base-package="com.ali" />
    
    <!--    配置数据源-->
        <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
            <property name="url" value="jdbc:mysql://localhost:3306/bank"/>
            <property name="username" value="root"/>
            <property name="password" value="123456"/>
            <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        </bean>
    <!--    配置jdbcTemplate-->
        <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
            <property name="dataSource" ref="dataSource"/>
        </bean>
    
    <!--    配置事务管理器-->
        <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
            <property name="dataSource" ref="dataSource"/>
        </bean>
    <!--    开启事务注解驱动器，开启事务注解，需要加上tx的命名空间-->
        <tx:annotation-driven transaction-manager="transactionManager"/>
    </beans>
    

可以在类和方法上加@Transactional 开启事务

*   加在类上表示这个类上的所有方法都开启事务
*   加在方法方法上表示只有这个方法开启事务

### 事务的传播行为

什么是事务的传播行为？

在service种有a（）和b（）2个方法，a（）上有事务，b（）上也有事务，当a（）在执行过程中调用了b（），事务是如何传递的？是合并到一个事务？还是开启一个新事务？这就是事务的传播行为。

一共有7种传播行为：

1.  REQUIRD:支持当前事务，如果不存在就新建一个事务（默认）【没有就新建，有就加入】
2.  SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行【有就加入，没有就不管了】
3.  MANDATORY：必须运行在一个事务中，如果当前没有事务发生，将抛出异常【有就加入，没有就抛异常】
4.  REQUIRES\_NEW：开启一个新事务，如果一个事务已经存在，则将这个存在的事务挂起【不管有没有。直接开启一个新事务。新事务和旧事务不存在嵌套关系，旧事务被挂起了】
5.  NOT\_SUPPORTED：以非事务方式运行。如果有事务。则挂起当前事务【不支持事务，存在就挂起】
6.  NEVER：以非事务方式运行。如果有事务。则抛异常【不支持事务，存在就抛异常】
7.  NESTED：如果当前有一个事务在进行中，则该方法应当运行在一个嵌套事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在。行为就像REQUIRD一样【有事务的话，就在这个事务里嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRD一样】

在代码中设置事务的传播行为：

    @Transactional(propagation = Propagation.MANDATORY)
    

### 事务隔离级别

数据库中读取数据存在三大问题：

1.  脏读：读取到没有提交到数据库的数据
2.  不可重复读：在同一个事务中，第一次和第二次读取的数据不一样
3.  幻读：读到的数据是假的（）

事务的隔离级别有4个：

1.  读未提交READ\_UNCOMMITTED： 存在脏读、不可重复读、幻读问题
2.  读提交READ\_COMMITTED：事务提交之后才读到。存在不可重复读、幻读问题
3.  可重复读REPEATABLE\_READ：解决不可重复读的问题，存在幻读问题
4.  序列化SERIALIZABLE：解决幻读问题，事务排队执行。不支持并发。

**MySQL默认可重复读，Oracle默认读提交**

仅在读的事务中设置隔离级别就行，写的事务没必要设置

代码中设置事务的隔离级别：

    @Transactional(isolation = Isolation.DEFAULT)
    

### 事务超时

    @Transactional(timeout = 10)
    

以上代码设置事务超时时间为10s

表示超过10s，如果事务中所有的DML语句还没有执行完毕的话，最终结果会回滚。

默认值-1，表示没有时间限制。

**事务的超时时间值得是哪段时间？**

在当前事务中，最后一条DML语句执行之前的时间，如果最后一条DML语句后面有很多业务逻辑，这些业务代码执行的时间不被计入超时时间。

### 只读事务

    @Transactional(readOnly = true)
    

将当前事务设为只读事务，在该事务中只允许执行select 语句。

该特性的作用是：启动spring的优化策略。提高select语句的执行效率。

### 设置哪些异常回滚事务

    @Transactional(rollbackFor = RuntimeException.class)
    

表示发生RuntimeException异常或该异常的子类异常才回滚

### 设置哪些异常不回滚事务

    @Transactional(noRollbackFor = NullPointerException.class)
    

表示发生NullPointerException异常或该异常的子类不回滚，其他异常才回滚

### 事务的全注解式开发

编写配置类

    @Configuration // 代替xml配置文件
    @ComponentScan("com.ali") // 扫描com.ali包下的所有类
    @EnableTransactionManagement // 开启事务管理
    public class Spring6Config {
    
        // @Bean注解用于将方法的返回值注册为Spring容器中的一个Bean
        @Bean(name = "druidDataSource")
        public DruidDataSource druidDataSource() {
            DruidDataSource druidDataSource = new DruidDataSource();
            druidDataSource.setUrl("jdbc:mysql://localhost:3306/spring6?useSSL=false&serverTimezone=UTC");
            druidDataSource.setUsername("root");
            druidDataSource.setDriverClassName("com.mysql.jdbc.Driver");
            druidDataSource.setPassword("123456");
            return druidDataSource;
        }
    
        @Bean(name = "transactionManager")
        public DataSourceTransactionManager transactionManager(DataSource dataSource) {
            DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();
            transactionManager.setDataSource(dataSource);
            return transactionManager;
        }
    
        @Bean(name = "jdbcTemplate")
        // 该方法的参数DataSource dataSource会自动从Spring容器中找到类型为DataSource的Bean并注入
        public JdbcTemplate jdbcTemplate(DataSource dataSource) {
            JdbcTemplate jdbcTemplate = new JdbcTemplate();
            jdbcTemplate.setDataSource(dataSource);
            return jdbcTemplate;
        }
    }
    

使用时和其他方式一样。

本文来自博客园，作者：[NE\_STOP](https://www.cnblogs.com/alineverstop/)，转载请注明原文链接：[https://www.cnblogs.com/alineverstop/p/19598826](https://www.cnblogs.com/alineverstop/p/19598826)