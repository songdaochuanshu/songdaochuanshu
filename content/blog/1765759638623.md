---
layout: post
title: '解密Prompt系列66. 视觉Token爆炸→DeepSeek-OCR光学压缩'
date: "2025-12-15T00:47:18Z"
---
解密Prompt系列66. 视觉Token爆炸→DeepSeek-OCR光学压缩
========================================

![解密Prompt系列66. 视觉Token爆炸→DeepSeek-OCR光学压缩](https://img2024.cnblogs.com/blog/1326688/202512/1326688-20251212083748282-299130263.png) 很多人认为：图像Token的信息密度和效率远不如文本。但 DeepSeek-OCR的核心价值就是它通过一套巧妙的\*串行视觉压缩架构\*，实现1个视觉Token近乎无损地承载10个文本Token的惊人效率。本文我们借着DeepSeek-OCR回顾下多模态的底层技术演进。

借着 DeepSeek-OCR这篇论文，本章我们来回顾下多模态大模型（VLM）的核心技术演进。

很多人认为：图像Token的信息密度和效率远不如文本。但 DeepSeek-OCR的核心价值，就是用实践证明了这是一个伪命题。它通过一套巧妙的_串行视觉压缩架构_，实现1个视觉Token近乎无损地承载10个文本Token的惊人效率。

下面我们沿着 \\(O(N^2)\\) 危机 \\(\\rightarrow\\) 结构感知 \\(\\rightarrow\\) 语义对齐 的路径，来梳理这背后的技术基石。

Part I：多模态基石的构建与 \\(O(N^2)\\) 危机
--------------------------------

我们先来回顾下多模态模型的技术基石，我们将按照模型结构->多模态对齐->指令生成这条路径进行深入。

### ViT: 图像的 BERT 化与 \\(O(N^2)\\) 的起点

> *   Google: AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE

💡 ViT的本质像是图像领域的Bert，只不过把文字token转换成了图像的像素块。在ViT出现之前，图像领域清一色使用CNN、ResNET，强调各种图片特征提取例如平移不变性，局部特征等等。但是ViT的出现，再一次证明大力出奇迹，只要数据量足够大，简单的Transformer Encoder胜过一切。

如果我们通过和NLP Transformer类比来认识ViT的话，整个模型结构会分成以下几个部分

1.  Tokenization  
    在文本中，句子被tokenize成token，作为模型的输入。在图像中，一个Height \* Width \* Channel大小的图像，会被分割成固定大小16_16的像素块（Patch）。如果图片的长宽是224_224，则模型的输入会有224_224/(16_16)=196个像素块。
    
2.  输入层  
    ViT的输入层包含两个部分
    

*   Patch Embedding:因为图像不像文本有可枚举的token，因此无法使用词典向量进行映射，所以ViT选择通过线性映射层（MLP）来把patch映射到固定的维度D。
*   Positional Encoding：和NLP相同，为了保留位置信息，ViT加入了1D的position embedding（2D经试验没有效果提升，因为大量数据会让模型在一维关系中学习到空间特征）
*   Class Head：和BERT相同，ViT也加入了一个可学习的全局token，用于表征图片的整体信息。

3.  中间层  
    中间层就是传统的Transformer结构了，通过交替的多头注意力，MLP线性映射层和LayerNorm归一化层。
    
4.  训练策略  
    考虑论文本身就是为了证明训练数据的Scaling战胜一切，因此在训练策略上也做了很相近的消融策略，包括
    

*   **数据量试验**：在Image-Net这种1M左右的小数据上效果弱于ResNet，但是当在300M+的数据上进行训练时，效果全面超越CNN
*   **分辨率试验**：在低分辨率预训练，在高分辨率微调。其实和现在长上文的NLP模型训练思路一致，在预训练输出长度较短，在post-train阶段在渐进式增长。
*   **位置编码实验**：为了适配上面分辨率增长的问题，ViT在固定位置便马上进行差值
*   **训练超参**：使用Adam，低正则参数（数据量足够大很少过拟合）

VIT在后面任务中面临最大的问题就是\\(O(N^2)\\)的视觉token膨胀，随着输入图片分辨率的变大，当输入1024\*1024高分辨率图片时，输入token数将高达4096。

### VIT-DET：解决\\(O(N^2)\\)的局部注意力方案

> *   Meta: Exploring plain vision transformer backbones for object detection

💡 ViTDet 解决了 Plain ViT 无法用于高分辨率密集预测（如检测、分割、OCR）的痛点，其解决方案与 NLP 领域的 Longformer 思路高度相似：局部窗口 Attention + 稀疏全局连接。

1.  窗口注意力机制  
    将高分辨率图像划分成14 \*14或者16 \* 16的块，内部进行Attention，这样不论输入的图像像素如何变化，在Self-Attention层的计算复杂度都是恒定不会变化的。这样每个图像patch只关注它所在窗口内的相邻patch。这也是后面DeepSeek-OCR能处理高分辨率图像的技术基础。
    
2.  稀疏全局 Attention 层  
    那局部Attention肯定要配合全局Attention能力，才能让block之间的信息互通。VIT-DET在网络中插入了4个标准的全局Attention层，例如如果整个VIT有24层，则每6层插入一个全局层，这样保证全局信息交互只在有限层进行，用于在保证显存和计算成本可控的前提下，兼顾全局信息的共享。
    

### Segment Anything Model：图像分割领域的 GPT-3

> *   Meta：Segment Anything
> *   Meta: Exploring Plain Vision Transformer Backbones for Object Detection

💡 SAM是一个支持Prompt Engineering的生成式模型，但生成的不是token而是mask。它引入了promptable segmentation任务，给模型一个提示（点、框、文本），模型负责切割对应的物体。为DeepSeek-OCR提供了感知图片结构和几何的模型基础。

如上图所示，SAM模型包含三个组成部分

*   **Image Encoder**：使用MAE预训练的VIT模型，作为强大的特征提取器提取每张图片的Embedding。MAE类似NLP里面BERT的训练方式，BERT是完形填空，MAE是遮掩部分图片进行重构还原。
*   **Prompt Encoder**：这里的图像分割指令有两种
    *   **Sparse**：包含points（用户点中了图像中的某个物体）和boxes（用户框柱了图像的一个矩形区域）。分别用单个坐标和左上右下两个坐标点，使用可训练的位置编码表征。
    *   **Dense**：文本描述，例如一把黑色的剪刀。使用预训练CLIP的Text Encodier
*   **Mask Decoder**：轻量的Transformer Decoder，简单解释Image Embedding就是Key/Value, Prompt Embedding是Query，通过cross-Attention去图像里面捞出对应的像素区域，使用输出头在整个图片上进行分类预测，预测每个位置是否应该被Mask。

同时为了解决Prompt Ambiguity的问题，例如如果用户点击了T恤，那用户究竟是想分割人？还是想分割T恤？论文提出了同时预测3个MASK的方案，同时预测多个可能的分割掩码结果，并用模型置信度打分选择最优可能的一个进训练，类似NLP模型的Beam-Search。

### CLIP：视觉与文本的“罗塞塔石碑”

> *   OpenAI: Learning Transferable Visual Models From Natural Language Supervision

💡 CLIP本质就是一个Dual-Encoder对齐模型，可以类比NLP领域的SimCSE。通过InfoNCE Loss进行大规模对比学习，把文本和图像映射到同一个向量空间。被当前多模态太模型提供了核心的模态对齐能力。

感觉直接看qseudo code比看图来的更清晰，整个CLIP的训练过程如下

    # extract feature representations of each modality
    I_f = image_encoder(I) #[n, d_i]
    T_f = text_encoder(T) #[n, d_t]
    # joint multimodal embedding [n, d_e]
    I_e = l2_normalize(np.dot(I_f, W_i), axis=1)
    T_e = l2_normalize(np.dot(T_f, W_t), axis=1)
    # scaled pairwise cosine similarities [n, n]
    logits = np.dot(I_e, T_e.T) * np.exp(t)
    # symmetric loss function
    labels = np.arange(n)
    loss_i = cross_entropy_loss(logits, labels, axis=0)
    loss_t = cross_entropy_loss(logits, labels, axis=1)
    loss = (loss_i + loss_t)/2
    

1.  多模态映射: 选取对应模态的预训练模型来对不同模态的输入进行特征提取

*   Text encoder: CBOW或者Bert，N\*I -> N \* L \* D
*   image encoder：ViT或者Resnet， N_H_W\*C -> N \* L \* D
*   再通过线性投影层，把不同模态的向量维度映射到相同的维度空间

2.  对比训练

训练策略是通过Batch Contrastive Loss进行的，每个样本都有图片和对应的文字描述构成，因此一个batch内文本表征和图片表征的叉乘矩阵，应该只有对角线的相似度最高为正样本，其余都为负样本。

之所以选择InfoNCE，而非传统的Image Caption预测，因为论文发现这种训练方式模型收敛很慢，毕竟一个图片其实有无数种语言的描述方案，只让模型精准预测其中一种描述本身就不合理。而直接对齐高维向量表征的训练效率显著更高

3.  样本构建

图片和对应的文字描述样本集总共4亿条，为了保证图片概念的覆盖率，论文采用了搜索进行构建，先构建query集，再通过搜索构建(image,text) pair对。

4.  模型使用

使用以上对比训练得到的图像和文本Encoder，可以在两个领域之间进行零样本的知识迁移，类比GPT3水平的zero-shot，可以通过提示词“Transfer English to French”实现指令理解。CLIP训练过的图文Encoder同样可以，例如你要对象进行分类，只需要把1000个标签填入“A photo of {label}”，然后用Text Encoder进行编码，再计算和图像Encoder相似度最高的文本向量，就是该图片的分类了。

CLIP不仅为图像和文本模态对齐提供了思路，同时也是较早关注图像领域zero-shot开放域迁移的。

Part II：DeepSeek-OCR 的核心贡献：光学压缩秘籍
---------------------------------

> *   DeepSeek-OCR: Contexts Optical Compression

DeepSeek-OCR的核心亮点在于它提出了一个革命性的观点：**通过高分辨率图像渲染 + 专用压缩架构，可以将长文本内容压缩成数量更少的视觉 Token，从而为LLM 的长上下文难题提供新的压缩思路。**

OCR其实只是一个实验场景，论文核心要回答的是“一张包含 1000 个单词的图片，到底最少需要多少个 Visual Token 才能让 LLM 完美还原出这 1000 个词？”

### 串行压缩的 DeepEncoder 架构

DeepSeek-OCR 的 DeepEncoder 仅有 380M 参数，但通过巧妙的**串行（Serial）**结构，完美平衡了“高分辨率”与“低 Token 数”的需求。

1.  **80M SAM预训练VIT-DET**

通过window-Attention，能在高分辨率图像下保持相对较低的显存占用，负责图片核心的结构特征提取。

2.  **两层16\*16CNN Compressor**

用于对SAM输出的图像特征进一步降采样，降低激活率，是DeepSeek-OCR高保真，极高压缩率的核心。

3.  **300M CLIP预训练VIT-Large**

移除了首层的Embedding层，因为输入从图片变成了CNN降采样后的图像向量，采用全局注意力机制，对CNN降采样后的视觉Token进行全局语义的整合。

虽然都是VIT模型结构，但DeepSeek-OCR的组合方式大有学问。前面我们提到SAM本身的训练目标是边缘检测，因此预训练后的模型对于几何结构、笔画边界、布局线条有更强的捕捉能力，所以使用SAM预训练模型作为OCR的特征提取器再合适不过。而使用CLIP作为后端，接受经过压缩的视觉特征自然是使用CLIP本身和文本语义对齐的特性，把SAM提取的结构特征，站在全局视角翻译成包含语音信息Latent Tokens，用于后续解码器的解码。

用SAM“看清”，用CLIP“看懂”之后，最后就到解码器“讲给我听”，论文使用了DeepSeek-3B-MOE，总参数是3B，但推理时每个token只激活64个专家中的6个，对应570M左右的参数。之所以选择MOE，也是充分考虑到OCR任务本身的多元性，涉及到多语音、多符号（公式、图表）、多排版，而MOE可以根据输入的不同，选择不同的专家进行解码。

而之所以没有像Qwen使用位置编码，因为DeepSeek-OCR还是个单任务模型，因此只需要模型在训练过程中学习和原图图像token信息一一对应的文本token信息，那SAM的局部信息提取，加上从左到右，从上到下固定的token拼接顺序，再配合CLIP的全局语义理解（这是一个三栏排列还是个单栏报纸），其实就完全足够了。

### 动态分辨率

为了适配不同的下游图片尺寸，DeepSeek-OCR对于动态多分辨率设计了两种方案。这里借鉴了InternVL1.5提出的tiling思路。

1.  **Native Resolution**

论文预定义了四种分辨率Tiny(512)，Small(640), Base(1024), Large(1280)。输入图片会保持原有的长宽比，把短边padding到最近的分辨率。

2.  **Gundam Mode**

主要针对超高分辨率的长图（例如报纸，在我的场景中是收集拍照或截图的长图）。这时会采用多分辨率组图，类似NLP中的chunking逻辑。包括

*   Global View：把全图reszie到1024 \* 1024，提供全局上下文
*   Local View：将大图切分成多个640\*640的图片快，提供局部视野。这里使用了InternVL提供的tiling方案。

这样通过Gloabl+Local的方案，让模型既能获取全局排版，也能看清局部小字。

### 模型训练

DeepSeek-OCR收集处理了海量的相关语料，大致涵盖以下三个方向

*   OCR 1.0: 30M的PDF文档，有直接用pymuPDF提取的粗标样本，也有用MinerU、GOT-OCR精标的样本，还有用word反向构建的合成数据来保证公式与表格的准确。注意这里不同质量的样本在训练时会配合使用不同的指令来实现带噪学习。
*   OCR 2.0: 主要覆盖图表、公式、化学方程式等结构化数据。其中包括使用image-to-HTML构建得到的数据。
*   通用文本和图像：保证Decoder和CLIP Encoder的通用文本和图像能力的灾难性遗忘

使用以上数据论文进行了两阶段的模型训练

*   DeepEncoder预热训练：让编码器输出高质量图像Token，有点类似先训练embedding层
*   Encoder+Decoder联合训练：把Encoder模块中的SAM和Compressor参数都冻结，只保留CLIP可训练用于和Decoder的文本表征进行对齐。

### 核心发现：上下文光学压缩的 Scaling Law

通过在 OCR 任务上的实验，DeepSeek-OCR 得到了关于视觉信息密度最关键的结论，为 LLM 的长期记忆和遗忘机制提供了新的理论依据。

*   **10\*无损压缩**，既当文本token/视觉token<10，COR的解码精准度可以保持在97%+。
*   **20\*优雅遗忘**，既当文本token/视觉token=20，OCR的解码准确率仍有60%没有完全遗忘。

第一个结论其实是反常识的，之前普遍认为图像token的信息密度更低，但其实这是对不同体裁图片的差异化认知导致的。而论文论证在当前的文本tokenizer的效果上，视觉模态可以成文文本模态的超级压缩格式。

而第二个结论其实和超长上文的记忆压缩机制相契合，对于超长文档的问答，是有可能通过图像token进行信息压缩，只保留核心语义信息。

Part III：横向对比：多模态 VLM 的不同路线
---------------------------

> *   Vary: Scaling up the Vision Vocabulary for Large Vision-Language Models
> *   Qwen2-vl: Enhancing vision-language model’s perception of the world at any resolution.
> *   InterVL 1.5: How Far Are We to GPT-4V? Closing the Gap to Commercial Multimodal Models with Open-Source Suites

最后，我们通过一张表，清晰地对比 DeepSeek-OCR 与其他主流 VLLM 在处理高分辨率和 Token 效率上的技术路线差异。

模型

核心 Token 策略

架构拓扑

关键技术

优势与劣势

借鉴

DeepSeek-OCR

串行压缩 (Token Deflation)

SAM → Conv → CLIP ViT → LLM

ViTDet (Window Attn) + 16x Conv Compressor

**优势**：Token压缩率最高，推理效率最高；在文档领域实现 1:10 无损压缩。

Qwen2-VL

线性增长 (Token Inflation)

ViT → Pooling → LLM

Naive Dynamic Resolution + M-RoPE (3D 位置编码)

**优势**：保真度高，位置感知优秀；  
**劣势**：Token 数量随分辨率线性增长，推理昂贵。

不用通用位置编码而借助物理压缩

InternVL2

Tiling

InternViT (6B) → QLLaMA (8B) → LLM

巨型 ViT Encoder + LLaMA-based Adapter

**优势**：视觉基座能力强；  
**劣势**：整体参数量巨大，输入VIT分辨率低导致图像分割碎片化，token数过高、推理成本极高。

借鉴tiling

Vary

并行词表扩充

CLIP、SAM+Conv → Concat Fusion → LLM

SAM-based Tiny Vocabulary + Parallel Dual-Branch

**优势**：增强文档理解；  
**劣势**：并行结构显存占用大，Token 数量是两者之和，计算冗余。

借鉴Conv压缩，把Vary并行架构改为串行