---
layout: post
title: '探秘 AgentRun｜基于 Serverless 的 AI Agent 沙箱工程化之路'
date: "2026-01-23T00:46:56Z"
---
探秘 AgentRun｜基于 Serverless 的 AI Agent 沙箱工程化之路
============================================

阿里云函数计算 AgentRun 全新发布后，我们整理了“探秘 AgentRun”系列文章，本系列将梳理企业落地Agent 常见难题，给出具体解法，助力 Agentic AI 快速走进生产级环境。欢迎加入“函数计算 AgentRun 客户群”与我们交流，钉钉群号：134570017218。

AI Agent 时代的沙箱需求
----------------

### 从 Copilot 到 Agent：执行能力的质变

在生成式 AI 的早期阶段，应用主要以“Copilot”形式存在，AI 仅作为辅助生成建议。然而，随着 AutoGPT、BabyAGI 以及 OpenAI Code Interpreter（现为 Advanced Data Analysis）的出现，AI 开始扮演“Agent”的角色。Agent 被赋予了目标，并能自主规划步骤、使用工具来达成目标。

这种质变的核心在于**代码执行（Code Execution）**。为了回答“分析这层楼的销售数据并绘制趋势图”这样的请求，LLM 不再只是生成一段 Python 代码文本，而是需要在一个真实的 Python 环境中运行这段代码，并获取绘图结果。同样，为了“帮我预订一张去东京的机票”，Agent 可能需要在一个无头浏览器（Headless Browser）中模拟用户点击。

### 不可信代码的安全隐患

当 LLM 生成代码并执行时，这段代码在本质上是**不可信的（Untrusted）**。如果直接在应用服务器或用户的本地设备上运行，将面临灾难性的安全风险：

*   **系统破坏**：AI 生成的代码可能无意或恶意地包含 rm -rf / 等破坏性指令，或者修改关键系统配置文件。
*   **数据泄露**：代码可能尝试读取环境变量中的 API Key，或者扫描内网数据库，将敏感数据发送到外部服务器。
*   **资源耗尽**：死循环或内存泄漏代码可能导致宿主机崩溃，影响其他租户的服务。
*   **网络攻击**：恶意 Prompt 注入（Prompt Injection）可能诱导 AI 将执行环境作为跳板（Jump Box），对内部网络发起 DDoS 攻击或端口扫描。

### Agent 场景面临的独特挑战

除了基础的安全性，AI Agent 的交互特性还给沙箱环境带来了前所未有的工程挑战，这也是传统沙箱（如简单的 Docker 容器或虚拟机）难以应对的：

*   **状态保持**：与传统的“请求-响应”模式不同，Agent 往往需要进行多轮对话。上一轮定义的变量（如 df = load\_data()）需要在下一轮（df.plot()）中继续可用。这就要求沙箱环境必须具备**上下文记忆能力**，而非每次请求都重置环境。
*   **极速启动**：用户无法忍受每次交互都等待数秒甚至数十秒的虚拟机启动时间。为了保证流畅的对话体验（Time to First Token），沙箱必须具备毫秒级的冷启动能力。
*   **环境依赖多样性**：不同的 Agent 任务可能需要完全不同的依赖库（如 Pandas、Scipy 用于数据分析，Puppeteer 用于网页操作）。沙箱需要支持灵活的自定义镜像或动态依赖加载，同时不能影响启动速度。
*   **资源成本控制**：Agent 的调用往往具有稀疏性和突发性（例如一天只用几次，但一次用很久）。长期运行独占的虚拟机（VM）成本高昂且资源利用率低，而传统的 FaaS 虽然便宜但往往缺乏状态保持能力。如何在低成本和高性能之间找到平衡点，是一个巨大的挑战。  
    因此，构建一个**沙箱**（Sandbox）——一个与宿主机、内网以及其他用户数据严格隔离，同时具备高性能、低成本、有状态的封闭执行环境——成为了 AI Agent 沙箱落地的前提条件。

AgentRun Sandbox：专为 Agent 设计的工程化方案
----------------------------------

为了解决上述挑战，我们推出了 **AgentRun Sandbox**。这是一个**以高代码为核心，开放生态、灵活组装**的一站式 Agentic AI 基础设施平台。

AgentRun 并非从零构建传统的虚拟机集群，而是**基于阿里云函数计算（FC）这一强大的 Serverless 底座构建**。通过充分利用 Serverless 的**按需付费、极致弹性以及免运维（NoOps）** 特性，AgentRun 解决了一直困扰沙箱领域的成本与效率难题，并在此基础上通过工程化封装，提供了面向 Agent 场景的专业能力。

### 为什么选择函数计算作为 Sandbox Infra

在构建 Agent 沙箱时，我们坚定地选择了函数计算（FC）作为底层基础设施，这主要基于以下核心优势的考量：

*   **强安全隔离**： 沙箱的核心诉求是安全。函数计算底层采用神龙裸金属与 RunD 安全容器技术，每个执行环境都运行在独立的 MicroVM 中。这种基于虚拟化技术的内核级隔离，相比传统的 Docker 容器隔离具有更高的安全性，能有效防止恶意代码逃逸，为不可信代码执行提供了坚实屏障。
*   **极致弹性与冷启动优化**： Agent 的调用往往具有突发性。函数计算具备毫秒级的弹性伸缩能力，结合 RunD 技术对启动速度的极致优化，使得沙箱能够在数秒甚至毫秒内完成创建和启动。这不仅满足了高并发场景下的需求，也保证了 Agent 交互的流畅性，避免了传统虚拟机启动慢带来的延迟感。
*   **成本效益**：自建虚拟机集群通常需要为峰值流量预留资源，导致低谷期资源浪费。函数计算采用按需付费（Pay-as-you-go）模式，且 AgentRun 利用了 FC 的空闲自动回收机制，真正做到了“有请求才计费”。对于稀疏调用的 Agent 场景，这种模式能显著降低基础设施成本。
*   **免运维**： 基于 Serverless 架构，开发者无需关心底层服务器的操作系统补丁、网络配置及集群维护。AgentRun 团队可以将精力集中在沙箱的核心逻辑与业务体验上，而非底层基础设施的繁琐运维。
*   **会话能力**：函数计算围绕 AI Agent Sandbox 场景推出了会话亲和、隔离以及管理能力。在一次会话生命周期内，相同会话的请求均会被亲和路由到同一个实例中，并独占该实例，保证了会话交互的连续性、上下文完整性以及多租安全性，同时提供完整的管理接口来主动对会话生命周期进行控制，降低了开发门槛。

### AgentRun 的核心运行机制

传统的 Serverless 通常是无状态的，难以满足 Code Interpreter 这类需要上下文保持的场景。AgentRun 借助函数计算的会话产品能力，在无状态的计算底座上构建了有状态、会话级的沙箱体验。

#### 1\. 沙箱请求亲和

AgentRun 允许开发者显式地创建一个具有生命周期的执行环境，解决了传统 Serverless“用完即走”导致的上下文丢失问题。

*   **会话亲和**：AgentRun 依赖函数计算会话亲和机制。当开发者创建沙箱后，AgentRun 会维护一个唯一的 SessionID。后续所有携带该 ID 的请求，都会被精准路由到同一个底层的计算实例。这意味着用户在第一步定义的 df = pd.read\_csv(...) 对象，在第二步 df.plot() 时依然存在于内存中，完美复刻本地开发体验。
    
*   **MCP 协议原生支持**：针对模型上下文协议（Model Context Protocol, MCP），AgentRun 提供了 MCP SSE 及 MCP Streamable HTTP 会话亲和支持。AgentRun 可以直接作为 MCP 网关，让 LLM 与外部工具的交互更加顺滑。
    

#### 2\. 多层次安全隔离

在多租户 SaaS 平台中，安全性是 AgentRun 的基石。

*   **计算隔离**：AgentRun 利用底层基础设施的神龙裸金属与 RunD 安全容器技术，确保每个沙箱实例在内核级别进行隔离。通过强制将会话并发度设置为 1，AgentRun 保证租户 A 的进程空间、内存数据与租户 B 物理分离，防止容器逃逸。
*   **网络隔离**：网络隔离完全由用户控制。用户可以根据安全需求灵活配置，选择开启或关闭沙箱的公网访问权限，或者将沙箱接入指定的 VPC 网络环境，从而在满足业务连通性的同时，防止恶意代码对内网发起攻击。

#### 3\. 灵活的生命周期控制

AgentRun 通过函数计算的会话能力，接管了底层计算资源的生命周期，为上层应用提供精细化管理：

*   **自动闲置回收（Idle Timeout）**：为了通过 Serverless 架构降低成本，AgentRun 支持设置空闲超时（例如 5 分钟）。如果 Agent 在这段时间内没有新指令，底层实例会自动销毁并停止计费，完美适配 AI 交互“突发性强、稀疏度高”的特点。
*   **状态暂停与恢复（即将上线）**：针对长时间的任务间歇，AgentRun 能够将沙箱的内存与磁盘状态快照保存，在用户回归时通过快照快速恢复现场，既节省成本又保留了上下文。

#### 4\. 会话粒度存储隔离（即将上线）

代码执行需要隔离，数据存储更需要隔离。AgentRun 创新性地规划了会话粒度存储粘性。

*   **动态绑定**：AgentRun 允许用户为每个沙箱环境中动态分配一个存储挂载点的专属子目录。
*   **逻辑沙箱**：通过底层的挂载技术，沙箱内部只能看到属于自己的 /workspace，物理上无法访问其他租户的文件（如 ../../tenant-b/secret.txt），从文件系统层面根除了数据交叉风险。

AgentRun 开箱即用的沙箱能力
------------------

AgentRun 不仅提供了底层隔离环境，还预置了经过工程化调优的标准化模版，让开发者开箱即用：

*   **Code Interpreter（代码解释器）**：预装 Python/Node.js/Java 等环境，支持文件上传下载、数据分析、图表绘制及命令行操作。
*   **Browser User（浏览器沙箱）**：提供基于 CDP over WebSocket 协议的浏览器环境，兼容 Puppeteer / Playwright，让 Agent 能够安全地访问互联网进行网页操作。
*   **All In One**：集成了代码解释器与浏览器环境的全能型沙箱，满足复杂 Agent 任务需求。  
    这些模版镜像具备高度的灵活性，AgentRun 未来将开放镜像定义，允许用户基于标准镜像定制私有依赖库或安全策略。

AgentRun 沙箱架构详解  

### AgentRun 网关

这是 AgentRun 的门户，负责接收来自 AI Agent（如 LangChain 应用、ChatGPT Plugin）的 HTTP 请求，除了标准的身份验证、鉴权以及协议转换（如将 HTTP 转为 WebSocket）之外，其核心能力便是沙箱管理以及沙箱请求路由的功能，它屏蔽了底层 Serverless 基础设施的复杂性，实现了如下能力：

*   **沙箱管理**：管理沙箱资源，维护业务层沙箱 ID 与底层计算资源 SessionID 的映射关系
*   **状态维护**：监控沙箱的活跃状态，基于沙箱超时配置以及底层资源情况及时对状态进行更新
*   **资源调度**：根据用户指定的计算规格（CPU、Memory），向底层申请相应的资源。

### 函数计算沙箱环境

主要由函数计算作为底层算力来承载沙箱的运行。AgentRun 利用函数计算提供的极致弹性能力，实现在分钟内启动成三万个独立的沙箱环境，每个环境都运行在独立的 MicroVM 中，搭配自研开箱即用的沙箱镜像模版，在功能以及性能上为用户提供了双重保障。

### 典型工作流：从指令到结果

以“用户让 Agent 根据上传的 Excel 文件绘制图表”为例，AgentRun 的工作流程如下。

#### 阶段一：模板创建

1.  用户请求：Agent 接收到用户指令后，由 LLM 决策使用 Python 来实现该需求。
2.  Agent 工具调用：AI Agent 会向 AgentRun 网关发送 Code Interpreter 沙箱模板的创建请求。
3.  模板创建：AgentRun 网关会调用函数计算接口创建一个 Code 沙箱模板函数，镜像配置为前文提到的自研 Code Interpreter 沙箱模板，该函数需要同时配置会话亲和以及会话隔离。

#### 阶段二：沙箱创建

1.  Agent 工具调用：模板创建完成后，Agent 继续进行沙箱创建，创建时传入已有的模板 ID，标识沙箱实例运行时的配置和镜像
2.  沙箱创建：AgentRun 收到沙箱创建请求后，会调用 FC 的 CreateSession 接口来创建一个沙箱实例，该沙箱会有一个合适的闲置超时时间，最长可存活 24h
3.  创建完成：AgentRun 会保存 FC 返回的会话 ID，并生成沙箱业务 ID 与之对应，最终将沙箱业务 ID 返回给用户

#### 阶段三：任务执行

1.  上传文件：Agent 通过 Code Interpreter 的文件上传接口，将 Excel 文件上传。若想将该文件持久化，可以在创建沙箱时配置持久化存储 NAS，将其挂到沙箱中，并将文件上传到 NAS 挂载的目录上。
2.  绘制图表：Agent 生成代码 import pandas as pd; df = pd.read\_excel('data.xlsx')，并调用 Code Interpreter 的 run\_code 接口执行代码。
3.  会话亲和：Agent 所有发往 Code Interpreter 的请求中，都必须带上对应的沙箱 ID 才能保证请求都路由到同一个沙箱实例。
4.  内存驻留：代码执行完毕，变量 df 驻留在内存中.
5.  二次代码执行：Agent 根据数据列名生成绘图代码 df.plot()。再次发送代码运行请求
6.  上下文复用：请求再次到达同一实例，直接使用内存中的 df 对象进行绘图，生成图片文件。
7.  结果回传：图片被写入 NAS，下载链接返回给 Agent。

#### 阶段四：资源销毁

1.  空闲检测：Agent 完成任务，不再发送请求。
2.  自动回收：达到 SessionIdleTimeout（如 5 分钟）后，函数计算会自动销毁该沙箱实例，此时除了持久化到 NAS 上的数据，其余环境相关数据均被销毁。
3.  文件回收：如果 NAS 上的文件是会话隔离的，当用户会话结束后，NAS 上文件需要进行主动或者定时自动清除。

#### 工作时序图

AgentRun 的核心设计原则
----------------

AgentRun 的工程化实践遵循以下五大核心原则，这构成了其安全、高效、可扩展的基石：

### 原则一：配置即代码

AgentRun 将沙箱环境定义（环境变量、资源规格、健康检查等）封装为标准化模版。这种设计实现了沙箱配置的版本化管理，使得 Agent 环境可以像代码一样进行复制和回滚。

### 原则二：会话即沙箱

AgentRun 将“会话”作为沙箱的唯一实体。通过 SessionID 绑定底层的计算实例与上下文状态，实现了真正的按需分配与状态保持。沙箱的创建与销毁完全独立于底层物理设施，对用户透明。

### 原则三：生命周期可编程

AgentRun 不仅提供创建（Create）和删除（Delete）接口，还引入了“暂停”、“恢复”和“自动超时”机制。这种可编程性让上层应用能根据业务价值最大化资源利用率，实现成本与性能的最优平衡。

### 原则四：网络接入标准化

AgentRun 抹平了底层网络的差异，提供标准化的 HTTP/WebSocket 接口，并支持 Server-Sent Events（SSE）。无论底层如何升级，上层 Agent 沙箱始终通过标准的 Header 或 Cookie 携带 SessionID 进行交互，降低了集成复杂度。

### 原则五：存储隔离细粒度化（即将上线）

AgentRun 不仅支持模版粒度的文件系统共享，同时也能够配置沙箱粒度目录级动态挂载。每个沙箱单独挂载一个目录，从根源上杜绝了多租户环境下的数据越权访问风险。

总结与展望
-----

AgentRun Sandbox 是 Serverless 技术在 AI Agent 领域的最佳工程化实践。

通过将阿里云函数计算（FC）在 **RunD 安全虚拟化**（解决隔离与启动速度）、**会话亲和性**（解决状态保持）以及 **动态 NAS 挂载**（解决数据隔离）等方面的底层技术创新，封装为面向业务的 AgentRun 平台，我们成功降低了企业构建 AI Agent 的门槛。

对于构建下一代智能体应用的企业而言，选择 AgentRun Sandbox 不仅是选择了一个沙箱工具，更是选择了一套兼顾安全性、用户体验与商业效率的弹性基础设施。未来，AgentRun Sandbox 将继续在启动延迟优化、状态秒级快照恢复以及更多样化的存储支持上深耕，致力于成为 AI Agent 时代最佳的沙箱基座。

立即体验函数计算 AgentRun
-----------------

函数计算 AgentRun 的无代码到高代码演进能力，现已开放体验：

**查看更多产品详情**：[https://www.aliyun.com/product/fc/agentrun](https://www.aliyun.com/product/fc/agentrun)

1.**快速创建**：访问控制台（[https://functionai.console.aliyun.com/cn-hangzhou/agent/explore](https://functionai.console.aliyun.com/cn-hangzhou/agent/explore))，60秒创建你的第一个 Agent

2.**深度定制**：当需要更复杂功能时，一键转换为高代码  
3.**持续演进**：利用函数计算 AgentRun 的基础设施能力，持续优化你的 Agent

从想法到上线，从原型到生产，函数计算 AgentRun 始终是你最好的伙伴。欢迎加入“函数计算 AgentRun 客户群”，钉钉群号：134570017218。

### 快速了解函数计算 AgentRun

一句话介绍：函数计算 AgentRun 是一个以高代码为核心的一站式 Agentic AI 基础设施平台。秉持生态开放和灵活组装的理念，为企业级 Agent 应用提供从开发、部署到运维的全生命周期管理。

函数计算 AgentRun 架构图

AgentRun 运行时基于阿里云函数计算 FC 构建，继承了 Serverless 计算极致弹性、按量付费、零运维的核心优势。通过深度集成 AgentScope、LangChain、RAGFlow、Mem0 等主流开源生态。函数计算 AgentRun 将 Serverless 的极致弹性、零运维和按量付费的特性与 AI 原生应用场景深度融合，助力企业实现成本与效率的极致优化，**平均 TCO 降低 60%**。

**让开发者只需专注于 Agent 的业务逻辑创新，无需关心底层基础设施，让 Agentic AI 真正进入企业生产环境。**