---
layout: post
title: 'Manim实现旋转扭曲特效'
date: "2025-10-08T00:39:18Z"
---
Manim实现旋转扭曲特效
=============

在数学动画制作中，特殊效果可以极大地增强视觉表现力和吸引力。

本文将介绍如何使用`Manim`框架实现一个**旋转扭曲**特效，通过自定义动画类来创建独特的视觉效果。

实现原理
====

**旋转扭曲**特效的核心是**通过修改对象上每个点的坐标**来实现扭曲效果。

在`Manim`中，我们可以通过继承`Animation`类并重写`interpolate_mobject`方法来创建自定义动画。

自定义动画类的结构
---------

    class TwistAnimation(Animation):
        def __init__(
            self,
            mobject,
            center=ORIGIN,
            twist_angle=TAU,
            strength=1.0,
            direction="clockwise",
            **kwargs
        ):
            super().__init__(mobject, **kwargs)
            
            # 存储初始状态以便在动画过程中重置
            self.center = center
            self.twist_angle = twist_angle
            self.strength = strength
            self.direction = direction
            
            # 根据方向调整扭曲角度
            if direction == "counterclockwise":
                self.twist_angle = -self.twist_angle
    

这个类定义了几个关键参数：

*   `mobject`：要进行扭曲的Manim对象
*   `center`：扭曲中心点，默认为原点
*   `twist_angle`：总扭曲角度，默认为TAU(360度)
*   `strength`：扭曲强度，默认为1.0
*   `direction`：扭曲方向，可以是"clockwise"(顺时针)或"counterclockwise"(逆时针)

扭曲算法的核心实现
---------

扭曲效果的核心在于`interpolate_mobject`方法，它在动画的每一帧被调用，根据当前的进度`alpha`更新对象的形状：

    def interpolate_mobject(self, alpha):
        # 重置对象到初始状态
        self.mobject.become(self.starting_mobject)
        
        # 计算当前的扭曲角度
        current_twist_angle = alpha * self.twist_angle
        
        # 获取对象的所有点
        points = self.mobject.points
        
        # 对每个点应用扭曲变换
        for i in range(len(points)):
            # 计算点相对于中心的位置
            point = points[i]
            rel_point = point - self.center
            
            # 计算点到中心的距离
            distance = np.linalg.norm(rel_point)
            
            # 如果点在中心，则不进行变换
            if distance == 0:
                continue
            
            # 计算点的极角
            angle = np.arctan2(rel_point[1], rel_point[0])
            
            # 计算扭曲后的角度：距离中心越远，扭曲角度越大
            twisted_angle = angle + current_twist_angle * (distance * self.strength)
            
            # 计算扭曲后的坐标
            twisted_x = self.center[0] + distance * np.cos(twisted_angle)
            twisted_y = self.center[1] + distance * np.sin(twisted_angle)
            
            # 更新点的位置
            points[i] = np.array([twisted_x, twisted_y, point[2]])
        
        # 将更新后的点应用到对象上
        self.mobject.set_points(points)
    

这个算法的**核心思想**是：

1.  将对象上的每个点转换为相对于扭曲中心的极坐标
2.  根据点到中心的距离计算扭曲角度（距离越远，扭曲越大）
3.  将扭曲后的极坐标转换回笛卡尔坐标
4.  更新对象上所有点的位置

这种实现方式使得扭曲效果非常自然，尤其是对于几何形状对象。

使用示例
====

代码中提供了三个示例场景，展示了如何使用这个扭曲特效。

基本扭曲效果
------

`Example01`类展示了基本的扭曲效果，包括顺时针和逆时针扭曲：

    class Example01(Scene):
        """基本的扭曲效果"""
        
        def construct(self):
            # 创建一个矩形作为扭曲对象
            rect = Rectangle(width=4, height=2, color=BLUE, fill_opacity=0.5)
            
            # 添加扭曲动画
            self.play(Create(rect))
            self.wait()
            self.play(TwistAnimation(rect, run_time=2))
            self.play(TwistAnimation(rect, twist_angle=-TAU, run_time=2))  # 反向扭曲
            self.wait()
    

这个示例创建了一个蓝色矩形，然后先应用顺时针扭曲，再应用逆时针扭曲。

![](https://img2024.cnblogs.com/blog/83005/202510/83005-20251007093803884-1342167556.gif)

不同扭曲中心的效果
---------

`Example02`类展示了使用不同扭曲中心的效果：

    class Example02(Scene):
        """不同扭曲中心的效果"""
        
        def construct(self):
            # 创建多个对象，并设置不同的扭曲中心
            circle1 = Circle(radius=0.8, color=RED, fill_opacity=0.5)
            circle1.shift(LEFT * 2)
            
            circle2 = Circle(radius=0.8, color=GREEN, fill_opacity=0.5)
            
            circle3 = Circle(radius=0.8, color=BLUE, fill_opacity=0.5)
            circle3.shift(RIGHT * 2)
            
            # 添加中心标记
            center_marker1 = Dot(color=WHITE).shift(LEFT * 3)
            center_marker3 = Dot(color=WHITE).shift(RIGHT * 3)
            
            # 添加对象到场景
            self.play(Create(circle1), Create(circle2), Create(circle3))
            self.play(Create(center_marker1), Create(center_marker3))
            self.wait()
            
            # 应用扭曲动画，使用不同的中心
            self.play(
                TwistAnimation(circle1, center=center_marker1.get_center(), run_time=2),
                TwistAnimation(circle2, center=ORIGIN, run_time=2),
                TwistAnimation(circle3, center=center_marker3.get_center(), run_time=2),
            )
            self.wait()
    

这个示例创建了**三个**不同颜色的圆，并分别使用不同的中心点进行扭曲，直观地展示了扭曲中心对效果的影响。

![](https://img2024.cnblogs.com/blog/83005/202510/83005-20251007093803868-235302615.gif)

不同扭曲强度的效果
---------

`Example03`类展示了使用不同扭曲强度的效果：

    class Example03(Scene):
        """演示不同扭曲强度的效果"""
        
        def construct(self):
            # 创建多个对象，并设置不同的扭曲强度
            square1 = Square(side_length=1.5, color=YELLOW, fill_opacity=0.5)
            square1.shift(LEFT * 2)
            
            square2 = Square(side_length=1.5, color=MAROON, fill_opacity=0.5)
            
            square3 = Square(side_length=1.5, color=TEAL, fill_opacity=0.5)
            square3.shift(RIGHT * 2)
            
            # 添加对象到场景
            self.play(Create(square1), Create(square2), Create(square3))
            self.wait()
            
            # 应用扭曲动画，使用不同的强度
            self.play(
                TwistAnimation(square1, strength=0.5, run_time=2),
                TwistAnimation(square2, strength=1.0, run_time=2),
                TwistAnimation(square3, strength=2.0, run_time=2),
            )
            self.wait()
    

这个示例创建了**三个**不同颜色的正方形，并分别应用不同强度的扭曲，展示了扭曲强度对效果的影响。

![](https://img2024.cnblogs.com/blog/83005/202510/83005-20251007093803903-689122922.gif)

总结
==

特效特点
----

这个旋转扭曲特效具有以下特点：

1.  **高度可定制性**：通过调整扭曲中心、扭曲角度、扭曲强度和扭曲方向，可以创建各种不同的扭曲效果
2.  **自然流畅**：基于极坐标变换的算法使得扭曲效果非常自然流畅
3.  **适用范围广**：可以应用于各种`Manim`对象，包括几何形状和文本
4.  **易于集成**：作为一个自定义`Animation`类，可以很容易地集成到现有`Manim`项目中

使用场景
----

这个扭曲特效可以用于以下场景：

1.  **数学教学**：用于展示几何变换、极坐标转换等数学概念
2.  **视觉效果增强**：为动画添加独特的视觉效果，增强观众的注意力
3.  **转场动画**：作为场景之间的转场效果
4.  **强调重点**：通过扭曲效果突出显示重要的对象或概念
5.  **创意动画**：用于创建具有艺术感的动画效果

通过这个简单而强大的特效，我们可以为`Manim`动画增添更多的视觉表现力和创意可能性。