---
layout: post
title: 'C++ 语言特性的变更可能让你的防御成为马奇诺防线'
date: "2025-12-13T00:42:02Z"
---
C++ 语言特性的变更可能让你的防御成为马奇诺防线
=========================

马奇诺防线
=====

[马奇诺防线](https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%A5%87%E8%AF%BA%E9%98%B2%E7%BA%BF)是法国在1930年代修建的一道大型防御工事系统。防线由复杂的地下工事网络组成，包括炮台、掩体、地下兵营、弹药库和指挥所等设施，有些地下工事深达数十米。

然而，在1940年的法国战役中，马奇诺防线并未发挥预期作用，德军绕过马奇诺防线，通过比利时和阿登森林发动突袭，迅速击败了法军。这使得马奇诺防线成为了"过时防御思维"的象征。

代码中的防御
======

日常工作中，编写一些功能类，或者一个相对完备的功能模块是比较常有的，我们编写它们要么是供其他同事使用，要么作为积累和展示。一旦想到自己的代码可能被其他同行调用，我们就会一改平时漫不经心的态度，幻想着他人会触碰我们代码中的逻辑缺陷，败坏他们的程序，自己落得颜面扫地。

于是我们步步为营，每添加或修改一点功能就会仔细推敲有可能发生的意外，运用自己掌握的手段攘除它们滋生的可能，保证我们的代码永远行驶在正轨之上，这就像代码中的防御工事。

但是这种防御与网络和数据安全领域的防御又有所区别，后者的防御对象经常是那些图谋不轨者，就像战争中的敌人一样与我们是对立的。而我们的这种防御更像是一种辅助，它让我们的用户尽可能不陷入困境，就像 Effective C++ 中说的，让接口更难被误用。

一个例子
====

假设我们有一个比较复杂的类 Complex，它有诸多成员变量，其中某些成员组合在一起可以描述一个抽象的属性，多个属性可能会涉及相同的成员变量，将与某个属性关联的成员打包到一个属性类中是不可行的。

一个解决方案是，将各种的抽象属性封装为不同的代理类，它们各自只引用自己关心的 Complex 数据成员，通过这些代理类来读取或修改相应的属性，思路如图：

![](https://img2024.cnblogs.com/blog/3635299/202507/3635299-20250722175050724-49004845.webp)

一个确切的例子，假如我们有一个房子，它的内部包含多种家用电器，现在我们想为这个房子的智能控制系统编写一系列的模式，比如归家模式、电影模式、度假模式等等。我们就可以将这些模式包装为多个类，各个模式只引用它们需要操作的电器，用以查询或改变房子的状态。假如我们编写了如下代码：

代码

    
    class House;
    class MovieMode
    {
    public:
        enum class Atmosphere
        {
            Romantic,
            Action,
            Horror,
            Drama,
            //其他氛围
            ...
        };
        bool is_on() const;//电影模式是否开启
        void turn_on();//开启电影模式
        Atmosphere get_atmosphere() const;//获取观影氛围
        void set_atmosphere(Atmosphere ap);//设置观影氛围
        //其他接口
        ...
        //明确表明不希望任何形式的复制
        MovieMode(const MovieMode &) = delete;
        MovieMode &operator=(const MovieMode &) = delete;
        MovieMode &operator=(MovieMode &&) noexcept = delete;
    private:
        MovieMode(House &house, Light &mood_light, Device &_projector, 
            Device &stereo_system);
        //用于从函数返回
        MovieMode(MovieMode &&) noexcept = default;
    private:
        House &_house;//操作的对象
        Light &_mood_light;//氛围灯
        Device &_projector;//投影仪
        Device &_stereo_system;//音响
        //其他可能关联的设备
        ...
        //将House声明为友元，使它能够创建和返回本类的实例
        friend class House;
    };
    class House
    {    
    public:
        //构造、设置等接口
        ...
        //打开所有灯
        void turn_on_all_lights();
        //关闭所有灯
        void turn_off_all_lights();
        //打开所有电器
        void turn_on_all_devices();
        //关闭所有电器
        void turn_off_all_devices();
        //创建电影模式
        MovieMode movie_mode();
        const MovieMode movie_mode() const;
        //创建其他模式
        ...
    private:
        //各种灯具
        Light _entry_light;//玄关灯
        Light _corridor_light;//过道灯
        Light _mood_light;//氛围灯
        Light _kitchen_light;//厨房灯
        //其他的灯具
        ...
        //各种电器
        Device _refrigerator;//电冰箱
        Device _projector;//投影仪
        Device _stereo_system;//音响
        Device _air_filter;//空气净化器
        //其他电器
        ...
    };
    {{the-copyright}} authored by cnblogs @saltymilk https://www.cnblogs.com/saltymilk/p/18998670 {{/the-copyright}}

这段代码显得有些粗制滥造，实际情况中，应该为各种家用电器设计一套继承体系方便分类与管理，房子也可以分割为不同的房间，每个家用电器可以放置到不同的房间内。但是作为例子，用以说明本文的意图足矣。

可以看到，MovieMode 类除定义了与功能相关的接口外，其构造函数、拷贝控制系列函数都做了显式定义。而 House 类创建 MovieMode 的接口区分 const 和非 const 两个版本。这样的定义主要有以下考量：

1\. MovieMode 构造函数和移动构造函数为私有，只能由友元 House 类的接口创建它的实例和从函数中返回：

代码

    
    MovieMode House::movie_mode()
    {
        return MovieMode(*this, _mood_light, _projector, _stereo_system);
    }
    const MovieMode House::movie_mode() const
    {
        return const_cast(this)->movie_mode();
    }

2\. MovieMode 的拷贝构造、拷贝赋值、移动赋值函数皆显式删除，除通过 House 的实例获取外，用户无法以其他方式创建或拷贝 MovieMode 的实例：

代码

    
    House house;
    house.movie_mode().turn_on();
    house.movie_mode().set_atmosphere(MovieMode::Atmosphere::Romantic);
    MovieMode mode = house.movie_mode();//错误，无法拷贝或移动构造 MovieMode

这点很重要，因为 MovieMode 是一个代理类，它的内部保存着一个对 House 对象的引用，所以它的生命周期必须是它所绑定的 House 对象的子集，否则对它的读写操作就可能是在操作一个空悬引用。

3\. House 创建 MovieMode 的接口区分 const 和非 const 版本，这保证了 const House 实例不会被意外修改

代码

    
    const House chouse;
    MovieMode::Atmosphere ap = chouse.movie_mode().get_atmosphere();
    chouse.movie_mode().turn_on();//错误，无法通过 const MovieMode 对象调用

经过测试用例的验证，这一系列防御措施确实可以防止预想中各种意外情况的发生，于是我们满怀信心地将这份代码提供了出去。

防御失效
====

假如经过一段时间后，我们的这个模块被其他人引用，但是我们发现了这样的代码，让我们后背一凉：

代码

    
    const House chouse;
    auto mode = chouse.movie_mode();
    mode.set_atmosphere(MovieMode::Atmosphere::Romantic);
    {{the-copyright}} authored by cnblogs @saltymilk https://www.cnblogs.com/saltymilk/p/18998670 {{/the-copyright}}

后两句代码直接无视了我们精心设下的防御工事，既“复制”了 MovieMode 对象，还通过它修改了一个 const House 对象的状态！这让我们有点惊讶，我们在测试代码时这样的语句已经确定是无法通过编译的，但是现在它们活生生的在我们眼前，编译器没有一点阻挠地编译成功了。经过一番对比后我们恍然大悟：这些代码是使用 C++17 语言标准编译，而我们测试的环境是 C++14。

读到此处有的读者可能会想，C++26 都快发布了，为什么还用 C++14 ？在作者所处的传统软件工作环境中，C++17 及之后的版本普及率确实相当低，很多项目甚至还在用 C++11，像作者这种新手才会好奇地摆弄新的语言特性。

我们都知道 C++ 的拷贝省略（[Copy Elision](https://en.cppreference.com/w/cpp/language/copy_elision.html)），而在[这篇博客](https://www.cnblogs.com/saltymilk/p/19031419#Semantic Check And Optimization)里我正好已经讨论过它与语义检查的关系。C++14 标准下语义检查会拒绝上述代码的写法，因为它引用了无法访问的移动构造函数，而到了 C++17 中，由于强制拷贝省略要求这种情形下必须省略移动构造函数的调用，编译器只需检查在 mode 真正的构造函数调用处（movie\_mode 的函数内部，更具体地说，是非 const 版本的 House 的 movie\_mode 内部）MovieMode 的构造函数可访问即可，而由于 House 类是 MovieMode 类的友元，在它的成员函数内构造 MovieMode 对象当然是没问题的。

`auto mode = chouse.movie_mode();` 这一句的语义是从一个函数返回的临时的 const MovieMode 对象构建一个非 const 的 MovieMode 对象 mode，需要经历一次构造，多次移动和移动构造，然而在强制拷贝省略的前提下，只需在真正的创建点原位构造一个非 const 的 MovieMode 对象即可，所以上述代码可成功编译。

就像马奇诺防线一样，我们的防御失效了，新的语言标准可以让危险代码绕过我们坚固的防御工事直击要害。这让我想起以前玩植物大战僵尸时的情形：我布置了强大的地面火力和结实的高坚果墙，但是突然出现几只气球僵尸大摇大摆地飞进房子吃掉了脑子。

不过幸好这不像战争一样只有一次机会，我们可以对我们的防御工事进行补救。

方案一（成员函数引用限定符）
==============

强制拷贝省略会直接无视我们的防御措施所倚仗的流程，那么有没有办法让强制拷贝省略失效？查阅了一些资料看到说在返回临时对象的函数内增加一些分支逻辑可以干扰编译器对于强制拷贝省略可行性的判断，这样我们可以牺牲一点点效率来重新获取安全性，比如：

代码

    
    MovieMode House::movie_mode()
    {
        uintptr_t addr = (uintptr_t)this;
        MovieMode *pm = nullptr;
        if(addr & 0x1000)//一个运行时才能确定的判断
            return MovieMode(*this, _mood_light, _projector, _stereo_system);
        else
        {
            MovieMode mode(*this, _mood_light, _projector, _stereo_system);
            pm = &mode;
            return std::move(*pm);
        }
    }

上述代码为了制造一些干扰已经非常刻意了，然而可惜的是，使用 MSVC、clang、GCC 对这段代码进行编译，在语言标准设定为 C++17 的情况下，`auto mode = chouse.movie_mode();` 这一句代码全都顺利通过编译，看来编译器在这方面都是非常激进的。不过就算这样能够成功阻止编译器施行强制拷贝省略，我也不打算编写这样丑陋不堪的代码。

既然几乎无法阻止独立的 MovieMode 被构造出来，我们就要在其他地方想办法了。有很长一段时间我都想不出什么合适的方法来，直到一次翻 Effective Modern C++ 时，在条款十二（Declare overriding functions override）中看到成员函数的引用限定符这个 C++11 添加的语言特性。这个概念在我最开始读 C++ Primer 时就知晓，但是以当时我的代码经历来说，这个特性毫无用武之地，之后的开发中也没有用过它，所以渐渐淡忘了，再次看到它时我是非常激动的，它就是我寻找的东西！真是 “初闻不识曲中意，再听已是曲中人” 啊。考虑到:

代码

    
    House house;
    house.movie_mode().set_atmosphere(...);//set_atmosphere 是在一个右值上调用的
    auto mode = house.movie_mode();
    mode.set_atmosphere(...);//set_atmosphere 是在一个左值上调用的

添加一个右值引用限定符，我们就能限制 set\_atmosphere 只能通过 MovieMode 的右值对象调用了：

代码

    
    class MovieMode
    {
    public:
        void set_atmosphere(Atmosphere ap) &&//右值引用限定
        //其他成员
        ...
    };
    House house;
    house.movie_mode().set_atmosphere(...);//OK
    auto mode = house.movie_mode();
    mode.set_atmosphere(...);//错误，不能在 lvalue 上调用 MovieMode::set_atmosphere
    {{the-copyright}} authored by cnblogs @saltymilk https://www.cnblogs.com/saltymilk/p/18998670 {{/the-copyright}}

现在就算用户得到一个独立的 MovieMode 对象，也无法用它来调用 set\_atmosphere 了。同理我们可以为 MovieMode 的其他接口都添加右值引用限定（const 属性仍保持原样），这样就算用户通过某种方法获得了一个空悬的 MovieMode 对象，他也没法在其上做出进一步的操作而引发未定义行为了。

方案二（依赖稳定的语言特性）
==============

上述诸多麻烦的根本原因是，我们的特性依赖了一个不是长期保持不变的语义，一旦这个语义发生根本性的改变，我们就必须做出调整。

我们知道，从一个非临时的对象构造另一个对象需要调用拷贝构造函数这一语言规则是一定不会被改变的，我们的 House 类可以将控制系统支持的所有模式作为成员存储在类内，只返回它们的引用：

代码

    
    class House;
    class MovieMode
    {
    public:
        //明确表明不希望任何形式的复制
        MovieMode(const MovieMode &) = delete;
        MovieMode &operator=(const MovieMode &) = delete;
        MovieMode(MovieMode &&) noexcept = delete;
        MovieMode &operator=(MovieMode &&) noexcept = delete;
        //其他成员函数
        ...
    private:
        MovieMode(House &house, Light &mood_light, Device &_projector, 
            Device &stereo_system);
        friend class House;
        //其他成员
        ...
    };
    class House
    {
    public:
        MovieMode &movie_mode() { return _movie_mode; }
        const MovieMode &MovieMode() const { return _movie_mode; }
        //其他成员函数
        ...
    private:
        MovieMode _movie_mode;
        //其他成员
        ...
    };

现在用户连创建一个独立的 MovieMode 变量都不可能了，操作某个 House 实例的 MovieMode 必须通过 movie\_mode 接口调用来完成，而且这样的设计可以确保长期的稳定性，因为它所依赖的语言特性是 C++ 对象模型最基础的规则之一，几乎不可能变更。

当然这种实现的代价是大大增加了 House 类的内存占用，如果实际应用中需要创建非常多的 House 实例，这种方式可能也不是最佳选择。

刻意的破坏不在防御目标之列
=============

有人说，仍然有方法可以绕开限制：

代码

    
    //针对方案一：
    auto create_dangling_mode() -> decltype(std::declval().movie_mode())
    {
        return House().movie_mode();
    }
    create_dangling_mode().set_atmosphere(...);//在空悬的 MovieMode 调用 set_atmosphere
    const House chouse;
    auto mode = chouse.movie_mode();
    static_cast(mode).set_atmosphere(...);//修改 const 对象的数据
    //针对方案二：
    const House chouse;
    const_cast(chouse.movie_mode()).set_atmosphere(...);//修改 const 对象的数据

这些并不是什么高超的编程技巧，我们确实无法也没有义务防御这样的操作。就像是坐飞机时非要解开安全带撬开舷窗把头伸出窗外一样，我们只能说，自作孽不可活，祝他好运。

为易用性而妥协
=======

上面的两种修改方案，都能够保证正常用户只能通过这样的方式去调用 MovieMode 的接口：

代码

    
    House house;
    house.movie_mode().xxx();

这样能够保证每个创建出来的 MovieMode 的生命周期都是它所绑定的 House 对象的子集，不会出现空悬引用。

但是正是最开始 `auto mode = house.movie_mode();` 这句代码，让我们产生了思考，用户一般不会故意去测试代码的边界情况，那么站到用户的角度来看，为什么会这样编写呢？考虑到这样使用场景，代码中有多个条件分支都要对同一个 House 的 MovieMode 进行设置：

代码

    
    House house;
    if(...)
        house.movie_mode().xxx();
    else if(...)
        house.movie_mode().xxx();
    //还有许多分支

这种情况下，重复地键入 `house.movie_mode()` 可能形成不好的体验，而这样的编写方式会更方便自然：

代码

    
    House house;
    auto mode = house.movie_mode();
    if(...)
        mode.xxx();
    else if(...)
        mode.xxx();
    //还有许多分支

如果每次设置都需要通过调用一长串的函数来实现，确实会影响使用体验，我们或许应该为易用性而妥协。文章开头已经说到，我们与用户之间并不是你死我活的敌对关系，我们可以在接口文档中提醒用户，哪些使用方式是危险的需要避免，相信用户不会故意去违背这些善意的提示编写危险的代码。

假如我们在方案一中去掉了 MovieMode 成员函数上施加的右值引用限定符，或者在方案二中解除了 MovieMode 不可复制的限制，为易用性让路，并撰写了详细的说明文档，用户也非常配合，然而开始的那个会意外修改 const 数据的问题会再次浮现出来：

代码

    
    const House chouse;
    auto mode = chouse.movie_mode();
    mode.xxx();//mode 不是 const 的，可能意外修改一个 const 对象的数据

创建的 mode 是一个非 const 的版本，通过它能够修改 chouse 的数据。而要求用户注意到这一点，每次调用一个 const 版本的 House 实例的 movie\_mode 都写成: `const auto mode = chouse.movie_mode();` 也是不切实际的，这个问题是我们必须解决的。

解决方法也很简单，MSVC 标准库 `std::vector` 的迭代器（iterator）设计已经给了我们示范：iterator 继承自 const\_iterator，const\_iterator 实现读操作，iterator 实现写操作。

![vector iterator](https://img2024.cnblogs.com/blog/3635299/202512/3635299-20251212162436896-1927101919.jpg)

我们的 MovieMode 跟迭代器非常相似，完全可以采用相同的设计方式：

代码

    
    class Const_MovieMode; //所有的读操作
    class MovieMode : public Const_MovieMode//所有的写操作
    class House
    {
    public:
        Const_MovieMode movie_mode() const;
        MovieMode movie_mode();
    };

现在用户创建一个 const 版本的 House 然后通过 movie\_mode 得到的是一个 Const\_MovieMode，在这个对象上是绝对无法修改绑定对象的数据的。

或许有能够兼顾安全性和易用性的实现，毕竟在 C++ 中，你几乎总能够找到方案实现你的任何想法，但是就我目前的水平来看已经捉襟见肘了，还须继续学习。

总结
==

1\. C++ 中一旦你想构建一个与默认行为相异的类，你就不得不精细定制类的各种行为以达到你的设计目的，而这种定制大概率会改变一些你未注意到的行为，为此你不得不深究相关的语言细节，而当你了解的更深后，你又会回过头发现之前的实现可以重构，重构的过程中又会触碰更多细节，如此往复。很多人说 C++ 是一门心智负担很重的语言，但是在其他的编程语言中这种情形同样存在，它是学习过程的必然现象，不过 C++ 在这一点上表现得尤为突出。

2\. 语言标准的变更可能会破坏我们原有代码的设计意图，所以我们应该尽量依赖那些能够保持长期不变的特性。

本文来自博客园，作者：[saltymilk](https://www.cnblogs.com/saltymilk/)，转载请注明原文链接：[https://www.cnblogs.com/saltymilk/p/18998670](https://www.cnblogs.com/saltymilk/p/18998670)