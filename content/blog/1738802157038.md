---
layout: post
title: '并发编程 - 线程同步（三）之原子操作Interlocked简介'
date: "2025-02-06T00:35:57Z"
---
并发编程 - 线程同步（三）之原子操作Interlocked简介
================================

原子操作是不可分割的操作单元，Interlocked提供硬件级别原子操作，比传统锁机制效率高。Interlocked支持多种原子操作，如增减、替换、位操作等，确保多线程安全。

上一章我们了解了3种处理多线程中共享资源安全的方法，今天我们将更近一步，学习一种针对简单线程同步场景的解决方案——Interlocked。

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250205175054210-34364760.jpg)

在此之前我们先学习一个概念——原子操作。

_**01**_、原子操作
=============

原子操作，其概念源于化学领域，原子是构成化学元素的普通物质的最小单位；原子也是化学变化中最小的粒子及元素化学性质的最小单位。

借鉴到编程语言中原子操作指：不可分割的操作单元，是指一类不可中断的操作，它在执行时要么全部执行，要么全部不执行，不会被其他操作打断，而执行结果要么全部成功，要不全部失败，没有其他状态。

我们再回忆一下我们学习线程同步的目的——**确保多个线程在访问共享资源时能够按顺序、安全地进行操作**，从而避免并发执行带来的**数据竞争**和**不一致的状态。**

可以说原子操作天然的解决了多线程共享资源安全问题。

在C#语言中，Interlocked类提供了一系列可以进行原子操作的工具。

_**02**_、Interlocked实现原理
========================

Interlocked的原子操作是基于CPU本身实现，是硬件级别的原子指令封装，并且它不需要显式的线程阻塞，因此比传统的锁机制（如互斥锁、信号量等）效率更高，尤其是在高并发的场景下。

线程阻塞是指操作系统把当前线程从运行状态变更为阻塞状态，并且操作系统会把当前线程占用的CPU时间片分配给其他线程，使当前线程尽可能少的占用CPU时间。在分配CPU时间片时会涉及上下文切换等操作。

因此Interlocked的非阻塞特性，严格意义上来说并不是锁，但是效率却比锁高得多。

另外如果一个方法在CPU层面上被设计为对立不可分割的指令，那么它本质上就是原子的，严格的原子性可以阻止任何抢占的可能。因此在32位CPU中，一个操作数的大小为32位，因此可以提供32位即4个字节大小及以内的数据类型（如int，float）进行读写的原子操作。同理64位CPU，则可以提供64位级8个字节大小及以内的数据类型（如long，double）进行读写的原子操作。

其实在上一章也举个一个例子，在32位CPU环境下操作long类型，多线程情况下会出现线程不完全问题，因为对于32位CPU，操作一次long类型数据至少需要两个原子指令，因此就会出现线程安全问题。

_**03**_、Interlocked常用方法
========================

Interlocked方法从.NET Framework 1.1到目前最新的.NET 9也经历了长足的发展和完善。可以总结为：支持的操作类型在增加，操作能力也再增加，由早期的简单递增、递减、替换操作到现在的复杂位操作，内存屏障操作等。

下面我们先整体了解一下Interlocked有那些方法。

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250205175103373-1145211926.png)

*   **Read：** 原子的读取64位值；
    
*   **Increment：** 原子的递增指定的变量，并返回递增后的新值；
    
*   **Decrement：** 原子的递减指定的变量，并返回递减后的新值；
    
*   **Add：** 原子的对两个变量求和，将第一个变量替换为两者和，并返回操作后第一个变量的新值；
    
*   **Exchange：** 原子的交换两个变量，并返回第一个变量的原始值；
    
*   **Exchange：** Exchange方法的泛型版本；
    
*   **CompareExchange：** 原子的比较第一个变量和第三个变量是否相等，如果相等，则将第一个变量替换为第二个变量值，并返回第一个变量的原始值；
    
*   **CompareExchange：** CompareExchange方法的泛型版本；
    
*   **And：** 原子的对两个变量进行按位与操作，将第一个变量替换为操作结果，并返回第一个变量的原始值；
    
*   **Or：** 原子的对两个变量进行按位或操作，将第一个变量替换为操作结果，并返回第一个变量的原始值；
    
*   **MemoryBarrier：** 强制执行内存屏障，作用范围当前线程，无返回值；
    
*   **MemoryBarrierProcessWide：** 提供进程范围的内存屏障，确保任何 CPU 的读取和写入无法跨屏障移动；
    

后面我们将详细讲解每个方法的如何使用。

_**注**_：测试方法代码以及示例源码都已经上传至代码库，有兴趣的可以看看。[https://gitee.com/hugogoos/Planner](https://gitee.com/hugogoos/Planner)