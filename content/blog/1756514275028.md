---
layout: post
title: '【渲染管线】UnityURP中[渲染路径]选择‌'
date: "2025-08-30T00:37:55Z"
---
【渲染管线】UnityURP中\[渲染路径\]选择‌
==========================

![【渲染管线】UnityURP中[渲染路径]选择‌](https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250829095314919-888288675.png) 本文深入解析Unity URP渲染管线技术特点，重点对比了Build-in与URP的核心差异。URP基于SRP架构，支持在渲染流程中插入自定义Pass，提供Forward、Deferred、Forward+等多种渲染路径。文章详细拆解了URP的渲染阶段顺序（从BeforeRendering到AfterRendering共11个关键节点），并着重分析了延迟渲染路径的技术实现，包括GBuffer处理、光照计算流程和半透明物体前向渲染的特殊规则。通过Shader配置示例和调试方法，展示了URP延迟渲染路径下&qu

URP基于SRP，相比于Build-in的渲染管线，进一步开放了渲染流水线中各个Pass的配置与可编程性。除了内置的Forward前向渲染路径、Deferred延迟渲染路径、Forward+前向加渲染路径，这几种渲染路径中特定需要的渲染Pass以外，可以在渲染管线_**各个阶段**_插入自定义Pass来完成自定义操作。Build-in不具备修改管线中的各个阶段插入自定义Pass的能力。

> [【从UnityURP开始探索游戏渲染】](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**专栏-直达**

渲染的各个阶段的事件
==========

*   这里列出渲染的各个阶段的事件枚举`RenderPassEvent`（com.unity.render-pipelines.universal@14.0.12/Runtime/Passes/ScriptableRenderPass.cs），依此也可快速看出渲染的流程顺序：
    
    > BeforeRendering（开始渲染前） → RenderingShadows（阴影渲染） →  
    > RenderingPrePasses（预渲染） → RenderingGbuffer（G-buffer） →  
    > RenderingDeferredLights（延迟着色） → RenderingOpaques（渲染不透明） →  
    > RenderingSkybox（渲染天空盒） → RenderingTransparents（渲染透明） →  
    > RenderingPostProcessing（后处理） → AfterRendering（渲染结束后）
    

枚举值

数值

描述

BeforeRendering

0

在渲染管线中其他所有通道之前执行ScriptableRenderPass。此时相机矩阵和立体渲染尚未设置。可用于绘制后期管线中使用的自定义输入纹理，如LUT纹理。

BeforeRenderingShadows

50

在渲染阴影贴图之前执行ScriptableRenderPass。此时相机矩阵和立体渲染尚未设置。

AfterRenderingShadows

100

在渲染阴影贴图之后执行ScriptableRenderPass。此时相机矩阵和立体渲染尚未设置。

BeforeRenderingPrePasses

150

在渲染预通道(如深度预通道)之前执行ScriptableRenderPass。此时相机矩阵和立体渲染已经设置完成。

AfterRenderingPrePasses

200

在渲染预通道(如深度预通道)之后执行ScriptableRenderPass。此时相机矩阵和立体渲染已经设置完成。

BeforeRenderingGbuffer

210

在渲染G-buffer通道之前执行ScriptableRenderPass。

AfterRenderingGbuffer

220

在渲染G-buffer通道之后执行ScriptableRenderPass。

BeforeRenderingDeferredLights

230

在渲染延迟着色通道之前执行ScriptableRenderPass。

AfterRenderingDeferredLights

240

在渲染延迟着色通道之后执行ScriptableRenderPass。

BeforeRenderingOpaques

250

在渲染不透明物体之前执行ScriptableRenderPass。

AfterRenderingOpaques

300

在渲染不透明物体之后执行ScriptableRenderPass。

BeforeRenderingSkybox

350

在渲染天空盒之前执行ScriptableRenderPass。

AfterRenderingSkybox

400

在渲染天空盒之后执行ScriptableRenderPass。

BeforeRenderingTransparents

450

在渲染透明物体之前执行ScriptableRenderPass。

AfterRenderingTransparents

500

在渲染透明物体之后执行ScriptableRenderPass。

BeforeRenderingPostProcessing

550

在渲染后处理效果之前执行ScriptableRenderPass。

AfterRenderingPostProcessing

600

在渲染后处理效果之后执行ScriptableRenderPass，但在最终blit、后处理AA效果和色彩分级之前。

AfterRendering

1000

在所有效果渲染完成后执行ScriptableRenderPass。

‌**前向渲染**‌
==========

*   逐物体处理光照，适合移动端和简单光照场景。

‌**延迟渲染**‌
==========

*   分离几何与光照计算，在屏幕空间执行光照，支持大量动态光源，但需更高显存开销 ‌。配置方式：URP Asset 中设置渲染路径。
*   **延迟渲染路径下GBufferPass阶段后，管线内部会固定处理LightingPass阶段，计算光照输出到缓冲区的**

**一、光照计算流程‌**
-------------

### ‌**输入数据来源**‌

*   读取GBuffer纹理（RT0-RT3）中的材质属性（漫反射、法线、高光等）
*   深度缓冲区用于可见性判断和光源裁剪

### ‌**计算方式**‌

*   全屏四边形或光源几何体逐像素处理
*   定向光全局计算，点/聚光灯通过模板测试局部渲染

### ‌**输出目标**‌

*   直接写入帧缓冲区（Frame Buffer）形成最终颜色

* * *

**‌二、关键实现文件‌**
--------------

### ‌**核心着色器**‌

*   `Internal-DeferredShading.shader`：内置延迟光照计算逻辑‌
*   包含光源类型分支（定向光、点光源、聚光灯）和阴影处理

### ‌**HLSL工具库**‌

*   `UnityDeferredLibrary.hlsl`：提供光照模型函数（如Blinn-Phong/PBR）‌
*   `UnityGBuffer.hlsl`：定义GBuffer数据编码/解码方法‌

### ‌**C#管线控制**‌

*   `DeferredLights.cs`：管理GBuffer创建与光照Pass调度‌

* * *

**‌三、技术特性‌**
------------

### ‌**性能优化**‌

*   通过光源体积剔除和模板测试减少无效计算

### ‌**扩展性**‌

*   可通过替换`Internal-DeferredShading.shader`自定义光照模型‌
*   延迟渲染路径下，透明序列的物体使用LightMode为UniversalForward的pass来渲染半透明物体
*   在Unity URP延迟渲染路径下，‌**设置`LightMode="UniversalForward"`的Pass会被执行**‌，但仅针对特定类型的物体。以下是具体规则：

**‌一、延迟渲染路径下的前向Pass执行规则‌**
--------------------------

### ‌**半透明物体强制前向渲染**‌

*   所有标记为`"Queue"="Transparent"`的物体，即使管线使用延迟渲染路径，其`LightMode="UniversalForward"`的Pass仍会被执行
*   原因：延迟渲染无法处理透明度混合，需退回前向路径

### ‌**不透明物体的例外**‌

*   不透明物体（`"Queue"="Geometry"`）的`UniversalForward` Pass在延迟路径下‌**不会执行**‌
*   此类物体统一由GBuffer Pass（`LightMode="UniversalGBuffer"`）处理

* * *

**‌二、技术实现原理‌**
--------------

‌**管线阶段**‌

‌**执行内容**‌

‌**相关Pass的LightMode**‌

‌**不透明物体阶段**‌

写入GBuffer（颜色、法线、材质属性等）

`UniversalGBuffer`

‌**光照计算阶段**‌

基于GBuffer进行屏幕空间光照叠加

内置管线Pass（无LightMode标签）

‌**半透明物体阶段**‌

按前向渲染方式逐物体计算光照，混合到帧缓冲区

`UniversalForward`

> 光照计算由URP内置着色器Internal-DeferredShading.shader完成，不依赖材质Shader中的Pass

* * *

**‌三、验证与实践要点‌**
---------------

### ‌**Shader配置示例**‌

*   半透明物体必须显式声明前向标签：

    SubShader {
        Tags { "Queue" = "Transparent" }
        Pass {
            Tags { "LightMode" = "UniversalForward" } // 延迟路径下仍会执行
            Blend SrcAlpha OneMinusSrcAlpha
            ZWrite Off
            ...
        }
    } 
    

### ‌**调试方法**‌

*   使用‌**Frame Debugger**‌工具可观察到：
    *   不透明物体仅显示`Render Opaques`和`GBuffer`相关条目
    *   半透明物体显示`Render Transparents`条目并执行`UniversalForward` Pass

* * *

**‌四、底层机制说明‌**
--------------

*   URP延迟路径本质上是‌**混合渲染方案**‌：
    
*   不透明物体 → ‌**延迟渲染**‌（GBuffer + 屏幕空间光照）
    
*   半透明/特殊效果物体 → ‌**前向渲染**‌（逐物体光照计算）这种设计兼顾了不透明物体的光照性能与特殊材质的灵活性
    

* * *

> [【从UnityURP开始探索游戏渲染】](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**专栏-直达**

（欢迎_点赞留言_探讨，更多人加入进来能更加完善这个探索的过程，🙏）