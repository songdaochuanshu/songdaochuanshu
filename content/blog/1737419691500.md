---
layout: post
title: 'Go语言【Gin框架】：JSON、AsciiJSON、PureJSON和SecureJSON的区别'
date: "2025-01-21T00:34:51Z"
---
Go语言【Gin框架】：JSON、AsciiJSON、PureJSON和SecureJSON的区别
=================================================

在Go语言中，`JSON`、`AsciiJSON`、`PureJSON` 和 `SecureJSON` 是Gin框架用于发送JSON响应的方法。

### 1\. `c.JSON`

**功能**：将提供的数据序列化为标准的JSON格式，并将其作为HTTP响应发送给客户端。

**特点**：

*   支持Unicode字符，无需将非ASCII字符转义。
*   某些字符（如 <、> 和 &）会被自动转义为相应的 Unicode 转义序列。

**使用场景**：

*   需要发送包含Unicode字符（如中文、表情符号等）的JSON数据时。

### 2\. `c.AsciiJSON`

**功能**：将数据序列化为仅包含ASCII字符的JSON格式，通过转义非ASCII字符确保JSON内容为ASCII编码。

**特点**：

*   所有非ASCII字符（如中文、特殊符号）会被转义为Unicode编码（如 `\uXXXX`）。

**使用场景**：

*   适用于需要确保JSON响应为纯ASCII的场景，例如某些旧版系统或特定的安全需求。
*   客户端对JSON编码有严格要求，只接受ASCII字符。
*   避免因非ASCII字符导致的读取或解析问题。

### 3\. `c.PureJSON`

**功能**：发送未经额外处理的纯JSON数据，不进行任何包装或转义。

**特点**：

*   直接将提供的JSON数据发送给客户端。
*   避免框架对JSON数据进行额外的修改。

**使用场景**：

*   已经预处理或生成了符合要求的JSON数据，且不希望框架进行任何干预。
*   需要发送特定格式或结构的JSON响应时。

### 4\. `c.SecureJSON`

**功能**：在JSON响应前添加安全前缀，以防止JSON Hijacking（JSON劫持）攻击。

**特点**：

*   通常在JSON数据前添加特定的字符或字符串（例如 `")]}',\n"`），使得响应不再是有效的JavaScript代码，增加安全性。

**使用场景**：

*   适用于公开API或需要防范特定安全威胁的场景。
*   提供跨域API时，防止恶意网站通过`<script>`标签加载JSON数据进行攻击。
*   需要增强JSON响应的安全性，避免被恶意利用。

### 代码

    package main
    
    import (
    	"net/http"
    
    	"github.com/gin-gonic/gin"
    )
    
    type User struct {
    	Name  string   `json:"name"`
    	Email string   `json:"email"`
    	Names []string `json:"names"`
    }
    
    func main() {
    	// 创建默认的Gin引擎
    	r := gin.Default()
    
    	// 示例数据
    	user := User{
    		Name:  "张三", // 包含非ASCII字符
    		Email: "zhangsan<@example.com>",
    		Names: []string{"lena", "austin", "foo"},
    	}
    
    	// 路由1: 使用 c.JSON（标准JSON响应，支持Unicode）
    	r.GET("/json", func(c *gin.Context) {
    		c.JSON(http.StatusOK, user)
    		// 输出:
    		// {
    		//   "name": "张三",
    		//   "email": "zhangsan\u003c@example.com\u003e"
    		//	 "names": ["lena","austin","foo"]
    		// }
    	})
    
    	// 路由2: 使用 c.AsciiJSON（ASCII编码的JSON，非ASCII字符会被转义）
    	r.GET("/ascii-json", func(c *gin.Context) {
    		c.AsciiJSON(http.StatusOK, user)
    		// 输出:
    		// {
    		//   "name": "\u5f20\u4e09",
    		//   "email": "zhangsan\u003c@example.com\u003e"
    		//	 "names": ["lena","austin","foo"]
    		// }
    	})
    
    	// 路由3: 使用 c.PureJSON
    	// JSON 使用 unicode 替换特殊 HTML 字符，例如 < 变为 \ u003c。如果要按字面对这些字符进行编码，则可以使用 PureJSON
    	r.GET("/pure-json", func(c *gin.Context) {
    		c.PureJSON(http.StatusOK, user)
    		// 输出:
    		// {"name":"张三","email":"zhangsan<@example.com>, "names":["lena","austin","foo"]}
    	})
    
    	// 路由4: 使用 c.SecureJSON（在JSON前添加安全前缀，防止JSON Hijacking攻击）
    	// 如果给定的结构是数组值，则默认预置 "while(1)," 到响应体
    	r.GET("/secure-json", func(c *gin.Context) {
    		// 默认前缀为 ")];}',\n"
    		c.SecureJSON(http.StatusOK, user)
    		// 输出类似于:
    		// )]}',
    		// {
    		//   "name": "张三",
    		//   "email": "zhangsan\u003c@example.com\u003e"
    		//	 "names": ["lena","austin","foo"]
    		// }
    	})
    
    	// 启动服务器，监听8080端口
    	r.Run(":8080")
    }
    

### 总结

*   **`c.JSON`**：标准JSON响应，支持Unicode。
*   **`c.AsciiJSON`**：ASCII编码的JSON响应，非ASCII字符会被转义。
*   **`c.PureJSON`**：发送未经处理的原始JSON数据。
*   **`c.SecureJSON`**：在JSON前添加安全前缀，防止JSON Hijacking攻击。