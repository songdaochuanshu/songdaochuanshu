---
layout: post
title: '基于stm32单片机家庭环境监测系统'
date: "2025-08-26T00:40:47Z"
---
基于stm32单片机家庭环境监测系统
==================

1.演示视频
------

[基于stm32单片机家庭环境监测系统视频演示\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV18de4z8Est/?vd_source=fe50c8500dae5a3543c98e910b928780)

2\. 项目介绍
--------

本项目基于STM32F103C8T6最小系统板，打造了一个功能强大、显示直观的家庭环境监测系统。系统集成了温湿度、光照强度、多种气体、人体感应等传感器，并通过OLED屏幕本地实时显示数据，同时支持手机蓝牙小程序远程监控与告警。它不仅是一个全面的环境数据采集站，更是一个具备布防/撤防功能的简易家庭安防系统。

3\. 系统功能亮点
----------

*   ​**环境多参数监测**​：实时采集温度、湿度、光照强度、空气质量（CO/CO2/烟雾等综合指标）。
*   ​**人体红外感应**​：检测指定区域内是否有人体活动。
*   ​**双模远程通信**​：支持ESP32 Wi-Fi模块​（预留扩展接口）和HC-05/06蓝牙模块与手机连接。
*   ​**手机小程序监控**​：通过自开发的微信小程序，可远程查看所有传感器数据，并进行系统控制。
*   ​**智能安防布防**​：具备“布防”和“撤防”两种模式。在布防模式下，检测到人体入侵将触发本地蜂鸣器高声警报并推送手机提醒。
*   ​**交互与提示**​：配备四个功能按键和一个蜂鸣器，方便本地操作和声音提示。

4.硬件设计
------

### 4.1 硬件组成 (BOM List)

模块名称

型号/规格

通信协议

功能

​**主控芯片**​

STM32F103C8T6 (最小系统板)

\-

系统核心，负责数据处理与逻辑控制

​**显示模块**​

0.96英寸 OLED屏

I2C

本地实时显示所有传感器数据及系统状态

​**温湿度传感器**​

AHT20

I2C

高精度测量环境温度和湿度

​**光照传感器**​

GY-30 (BH1750)

I2C

检测环境光照强度 (Lux)

​**气体传感器**​

MQ-135

模拟/数字

综合检测空气质量、CO2、CO、烟雾、苯等有害气体

​**人体红外传感器**​

HC-SR501

数字GPIO

检测人体移动

​**蓝牙模块**​

HC-05 或 HC-06

UART

与手机小程序进行串口蓝牙通信

​**Wi-Fi模块**​

ESP-01S (ESP8266) 或 ESP32

UART

预留物联网扩展接口，可接入云平台

​**声学提示**​

有源蜂鸣器

GPIO

发出警报和提示音

​**输入控制**​

4x轻触按键

GPIO

本地切换模式、设置参数等

​**供电接口**​

Type-C

\-

5V供电，并配有电源开关

### 4.2主要芯片介绍

​**STM32F103C8T6介绍**

STM32F103C8T6是一款由意法半导体公司（ST）推出的基于Cortex-M3内核的32位微控制器，硬件采用LQFP48封装，属于ST公司微控制器中的STM32系列。

**AHT20温湿度传感器介绍**

**AHT20**是一款高精度数字温湿度传感器，采用I2C通信（地址0x38），供电需3.3V。其温度精度±0.3℃，湿度精度±2%RH，出厂已校准，即插即用。相比DHT11，精度更高、通信更稳定，是环境监测项目的理想选择。

**BH1750光照强度传感器介绍**

**BH1750FVI**​ 是一款数字式环境光强度传感器。它通过 ​**I2C**​ 接口直接输出光照度值（单位：Lux），测量范围 ​**1 - 65535 lx**。具有高精度、无需外部元件等优点，是替代光敏电阻的理想选择，广泛应用于自动背光调节和智能照明系统。

**ECB01H2S蓝牙模块介绍**

**ECB01H2S**​ 是一款基于蓝牙5.0的**串口透传模块**。它将复杂的蓝牙协议封装成简单的串口通信，用户只需通过**AT指令**进行配置，即可让主控设备（如STM32）通过串口与手机等蓝牙主机实现无线数据双向传输，极大简化了无线通信功能的开发流程，广泛应用于智能硬件和数据传输项目。

**I2C OLED显示屏介绍** 

该屏幕拥有**128x64**高分辨率，采用**I2C接口**，仅需两根信号线即可驱动。其像素点自发光，显示黑色时功耗极低，无需背光，视觉效果清晰锐利，对比度高，是嵌入式项目中最受欢迎的小型显示方案。

**ESP8266WiFi模块介绍**

**ESP8266**​ 是一款低成本、高性能的Wi-Fi SOC芯片模块。其核心功能是通过**串口AT指令**与单片机通信，轻松实现设备联网。它内置了TCP/IP协议栈，可作为独立MCU或Wi-Fi适配器使用，是物联网项目中实现无线连接最经典、性价比最高的解决方案之一。

5.系统设计与实现
---------

### 5.1整体系统设计

### 5.2 [数据流](https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E6%B5%81&spm=1001.2101.3001.7020)与工作逻辑

1.  ​**数据采集层**​：STM32主控循环读取各个传感器的数据。
2.  ​**数据处理层**​：对原始数据进行滤波、校准和计算，得到有意义的物理量（如℃、%RH、Lux、空气质量等级）。
3.  ​**本地显示层**​：处理后的数据通过I2C协议发送到OLED屏幕进行刷新显示。
4.  ​**远程通信层**​：STM32通过串口将数据按照自定义协议格式发送给蓝牙模块，再由蓝牙传输至手机小程序。手机下发的控制指令（如布防）也通过此路径逆向传输给STM32。

​**逻辑控制层**​：主控根据当前系统模式（布防/撤防）和传感器状态（是否检测到人）执行相应的动作，如控制蜂鸣器。

*   **本地显示效果：**​

　　　　屏幕第一页显示：`温度: 26.5℃`， `湿度: 45%`， `光照: 256 Lux`。

　　　　屏幕循环显示气体数据：`Air Q: Good`， `Gas: None`， `PM2.5: 15`， `Smoke: Low`。

　　　　人体检测状态：`P: Yes` (有人) 或 `P: No` (无人)。

　　　　安防状态：`Security On` (布防) 或 `Security Off` (撤防)。

*   ​**手机监控**​：

　　　　手机小程序成功连接蓝牙后，界面同步显示所有环境数据。

　　　　设有“布防/撤防”切换按钮。

　　　　在布防状态下，若检测到人体，手机端会弹出**弹窗警报**，并显示“警戒中！”。

*   ​**安防联动**​：

​　　　　**撤防模式**​：检测到人体，仅在屏幕和手机端显示“有人”，无声音警报。​**​（适合家中有人时）​**​

​　　　　**布防模式**​：检测到人体，​**蜂鸣器立即鸣叫**，同时手机端弹出警报。​**​（适合出门或夜间）​**​​

6.代码展示
------

/\* USER CODE BEGIN Header \*/
/\*\*
  \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  \* @file           : main.c
  \* @brief          : Main program body - 简化版
  \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  \*/
/\* USER CODE END Header \*/
/\* Includes ------------------------------------------------------------------\*/
#include "main.h"
#include "oled.h"
#include "temp\_humi.h"
#include "gas\_sensor.h"
#include "light\_sensor.h"
#include "bluetooth.h"
#include "gas\_display.h"
#include "buzzer.h"
#include <stdio.h>
#include <string.h>

/\* Private variables ---------------------------------------------------------\*/
I2C\_HandleTypeDef hi2c1;
ADC\_HandleTypeDef hadc1;
UART\_HandleTypeDef huart1;

/\* Private function prototypes -----------------------------------------------\*/
void SystemClock\_Config(void);
void MX\_GPIO\_Init(void);
void MX\_I2C1\_Init(void);
void MX\_ADC1\_Init(void);
void MX\_USART1\_UART\_Init(void);

/\*\*
  \* @brief  IR传感器初始化 - 简化版
  \* @param  None
  \* @retval None
  \*/
void IR\_Sensor\_Init(void)
{
  GPIO\_InitTypeDef GPIO\_InitStruct \= {0};
  
  \_\_HAL\_RCC\_GPIOB\_CLK\_ENABLE();
  
  GPIO\_InitStruct.Pin \= GPIO\_PIN\_9;
  GPIO\_InitStruct.Mode \= GPIO\_MODE\_INPUT;
  GPIO\_InitStruct.Pull \= GPIO\_PULLUP;
  GPIO\_InitStruct.Speed \= GPIO\_SPEED\_FREQ\_LOW;
  HAL\_GPIO\_Init(GPIOB, &GPIO\_InitStruct);
}

/\*\*
  \* @brief  检测人体存在 - 简化版
  \* @param  None
  \* @retval 1: 检测到人体, 0: 未检测到人体
  \*/
uint8\_t IR\_Sensor\_Detect(void)
{
  return (HAL\_GPIO\_ReadPin(GPIOB, GPIO\_PIN\_9) == GPIO\_PIN\_RESET) ? 1 : 0;
}

/\*\*
  \* @brief  应用程序入口点
  \* @retval int
  \*/
int main(void)
{
  /\* 初始化HAL库 \*/
  HAL\_Init();
  
  /\* 配置系统时钟 \*/
  SystemClock\_Config();
  
  /\* 初始化所有外设 \*/
  MX\_GPIO\_Init();
  MX\_I2C1\_Init();
  MX\_ADC1\_Init();
  MX\_USART1\_UART\_Init();
  
  /\* 初始化所有传感器和外设 \*/
  OLED\_Init();
  TEMP\_HUMI\_Init();
  GAS\_SENSOR\_Init();
  LIGHT\_SENSOR\_Init();
  IR\_Sensor\_Init();
  Bluetooth\_Init();
  BUZZER\_Init();
  
  /\* 显示初始屏幕 \*/
  OLED\_Clear();
  OLED\_ShowString(0, 0, "Starting...", 12);
  OLED\_Refresh();
  
  /\* 初始化变量 \*/
  float temperature = 0.0f;
  float humidity = 0.0f;
  float light = 0.0f;
  uint8\_t ir\_status \= 0;
  uint8\_t last\_ir\_status \= 0;
  uint8\_t bt\_send\_counter \= 0;
  
  /\* 创建气体数据结构 \*/
  GAS\_DATA gas\_data \= {0};
  
  /\* 气体传感器初始校准 \*/
  GAS\_SENSOR\_Calibrate(400.0f);
  
  /\* 手动设置一些初始值，确保数据不为空 \*/
  gas\_data.raw\_ppm \= 500.0f;
  gas\_data.co2\_equivalent \= 400.0f;
  gas\_data.combustible\_gas \= 150.0f;
  gas\_data.smoke\_density \= 75.0f;
  gas\_data.pm25 \= 50.0f;
  gas\_data.aqi \= 100;
  gas\_data.change\_rate \= 0.5f;
  gas\_data.gas\_type \= GAS\_TYPE\_NORMAL;
  gas\_data.safety\_level \= SAFETY\_LEVEL\_SAFE;
  gas\_data.leak\_detected \= 0;
  gas\_data.fire\_risk \= 2;
  
  /\* 无限循环 \*/
  while (1)
  {
    /\* 检查布防/撤防状态是否改变 \*/
    if (Bluetooth\_GetAndClearStatusChanged()) {
      uint8\_t armed\_status \= Bluetooth\_GetArmedStatus();
      DISPLAY\_ArmedStatus(armed\_status, 3000);
      
      if (armed\_status) {
        BUZZER\_LoudAlarm();
      } else {
        BUZZER\_Beep(100);
      }
    }
    
    /\* 读取传感器数据 \*/
    TEMP\_HUMI\_ReadData(&temperature, &humidity);
    if (LIGHT\_SENSOR\_IsConnected()) {
      LIGHT\_SENSOR\_ReadLight(&light);
    }
    ir\_status \= IR\_Sensor\_Detect();
    
    /\* 更新气体传感器数据 - 确保每次循环都更新 \*/
    uint16\_t adc\_value \= GAS\_SENSOR\_Read();
    if (adc\_value > 0) {
      GAS\_SENSOR\_UpdateData(&gas\_data);
    }
    
    /\* 人体检测处理 \*/
    if (ir\_status && !last\_ir\_status) {
      /\* 更新显示 \*/
      DISPLAY\_UpdateEnvData(temperature, humidity, light, ir\_status);
      DISPLAY\_GasData(&gas\_data);
      
      /\* 发送数据到蓝牙 - 恢复原来的两次发送格式 \*/
      /\* 第一次发送基本环境数据 \*/
      char bt\_data1\[150\];
      sprintf(bt\_data1, "{\\"temp\\":%.1f,\\"humi\\":%.1f,\\"light\\":%.1f,\\"human\\":%d,\\"aqi\\":%d,\\"pm25\\":%.1f}\\r\\n",
              temperature, humidity, light, ir\_status, gas\_data.aqi, gas\_data.pm25);
      Bluetooth\_SendString(bt\_data1);
      
      /\* 短暂延时，确保第一条数据发送完成 \*/
      HAL\_Delay(20);
      
      /\* 第二次发送气体详细数据 \*/
      char bt\_data2\[150\];
      sprintf(bt\_data2, "{\\"co2\\":%.1f,\\"ppm\\":%.1f,\\"gas\_type\\":%d,\\"safety\\":%d,\\"leak\\":%d,\\"fire\\":%d,\\"rate\\":%.2f}\\r\\n",
              gas\_data.co2\_equivalent, gas\_data.raw\_ppm, gas\_data.gas\_type, 
              gas\_data.safety\_level, gas\_data.leak\_detected, gas\_data.fire\_risk, gas\_data.change\_rate);
      Bluetooth\_SendString(bt\_data2);
      
      /\* 布防状态下发出警报 \*/
      if (Bluetooth\_GetArmedStatus()) {
        BUZZER\_EmergencyAlarm();
      }
    }
    last\_ir\_status \= ir\_status;
    
    /\* 更新显示 \*/
    DISPLAY\_UpdateEnvData(temperature, humidity, light, ir\_status);
    DISPLAY\_GasData(&gas\_data);
    
    /\* 处理蓝牙数据 \*/
    Bluetooth\_Process();
    
    /\* 每5秒通过蓝牙发送环境数据 \*/
    if (++bt\_send\_counter >= 5) {
      bt\_send\_counter \= 0;
      
      /\* 恢复原来的两次发送格式 \*/
      /\* 第一次发送基本环境数据 \*/
      char bt\_data1\[150\];
      sprintf(bt\_data1, "{\\"temp\\":%.1f,\\"humi\\":%.1f,\\"light\\":%.1f,\\"human\\":%d,\\"aqi\\":%d,\\"pm25\\":%.1f}\\r\\n",
              temperature, humidity, light, ir\_status, gas\_data.aqi, gas\_data.pm25);
      Bluetooth\_SendString(bt\_data1);
      
      /\* 短暂延时，确保第一条数据发送完成 \*/
      HAL\_Delay(50);
      
      /\* 第二次发送气体详细数据 \*/
      char bt\_data2\[150\];
      sprintf(bt\_data2, "{\\"co2\\":%.1f,\\"ppm\\":%.1f,\\"gas\_type\\":%d,\\"safety\\":%d,\\"leak\\":%d,\\"fire\\":%d,\\"rate\\":%.2f}\\r\\n",
              gas\_data.co2\_equivalent, gas\_data.raw\_ppm, gas\_data.gas\_type, 
              gas\_data.safety\_level, gas\_data.leak\_detected, gas\_data.fire\_risk, gas\_data.change\_rate);
      Bluetooth\_SendString(bt\_data2);
    }
    
    /\* 切换LED指示灯状态 \*/
    HAL\_GPIO\_TogglePin(GPIOC, GPIO\_PIN\_13);
    
    /\* 延时1秒 \*/
    HAL\_Delay(1000);
  }
}

/\*\*
  \* @brief 系统时钟配置
  \* @retval None
  \*/
void SystemClock\_Config(void)
{
  RCC\_OscInitTypeDef RCC\_OscInitStruct \= {0};
  RCC\_ClkInitTypeDef RCC\_ClkInitStruct \= {0};
  RCC\_PeriphCLKInitTypeDef PeriphClkInit \= {0};

  RCC\_OscInitStruct.OscillatorType \= RCC\_OSCILLATORTYPE\_HSE;
  RCC\_OscInitStruct.HSEState \= RCC\_HSE\_ON;
  RCC\_OscInitStruct.HSEPredivValue \= RCC\_HSE\_PREDIV\_DIV1;
  RCC\_OscInitStruct.HSIState \= RCC\_HSI\_ON;
  RCC\_OscInitStruct.PLL.PLLState \= RCC\_PLL\_ON;
  RCC\_OscInitStruct.PLL.PLLSource \= RCC\_PLLSOURCE\_HSE;
  RCC\_OscInitStruct.PLL.PLLMUL \= RCC\_PLL\_MUL9;
  HAL\_RCC\_OscConfig(&RCC\_OscInitStruct);

  RCC\_ClkInitStruct.ClockType \= RCC\_CLOCKTYPE\_HCLK|RCC\_CLOCKTYPE\_SYSCLK
                              |RCC\_CLOCKTYPE\_PCLK1|RCC\_CLOCKTYPE\_PCLK2;
  RCC\_ClkInitStruct.SYSCLKSource \= RCC\_SYSCLKSOURCE\_PLLCLK;
  RCC\_ClkInitStruct.AHBCLKDivider \= RCC\_SYSCLK\_DIV1;
  RCC\_ClkInitStruct.APB1CLKDivider \= RCC\_HCLK\_DIV2;
  RCC\_ClkInitStruct.APB2CLKDivider \= RCC\_HCLK\_DIV1;
  HAL\_RCC\_ClockConfig(&RCC\_ClkInitStruct, FLASH\_LATENCY\_2);
  
  /\* 配置ADC时钟 \*/
  PeriphClkInit.PeriphClockSelection \= RCC\_PERIPHCLK\_ADC;
  PeriphClkInit.AdcClockSelection \= RCC\_ADCPCLK2\_DIV6;
  HAL\_RCCEx\_PeriphCLKConfig(&PeriphClkInit);
}

/\*\*
  \* @brief GPIO初始化函数
  \* @param None
  \* @retval None
  \*/
void MX\_GPIO\_Init(void)
{
  GPIO\_InitTypeDef GPIO\_InitStruct \= {0};

  /\* 使能GPIO时钟 \*/
  \_\_HAL\_RCC\_GPIOC\_CLK\_ENABLE();
  \_\_HAL\_RCC\_GPIOD\_CLK\_ENABLE();
  \_\_HAL\_RCC\_GPIOA\_CLK\_ENABLE();
  \_\_HAL\_RCC\_GPIOB\_CLK\_ENABLE();

  /\* 配置PC13引脚为输出 \*/
  HAL\_GPIO\_WritePin(GPIOC, GPIO\_PIN\_13, GPIO\_PIN\_RESET);
  GPIO\_InitStruct.Pin \= GPIO\_PIN\_13;
  GPIO\_InitStruct.Mode \= GPIO\_MODE\_OUTPUT\_PP;
  GPIO\_InitStruct.Pull \= GPIO\_NOPULL;
  GPIO\_InitStruct.Speed \= GPIO\_SPEED\_FREQ\_LOW;
  HAL\_GPIO\_Init(GPIOC, &GPIO\_InitStruct);
  
  /\* 配置PA0引脚为模拟输入（气体传感器） \*/
  GPIO\_InitStruct.Pin \= GPIO\_PIN\_0;
  GPIO\_InitStruct.Mode \= GPIO\_MODE\_ANALOG;
  GPIO\_InitStruct.Pull \= GPIO\_NOPULL;
  HAL\_GPIO\_Init(GPIOA, &GPIO\_InitStruct);
}

/\*\*
  \* @brief I2C1初始化函数
  \* @param None
  \* @retval None
  \*/
void MX\_I2C1\_Init(void)
{
  hi2c1.Instance \= I2C1;
  hi2c1.Init.ClockSpeed \= 100000;
  hi2c1.Init.DutyCycle \= I2C\_DUTYCYCLE\_2;
  hi2c1.Init.OwnAddress1 \= 0;
  hi2c1.Init.AddressingMode \= I2C\_ADDRESSINGMODE\_7BIT;
  hi2c1.Init.DualAddressMode \= I2C\_DUALADDRESS\_DISABLE;
  hi2c1.Init.OwnAddress2 \= 0;
  hi2c1.Init.GeneralCallMode \= I2C\_GENERALCALL\_DISABLE;
  hi2c1.Init.NoStretchMode \= I2C\_NOSTRETCH\_DISABLE;
  
  HAL\_I2C\_Init(&hi2c1);
}

/\*\*
  \* @brief ADC1初始化函数
  \* @param None
  \* @retval None
  \*/
void MX\_ADC1\_Init(void)
{
  ADC\_ChannelConfTypeDef sConfig \= {0};

  /\* ADC1基本配置 \*/
  hadc1.Instance \= ADC1;
  hadc1.Init.ScanConvMode \= ADC\_SCAN\_DISABLE;
  hadc1.Init.ContinuousConvMode \= DISABLE;
  hadc1.Init.DiscontinuousConvMode \= DISABLE;
  hadc1.Init.ExternalTrigConv \= ADC\_SOFTWARE\_START;
  hadc1.Init.DataAlign \= ADC\_DATAALIGN\_RIGHT;
  hadc1.Init.NbrOfConversion \= 1;
  HAL\_ADC\_Init(&hadc1);

  /\* 配置ADC通道0（PA0引脚）- 气体传感器 \*/
  sConfig.Channel \= ADC\_CHANNEL\_0;
  sConfig.Rank \= ADC\_REGULAR\_RANK\_1;
  sConfig.SamplingTime \= ADC\_SAMPLETIME\_55CYCLES\_5;
  HAL\_ADC\_ConfigChannel(&hadc1, &sConfig);
  
  /\* 校准ADC \*/
  HAL\_ADCEx\_Calibration\_Start(&hadc1);
}

/\*\*
  \* @brief USART1初始化函数
  \* @param None
  \* @retval None
  \*/
void MX\_USART1\_UART\_Init(void)
{
  huart1.Instance \= USART1;
  huart1.Init.BaudRate \= 9600;
  huart1.Init.WordLength \= UART\_WORDLENGTH\_8B;
  huart1.Init.StopBits \= UART\_STOPBITS\_1;
  huart1.Init.Parity \= UART\_PARITY\_NONE;
  huart1.Init.Mode \= UART\_MODE\_TX\_RX;
  huart1.Init.HwFlowCtl \= UART\_HWCONTROL\_NONE;
  huart1.Init.OverSampling \= UART\_OVERSAMPLING\_16;
  
  HAL\_UART\_Init(&huart1);
  
  /\* 启用UART接收中断 \*/
  HAL\_NVIC\_SetPriority(USART1\_IRQn, 0, 0);
  HAL\_NVIC\_EnableIRQ(USART1\_IRQn);
}

/\*\*
  \* @brief 错误处理函数
  \* @retval None
  \*/
void Error\_Handler(void)
{
  \_\_disable\_irq();
  while (1)
  {
  }
}

#ifdef  USE\_FULL\_ASSERT
void assert\_failed(uint8\_t \*file, uint32\_t line)
{
  /\* 用户可以添加自己的实现来报告文件名和行号 \*/
}
#endif /\* USE\_FULL\_ASSERT \*/

7.​原理图
------

**欢迎在评论区交流讨论！​**