---
layout: post
title: '嵌入式Linux手动交叉编译开源软件需要注意的问题'
date: "2026-02-16T00:59:26Z"
---
嵌入式Linux手动交叉编译开源软件需要注意的问题
=========================

该文章主要提到了一些常见的编译错误及其解决方案，并提供了一些最佳实践，帮助开发者避免编译过程中的陷阱。通过这些建议，读者能够更高效地进行嵌入式Linux开发，减少编译和调试的时间。

在嵌入式Linux的开发过程中，我们经常需要用到一些软件库或者是测试工具，这些库和工具大概率都是x86平台上开发的，就需要我们通过对源码进行交叉编译，生成能够在开发板上使用的软件和动态库。

对于某些开源软件进行编译有两种情况，第一种是如果我们使用buildroot根文件系统，可以在buildroot的`menuconfig`编译菜单中，勾选相应的软件，重新编译根文件系统，编译完成之后该根文件系统就会自动带上对应的库和可执行程序，第二种是buildroot中无法找到我们需要的软件，这种情况下，只能够进行手动交叉编译，接下具体讲解下手动交叉编译开源软件可能遇到的一些问题

一、使用交叉编译工具链时常见问题
================

1.1 编译过程中头文件相关问题
----------------

交叉编译时我们可能会遇到找不到头文件的问题，我们都知道在x86平台上开发程序，程序中通过尖括号的方式包含头文件：`#include <xxx.h>`他会到系统目录下去查找所需要的头文件，一般情况在`/usr/include`或者`/usr/local/include`路径下，那么对于我们的交叉编译工具的系统目录又是哪里呢，我们可以通过以下命令来查看当前交叉编译工具对应的`include`系统路径在哪

    echo 'main(){}' | <交叉编译工具> -E -v -
    

这个命令利用 `gcc` 的预处理（`-E`）和详细输出（`-v`）功能，帮助查看编译器查找头文件和库文件的路径。适用于调试和理解交叉编译器的工作原理，尤其是在处理不同平台和工具链时。下面在我的平台中举例，我使用rk3576的SDK中自带的交叉编译工具，执行如上命令之后，输出结果如下图所示  
![Pasted image 20260215184437.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541237-2069199422.png)  
可以看见，该命令将`#include ""`和`#include <>`会查找的路径都打印了出来，对于源文件中通过`#include ""`的头文件，该编译器会到源文件当前路径下查找，对与原文件中通过`#include <>`的头文件，`aarch64-none-linux-gnuu-gcc`编译器会去以下三个路径中去查找，而不是x86平台下的系统路径中去查找。如果在我们交叉编译过程中，缺少某些头文件，我们就可以把对应头文件拷贝到这些目录中去，放到任意一个路径下就行。

    /home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/../lib/gcc/aarch64-none-linux-gnu/10.3.1/include  
    /home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/../lib/gcc/aarch64-none-linux-gnu/10.3.1/include-fixed  
    /home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/../lib/gcc/aarch64-none-linux-gnu/10.3.1/../../../../aarch64-none-linux-gnu/inclu  
    de
    

除了上面这种方法，也可以直接在编译源文件的时候在后面加上`-v`选项查看详细的编译信息，例如我这里编译一个usb相关的应用程序，下面是我执行交叉编译的命令，后面加上了`-v`来显示具体的编译信息

    /home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcc usb1.c -o usb1 -v
    

执行结果如下  
![Pasted image 20260215203358.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541189-1040648713.png)  
这里可以看见上面所讲的交叉编译工具的头文件系统路径，同时也报出一个错误，无法找到`libusb.h`文件，因为我没有吧对应头文件拷贝到红框中的任何一个头文件路径中去，也没有通过`-I`命令手动指定。接下来我将通过手动指定的方式来展示加了这个选项之后的变化。

上面提到了除了使用系统目录外，也可以自己指定目录：编译时用`-I<path>`选项指定。编译时，编译器会优先使用通过`-I`指定的路径，因为如果指定了`-I`选项，该选项的路径会放到最前面，接着上面的报错，我加入了`-I`选项之后  
![Pasted image 20260215203743.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541172-1625023185.png)  
可以看见`-I`选项指定的路径优先级排到了最前面

1.2 编译过程中库文件问题
--------------

在交叉编译链接程序时如果有这样的提示：`undefined reference to xxx`，它表示 `xxx` 函数未定义。出现这个错误主要是有两种情况，第一就是交叉编译工具的系统库文件路径中没有相应的库，第二就是编译源码使用的库的版本和当前系统中库的版本不同，库的差异导致报错。解决方法要么去写出这个函数，或是使用库函数，那需要在链接时指定库。那么我们如何确定交叉编译工具对应的系统库文件在哪里？同样执行相同命令确定目录

    echo 'main(){}' | <交叉编译工具> -E -v -
    

当然也可以在编译命令后加上`-v`选项  
![Pasted image 20260215185448.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541242-413123482.png)  
可以看到红框部分打印出了`LIBRARY_PATH`这个宏，这个宏就表示的是交叉编译工具在链接时，会到这些路径下去查找库文件，当我们缺少库文件时，可以将库文件拷贝到这些目录下的任意一个路径就行，同样我们也可以自己指定链接库的路径，链接时用`-L<path>`选项指定，编译时，编译器会优先使用通过`-L`指定的路径

当我们已经将需要链接的库拷贝到对应的系统库文件路径下之后，或者我们已经通过`-L`选项指定了库路径之后，我们想要链接库应该如何操作？例如我们想要链接`libpthread.so`，那么我们在编译链接时就需要加上`-lpthread`的编译选项。就可以正常编译程序了。

到此，我们已经知道了，编译一个开源软件时，如果出现了问题，应该如何查找交叉编译工具的头文件路径和库文件路径，主要用来处理一些开源软件编译过程中，依赖缺失的问题，例如我现在需要编译一个软件，但是缺少其他软件的库依赖，那么我们就需要先交叉编译依赖库，然后将编译出来的库以及对应头文件拷贝到交叉编译工具对应的头文件和库文件的系统目录下，再编译我们的目标软件，这里需要注意的一点就是，编译出来的`lib`文件，有一些可能是一个库软连接到了另一个库上，所以在拷贝的时候需要使用`cp -drf`命令来拷贝，避免破坏软连接

那么通过`-I`和`-L`指定路径与将依赖头文件与库拷贝到已有的路径中，有什么区别？区别就是如果使用指定路径的方式，在每次编译的时候都需要重新输一遍路径，这对于只用编译一次的情景还行，如果是之后的应用开发会经常用到这个库，还是建议将库拷贝到交叉编译器默认的系统库和头文件路径中去，避免每次编译的时候都重新敲一遍路径。

1.3 运行过程中找不到库相关问题
-----------------

如果在执行可执行程序的时候，出现找不到某各库的问题，说明当前的系统库路径下缺少这个库，只需要将运行需要的库，拷贝到对应的链接库目录下就能解决这个问题

    error while loading shared libraries: libxxx.so:
    cannot open shared object file: No such file or directory
    

对应的系统库路径在哪？一般系统目录就是板子上的`/lib`、`/usr/lib`目录，当前也可以自己指定，运行程序用环境变量 `LD_LIBRARY_PATH` 指定，执行以下的命令来添加一个新的库路径

    export LD_LIBRARY_PATH=/xxx_dir
    

程序运行时，并不需要头文件，如果不在开发板上编译，那么头文件不用拷贝到开发板上