---
layout: post
title: '.NET驾驭Word之力：基于规则自动生成及排版Word文档'
date: "2025-10-21T00:41:10Z"
---
.NET驾驭Word之力：基于规则自动生成及排版Word文档
==============================

.NET驾驭Word之力：基于规则自动生成及排版Word文档
==============================

> 在现代办公环境中，自动化文档生成和排版已经成为提高工作效率的重要手段。MudTools.OfficeInterop.Word 是一个强大的 .NET 库，它封装了 Microsoft Word 的 COM 组件，让开发者能够以面向对象的方式轻松操作 Word 文档。本文将详细介绍如何使用这个库来实现自动生成合同条款、自动排版、创建嵌套表格、生成文档大纲和目录等功能。

简介
--

MudTools.OfficeInterop 是一个针对 Microsoft Office 应用程序（Excel、Word、PowerPoint、VBE）的 .NET 封装库，旨在简化对 Office COM 组件的操作。它提供现代化、面向对象的 API 接口，使得开发者可以更轻松地处理 Office 文档。其中 Word 模块专门用于操作 Microsoft Word 应用程序，提供了完整的 Word 文档操作接口。

环境准备
----

在开始使用 MudTools.OfficeInterop.Word 之前，需要确保具备以下环境：

1.  Windows 操作系统（因依赖 Office COM）
2.  Microsoft Office 或 WPS Office 安装（2007 或更高版本）
3.  .NET SDK（.NET Framework 4.6.2+ 或 .NET Standard 2.1 或 .NET 6.0-windows 及以上）

通过 NuGet 安装所需的包：

    <PackageReference Include="MudTools.OfficeInterop.Word" Version="1.2.0" />
    

MudTools.OfficeInterop.Word 采用了工厂模式设计，通过 [WordFactory](https://gitee.com/mudtools/OfficeInterop/tree/master/MudTools.OfficeInterop.Word/WordFactory.cs) 类来创建和操作 Word 应用程序实例。这种方式使得开发者可以以统一的方式创建不同类型的文档，而无需关心底层的 COM 对象创建细节。

创建 Word 应用程序实例
--------------

MudTools.OfficeInterop.Word 提供了 [WordFactory](https://gitee.com/mudtools/OfficeInterop/tree/master/MudTools.OfficeInterop.Word/WordFactory.cs) 类来创建和操作 Word 应用程序实例。WordFactory 提供了以下方法：

*   `BlankWorkbook()` - 创建新的空白 Word 文档
*   `CreateFrom(string templatePath)` - 基于模板创建新的 Word 文档
*   `Open(string filePath)` - 打开现有的 Word 文档文件

下面是一个简单的示例，展示如何创建一个空白 Word 文档：

    using MudTools.OfficeInterop;
    
    // 创建 Word 应用程序实例
    using var app = WordFactory.BlankWorkbook();
    app.Visible = true;
    
    var document = app.ActiveDocument;
    

使用 `using` 语句可以确保 Word 应用程序实例在使用完毕后被正确释放，避免出现内存泄漏等问题。通过设置 `app.Visible = true`，可以在操作过程中查看 Word 应用程序的界面，便于调试和演示。

自动生成合同条款
--------

在业务场景中，我们经常需要根据预设的模板和数据自动生成合同条款。MudTools.OfficeInterop.Word 提供了强大的功能来实现这一点。通过基于规则的生成方式，我们可以更加灵活地创建各种类型的合同。

### 基于规则的合同条款生成

基于规则的合同条款生成是指通过定义一套规则和模板，系统可以根据输入的数据自动选择和生成相应的合同条款。这种方法可以大大提高合同生成的效率和一致性。

这种方法的核心思想是将合同条款的结构和内容与具体的业务数据分离。通过定义规则模板，我们可以创建一个灵活的系统，能够适应不同类型的合同需求，而无需修改代码。这种方式特别适用于需要大量生成标准化合同的场景，如人力资源部门的劳动合同、法务部门的各种业务合同等。

首先，我们需要定义合同条款的规则和模板：

    {
      "contractRules": {
        "serviceContract": {
          "title": "服务合同",
          "clauses": [
            {
              "id": "clause1",
              "title": "服务内容",
              "template": "甲方委托乙方提供{service_type}服务，具体包括：{service_details}。",
              "requiredFields": ["service_type", "service_details"]
            },
            {
              "id": "clause2",
              "title": "服务期限",
              "template": "本合同服务期限为{duration}，自{start_date}起至{end_date}止。",
              "requiredFields": ["duration", "start_date", "end_date"]
            },
            {
              "id": "clause3",
              "title": "服务费用",
              "template": "本合同总金额为人民币{amount}元（大写：{amount_capital}）。",
              "requiredFields": ["amount", "amount_capital"]
            }
          ]
        },
        "employmentContract": {
          "title": "劳动合同",
          "clauses": [
            {
              "id": "clause1",
              "title": "工作内容",
              "template": "甲方聘用乙方在{department}部门担任{position}职务，工作内容包括：{responsibilities}。",
              "requiredFields": ["department", "position", "responsibilities"]
            },
            {
              "id": "clause2",
              "title": "工作时间和休假",
              "template": "乙方每日工作{hours_per_day}小时，每周工作{days_per_week}天。按照国家规定享受带薪年假。",
              "requiredFields": ["hours_per_day", "days_per_week"]
            },
            {
              "id": "clause3",
              "title": "薪酬待遇",
              "template": "甲方每月支付乙方基本工资人民币{base_salary}元，绩效奖金根据考核结果发放。",
              "requiredFields": ["base_salary"]
            }
          ]
        }
      }
    }
    

在上述配置中，我们定义了两种类型的合同规则：服务合同和劳动合同。每种合同类型都包含若干条款，每个条款都有一个模板和必需字段列表。通过这种方式，我们可以灵活地定义各种合同类型及其条款。

### 实现基于规则的合同生成器

    using MudTools.OfficeInterop;
    using System;
    using System.Collections.Generic;
    using System.IO;
    using Newtonsoft.Json;
    
    // 合同条款定义
    public class ContractClause
    {
        public string Id { get; set; }
        public string Title { get; set; }
        public string Template { get; set; }
        public List<string> RequiredFields { get; set; }
    }
    
    // 合同规则定义
    public class ContractRule
    {
        public string Title { get; set; }
        public List<ContractClause> Clauses { get; set; }
    }
    
    // 合同规则配置
    public class ContractRulesConfig
    {
        public Dictionary<string, ContractRule> ContractRules { get; set; }
    }
    
    // 合同数据
    public class ContractData
    {
        public string ContractType { get; set; }
        public Dictionary<string, string> Fields { get; set; }
        public string PartyA { get; set; }
        public string PartyB { get; set; }
        public DateTime SignDate { get; set; }
    }
    
    class RuleBasedContractGenerator
    {
        public static void GenerateContractFromRules(string rulesConfigPath, ContractData contractData)
        {
            try
            {
                // 加载规则配置
                var rulesConfig = LoadRulesConfig(rulesConfigPath);
                
                // 创建 Word 文档
                using var app = WordFactory.BlankWorkbook();
                app.Visible = true;
                var document = app.ActiveDocument;
                
                // 设置文档属性
                document.Title = $"{rulesConfig.ContractRules[contractData.ContractType].Title}";
                
                // 添加合同标题
                AddContractTitle(document, rulesConfig.ContractRules[contractData.ContractType].Title);
                
                // 添加合同双方信息
                AddPartiesInfo(document, contractData.PartyA, contractData.PartyB, contractData.SignDate);
                
                // 根据规则生成合同条款
                GenerateClauses(document, rulesConfig.ContractRules[contractData.ContractType], contractData.Fields);
                
                // 添加签名部分
                AddSignatureSection(document, contractData.PartyA, contractData.PartyB, contractData.SignDate);
                
                // 保存文档
                document.SaveAs($@"C:\contracts\{contractData.ContractType}_{DateTime.Now:yyyyMMddHHmmss}.docx");
                
                Console.WriteLine("合同已根据规则成功生成");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"生成合同时出错: {ex.Message}");
            }
        }
        
        private static ContractRulesConfig LoadRulesConfig(string configPath)
        {
            try
            {
                var json = File.ReadAllText(configPath);
                return JsonConvert.DeserializeObject<ContractRulesConfig>(json);
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"读取规则配置文件失败: {ex.Message}", ex);
            }
        }
        
        private static void AddContractTitle(IWordDocument document, string title)
        {
            var range = document.Range();
            range.Text = $"{title}\n";
            range.Font.Name = "微软雅黑";
            range.Font.Size = 18;
            range.Font.Bold = 1;
            range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
            range.ParagraphFormat.SpaceAfter = 24;
        }
        
        private static void AddPartiesInfo(IWordDocument document, string partyA, string partyB, DateTime signDate)
        {
            var range = document.Range(document.Content.End - 1, document.Content.End - 1);
            range.Text = $"甲方：{partyA}\n乙方：{partyB}\n签订日期：{signDate:yyyy年MM月dd日}\n\n";
            range.Font.Name = "宋体";
            range.Font.Size = 12;
            range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphLeft;
            range.ParagraphFormat.SpaceAfter = 12;
        }
        
        private static void GenerateClauses(IWordDocument document, ContractRule contractRule, Dictionary<string, string> fields)
        {
            foreach (var clause in contractRule.Clauses)
            {
                // 检查必需字段是否存在
                if (!CheckRequiredFields(clause, fields))
                {
                    throw new InvalidOperationException($"条款 '{clause.Title}' 缺少必需字段");
                }
                
                // 生成条款编号和标题
                AddClauseHeader(document, clause.Id, clause.Title);
                
                // 根据模板生成条款内容
                var clauseContent = GenerateClauseContent(clause.Template, fields);
                AddClauseContent(document, clauseContent);
            }
        }
        
        private static bool CheckRequiredFields(ContractClause clause, Dictionary<string, string> fields)
        {
            foreach (var requiredField in clause.RequiredFields)
            {
                if (!fields.ContainsKey(requiredField) || string.IsNullOrEmpty(fields[requiredField]))
                {
                    return false;
                }
            }
            return true;
        }
        
        private static string GenerateClauseContent(string template, Dictionary<string, string> fields)
        {
            var content = template;
            foreach (var field in fields)
            {
                content = content.Replace($"{{{field.Key}}}", field.Value);
            }
            return content;
        }
        
        private static void AddClauseHeader(IWordDocument document, string clauseId, string clauseTitle)
        {
            var range = document.Range(document.Content.End - 1, document.Content.End - 1);
            range.Text = $"{clauseId} {clauseTitle}\n";
            range.Font.Bold = 1;
            range.Font.Size = 12;
            range.ParagraphFormat.SpaceAfter = 6;
        }
        
        private static void AddClauseContent(IWordDocument document, string content)
        {
            var range = document.Range(document.Content.End - 1, document.Content.End - 1);
            range.Text = $"{content}\n\n";
            range.Font.Bold = 0;
            range.Font.Size = 12;
            range.ParagraphFormat.SpaceAfter = 12;
        }
        
        private static void AddSignatureSection(IWordDocument document, string partyA, string partyB, DateTime signDate)
        {
            // 添加签名标题
            var signTitleRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            signTitleRange.Text = "\n（以下无正文）\n\n甲方（盖章）：\t\t\t\t\t乙方（盖章）：\n";
            signTitleRange.Font.Bold = 1;
            
            // 添加签名线
            var signLineRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            signLineRange.Text = "法定代表人或授权代表：\t\t\t\t法定代表人或授权代表：\n";
            
            // 添加日期行
            var dateRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            dateRange.Text = $"签订日期：{signDate:yyyy年MM月dd日}\t\t\t\t签订日期：{signDate:yyyy年MM月dd日}\n";
        }
    }
    

### 使用示例

#### 示例1：生成服务合同

    class ServiceContractExample
    {
        public static void GenerateServiceContract()
        {
            var contractData = new ContractData
            {
                ContractType = "serviceContract",
                PartyA = "ABC科技有限公司",
                PartyB = "XYZ集团",
                SignDate = DateTime.Now,
                Fields = new Dictionary<string, string>
                {
                    ["service_type"] = "软件开发",
                    ["service_details"] = "企业资源管理系统开发、部署和维护",
                    ["duration"] = "90天",
                    ["start_date"] = DateTime.Now.ToString("yyyy年MM月dd日"),
                    ["end_date"] = DateTime.Now.AddDays(90).ToString("yyyy年MM月dd日"),
                    ["amount"] = "500,000.00",
                    ["amount_capital"] = "伍拾万元整"
                }
            };
            
            RuleBasedContractGenerator.GenerateContractFromRules(@"C:\config\contractRules.json", contractData);
        }
    }
    

#### 示例2：生成劳动合同

    class EmploymentContractExample
    {
        public static void GenerateEmploymentContract()
        {
            var contractData = new ContractData
            {
                ContractType = "employmentContract",
                PartyA = "ABC科技有限公司",
                PartyB = "张三",
                SignDate = DateTime.Now,
                Fields = new Dictionary<string, string>
                {
                    ["department"] = "技术部",
                    ["position"] = "高级软件工程师",
                    ["responsibilities"] = "负责系统架构设计、核心代码编写和技术团队管理",
                    ["hours_per_day"] = "8",
                    ["days_per_week"] = "5",
                    ["base_salary"] = "25,000.00"
                }
            };
            
            RuleBasedContractGenerator.GenerateContractFromRules(@"C:\config\contractRules.json", contractData);
        }
    }
    

### 高级功能扩展

基于规则的合同生成系统还可以进一步扩展，以支持更复杂的业务需求：

1.  **条件条款**：根据特定条件选择不同的条款模板
2.  **条款依赖**：某些条款的出现依赖于其他条款的选择
3.  **动态计算**：自动计算金额、日期等字段
4.  **版本控制**：管理不同版本的合同模板和规则

    // 扩展示例：支持条件条款
    public class ConditionalContractClause
    {
        public string Id { get; set; }
        public string Title { get; set; }
        public string Template { get; set; }
        public List<string> RequiredFields { get; set; }
        public string ConditionField { get; set; }  // 条件字段
        public List<string> ConditionValues { get; set; }  // 条件值
    }
    
    // 扩展示例：支持动态计算
    public class CalculatedField
    {
        public string FieldName { get; set; }
        public string CalculationRule { get; set; }  // 计算规则，如"amount * 0.1"
    }
    

通过基于规则的合同条款生成系统，我们可以：

1.  **提高效率**：自动生成合同，减少人工编写时间
2.  **保证一致性**：使用标准化的条款模板，确保合同条款的一致性
3.  **降低错误率**：减少手工输入错误
4.  **灵活配置**：通过修改规则配置适应不同的合同类型
5.  **易于维护**：条款模板和业务规则分离，便于维护和更新

这种方法特别适用于需要大量生成标准化合同的场景，如人力资源部门的劳动合同、法务部门的各种业务合同等。

自动文档排版
------

MudTools.OfficeInterop.Word 提供了丰富的格式化功能，可以实现自动文档排版。我们可以通过从JSON配置文件中读取预设的格式信息，然后应用到文档中。

文档排版是文档自动化中的一个重要环节。良好的排版不仅能够提升文档的专业性，还能增强读者的阅读体验。通过将排版规则外部化，我们可以实现排版样式与代码的分离，使得排版调整变得更加灵活和可维护。

### 从JSON配置文件读取格式设置

首先，我们需要定义一个JSON配置文件来存储文档格式设置：

    {
      "documentStyles": {
        "normal": {
          "fontName": "宋体",
          "fontSize": 12,
          "lineSpacing": 1.5
        },
        "heading1": {
          "fontName": "黑体",
          "fontSize": 16,
          "bold": true,
          "spaceAfter": 12
        },
        "heading2": {
          "fontName": "楷体",
          "fontSize": 14,
          "bold": true,
          "spaceAfter": 10
        },
        "heading3": {
          "fontName": "仿宋",
          "fontSize": 12,
          "bold": true,
          "spaceAfter": 8
        }
      },
      "pageLayout": {
        "orientation": "portrait",
        "marginTop": 72,
        "marginBottom": 72,
        "marginLeft": 72,
        "marginRight": 72
      },
      "headerFooter": {
        "headerText": "公司机密",
        "showPageNumbers": true
      }
    }
    

在上述配置中，我们定义了文档的各种样式设置，包括正文、各级标题的字体、字号、行距等属性。同时，我们还定义了页面布局和页眉页脚的设置。通过这种方式，我们可以轻松地调整文档的整体外观，而无需修改代码。

### 实现格式读取和应用

    using MudTools.OfficeInterop;
    using System;
    using System.IO;
    using Newtonsoft.Json;
    
    // 定义JSON配置对应的类
    public class DocumentStyleConfig
    {
        public string FontName { get; set; }
        public int FontSize { get; set; }
        public bool Bold { get; set; }
        public float SpaceAfter { get; set; }
        public double LineSpacing { get; set; }
    }
    
    public class PageLayoutConfig
    {
        public string Orientation { get; set; }
        public float MarginTop { get; set; }
        public float MarginBottom { get; set; }
        public float MarginLeft { get; set; }
        public float MarginRight { get; set; }
    }
    
    public class HeaderFooterConfig
    {
        public string HeaderText { get; set; }
        public bool ShowPageNumbers { get; set; }
    }
    
    public class DocumentFormatConfig
    {
        public Dictionary<string, DocumentStyleConfig> DocumentStyles { get; set; }
        public PageLayoutConfig PageLayout { get; set; }
        public HeaderFooterConfig HeaderFooter { get; set; }
    }
    
    class DocumentFormatter
    {
        public static void FormatDocumentFromConfig(string configPath)
        {
            try
            {
                using var app = WordFactory.BlankWorkbook();
                var document = app.ActiveDocument;
                
                // 从JSON文件读取配置
                var config = LoadFormatConfig(configPath);
                
                // 应用文档样式
                ApplyDocumentStyles(document, config.DocumentStyles);
                
                // 设置页面布局
                ApplyPageLayout(document, config.PageLayout);
                
                // 设置页眉页脚
                ApplyHeaderFooter(document, config.HeaderFooter);
                
                // 添加内容并应用样式
                AddFormattedContent(document);
                
                document.SaveAs(@"C:\temp\FormattedDocument.docx");
                Console.WriteLine("文档已根据配置文件格式化并保存");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"格式化文档时出错: {ex.Message}");
            }
        }
        
        private static DocumentFormatConfig LoadFormatConfig(string configPath)
        {
            try
            {
                var json = File.ReadAllText(configPath);
                return JsonConvert.DeserializeObject<DocumentFormatConfig>(json);
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"读取配置文件失败: {ex.Message}", ex);
            }
        }
        
        private static void ApplyDocumentStyles(IWordDocument document, Dictionary<string, DocumentStyleConfig> styles)
        {
            try
            {
                // 设置正文样式
                if (styles.TryGetValue("normal", out var normalStyleConfig))
                {
                    var normalStyle = document.Styles["正文"];
                    normalStyle.Font.Name = normalStyleConfig.FontName;
                    normalStyle.Font.Size = normalStyleConfig.FontSize;
                    // 注意：这里可能需要根据实际API调整行距设置方式
                }
                
                // 设置标题1样式
                if (styles.TryGetValue("heading1", out var heading1StyleConfig))
                {
                    var heading1Style = document.Styles["标题 1"];
                    heading1Style.Font.Name = heading1StyleConfig.FontName;
                    heading1Style.Font.Size = heading1StyleConfig.FontSize;
                    if (heading1StyleConfig.Bold)
                        heading1Style.Font.Bold = 1;
                    heading1Style.ParagraphFormat.SpaceAfter = heading1StyleConfig.SpaceAfter;
                }
                
                // 设置标题2样式
                if (styles.TryGetValue("heading2", out var heading2StyleConfig))
                {
                    var heading2Style = document.Styles["标题 2"];
                    heading2Style.Font.Name = heading2StyleConfig.FontName;
                    heading2Style.Font.Size = heading2StyleConfig.FontSize;
                    if (heading2StyleConfig.Bold)
                        heading2Style.Font.Bold = 1;
                    heading2Style.ParagraphFormat.SpaceAfter = heading2StyleConfig.SpaceAfter;
                }
                
                // 设置标题3样式
                if (styles.TryGetValue("heading3", out var heading3StyleConfig))
                {
                    var heading3Style = document.Styles["标题 3"];
                    heading3Style.Font.Name = heading3StyleConfig.FontName;
                    heading3Style.Font.Size = heading3StyleConfig.FontSize;
                    if (heading3StyleConfig.Bold)
                        heading3Style.Font.Bold = 1;
                    heading3Style.ParagraphFormat.SpaceAfter = heading3StyleConfig.SpaceAfter;
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"应用文档样式时出错: {ex.Message}", ex);
            }
        }
        
        private static void ApplyPageLayout(IWordDocument document, PageLayoutConfig pageLayout)
        {
            try
            {
                // 设置页面方向
                bool isLandscape = pageLayout.Orientation.ToLower() == "landscape";
                document.SetPageOrientation(isLandscape);
                
                // 设置页边距
                document.SetMargins(
                    pageLayout.MarginTop,
                    pageLayout.MarginBottom,
                    pageLayout.MarginLeft,
                    pageLayout.MarginRight
                );
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"设置页面布局时出错: {ex.Message}", ex);
            }
        }
        
        private static void ApplyHeaderFooter(IWordDocument document, HeaderFooterConfig headerFooter)
        {
            try
            {
                // 添加页眉
                if (!string.IsNullOrEmpty(headerFooter.HeaderText))
                {
                    document.AddHeader(headerFooter.HeaderText);
                }
                
                // 添加页脚（页码）
                if (headerFooter.ShowPageNumbers)
                {
                    document.AddFooter($"第 \\page 页 共 \\numpages 页");
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"设置页眉页脚时出错: {ex.Message}", ex);
            }
        }
        
        private static void AddFormattedContent(IWordDocument document)
        {
            // 添加标题
            var titleRange = document.Range();
            titleRange.Text = "文档标题\n";
            titleRange.Style = "标题 1";
            
            // 添加正文
            var contentRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            contentRange.Text = "这是文档的正文内容。在这里我们可以添加大量的文本内容来演示自动排版功能。\n\n";
            contentRange.Style = "正文";
            
            // 添加子标题
            var subTitleRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            subTitleRange.Text = "第一个子标题\n";
            subTitleRange.Style = "标题 2";
            
            // 添加更多正文
            var moreContentRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            moreContentRange.Text = "这是子标题下的内容。我们可以继续添加更多文本以展示格式化效果。\n\n";
            moreContentRange.Style = "正文";
        }
    }
    

通过这种方式，我们可以将文档格式设置与代码分离，使得格式调整变得更加灵活和可维护。当需要修改文档样式时，只需要修改JSON配置文件，而无需重新编译代码。

创建嵌套表格
------

表格是 Word 文档中组织数据的重要工具。MudTools.OfficeInterop.Word 提供了完整的表格操作功能，包括创建嵌套表格。

在实际业务场景中，我们经常需要创建复杂的表格结构来展示层次化的数据。嵌套表格是一种非常有用的技巧，它允许我们在一个表格单元格内创建另一个表格，从而实现更加复杂的数据展示效果。

### 创建基本表格

    using MudTools.OfficeInterop;
    using System;
    
    class TableCreator
    {
        public static void CreateBasicTable()
        {
            try
            {
                using var app = WordFactory.BlankWorkbook();
                var document = app.ActiveDocument;
                
                // 创建表格
                var tableRange = document.Range(document.Content.End - 1, document.Content.End - 1);
                var table = document.Tables.Add(tableRange, 4, 3);
                
                // 填充表头
                table.Cell(1, 1).Range.Text = "姓名";
                table.Cell(1, 2).Range.Text = "部门";
                table.Cell(1, 3).Range.Text = "职位";
                
                // 填充数据
                string[,] data = {
                    {"张三", "技术部", "软件工程师"},
                    {"李四", "市场部", "市场专员"},
                    {"王五", "人事部", "HR专员"}
                };
                
                for (int i = 0; i < data.GetLength(0); i++)
                {
                    for (int j = 0; j < data.GetLength(1); j++)
                    {
                        table.Cell(i + 2, j + 1).Range.Text = data[i, j];
                    }
                }
                
                // 格式化表格
                FormatTable(table);
                
                document.SaveAs(@"C:\temp\BasicTable.docx");
                Console.WriteLine("基本表格已创建");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"创建基本表格时出错: {ex.Message}");
            }
        }
        
        private static void FormatTable(IWordTable table)
        {
            // 设置表格边框
            table.Borders.Enable = 1;
            table.Borders[WdBorderType.wdBorderTop].LineStyle = WdLineStyle.wdLineStyleSingle;
            table.Borders[WdBorderType.wdBorderLeft].LineStyle = WdLineStyle.wdLineStyleSingle;
            table.Borders[WdBorderType.wdBorderBottom].LineStyle = WdLineStyle.wdLineStyleSingle;
            table.Borders[WdBorderType.wdBorderRight].LineStyle = WdLineStyle.wdLineStyleSingle;
            
            // 格式化表头
            for (int i = 1; i <= 3; i++)
            {
                var cell = table.Cell(1, i);
                cell.Range.Font.Bold = 1;
                cell.Range.Font.Color = WdColor.wdColorWhite;
                cell.Shading.BackgroundPatternColor = WdColor.wdColorDarkBlue;
                cell.Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
            }
            
            // 格式化数据行
            for (int row = 2; row <= 4; row++)
            {
                for (int col = 1; col <= 3; col++)
                {
                    var cell = table.Cell(row, col);
                    cell.Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
                    
                    // 交替行颜色
                    if (row % 2 == 0)
                    {
                        cell.Shading.BackgroundPatternColor = WdColor.wdColorGray10;
                    }
                }
            }
        }
    }
    

在上述代码中，我们创建了一个包含员工信息的基本表格。通过设置边框、背景色和对齐方式，使表格更加美观和易读。

### 创建嵌套表格

嵌套表格是在一个表格单元格内创建另一个表格，这在复杂数据展示中非常有用：

    using MudTools.OfficeInterop;
    using System;
    
    class NestedTableCreator
    {
        public static void CreateNestedTable()
        {
            try
            {
                using var app = WordFactory.BlankWorkbook();
                var document = app.ActiveDocument;
                
                // 创建外层表格
                var outerTableRange = document.Range(document.Content.End - 1, document.Content.End - 1);
                var outerTable = document.Tables.Add(outerTableRange, 3, 2);
                
                // 设置外层表格标题
                outerTable.Cell(1, 1).Range.Text = "项目名称";
                outerTable.Cell(1, 2).Range.Text = "项目详情";
                
                // 填充外层表格数据
                outerTable.Cell(2, 1).Range.Text = "Web应用开发";
                outerTable.Cell(3, 1).Range.Text = "移动应用开发";
                
                // 在外层表格的单元格中创建嵌套表格
                CreateNestedTableInCell(outerTable.Cell(2, 2));
                CreateNestedTableInCell(outerTable.Cell(3, 2));
                
                // 格式化外层表格
                FormatOuterTable(outerTable);
                
                document.SaveAs(@"C:\temp\NestedTable.docx");
                Console.WriteLine("嵌套表格已创建");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"创建嵌套表格时出错: {ex.Message}");
            }
        }
        
        private static void CreateNestedTableInCell(IWordCell cell)
        {
            // 在单元格中创建嵌套表格
            var nestedTable = cell.Tables.Add(cell.Range, 3, 2);
            
            // 填充嵌套表格数据
            nestedTable.Cell(1, 1).Range.Text = "任务";
            nestedTable.Cell(1, 2).Range.Text = "状态";
            nestedTable.Cell(2, 1).Range.Text = "需求分析";
            nestedTable.Cell(2, 2).Range.Text = "完成";
            nestedTable.Cell(3, 1).Range.Text = "UI设计";
            nestedTable.Cell(3, 2).Range.Text = "进行中";
            
            // 格式化嵌套表格
            FormatNestedTable(nestedTable);
        }
        
        private static void FormatOuterTable(IWordTable table)
        {
            // 设置表格边框
            table.Borders.Enable = 1;
            
            // 格式化表头
            var headerCell = table.Cell(1, 1);
            headerCell.Merge(table.Cell(1, 2)); // 合并表头单元格
            headerCell.Range.Font.Bold = 1;
            headerCell.Range.Font.Size = 14;
            headerCell.Shading.BackgroundPatternColor = WdColor.wdColorLightBlue;
            headerCell.Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
            
            // 格式化数据行
            for (int row = 2; row <= 3; row++)
            {
                for (int col = 1; col <= 2; col++)
                {
                    var cell = table.Cell(row, col);
                    cell.Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
                }
            }
        }
        
        private static void FormatNestedTable(IWordTable table)
        {
            // 设置嵌套表格边框
            table.Borders.Enable = 1;
            table.Borders.LineStyle = WdLineStyle.wdLineStyleDot;
            
            // 格式化嵌套表格表头
            var headerCell1 = table.Cell(1, 1);
            var headerCell2 = table.Cell(1, 2);
            headerCell1.Range.Font.Bold = 1;
            headerCell2.Range.Font.Bold = 1;
            headerCell1.Shading.BackgroundPatternColor = WdColor.wdColorGray25;
            headerCell2.Shading.BackgroundPatternColor = WdColor.wdColorGray25;
            headerCell1.Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
            headerCell2.Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
        }
    }
    

嵌套表格在实际应用中非常有用，特别是在需要展示层次化数据时。例如，在项目管理文档中，我们可能需要在项目列表中详细描述每个项目的任务分配情况。通过嵌套表格，我们可以清晰地展示这种层次关系，使文档结构更加清晰。

生成文档大纲
------

文档大纲可以帮助读者快速了解文档结构，MudTools.OfficeInterop.Word 提供了设置段落大纲级别的功能。

文档大纲是一种非常有用的文档组织方式，它允许读者通过展开或折叠不同的章节来浏览文档内容。通过设置段落的大纲级别，我们可以创建一个结构清晰的文档，便于读者快速定位感兴趣的内容。

### 设置段落大纲级别

    using MudTools.OfficeInterop;
    using System;
    
    class DocumentOutlineCreator
    {
        public static void CreateDocumentOutline()
        {
            try
            {
                using var app = WordFactory.BlankWorkbook();
                var document = app.ActiveDocument;
                
                // 添加标题
                AddHeading(document, "文档标题", WdOutlineLevel.wdOutlineLevel1);
                
                // 添加章节标题
                AddHeading(document, "第一章 简介", WdOutlineLevel.wdOutlineLevel1);
                AddHeading(document, "1.1 背景", WdOutlineLevel.wdOutlineLevel2);
                AddHeading(document, "1.2 目标", WdOutlineLevel.wdOutlineLevel2);
                
                AddHeading(document, "第二章 技术方案", WdOutlineLevel.wdOutlineLevel1);
                AddHeading(document, "2.1 架构设计", WdOutlineLevel.wdOutlineLevel2);
                AddHeading(document, "2.1.1 系统架构", WdOutlineLevel.wdOutlineLevel3);
                AddHeading(document, "2.1.2 数据架构", WdOutlineLevel.wdOutlineLevel3);
                AddHeading(document, "2.2 技术选型", WdOutlineLevel.wdOutlineLevel2);
                
                AddHeading(document, "第三章 实施计划", WdOutlineLevel.wdOutlineLevel1);
                AddHeading(document, "3.1 时间安排", WdOutlineLevel.wdOutlineLevel2);
                AddHeading(document, "3.2 资源分配", WdOutlineLevel.wdOutlineLevel2);
                
                // 添加正文内容
                AddBodyContent(document);
                
                document.SaveAs(@"C:\temp\DocumentWithOutline.docx");
                Console.WriteLine("带大纲的文档已创建");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"创建文档大纲时出错: {ex.Message}");
            }
        }
        
        private static void AddHeading(IWordDocument document, string text, WdOutlineLevel level)
        {
            var range = document.Range(document.Content.End - 1, document.Content.End - 1);
            range.Text = $"{text}\n";
            
            // 设置大纲级别
            range.ParagraphFormat.OutlineLevel = level;
            
            // 根据大纲级别设置样式
            switch (level)
            {
                case WdOutlineLevel.wdOutlineLevel1:
                    range.Font.Size = 16;
                    range.Font.Bold = 1;
                    break;
                case WdOutlineLevel.wdOutlineLevel2:
                    range.Font.Size = 14;
                    range.Font.Bold = 1;
                    break;
                case WdOutlineLevel.wdOutlineLevel3:
                    range.Font.Size = 12;
                    range.Font.Bold = 1;
                    break;
            }
            
            range.ParagraphFormat.SpaceAfter = 12;
        }
        
        private static void AddBodyContent(IWordDocument document)
        {
            // 添加章节内容
            AddParagraph(document, "这是第一章的正文内容。在这里可以添加详细的介绍和背景信息。");
            AddParagraph(document, "这是第二章的技术方案内容。详细描述系统架构和技术选型。");
            AddParagraph(document, "这是第三章的实施计划内容。详细说明项目的时间安排和资源分配。");
        }
        
        private static void AddParagraph(IWordDocument document, string text)
        {
            var range = document.Range(document.Content.End - 1, document.Content.End - 1);
            range.Text = $"{text}\n\n";
            range.ParagraphFormat.OutlineLevel = WdOutlineLevel.wdOutlineLevelBodyText;
        }
    }
    

通过设置大纲级别，我们可以创建一个结构化的文档，读者可以使用Word的大纲视图来浏览文档内容。这种方式特别适用于长篇技术文档或报告。

生成文档目录
------

文档目录可以帮助读者快速导航到感兴趣的章节。虽然 MudTools.OfficeInterop.Word 没有直接提供创建目录的方法，但我们可以通过使用 Word 的内置功能来实现。

文档目录是长篇文档中不可或缺的一部分，它为读者提供了快速导航到特定章节的途径。通过自动生成目录，我们可以确保目录与文档内容保持同步，避免手动维护目录带来的错误。

### 使用字段创建目录

    using MudTools.OfficeInterop;
    using System;
    
    class TableOfContentsCreator
    {
        public static void CreateTableOfContents()
        {
            try
            {
                using var app = WordFactory.BlankWorkbook();
                var document = app.ActiveDocument;
                
                // 添加文档标题
                AddDocumentTitle(document, "技术方案文档");
                
                // 添加目录标题
                AddTocHeading(document, "目录");
                
                // 插入目录字段（位置占位）
                InsertTableOfContentsField(document);
                
                // 添加章节内容（确保在目录之后添加，这样大纲级别才能正确识别）
                AddDocumentContentWithHeadings(document);
                
                // 更新目录字段
                document.UpdateAllFields();
                
                document.SaveAs(@"C:\temp\DocumentWithTOC.docx");
                Console.WriteLine("带目录的文档已创建");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"创建文档目录时出错: {ex.Message}");
            }
        }
        
        private static void AddDocumentTitle(IWordDocument document, string title)
        {
            var range = document.Range();
            range.Text = $"{title}\n";
            range.Font.Name = "微软雅黑";
            range.Font.Size = 18;
            range.Font.Bold = 1;
            range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
            range.ParagraphFormat.SpaceAfter = 24;
        }
        
        private static void AddTocHeading(IWordDocument document, string heading)
        {
            var range = document.Range(document.Content.End - 1, document.Content.End - 1);
            range.Text = $"{heading}\n";
            range.Font.Size = 16;
            range.Font.Bold = 1;
            range.ParagraphFormat.SpaceAfter = 12;
        }
        
        private static void InsertTableOfContentsField(IWordDocument document)
        {
            // 在当前位置插入目录字段
            var range = document.Range(document.Content.End - 1, document.Content.End - 1);
            range.Text = "\n"; // 留出空间
            
            // 插入目录字段（使用Word原生字段代码）
            var tocRange = document.Range(document.Content.End - 2, document.Content.End - 1);
            tocRange.Text = "TOC \\o \"1-3\" \\h \\z \\u"; // 目录字段代码
            
            // 应用字段样式
            tocRange.Font.Size = 12;
        }
        
        private static void AddDocumentContentWithHeadings(IWordDocument document)
        {
            // 添加章节内容
            AddHeadingWithLevel(document, "第一章 简介", 1);
            AddBodyText(document, "这是第一章的内容，介绍项目的背景和目标。");
            
            AddHeadingWithLevel(document, "第二章 技术架构", 1);
            AddBodyText(document, "这是第二章的内容，详细描述系统的技术架构。");
            
            AddHeadingWithLevel(document, "2.1 系统设计", 2);
            AddBodyText(document, "系统设计部分的内容。");
            
            AddHeadingWithLevel(document, "2.2 数据库设计", 2);
            AddBodyText(document, "数据库设计部分的内容。");
            
            AddHeadingWithLevel(document, "第三章 实施计划", 1);
            AddBodyText(document, "这是第三章的内容，详细说明项目的实施计划。");
        }
        
        private static void AddHeadingWithLevel(IWordDocument document, string text, int level)
        {
            var range = document.Range(document.Content.End - 1, document.Content.End - 1);
            range.Text = $"\n{text}\n";
            
            // 应用内置标题样式
            switch (level)
            {
                case 1:
                    range.Style = "标题 1";
                    break;
                case 2:
                    range.Style = "标题 2";
                    break;
                case 3:
                    range.Style = "标题 3";
                    break;
            }
        }
        
        private static void AddBodyText(IWordDocument document, string text)
        {
            var range = document.Range(document.Content.End - 1, document.Content.End - 1);
            range.Text = $"{text}\n\n";
            range.Style = "正文";
        }
    }
    

通过使用Word的字段功能，我们可以自动生成目录，并在文档内容发生变化时更新目录。这种方式确保了目录的准确性和时效性。

综合示例：创建完整的技术文档
--------------

让我们创建一个综合示例，展示如何使用所有这些功能创建一个完整的技术文档：

    using MudTools.OfficeInterop;
    using System;
    
    class ComprehensiveDocumentGenerator
    {
        public static void GenerateTechnicalDocument()
        {
            try
            {
                using var app = WordFactory.BlankWorkbook();
                app.Visible = true;
                var document = app.ActiveDocument;
                
                // 设置文档属性
                document.Title = "企业管理系统技术方案";
                document.Author = "技术部";
                
                // 设置文档样式
                SetupDocumentStyles(document);
                
                // 添加封面
                AddCoverPage(document);
                
                // 添加目录
                AddTableOfContents(document);
                
                // 添加正文内容
                AddMainContent(document);
                
                // 更新所有字段（包括目录）
                document.UpdateAllFields();
                
                // 保存文档
                document.SaveAs(@"C:\temp\TechnicalDocument.docx");
                
                Console.WriteLine("完整技术文档已生成");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"生成技术文档时出错: {ex.Message}");
            }
        }
        
        private static void SetupDocumentStyles(IWordDocument document)
        {
            // 设置正文样式
            var normalStyle = document.Styles["正文"];
            normalStyle.Font.Name = "宋体";
            normalStyle.Font.Size = 12;
            normalStyle.ParagraphFormat.LineSpacing = 1.5f;
            normalStyle.ParagraphFormat.SpaceAfter = 10;
            
            // 设置标题1样式
            var heading1Style = document.Styles["标题 1"];
            heading1Style.Font.Name = "黑体";
            heading1Style.Font.Size = 16;
            heading1Style.Font.Bold = 1;
            heading1Style.ParagraphFormat.SpaceAfter = 15;
            heading1Style.ParagraphFormat.SpaceBefore = 12;
            
            // 设置标题2样式
            var heading2Style = document.Styles["标题 2"];
            heading2Style.Font.Name = "楷体";
            heading2Style.Font.Size = 14;
            heading2Style.Font.Bold = 1;
            heading2Style.ParagraphFormat.SpaceAfter = 12;
            heading2Style.ParagraphFormat.SpaceBefore = 10;
            
            // 设置标题3样式
            var heading3Style = document.Styles["标题 3"];
            heading3Style.Font.Name = "仿宋";
            heading3Style.Font.Size = 12;
            heading3Style.Font.Bold = 1;
            heading3Style.ParagraphFormat.SpaceAfter = 10;
            heading3Style.ParagraphFormat.SpaceBefore = 8;
        }
        
        private static void AddCoverPage(IWordDocument document)
        {
            // 添加封面标题
            var titleRange = document.Range();
            titleRange.Text = "企业管理系统\n技术方案\n\n";
            titleRange.Font.Name = "微软雅黑";
            titleRange.Font.Size = 24;
            titleRange.Font.Bold = 1;
            titleRange.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
            
            // 添加公司信息
            var companyRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            companyRange.Text = "\n\n\nABC科技有限公司\n";
            companyRange.Font.Size = 14;
            companyRange.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
            
            // 添加日期
            var dateRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            dateRange.Text = $"\n{DateTime.Now:yyyy年MM月dd日}\n";
            dateRange.Font.Size = 12;
            dateRange.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
            
            // 添加分页符
            document.AddPageBreak(document.Content.End - 1);
        }
        
        private static void AddTableOfContents(IWordDocument document)
        {
            // 添加目录标题
            var tocTitleRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            tocTitleRange.Text = "目录\n";
            tocTitleRange.Style = "标题 1";
            
            // 添加目录字段
            var tocRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            tocRange.Text = "TOC \\o \"1-3\" \\h \\z \\u\n";
            tocRange.Font.Size = 12;
            
            // 添加分页符
            document.AddPageBreak(document.Content.End - 1);
        }
        
        private static void AddMainContent(IWordDocument document)
        {
            // 第一章 简介
            AddHeading(document, "第一章 简介", "标题 1");
            AddHeading(document, "1.1 项目背景", "标题 2");
            AddParagraph(document, "随着企业业务的快速发展，传统的管理方式已经无法满足现代企业的需求。为了提高管理效率，降低运营成本，我们决定开发一套全新的企业管理系统。");
            
            AddHeading(document, "1.2 项目目标", "标题 2");
            AddParagraph(document, "本项目的主要目标包括：");
            AddBulletList(document, new[] { 
                "提高管理效率", 
                "降低运营成本", 
                "增强数据安全性", 
                "提升用户体验" 
            });
            
            // 第二章 技术架构
            AddHeading(document, "第二章 技术架构", "标题 1");
            AddHeading(document, "2.1 系统架构", "标题 2");
            AddParagraph(document, "系统采用分层架构设计，主要包括：");
            
            // 创建系统架构表格
            var archTableRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            var archTable = document.Tables.Add(archTableRange, 4, 2);
            archTable.Cell(1, 1).Range.Text = "层名";
            archTable.Cell(1, 2).Range.Text = "描述";
            archTable.Cell(2, 1).Range.Text = "表示层";
            archTable.Cell(2, 2).Range.Text = "负责用户界面展示";
            archTable.Cell(3, 1).Range.Text = "业务逻辑层";
            archTable.Cell(3, 2).Range.Text = "处理业务逻辑";
            archTable.Cell(4, 1).Range.Text = "数据访问层";
            archTable.Cell(4, 2).Range.Text = "负责数据存取";
            FormatSimpleTable(archTable);
            
            AddHeading(document, "2.2 技术选型", "标题 2");
            AddParagraph(document, "本系统采用以下技术栈：");
            
            // 创建技术选型表格
            var techTableRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            var techTable = document.Tables.Add(techTableRange, 4, 3);
            techTable.Cell(1, 1).Range.Text = "技术";
            techTable.Cell(1, 2).Range.Text = "版本";
            techTable.Cell(1, 3).Range.Text = "用途";
            techTable.Cell(2, 1).Range.Text = ".NET";
            techTable.Cell(2, 2).Range.Text = "6.0";
            techTable.Cell(2, 3).Range.Text = "后端开发";
            techTable.Cell(3, 1).Range.Text = "Vue.js";
            techTable.Cell(3, 2).Range.Text = "3.0";
            techTable.Cell(3, 3).Range.Text = "前端开发";
            techTable.Cell(4, 1).Range.Text = "SQL Server";
            techTable.Cell(4, 2).Range.Text = "2019";
            techTable.Cell(4, 3).Range.Text = "数据库";
            FormatSimpleTable(techTable);
            
            // 第三章 实施计划
            AddHeading(document, "第三章 实施计划", "标题 1");
            AddHeading(document, "3.1 时间安排", "标题 2");
            AddParagraph(document, "项目计划分为以下几个阶段：");
            
            // 创建时间安排表格
            var scheduleTableRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            var scheduleTable = document.Tables.Add(scheduleTableRange, 5, 3);
            scheduleTable.Cell(1, 1).Range.Text = "阶段";
            scheduleTable.Cell(1, 2).Range.Text = "时间";
            scheduleTable.Cell(1, 3).Range.Text = "主要任务";
            scheduleTable.Cell(2, 1).Range.Text = "需求分析";
            scheduleTable.Cell(2, 2).Range.Text = "第1-2周";
            scheduleTable.Cell(2, 3).Range.Text = "收集和分析用户需求";
            scheduleTable.Cell(3, 1).Range.Text = "系统设计";
            scheduleTable.Cell(3, 2).Range.Text = "第3-4周";
            scheduleTable.Cell(3, 3).Range.Text = "设计系统架构和数据库";
            scheduleTable.Cell(4, 1).Range.Text = "编码实现";
            scheduleTable.Cell(4, 2).Range.Text = "第5-10周";
            scheduleTable.Cell(4, 3).Range.Text = "编写代码和单元测试";
            scheduleTable.Cell(5, 1).Range.Text = "测试部署";
            scheduleTable.Cell(5, 2).Range.Text = "第11-12周";
            scheduleTable.Cell(5, 3).Range.Text = "系统测试和上线部署";
            FormatSimpleTable(scheduleTable);
        }
        
        private static void AddHeading(IWordDocument document, string text, string style)
        {
            var range = document.Range(document.Content.End - 1, document.Content.End - 1);
            range.Text = $"{text}\n";
            range.Style = style;
        }
        
        private static void AddParagraph(IWordDocument document, string text)
        {
            var range = document.Range(document.Content.End - 1, document.Content.End - 1);
            range.Text = $"{text}\n\n";
            range.Style = "正文";
        }
        
        private static void AddBulletList(IWordDocument document, string[] items)
        {
            foreach (var item in items)
            {
                var range = document.Range(document.Content.End - 1, document.Content.End - 1);
                range.Text = $"{item}\n";
                range.Style = "正文";
                range.ListFormat.ApplyBulletDefault();
            }
            // 添加一个空段落来结束列表
            var endRange = document.Range(document.Content.End - 1, document.Content.End - 1);
            endRange.Text = "\n";
        }
        
        private static void FormatSimpleTable(IWordTable table)
        {
            // 设置表格边框
            table.Borders.Enable = 1;
            
            // 格式化表头
            for (int i = 1; i <= table.Columns.Count; i++)
            {
                var cell = table.Cell(1, i);
                cell.Range.Font.Bold = 1;
                cell.Shading.BackgroundPatternColor = WdColor.wdColorGray25;
                cell.Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
            }
            
            // 设置表格内容居中
            for (int row = 1; row <= table.Rows.Count; row++)
            {
                for (int col = 1; col <= table.Columns.Count; col++)
                {
                    table.Cell(row, col).Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter;
                }
            }
        }
    }
    

注意事项
----

在使用 MudTools.OfficeInterop.Word 进行文档自动化时，需要注意以下几点：

### 资源管理

始终使用 `using` 语句确保 COM 对象得到正确释放：

    using var app = WordFactory.BlankWorkbook();
    // 执行操作
    // 资源会自动释放
    

正确的资源管理是使用 COM 组件的关键。由于 Word 是一个重量级应用程序，如果未能正确释放资源，可能会导致内存泄漏或 Word 进程无法退出的问题。

### 异常处理

包装所有操作在 try-catch 块中处理可能的异常：

    try
    {
        // Word 操作
    }
    catch (Exception ex)
    {
        Console.WriteLine($"操作出错: {ex.Message}");
    }
    

Word 自动化操作可能会因为各种原因失败，例如文件被占用、路径不存在、权限不足等。通过适当的异常处理，可以确保程序的稳定性，并提供有用的错误信息。

### 性能优化

对于大量文档处理，考虑以下优化策略：

1.  批量处理文档时，重用 Word 应用程序实例
2.  避免频繁的 UI 更新操作
3.  在处理完成后关闭 Word 应用程序

    class BatchProcessor
    {
        public static void ProcessDocuments(string[] filePaths)
        {
            using var app = WordFactory.BlankWorkbook();
            app.Visible = false; // 隐藏界面以提高性能
            
            foreach (var filePath in filePaths)
            {
                try
                {
                    var document = app.Open(filePath);
                    // 处理文档
                    document.Close(false); // 不保存更改
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"处理文件 {filePath} 时出错: {ex.Message}");
                }
            }
        }
    }
    

通过隐藏 Word 界面，我们可以显著提高处理速度，特别是在批量处理文档时。

总结
--

MudTools.OfficeInterop.Word 为 .NET 开发者提供了一个强大而易用的 Word 文档自动化解决方案。通过本文介绍的功能，您可以：

1.  自动生成合同条款和其他结构化文档
2.  实现自动文档排版，确保文档风格统一
3.  创建复杂的嵌套表格来展示数据
4.  生成文档大纲和目录，提高文档可读性

这些功能在实际业务场景中非常有用，可以帮助企业大幅提高文档处理效率，减少人工操作错误。通过合理使用这个库，您可以构建出功能强大的文档自动化系统。

[项目自带的Word操作示例代码](https://gitee.com/mudtools/OfficeInterop/tree/master/Samples/WordSamples)

希望本文能帮助您更好地理解和使用 MudTools.OfficeInterop.Word 库，如果您有任何问题或建议，欢迎在评论区留言讨论。