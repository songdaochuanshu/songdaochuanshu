---
layout: post
title: '10分钟带你体验 Solon 的状态机'
date: "2025-08-30T00:37:54Z"
---
10分钟带你体验 Solon 的状态机
===================

Solon State Machine是一个简化应用程序状态管理的框架，通过定义状态(State)、事件(Event)和转换(Transition)来管理对象状态流转。本文以订单系统为例，演示如何快速使用：首先定义订单状态和事件枚举，然后创建状态机类配置状态转换规则，最后在控制器中通过注入状态机实例来触发状态变更。使用状态机可使代码更清晰，便于维护复杂的状态流转逻辑。10分钟即可掌握基本用法，适用于订单、审批等需要状态管理的业务场景。

一、介绍
----

Solon 状态机，称为 Solon State Machine。它是一种可以管理状态、事件之间的关系，以及他们之间的转换。这是一个专门为应用程序中的状态管理和状态转换提供支持的框架。

它简化了事物对象在不同状态下，不同事件转化的代码管理，让其代码变得更加清晰明了。

本文将介绍 Solon State Machine 状态机在 Solon 框架下的使用，10分钟带你理解并上手使用 Solon 状态机

二、状态机的核心概念
----------

首先，我们必须要了解 Solon 状态机的几个核心概念，如下

*   状态（State）：代表着对象的当前状态
*   事件（Event）：对象状态转变是因何而改变的
*   转换（Transition）：定义了事物的状态是通过哪个事件变到了另一个状态

比如，最常见的就是订单系统，下面就简单模拟一下正常订单的状态流转：

*   用户下单（状态为：待支付）
*   用户支付成功（状态为：已支付待发货）
*   仓库已发货（状态为：已发货待收货）
*   用户成功收货（状态为：已收货）

三、代码
----

添加对应的 maven 依赖

    <dependency>
        <groupId>org.noear</groupId>
        <artifactId>solon-statemachine</artifactId>
        <version>3.5.1</version>
    </dependency>
    

对于状态，由于非常固定，我们最好是使用枚举，如下OrderStatus.java

    public enum OrderStatusEnum {
        WAIT_PAY, //待支付
        WAIT_DELIVER, //已支付待发货
        WAIT_RECEIVE, //已发货待收货
        RECEIVED; //已收货
    }
    

还要定义一下事件的枚举

    public enum OrderStatusEventEnum {
        ORDER, //用户下单
        PAY, //用户支付成功
        DELIVER, //仓库已发货
        RECEIVE; //用户成功收货
    }
    

接下来我们就能定义转换了，在 Solon 框架下，我们可以定义一个 OrderStateMachine 托管类

    @Managed
    public class OrderStateMachine extends StateMachine<OrderStatusEnum,OrderStatusEventEnum, OrderEntity> {
        public OrderStateMachine() {
            // 待支付 -> 已支付待发货（支付成功）
            from(OrderStatusEnum.WAIT_PAY).to(OrderStatusEnum.WAIT_DELIVER)
                    .on(OrderStatusEventEnum.PAY)
                    .then(c -> c.getPayload().setStatus(c.getTo()));
    
            // 已支付待发货 -> 已发货待收货（仓库已发货）
            from(OrderStatusEnum.WAIT_DELIVER).to(OrderStatusEnum.WAIT_RECEIVE)
                    .on(OrderStatusEventEnum.DELIVER)
                    .then(c -> c.getPayload().setStatus(c.getTo()));
    
            // 已发货待收货 -> 已收货（用户收货）
            from(OrderStatusEnum.WAIT_RECEIVE).to(OrderStatusEnum.RECEIVED)
                    .on(OrderStatusEventEnum.RECEIVE)
                    .then(c -> c.getPayload().setStatus(c.getTo()));
        }
    }
    

是不是感觉还缺了什么呢，配置中还缺少一个下单事件，这没有关系，这是我们初始的一个事件，不参于配置

我们写对应的 OrderController 接口即可，这边模拟一下，创建订单进行落库

    @Controller
    public class OrderController {
        @Mapping("/create")
        public Result<Void> create() {
            // TODO 模拟订单落库
            return Result.succeed();
        }
    }
    

重点是在后面的，支付这一个阶段，我们应该如何接入状态机，如下

    @Controller
    public class OrderController {
        @Inject
        private OrderStateMachine orderStatusMachine;
    
        @Mapping("/create")
        public Result create() {
            // TODO 模拟订单落库
            return Result.succeed();
        }
    
        @Post
        @Mapping("/pay")
        public Result pay() {
            // TODO 模拟订单支付
            return Result.succeed();
        }
    
        @Post
        @Mapping("/payNotify")
        public Result payNotify(Integer orderId) {
            // TODO 支付成功后，使用状态机
    
            // 模拟通过id查找一个订单对象
            OrderEntity entity = new OrderEntity(orderId, OrderStatusEnum.WAIT_PAY);
    
            // 使用状态机发送这个消息
            orderStatusMachine.sendEvent(OrderStatusEventEnum.PAY, EventContext.of(entity.getStatus(), entity));
            return Result.succeed();
        }
    }