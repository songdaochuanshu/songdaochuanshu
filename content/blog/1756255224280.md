---
layout: post
title: '如何用labelimg标注yolo数据集，并利用工具自动划分数据集'
date: "2025-08-27T00:40:24Z"
---
如何用labelimg标注yolo数据集，并利用工具自动划分数据集
=================================

![如何用labelimg标注yolo数据集，并利用工具自动划分数据集](https://img2024.cnblogs.com/blog/3687401/202508/3687401-20250826165038360-1517130173.png) 本文介绍了使用LabelImg工具标注YOLO格式数据集的全流程。首先详细讲解了LabelImg的标注方法，包括创建矩形框、类别命名及标注文件格式说明。然后提供了Python脚本自动划分数据集的方案，支持自定义训练集/验证集/测试集比例，并生成YOLO训练所需的dataset.yaml配置文件。最后展示了基于PyQt5封装的GUI工具，使数据集划分更加可视化、易操作。整个过程从数据标注到预处理完整覆盖，为计算机视觉项目的数据准备提供了便捷的解决方案。

视频演示
====

[如何用labelimg标注yolo数据集，并利用工具自动划分数据集\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV15zeozXEhV/?vd_source=fe50c8500dae5a3543c98e910b928780)

1 labelimg标注数据集
===============

1.1 labelimg工具介绍
----------------

LabelImg是一款开源的图像标注工具，专门用于为目标检测任务创建数据集。它支持矩形框标注，可导出PASCAL VOC、YOLO、CreateML等多种格式。

通过简单的点击和拖拽操作，用户即可快速为图像中的对象添加标注框和类别标签。

该工具界面简洁直观，支持快捷键操作，大幅提升标注效率，是计算机视觉领域数据准备的常用工具之一。

1.2 labelimg标注数据集
-----------------

点击界面左侧的“Open Dir”按钮，选择数据集所存放的文件夹，选择后文件夹中存放的图片信息会展示到界面上

左下角的File List会显示读取进来的数据集列表

点击左侧的Create \\nRectBox 按钮，长按鼠标左键可以对图像中的目标物体绘制矩形框

绘制完成之后，弹出来的命名对话框中，写上当前绘制的类别的名字，这里绘制的这个手势是剪刀，我们命名为“Scissors”

依次对剩下的图像数据集进行绘制标注。

查看存放图片的文件夹，会发现每一个图片的旁边，都生成了一个同名的txt文档，这个文档就是我们标注数据后产生的标注文件。  

这里可以打开标注文件，查看下标注文件中的内容：

0 0.560937 0.768750 0.625000 0.425000

标注文件中的内容按照行排列，每一行有5个数字，第1个数字是一个整数，后面4个数字是0到1之间的小数，这里以上图举例，说明下数字的含义：

第1个数字“0”：表示当前目标物体的类别编号，0表示第0号目标物体，同理如果是2的话，表明第2号目标物体，具体的编号根据标注时编写目标物体的名称的先后顺序而来。

第2、3个数字“0.560937 0.768750”：表示的是标注物体的坐标信息，分别是x轴和y轴的坐标，坐标为目标检测物体的中心区域，坐标原点是图像的左上角，这里不一样的地方是，坐标轴长不是按照图像的实际尺寸来标注的，而是做了归一化处理，即左下角的y轴坐标是1，右上角的x轴坐标是1，所以x轴和y轴的坐标的阈值是0到1之间。

第4、5数字"0.625000 0.425000"：表示的是标注物体的尺寸，分别表示宽度和高度，数值同样是归一化处理，例如0.625表示尺寸为宽度的62.5%

最后还有一个classes.txt文件，打开后是标注的名字信息

scissors
rock
paper

2 划分数据集
=======

当标注完数据之后，yolo模型训练的时候，数据集需要区分训练集和验证集，最后为了检测模型的有效性，我们还需要测试集

所以这里又写了一个python脚本可以将我们标注好的数据集一次性随机性的按照设定的划分比例进行自动化数据集划分

\# YOLO 数据集划分工具
# 功能：将包含图片和对应标注文件的数据集按比例随机划分为训练集、验证集和测试集
# 同时生成YOLO训练所需的dataset.yaml配置文件

import os
import shutil
import random
import yaml

# ============ 配置参数 ============
SOURCE\_DIR = "data"                 # 源数据目录，图片及其标注 .txt 文件应在此目录
OUTPUT\_DIR = "data\_split\_output2"    # 输出根目录，将生成 train/val/test 及其 images/labels

TRAIN\_RATIO = 0.7                   # 训练集比例
VAL\_RATIO = 0.2                     # 验证集比例
TEST\_RATIO = 0.1                    # 测试集比例
SEED = 42                           # 随机种子，确保每次划分结果一致
REQUIRE\_LABEL = True                # 仅包含存在对应 .txt 标注的图片

IMG\_EXTS = {'.jpg', '.jpeg', '.png', '.bmp', '.gif', '.tiff'}  # 支持的图片格式
# ==========================================


def ensure\_dir(path: str):
    """确保目录存在，不存在则创建"""
    os.makedirs(path, exist\_ok=True)


def main():
    # 检查源目录是否存在
    if not os.path.isdir(SOURCE\_DIR):
        print(f"源目录不存在: {SOURCE\_DIR}")
        return

    # 收集图片及对应标注信息
    candidates = \[\]
    for fname in os.listdir(SOURCE\_DIR):
        fpath = os.path.join(SOURCE\_DIR, fname)
        # 跳过非文件项
        if not os.path.isfile(fpath):
            continue
        
        # 检查文件是否为图片格式
        ext = os.path.splitext(fname)\[1\].lower()
        if ext in IMG\_EXTS:
            base = os.path.splitext(fname)\[0\]  # 获取文件名（不含扩展名）
            label\_name = base + ".txt"         # 对应的标注文件名
            label\_path = os.path.join(SOURCE\_DIR, label\_name)

            # 如果需要标注文件且不存在，则跳过此图片
            if REQUIRE\_LABEL and not os.path.exists(label\_path):
                continue

            # 记录图片文件名和对应的标注文件名（如果有）
            has\_label = os.path.exists(label\_path)
            candidates.append((fname, label\_name if has\_label else None))

    n = len(candidates)
    if n == 0:
        print("未找到符合条件的图片及标注对。")
        return

    # 检查比例设置是否有效
    ratio\_sum = TRAIN\_RATIO + VAL\_RATIO + TEST\_RATIO
    if ratio\_sum <= 0:
        print("train/val/test 比例之和必须大于0")
        return

    # 设置随机种子并打乱数据顺序
    random.seed(SEED)
    random.shuffle(candidates)

    # 计算各数据集的数量
    n\_train = int(n \* (TRAIN\_RATIO / ratio\_sum))
    n\_val = int(n \* (VAL\_RATIO / ratio\_sum))
    n\_test = n - n\_train - n\_val

    # 定义输出目录路径
    train\_img\_out = os.path.join(OUTPUT\_DIR, "train", "images")
    train\_lab\_out = os.path.join(OUTPUT\_DIR, "train", "labels")
    val\_img\_out = os.path.join(OUTPUT\_DIR, "val", "images")
    val\_lab\_out = os.path.join(OUTPUT\_DIR, "val", "labels")
    test\_img\_out = os.path.join(OUTPUT\_DIR, "test", "images")
    test\_lab\_out = os.path.join(OUTPUT\_DIR, "test", "labels")

    # 创建所有输出目录
    for d in \[train\_img\_out, train\_lab\_out, val\_img\_out, val\_lab\_out, test\_img\_out, test\_lab\_out\]:
        ensure\_dir(d)

    def copy\_pair(item, dst\_img\_dir, dst\_lab\_dir):
        """复制图片和对应的标注文件到目标目录"""
        img\_name, label\_name = item
        src\_img = os.path.join(SOURCE\_DIR, img\_name)
        dst\_img = os.path.join(dst\_img\_dir, img\_name)
        shutil.copy2(src\_img, dst\_img)  # 复制图片文件

        # 如果存在标注文件，则一并复制
        if label\_name:
            src\_lab = os.path.join(SOURCE\_DIR, label\_name)
            if os.path.exists(src\_lab):
                dst\_lab = os.path.join(dst\_lab\_dir, label\_name)
                shutil.copy2(src\_lab, dst\_lab)  # 复制标注文件

    # 按划分结果复制文件到对应目录
    idx = 0
    for \_ in range(n\_train):
        copy\_pair(candidates\[idx\], train\_img\_out, train\_lab\_out)
        idx += 1
    for \_ in range(n\_val):
        copy\_pair(candidates\[idx\], val\_img\_out, val\_lab\_out)
        idx += 1
    for \_ in range(n\_test):
        copy\_pair(candidates\[idx\], test\_img\_out, test\_lab\_out)
        idx += 1

    # 读取类别信息
    classes\_file = os.path.join(SOURCE\_DIR, 'classes.txt')
    class\_names = \[\]
    if os.path.exists(classes\_file):
        with open(classes\_file, 'r', encoding='utf-8') as f:
            class\_names = \[line.strip() for line in f.readlines() if line.strip()\]
    else:
        print(f"警告: 未找到 classes.txt 文件，使用默认类别")
        class\_names = \['class0', 'class1', 'class2'\]  # 默认类别名
    
    # 生成 YAML 配置文件 (手动控制顺序)
    yaml\_path = os.path.join(OUTPUT\_DIR, 'dataset.yaml')
    with open(yaml\_path, 'w', encoding='utf-8') as f:
        # 写入数据集路径
        f.write(f"train: ./train/images\\n")
        f.write(f"val: ./val/images\\n")
        f.write(f"test: ./test/images\\n")
        f.write(f"\\n")
        # 写入类别数量
        f.write(f"nc: {len(class\_names)}\\n")
        # 写入类别名称列表
        f.write(f"names:\\n")
        for name in class\_names:
            f.write(f"- {name}\\n")
    
    # 输出划分结果摘要
    print("划分完成：")
    print(f"  训练集: train/images={train\_img\_out}, train/labels={train\_lab\_out}, 张数={n\_train}")
    print(f"  验证集:  val/images={val\_img\_out},   val/labels={val\_lab\_out}, 张数={n\_val}")
    print(f"  测试集:  test/images={test\_img\_out},  test/labels={test\_lab\_out}, 张数={n\_test}")
    print(f"  配置文件: {yaml\_path}")


if \_\_name\_\_ == "\_\_main\_\_":
    main()

代码中设置好对应的初始化参数：

SOURCE\_DIR = "data"                 # 源数据目录，图片及其标注 .txt 文件应在此目录
OUTPUT\_DIR = "data\_split\_output2"    # 输出根目录，将生成 train/val/test 及其 images/labels

TRAIN\_RATIO = 0.7                   # 训练集比例
VAL\_RATIO = 0.2                     # 验证集比例
TEST\_RATIO = 0.1                    # 测试集比例

代码中都有相应的注释，这里不再赘述，主要是设置好数据集所在目录，输出的数据集的目录，各个数据集的比例

代码的核心思想就是读取文件夹下的所有图片，然后把图片存放到candidates的list中，然后使用random.shuffle方法打乱candidates中的数据。最后依次按照划分的比例读取数据集。

最终划分好的数据集如下（为了结构展现清楚，这里用macos下的目录展现形式）  

同时还生成了yolo框架训练时需要用到的yaml数据集说明文件，这里名字命名为dataset.yaml，打开后内容如下

train: ./train/images
val: ./val/images
test: ./test/images

nc: 3
names:
- scissors
- rock
- paper

上面有数据集所在的目录，nc数，还有对应类别的名字

3 封装好GUI的划分数据集工具
================

利用pyqt5制作了一个界面，将python脚本集成进去，并打包成exe，方便标注数据集的小伙伴不用特意从python环境中去处理

有了界面之后，各个参数的设置就比较清楚了

可以设置源数据集所在的目录，也可以直接把数据集的文件夹拖动到界面上，自动把目录填入

设置输出目录，最终划分数据集后所保存的位置

设置不同数据集的划分比例，这里需要注意划分的比例之和不能超过1

点击开始划分按钮后，会有数据集划分的进度和日志信息，方便用户随时了解划分进度情况。

以上就是如何使用labelimg来标注数据集，然后如果通过脚本自动划分数据集，最终通过封装好gui来实现更进一步的数据集划分，中间细节难免有些疏漏，如有问题，可以评论区进行讨论。

​