---
layout: post
title: 'CMake构建学习笔记23-SQLite库的构建'
date: "2025-09-03T00:37:30Z"
---
CMake构建学习笔记23-SQLite库的构建
========================

在Windows下通过自定义CMake项目将SQLite源码构建成动态库，并实现编译、链接与安装的自动化流程。

1\. 构建思路
========

在前文中构建了大量的库包程序（参看[CMake构建学习笔记-目录](https://charlee44.com/post.html?id=a1671c83735546cfa5c69b7ae7e37403)）之后，可以总结一下在Windows下使用脚本构建程序的办法：

1.  使用CMake构建。这是目前最通用最流行的构建方式，大部分C/C++程序都在逐渐向这个方向转。
2.  使用namke构建。在CMake流行之前，有的程序会提供MSVC项目文件，这种情况下可以使用namke来进行构建。
3.  使用MSYS2/MinGW构建。适用于只提供了Linux环境构建方式的程序，不过可能会有二进制兼容问题，一般不推荐。
4.  使用第三方的项目构建。比如自己组织CMake项目，或者使用vcpkg这样的库包管理工具直接安装。

2\. 构建SQLite
============

SQLite是一个轻量级的、无需独立服务器进程的嵌入式关系型数据库。它将整个数据库（包括表、索引和数据）存储在一个单一的磁盘文件中，支持标准的SQL语法，广泛用于嵌入式设备、移动应用和小型Web项目。SQLite是一个老牌的C库，不提供CMake的构建方式，而且它还是个可执行程序而不仅仅是库，这给程序的集成带来一定的麻烦。

那么如何在Windows下将SQLite构建成库文件呢？这里选择第4种方案，根据源代码文件生成CMake项目。SQLite提供了一个很不错的特性，就是支持将所有的实现代码组合成一个`sqlite.c`文件，因此自己组织CMake项目就比较简单，组织结构如下：

project-root/  
├── include/  
│ ├── sqlite3.h  
│ └── sqlite3ext.h  
├── src/  
│ └── sqlite3.c  
├── CMakeLists.txt  
├── CMakePresets.json  
└── sqlite3.def

源代码`sqlite.c`、`sqlite3.h`、`sqlite3ext.h`是SQLite的源代码文件，不用进行修改。需要注意的是SQLite提供两种源代码文件，一种是分散组织的，一种是组合成单文件的，一定要选择后者才能看到`sqlite.c`文件（比如sqlite-amalgamation-3460000.zip）。

另外，`sqlite3.def`是模块定义文件，为Windows的DLL模块定义各种属性和导出符号。如果是像笔者一样需要构建成动态库，那么这个文件一定要有。这个文件可以在SQLite提供预编译包种找到（比如sqlite-dll-win-x64-3460000）。

最后，`CMakeLists.txt`中的内容如下：

    # 输出cmake版本提示
    message(STATUS "The CMAKE_VERSION is ${CMAKE_VERSION}.")
    
    # cmake的最低版本要求
    cmake_minimum_required (VERSION 3.10)
    
    # 工程名称、版本、语言
    project(sqlite3 VERSION 3.4.6)
    
    # 支持当前目录
    set(CMAKE_INCLUDE_CURRENT_DIR ON)
    
    # 判断编译器类型
    message("CMAKE_CXX_COMPILER_ID: ${CMAKE_CXX_COMPILER_ID}")
    
    # 判断编译器类型
    if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
        message(">> using Clang")
    elseif ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
        message(">> using GCC")
    elseif ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel")
        message(">> using Intel C++")
    elseif ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "MSVC")
        message(">> using Visual Studio C++")	  
        add_compile_options(/utf-8)
    else()
        message(">> unknow compiler.")
    endif()
    
    # 设置编译定义
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} \
    -DSQLITE_THREADSAFE=1 \
    -DSQLITE_ENABLE_COLUMN_METADATA \
    -DSQLITE_ENABLE_PREUPDATE_HOOK \
    -DSQLITE_ENABLE_RTREE \
    -DSQLITE_ENABLE_GEOPOLY \
    -DSQLITE_ENABLE_SESSION \
    -DSQLITE_ENABLE_RBU")
    
    # 源代码文件
    set(INCLUDE_FILES 
        ./include/sqlite3.h
        ./include/sqlite3ext.h
    )
    set(SOURCE_FILES
        ./src/sqlite3.c
        ${INCLUDE_FILES}
    )
    
    # 动态库前缀与后缀
    IF(CMAKE_SYSTEM_NAME MATCHES "Linux")
    	set(LibraryPrefix lib)
        set(LibraryPostfix so)
    ELSEIF(CMAKE_SYSTEM_NAME MATCHES "Windows")
    	set(LibraryPrefix )
        set(LibraryPostfix lib)
    ENDIF()
    
    
    # 将源代码添加到此项目的可执行文件。
    add_library(${PROJECT_NAME} SHARED ${SOURCE_FILES})
    
    if(CMAKE_SYSTEM_NAME MATCHES "Windows")   
        # 指定.def文件
        set_target_properties(${PROJECT_NAME} PROPERTIES
        OUTPUT_NAME ${PROJECT_NAME}
        LINK_FLAGS "/DEF:${CMAKE_CURRENT_SOURCE_DIR}/sqlite3.def")
    endif()
    
    # TODO: 如有需要，请添加测试
    
    # 安装头文件到 include 目录
    install(DIRECTORY include/ DESTINATION include)
    
    # 安装库文件到 lib 目录
    install(TARGETS ${PROJECT_NAME}
            LIBRARY DESTINATION lib  # 对于共享库
            ARCHIVE DESTINATION lib  # 对于静态库
            RUNTIME DESTINATION bin  # 对于可执行文件
    )
    

然后执行如下脚本指令：

    cmake $SourceLocalPath `
        -B "$BuildDir" `
        -G "$Generator" `
        -A x64 `
        -DCMAKE_CONFIGURATION_TYPES=RelWithDebInfo `
        -DCMAKE_INSTALL_PREFIX="$InstallDir"
    
    # 构建阶段，指定构建类型
    cmake --build $BuildDir --config RelWithDebInfo
    
    # 安装阶段，指定构建类型和安装目标
    cmake --build $BuildDir --config RelWithDebInfo --target install
    

即可完成编译、链接到安装的完整构建过程。`$SourceLocalPath`是源代码目录，也就是前面的CMake项目文件夹；`$BuildDir`是构建目录文件夹；`"$Generator"`是生成器，比如`Visual Studio 16 2019`。