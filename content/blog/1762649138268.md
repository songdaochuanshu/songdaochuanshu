---
layout: post
title: '奶奶都能看懂的 C++ —— 数组与指针'
date: "2025-11-09T00:45:38Z"
---
奶奶都能看懂的 C++ —— 数组与指针
====================

本文以浅显生动的方式讲解了C++中数组与指针的关系，展示了数组的遍历方式、多维数组的本质及范围for的应用，让读者理解数组退化为指针的机制与多维结构的内在逻辑。

在[上一篇](https://blog.samhou.top/cpp-vector-iterator-guide/)中，我们讨论了 vector 和迭代器，用以遍历一个有序可变序列。而我们知道，在 vector 之下有一种更加基本的数据类型——数组，它是有序**固定大小**的序列。实际上，我们所涉及的迭代器（范围 for），在数组中也以某种形式可用。

单维数组
----

### 使用数组

奶奶都知道怎么创建数组：

    int a[100]={0};//创建数组，然后初始化所有元素为0
    int a[100]={0,1,2};//创建，然后初始化前三个元素，后面的元素初始化为默认值 (0)
    

她也知道数组可以使用下标运算遍历（下标从零开始）：

    for(int i = 0;i<100;i++){
        cout<<a[i]<<endl;
    }
    

但是，数组不能直接赋值给另一个数组，这一点和 vector 不同，需要注意（大小都不一样且固定，怎么复制呢？）。

### 数组即指针

很好。但是你有没有想过，如果我直接把数组输出，会发生什么？

    int a[100]={1,2};
    cout<<a<<endl; // 0x7ffc4d858a10
    

WOW，这个输出是不是有些熟悉？

没错，在[指针](https://blog.samhou.top/cpp-pointer-guide/)那一篇里，我们曾经见过。这是十六进制数，表示一个**地址**。也就是说，我们输出了数组，但是它的表现居然和指针一样，输出了一个对象的地址！

但是，这个地址究竟是什么？指向了哪个对象？

嗯，我们解引用试试：

    cout<<*a<<endl; // 1
    

输出的是**1**。居然是数组的第一个元素！

也就是说，如果我们直接使用数组，却不指定下标，那么它会被当做一个**指向第一个元素的指针**。

### 指针和迭代器

事情从这里开始就变得有趣起来了。实际上，数组在内存中是**连续存储**的，那么，我们可以用指针运算的方式，来遍历整个数组：

    int a[5]={0};
    for(int *p=a;p!=a+5;p++){
        cout<<*p<<endl;
    }
    

在上面的代码中，我们先创建了指向第一个元素的指针，然后不断将指针向后移动，输出解引用后的对象，直到到达最后一个元素的后一个位置，立即退出。查看下面图片，了解具体过程。

实际上，std 提供了 `begin()` 和 `end()`，来获取首个元素，和末尾元素的后一个位置。

    #include <iterator> //先引入，再使用
    int a[5]={0};
    for(int *p=begin(a);p!=end(a);p++){
        cout<<*p<<endl;
    }
    

是不是很熟悉？我们曾经提到过，[范围 for 语句](https://blog.samhou.top/cpp-vector-iterator-guide/)满足的条件：

> begin,end 返回的是一个迭代器/迭代器可以自增

实际上，返回的是一个可运算的指针，也是可行的：

    int a[5]={0};
    for(int i:a){
        cout<<i<<endl;
    }
    

上方的三种形式，都是等价的。也就是说，数组也可以用范围 for 语句（当然也可以设定为引用，然后修改）。

多维数组
----

### 更高的维度

之前我们创建的数组，是对象的固定有序序列。那么我们想一想，数组其中的对象能否是一个数组呢？实际上是可以的，这称为**多维数组**。

    int a[100][100]={}; // 全部初始化为默认值 (0)
    int b[10][10]={{1,2},{2,3}}; // 初始化一部分
    

我们都知道我们现在所在的空间是三维的，这个**维数**，就是指的是有多少根轴，比如上下、左右、前后。而 Excel 表格是二维的，有 X Y 两根轴。因此，从名字上来说，多维数组可以理解为一片 N 维的空间，空间中的每个坐标点，每一个都包含一个独立的元素。

比如说，上面定义了两个二维数组，第一个全部初始化为默认值 0，第二个把**第一行**第一个数设为 1，第二个数设为 2；**第二行**第一个数设为 2，第二个数设为 3，其余设定为默认值 0。

    cout<<b[0][0]<<endl; // 1
    cout<<b[0][1]<<endl; // 2
    cout<<b[1][0]<<endl; // 2
    cout<<b[1][1]<<endl; // 3
    

下标运算符是可用的。在二维中，我们把第一个下标称为**行**，第二个称为**列**。

这是多维数组含义上的理解。但是其本质是什么呢？

### 多维数组的本质

我们还得来看看这个初始化：

    int b[10][10]={{1,2},{2,3}}; // 初始化一部分
    

不难发现，这个初始化语句的字面值，是一个数组中嵌套了另外一个数组。也就是说，可以这么理解这个声明：

**创建包含 10 个元素的数组，其中所有元素的类型均为包含 10 个元素的数组。**

这样我们就不难理解，第一个下标决定是哪一个_包含 10 个元素数组_，第二个下标决定获取到的数组中的哪一个元素。

推广下，三维也是一样的。

    int c[10][10][10]={ { {1,2},{1,3} }, { {1,2},{3,2} }}; 
    

考考你，先想想下面的输出是什么，然后我再告诉你答案。

    cout<<c[0][1][1]<<endl;
    cout<<c[1][1][0]<<endl;
    

想好了吗？来看看输出吧。

输出是两个 3。我们来看看这个过程。

1.  第一行
    1.  首先，取得下标为 0 的元素（数组）：`{ {1,2},{1,3} }`
    2.  再从中取得下标为 1 的元素（数组）：`{1,3}`
    3.  再取出下标为 1 的元素（int 类型变量）：`3`
2.  第二行
    1.  首先，取得下标为 1 的元素（数组）：`{ {1,2},{3,2} }`
    2.  再从中取得下标为 1 的元素（数组）：`{3,2}`
    3.  再取出下标为 0 的元素（int 类型变量）：`3`

### 遍历多维数组

你当然可以用奶奶都会的 for 循环嵌套+下标来遍历：

    int a[10][10]={};
    for(int i=0;i<10;i++){
        for(int j=0;j<10;j++){
            cout<<a[i][j]<<endl;
        }
    }
    

但我们之前提到了数组即为指针，这同样适用于多维数组：

    for(int (*i)[10]=a;i!=a+10;i++){
        for(int *j=*i;j!=*i+10;j++){
            cout<<*j<<endl;
        }
    }
    

我们来仔细看看这里究竟发生了什么。

先看外层循环。首先，我们创建了一个指向 a 这个数组首个元素的指针。我们刚才提到，a 的第一个元素是一个**包含 10 个元素的数组**，因此我们创建的指针必须具有正确的类型。`*i` 表示它是个指针，`[10]` 表示这个指针指向的是一个数组，且数组的长度为 10。

你应该注意到了那个括号，这是因为 `[10]` 的优先级更高。不打括号 `int *i[10]` 表示一个数组里存储 10 个 int 类型的指针，这和我们想要达到的目标完全不同。

接下来，我们每次循环时都把指针向后移动一个位置。由于已经指定了正确的类型，因此指针将移到 a 中的下一个元素，也就是**第二个包含 10 个元素的数组**。指针每次循环都会**指向下一个数组**，直到到达 a 中的最后一个数组的下一个位置，立即退出循环。

再来看内层循环。我们先定义了一个 int 类型的指针，这个指针初始化为 `*i`，也就是先获取**外层指向包含 10 个元素数组的指针**，然后解引用，获取到这个数组，而由于**数组本质是一个指向首元素的指针**，所以相当于 j 初始化为**指向这个包含 10 个 int 的数组的首个元素的指针**。

接下来，输出 j 解引用后的那个 int 元素，然后 j 向后移动一个位置，直到到达该数组末尾的下一个位置，立即退出循环。

也就是说，多维数组本质就是多个数组的嵌套，而只要记住数组即为指向其第一个元素的指针，那么无论嵌套多少都不用关心——每一次嵌套，都只是让指针指向**包含数组的数组**而已。

当维数越来越多的时候，我们手动指定指针指向的是怎样的对象容易累死自己，因此建议使用 `auto`。

    for(auto i=a;i!=a+10;i++){
        for(auto j=*i;j!=*i+10;j++){
            cout<<*j<<endl;
        }
    }
    

注意了，既然是指针，那么修改时，修改的元素是原本数组内的对象，而并非拷贝副本：

    int a[3][3]={};
    for(auto i=a;i!=a+3;i++){
        for(auto j=*i;j!=*i+3;j++){
            cout<<*j<<endl;
    		*j=1;
        }
    	cout<<endl;
    }
    // 输出都是 0
    for(auto i=a;i!=a+3;i++){
        for(auto j=*i;j!=*i+3;j++){
            cout<<*j<<endl;
        }
    	cout<<endl;
    }
    // 输出都是 1
    

当然，由于是数组，所以多维情况下 `begin()` `end()` 依然可用，而且和用指针运算相同，都能正确获取到指向**对应数组**的**首个数组元素的指针**：

    for(auto i=begin(a);i!=end(a);i++){
        for(auto j=begin(*i);j!=end(*i);j++){
            cout<<*j<<endl;
    		*j=1;
        }
    	cout<<endl;
    }
    

### 范围 for 语句

当然了，正是由于这些性质，因此范围 for 语句也可用：

    int a[3][3]={};
    for(int i[3]:a){ // Error
        for(int j:i){
            cout<<j<<endl;
        }
    }
    

……但是上面的根本就没办法通过编译。这是因为，范围 for 的本质是会把 a 中的每个元素**拷贝赋值**给 i，但问题是，每个元素都是一个数组，而这样就会**自动变为指向数组首个元素的指针**。因此，类型并非是一个包含 3 个元素的数组，而是一个指针。

但如果我们使用正确的指针类型，那么内层的 for 就不对了，因为你无法把 i 当作一个数组，因为它只是一个指针，不能遍历。所以只能改成使用**一般 for**：

    for(int *i:a){ 
    	for(int *j=i;j!=i+3;j++){
    		cout<<*j<<endl; // OK
    	}
    }
    

但是等等，让我们回忆一下之前的[范围 for 的介绍](https://blog.samhou.top/cpp-vector-iterator-guide/)。我们提到过，如果想要修改，可以创建引用，那么就不会拷贝赋值了。

_不会拷贝_？仔细想想这意味着什么：

创建的引用指向的是原来的数组中的数组，也就是**为内层数组创建了别名**！这样的话，自动转换为指针就不存在了（注意这里和之前一样，也得加上括号避免优先级问题）：

    int a[3][3]={};
    for(int (&i)[3]:a){ 
        for(int &j:i){
            cout<<j<<endl;
        }
    }
    

当然，你把最内层的引用去掉也没事。毕竟最内层本身就是个 int，不会再遍历了，加不加取决于你要不要修改。你也可以加上 const 防止修改，同时避免赋值性能损耗，这点我们之前也提到过了。

当然，你也可以用 auto，省点事情：

    for(auto &i:a){ 
        for(auto &j:i){
            cout<<j<<endl;
        }
    }
    

总结
--

对于数组和指针，我们已经非常深入了。现在你应该已经知道了遍历数组的多种方法，如何使用指针控制你的循环，同时用上省事的范围 for 和 auto。下一篇，我们终于将离开这堆你已经有了深入了解的数据海洋，去拆解更多其它 C++ 的知识，同样是奶奶级哦。

本文作者：[SamHou0](https://www.cnblogs.com/samhou/)。原文链接：[https://www.cnblogs.com/samhou/p/19201817/cpp-array-with-pointer](https://www.cnblogs.com/samhou/p/19201817/cpp-array-with-pointer)

本文的所有发布平台：[About](https://blog.samhou.top/about)

本博客所有文章除特别声明外，均采用 CC BY-NC-ND 4.0 许可协议。转载请注明来源 SamHou's blog！