---
layout: post
title: 'c++中bitset的常见用法'
date: "2025-02-20T00:36:29Z"
---
c++中bitset的常见用法
===============

C++ 中的 `bitset` 是一个用于处理固定大小位序列的模板类，提供高效的位操作功能。以下是对其关键特性的详细介绍：

### 1\. **声明与初始化**

*   **头文件**：需包含 `<bitset>`。
*   **声明**：`bitset<N>` 表示一个包含 `N` 位的二进制集合（`N` 为编译时常量）。
    
        bitset<8> b1;       // 默认初始化，所有位为0
        bitset<4> b2(5);    // 用整数初始化：0101
        bitset<4> b3("1010"); // 用字符串初始化：1010
        bitset<4> b4(b3);   // 拷贝构造
        
    

### 2\. **初始化规则**

*   **整数初始化**：高位截断，低位对齐。
    
        bitset<3> b(10);    // 10的二进制为1010 → 截断为010（值为2）
        
    
*   **字符串初始化**：
    
    *   字符串只能包含 `'0'` 和 `'1'`。
    *   默认从字符串的 **左端（高位）** 开始解析。
    
        bitset<4> b("1010"); // 高位 → 低位：1 0 1 0 → 十进制10
        bitset<4> b("101010", 2, 4); // 从索引2取4位："1010" → 值为10
        
    

### 3\. **常用操作**

*   **位访问**：
    
    *   `[]` 运算符：通过索引访问（从右到左，0为最低位）。
    *   `test(pos)`：检查指定位是否为1，越界抛出异常。
    
        bitset<4> b("1010");
        bool bit0 = b[0];   // 0 → 最低位
        bool bit3 = b[3];   // 1 → 最高位
        
    
*   **修改位**：
    
    *   `set(pos, val)`：设置某位（默认1）。
    *   `reset(pos)`：清除某位（设为0）。
    *   `flip(pos)`：翻转某位。
    
        b.set(0);       // 1010 → 1011
        b.reset(3);     // 1011 → 0011
        b.flip(1);      // 0011 → 0001
        
    
*   **统计与判断**：
    
    *   `count()`：返回1的个数。
    *   `any()/none()/all()`：判断是否存在/没有/全部为1。
    
        if (b.any()) cout << "至少1位为1";
        
    

### 4\. **位运算**

*   支持 `&`、`|`、`^`、`~`、`<<`、`>>` 等运算符（长度需相同）：
    
        bitset<4> a("1010"), b("1100");
        auto c = a & b;     // 1000
        auto d = a << 1;    // 0100
        
    

### 5\. **类型转换**

*   `to_ulong()/to_ullong()`：转为无符号整数（可能溢出）。
*   `to_string()`：转为字符串，可指定填充字符。
    
        bitset<4> b(10);
        string s = b.to_string(); // "1010"
        
    

### 6\. **应用场景**

*   位标志管理：如权限控制、状态标记。
*   位掩码操作：快速筛选或修改特定位。
*   数据压缩：高效存储布尔值。

### 示例代码

    #include <bitset>
    #include <iostream>
    using namespace std;
    
    int main() {
        bitset<8> b1(42);          // 00101010
        bitset<8> b2("10101010");  // 10101010
        cout << b1 << endl;         // 输出 00101010
        b1.set(0);                 // 变为 00101011
        b2.flip();                 // 变为 01010101
        cout << (b1 & b2) << endl; // 00000001
        cout << b1.to_ulong() << endl; // 43
        return 0;
    }
    

### 注意事项

*   **越界访问**：`test(pos)` 会检查越界，`[]` 不会。
*   **性能**：位操作高效，适合密集运算。
*   **字符串顺序**：字符串的第一个字符对应高位。

`bitset` 是处理二进制数据的利器，结合明确的位序规则和丰富的接口，可显著简化位级操作代码。