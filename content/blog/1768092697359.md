---
layout: post
title: '20260109 - TRU 协议攻击事件分析：买得够多免费送了喂！'
date: "2026-01-11T00:51:37Z"
---
20260109 - TRU 协议攻击事件分析：买得够多免费送了喂！
==================================

20260109，ETH 链上的 TRU 协议遭受了黑客攻击，损失约 2600 万美元。漏洞原因是计算购买 TRU 代币所需要的 ETH 数量的计算公式设计存在缺陷，购买大量 TRU 代币时会因为精度丢失而得到 0 值，使得攻击者可以以 0 ETH 购买大量的 TRU 代币，最后抛售完成获利。

*   TX：[https://app.blocksec.com/explorer/tx/eth/0xcd4755645595094a8ab984d0db7e3b4aabde72a5c87c4f176a030629c47fb014](https://app.blocksec.com/explorer/tx/eth/0xcd4755645595094a8ab984d0db7e3b4aabde72a5c87c4f176a030629c47fb014)

Trace 分析
========

![image](https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154123776-1794652238.png)

1.  黑客调用 buyTRU() 函数以零成本购入大量的 TRU 代币
2.  然后调用 sellTRU() 函数卖出所有 TRU 代币完成获利

随后攻击者利用漏洞以零或极低成本的价格购买 TRU 代币后出售的流程重复多次。

代码分析
====

TRU 合约是一个代理合约：0x764C64b2A09b09Acb100B80d8c505Aa6a0302EF2

其具体的逻辑逻辑合约为：0x18ceDF1071EC25331130C82D7AF71D393Ccd4446

由于逻辑合约并没有开源，所以接下来会采用 dedaub 反编译 + 人工校正的方式分析项目的业务逻辑。

*   逻辑合约的反编译地址：[https://app.dedaub.com/ethereum/address/0xc186e6f0163e21be057e95aa135edd52508d14d3/decompiled](https://app.dedaub.com/ethereum/address/0xc186e6f0163e21be057e95aa135edd52508d14d3/decompiled)

在 buyTRU() 函数中，会根据输入的 TRUAmount 参数值计算所需要的 ETH 数量，并检查 msg.value 的值是否为相等。通过检查后，会给用户 mint TRUAmount 数量的 TRU 代币。

![image](https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154138455-1713236541.png)

其问题就出在计算 ETH 数量的 TRUtoETH() 函数上，其反编译的内容如下，根据输入的 TRUAmount 值进行一系列的计算。

![image](https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154148291-397462858.png)

通过 solidity 重写这个函数，得到以下的内容。其中 \_setParameters 的值为 75，代表 75% 的一个比例。

    function TRUtoETH(uint256 TRUAmount) private view returns (uint256) {
        uint256 totalSupply = TRU.totalSupply();
        
        // numerator: (100 - 75) * totalSupply² = 25 * totalSupply²
        uint256 numerator = (100 - _setParameters) * totalSupply * totalSupply;
        
        // denominator: 100 * TRUAmount * _reserve * (TRUAmount + 2 * totalSupply)
        uint256 denominator = 100 * TRUAmount * _reserve * (TRUAmount + 2 * totalSupply);
        
        return numerator / denominator;
    }
    
    

由上面的代码分析可得，当 \_setParameters，totalSupply 和 \_reserve 为固定值时，传入的参数 TRUAmount 越大，分母就越大，返回值就会相应的变小。而当分母大于分子时，由于 solidity 精度丢失的特性，返回值将会为 0。也就是说：

> 当 TRUAmount 的值非常大，当前的计算公式在计算所需要提供的 ETH 数量时，会由于 solidity 的精度丢失返回 0 值。

这样，攻击者就完成了攻击的第一个步骤：以零或极低成本的价格购买 TRU 代币。

随后就是正常使用 sellTRU() 函数卖出所有 TRU 代币完成了获利。

![image](https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154205268-1163820900.png)