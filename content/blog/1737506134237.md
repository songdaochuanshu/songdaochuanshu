---
layout: post
title: '微信公众号-脚本简单实现，自动新建草稿并发布草稿文章，代码开源'
date: "2025-01-22T00:35:34Z"
---
微信公众号-脚本简单实现，自动新建草稿并发布草稿文章，代码开源
===============================

介绍
==

本来想写一个自动化发布微信公众号的小绿书的脚本。但是微信公众号官网没有小绿书的接口。

想着算了吧，写都写了，那就写一个微信普通文章的脚本吧。

写完了 就想着把脚本分享出来，给大家一起交流下。

水平有限，大佬轻喷。

思路
==

1，获取百度热搜列表

2，给热搜图片加上文字标题

3，上传图片到微信公众号素材库

4，新建微信公众号草稿

5，发布草稿

前期准备
====

1，[注册微信公众号](https://mp.weixin.qq.com/)，获取AppID和AppSecret

![](https://img2024.cnblogs.com/blog/1257808/202501/1257808-20250121154007800-2087794243.png)

2，微信公众号接口文档（ [文档链接](https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html)），参照文档进行接口调用

3，微信公众号设置IP白名单

在服务器上面获取出口外网ip

curl -s https://ipinfo.io/ip

环境要求
====

1，我使用的是python12

2，依赖就需要安装PIL库，其他库都是默认安装的

(py12-ai-django5) \[root@gtp-test01-cyt wxmp\]# python -V

_Python 3.12.4_

  
\# 

import requests

import os

import time

import yaml

import json

import string

  

from PIL import Image, ImageDraw, ImageFont

\# 安装PIL

pip install pillow==10.4.0

\# 运行脚本wxmp.py 就行

python wxmp.py

\# 输出

图片已保存到 hotimg/orgimg/2.png  
图片已保存到 hotimg/orgimg/3.png  
图片已保存到 hotimg/orgimg/4.png  
图片已保存到 hotimg/orgimg/5.png  
图片已保存到 hotimg/orgimg/6.jpg  
图片已保存到 hotimg/orgimg/7.jpg  
图片已保存到 hotimg/orgimg/8.png  
图片已保存到 hotimg/orgimg/9.png  
图片已保存到 hotimg/orgimg/10.jpg  
图片已保存到 hotimg/orgimg/11.png  
图片已加文字 hotimg/nowimg/2.png  
图片已加文字 hotimg/nowimg/3.png  
图片已加文字 hotimg/nowimg/4.png  
图片已加文字 hotimg/nowimg/5.png  
图片已加文字 hotimg/nowimg/6.jpg  
图片已加文字 hotimg/nowimg/7.jpg  
图片已加文字 hotimg/nowimg/8.png  
图片已加文字 hotimg/nowimg/9.png  
图片已加文字 hotimg/nowimg/10.jpg  
图片已加文字 hotimg/nowimg/11.png  
新建草稿成功--{'media\_id': 'V4QdIouS1e-m5FaD0\_0keQQMcEMKo0-3YjLoF\_JqJohqywWC3Byyr81SXUi1TheO', 'item': \[\]}  
{'errcode': 0, 'errmsg': 'ok', 'publish\_id': 2247483801, 'msg\_data\_id': 2247483801}

 获取接口token
==========

1，由于access\_token的有效期只有2小时，故需要定时刷新。

2，这里使用app\_token.yaml来保存获取到的token以及时间；token在时效内返回保存的token，超过时效会获取新的token

def get\_token(
        app\_id\='',  # 微信公众号AppID
        app\_secret=''  # 微信公众号AppSecret
):
    """
    获取token
    :return:
    """
    url \= f'https://api.weixin.qq.com/cgi-bin/token?grant\_type=client\_credential&appid={app\_id}&secret={app\_secret}'
    res \= requests.get(url=url)
    result \= res.json()
    if result.get('access\_token'):
        token \= result\['access\_token'\]
        print(f"获取token成功：{token\[:14\]}\*\*\*\*")
        return token
    else:
        print(f"获取token失败--{result}")

def refresh\_token():
    """
    token刷新机制
    :return:
    """
    app\_token\_path \= os.path.dirname(os.path.abspath(\_\_file\_\_)) + os.sep + 'app\_token.yaml'
    try:
        # 读取时间和token
        if not os.path.exists(app\_token\_path):
            with open(app\_token\_path, 'w+') as f:
                f.write('')
        cfg\_token \= yaml\_read(app\_token\_path)
        t \= cfg\_token\['time'\]
        record\_token \= cfg\_token\['token'\]
        cur\_time \= time.time()
        # token时间在7200s之内，返回token
        if 0 < cur\_time - t < 7200:
            # print(f"token时效内")
            return record\_token
        # token过期，刷新时间和token
        else:
            # print('token已过期')
            token = get\_token()
            if token:
                data \= {'time': time.time(), 'token': token}
                yaml\_clear(app\_token\_path)
                yaml\_write(data, app\_token\_path)
                return token
    except TypeError:
        # 获取初始时间和token
        print('获取初始token')
        token \= get\_token()
        data \= {'time': time.time(), 'token': token}
        yaml\_write(data, app\_token\_path)
        return token

def yaml\_read(file):
    """
    yaml文件读取
    :param file:
    :return:
    """
    with open(file\=file, mode="r", encoding="utf-8") as f:
        data \= yaml.safe\_load(f.read())
    return data

def yaml\_write(data, file):
    """
    yaml文件写入
    :param data:
    :param file:
    :return:
    """
    with open(file, 'a', encoding='utf-8') as f:
        yaml.dump(
            data,
            stream\=f,
            allow\_unicode\=True,  # 避免unicode编码问题
            sort\_keys=False  # 不自动排序
        )

def yaml\_clear(file):
    """
    yaml文件清空
    :param file:
    :return:
    """
    with open(file, 'w', encoding='utf-8') as f:
        f.truncate()

获取热搜
====

这里我是找的网上别人写好的接口。简单快速方便

https://dabenshi.cn/other/api/hot.php?type=douyinhot // 抖音热点
https://dabenshi.cn/other/api/hot.php?type=toutiaoHot // 头条热榜
https://dabenshi.cn/other/api/hot.php?type=baidu // 百度热搜

我这里使用的是百度热搜。

获取热搜数据
------

# 获取热搜数据
def get\_hotdata():
    '''
    获取百度热搜的数据
    url网上找的: https://dabenshi.cn/other/api/hot.php?type=baidu
    '''
    url \= f"https://dabenshi.cn/other/api/hot.php?type=baidu"
    hotdata \= \[\] # 存储所有的热搜数据
    res \= requests.get(url=url)
    result \= res.json()
    hotdata \= result\['data'\]\[1:11\]    # 这里我只拿了10条数据  
  
  
\# 数据就是一个打列表，里面有字典  
hotdata =\[

        _{
            "index": 2,
            "title": "外交部回应是否邀请特朗普访华",
            "desc": "1月21日，外交部就“中方是否邀请特朗普访华”一事做出回应：愿同美国新政府保持沟通，加强合作。",
            "pic": "https:\\/\\/fyb-2.cdn.bcebos.com\\/hotboard\_image\\/4d0700b48e6c791e29f1e231e24af061",
            "url": "https:\\/\\/www.baidu.com\\/s?wd=%E5%A4%96%E4%BA%A4%E9%83%A8%E5%9B%9E%E5%BA%94%E6%98%AF%E5%90%A6%E9%82%80%E8%AF%B7%E7%89%B9%E6%9C%97%E6%99%AE%E8%AE%BF%E5%8D%8E&sa=fyb\_news&rsv\_dl=fyb\_news",
            "hot": "797.6万",
            "mobilUrl": "https:\\/\\/www.baidu.com\\/s?wd=%E5%A4%96%E4%BA%A4%E9%83%A8%E5%9B%9E%E5%BA%94%E6%98%AF%E5%90%A6%E9%82%80%E8%AF%B7%E7%89%B9%E6%9C%97%E6%99%AE%E8%AE%BF%E5%8D%8E&sa=fyb\_news&rsv\_dl=fyb\_news"
        }  
\]_

下载热搜图片
======

其实就是把热搜数据里面的pic图片保存到了本地

这样一会就好给图片加上标题文字了

def get\_hotimg(hotdataall):
    """
    下载热搜图片
    hotdata: 所有数据
    """

    if hotdataall:
        for hotdata in hotdataall:
            try:
                # 发送HTTP GET请求获取图片数据
                response = requests.get(hotdata\['pic'\], timeout=10)
                # 检查请求是否成功
                if response.status\_code == 200:
                    # 获取Content-Type头信息
                    content\_type = response.headers.get('Content-Type')

                    # 根据Content-Type判断图片类型
                    image\_extension = None
                    if content\_type == 'image/jpeg':
                        image\_extension \= '.jpg'
                    elif content\_type == 'image/png':
                        image\_extension \= '.png'
                    elif content\_type == 'image/gif':
                        image\_extension \= '.gif'
                    else:
                        raise Exception(f"Unsupported image type: {content\_type}")

                    # 以二进制写模式打开文件，并将图片数据写入文件
                    img\_name = "hotimg/orgimg/" + str(hotdata\['index'\]) + image\_extension
                    img\_name\_new \= "hotimg/nowimg/" + str(hotdata\['index'\]) + image\_extension
                    with open(img\_name, 'wb') as file:
                        file.write(response.content)
                    print(f'图片已保存到 {img\_name}')

                    hotdata\['image\_path'\] = img\_name
                    hotdata\['image\_path\_new'\] = img\_name\_new
                else:
                    print(f'下载图片失败，状态码: {response.status\_code}')
            except requests.RequestException as e:
                print(f'请求出现异常: {e}')

给图片加上标题文字
=========

# 给图片加上文字
    if hotdata:
        for hotdata\_in in hotdata:
            image\_path \= hotdata\_in\['image\_path'\]
            image\_path\_new \= hotdata\_in\['image\_path\_new'\]
            text \= hotdata\_in\['title'\]
            max\_width \= 500

            add\_text\_to\_image(image\_path, image\_path\_new, text\=text, max\_width=max\_width)

def add\_text\_to\_image(image\_path, image\_path\_new, text='', max\_width=500):
    '''
    给图片添加文字
    '''
    image \= Image.open(image\_path)
    draw \= ImageDraw.Draw(image)
    width, height \= image.size

    font\_size \= max(30, int(width \* 0.03))

    font \= ImageFont.truetype("ttf/feihuasongti.ttf", font\_size)
    text\_color \= (255, 255, 255)  # 黑色字体
    shadow\_color = (0, 0, 0)  # 黑色阴影
    # text\_width, text\_height = draw.textsize(text, font=font)
    # 获取文本尺寸
    bbox = draw.textbbox((0, 0), text, font=font)
    text\_width \= bbox\[2\] - bbox\[0\]
    text\_height \= bbox\[3\] - bbox\[1\]

    while text\_width > width - 30:
        font\_size \-= 1
        font \= ImageFont.truetype("ttf/feihuasongti.ttf", font\_size)
        # text\_width, text\_height = draw.textsize(text, font=font)
        # 获取文本尺寸
        bbox = draw.textbbox((0, 0), text, font=font)
        text\_width \= bbox\[2\] - bbox\[0\]
        text\_height \= bbox\[3\] - bbox\[1\]

    # 计算文本位置
    x = width - text\_width
    y \= height - text\_height - 30
    # 绘制文本阴影
    draw.text(((x/2) + 2, y + 2), text, font=font, fill=shadow\_color)
    draw.text((x / 2, y), text, font=font, fill=text\_color)

    image.save(image\_path\_new)
    print(f'图片已加文字 {image\_path\_new}')

类似这样，在图片底部加上文字

![](https://img2024.cnblogs.com/blog/1257808/202501/1257808-20250121160053216-1827689939.png)

上传图片素材
======

这块会返回上传到素材url。这个url地址，可以在文章里面使用

def add\_media(hotdataall):
    """
    新增临时素材: https://api.weixin.qq.com/cgi-bin/media/upload?access\_token=ACCESS\_TOKEN&type=TYPE
    上传图文消息内的图片获取URL, 新增永久素材: https://api.weixin.qq.com/cgi-bin/media/uploadimg?access\_token=ACCESS\_TOKEN
    新增其他类型永久素材, 新增永久素材: https://api.weixin.qq.com/cgi-bin/material/add\_material?access\_token=ACCESS\_TOKEN&type=TYPE
    """
    # url = f"https://api.weixin.qq.com/cgi-bin/media/upload?access\_token={refresh\_token()}&type=image"
    url = f"https://api.weixin.qq.com/cgi-bin/media/uploadimg?access\_token={refresh\_token()}"

    if hotdataall:
        for hotdata in hotdataall:
            with open(hotdata\['image\_path\_new'\], 'rb') as fp:
                files \= {'media': fp}
                res \= requests.post(url, files=files)
                res \= json.loads(str(res.content, 'utf8'))
                hotdata\["wx\_img\_url"\] = res\['url'\]

新建草稿
====

这里会返回草稿的ID

def add\_draft(hotdataall):
    '''
    新建草稿
    '''
    url \= f'https://api.weixin.qq.com/cgi-bin/draft/add?access\_token={refresh\_token()}'

    # content = "<img src='https://mmbiz.qpic.cn/sz\_mmbiz\_jpg/hY63os7Ee2Ro6WVkfj9nvfDdpONqLwr48J2eQEYXygs3cWibLvQTHAveYWNnXOOWHO3jZldO3fr7quVj6V0X5uA/0?wx\_fmt=jpeg'/>"
    # 读取文件html
    # 打开HTML文件并读取内容
    with open('content.html', 'r', encoding='utf-8') as file:
        html\_content\_template \= file.read()

    # 动态生成草稿content内容全部，先定义一个变量
    html\_content = ""

    # 动态生成草稿content内容片段
    for hotdata in hotdataall:
        # 判断热搜第一
        if hotdata\['index'\] == 2:
            title\_color \= "red"
        else:
            title\_color \= "black"

        # 定义变量
        hot\_context = {
            'num': hotdata\['index'\] - 1,
            'url\_img': hotdata\['wx\_img\_url'\],
            'title\_color': title\_color,
            'title\_title': hotdata\['title'\],
            'describe': hotdata\['desc'\],
        }

        # 替换变量
        substitute\_data = string.Template(html\_content\_template)
        result \= substitute\_data.safe\_substitute(hot\_context)
        html\_content += result

    data \= {
        "articles": \[
            {
                "title":"标题",
                "author":"作者",
                "digest":"描述",
                "content":html\_content,
                "thumb\_media\_id":"封面素材ID",
                "need\_open\_comment":1,
                "only\_fans\_can\_comment":1
            }
        \]
    }

    res \= requests.post(url=url, data=json.dumps(data, ensure\_ascii=False).encode('utf-8'))

    if res.status\_code == 200:
        result \= json.loads(res.content)
        if result.get('media\_id'):
            print(f'新建草稿成功--{result}')
            return result\['media\_id'\]
        else:
            print(f'新建草稿失败--{result}')
    else:
        print(f'新建草稿失败--{res.text}')

发布草稿
====

def free\_publish(media\_id):
    '''
    发布草稿
    '''
    url \= f'https://api.weixin.qq.com/cgi-bin/freepublish/submit?access\_token={refresh\_token()}'

    data \= {
        "media\_id": media\_id
    }

    res \= requests.post(url=url, json=data)
    res \= json.loads(str(res.content, 'utf8'))
    print(res)

源码
==

gitee：[https://gitee.com/ccsang/wxmp](https://gitee.com/ccsang/wxmp)

关注我的公众号
=======

这个公众号的文章就是这个脚本定时发送的。

![](https://img2024.cnblogs.com/blog/1257808/202501/1257808-20250121164236782-1608543354.jpg)

希望这个脚本对你有用。欢迎交流

最近想弄些PRA，自动化弄下那些没有接口的应用的。有大佬指教吗。