---
layout: post
title: 'dp 总结 1'
date: "2025-10-03T00:37:54Z"
---
dp 总结 1
=======

dp 总结 1

闲来无事, 把刚学明白的 dp 笔记整理一下.

shout out to professor [Adzlpxsn](https://codeforces.com/profile/Adzlpxsn).

基本的, 状态, 转移, 方程
===============

状态
--

一句话概况即为当前的属性.

比如说, 贝贝现在是 \\(30\\) 岁, 发了 \\(0\\) 张专辑, 我们就可以说 \\(f\_{30}=0\\).

这里我们说 \\(30\\) 和 \\(0\\) 是不同的信息, 所以一个状态 \\(f\_{x}=y\\) 里包含的信息其实有 \\(x\\) 和 \\(y\\).

同样的, \\(f\_{x,y}=z\\) 里包含的信息有 \\(3\\) 个, 即 \\(x\\) \\(y\\) \\(z\\).

转移
--

转移, 就是说用 \\(f\_{x}\\) 推算 \\(f\_{y}\\), 或者用 \\(f\_{x}\\) 和 \\(f\_{y}\\) 推算 \\(f\_{z}\\).

举个例子.

贝贝的新专辑 "金手指", 第 \\(x\\) 首歌是 boombap 还是 trap 取决于第 \\(x-1\\) 首和第 \\(x-2\\) 首, 即 \\(f\_{x}=(f\_{x-1}+f\_{x-2}) \\bmod 2\\). 那么我们就说 \\(f\_{x}\\) 由 \\(f\_{x-1}\\) 和 \\(f\_{x-2}\\) 转移而来.

方程
--

方程就是把转移的过程写成人类能看懂的东西, 比如 "数学语言" "自然语言" "编程语言".

线性 dp
=====

最简单的线性 dp, 就是跳跃问题.

[problem:AtCoder-dp\_a](https://vjudge.net/problem/AtCoder-dp_a#author=GPT_zh)

考虑状态, 我们让 \\(f\_{x}\\) 表示现在位于 \\(stone\_{x}\\) 时最少跳了多少.

转移就比较容易了, \\(f\_{x}=\\operatorname{std::min}(f\_{x-2}+|h\_{x-2}-h\_{x}|,f\_{x-1}+|h\_{x-1}-h\_{x}|)\\).

没什么好讲的, 注意边界条件初始化就好了, 难的题就很难.

背包 dp
=====

这个就好玩了.

01 背包
-----

我个人觉得背包 dp 和线性 dp 大抵是有血缘关系的罢.

[problem:AtCoder-dp\_d](https://vjudge.net/problem/AtCoder-dp_d#author=GPT_zh)

可以想到, 我们让 \\(f\_{c}\\) 表示在背包容量为 \\(c\\) 时的最大价值.

于是有转移方程 \\(f\_{c}=\\operatorname{std::max}(f\_{c},f\_{c-w\_{x}}+v\_{x})\\).

那么这时候我们有一个问题.

> 如果内层循环从 \\(w\_{x}\\) 枚举到 \\(W\\), 那么有可能会造成重复选择, 但题意说每个物品只有 \\(1\\) 个.

于是我们可以调转内层循环的方向, 从 \\(W\\) 枚举到 \\(w\_{x}\\), 此时每个物品就只会被选一次了.

代码

    for(ll	x=1;x<=n;x++)	// 枚举每个物品
    	for(ll	c=W;w[x]<=c;c--)	// 枚举背包大小
    		f[c]=std::max(f[c],f[c-w[x]]+v[x]);	// 转移
    std::cout<<f[W]<<"\n";
    

完全背包
----

再考虑, 如果每个物品可以选无数次呢?

[problem:洛谷-P1616](https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P1616)

显然, 只要把内层循环的方向调回去就可以了.

    for(ll	x=1;x<=n;x++)	// 枚举每个物品
    	for(ll	c=w[x];c<=W;c++)	// 枚举背包大小
    		f[c]=std::max(f[c],f[c-w[x]]+v[x]);	// 转移
    std::cout<<f[W]<<"\n";
    

多重背包
----

现在我们说, 每个物品不止有 \\(1\\) 个, 但也不能无限选, 于是我们说物品 \\(x\\) 有 \\(t\_{x}\\) 个, 这就是多重背包.

[problem:洛谷-1776](https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P1776)

如果当成 \\(t\_{x}\\) 个相同物品那么显然会超时, 因为 \\(\\sum\\limits\_{x\\in\[1,n\]}t\_{x}\\ge+\\infin\\).

于是我们想, 我们学计算机最重要的是什么? 是二进制.

是的, 我们只要拆分成二进制就好了.

    std::vector<td>v,w;
    for(td	x=1;x<=n;x++){
    	td	vx,wx,tx;
    	std::cin>>vx>>wx>>tx;
    	for(td	f=1;f<=tx;f<<=1){	// 二进制分解
    		v.emplace_back(vx*f);
    		w.emplace_back(wx*f);
    		tx-=f;
    	}	if(tx!=0){	// 最后还剩一点点, 单独做成一个
    		v.emplace_back(vx*tx);
    		w.emplace_back(wx*tx);
    	}
    }
    

然后跑一遍 01 背包就解决了.

分组背包
----

当每一组物品里只能选 \\(1\\) 个的时候应该怎么办呢?

[problem:洛谷-P1757](https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P1757)

这里留给读者思考, 简单放一下代码, 和 01 背包也差不多.

    ll	t=0;
    std::vector<std::vector<ll>>g(n+1);
    for(ll	x=1;x<=n;x++){
    	ll	s;
    	std::cin>>w[x]>>v[x]>>s;
    	t=std::max(t,s);
    	g[s].emplace_back(x);
    }
    for(ll	s=1;s<=t;s++)
    	for(ll	c=W;0<=c;c--)
    		for(ll	x:g[s])
    			if(w[x]<=c)
    				f[c]=std::max(f[c],f[c-w[x]]+v[x]);
    std::cout<<f[W]<<"\n";
    

时间复杂度总结
=======

像线性 dp 就是 \\(O(n\*k)\\), 其中 \\(k\\) 为转移复杂度, 比如之后会讲的优化就能搞出 \\(k=\\log n\\).

背包 dp 就比较固定了, 都是 \\(O(n\*W)\\). 特别的, 由于多重背包是二进制搞来的, 所以多重背包的 \\(n'=\\sum\\limits\_{x\\in\[1,n\]}\\log x\\)

下期预告
====

区间 dp, 状压 dp.

原文来自CnBlogs, 作者: [young\_tea](https://www.cnblogs.com/young-tea/).