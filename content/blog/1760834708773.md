---
layout: post
title: 'WPF/C#：使用Microsoft Agent Framework框架创建一个带有审批功能的终端Agent'
date: "2025-10-19T00:45:08Z"
---
WPF/C#：使用Microsoft Agent Framework框架创建一个带有审批功能的终端Agent
======================================================

前言
--

最近新出了一个Microsoft Agent Framework框架，我感觉还挺有意思的，就通过它的那个`Using function tools with human in the loop approvals`例子，做了一个终端助手Agent。我觉得使用这个作为学习人在环上这个例子蛮合适的，因为对于需要执行敏感操作（如系统命令）的场景，人工审批机制显得尤为重要。本文以Rouyan为例，说明如何使用Microsoft Agent Framework创建一个能够执行终端命令并具备人工审批功能的WPF应用。

在详细介绍之前，先来看看它的效果。

1、比如获取当前时间

会先弹出一个人工审批窗口：

然后你点击同意了才会执行：

如果你拒绝了就是这样：

实际上你可以利用终端做很多事情，我再举一个例子。

2、新建一个文件，写入你好：

选择同意，结果如图所示：

在介绍如何具体实现之前，先来介绍一下Microsoft Agent Framework。

Microsoft Agent Framework介绍
---------------------------

GitHub上的简介是：“一个用于构建、编排和部署AI代理及多代理工作流程的框架，支持Python和.NET。”

GitHub地址：[https://github.com/microsoft/agent-framework](https://github.com/microsoft/agent-framework)

Microsoft Agent Framework 是一个开源开发工具包，用于为 .NET 和 Python 构建 AI 代理和多代理工作流。它整合并扩展了 Semantic Kernel 和 AutoGen 项目的思想，融合了两者的优点，并新增了多项功能。该框架由同一团队开发，将成为未来构建 AI 代理的统一基础。

Agent Framework 提供了两大主要功能类别：

AI 代理：单个代理利用大语言模型（LLM）处理用户输入，调用工具和 MCP 服务器执行操作，并生成响应。代理支持的模型提供商包括 Azure OpenAI、OpenAI 和 Azure AI。

工作流：基于图形的工作流，用于连接多个代理和功能，以执行复杂的多步骤任务。工作流支持基于类型的路由、嵌套、检查点以及适用于人工干预场景的请求/响应模式。

该框架还提供了基础构建模块，包括模型客户端（聊天补全和响应）、用于状态管理的代理线程、用于代理记忆的上下文提供程序、用于拦截代理操作的中间件，以及用于工具集成的MCP客户端。这些组件共同为您提供灵活性和强大功能，以构建交互性强、稳健且安全的AI应用程序。

具体实现
----

1、安装Nuget包：

2、编写运行脚本的函数

    [Description("Execute a Windows cmd.exe script and return its output.")]
    static string ExecuteCmd([Description("The script content to run via 'cmd.exe /c'.")] string script)
    {
        try
        {
            var psi = new ProcessStartInfo("cmd.exe", "/c " + script)
            {
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true
            };
    
            using (var process = new Process())
            {
                process.StartInfo = psi;
                process.Start();
    
                string output = process.StandardOutput.ReadToEnd();
                string error = process.StandardError.ReadToEnd();
    
                process.WaitForExit();
    
                if (!string.IsNullOrWhiteSpace(error))
                {
                    return $"错误: {error.Trim()}";
                }
    
                return output.Trim();
            }
        }
        catch (Exception ex)
        {
            return $"执行失败: {ex.Message}";
        }
    }
    

3、配置AI Agent

文档中只写了Azure中怎么使用，兼容OpenAI格式的可以这样写：

     // 配置AI Agent
     DotEnv.Load();
     var envVars = DotEnv.Read();
    
     var apiKey = envVars["OPENAI_API_KEY"];
     var model = envVars["OPENAI_CHAT_MODEL"];
     var baseUrl = new Uri(envVars["OPENAI_BASE_URL"]);
    
     ApiKeyCredential apiKeyCredential = new ApiKeyCredential(apiKey);
    
     OpenAIClientOptions openAIClientOptions = new OpenAIClientOptions();
     openAIClientOptions.Endpoint = baseUrl;
    
     AIAgent agent = new OpenAIClient(apiKeyCredential, openAIClientOptions)
         .GetChatClient(model)
         .CreateAIAgent(instructions: "你是一个乐于助人的助手，可以执行命令行脚本。请使用中文回答。", tools: [new ApprovalRequiredAIFunction(AIFunctionFactory.Create(ExecuteCmd))]);
    

这里有一个新东西就是`ApprovalRequiredAIFunction`。

这说明如果调用这个函数需要经过人工审批。

4、审批流程

    // Call the agent and check if there are any user input requests to handle.
    AgentThread thread = agent.GetNewThread();
    
    var response = await agent.RunAsync(InputText, thread);
    var userInputRequests = response.UserInputRequests.ToList();
    

我们先来看看这个是什么，运行起来打个断点看看：

这就是一个Agent想要执行的函数，那么现在来看看如何审批：

    while (userInputRequests.Count > 0)
    {
        var userInputResponses = new List<ChatMessage>();
    
        foreach (var functionApprovalRequest in userInputRequests.OfType<FunctionApprovalRequestContent>())
        {
            var scriptContent = functionApprovalRequest.FunctionCall.Arguments?["script"]?.ToString() ?? "未知脚本";
            var functionName = functionApprovalRequest.FunctionCall.Name;
    
            var dialogVm = new HumanApprovalDialogViewModel
            {
                Title = "命令执行审批",
                Message = $"是否同意执行以下命令？\n\n函数名称: {functionName}\n脚本内容: {scriptContent}"
            };
    
            bool? result = _windowManager.ShowDialog(dialogVm);
            bool approved = result == true;
    
            userInputResponses.Add(new ChatMessage(ChatRole.User, [functionApprovalRequest.CreateResponse(approved)]));
        }
    
        // Pass the user input responses back to the agent for further processing.
        response = await agent.RunAsync(userInputResponses, thread);
        userInputRequests = response.UserInputRequests.ToList();
    }
    

根据这个地方`userInputResponses.Add(new ChatMessage(ChatRole.User, [functionApprovalRequest.CreateResponse(approved)]));`中的approved传入的是true还是false表示用户是同意还是拒绝。

然后发送请求获取新的回复，直到没有需要人工审批的函数为止。

5、流式响应

最后再获取一个流式响应：

    await foreach (var update in agent.RunStreamingAsync("输出最终答案", thread))
    {
        OutputText += update.Text;
    }
    

最后
--

以上就是本期的全部内容，希望对你有所帮助。

全部代码已上传至GitHub，地址：[https://github.com/Ming-jiayou/Rouyan。](https://github.com/Ming-jiayou/Rouyan%E3%80%82)

终端助手的代码主要在src/Rouyan/Pages/ViewModel/TerminalAgentViewModel.cs中。