---
layout: post
title: 'Oracle数据库性能诊断与SQL优化实战指南'
date: "2025-12-08T00:44:07Z"
---
Oracle数据库性能诊断与SQL优化实战指南
-----------------------

在数据库运维与开发中，Oracle数据库的高性能稳定运行是业务连续性的核心保障。随着数据量增长与并发访问加剧，性能瓶颈往往成为系统短板，而SQL语句优化与执行计划调优是解决性能问题的关键。

一、AutoTrace：SQL优化的基础工具
----------------------

AutoTrace是Oracle SQL\*Plus提供的轻量型SQL诊断工具，能够跟踪执行计划、收集统计信息，是SQL优化的入门必备工具。其核心价值在于快速定位SQL执行中的低效操作，为优化提供数据支撑。

### 1.1 AutoTrace的启用与配置

Oracle10g前后的AutoTrace启用流程存在差异，需针对性配置：

*   **Oracle10g之前版本**：需手动创建基础表、角色并授权
    1.  执行`$ORACLE_HOME\rdbms\admin\utlxplan.sql`创建plan\_table，为多用户共享创建公有同义词并授权`public`；
    2.  运行`$ORACLE_HOME\sqlplus\admin\plustrce.sql`创建plustrace角色，授予v\_$sesstat、v\_$statname等视图查询权限；
    3.  将plustrace角色授予public，确保所有用户均可使用。
*   **Oracle10g及以后版本**：功能默认增强，无需手动创建plan\_table（Oracle内置PLAN\_TABLE$字典表及公有同义词），直接启用即可。

AutoTrace核心参数配置：

    SET AUTOTRACE OFF -- 关闭（默认）
    SET AUTOTRACE ON EXPLAIN -- 仅显示执行计划
    SET AUTOTRACE ON STATISTICS -- 仅显示统计信息
    SET AUTOTRACE ON -- 显示执行计划+统计信息
    SET AUTOTRACE TRACEONLY -- 显示执行计划+统计信息，不输出查询结果
    

### 1.2 AutoTrace的功能增强与内部原理

*   **Oracle10gR2增强特性**：执行计划输出格式化，新增Plan hash value、Predicate Information等关键信息，结合dbms\_xplan工具实现更友好的结果展示；
*   **内部运行机制**：启用AutoTrace时，Oracle会创建两个会话——主会话执行SQL查询，辅助会话记录执行计划与统计信息，二者共享同一操作系统进程；
*   **核心价值**：可快速识别视图底层基础表，为Oracle内部机制研究提供便捷途径，例如通过`SET AUTOTRACE TRACE EXPLAIN`查询plan\_table的底层存储结构。

### 1.3 AutoTrace在SQL优化中的实战应用

某生产环境中，如下SQL存在性能瓶颈：

    SELECT * FROM sys_user 
    WHERE user_code = 'zhangyong' 
    OR user_code IN (SELECT grp_code FROM sys_grp WHERE sys_grp.user_code = 'zhangyong')
    

通过AutoTrace分析发现：

*   执行计划显示全表扫描SYS\_USER表（15190条记录），逻辑读高达30590；
*   FILTER操作导致大量无效数据扫描，性能低效。

优化方案：通过UNION ALL展开OR条件，避免FILTER操作，利用索引访问替代全表扫描：

    SELECT * FROM sys_user WHERE user_code = 'zhangyong' 
    UNION ALL 
    SELECT * FROM sys_user WHERE user_code <> 'zhangyong' 
    AND user_code IN (SELECT grp_code FROM sys_grp WHERE sys_grp.user_code = 'zhangyong')
    

优化后效果：逻辑读从30590降至130，执行效率提升99.6%，执行计划转为NESTED LOOPS关联与索引扫描。

二、SQL执行计划的多维度获取方法
-----------------

执行计划是SQL优化的核心依据，Oracle提供多种获取方式，适用于不同诊断场景，需根据实际需求灵活选择。

### 2.1 基于V$SQL\_PLAN的实时执行计划获取

V$SQL\_PLAN视图记录了缓存中或正在执行的SQL执行计划，支持实时诊断，适用于生产环境性能问题定位：

*   **核心优势**：无需干预SQL执行，直接获取运行时执行计划，避免Explain Plan的静态分析偏差；
*   **使用方法**：通过SQL的HASH\_VALUE关联查询，例如：
    
        create table t as select * from v$sql_plan where hash_value=3740055767; -- 保存执行计划到临时表
        
    
*   **实战案例**：某存储过程执行缓慢，通过在过程中启用SQL\_TRACE获取问题SQL的HASH\_VALUE，再通过V$SQL\_PLAN定位执行计划偏差——发现CBO错误选择位图转换（bitmap convert）导致性能下降，删除冗余索引后恢复正常。

### 2.2 EXPLAIN PLAN与DBMS\_XPLAN的组合使用

EXPLAIN PLAN用于生成SQL执行计划并存储到plan\_table，DBMS\_XPLAN负责格式化展示，二者结合适用于离线SQL分析：

*   **基础用法**：
    
        EXPLAIN PLAN FOR SELECT * FROM emp WHERE empno=7788; -- 生成执行计划
        SELECT plan_table_output FROM TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE','NO','ALL')); -- 展示详情
        
    
*   **Oracle10g增强功能**：
    *   DISPLAY\_CURSOR：通过SQL\_ID获取共享池中的执行计划，支持实时会话SQL诊断；
    *   DISPLAY\_AWR：从AWR（自动工作负载库）中获取历史SQL执行计划，适用于间歇性性能问题追溯。

### 2.3 基于AWR的历史执行计划查询

AWR自动存储数据库运行历史数据，通过DBMS\_XPLAN.DISPLAY\_AWR可获取历史SQL的执行计划，适用于问题回溯：

*   **核心参数**：需指定SQL\_ID，支持多版本执行计划对比；
*   **使用示例**：
    
        select * from table(dbms_xplan.display_awr('072t81cu41xfj'));
        
    
*   **适用场景**：SQL执行计划不稳定导致的间歇性性能问题，可通过历史计划对比定位优化器选择偏差原因。

三、问题SQL捕获与CPU过度消耗解决方案
---------------------

生产环境中，CPU过度消耗往往由低效SQL引发，需通过系统工具与数据库视图联动定位，精准解决性能瓶颈。

### 3.1 系统层面的问题定位

*   **vmstat工具**：监控CPU使用率与运行队列，当idle值接近0且运行队列进程数超过CPU核心数时，说明CPU存在瓶颈；
*   **top工具**：排查高CPU消耗进程，若多个oracle进程平均消耗CPU（1%左右），需警惕大量低效SQL并发执行；
*   **进程数量检查**：通过`ps -ef|grep ora|wc -l`统计Oracle进程数，若远超正常连接数（如从100增至300+），可能是SQL执行阻塞导致进程累积。

### 3.2 数据库层面的SQL捕获与优化

*   **等待事件分析**：查询v$session\_wait，若存在大量`db file scattered read`（全表扫描）或`db file sequential read`（索引扫描等待），需重点关注对应SQL；
*   **SQL捕获脚本**：通过sid关联v$session与v$sqltext，获取问题SQL：
    
        SELECT sql_text FROM v$sqltext a 
        WHERE a.hash_value = (SELECT sql_hash_value FROM v$session b WHERE b.SID = '&sid') 
        ORDER BY piece ASC;
        
    
*   **实战案例**：某生产系统CPU使用率达97%，通过v$session\_wait发现大量`db file scattered read`等待，捕获SQL后发现HS\_INFO表（22万条记录）全表扫描。该表numcatalogguid字段无索引，创建索引后：
    
        create index hs_info_NUMCATALOGGUID on hs_info(NUMCATALOGGUID);
        
    
    逻辑读从3499降至89，CPU使用率恢复正常（idle值60%+）。

### 3.3 关键优化原则

*   大表避免全表扫描，通过索引访问提升效率；
*   利用Oracle的`_small_table_threshold`参数区分大小表，合理设置缓冲池策略；
*   避免索引过度创建，聚焦高区分度字段（如numcatalogguid）。

四、SQL\_TRACE/10046事件：深度诊断工具
---------------------------

SQL\_TRACE是Oracle内核级跟踪工具，10046事件是其增强版本，支持捕获SQL解析、执行计划、绑定变量、等待事件等细节，是复杂性能问题的终极诊断手段。

### 4.1 基础配置与使用方法

*   **SQL\_TRACE启用方式**：
    *   全局启用：`sql_trace = true`（pfile/spfile中设置，生产环境慎用）；
    *   会话级启用：`alter session set sql_trace=true;`；
    *   跟踪其他会话：`exec dbms_system.set_sql_trace_in_session(9,437,true);`（需sid与serial#）。
*   **10046事件级别**：
    *   Level 1：等价于SQL\_TRACE；
    *   Level 4：增加绑定变量捕获；
    *   Level 8：增加等待事件跟踪；
    *   Level 12：Level 1+4+8（生产环境推荐）。
*   **跟踪文件处理**：通过tkprof工具格式化trace文件：
    
        tkprof eygle_ora_28653.trc auto.log aggregate=no
        
    

### 4.2 典型案例解析

#### 案例1：隐式转换导致索引失效

某新闻发布系统访问缓慢，通过10046事件跟踪发现：

    select auditstatus,categoryid from categoryarticleassign where articleId=20030700400141;
    

*   表结构中articleId为VARCHAR2类型，查询条件中传入数字类型，导致隐式转换；
*   执行计划显示全表扫描（逻辑读3892），索引IDX\_ARTICLEID未被使用。

解决方案：统一数据类型，在条件中添加单引号：

    select auditstatus,categoryid from categoryarticleassign where articleId='20030700400141';
    

优化后逻辑读降至2，索引正常生效。

#### 案例2：后台错误跟踪（ORA-00604）

执行`drop user wapcomm`时报错ORA-00604，通过SQL\_TRACE跟踪发现：

*   递归SQL尝试删除SDO\_GEOM\_METADATA\_TABLE表数据，但该表不存在；
*   定位为Oracle Spatial Option安装残留问题，删除MDSYS用户后问题解决。

### 4.3 与等待事件、参数调优的联动

*   **等待事件分析**：10046事件可捕获`db file scattered read`等等待，结合v$event\_name视图解读参数含义；
*   **db\_file\_multiblock\_read\_count参数**：影响全表扫描效率，设置过大可能导致CBO倾向全表扫描，需结合IO能力调整（推荐值≤32）；
*   **IO能力测试**：通过10046事件跟踪全表扫描的IO次数，评估`db_file_multiblock_read_count`最优值。

五、物化视图：翻页查询与大数据量优化方案
--------------------

物化视图通过预计算、预存储聚合数据，以空间换时间，适用于翻页查询、报表统计等场景，可显著降低逻辑读与排序消耗。

### 5.1 物化视图的创建与配置

某婚恋系统翻页查询存在性能问题，SQL如下：

    SELECT * FROM (SELECT t.*, ROWNUM i 
    FROM (SELECT u.numuserid, u.vc2username FROM hw_user4love u 
    WHERE u.numintention <> 99 ORDER BY u.numusertype DESC) t 
    WHERE ROWNUM <= 40) WHERE i > 20;
    

该SQL涉及3张底层表全表扫描，逻辑读44760，排序消耗大量临时表空间（ORA-1652错误）。

创建物化视图优化：

    CREATE MATERIALIZED VIEW HW_User4Love 
    BUILD IMMEDIATE 
    REFRESH COMPLETE START WITH SYSDATE NEXT trunc(sysdate+1) +4/24 
    ENABLE QUERY REWRITE 
    AS 
    select u.numUserId, u.vc2UserName, u.numUserType from HW_User u, HW_UserProfile p, HW_UserScore s 
    where u.numUserId = p.numUserId and u.numUserId = s.numUserId and s.numExperience > 100;
    

*   **关键配置**：每日凌晨4点完全刷新，适配非实时更新的业务场景；
*   **优化效果**：逻辑读降至3446，执行时间从83秒缩短至1秒。

### 5.2 进一步优化：降序索引消除排序

物化视图仍存在排序消耗，创建降序索引：

    create index idx_desc on HW_USER4LOVE (numUserType desc, numRank desc, numUserId desc);
    

*   **核心原理**：降序索引本质为函数索引，仅CBO可识别，直接匹配ORDER BY子句；
*   **最终效果**：逻辑读降至88，排序操作完全消除，执行时间缩短至0.22秒。

六、跨场景性能问题诊断案例：Checkpoint not complete
-------------------------------------

某系统出现高I/O等待（io busy 99%）、日志切换缓慢，alert.log频繁出现“Checkpoint not complete”错误。

### 6.1 问题定位

*   **系统层面**：sar工具显示磁盘写入速度仅600K/s（正常应达1-2M/s），硬件I/O存在瓶颈；
*   **数据库层面**：v$session\_wait存在大量`log file switch (checkpoint incomplete)`等待，v$log显示日志组切换频繁；
*   **根因分析**：
    1.  存储设备Sun StorEdge T3的UPS电池损坏，导致写入模式从write back转为write through，I/O效率暴跌；
    2.  某表数据量达2000万条，定期清理程序故障导致数据膨胀，大量查询全表扫描加剧I/O压力。

### 6.2 解决方案

1.  更换UPS电池，恢复正常I/O写入模式；
2.  修复数据清理程序，归档历史数据，优化全表扫描SQL；
3.  调整日志文件大小，减少日志切换频率。

七、Oracle 性能优化核心工具使用手册
=====================

AutoTrace：SQL优化基础诊断工具
---------------------

### 1\. 工具概述

AutoTrace是Oracle SQL\*Plus内置工具，用于跟踪SQL执行计划、收集执行统计信息（如逻辑读、物理读、排序次数等），无需复杂配置即可快速定位SQL低效点，是SQL优化入门必备工具。

### 2\. 启用与配置

#### 2.1 Oracle10g 之前版本（手动启用）

1.  创建基础表与同义词

    -- 连接系统用户
    connect / as sysdba;
    -- 执行脚本创建plan_table
    @?\rdbms\admin\utlxplan;
    -- 创建公有同义词，支持多用户共享
    create public synonym plan_table for plan_table;
    -- 授权public用户访问
    grant all on plan_table to public;
    

2.  创建plustrace角色并授权

    -- 执行脚本创建角色
    @?\sqlplus\admin\plustrce;
    -- 授予角色系统视图查询权限
    grant select on v_$sesstat to plustrace;
    grant select on v_$statname to plustrace;
    grant select on v_$session to plustrace;
    -- 授予DBA角色管理权限
    grant plustrace to dba with admin option;
    

3.  开放所有用户权限

    grant plustrace to public;
    

#### 2.2 Oracle10g 及以后版本（默认启用）

*   无需手动创建plan\_table，Oracle内置PLAN\_TABLE$字典表及公有同义词；
*   直接通过SET AUTOTRACE命令启用，功能自动增强（执行计划格式化、注释说明）。

### 3\. 核心使用命令

命令

功能描述

SET AUTOTRACE OFF

关闭AutoTrace（默认状态）

SET AUTOTRACE ON EXPLAIN

仅显示SQL执行计划，不显示查询结果和统计信息

SET AUTOTRACE ON STATISTICS

仅显示执行统计信息，不显示执行计划和查询结果

SET AUTOTRACE ON

显示执行计划+统计信息+查询结果

SET AUTOTRACE TRACEONLY

显示执行计划+统计信息，不显示查询结果（避免大结果集输出）

### 4\. 实战场景：SQL优化诊断

#### 问题SQL示例

    SELECT * FROM sys_user 
    WHERE user_code = 'zhangyong' 
    OR user_code IN (SELECT grp_code FROM sys_grp WHERE sys_grp.user_code = 'zhangyong');
    

#### 诊断步骤

1.  启用AutoTrace查看执行计划和统计信息

    SET AUTOTRACE ON;
    -- 执行问题SQL
    SELECT * FROM sys_user WHERE user_code = 'zhangyong' OR user_code IN (SELECT grp_code FROM sys_grp WHERE sys_grp.user_code = 'zhangyong');
    

2.  关键指标分析：逻辑读（consistent gets）高达30590，执行计划显示全表扫描（TABLE ACCESS FULL）和FILTER操作；
3.  优化后验证：通过UNION ALL改写SQL，再次执行AutoTrace，逻辑读降至130，性能提升99.6%。

### 5\. 注意事项

*   执行权限：普通用户需拥有plustrace角色权限，否则无法启用；
*   输出干扰：查询大结果集时建议使用TRACEONLY，避免结果集刷屏；
*   版本差异：Oracle10g后执行计划输出格式化，包含Plan hash value和Predicate Information，更易解读。

* * *

SQL\_TRACE/10046事件：深度诊断工具
-------------------------

### 1\. 工具概述

SQL\_TRACE是Oracle内核级跟踪工具，10046事件是其增强版本，可捕获SQL解析过程、执行计划、绑定变量、等待事件等底层信息，适用于复杂性能问题（如隐式转换、递归SQL错误、IO等待）诊断。

### 2\. 核心配置与启用

#### 2.1 SQL\_TRACE启用方式

##### （1）全局启用（不推荐生产环境）

    -- 修改参数文件（pfile/spfile），需重启数据库
    alter system set sql_trace=true scope=spfile;
    

##### （2）会话级启用（推荐）

    -- 启用当前会话跟踪
    alter session set sql_trace=true;
    -- 执行需诊断的SQL操作
    select count(*) from dba_users;
    -- 停止跟踪
    alter session set sql_trace=false;
    

##### （3）跟踪其他用户会话

    -- 1. 查询目标会话的SID和SERIAL#
    select sid, serial#, username from v$session where username is not null;
    -- 2. 启用跟踪（需SYSDBA权限）
    exec dbms_system.set_sql_trace_in_session(9, 437, true); -- SID=9，SERIAL#=437
    -- 3. 停止跟踪
    exec dbms_system.set_sql_trace_in_session(9, 437, false);
    

#### 2.2 10046事件级别与启用

##### 事件级别（功能递增）

*   Level 1：等价于SQL\_TRACE，捕获基础执行信息；
*   Level 4：增加绑定变量（bind values）捕获；
*   Level 8：增加等待事件跟踪；
*   Level 12：Level 1+4+8（生产环境诊断首选）。

##### 启用命令

    -- 会话级启用Level 12
    alter session set events '10046 trace name context forever, level 12';
    -- 执行SQL操作
    select count(*) from t;
    -- 停止跟踪
    alter session set events '10046 trace name context off';
    

### 3\. 跟踪文件处理

#### 3.1 查找跟踪文件路径

    select d.value||'/'||lower(rtrim(i.instance, chr(0)))||'_ora_'||p.spid||'.trc' trace_file_name
    from (select p.spid from sys.v$mystat m, sys.v$session s, sys.v$process p 
          where m.statistic# = 1 and s.sid = m.sid and p.addr = s.paddr) p,
         (select t.instance from sys.v$thread t, sys.v$parameter v 
          where v.name = 'thread' and (v.value = 0 or t.thread# = to_number(v.value))) i,
         (select value from sys.v$parameter where name = 'user_dump_dest') d;
    

#### 3.2 格式化跟踪文件（tkprof工具）

    # 格式：tkprof 原始跟踪文件 输出文件 选项
    tkprof eygle_ora_28653.trc auto.log aggregate=no;
    

### 4\. 实战场景

#### 场景1：隐式转换导致索引失效

*   问题现象：新闻发布系统SQL执行缓慢，逻辑读高达3892；
*   跟踪步骤：启用10046事件跟踪，格式化文件发现SQL中字符型字段（ARTICLEID）与数字条件比较，触发隐式转换，索引失效；
*   解决：条件值添加单引号（`articleId='20030700400141'`），逻辑读降至2。

#### 场景2：递归SQL错误诊断（ORA-00604）

*   问题现象：执行`drop user`时报错“ORA-00604: error occurred at recursive SQL level 1”；
*   跟踪步骤：启用SQL\_TRACE，格式化文件发现递归SQL尝试删除SDO\_GEOM\_METADATA\_TABLE，该表不存在；
*   解决：创建该表的同义词或删除冗余Spatial组件。

### 5\. 注意事项

*   性能影响：全局启用会导致数据库性能下降，生产环境仅对目标会话启用；
*   空间占用：跟踪文件可能占用大量磁盘空间，需提前分配足够USER\_DUMP\_DEST空间；
*   权限要求：启用其他会话跟踪需SYSDBA权限，且需获取目标会话的SID和SERIAL#。

* * *

DBMS\_XPLAN：执行计划格式化工具
---------------------

### 1\. 工具概述

DBMS\_XPLAN是Oracle提供的执行计划格式化包，支持从plan\_table、共享池（V$SQL\_PLAN）、AWR中提取执行计划，输出结构化、易解读的结果，适配不同诊断场景（离线SQL分析、实时会话诊断、历史问题回溯）。

### 2\. 核心函数与使用

#### 2.1 DISPLAY：从plan\_table提取执行计划

##### 适用场景：离线分析已知SQL的执行计划

    -- 1. 生成执行计划到plan_table
    EXPLAIN PLAN set statement_id = 'emp_query' FOR
    SELECT * FROM emp WHERE empno=7788;
    -- 2. 格式化输出
    SELECT plan_table_output 
    FROM TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE', 'emp_query', 'ALL'));
    

*   参数说明：`TABLE_NAME`（默认plan\_table）、`STATEMENT_ID`（执行计划标记）、`FORMAT`（ALL显示完整信息，含谓词、投影列）。

#### 2.2 DISPLAY\_CURSOR：从共享池提取实时执行计划

##### 适用场景：诊断正在执行的SQL（如存储过程中的慢SQL）

    -- 1. 查询目标SQL的SQL_ID
    select sid, username, sql_id from v$session where sql_id is not null;
    -- 2. 格式化输出执行计划
    SELECT plan_table_output 
    FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('bgg2p17bx7y1v', 2, 'ALL')); -- SQL_ID=xxx，CHILD_NUMBER=2
    

#### 2.3 DISPLAY\_AWR：从AWR提取历史执行计划

##### 适用场景：回溯间歇性性能问题的SQL执行计划

    -- 1. 从AWR报告获取SQL_ID
    -- 2. 格式化输出历史执行计划
    select * from table(dbms_xplan.display_awr('072t81cu41xfj'));
    

### 3\. 实战场景：存储过程慢SQL诊断

*   问题现象：存储过程执行缓慢，单条SQL在SQL\*Plus中执行快速；
*   诊断步骤：
    1.  在存储过程中启用SQL\_TRACE，获取问题SQL的HASH\_VALUE；
    2.  通过`create table t as select * from v$sql_plan where hash_value=3740055767`保存执行计划；
    3.  用DBMS\_XPLAN.DISPLAY格式化输出，发现CBO选择位图转换（bitmap convert）导致性能下降；
*   解决：删除冗余索引，执行计划恢复正常。

### 4\. 注意事项

*   权限要求：使用DISPLAY\_CURSOR需授权用户访问V$SESSION、V$SQL、V$SQL\_PLAN视图；
*   版本差异：Oracle10g后DISPLAY\_CURSOR和DISPLAY\_AWR功能增强，支持更多格式化选项；
*   执行计划老化：共享池中的执行计划可能被老化，历史计划需通过AWR提取。

* * *

物化视图：批量查询与翻页优化工具
----------------

### 1\. 工具概述

物化视图通过预计算并存储聚合/关联数据，以空间换时间，减少逻辑读和排序消耗，适用于翻页查询、报表统计等批量数据访问场景，支持自动刷新和查询重写。

### 2\. 创建与配置

#### 基础创建语句

    CREATE MATERIALIZED VIEW HW_User4Love 
    BUILD IMMEDIATE -- 立即创建数据
    REFRESH COMPLETE -- 完全刷新（替代原有数据）
    START WITH SYSDATE -- 首次刷新时间
    NEXT trunc(sysdate+1) +4/24 -- 刷新周期（每日凌晨4点）
    ENABLE QUERY REWRITE -- 启用查询重写（自动匹配物化视图）
    AS 
    select u.numUserId, u.vc2UserName, u.numUserType, s.numRank, p.numGender
    from HW_User u, HW_UserProfile p, HW_UserScore s 
    where u.numUserId = p.numUserId and u.numUserId = s.numUserId and s.numExperience > 100;
    

#### 关键配置说明

*   刷新方式：`COMPLETE`（完全刷新）或`FAST`（增量刷新，需物化视图日志）；
*   刷新周期：通过`NEXT`子句指定（如`NEXT sysdate+7`表示每周刷新）；
*   查询重写：`ENABLE QUERY REWRITE`开启后，Oracle自动将匹配的SQL改写为访问物化视图。

### 3\. 实战场景：翻页查询优化

#### 问题SQL（翻页查询，逻辑读44760）

    SELECT * 
    FROM (SELECT t.*, ROWNUM i 
          FROM (SELECT u.numuserid, u.vc2username FROM hw_user4love u 
                WHERE u.numintention <> 99 
                ORDER BY u.numusertype DESC, u.numrank DESC) t 
          WHERE ROWNUM <= 40) 
    WHERE i > 20;
    

#### 优化步骤

1.  创建物化视图（预存储关联数据）；
2.  验证优化效果：执行相同翻页SQL，逻辑读降至3446，执行时间从83秒缩短至1秒；
3.  进一步优化：创建降序索引消除排序

    create index idx_desc on HW_USER4LOVE (numUserType desc, numRank desc, numUserId desc);
    

*   最终效果：逻辑读降至88，排序操作完全消除，执行时间0.22秒。

### 4\. 注意事项

*   数据一致性：刷新周期需匹配业务需求（如非实时场景可每日刷新）；
*   存储消耗：物化视图占用磁盘空间，需评估数据量和刷新频率；
*   索引支持：降序索引本质为函数索引，仅CBO优化器可识别，需确保优化器模式为CBO。

* * *

辅助诊断工具（系统命令+脚本）
---------------

### 1\. vmstat：系统CPU/内存监控

#### 功能：监控CPU使用率、运行队列、内存交换，定位系统级瓶颈

    # 格式：vmstat 采样间隔 采样次数
    vmstat 3 5;
    

#### 关键指标解读

*   `r`（运行队列）：超过CPU核心数则存在CPU瓶颈；
*   `id`（CPU空闲率）：持续低于5%表示CPU耗尽；
*   `si/so`（内存交换）：非零表示内存不足，需调整SGA大小。

### 2\. top：进程级CPU消耗定位

#### 功能：查看高CPU消耗进程，识别异常Oracle进程

    top;
    

#### 关键操作

*   过滤Oracle进程：`top -u oracle`；
*   若多个Oracle进程平均CPU消耗1%左右，需排查批量低效SQL。

### 3\. getsort.sql：排序SQL捕获脚本

#### 功能：捕获占用临时表空间的排序SQL（如ORA-1652错误）

    SELECT /*+ rule */ 
    DISTINCT a.SID, a.process, a.serial#, 
    TO_CHAR(a.logon_time, 'YYYYMMDD HH24:MI:SS') LOGON, a.osuser, 
    c.tablespace, b.sql_text 
    FROM v$session a, v$sql b, v$sort_usage c 
    WHERE a.sql_address = b.address(+) AND a.sql_address = c.sqladdr;
    

* * *

工具选择指南
------

诊断场景

推荐工具

核心优势

简单SQL优化（执行计划/逻辑读）

AutoTrace

配置简单，快速输出关键指标

复杂问题（隐式转换/等待事件）

SQL\_TRACE/10046事件

捕获底层细节，支持深度诊断

实时会话SQL诊断

DBMS\_XPLAN.DISPLAY\_CURSOR

无需干预，直接提取共享池执行计划

历史性能问题回溯

DBMS\_XPLAN.DISPLAY\_AWR

从AWR获取历史执行计划

翻页查询/报表统计

物化视图

预存储数据，大幅降低逻辑读

系统级瓶颈（CPU/IO）

vmstat+top

快速定位系统层面问题

posted on 2025-12-07 20:08  [刘子毅](https://www.cnblogs.com/liuziyi1)  阅读(44)  评论(0)    [收藏](javascript:void\(0\))  [举报](javascript:void\(0\))