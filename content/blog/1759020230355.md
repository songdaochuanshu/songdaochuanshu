---
layout: post
title: '揭秘JUC：volatile与CAS，并发编程的两大基石'
date: "2025-09-28T00:43:50Z"
---
揭秘JUC：volatile与CAS，并发编程的两大基石
----------------------------

JUC（java.util.concurrent）并发包，作为Java语言并发编程的利器，由并发编程领域的泰斗道格·利（Doug Lea）精心打造。它提供了一系列高效、线程安全的工具类、接口及原子类，极大地简化了并发编程的开发流程与管理复杂度。

**JUC并发包与happens-before、内存语义的关系**

探索JUC并发包，会发现它与Java内存模型中的happens-before原则及内存语义紧密相连。从高层视角俯瞰，volatile关键字与CAS（Compare-And-Swap）操作构成了JUC并发包底层实现的核心基石。接下来，以并发工具Lock为例，剖析其背后的实现机制。

    class LockExample {
        int x = 0;
        Lock lock = new ReentrantLock();
    
        public void set() {
            // 获取锁
            lock.lock();       
            try {
               x = 1;
            } finally {
                // 释放锁
                lock.unlock();  
            }
        }
    
        public void get() {
            // 获取锁
           lock.lock();        
            try {
               int i = x;
               // ......
            } finally {
                // 释放锁
               lock.unlock();   
            }
        }
    }
    

Lock的实现依赖于Java同步器框架（AbstractQueuedSynchronizer，AQS）。AQS内部维护了一个由volatile修饰的整型变量state，用于表示同步状态。  
‌ 1）获取锁‌：当调用Lock的lock()方法时，会触发AQS的tryAcquire()方法尝试获取锁。该方法首先检查当前state是否为0（表示锁未被占用），若是，则通过CAS操作将state设置为1，并标记当前线程为锁的持有者。若锁已被当前线程持有（即重入锁情况），则直接增加state的值。  
‌ 2）释放锁‌：当调用Lock的unlock()方法时，会触发AQS的tryRelease()方法释放锁。该方法首先减少state的值，若减少后state为0，则表示锁已完全释放，同时清除锁的持有者信息。

    // 关键volatile变量
    private volatile int state;
    
    protected final boolean tryAcquire(int acquires) {
        // 1 获取到当前线程
        final Thread current = Thread.currentThread();
        // 2 获取到当前锁的state值
        int c = getState();
        // 3 如果state值为0，则是无线程占用锁
        if (c == 0) {
            // 4 compareAndSetState则通过CAS对state进行设置为1
            if (compareAndSetState(0, acquires)) {
                // 5 设置占用线程为当前线程并返回true
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        // 6 如果state不为0，并且当前线程等于锁占用的线程，则说明锁重入了。
        else if (current == getExclusiveOwnerThread()) {
            // 7 直接将state设置为+1
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        // 8 如果是false，则说明是其他线程，直接返回false。
        return false;
    }
    
    protected final boolean tryRelease(int releases) {
       // 1 对state进行减值
       int c = getState() - releases;
       // 2 判断当前线程等于锁占用的线程
       if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
       boolean free = false;
        // 3 当c值为0，代表释放锁成功
        if (c == 0) {
            free = true;
            // 4 设置为当前锁没有线程独占
            setExclusiveOwnerThread(null);
        }
        // 5 将state重新置为0，意味其他线程可以重新抢锁
        setState(c);
        // 6 释放锁成功
        return free;
    }
    

从上述代码中，可以观察到volatile变量state在锁获取与释放过程中的关键作用。根据volatile的happens-before规则，释放锁的线程在修改volatile变量之前对共享变量的修改，对于后续获取该锁的线程来说是可见的。这确保了锁机制的正确性与线程间的数据一致性。  
为了更直观地理解Lock的获取与释放过程，我们可以将其简化为如下伪代码。

    class SimplifiedLockExample {
        int x = 0;
        volatile int state;
           
        public void set() {
            // 当前线程从主内存读取state值
            while(state != 0) {
               // 伪代码 阻塞当前线程
               park(Thread.currentThread())
            } 
            // CAS操作，确保只有一个线程能成功设置state为1
           compareAndSwap(state, 1)
           // 赋值操作，受volatile内存语义保护，防止重排序
           x = 1;
           // 释放锁，将state重置为0
           state = 0;  
           // 唤醒其他等待线程
           unpark(nonCurrentThread());
        }
            
        public void get() {
           // 当前线程从主内存读取state值
            while(state != 0) {
               // 阻塞当前线程，等待锁释放
               park(Thread.currentThread())
            }          
            // CAS操作，尝试获取锁 
            compareAndSwap(state, 1)
            // 读取共享变量x的最新值
            int i = x;
            // 其他操作...
            // 释放锁，将state重置为0
            state = 0;
            // 唤醒其他等待线程
            unpark(nonCurrentThread());   
         }
         
        // 伪代码方法，实际实现需依赖底层系统调用
        private void park(Thread thread) 
        private void unpark(Thread thread) 
        private boolean compareAndSwap(int expect, int newValue, int updateValue) 
        private Thread nonCurrentThread()
    }
    

Java的CAS会使用现代处理器上提供的原子指令，实现无锁的线程安全更新机制。同时，volatile变量的读/写可以实现线程线程之间的通信。如果仔细分析JUC并发包的源代码实现，会发现一个通用化的实现模式。  
‌ 1）声明共享变量为volatile‌：确保变量的可见性与有序性。  
‌ 2）使用CAS的原子条件更新‌：实现线程间的同步与数据的一致性更新。  
‌ 3）配合volatile的读/写内存语义‌：实现线程间的通信与数据传递。  
这一模式在AQS、非阻塞数据结构（如ConcurrentHashMap）及原子变量类（如AtomicInteger）等JUC并发包的基础类中得到了广泛应用。而这些基础类又进一步支撑了JUC并发包中高层类的实现，构建了一个层次分明、功能强大的并发编程框架。

**未完待续**

**很高兴与你相遇！如果你喜欢本文内容，记得关注哦**

本文来自博客园，作者：[poemyang](https://www.cnblogs.com/poemyang/)，转载请注明原文链接：[https://www.cnblogs.com/poemyang/p/19114881](https://www.cnblogs.com/poemyang/p/19114881)

posted on 2025-09-27 11:28  [poemyang](https://www.cnblogs.com/poemyang)  阅读(78)  评论(0)    [收藏](javascript:void\(0\))  [举报](javascript:void\(0\))