---
layout: post
title: '随机收缩算法求解全局最小割'
date: "2025-02-21T00:36:40Z"
---
随机收缩算法求解全局最小割
=============

### 全局最小割问题

全局最小割问题（Global Min-Cut Problem）是图论中的一个经典问题，旨在通过切割图中的边来划分图的顶点集合。具体来说，给定一个加权无向图 $ G = (V, E) $，其中 $ V $ 是节点集合，$ E $ 是边集合，图中每条边 $ e \\in E $ 有一个权重 $ w(e) $，全局最小割问题的目标是找到一个划分 $ (S, T) $ 使得从集合 $ S $ 到集合 $ T $ 的边的总权重最小。也就是说，我们希望将图的顶点集合 $ V $ 分割成两个子集 $ S $ 和 $ T $，使得割集 $ \\text{cut}(S) $ 的总权重最小，其中割集定义为从 $ S $ 到 $ T $ 的所有边的集合。

形式上，最小割问题的目标是求解以下优化问题：

\\\[\\min\_{S \\subseteq V} \\sum\_{u \\in S, v \\in V \\setminus S} w(u, v) \\\]

### 与最大流-最小割的关系

在许多应用中，最小割问题与最大流问题密切相关。最大流-最小割定理指出：在一个流网络中，源点到汇点的最大流量等于从源点到汇点之间的最小割的容量。这个定理为最小割问题提供了一个计算的工具：我们可以通过求解最大流来得到最小割。

然而，这个方法仅适用于网络流图，也就是需要确定一个源点和汇点，并通过最大流算法来计算流量。而全局最小割问题则更加通用，它定义在无向图上，并不依赖于特定的源汇点，而是要在图的所有可能的顶点划分中找到最优解。因此，全局最小割问题的求解方法比网络流中的最小割问题要复杂。

*   **网络流图的最小割**：在最大流问题中，最小割指的是一个特定源点 $ s $ 和汇点 $ t $ 之间的割集，其目标是将网络中所有从 $ s $ 到 $ t $ 的流切断。最大流-最小割定理提供了一个有效的途径来求解这个问题，即通过计算源点 $ s $ 到汇点 $ t $ 的最大流量，进而求得最小割的容量。
    
*   **全局最小割**：与网络流图最小割不同，全局最小割问题并不依赖于特定的源汇点，而是考虑图中所有可能的节点划分。我们希望在所有的划分中找到使得割集权重最小的划分，而这并不局限于单一的源汇节点。因此，全局最小割问题是一个更加一般化的图优化问题，通常会比网络流中的最小割问题更加复杂和困难。
    

在求解网络流图的最小割问题时，最常见的经典方法是基于最大流-最小割定理的算法。直接用最大流算法计算最小割。

全局最小割问题并不限于某一对源点和汇点之间的割，而是要求找到整个图的最优划分。因此，为了获得全局最小割，最暴力的方法是枚举源点和汇点（ \\(V^2\\) 级的组合），然后运行多次运行最大流算法，通过对多个源汇对进行计算，逐渐逼近全局最小割。实际上，由于最小割的一些性质，可以优化到只枚举 \\(V\\) 级的组合。

即使如此，这种方法在实际应用中面临着显著的效率问题。具体来说，最大流算法的时间复杂度通常较高，尤其是在图规模较大时，计算成本过高，效率低下。

随机收缩算法
------

**随机收缩算法（Random Contraction Algorithm）** 是一种求解图的最小割问题的随机算法。随机收缩算法的核心思想是通过不断地收缩图中的边，减少图的规模，最终将图分割成两个部分。这是一个通过随机求近似解的算法。

### 运行流程

朴素的随机收缩算法的基本步骤如下：

*   **初始化**：给定一个无向加权图 $ G = (V, E) $，每条边都有一个权重。
    
*   **随机选择并收缩边**：从图中随机选择一条边 $ e = (u, v) $（启发的说，权重越大的边应该设计的越容易被随机到），将这条边的两个端点 $ u $ 和 $ v $ 合并成一个新的节点 $ u' $。在合并节点时，所有连接到 $ u $ 或 $ v $ 的边都将连接到新的节点 \\(u'\\)（$ u $ 和 $ v $ 都连接的点将其权重相加），并且原来的边 $ e $ 被移除。
    
*   **重复过程**：不断进行随机收缩，直到图中只剩下两个节点。认为此时唯一边的边权就是割。
    

### 算法的正确性

可以将随机收缩算法看作是一个通过“压缩”图结构的过程。想象一下，你有一张非常大的地图，里面标记了所有城市和城市之间的道路。你希望找到一条道路，它将地图分割成两部分，并且这条道路的总长度最短。通过不断随机地缩小一些不重要的部分（例如那些与其他部分无关的道路），你逐步将地图压缩，最终剩下的部分就是你要找的最短的分割道路。由于小权重边更容易成为割边，所以他们被选择概率应该按权重降低，更容易保留到最后。

在进行每次收缩时，实际上是在保留图中的重要结构，而逐步忽略不影响最小割的部分。因此，经过多次收缩，最终剩下的两节点之间的边实际上就是最小割的边。

通过随机选择边进行收缩，每次选择的边可能不同，因此算法得到的解具有随机性。然而，在所有可能的随机路径中，最终的割通常是接近最优的。这个过程依赖于概率论的基础，保证了最终结果是正确的。通过多次运行算法，可以高概率得到真正的最优解。

### 单次求解的复杂度

每次收缩操作的时间复杂度取决于图的边数，以及所选的启发式数据结构。假设图有 $ n $ 个节点和 $ m $ 条边，进行一次收缩操作时，选择一条边的时间复杂度是 $ O(m) $，合并两个节点的时间复杂度是 $ O(1) $，更新图的结构最多在 $ O(m) $ 时间内完成。

随着收缩过程的进行，图中节点的数量逐渐减少。收缩过程会持续进行 $ n - 2 $ 次（直到剩下两个节点），因此总的时间复杂度大约为 $ O(mn) $。

### 运行轮数与高概率最优解的关系

虽然随机收缩算法在每次运行时可能得不到最优解，但它能以较高的概率找到接近最优的解。为了增加得到高质量解的概率，通常会多次运行算法。

在一次运行中，算法的每一步都是随机的，因此它可能不会找到最小割。然而，通过多次运行，算法最终会得到正确的最小割的概率会大幅增加。实际中，算法通常运行 $ O(n^2) $ 次，以便在大多数情况下找到最优解。这个次数保证了随机收缩算法能够在高概率下给出接近最优的最小割。

具体来说，数学上可以证明，若执行 $ t $ 次随机收缩，在每次收缩中最小割的存活概率至少是 $ \\frac{C\_2^t}{C\_2^n} $ 。通过选择适当的 $ t $，我们可以确保真正的最小割 $ S^\* $ 以较高的概率在最终的收缩中存活下来。

递归随机收缩算法
--------

随机收缩算法的效率仍然不高。**递归随机收缩算法（Recursive Random Contraction Algorithm）** 是对朴素随机收缩算法的一个优化，它通过递归的方式改进了最小割的求解过程，增强了算法的效率和求解结果的准确性。递归随机收缩算法的核心思想是通过递归不断减少图的规模，逐步收缩图中的边，直到得到较小的图，在其中寻找最优的最小割。

### 运行流程

递归随机收缩算法的运行流程与朴素的随机收缩算法相似，但通过递归的方式进一步优化了算法。它基于这样一个事实：在每次运行算法时，前几次收缩时图还很大，基本不容易漏掉最优解，所以我们不需要每轮运行都从完整的图开始。

*   **初始化**：给定一个无向加权图 $ G = (V, E) $，每条边都有一个权重。
    
*   **递归收缩**：
    
    *   如果图的节点数 $ n $ 小于或等于某个阈值（如 6），则通过穷举法计算最小割。
    *   否则，我们仍然进行收缩，分别运行两次但是都不进行到底，将节点数减少到 $ \\frac n{\\sqrt 2} $ 左右，我们运行两次得到两个不同的子图，并接下来递归求解两个子图，取两个子图得到的答案中更小的值。
*   **递归的停止条件**：
    
    *   当图的节点数小于等于某个阈值时，直接通过穷举搜索找到全局最小割。否则，继续进行递归收缩。
    *   递归结束后，返回最小割。

### 正确性

和朴素的随机收缩算法一样，每次收缩操作都在减少不影响最小割的部分。通过递归过程，逐步缩小图的规模，每一次收缩的操作都是在保留最小割的基础上进行的。因此，即使通过递归收缩，最终结果依然能够得到正确的最小割。当图的节点数减少到一定程度（如小于等于 6），再使用穷举法计算最小割。

可以把递归随机收缩算法理解为一个“分而治之”的过程。首先，我们将大图分成若干个小图，每个小图的规模逐步减小。然后，我们通过随机收缩将图简化，同时确保最小割在每次递归过程中都得到保留。最终，算法通过比较不同子图的最小割，选择最优的割作为最终的解。

### 复杂度

递归随机收缩算法的时间复杂度受递归层数和每层递归的操作次数的影响。在每次递归中，图的规模减小为原来的 $ \\frac{n}{\\sqrt{2}} $，因此递归层数为 $ O(\\log n) $。每次递归的复杂度为 $ O(m) $，其中 $ m $ 是图的边数。

因此，递归随机收缩算法的总体时间复杂度为：

\\\[O(m \\cdot \\log n) \\\]

相比于朴素的随机收缩算法，递归随机收缩算法通过递归的方式将问题规模逐渐缩小，避免了重复计算，提高了算法的效率。

递归随机收缩算法与朴素随机收缩算法一样，依赖于随机性。每次运行的结果可能有所不同，因此，为了提高找到最优解的概率，也通常需要多次运行递归随机收缩算法。

代码略