---
layout: post
title: '.NET Core中的配置Configuration实战'
date: "2025-04-24T00:40:07Z"
---
.NET Core中的配置Configuration实战
============================

在前面的一篇文章中，我们对.NET 中的配置Configuration进行了一个详细的介绍，并且从整个源码的解读解释了配置中的核心接口以及主要的实现类。文章链接为：[https://cshelloworld.com/home/detail/1912874623360438272](https://cshelloworld.com/home/detail/1912874623360438272)。这篇文章我们主要来介绍每种配置如何使用。

基于内存的配置程序
---------

基于内存的配置程序主要是在内存中维护了一个Key-Value键值对。

    static void MemoryConfig()
    {
        List<KeyValuePair<string, string?>>? initialData = new List<KeyValuePair<string, string?>>();
        initialData.Add(new KeyValuePair<string, string?>("name", "tom"));
    
        IConfigurationRoot configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(initialData)
            .Build();
    
        Console.WriteLine("name:" + configuration["name"]);
    }

调用如下:

    static void Main(string[] args)
    {
        MemoryConfig();
    }

基于现有的配置提供程序
-----------

这个配置提供程序用的相对较少，是微软在Microsoft.Extensions.Configuration类库中默认实现的一个配置提供程序，它可以把已经存在的配置`IConfigurationRoot`封装成一个配置提供程序。如果需要对针对现有配置快速Copy出一个新配置的话，可以使用这个配置提供程序。

    static void ChainedConfig()
    {
        List<KeyValuePair<string, string?>>? initialData = new List<KeyValuePair<string, string?>>();
        initialData.Add(new KeyValuePair<string, string?>("name", "tom"));
    
    	//初始化一个已有的配置
        IConfigurationRoot configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(initialData)
            .Build();
    
    	//基于已有的配置，重新生成一个一模一样的配置。
        IConfigurationRoot newConfiguration = new ConfigurationBuilder()
            .AddConfiguration(configuration)
            .Build();
        Console.WriteLine("name:" + configuration["name"]);
    }

基于命令行的配置提供程序
------------

基于命令行的配置程序，可以从控制台的命令行获取配置，这个配置提供程序可以快速将命令行参数分解成Key-Value键值对。而不需要我们自己手动对字符串进行处理（一般我们会按照空格拆分成数组，然后按照等号获取到键和值）

    //基于命令行的配置
    static void CommandLineConfig()
    {
        IConfigurationRoot configuration = new ConfigurationBuilder()
            .AddCommandLine(["name=tom","age=32"])
            .Build();
        Console.WriteLine("name:" + configuration["name"]);

基于环境变量的配置提供程序
-------------

.NET可以读取环境变量中的Key-Value键值对，并且可以过滤到指定的前缀来筛选。下面代码中，程序将会加载环境变量中以TEST\_开头的所有变量到配置中，我们在系统变量中，新增一个TEST\_Name的变量，一定要重启一下计算机，否则新增的环境变量不会生效。然后我们的程序就可以读取到TEST\_Name的变量值

    static void EnvironmentConfig()
    {
        IConfigurationRoot configuration = new ConfigurationBuilder()
            .AddEnvironmentVariables("Test_")
            .Build();
        Console.WriteLine("name:" + configuration["Name"]);
    }

基于Json文件的配置提供程序
---------------

基于json的配置文件是我们最常用的配置文件格式了，.NET提供了标准的json配置提供程序，我们使用一下代码从一个app.json文件中加载配置，并且app.json被修改的时候，程序中的配置也会被更新。

    //基于Json文件的配置
    static void AddJsonFileConfig()
    {
        IConfiguration configuration = new ConfigurationBuilder()
            .AddJsonFile("app.json", optional: true, reloadOnChange: true)
            .Build();
        Console.WriteLine("name:" + configuration["name"]);
    }

app.json的配置文件内容如下：

    {
    	"person":
    	{
    		"name":"caoruipeng",
    		"age":12,
    		"school":"北京大学"
    	},
    	"name":"tom11"
    }

基于XML文件的配置提供程序
--------------

基于XML的配置文件也是我们比较常用的配置文件格式了，.NET提供了标准的XML配置提供程序，我们使用一下代码从一个app.xml文件中加载配置，并且app.xml被修改的时候，程序中的配置也会被更新。

    //基于XML文件的配置
    static void AddXmlFileConfig()
    {
        IConfiguration configuration = new ConfigurationBuilder()
            .AddXmlFile("app.xml", optional: true, reloadOnChange: true)
            .Build();
        Console.WriteLine("name:" + configuration["name"]);
    }

app.xml的配置文件内容如下：

    <?xml version="1.0" encoding="utf-8" standalone="yes"?>
    <config>
    	<name>tom</name>
    	<age>21</age>
    	<school>beijing</school>
    </config>

基于Ini文件的配置提供程序
--------------

Ini配置文件平时 我们使用的比较少，不过微软还是帮我们提供了基于Ini文件的配置提供程序。

    //基于INI文件的配置
    static void AddIniFileConfig()
    {
        IConfiguration configuration = new ConfigurationBuilder()
            .AddIniFile("app.ini", optional: true, reloadOnChange: true)
            .Build();
        Console.WriteLine("name:" + configuration["person:name"]);
    }

app.ini文件的内容如下：

    [person]
    name=tom
    age=27

自定义配置提供程序
---------

官方提供的配置提供程序基本上可以满足我们的绝大部分需求，但是如果我们的配置存储在注册表中、存储在数据库中，这个时候官方的配置提供程序就无法满足我们的要求，我们就需要自定义配置提供程序。自定义配置提供程序很简单，主要包括两个类：自定义配置源`IConfigurationSource`、自定义配置提供程序`ConfigurationProvider`以及一个针对当前配置的扩展方法。下面代码，我们模拟一个基于数据库的配置提供程序，负责从数据库的配置表Config表中读取配置。当然案例代码，我们并不是真正的去读取数据库的表，大家可以自行完善代码。

    //自定义配置源
    public class DataBaseConfigurationSource : IConfigurationSource
    {
        public IConfigurationProvider Build(IConfigurationBuilder builder)
        {
            return new DataBaseConfigurationProvider();
        }
    }
    
    
    //自定义配置提供程序
    public class DataBaseConfigurationProvider : ConfigurationProvider
    {
        public override void Load()
        {
            base.Load();
            //读取数据库配置
        }
    }
    
    //数据库配置程序的扩展方法
    public static class DataBaseConfigurationExtensions
    {
        public static IConfigurationBuilder AddDb(this IConfigurationBuilder configurationBuilder)
        {
            configurationBuilder.Sources.Add(new DataBaseConfigurationSource());
            return configurationBuilder;
        }
    }
    
    //调用案例
    static void Main(string[] args)
    {
        var builder = new ConfigurationBuilder()
        .AddDb()
        .Build();
        var value = builder["key"];
    }