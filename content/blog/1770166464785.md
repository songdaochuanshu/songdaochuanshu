---
layout: post
title: 'LLVM Pass快速入门(三)：指令替换'
date: "2026-02-04T00:54:24Z"
---
LLVM Pass快速入门(三)：指令替换
=====================

指令替换
====

项目需求：将加法指令替换为减法

项目目录如下
======

    /MyProject
    ├── CMakeLists.txt # CMake 配置文件
    ├── build/ #构建目录
    │   └── test.c #测试编译代码
    └── mypass2.cpp # pass 项目代码
    

### 一，测试代码示例

**test.c**

    // test.c
    #include <stdio.h>
    
    int my_add(int a, int b) {
        return a + b; 
    }
    
    int main() {
        int x = 10;
        int y = 20;
        printf("Result: %d\n", my_add(x, y));
        return 0;
    }
    

### 二，编写Pass

其他的固定的模板之前文章注释有，这里我只注释当前项目重要的部分  
**代码流程：** 遍历指令并匹配`ADD`指令->替换为`sub`指令

    #include "llvm/IR/PassManager.h"
    #include "llvm/Passes/PassBuilder.h"
    #include "llvm/Passes/PassPlugin.h"
    #include "llvm/Support/raw_ostream.h"
    #include "llvm/IR/Function.h"
    #include "llvm/IR/BasicBlock.h"
    #include "llvm/IR/Instruction.h"
    #include "llvm/IR/Instructions.h"
    #include "llvm/IR/IRBuilder.h" // <--- 【新增】必须包含这个头文件！
    
    using namespace llvm;
    
    namespace {
    	struct mypass3 : public PassInfoMixin<mypass3> {
    	    PreservedAnalyses run(Function &F, FunctionAnalysisManager &) {
    	        errs() << "Analyzing Function: " << F.getName() << "\n";
    	        
    	        bool changed = false; 
    			
    			//这里的2个循环获取的是遍历函数的指令(函数->代码块->指令)
    	        for (BasicBlock &BB : F) {
    	            for (Instruction &Inst : BB) {
    		            ]//判断当前的指令是ADD指令(加法)
    	                if (Inst.getOpcode() == Instruction::Add) {
    						
    	                    errs() << "Found ADD, changing to SUB...\n" << Inst << "\n";
    						//创建IR构建器
    						//在修改IR时需要用到构建器
    	                    IRBuilder<> builder(&Inst);
    	                    
    	                    //这里时获取ADD的操作数：
    	                    //%add = add nsw i32 %0, %1中的%0和%1
    	                    Value *lhs = Inst.getOperand(0); // 左操作数
    	                    Value *rhs = Inst.getOperand(1); // 右操作数
    	                    //这里是构建新的指令：sub
    	                    //其中参数是：
    	                    //1：左操作数
    	                    //2：操作数
    	                    //3：返回的变量名，相当于：%add = add nsw i32 %0, %1中的%add
    	                    Value *newSub = builder.CreateSub(lhs, rhs, "new_sub");
    	                    
    	                    //替换指令
    	                    Inst.replaceAllUsesWith(newSub);
    	                    errs() << "Replaced with SUB: \n" << *lhs << "\n" << *rhs << "\n" << *newSub << "\n";
    	                    changed = true;
    	                    
    	                }
    	            }
    	        }
    			
    	        if (changed) {
    	            return PreservedAnalyses::none();
    	        }
    	
    	        return PreservedAnalyses::all();
    	    }
    	};
    
    } 
    
    extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo
    llvmGetPassPluginInfo() {
        return {
            LLVM_PLUGIN_API_VERSION,
            "mypass3",
            "v0.1",
            [](PassBuilder &PB) {
                PB.registerPipelineParsingCallback(
                    [](StringRef Name, FunctionPassManager &FPM,
                       ArrayRef<PassBuilder::PipelineElement>) {
                        if (Name == "mypass3") {
                            FPM.addPass(mypass3());
                            return true;
                        }
                        return false;
                    });
            }};
    }
    

### 三，Pass的构建

**下面引用的是之前文章的内容**  
构建LLVM Pass需要写`CMakeLists.txt`构建声明

##### 1\. 配置CMake配置文件

**CMakeLists.txt**  
下面的`cmake`配置可以直接拿去用，我已经标注好需要修改的位置

    #cmake 版本，可通过 cmake --version 判断
    cmake_minimum_required(VERSION 4.1.1) #---->修改 cmake版本号
    #项目名字
    project(mypass2) #---->修改 项目名称
    
    #导入项目的 LLVM cmake 配置文件路径(如果根据我之前文章安装这里就相同)
    set(LLVM_DIR "D:/LLVM/llvm-project/build/lib/cmake/llvm")#---->修改 llvm cmake配置路径
    #寻找 LLVM 的包文件
    #REQUIRED 找不到 LLVM 则停止构建
    #强制使用 LLVM 安装时生成的配置文件进行定位
    find_package(LLVM REQUIRED CONFIG)
    #将 LLVM 的 CMake 模块路径添加到当前 CMake 搜索路径中，以便后续使用 include(AddLLVM)。
    list(APPEND CMAKE_MODULE_PATH "${LLVM_CMAKE_DIR}")
    
    #引入 LLVM 提供的专用 CMake 宏
    include(AddLLVM)
    #将 LLVM 的头文件目录（如 llvm/IR/Function.h）加入编译器的搜索路径
    include_directories(${LLVM_INCLUDE_DIRS})
    #导入 LLVM 编译时使用的宏定义
    add_definitions(${LLVM_DEFINITIONS})
    #设置 C++ 标准为 C++17。(这里如果不用17编译会报错)
    set(CMAKE_CXX_STANDARD 17)
    #强制要求必须支持 C++17，如果编译器不支持则失败。
    set(CMAKE_CXX_STANDARD_REQUIRED ON)
    
    #创建一个模块化的库(.dll)
    add_library(mypass2 MODULE mypass1.cpp) #---->修改 项目名称，文件名
    #windows不用会报错：导出符号
    #LLVM Pass 需要暴露一些特定的入口点（如 getAnalysisUsage）给 opt 工具调用。
    set_target_properties(mypass2 PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS ON) #---->修改 项目名称
    # 指定该 Pass 需要链接的 LLVM 核心组件。 
    # LLVMCore: 提供 IR、Function、Module 等核心类。 
    # LLVMSupport: 提供各种辅助工具类（如 errs() 输出）。
    target_link_libraries(mypass2 LLVMCore LLVMSupport) #---->修改 项目名称，文件名  
    # 为该目标设置特定的编译器选项。 
    # /utf-8: 告诉 MSVC 编译器使用 UTF-8 编码处理源代码，防止中文注释引起的乱码或编译错误。  
    target_compile_options(mypass2 PRIVATE /utf-8)#---->修改 项目名称，文件名
    

##### 2.编译并构建Pass

**打开visual studio`的工作台，我这里是`x64 Native Tools Command Prompt for VS 2022\`**

进到`build`目录

    #构建项目
    #其中-DCMAKE_BUILD_TYPE=RelWithDebInfo不选会报错，由于我之前编译的是带符号的relase版本
    cmake -G "Ninja"  -DCMAKE_BUILD_TYPE=RelWithDebInfo ..
    #编译
    ninja
    

最后出现下面提示，即为编译成功

    [2/2] Linking CXX shared module mypass2.dll
    

### 四，使用当前的pass

进到`build`目录

    #把.c文件编译为.ll
    #-O1 使用O1优化（这里我尝试-O0不优化，会导致我的pass无法应用）
    #-Xclang -disable-llvm-passes 不使用默认的pass优化
    clang -S -emit-llvm -O1 -Xclang -disable-llvm-passes test.c -S -o test.ll
    
    #使用pass
    opt -load-pass-plugin=mypass2.dll -passes=mypass2  test.ll -S -o test_opt.ll
    
    #编译使用pass后的exe
    clang test_opt.ll -o test_opt.exe
    #编译使用pass前的exe
    clang test.ll -o test.exe
    

**输出结果**  
`运行test.exe`：**不使用**pass，输出结果如下：

    Result: 30
    

`运行test_opt.exe`：**使用**pass后，输出结果如下：

    Result: -10
    

**我们成功让我们的代码 加法 变 减法**

**如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~**

本文来自博客园，作者：[ClownLMe](https://www.cnblogs.com/ClownLMe/)，转载请注明原文链接：[https://www.cnblogs.com/ClownLMe/p/19570905](https://www.cnblogs.com/ClownLMe/p/19570905)