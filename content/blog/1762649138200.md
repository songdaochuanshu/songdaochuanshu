---
layout: post
title: '记一次 float64 排序失效的灵异事件'
date: "2025-11-09T00:45:38Z"
---
记一次 float64 排序失效的灵异事件
=====================

某一天的下午，我手头没什么事情，双眼迷离，正左手托着下巴空洞地盯着屏幕发呆。恍惚间，BUG反馈群冷不丁冒了消息，我定下神来看，测试同学反馈了一个排行榜的排序问题，排行榜中相同分数的玩家，后达到分数的反而排在先到达的玩家前面。

这实在匪夷所思，要知道这个排行榜模块已经是老古董代码了，之前测试和线上都很正常，怎么突然之间就出了问题。很可惜我并不负责这一块，没能以第一视角去解决这个精彩的问题，只是在同事敲定问题根源之后，我了解过后才晓得了事情的全貌。

大致情报
----

首先看下整体的背景，这个业务并没有自建排行榜使用业务程序代码维护玩家的排行，而是借用了 Redis 的 SortedSet 实现，这是个跳表的结构，查询和修改数据性能都很不错，也是我们的老朋友了，后面就简称 ZSet 吧。

而此时的我也知道 ZSet 是不稳定的排序，也就是说相同 Value 的 Key 并不是先来后到的规则，所以排序因素除了得分之外还要加上时间戳，也就是双重排序规则。但是 ZSet 数据结构的排序字段 Value 只是一个 float64，不支持更多参数。因此在业务侧需要将分数和时间两个参数拼接成一个 float64 再 Add 到 ZSet 中去，这也是大家常用的方式，项目中相关的处理函数如下：

    func (s *Rank) Encode(score int64) float64 {
    	now := time.Now().Unix()
    	tmp := float64(100000000) / float64(now)
    	return float64(score) + tmp
    }
    

透过代码可以看到此处使用得分作为 float64 的整数部分，用 100000000 除以当前时间戳作为小数部分，合并起来的 float64 的数字大小符合双重排序规则，也就是得分更高的数字更大，而相同分数下时间戳越小，小数越大，数字越大，就排在更前面。

看上去逻辑毫无漏洞，老油条可能已经发现了问题所在，不过我先不揭晓，此处埋个伏笔。解铃还须系铃人，我们来还原一下现场，过程很精彩，大家不要眨眼哦。

抽丝剥茧
----

测试同学的操作是让 player1，player2，player3 按照先后顺序达成同一个分数，然而排行榜中最后到达相同分数的 player3 反而排到了第一的位置。player4 的加入是为了对照，缩小BUG的排查范围仅限于分数相同的情况下。

Player

Score

player3

86,548,213

player2

86,548,213

player1

86,548,213

player4

86,118,363

接下来将分数 Score 和时间戳 Time 带入上面的函数得到返回值 Result

Score

Time

Result

86548213

1767657600

86548213.05657204

86548213

1767657601

86548213.05657204

86548213

1767657610

86548213.05657204

很怪异，得出的结果竟然一样！但是聪明的你一定马上反应过来了，这几个值的小数部分戛然而止必有蹊跷，那么真相只有一个，除法处理过后的时间戳小数被截断了！

问题是为什么？我使用计算器计算，选择保留15位小数，会发现结果其实并不相同，小数部分远不止 8 位。

Time

Result

1767657600

0.056572042006325

1767657601

0.056572041974321

经过一番思索，发现是因为一直忽略了 float64 本身的精确度也是有限的，在 float64 的结构中只有 52 位是有效数值精度，换算成 10 进制可以展示 `15 ~ 17` 个数字，在当前这个例子中因为整数已经是 `10^8` 级的数字，可留给表示小数的位就只剩下了 8 位左右，因此超过的小数部分就被截断了。真没想到，在我印象中包容天地万物的 float64 也有绠短汲深的一天。

趁热打铁，我赶忙查了下 float64 的构成和原理，float64 顾名思义是由 64 个 bit 位构成的结构，其中：

*   1 位是符号位，用来表示数值的正负
*   11 位是指数位，用来表示数值的规模
*   52 位是有效数字，用来表示数值的的精度

可以这样粗略地理解，52 位有效数字是连续的紧挨着的 `52 个 0 和 1`，而指数位的数字就是在 `52 个 0 和 1` 后面加多少个 0 或者说小数点往后移动几位。由此一来 float64 可以表示非常非常大的数字，可以达到接近 `2^2^10` 数量级，当然具体可以表示多大的数字还要看 IEEE 754 是怎么规定的了。数量级大的代价是低位的精度就不够了，比如 float64 就无法表示 `2^53 + 1`，`2^53` 数量级的数字个位和所有小数位只能都是 0。

相近时间戳计算出的小数前 8 位相同，而精度不够导致小数位只留下了 8 位，第一时间确实很难想到这块。要是 ZSet 本身就支持按插入时间排序该多好，想到这里我又去看了下 [ZSet的排序规则](https://redis.io/docs/latest/commands/ZADD/#elements-with-the-same-score)，文档中明确说明了相同 Value 下按照 Key 的 [字典序](https://en.wikipedia.org/wiki/Lexicographic_order) 排序。看完背后冷汗直冒，我想起了半年前很多家面试都被问到了这个问题，当时都是说跳表不能保证顺序，相同分数插入进去可前可后，现在就是感觉非常遗憾。

空口无凭，马上来实践测试一下，并增加 player100 和 player4 作为对照。

    ZADD test_key 86548213.05657204 player1
    ZADD test_key 86548213.05657204 player2
    ZADD test_key 86548213.05657204 player100
    ZADD test_key 1 player4
    

    ZRANGE test_key 0 -1 WITHSCORES REV
    

    player2
    8.654821305657203e+7
    player100
    8.654821305657203e+7
    player1
    8.654821305657203e+7
    player4
    1
    

如此看来，player1 按照字典序会排在 palyer2 前面，REV 倒序查询就落在了 player2 身后，这个结果能很好地解释测试同学的情况究竟为何。

不过相同分数这种情况出现的概率很小，暂时不用亡羊补牢，后面版本节点中我们使用自建排行榜的方案进行优化，这个问题就此告一段落。

痛定思痛
----

其实直接原因是测试同学把分数搞得太大了，即便没有时间戳的问题，也可能有分数显示不正确的问题，因为分数本身持久化的数据结构是 int64，可以保存的最大整数有 2^63，精度也是 63 位，而在 redis 中数据结构是 float64，最大精度只有 53 位，超过了就有排序问题，而且排行榜中解析出来的分数和玩家的分数本身又会显示不一致。

所以在项目开发中，一定要和策划同学确认排行榜中分数数值范围是多少，如果超过某个阈值就需要更换实现方案了。

如果是限时的排行榜比如活动结束后就会清空，是可以用当前时间戳减去活动开启时间作为小数部分的，可以一定程度上缓解症状，但是总归治标不治本，游戏的排行榜基本都是强业务相关的，如果有余力还是建议开发一个多排序字段的排行榜系统。