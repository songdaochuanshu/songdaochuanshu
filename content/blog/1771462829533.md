---
layout: post
title: 'Linux下GNU Autotools工具基础教程'
date: "2026-02-19T01:00:29Z"
---
Linux下GNU Autotools工具基础教程
=========================

本博客介绍了Linux下GNU Autotools工具的基础用法，涵盖了autoconf、automake等工具的功能及作用。通过实例演示，讲解了如何使用autoconf生成配置脚本，以及如何通过automake和Makefile.am定制构建过程。

对于我们平时写的小的测试Demo程序，可能自己手动编写一个`Makefile`文件就可以编译整个项目了，但是对于一些大型的工程，包含多个源码文件夹、头文件文件夹、库文件文件夹，如果我们每个源码文件的`Makefile`文件都自己去编写会非常繁琐，所以这时候需要一些自动化工具来帮助我们简化项目的构建，这里比较主流的有两种工具一个是GNU下的Autotools工具，一个是CMake工具。

Autotools工具是一些版本比较老的工具了，遗留了很多问题，包括他的语法复杂(m4宏语言)，涉及的工具种类太多，生成的`configure`脚本非常庞大等问题，在2000年后出现的新一代构建系统包括CMake、Meson、Ninja等能够有效解决Autotools的历史疑难杂症，并且语法更加现代化、生成速度更快。那我们为什么还要学习了解Autotools呢？因为历史原因，早年很多的开源软件都是使用的Autotools来构建的，并且Autotools目前在GNU体系中还是大量使用，并且在嵌入式Linux中非常常见，而且在一些老牌的C项目中也非常常见，所以还是非常有必要了解Autotools。

这里给出官方的Autotools的文档连接 [https://www.gnu.org/software/autoconf/](https://www.gnu.org/software/autoconf/)

一、Autotools工具详细介绍
=================

1.1 Autotools工具组成
-----------------

GNU Autotools并不是一个工具，而是由一系列的工具合集组成，在现如今的Linux发行版中，大概率是自带这些工具的，如果没有可以自行下载

*   `autoscan`：这个工具主要是用来扫描查找源代码目录下的源文件用来生成`configure.scan`文件。`configure.scan`文件是自动生成的模板，里面包含了一些系统配置的基本选项都是一些宏定义，这些宏通过`autoconf`工具处理后会变成检查系统特性、环境变量的shell脚本，我们可以根据这个模板修改，最后将`configure.scan`重新命名为`configure.ac`文件
*   `aclocal`：这个工具是一个`perl`脚本程序，他主要用来根据上一步的`configure.ac`文件的内容，自动生成`aclocal.m4`文件
*   `autoconf`：这个工具会使用`configure.ac`文件来生成名称为`configure`的shell脚本文件用来检查系统特性与环境变量，运行这个脚本文件之后，就会生成`Makefile`文件，之后我们就可以执行`make`和`make install`命令了
*   `autoheader`：这个工具主要是用来自动生成`config.h.in`文件的，当我们执行了`./configure`之后，会生成一个`config.h`文件，在调用`autoheader`工具之后，就会生成`config.h.in`文件
*   `automake`：使用`automake`来产生`Makefile.in`文件，需要注意的是`Makefile.in`是由`Makefile.am`生成的这个需要我们手动来编写

这里可以注意到，最后工具用到的文件都是以`.in`结尾的文件，这些文件相当于我们最后需要的目标文件的输入文件

1.2 `configure`脚本制作流程
---------------------

这块内容可以参考 [https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.72/autoconf.html](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.72/autoconf.html) 文档的第三章内容，详细阐述了`configure`脚本的制作流程，下面简单介绍一下，以下图流程图中，带`*`的是执行的命令，带`[]`的表示可选项

![Pasted image 20260216122316.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209097-1180976358.png)  
首先根据文档中的这个流程图，可以看见用我们的源文件，通过`autoscan`命令生成`configure.scan`文件，然后我们再修改这个模板，生成我们的`configure.ac`文件，在通过`autoconf`命令生成`configure`脚本的时候，`aclocal.m4`和`acsite.m4`这两个文件为可选项，如果我们后续需要使用`automake`工具，那么还需要在执行`autoconf`前使用`aclocal`工具生成`aclocal.m4`文件

在执行`autoconf`命令的同时，我们可以选择使用`autoheader`来生成`config.h.in`文件。这个文件的作用是为 configure 提供一个模板，告诉它哪些宏需要根据系统环境进行检测，从而生成最终的`config.h`文件，供代码在条件编译中使用，后需会详细讲解这部分内容。

如果我们还需要使用`automake`工具来生成`Makefile.in`文件，那么需要在`autoscan`生成了`configure.ac`文件之后追加以下的流程  
![Pasted image 20260216132616.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209304-1030423812.png)  
第一步，我们需要使用`aclocal`命令来生成`aclocal.m4`文件，有了这个文件之后，我们在生成`configure`的时候会使用到这个文件，然后第二步我们需要自己编写一个`Makefile.am`文件，然后执行`automake`命令来生成`Makefile.in`

做完上述两个流程之后，我们就可以得到两个关键文件了一个是`configure`脚本文件，一个是`Makefile.in`模板文件，在通过以下流程，生成最后的`Makefile`文件  
![Pasted image 20260216133225.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209082-1911362763.png)  
直接执行`configure`脚本文件，脚本会去找`config.h.in`和`Makefile.in`文件进行文件生成，最后生成`config.h`和`Makefile`文件，之后我们就可以执行`make`命令来编译工程了

可能这里三个图的关系比较混乱，后面会通过一个工程上的实例，来具体演示`Autotools`的使用以及流程

1.3 `autoheader`工具与`config.h.in`文件
----------------------------------

前面我们提到了使用`autoconf`生成`configure`的同时，可以使用`autoheader`来生成`config.h.in`文件，这个文件到底是用来干什么的呢？这一小节详细讲解一下。

例如，现在有一个场景：我们的应用代码需要跨平台，在 Linux 环境下，会使用到 `<unistd.h>` 头文件。不同系统可能是否存在这个头文件不同，因此我们希望通过自动化的方式进行检测和适配。我们需要先在`configure.ac`文件中添加配置项

    AC_INIT([example], [1.0])
    AC_CONFIG_HEADERS([config.h])
    AC_CHECK_HEADERS([unistd.h])
    AC_OUTPUT
    

*   `AC_CONFIG_HEADERS([config.h])`：告诉 Autotools 最终需要生成 `config.h` 文件
*   `AC_CHECK_HEADERS([unistd.h])`：告知 Autotools 需要检测系统是否有 `<unistd.h>`，并生成相应宏 `HAVE_UNISTD_H`

当我们在`configure.ac`中添加了这些选项之后，可以运行`autoheader`命令来生成`config.h.in`，这时的模板文件中会有以下这样的记录

    /* Define to 1 if you have the <unistd.h> header file. */
    #undef HAVE_UNISTD_H
    

*   注意：`#undef HAVE_UNISTD_H` 只是占位宏，值还没有确定
*   这个宏的名字是由 AC\_CHECK\_HEADERS 自动生成的

有了`config.h.in`文件之后，如果我们运行了`./configure`后，工具会检测系统中是否有`<unistd.h>`根据最终结果来生成`config.h`头文件，如果包含有那么在`config.h`文件中，就会多出

    #define HAVE_UNISTD_H 1
    
    //如果没有该头文件的话
    /* #undef HAVE_UNISTD_H */
    

后续我们就可以通过包含`config.h`文件来进行条件编译了，这样代码可以在不同平台上自动适配，而不需要手动修改

    #include "config.h"
    
    #ifdef HAVE_UNISTD_H
    #include <unistd.h>
    #endif
    
    int main() {
    #ifdef HAVE_UNISTD_H
        write(1, "unistd.h exists\n", 16);
    #else
        printf("unistd.h not found\n");
    #endif
        return 0;
    }
    

总结：

*   `config.h.in` = **模板文件**，列出待检测的宏
*   `./configure` = **系统检测器**，把模板宏填上实际值
*   `config.h` = **最终宏定义文件**，代码条件编译使用
*   条件编译语句 (`#ifdef`) 永远需要开发者在代码里自己写

二、Autotools实例分析
===============

这一章节主要是对autotools的具体使用举例。

**第一步**：创建demo工程项目，新建了一个源码文件夹，创建一个c文件，编写了一个简单的代码。  
![Pasted image 20260216140420.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209096-1334942740.png)

**第二步**：生成`configure.ac`文件。在源码路径下执行了`autoscan`命令之后，可以看见`configure.scan`文件已经生成出来了  
![Pasted image 20260216141414.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209334-698108259.png)  
可以打开这个文件查看，就是一些功能宏定义  
![Pasted image 20260216141527.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209314-113774963.png)  
宏解释：

*   `AC_PREREQ()`宏声明本文件要求的autoconf版本，本例使用的版本为2.71
*   `AC_INIT()`中分别的是: 软件包的名字，版本，作者的联系方式(一般是Email)
*   `AC_CONFIG_SRCDIR`宏用来侦测所指定的源码文件是否存在，来确定源码目录的有效性。此处为当前目录下的test.c，如果有多个源文件的话选择一个主要的文件，通常是 `main.c` 或其他代表源代码位置的文件。
*   `AC_CONFIG_HEADER`宏用于生成config.h文件，以便autoheader使用
*   `AC_PROG_CC`用来指定编译器，如果不指定，选用默认gcc。 比如: AC\_PROG\_CC(gcc)
*   `AC_OUTPUT`用来设定 configure 所要产生的文件，如果是makefile，configure会把它检查出来的结果带入makefile.in文件产生合适的makefile。使用Automake时，还需要一些其他的参数，这些额外的宏用aclocal工具产生

这些宏可以直接到 [https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.72/autoconf.html#Making-configure-Scripts](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.72/autoconf.html#Making-configure-Scripts) 官方文档中去查询

最后修改这个模板文件，填入自己的软件信息，并将`configure.scan`重命名为`configure.ac`文件  
![Pasted image 20260216160011.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209315-856118383.png)  
这里有几点需要注意，第一就是注意填写好自己软件的信息，第二就是如果我们后续要使用`automake`工具的话，需要添加一行`AM_INIT_AUTOMAKE`，并且需要指定构建行为常用的选项为`[foreign]`如果不指定的话，就是`[gnu]`严格模式，会检查AUTHORS、NEWS、README、ChangeLog、COPYING、INSTALL等文件，如果缺失的话，后续使用`automake`就会报错，这是我踩的一个坑，对于现代的项目，大多数使用`git`代码管理，对于这些文件有一些是不必要的，所以这里可以关闭GNU strict模式，如果你需要使用GNU的严格模式的话，创建这些所需文件就可以解决报错。第三点就是记得添加输出文件列表的宏`AC_CONFIG_FILES([文件名])`这三点编辑好之后，一个基础的`configure.ac`就编辑好了

**第三步**：生成`aclocal.m4`文件，因为我们后续要使用到`automake`工具，需要依赖`aclocal.m4`文件，所以这一步通过`aclocal`来生成`aclocal.m4`文件  
![Pasted image 20260216144207.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209281-1527369101.png)

可以看见执行了`aclocal`之后，`aclocal.m4`文件成功输出了

**第四步**：生成`config.h.in`文件，因为我们在`configure`中使用了宏检查，需要输出`config.h`，所以我们需要先生成`config.h.in`  
![Pasted image 20260216144505.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209256-1503264093.png)  
执行`autoheader`命令之后，`config.h.in`也成功生成了

**第五步**：生成`configure`文件，使用`autoconf`命令得到`configure`脚本文件  
![Pasted image 20260216145556.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209281-1821923245.png)  
如果这时候我们直接运行这个脚本，可以发现，缺少`install-sh`脚本，这个脚本就是通过`automake`来生成的  
![Pasted image 20260216145731.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209052-662252426.png)

**第六步**：编写`Makefile.am`文件，执行`automake`命令。这里只写了一个比较简单的`Makefile.am`进行测试  
![Pasted image 20260216161303.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209025-2002039184.png)  
`Makefile.am`文件编写规范非常重要，这里指出我踩到的另外一个坑，`Makefile.am`文件中的这两个宏定义，必须得规范否则也会爆出错误或者警告。

`bin_PROGRAMS`的含义是生成一个可执行文件 test，并在 `make install` 时安装到`$(bindir)`，一般情况下`$(bindir) = /usr/local/bin`  
`test_SOURCES`的结构为`<目标名>_SOURCES`目标名必须和`bin_PROGRAMS`的程序名完全一致，否则 Automake 会报错

除了`bin_PROGRAMS`还有其他Automake内部已经定义好的安装目录变量

变量

安装目录

bin\_PROGRAMS

$(bindir) → /usr/local/bin

sbin\_PROGRAMS

$(sbindir)

libexec\_PROGRAMS

$(libexecdir)

noinst\_PROGRAMS

不安装，只编译

check\_PROGRAMS

测试程序

具体其他宏的功能，大家可以查看官方的文档，这篇文章主要是autotools工具的使用，这里就不深入剖析底层了

还有一个需要注意的点是，如果我们这时候直接使用`automake`命令，会提示报错，工具也对我们继续了提示需要加上`--add-missing`选项，添加选项--add-missing 可以让automake工具自动添加必要的脚本文件，这里也可以看见如果`AM_INIT_AUTOMAKE`没有关闭GNU的严格模式，会报出缺失必要文件的错误。这里是因为这张图是没有修改的时候截取的，修改之后我没有重新`automake`  
![Pasted image 20260216150528.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209349-1310847039.png)  
加上该选项，并修改了`AM_INIT_AUTOMAKE`之后，再次执行`automake`命令执行成功，并成功生成`Makefile.in`文件和`install-sh`文件  
![Pasted image 20260216151252.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209051-539778253.png)

**第七步**：执行`configure`脚本，更具`Makfile.in`、`config.h.in`生成最后的文件。  
![Pasted image 20260216163034.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209360-2035713464.png)  
可以看见成功生成了`config.status`以及`Makefile`文件，打开该`Makefile`文件，可以看见生成了700多行  
![Pasted image 20260216164053.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209182-33307432.png)  
我们非常简单的一个代码，`autotools`工具给我们生成了700多行的`Makefile`文件，其中大量的代码都是用来检测环境和编译器相关的内容。有了`Makefile`之后，我们就可以直接使用`make`命令来编译了  
![Pasted image 20260216164308.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209147-1035686151.png)  
并且生成了对应的可执行文件，同时我们可以执行`make install`进行系统安装，默认安装到`/user/local/bin`下，需要注意的是使用`make install`时需要权限。  
![Pasted image 20260216164615.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209129-81980537.png)

我们可以使用`make dist`用来生成一个源码压缩包，拿到这个包之后，我们就可以将工程发布给别人或者发布成release版本了  
![Pasted image 20260216164748.png](https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260217172209359-157961370.png)  
至此整个`Autotools`最基本的流程与用法就结束了，当然在实际开发当中，我们不可能只有一个源文件，之后的博客会对实际工程项目情况举例与分析。