---
layout: post
title: 'C#  Winform 实现静态变量属性的值变了，触发事件，类似WPF的双向绑定'
date: "2025-02-08T00:34:40Z"
---
C# Winform 实现静态变量属性的值变了，触发事件，类似WPF的双向绑定
=======================================

在C# WinForms中，虽然没有像WPF那样内置的双向绑定机制，但你可以通过事件和属性封装来实现类似的功能。具体来说，你可以在静态属性的`set`访问器中触发一个自定义事件，然后在需要的地方订阅这个事件，以便在属性值发生变化时执行相应的操作。

**全局状态的隐患**

*   问题：静态类和静态事件引入了全局状态，这意味着任何代码都可以订阅或触发这个事件。这种全局状态可能导致代码难以维护和调试，尤其是在大型项目中。
*   风险：如果多个模块或类订阅了该事件，事件的触发可能会导致意外的副作用，甚至引发难以追踪的 bug。

**内存泄漏风险**

*   静态事件的生命周期与应用程序域相同，除非显式取消订阅，否则订阅者（尤其是对象实例）永远不会被垃圾回收。
*   如果订阅者没有正确取消订阅，可能会导致内存泄漏。

Form 窗体释放后，记得取消订阅

    public void MyForm_Closing(object sender, FormClosingEventArgs e)
    {
       //显式取消订阅
       GlobalEvents.SomeGlobalEvent -= HandleEvent;
    }
    //或者
    public void Dispose()
    {
       //显式取消订阅
       GlobalEvents.SomeGlobalEvent -= HandleEvent;
    }
    

以下是一个简单的示例，展示了如何实现这一功能：

    using System;
    using System.Windows.Forms;
    
    public static class MyStaticClass
    {
        // 定义事件
        public static event EventHandler<EventArgs> MyPropertyChanged;
    
        private static string _myProperty;
        public static string MyProperty
        {
            get { return _myProperty; }
            set
            {
                if (_myProperty != value)
                {
                    _myProperty = value;
                    // 触发事件
                    OnMyPropertyChanged();
                }
            }
        }
    
        // 触发事件的方法
        private static void OnMyPropertyChanged()
        {
            MyPropertyChanged?.Invoke(null, EventArgs.Empty);
        }
    }
    
    public class MyForm : Form
    {
        private Label myLabel;
    
        public MyForm()
        {
            myLabel = new Label();
            myLabel.Text = "Initial Value";
            myLabel.Location = new System.Drawing.Point(10, 10);
            this.Controls.Add(myLabel);
    
            // 订阅事件
            MyStaticClass.MyPropertyChanged += MyStaticClass_MyPropertyChanged;
        }
    
        // 事件处理程序
        private void MyStaticClass_MyPropertyChanged(object sender, EventArgs e)
        {
            // 当属性值变化时，更新Label的文本
            myLabel.Text = MyStaticClass.MyProperty;
        }
    
        [STAThread]
        public static void Main()
        {
            Application.EnableVisualStyles();
            Application.Run(new MyForm());
        }
    }
    

使用示例：  
你可以在其他地方修改 MyStaticClass.MyProperty 的值，例如：

    MyStaticClass.MyProperty = "New Value";
    

注意事项：

*   由于 MyProperty 是静态的，它的值在整个应用程序生命周期内是共享的。
*   如果你需要在多个窗体或控件之间共享状态，这种方法是有效的。

通过这种方式，你可以在WinForms中实现类似WPF的双向绑定效果。  
这里使用的是 `EventHandler<TEventArgs>` 泛型委托，其中 `TEventArgs` 是 `EventArgs` 类型（或派生类型）。这种定义方式已经隐式地使用了委托，因此不需要显式地定义一个新的委托类型。

如果显式定义委托，好处是什么？  
**1\. 自定义事件参数：**  
如果你需要传递更多信息（不仅仅是 sender 和 EventArgs），可以定义一个自定义的事件参数类，并为其定义一个专门的委托。

    public class MyPropertyChangedEventArgs : EventArgs
    {
        public string OldValue { get; }
        public string NewValue { get; }
    
        public MyPropertyChangedEventArgs(string oldValue, string newValue)
        {
            OldValue = oldValue;
            NewValue = newValue;
        }
    }
    
    // 定义自定义委托
    public delegate void MyPropertyChangedEventHandler(object sender, MyPropertyChangedEventArgs e);
    
    // 使用自定义委托定义事件
    public static event MyPropertyChangedEventHandler MyPropertyChanged;
    

这样，事件处理程序可以接收到更多信息（如旧值和新值）。

**2\. 提高代码可读性：**  
显式定义委托可以让代码更具可读性，尤其是当事件的用途非常明确时。

    public delegate void MyPropertyChangedDelegate(string newValue);
    
    public static event MyPropertyChangedDelegate MyPropertyChanged;
    

这种方式更直观地表达了事件的用途。

**3.灵活性：**  
自定义委托可以定义更灵活的参数列表，而不仅限于 object sender, EventArgs e 的标准模式。  
例如，你可以定义一个没有 sender 参数的事件：

    public delegate void MyPropertyChangedDelegate(string newValue);
    
    public static event MyPropertyChangedDelegate MyPropertyChanged;
    

### 显式定义委托

以下是显式定义委托的完整示例：

    using System;
    using System.Windows.Forms;
    
    public static class MyStaticClass
    {
        // 定义自定义委托
        public delegate void MyPropertyChangedDelegate(string newValue);
    
        // 定义事件
        public static event MyPropertyChangedDelegate MyPropertyChanged;
    
        private static string _myProperty;
        public static string MyProperty
        {
            get { return _myProperty; }
            set
            {
                if (_myProperty != value)
                {
                    string oldValue = _myProperty;
                    _myProperty = value;
                    // 触发事件
                    OnMyPropertyChanged(value);
                }
            }
        }
    
        // 触发事件的方法
        private static void OnMyPropertyChanged(string newValue)
        {
            MyPropertyChanged?.Invoke(newValue);
        }
    }
    
    public class MyForm : Form
    {
        private Label myLabel;
    
        public MyForm()
        {
            myLabel = new Label();
            myLabel.Text = "Initial Value";
            myLabel.Location = new System.Drawing.Point(10, 10);
            this.Controls.Add(myLabel);
    
            // 订阅事件
            MyStaticClass.MyPropertyChanged += MyStaticClass_MyPropertyChanged;
        }
    
        // 事件处理程序
        private void MyStaticClass_MyPropertyChanged(string newValue)
        {
            // 当属性值变化时，更新Label的文本
            myLabel.Text = newValue;
        }
    
        [STAThread]
        public static void Main()
        {
            Application.EnableVisualStyles();
            Application.Run(new MyForm());
        }
    }
    

总结  
使用 EventHandler 的好处：

*   简单、标准化，适合大多数场景。
*   符合 .NET 的事件模式（object sender, EventArgs e）。

显式定义委托的好处：

*   更灵活，可以自定义参数列表。
*   提高代码可读性和表达力。
*   适合需要传递更多信息的场景。

在实际开发中，选择哪种方式取决于具体需求。如果只是简单的值变化通知，使用 EventHandler 就足够了；如果需要更复杂的事件参数或更高的灵活性，则可以显式定义委托。

本文来自博客园，作者：[VipSoft](https://www.cnblogs.com/vipsoft/) 转载请注明原文链接：[https://www.cnblogs.com/vipsoft/p/18702001](https://www.cnblogs.com/vipsoft/p/18702001)