---
layout: post
title: '域登录态分享（类sso）'
date: "2025-10-27T00:44:43Z"
---
域登录态分享（类sso）
============

遇到一个问题，在同一主域下的多个子域之间共享登录状态的需求。例如：

*   `main.example.com` 主站
*   `learn.example.com` 学习中心

希望在任意子域登录后，其他子域也能自动识别登录状态，包括登出同步。

* * *

Cookie 跨子域共享
------------

浏览器安全策略允许 Cookie 在同一主域下共享，只需设置父域（.example.com 指的是包括 example.com 及子域名下都可以共用 cookie，单一指定直接放上域名即可）：

请求来源

Cookie 域

是否生效

`main.example.com`

`.example.com`

✅

`learn.example.com`

`.example.com`

✅

示例：

    Set-Cookie: sid=xxxxx; Domain=.example.com; Path=/; Secure; HttpOnly; SameSite=None
    

后端通过 `Set-Cookie` 响应头设置 Cookie，使其在所有子域生效。

* * *

自定义方案：集中式 Session（共享 sid 模型）
----------------------------

### 方案核心

1.  所有系统在后端共用一个 Session 中心（存储登录 sid 与用户信息映射）。
2.  用户在任一子域（如 `main.example.com`）登录后，后端生成唯一 sid 并通过 `Set-Cookie` 写入 `.example.com` 域。
3.  其他子域（如 `learn.example.com`）访问时，会自动携带同一 Cookie 中的 sid。
4.  各子域后端通过 Session 服务验证 sid 是否有效。
5.  若 sid 存在且有效，则返回用户信息或签发 token。
6.  退出登录时删除 sid，实现所有子域同步登出。

* * *

### 登录与验证流程

#### 1\. 用户登录（`main.example.com`）

    // 前端仅调用登录接口
    await fetch('https://api.main.example.com/login', {
      method: 'POST',
      body: JSON.stringify({ username, password }),
      credentials: 'include'
    });
    

后端示例（Node.js）：

    app.post('/login', (req, res) => {
      const { username, password } = req.body;
      const user = authenticate(username, password);
      if (user) {
        const sid = generateSid();
        sessionStore.set(sid, user);
        res.cookie('sid', sid, {
          domain: '.example.com',
          httpOnly: true,
          secure: true,
          sameSite: 'none',
          path: '/',
        });
        res.json({ success: true });
      } else {
        res.status(401).json({ success: false });
      }
    });
    

#### 2\. 子域验证登录状态（`learn.example.com`）

请求示例：

    await fetch('https://session.example.com/api/validate', {
      credentials: 'include'
    });
    

后端验证：

    app.get('/api/validate', (req, res) => {
      const sid = req.cookies.sid;
      const session = sessionStore.get(sid);
      if (session) {
        res.json({ valid: true, user: session.user });
      } else {
        res.json({ valid: false });
      }
    });
    

#### 3\. 登出同步

所有子域使用同一域的 Cookie：

    app.post('/logout', (req, res) => {
      const sid = req.cookies.sid;
      sessionStore.delete(sid);
      res.clearCookie('sid', { domain: '.example.com', path: '/' });
      res.json({ success: true });
    });
    

* * *

与标准 SSO 的区别对比
-------------

特性

自定义集中 Session 模型

标准化 SSO（OAuth2 / OIDC）

登录管理中心

✅ 有 Session 中心

✅ 独立 IdP（认证中心）

登录凭证形式

sid（后端 Session）

Access Token / ID Token（标准）

协议

❌ 自定义

✅ OAuth2 / OpenID Connect / SAML

安全性

⚠️ 依赖服务端实现

✅ 采用业界安全标准

跨域处理

通过共享 Cookie

统一跳转 + 授权码机制

登出同步

Cookie 统一清除

IdP 通知各客户端登出

扩展性

内部系统适用

可对外开放第三方登录

* * *

方案优缺点
-----

### 优点

*   后端集中控制登录状态，安全性高。
*   实现简单，适合同一主域下多子系统。
*   通过 `Set-Cookie` 跨子域自动共享，无需前端参与。

### 缺点

*   无标准协议，不适合开放平台。
*   若 Session 存储异常，影响所有子系统。
*   无法跨不同主域（如 `.example.com` 与 `.example.org`）。

* * *

演进方向
----

若未来需要：

*   对接外部系统或移动端；
*   支持 OAuth2 授权流程；
*   集成权限管理；

应演进为 **标准化 SSO 架构**：

    [main.example.com] --> [auth.example.com] <-- [learn.example.com]
                            │
                            └--> Issue JWT / Refresh Token
    

* * *

总结
--

场景

推荐方案

同一主域下多子域共享登录

✅ 集中 Session 模型

不同主域间登录共享

✅ 标准 SSO（OAuth2/OIDC）

内部系统快速集成

✅ 自建 Session 验证机制

长期扩展性

⚙️ 升级为标准认证中心

* * *

> **总结**：这个方案是参考 SSO 实现（轻量化内部集中式 Session 模型），主要是在同一主域多子域场景下，也可以使用 nginx 代理指向不同文件夹，有兴趣可以自行了解。后面会出一个 sso 方案，为 OAuth2 / OpenID Connect 架构。有问题大家提出讨论会进行更正！