---
layout: post
title: '割点和桥'
date: "2025-12-08T00:44:07Z"
---
割点和桥
====

无向图的连通性，主要研究割点和桥。本文介绍了割点和桥的定义及其延伸概念，介绍了如何用 Tarjan 算法求解割点与桥，包括对于图是否有重边的讨论。提供了相应的好题作为例题。普及+/提高

前置知识
----

无向图的连通性，主要研究割点和桥。

### 基础定义

*   割点：在无向图中，删去后使得连通分量数增加的点称为 **割点**。形式化地，对于一个无向连通图 \\(G = (V,E)\\)，存在一个点 \\(x \\in V\\)，使删除与 \\(x\\) 相关联的边后，图分裂成两个或两个以上的不连通的子图，称 \\(x\\) 即为图 \\(G\\) 的割点。
    
*   桥：在无向图中，删去后使得连通分量数增加的边称为 **割边**，也称 **桥**。形式化地，对于一个无向连通图 \\(G = (V,E)\\)，存在一条边 \\(e \\in E\\)，若 \\(G - e\\) 不连通，则称 \\(e\\) 即为图 \\(G\\) 的桥。
    

根据割点和桥的定义，孤立点 和 孤立边的两个端点 都不是割点，孤立边是桥。

### 延伸定义

*   点双连通图：不存在割点的无向图称为 **点双连通图**。结合上述分析，孤立点和孤立边均为点双连通图。
    
*   边双连通图：不存在割边的无向图称为 **边双连通图**。结合上述分析，孤立点是边双连通图，但孤立边不是边双连通图。
    
*   点双连通分量：一张图的极大点双连通子图称为 **点双连通分量**，简称 **点双**。
    
*   边双连通分量：一张图的极大边双连通子图称为 **边双连通分量**，简称 **边双**。
    

点双和边双缩点后均得到一棵树，而强连通分量缩点后得到一张有向无环图。

笔者在本文中只讨论如何求解割点与桥，在往后的学习中再作补充。

Tarjan 求割点
----------

不加证明地给出用 **割点判定法则**，读者画图不难理解：

1.  若 \\(v\\) 是非根结点 \\(u\\) 的子结点，且 \\(low\[v\] \\geq dfn\[u\]\\)，则 \\(u\\) 是割点；
    
2.  若根节点 \\(u\\) 在搜索树中至少有 \\(2\\) 棵子树，则 \\(u\\) 是割点。
    

**注意**：割点判定法则须谨记对于 \\(u\\) 是否为根结点的讨论。

[模版题](https://www.luogu.com.cn/problem/P3388) 代码如下，使用 Tarjan 算法求无向图 \\(G\\) 的所有割点的时间复杂度为 \\(O(n + m)\\)。

    #include <bits/stdc++.h>
    using namespace std;
    const int N = 2e4 + 8;
    int n, m, dfn[N], low[N], tim, ans, root;
    bool cut[N]; // 记录该点是否为割点
    vector<int> e[N];
    void Tarjan(int u) {
        dfn[u] = low[u] = ++tim;
        bool flag = false; // u是否为割点
        int cld = 0; // u的儿子个数
        for (int v : e[u]) {
            if (!dfn[v]) {
                Tarjan(v);
                low[u] = min(low[u], low[v]);
                cld++;
                if (low[v] >= dfn[u]) flag = true; // 符合判定1
            } else low[u] = min(low[u], dfn[v]);
        }
        if (u == root && cld < 2) flag = false; // 不符合判定2
        if (flag) ans++, cut[u] = true;
    }
    int main() {
        cin >> n >> m;
        for (int i = 1, u, v; i <= m; i++) {
            cin >> u >> v;
            e[u].push_back(v); e[v].push_back(u);
        }
        for (int i = 1; i <= n; i++) if (!dfn[i]) root = i, Tarjan(i);
        cout << ans << '\n';
        for (int i = 1; i <= n; i++) if (cut[i]) cout << i << ' ';
        return 0;
    }
    

Tarjan 求桥
---------

使用 Tarjan 算法求桥的时间复杂度为 \\(O(n + m)\\)，但需要特别注意是否有重边。

### 无重边

同样不加证明地给出 **桥的判定法则**，读者可以画图理解两者的差别：

若 \\(v\\) 是点 \\(u\\) 的子结点，且 \\(low\[v\] > dfn\[u\]\\)，则边 \\(e = (u, v)\\) 是桥。

对比割点判定法则，没有等号的原因为：删去的是边而非结点，所以只要子树内的结点能绕过 \\(e\\) ，到达包括 \\(u\\) 在内的子树外结点，那么 \\(e\\) 就是割边。

代码如下。

    void Tarjan(int u, int f) {
        dfn[u] = low[u] = ++tim;
        for (int v : e[u]) {
            if (v == f) continue;
            if (!dfn[v]) {
                Tarjan(v, u);
                low[u] = min(low[u], low[v]);
                if (low[v] > dfn[u]) ans++; // 割边的数目加1
            } else low[u] = min(low[u], dfn[v]);
        }
    }
    

### 有重边

Tarjan 求桥有个细节，就是判断非树边。对于当前边 \\(v \\rightarrow u\\)，若 \\(u\\) 是 \\(v\\) 的父亲，则跳过这条边。

但这样做在有重边时会出现错误，原因是算法会将重边也判定为非树边。

解决方法是记录边的编号。对于 vector，在 `push_back` 时将当前边的编号一并压入。

代码如下。

    int n, m, dfn[N], low[N], tim;
    bool bri[M]; // 是否为桥
    vector<pair<int, int> > e[N]; // pair.first记录结点编号，pair.second记录边编号
    void Tarjan(int u, int p) {
        dfn[u] = low[u] = ++tim;
        for (auto [v, i] : e[u]) {
            if (p == i) continue; // p记录上一条边的编号
            if (!dfn[v]) {
                Tarjan(v, i);
                low[u] = min(low[u], low[v]);
                if (low[v] > dfn[u]) bri[i] = true;
            } else low[u] = min(low[u], dfn[v]);
        }
    }
    

例题
--

### [Blockade](https://www.luogu.com.cn/problem/P3469)

首先对第 \\(i\\) 个结点讨论。

如果第 \\(i\\) 个点不是割点，那么原图只分为孤点 \\(i\\) 和剩余 \\((n - 1)\\) 个点所构成的连通块。由于要求有序点对，所以共有 \\(2 \* (n - 1)\\) 对。

如果第 \\(i\\) 个点不是割点，那么原图分为孤点 \\(i\\) 和 \\(k\\) 个连通块，设第 \\(j\\) 个连通块的大小为 \\(sz\[j\]\\)，约定“\\(a\\) 在前”意即在有序数对 \\((a,b)\\) 中的 \\(a\\) 位置。对于点 \\(i\\) 的 \\((k-1)\\) 棵子树在前，共有 \\(\\sum \\limits\_ {j = 1} ^ {k - 1} sz\[j\] \* (n - sz\[j\])\\) 对；对于割点 \\(i\\) 在前，共有 \\((n-1)\\) 对；设除割点 \\(i\\) 及被拆出的子树中的点共有 \\(sum\\) 个。对于除上述情况外的点，共有 \\(sum \* (n - sum)\\) 对。

最后实现时按照上述分析维护即可，注意要开 long long。

点击查看代码

    #include <bits/stdc++.h>
    using namespace std;
    #define int long long
    const int N = 1e5 + 8;
    int n, m, tim, dfn[N], low[N], ans[N], sz[N];
    vector<int> e[N];
    void Tarjan(int u, int f) {
        dfn[u] = low[u] = ++tim;
        sz[u] = 1;
        int chi = 0, sum = n - 1;
        bool flag = false;
        for (int v : e[u]) {
            if (v == f) continue;
            if (!dfn[v]) {
                Tarjan(v, u);
                chi++;
                low[u] = min(low[u], low[v]);
                sz[u] += sz[v];
                if (low[v] >= dfn[u]) {
                    sum -= sz[v];
                    ans[u] += sz[v] * (n - sz[v]);
                    flag = true;
                }
            } else low[u] = min(low[u], dfn[v]);
        }
        if (u == 1 && chi < 2) flag = false;
        if (!flag) ans[u] = 2 * (n - 1);
        else ans[u] += n - 1 + sum * (n - sum);
    }
    signed main() {
        cin >> n >> m;
        for (int i = 1, u, v; i <= m; i++) {
            cin >> u >> v;
            e[u].push_back(v);
            e[v].push_back(u);
        }
        Tarjan(1, 0);
        for (int i = 1; i <= n; i++) cout << ans[i] << '\n';
        return 0;
    }

### [分离的路径](https://www.luogu.com.cn/problem/P2860)

题目相当于要求添加最少得边使原图变成一个边双连通图。换句话说，图中所有点的度数至少为 \\(2\\)。考虑度数为 \\(1\\) 的点，显然它们应至少连 \\(1\\) 条边。贪心地，每条边都连接 \\(2\\) 个度数均为 \\(1\\) 的点的策略是最优的。如果度数为 \\(1\\) 的点的个数是奇数，那么仍要多连 \\(1\\) 条边才能符合题意。

**结论**：最小路径数为边双缩点得到的缩点树 \\(T\\) 的叶子结点个数除以 \\(2\\) 向上取整。

一个比较简单的实现方法是：先 Tarjan 找出所有桥，再 DFS 找出所有边双连通分量，最后统计边双连接的桥的数目为 \\(1\\) 的个数即可。

点击查看代码

    #include <bits/stdc++.h>
    using namespace std;
    const int N = 5e3 + 8, M = 1e4 + 8;
    int n, m, dfn[N], low[N], tim, ans, res;
    bool bri[M], vis[N];
    vector<pair<int, int> > e[N];
    void Tarjan(int u, int p) { // 找出所有桥
        dfn[u] = low[u] = ++tim;
        for (auto [v, i] : e[u]) {
            if (p == i) continue;
            if (!dfn[v]) {
                Tarjan(v, i);
                low[u] = min(low[u], low[v]);
                if (low[v] > dfn[u]) bri[i] = true;
            } else low[u] = min(low[u], dfn[v]);
        }
    }
    void dfs(int u) { // 找出所有边双
        if (vis[u]) return;
        vis[u] = true;
        for (auto [v, i] : e[u]) {
            if (bri[i]) {
                res++;
                continue;
            }
            dfs(v);
        }
    }
    int main() {
        cin >> n >> m;
        for (int i = 1, u, v; i <= m; i++) {
            cin >> u >> v;
            e[u].push_back({v, i});
            e[v].push_back({u, i});
        }
        Tarjan(1, 0);
        for (int i = 1; i <= n; i++)
            if (!vis[i]) { 
                res = 0;
                dfs(i);
                if (res == 1) ans++; // 若边双只有一条桥，则它是缩点树的叶子结点
            }
        cout << (ans + 1) / 2;
        return 0;
    }

### [嗅探器](https://www.luogu.com.cn/problem/P5058)

类比 Tarjan 求割点的过程，若割点 \\(u\\) 非根 \\(a\\) 且子树根 \\(v\\) 的时间戳小于等于终点 \\(b\\) 的时间戳，则 \\(b\\) 在 \\(v\\) 的子树内，所以 \\(u\\) 点即所求的嗅探器安装位置。

点击查看代码

    #include <bits/stdc++.h>
    using namespace std;
    const int N = 2e5 + 8;
    int n, a, b, dfn[N], low[N], tim, ans = 1e9;
    vector<int> e[N];
    void Tarjan(int u) {
        dfn[u] = low[u] = ++tim;
        bool flag = false;
        int cld = 0;
        for (int v : e[u]) {
            if (!dfn[v]) {
                Tarjan(v);
                low[u] = min(low[u], low[v]);
                cld++;
                if (low[v] >= dfn[u] && u != a && dfn[b] >= dfn[v]) flag = true;
            } else low[u] = min(low[u], dfn[v]);
        }
        if (flag) ans = min(ans, u);
    }
    int main() {
        cin >> n;
        int u, v;
        while (cin >> u >> v) {
            if (u == 0 && v == 0) break;
            e[u].push_back(v);
            e[v].push_back(u);
        }
        cin >> a >> b;
        Tarjan(a);
        if (ans != 1e9) cout << ans;
        else cout << "No solution";
        return 0;
    }