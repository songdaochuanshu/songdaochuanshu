---
layout: post
title: '.NET 11 预览版 1 中的新兴架构演进：RISC-V 与 LoongArch 支持的深度技术解析与生态展望'
date: "2026-02-26T00:55:56Z"
---
.NET 11 预览版 1 中的新兴架构演进：RISC-V 与 LoongArch 支持的深度技术解析与生态展望
========================================================

综合上述基于最前沿开发日志、编译架构底座与硬件演进基准的多维深度剖析，.NET 11 预览版 1 在面对以 RISC-V 和 LoongArch 为代表的新一代非垄断性微处理器指令集上所展现出的大规模技术演进态势，其核心意义早已远远超越了虚拟机层面特定 C++ 代码逻辑或汇编模块架构适配的浅层堆叠。从更加宏大的产业视角审视，这一底层基础设施变迁的缩影，实质上折射出了全球计算秩序权力正在历经一场波澜壮阔的板块结构性地壳运动。

进入 2026 年，全球微处理器指令集架构（ISA）的版图正在经历一场深刻的结构性重塑。长期以来由 x86 和 ARM 主导的计算生态，正面临来自开源标准架构 RISC-V 以及具备完全自主知识产权的 LoongArch（龙架构）的强力挑战。在这一宏观技术背景下，现代应用程序运行时的底层适配策略成为了衡量技术生态生命力的关键指标。微软近期发布的.NET 11 预览版 1（Preview 1）及其相关的开源代码库动态，清晰地展示了通用语言运行时（CoreCLR）向这些新兴硬件架构延伸的技术深度与战略考量。在此次更新中，除了常规的库优化、垃圾回收器（GC）堆硬限制以及基于 WebAssembly 的 CoreCLR 基础工作外，底层架构的赋能成为了最受瞩目的核心议题。本文将通过深度解析.NET 11 Preview 1 的官方发布说明、底层代码库（dotnet/runtime）的里程碑进展、编译范式（JIT 与 Native AOT）的演进，以及底层操作系统的协同生态，全面剖析.NET 在 RISC-V 和 LoongArch 架构上的技术实现与战略影响。

**官方背书的基础设施层级迈进：RISC-V 架构在.NET 11 中的深度集成**
------------------------------------------

在.NET 11 预览版 1 的官方发布节点中，RISC-V 与 s390x 一起被明确列入“架构支持启用（Architecture Enablement）”的核心更新范畴。这一声明标志着 RISC-V 在.NET 生态中正逐渐从一个纯粹的社区实验性项目，向具有官方背书的生产级基础设施层级迈进。这种转变并非一蹴而就，而是建立在极其严密的底层指令集特性适配基础之上。

### **压缩指令集（“C”扩展）的底层映射与执行密度优化**

根据官方的运行时发布说明，.NET 11 Preview 1 为 RISC-V 架构引入了初始的“C”扩展（Compressed Instructions）支持。这一扩展的集成对于受管理运行时（Managed Runtime）而言具有基础性的工程意义。在标准的 RISC-V 基础整数指令集（RV32I 或 RV64I）中，所有指令均采用固定的 32 位长度编码格式。然而，在实际的程序执行与高频业务逻辑中，大量指令属于模式高度重复的基础操作，例如对零号寄存器的存取、小范围常数的加载、以及栈指针的微小偏移调整。RISC-V 的“C”扩展通过提供一套紧凑的 16 位短指令编码，将这些高频的 32 位指令映射到更小的物理空间中，从而大幅提高了原生代码的物理密度。

在.NET 的 CoreCLR 即时编译器（RyuJIT）中实现“C”扩展的底层逻辑极为复杂。即时编译器在代码生成（CodeGen）的最后阶段，必须具备高度智能的模式匹配能力，能够识别特定的寄存器分配模式（Compressed integer register-register ops），并在不改变原有语义流的前提下，安全地输出 16 位的压缩指令替代原有的 32 位长指令。这种指令级压缩在运行时层面带来的直接效益是显著缩小了由 JIT 编译生成的机器码在物理内存中的占用体积。更为关键的是，更密集的指令流意味着处理器能够在单个缓存行（Cache Line）中预取更多的操作逻辑，进而显著降低了指令缓存（I-Cache）的未命中率。在云原生高并发微服务场景或存储资源极度受限的边缘计算设备中，这种 I-Cache 命中率的微观提升将通过庞大的执行基数被无限放大，最终直接转化为更高的每周期指令数（IPC）与更低的能耗比。

与此同时，混合长度指令集的引入也打破了传统的系统级假设。由于指令长度不再是严格的 4 字节对齐边界，而是混合了 2 字节与 4 字节的非规则边界，这直接导致传统的函数地址对齐与栈回溯机制失效。因此，.NET 11 Preview 1 在引入“C”扩展的同时，必须同步更新 RISC-V 环境下的异常处理与栈展开（Stack Unwinding）机制。当运行时抛出异常或进行垃圾回收的安全点（Safe Point）扫描时，执行引擎能够确保在遇到 16 位边界的指令指针（Instruction Pointer）时，精确无误地识别当前帧的上下文并回溯调用栈，而配套的底层反汇编器和调试工具链也进行了同步的升级调整。

### **Zbs 扩展与底层状态翻转的高效折叠**

除了基础的“C”扩展，.NET 11 Preview 1 还在代码生成器中引入了对 RISC-V Zbs 扩展的深度支持（追踪提案号为 dotnet/runtime#115335）。Zbs 是 RISC-V 庞大的位操作扩展集（Bit-Manipulation Extension）中的一个专门子集，其核心目标是提供针对单个比特位的高效硬件指令，包括位的设置、清除、反转和提取操作。

从高级语言生态（如 C# 或 F#）的视角来看，位操作通常需要通过掩码构建、按位与、按位或以及移位等一系列复合算术逻辑运算来实现。在尚未支持 Zbs 扩展的 RISC-V 处理器基线上，RyuJIT 必须将“设置第 N 位为 1”这样的单点逻辑，笨拙地翻译为包含加载立即数、执行变长移位、执行逻辑或等多条独立机器指令的微型执行流。然而，在启用 Zbs 支持的硬件前提下，.NET 11 的 JIT 编译器现在可以利用架构嗅探机制，动态将其折叠为单一的硬件级机器指令（例如 bset, bclr, binv, bext 等）。

这一特性在.NET 运行时的内部实现以及高频业务逻辑中具有极其深远的性能影响。以.NET 的分代垃圾回收器（Garbage Collector）为例，GC 线程在执行并发标记（Concurrent Mark）阶段时，需要以极高的频率操作内存卡表（Card Table）和堆对象头（Object Header）中的特定状态位，以标记对象的存活状态或代际晋升信息。Zbs 扩展使得这些底层的并发状态翻转操作变得极其精简，不仅有效减少了 CPU 的执行周期，更降低了多核多线程环境下的内存总线锁定压力。此外，在 C# 开发者广泛使用的 \[Flags\] 枚举验证中，Zbs 扩展使得诸如 Enum.HasFlag 之类的底层平台调用机制在原生代码层面达到了理论上的最优时钟周期表现，消除了原本由多指令组合带来的微架构流水线气泡。

**隐性崛起与社区突围：LoongArch 架构的自主演进模型**
---------------------------------

值得学术界与工业界高度关注的是，尽管 RISC-V 和基于 IBM 大型机的 s390x 在.NET 11 Preview 1 的官方发布日志中被重点提及，但关于中国自主研发的指令集架构 LoongArch（龙架构）的进展，却并未出现在这一层级的官方通告中。然而，通过穿透表层日志，深度分析 GitHub 上 dotnet/runtime 代码库的实际合并记录与里程碑架构，可以清晰地观测到 LoongArch 架构在.NET 11 开发周期内所展现出的惊人社区驱动力、技术成熟度以及极其庞大的代码集成量。

### **从 MIPS 的历史羁绊到完全独立的 ISA 拓荒**

LoongArch 在.NET 生态中的集成路径与其自身硬件架构的演进历史密不可分。开发该架构的龙芯中科（Loongson）早期长期基于 MIPS 架构授权开发微处理器。然而，随着地缘技术战略的转变与自主可控需求的指数级增长，龙芯在 2021 年之后彻底摒弃了 MIPS 授权体系，全面转向了完全由本土自主设计的 LoongArch 指令集（ISA）。这种设计哲学不仅剥离了过往架构的冗余历史包袱，更在指令编码格式、寄存器堆规范以及应用程序二进制接口（ABI）的设计上，既体现了现代精简指令集的正交性特征，又保持了与主流微架构高度适配的独立性。

硬件底层的算力跃升是推动软件生态适配的根本驱动力。根据 2026 年最新的硬件基准测试数据与独立评估，龙芯最新的桌面级 3A6000 处理器乃至面向数据中心的高密度 3B6000 处理器（具备 12 核心与 24 线程，并支持 ECC 内存），在核心微架构的同频指令吞吐量（IPC）上，已经能够与国际主流厂商的成熟架构（如 Intel 的第 10 代至 11 代 Core 架构，乃至 AMD Zen 系列的部分产品）形成有力的直接竞争。这种物理硅片层面硬实力的成熟，使得构建于其上的国产操作系统生态迫切需要顶级通用软件运行时的对等支持，而.NET 平台的全面兼容则成为了这一宏大工程的关键拼图。

### **里程碑 11.0.0 中的核心技术攻坚与向量化重构**

根据 GitHub 开源追踪数据，针对 LoongArch64 的大规模重构与支持工作在 dotnet/runtime 仓库中被系统性地标记为特有架构标签（arch-loongarch64），并被明确归入 11.0.0 版本的开发里程碑中。由龙芯技术团队与庞大的开源爱好者组成的联合力量指出，该架构平台目前已经“开发并支持了 dotnet 内部几乎所有的功能边界” 。在.NET 11 周期内，针对 LoongArch 进行的底层核心优化远超基础指令映射，直接切入了现代高性能计算的腹地。

其中最具代表性的技术攻坚在于 SIMD 硬件向量化扩展（LSX 与 LASX）在 JIT 编译器中的深度集成。LoongArch 架构体系内包含了专用的龙芯基础 SIMD 扩展（LSX，处理 128 位向量数据）和高级 SIMD 扩展（LASX，处理 256 位宽向量数据）。在现代.NET 基础类库（BCL）中，极其庞大的代码分支严重依赖于 System.Numerics.Vector<T> 抽象以及特定硬件的内部函数（Hardware Intrinsics）来加速海量数据集的字符串解析、加密解密轮次以及张量运算。

当前在.NET 11 的代码树中，针对这些 128 位和 256 位宽幅向量寄存器的 JIT 映射逻辑正在进行高度定制化的代码重构（如议题 dotnet/runtime#113354 所追踪）。JIT 编译器的目标是确保 C# 源码层面的 Vector128 和 Vector256 数据结构，能够在龙芯硬件上直接且透明地触发原生 LSX 或 LASX 硬件加速管线，而非通过低效的标量循环执行进行软件回退。这种跨平台的向量抽象匹配，对于确保运行在国产服务器上的分布式数据库与云原生中间件具备足够的时延优势具有决定性意义。

此外，针对操作系统底层 ABI 演进的动态适配同样在紧锣密鼓地推进。在较新的开源 Linux 发行版（如 glibc 2.38 及以上版本）中，动态链接器对于线程本地存储（TLS）描述符的解析与重定位机制发生了根本性的改变。针对这种变化，LoongArch 架构的贡献者必须向 CoreCLR 提交特定的汇编层级探测代码。例如，在核心辅助函数 GetTLSResolverAddress 中，必须通过精确计算程序计数器（PC）的高 20 位与低 12 位相对偏移，以动态解析并挂载线程本地静态变量的内存绝对地址。这种对于系统内核与 C 标准库底层 ABI 变化的毫秒级跟进，从根本上保证了.NET 11 能够在如深度系统（Deepin）、银河麒麟（Kylin OS V11）等最新国产商业及开源操作系统上实现无缝的运行稳定性。

### **社区分发瓶颈、信任割裂与虚拟单体仓库自举**

深层的数据透视表明，LoongArch 目前在.NET 核心生态中所面临的最大结构性挑战，并不在于 C++ 虚拟机源码的移植难度或特定汇编原语的实现阻力，而在于由微软官方主导的闭环构建系统与全球发版策略所产生的隐性排斥力。

在.NET 的商业支持架构下，微软对于诸如 x64 架构或 ARM64 架构等所谓的“一等公民支持平台”，会提供极其庞大且昂贵的全链路持续集成（CI）构建基础设施。官方服务器会自动编译生成这些架构的交叉编译 JIT（例如针对 Windows 宿主机的 clrjit\_<host>\_arm64.dll），并将包含可分发执行代码的底层运行时包（如 Microsoft.NETCore.App.Runtime.\*）直接发布并托管至全球范围内广泛使用的 NuGet.org 中央服务器。

然而，基于复杂的商业考量与测试资源限制，LoongArch 在微软的体系中被严格定义并隔离为“社区平台（Community Platform）” 。微软官方明确拒绝对这些社区平台提供预编译的运行时二进制包下载服务，也并不将其纳入主干版本的官方质量保证协议。为了冲破这一由于商业策略导致的分发壁垒，龙芯开发团队与中国开源社区共同设计并主导了一套极具极客精神且高度复杂的自举构建（Bootstrapping）流程：

为了彻底脱离对官方环境的硬性依赖，社区在.NET 10 和延续至今的.NET 11 开发周期中，全面采用了基于 VMR（虚拟单体仓库，Virtual Monolithic Repository）的源码构建模型 。开发者通过编写复杂的 GitHub Actions 脚本，配合 QEMU 跨架构模拟器或是挂载实际的物理机节点，预先在云端构建出初始目标架构的最小化 SDK 工具链。随后，将这一刚刚出炉的初版 SDK 作为宿主环境的基础编译器（Bootstrap Compiler），在真实的 LoongArch 硬件上启动耗时极长的原生系统级自举重编译。

更为棘手的是包管理器的网络阻断问题。由于标准的.NET SDK 在执行 dotnet build 或 dotnet publish 命令时，会默认尝试从 NuGet.org 拉取缺失的隐式依赖包，而这些由微软控制的服务器上根本不存在针对 LoongArch 的原生架构包，这必然导致构建链条的断裂。为了化解这一死局，社区版 SDK 必须被深度魔改并配置为优先从本地离线包存储目录（如 <SDK install prefix>/library-packs）恢复架构特定的原生包（例如 Native AOT 所需的核心工具链、dotnet-sos 内存转储分析工具等）。

这种依赖社区极客群体与硬件企业联合维持的“自给自足”式分发模型，虽然以极其强悍的韧性证明了开源架构合作的去中心化潜力，但也深刻地暴露了新兴自主硬件架构在试图获得全球顶层软件商业主体平等待遇之前，必须独自蹚过的痛苦磨合期。这也直接导致了生态内部一种“双轨信任体系”的滋生：主流架构用户完全信任且依赖于由微软加密签名的直递分发流，而 LoongArch 及部分 RISC-V 用户则必须将信任链条转移至本地开源社区或芯片厂商二次重构打包的系统镜像中。这种信任的客观割裂，在未来涉及高敏感度企业级云服务部署或严重安全漏洞（CVE）紧急热修复时，极易因社区响应带宽不足或官方阻断而引发系统性的安全真空挑战。

* * *

**表 1：.NET 11 预览阶段 RISC-V 与 LoongArch 核心集成维度对比分析**

技术考察维度

RISC-V 架构 (RV64GCV/Zbs)

LoongArch 架构 (LA64)

**官方支持与定位层级**

作为“架构支持启用”重点更新列入官方 Release Notes

维持社区维护平台地位，未出现在官方主发布文档中

**二进制包源与分发模式**

结合社区交叉构建与部分微软官方 CI 基建整合的过渡态

完全剥离官方 NuGet 服务器，依赖 VMR 单体仓库编译与本地包缓存自举

**基础微指令级优化路线**

聚焦代码密度的“C”扩展（压缩指令）与状态操控的 Zbs 扩展（单比特位操作）

深度融合基础架构指令，密集跟进现代 Linux (glibc 2.38+) 的 TLS 描述符动态寻址变迁

**数据并行与高级向量化**

逐步向 RVA23 标准靠拢，当前以通用 Vector<T> 后备降级抽象为主

明确开启 128位 LSX 与 256位 LASX 硬件 SIMD 指令扩展的 JIT 直接映射集成

**当前核心生态驱动引擎**

国际开源标准组织与多维硬件厂商协作共建 (如 SiFive, SpacemiT 联盟)

龙芯中科企业主导及本土开源操作系统上下游生态（如深度、麒麟）的自下而上强力托举

\---
----

**编译范式的底层博弈：JIT 灵活性与 Native AOT 的跨架构深水区**

.NET 运行时的代码执行模型并非单一，而是构建于多轨制的编译范式之上。传统的即时编译（JIT）提供了无可替代的动态适应性，而在近期.NET 版本迭代中被提升至极高战略地位的本机提前编译（Native AOT），则是决定该生态能否在云原生微服务无服务器（Serverless）架构和极限嵌入式物联网（IoT）场景中确立统治地位的关键利器。在这两类对底层细节极度敏感的新兴架构（RISC-V 与 LoongArch）上，JIT 和 Native AOT 正在经历着截然不同、甚至充满矛盾的技术演进曲线。

### **动态信息嗅探与 JIT 的渐进式重构优势**

即时编译器（JIT）的核心架构优势，在于其能够在应用程序启动后的执行准备阶段，实时且精准地提取当前所处物理硬件的微架构元数据（例如处理器确切代数、内核特性开关、以及支持的特定指令集扩展），并据此在运行时动态生成局部最优的原生机器指令流。

对于 RISC-V 这一以“模块化与极致可扩展性”为设计初衷的架构而言，JIT 的动态嗅探能力是拯救性能的基石。在 RISC-V 的碎片化现实中，不同的系统级芯片（SoC）可能封装了完全不同的指令集扩展子集（例如某些极简物联网芯片仅包含基础的整数运算 I 与乘法 M 扩展，而高性能节点则封装了完整的位操作 Zbs 与向量化 V 扩展）。.NET 11 Preview 1 的 RyuJIT 系统在初始化虚拟机时，会读取操作系统暴露的硬件能力标志（HWCAP）。当嗅探到当前宿主芯片在物理层支持 Zbs 扩展时，JIT 引擎的代码生成器（CodeGen）便会在转换中间语言（IL）时，果断抛弃冗长的位掩码回退逻辑，瞬间启用单比特位操作的直通优化路径。这种能力使得同一份已编译的.NET DLL 程序集，无需针对不同的 RISC-V 芯片做预先隔离打包，便能在不同的硬件上榨取各自的极限性能。

同样地，对于 LoongArch 架构，由于其处理器产品的代际微架构迭代速度极快（如从早期 3A5000 的初露峥嵘，跃升至 3C6000 的服务器级算力），JIT 编译器能够基于 CPU 的家族架构版本标记，在极短的时间窗口内自动决策是否在某段高频热点路径中展开特定的内存操作循环，或是直接发射最高阶的 LASX 指令集来加速大规模连续内存块的并发拷贝（Memcpy）。更重要的是，JIT 编译模式对于那些重度依赖于动态加载程序集（Dynamic Assembly Loading）机制、重度使用反射（Reflection）以实现依赖注入（DI）和对象关系映射（ORM）的大型遗留企业级复杂应用，提供了毫无损耗的向后兼容性。在新架构软硬件生态启动和大规模应用迁移的历史初期，这种无需业务代码重写的平滑过渡能力，其战略价值无论如何评估都不为过。

### **Native AOT 在链接与异常处理机制上的结构性暗礁**

尽管 JIT 提供了完美的动态执行灵活性，但在要求毫秒级冷启动、极致内存控制的现代容器化部署以及受限的边缘计算网络节点中，JIT 在编译过程产生的内存抖动和 CPU 预热期长（Warm-up delay）成为了难以容忍的致命弱点。Native AOT 被学术界与工业界视为彻底根除这一痼疾的“终极技术圣杯”，它通过在前期构建发布期（Publish Time）调用庞大的静态分析工具，将受管制的中间语言（IL）彻底剔除 CoreCLR 虚拟机的外壳，直接降维剥离并链接为不依赖任何运行时组件的目标平台二进制原生机器码可执行文件。

然而，在.NET 11 的预览技术周期内，试图将极其复杂的 Native AOT 引擎安全稳定地推向 RISC-V 和 LoongArch 这两片未知的拓荒地，却遭遇了极其严峻的底层工具链、内存对齐与链接器（Linker）规范壁垒：

首先，跨平台异常展开上下文的结构体对齐（Struct Alignment）谬误成为了阻挡 AOT 编译的首要顽疾。Native AOT 剥离了传统虚拟机庞大的异常捕获安全网，转而高度依赖操作系统提供的外部底层原生库（例如由 LLVM 维护的 llvm-libunwind 项目）来处理 C++ 及其生成的汇编底层的异常传播与帧栈重构。底层开发维度的技术细节分析指出，在极力推进 RISC-V 架构的 Native AOT 端口移植时（相关追踪议题为 dotnet/runtime#106223），其庞大的底层源码构建流程频繁遭遇结构体内存越界与尺寸断言崩溃。深入排查发现，在 llvm-libunwind 暴露的 C++ 接口中，用于存放展开信息的泛型结构 UnwindCursor<A, R> 的物理尺寸，与 CoreCLR 内部平台抽象层（PAL）所预期的经典 unw\_cursor\_t 结构体，在 RISC-V 环境下的内存对齐填充规则出现了高达 96 字节的惊人空间差异。如此巨大的内存偏差将直接导致栈空间覆盖（Stack Corruption）与进程的灾难性崩溃。为了缝合这一生态断层，不仅需要在外部进行结构体边界的强制约束，甚至由于 LLVM 使用的物理寄存器命名规范（如将整型寄存器映射为 X1, X2 系列）与 CoreCLR 平台抽象层内部长期固化的规范（映射为 T1, T2 别名系列）存在语义分歧，底层开发者不得不在海量的 C++ 辅助宏定义中进行枯燥且极易出错的手动指针偏移补偿与寄存器掩码映射转换。

其次，.NET 11 Preview 1 官方隆重推出的“运行时异步（Runtime Async）”特性，为 Native AOT 在新架构上的落地制造了新的复杂度高墙。传统基于 C# 编译器的 async/await 实现依赖于生成复杂的托管状态机（Compiler-generated state machine），而.NET 11 的 Runtime Async 将这些协程挂起、栈重写和上下文切换的基础设施直接下沉嵌入到了运行时的最深层。官方日志明确指出，在 Preview 1 中，Native AOT 的基础设施应该已经具备了编译含有这些 runtime-async 调用代码的能力。要在 RISC-V 或 LoongArch 这样内存模型规范尚未完全固化且相关寄存器调用约定仍处于演进中的相对后进平台上实现这一底层挂起机制，AOT 编译器的后端发射器（Backend Emitter）必须能够极度精准、毫无偏差地发射带有体系结构专属性的汇编桩（Assembly stubs），这无疑是对整个社区架构能力的一场极限压力测试。

最后，多核内存屏障（Memory Barriers）与极速原子操作的汇编映射鸿沟难以逾越。现代由 C# 构建的高并发网络异步服务器（如 ASP.NET Core 或 Kestrel），在被彻底编译为原生的 AOT 二进制后，其微弱的锁机制和无锁并行数据字典在物理执行时，依然极其依赖于 CPU 提供的强一致性内存排序保证。针对 Native AOT 特有的执行环境，系统开发者无法复用 JIT 中现成的汇编模板，而必须亲自下场，专门为 RISC-V 和 LoongArch 的微架构编写底层的汇编级内存屏障函数，并处理复杂的指令流水线重排控制，以确保在大规模多核 SMP 环境下的缓存一致性与内存全局可见性（具体技术障碍可见追踪议题 dotnet/runtime#106219） 。

综上所述，RISC-V 与 LoongArch 在 Native AOT 引擎上的技术推进，绝对不仅仅停留在 C# 语法特性的表层兼容转换，它本质上是一场深入操作系统内核源码、涉及极其庞杂的 LLVM 前端与后端工具链耦合、底层 C 语言标准库运行时（glibc 或 musl 选择）、目标平台特异性 ELF 链接器规范修正以及微体系结构 ABI 强制约定的全景式系统工程宏大“战役” 。

**硅片边界的物理突破与 Linux 7.0 内核生态的底层同频共振**
------------------------------------

软件运行时的性能天花板和稳定性基石，最终依然受制于硬件微架构的物理承载极限以及操作系统底层内核对这些算力的调度潜能。在系统性评估分析.NET 11 及其前瞻版本针对这两大新兴架构的支持前景与商业潜力时，我们绝不能孤立地将视野局限于虚拟机源码，而必须将镜头拉远，审视 2026 年 RISC-V 和 LoongArch 在整个开源 Linux 内核体系与主流企业发行版生态中所取得的宏观突围。

### **RVA23 配置文件确立：RISC-V 终结碎片化的统一基线**

如前文所述，RISC-V 基于指令集高度模块化设计的初衷，曾一度成为其在高级软件生态中落地的最大双刃剑，导致了严重的硬件实现碎片化（Hardware Fragmentation），使得高级编译器在应对繁杂的硬件排列组合时疲于奔命。然而，随着 RVA23（RISC-V 应用程序环境配置文件 2023）架构标准在 2025 年至 2026 年间从纸面草案走向全面确立，并被全球主流的硬件芯片设计厂商（包括 SiFive、SpacemiT 乃至参与标准制定的诸多中国创企）作为不可逾越的设计红线广泛采纳，RISC-V 生态终于迎来了具有划时代破局意义的统一硬件基线。

RVA23 规范通过刚性契约，强制规定了所有声称兼容该配置文件的处理器必须包含 RVV 1.0 标准（基础向量计算扩展）以及一系列专门用于支撑现代高级操作系统与受管理语言运行时的高级特权功能。这种底层硬件特性的标准化收敛与闭环，直接为类似.NET 的 CoreCLR、Java 的 HotSpot 以及 JavaScript 的 V8 这样庞大的高级指令虚拟机，提供了一个不再随波逐流的坚固技术靶标。

在统一的指令集地基上，.NET 的 JIT 编译器核心贡献者们终于得以从繁杂的架构组合中解脱出来，不再需要耗费大量的开发带宽去为无数种由于指令缺失而导致的异常情况编写性能低下的软件回退（Fallback）分支逻辑。相反，他们现在可以针对 RVA23 这个被全行业确认为“黄金标准”的模型，直接将精力投入到深度的指令流水线交错重组与数据预取（Prefetching）优化中。这种硬件层面的大一统，同样也在极大地驱动着宏观操作系统的快速跟进，例如 Canonical 公司宣布在其企业级的 Ubuntu 26.04 (LTS) 发行版中，为基于 RVA23 的服务器芯片提供官方稳定的 RISC-V 核心镜像，彻底打通了从底层硅片到上层.NET 云原生容器部署的基础设施链路。

### **Linux 7.0 内核跃升与 LoongArch 处理器的洪荒算力释放**

在针对 LoongArch（龙架构）的开源生态软硬协同方面，2026 年 2 月在开源社区正式发布的全新 Linux 7.0 内核大版本，为架构生态带来了一轮极其重要的底层红利与特权层级优化。

深度技术补丁日志的数据显示，Linux 7.0 内核专门针对 LoongArch 体系架构引入了对 128 位原子比较交换（128-bit atomic CMPXCHNG）的深度汇编指令支持。这项底层内核能力的增强，对于构建在操作系统调度器之上的.NET 运行时有着脱胎换骨的价值。在.NET 极其精密的并发模型体系中，基础的锁定互斥机制（例如暴露给开发者的 Interlocked 工具类抽象）、底层庞大且错综复杂的无锁数据结构队列（Lock-free structures），以及执行效率决定生死存亡的垃圾回收（GC）内部多线程堆内存分配器，在极大概率上都极度依赖于处理器原子维度的 CAS (Compare-And-Swap) 机器原语。传统的 64 位互斥操作往往由于存在所谓的 ABA 并发逻辑漏洞，需要复杂的软件算法进行弥补；而 128 位物理宽度的 CMPXCHNG 允许内核及挂载于其上的.NET 运行时，以完全无锁且原子化的方式，在一个指令时钟周期内安全地更新并同步一对紧密相邻的 64 位数据结构（例如，在一个内存事务中同时覆盖一个对象指针与其对应的版本序列号或是 ABA 重入计数器）。这一技术突破，将在涉及金融交易或高频实时竞价等应用场景下，大幅度消减.NET 11 进程在应对超高并发网络请求时由线程上下文频繁切换导致的锁争用延迟（Lock contention overhead）崩溃。

与此同时，Linux 7.0 对于 LoongArch 核心处理器同步多线程（SMT）硬件特性的动态热插拔（Hotplug）机制提供了官方源码级的支持方案。这项针对内核调度器行为特性的重构，与龙芯 3B6000 处理器的物理核心调度高度契合（该芯片不仅具备 12 个强劲的物理核心与 24 个逻辑线程，其本身设计的微架构更是专门面向高密度云计算服务器环境）。在此双重支持的叠加效应下，.NET 底层的自适应线程池（ThreadPool）管理机制与极其精密的工作窃取调度队列（Work-Stealing Queues）将能够更加平滑、更加动态且毫无滞后地响应操作系统的核心算力重分配调度策略，彻底释放芯片在应对高突发流量波动时的物理潜能。

在更广阔、更具标志意义的社区操作系统发行版层面，国际最具声望的开源 Linux 社区 Debian 做出了一项震撼架构生态的决定：在其代号为 "forky" 的未来 Debian 14 全新版本中，历经极其漫长的社区代码审核与编译考验，正式将 loong64 纳入了其最高技术评级的官方架构支持体系（Official Architecture）序列。这种由早年间基于衍生包拼凑的“非主流野生生态”，通过自身硬核的基础包构建实力硬生生转化为全球最严谨发行版“官方正编”的转变，不仅是 LoongArch 走向国际计算舞台的一块耀眼里程碑，更在商业层面上极大降低了政企客户以及系统集成商（SI）在使用 LoongArch 自主可控硬件规模化部署大型.NET 云服务节点时的底层系统环境配置风险与长期的持续运行维护成本。

* * *

**表 2：跨架构底层协同演进技术数据特征总览 (追踪截至 2026 年第一季度数据)**

系统底层技术协同组件

RISC-V 架构宏观演进动态

LoongArch 架构宏观演进动态

**Linux 内核级调度支持**

在后续补丁中密集提交针对 RVA23 标准规范的底层机制修正

Linux 7.0 发版正式引入 128 位原子 CMPXCHNG 支持与高级 SMT 热插拔优化

**微体系基础硬件标杆**

涌现出基于 SiFive P550 核心, SpacemiT K3 高级处理器的评估板平台

全面铺开基于 Loongson 3A6000 (桌面级效能) 与 3B6000 (12C/24T 企业级节点) 的算力评测

**开源工具链与发行版**

Ubuntu 26.04 版本针对 RVA23 平台提供底层深度构建优化

开源重镇 Debian 14 正式发文确立 loong64 架构为最高级别的官方主发布架构

**Native AOT 构建阻碍点**

第三方底层库 llvm-libunwind 依然存在高达 96 字节的严重结构体空间对齐偏差与平台寄存器映射分歧

在诸如 glibc 2.38 等最新 C 标准库体系下，由于系统 API 变更，针对线程本地存储 (TLS) 的动态寻址描述符正面临被迫重构重写

\---
----

**次级与三级衍生生态影响：重塑多语言技术栈的权力格局**

试图客观且公允地评估.NET 11 Preview 1 在 RISC-V 与 LoongArch 架构上的这些高难度底层技术拓荒，我们就绝不能仅仅将其降维视作微软某一个大版本产品的局部常规性功能更新堆叠。在底层逻辑上，这实则是反映并推动着一场涵盖了国际化开源社区的运作规则、全球地缘计算技术战略的变迁、以及跨编程语言核心生态之间激烈生存竞争的庞大系统性秩序变革。通过透视上述庞杂的基础表层编译数据与框架适配进展，我们可以顺理成章地推演出几项将在未来数年内深刻影响架构发展走向的关键次级与三级衍生影响。

### **开源基础设施的自下而上倒逼与区域技术战略驱动机制**

通常在传统的国际商业软件历史认知中，大型开发语言底层生态的繁荣与架构迁移，绝大多数是由处于金字塔顶端的顶级跨国科技巨头，依据其最核心的垄断商业需求，通过自上而下的巨额资本投入所强行驱动的。微软自身过去几十年对传统 x86 体系的深度捆绑，以及近年来不遗余力地拥抱 ARM64 架构，其最核心且唯一的原始动机，皆是建立在保障其极其庞大的 Azure 云计算数据中心帝国绝对商业利益最大化的基础之上。然而，此次通过观察 dotnet/runtime 这一核心代码库对 LoongArch 和 RISC-V 这些所谓边缘架构的接纳过程，展示出的却是一种截然不同的力量结构模式：一种由强烈的区域性地缘技术自主战略（特别是以追求极致供应链系统安全性与基础半导体算力自主权为根本驱动导向的需求）自下而上反向集结，进而以极其硬核的技术提交量倒逼传统国际化开源基础设施系统被迫让步并进行接纳的演进模型 。

作为一条带有强烈主权色彩、完全独立于西方传统 Intel/AMD 与英国 ARM 等封闭授权体系之外的自主开发架构，龙架构（LoongArch）原本在纯粹追求商业最大公约数的北美软件巨头眼中并无战略优先级。然而，它却依靠着背后极其庞大、专业且具备极强使命感的本土开源社区力量的日夜奋战（例如，社区开发者持续独立提供全套定制交叉编译器，无休止地定位并修复 JIT 代码在异常边界的溢出错误，以及向最底层的 QEMU 模拟器和 Linux 内核主线持续提交海量规范化的适配补丁代码），硬生生地凭借技术源码的绝对控制力，在一直被视作“北美企业级技术最高阵地”的.NET 底层开源库源码树中，以不容置疑的方式砸开了一条专属的、受到社区公认的合并架构通道。这种极为罕见的硬核生态冲锋机制无可辩驳地验证了一个趋势：在现代基于彻底开放源码的分布式运作协作模式（如通过前文所述的虚拟单体仓库 VMR 构建理念）下，即使某项新颖且区域性极强的处理器架构绝非项目发起组织的全球商业利益核心，但只要该架构的支持者联盟具备足够庞大且持久的硬核代码贡献能力，并背靠着一片广阔且拥有极高天花板的区域性战略市场前景，这股原本处于边缘的技术洪流依然能够依靠自身实力获取乃至改写全球底层技术演进方向的一席之地，并最终实现事实层面上的技术话语权平权。

### **跨语言技术架构生态（Rust、Go、.NET）的适配代差与存亡逻辑**

伴随着 2026 年新一代异构硅片硬件（RISC-V 和 LoongArch）在各行各业的大规模铺展，这股硬件洪流正在以前所未有的速度和力度，深刻地影响并筛选着主流高级编程语言在下一代系统级开发领域的优胜劣汰进程。在这样的技术选型极限测试场景中，Rust、Go 以及.NET 这三大现代语言阵营表现出了截然不同的战略妥协与架构生存逻辑。

作为当前系统级编程语言当红炸子鸡的 Rust 语言，在处理新架构的接纳准入方面，一直以来都采取了极其防御性甚至有些苛刻保守的架构官方支持分级（Tier 1/Tier 2/Tier 3）防火墙机制。尽管由于出色的内存安全特性，Rust 在 Linux 7.0 乃至未来的内核驱动开发中大放异彩、势如破竹，然而在由语言官方所维护的目标编译三元组（Target Tuple）规范中，RISC-V 和 LoongArch 这两大新兴指令集架构仍长期且艰难地徘徊在 Tier 2 甚至部分工具链停滞在 Tier 3 级别。这种尴尬的分级定义意味着，尽管语言维护者要求任何新增代码提交在涉及这些新架构时构建流程绝对不能在 CI（持续集成）服务器上遭遇编译失败，但对于复杂的底层运行时测试用例的大面积溃败却采取了一种放任允许的态度，且坚决不提供任何形式的顶级商业发版环境下的官方构建无缺漏保证。这种过度追求自身语言核心内存安全不被破坏的“稳健甚至缓慢的”架构拥抱策略，虽然在最高层面上完美保护了语言金字塔的声誉，但也客观上极大地拉长并阻碍了这批新兴处理器架构在其生态上达到“企业级开箱即用”以及完全可用性的演进生命周期。

相比之下，Go 语言则通过其设计哲学中极其强调的封闭体系静态编译特性和高度独立自治的自举编译器架构机制，在面对 RISC-V 和 LoongArch 等底层物理新架构涌现时，展现出了一种令人瞠目结舌的快速响应以及几乎无摩擦的极速支持能力（在开发者的操作层面，往往仅仅需要在构建时进行极其简单的底层环境变量 GOOS 和 GOARCH 的无缝切换便可生成对应架构的可执行文件）。然而，在技术领域往往没有免费的午餐，Go 语言的这种便捷性是通过在二进制层面做出痛苦的体积膨胀妥协而换取的。为了保证无缝的执行体验，Go 会在没有任何动态运行时依赖的前提下，极其霸道地将其设计中庞大而复杂的并发调度器底层引擎和占用不菲的垃圾回收器核心逻辑，毫无遗漏地硬编码并静态链接至每一个编译输出的最终执行文件中。这种以牺牲体积换取便利的架构权衡，直接导致其在面对微缩型物联网设备终端，或是对于板载存储资源和内存通道极其受限、每兆字节（Megabyte）容量都必须锱铢必较的新兴 RISC-V 定制化边缘开发板上时，面临着因为二进制可执行程序物理体积严重过度膨胀而根本无法烧录的巨大工程落地障碍。

此时，回看正处于本文核心焦点、步入第十一个大版本演进阶段的.NET 平台，其在针对 RISC-V 和 LoongArch 体系架构的支持路径探索中，展示出了一种极度务实、甚至混合了多种技术战术思想平衡的“混合妥协潜能战术”。总体表现为“JIT 技术底盘率先铺展抢占生态高地、Native AOT 在极深水区紧盯其后填补短板”。一方面，.NET 开发团队极其聪明地利用了其已经锤炼数十年的虚拟机环境（CoreCLR 引擎）的强大软硬件屏障隔离优势，通过一套平台抽象层有效屏蔽了底层千差万别的寄存器映射与物理页管理差异，借助极度庞大且成熟的基础核心类库体系（BCL），在短短两三年内迅速在如同采用 Loongson 3C6000 多路服务器这样算力充沛且急需应用落地的高性能后端数据中心场景中，实现了业务代码零修改、功能全覆盖的极速铺载；而在战术的另一面，面对技术挑战呈现指数级增长的系统极深水区，也就是如何通过彻底的机器码直接编译（Native AOT 技术），解决前述诸如跨语言底层异常处理结构内存模型不互认、以及在多核弱内存一致性架构上强制手工植入超低级屏障等底层硬核工程天堑，.NET 依然在投入核心资源进行缓慢而艰苦且毫不妥协的底层推进。此举的最高战略野心昭然若揭：它不仅要稳住高性能服务端的旧有地盘，更试图在不久的未来由无数碎片化的 RISC-V 微型控制器（MCU）、极低功耗节点及海量嵌入式工业控制领域掀起的下沉市场风暴中，利用极度精简的无虚拟机 AOT 产物，同极其强势的 Rust 甚至更古老的 C 语言，展开一场极其残酷的关于“微米级执行体积与零毫秒启动延迟”的市场存量份额的生死争夺战。

**六、 结论**
---------

综合上述基于最前沿开发日志、编译架构底座与硬件演进基准的多维深度剖析，.NET 11 预览版 1 在面对以 RISC-V 和 LoongArch 为代表的新一代非垄断性微处理器指令集上所展现出的大规模技术演进态势，其核心意义早已远远超越了虚拟机层面特定 C++ 代码逻辑或汇编模块架构适配的浅层堆叠。从更加宏大的产业视角审视，这一底层基础设施变迁的缩影，实质上折射出了全球计算秩序权力正在历经一场波澜壮阔的板块结构性地壳运动。

对于具有全球性开源野心的 RISC-V 架构而言，.NET 11 敏锐且极具前瞻性地通过在最核心的即时编译器代码生成器中快速引入能够极致压缩代码体积的“C”扩展指令映射，以及精准消灭冗余微操作的气泡消除利器 Zbs 特化位操作扩展，极其精准地抓住了该精简架构在面对现代庞杂面向对象语言系统时，在静态指令密度与高频复杂状态动态翻转操作（如垃圾回收标记）上的致命核心硬件痛点。这些极为扎实的编译器优化，不仅有效修复了基础性能的洼地，更预示着.NET 作为一门拥有庞大企业级应用基因的技术栈，正在毫不含糊地为协助 RISC-V 迈向极度苛求高密度逻辑压缩的边缘算力节点和极限低功耗微型物联网核心应用场景，进行着极具战略价值的底层基建冲锋。可以预见，随着被全行业寄予厚望的 RVA23 标准规范在全球硬件产业链体系中的最终强制普及定案，RISC-V 阵营目前在推进.NET 高级本机提前编译（Native AOT）时所遭遇的底层结构体兼容深水区，以及在处理大吞吐量内存 SIMD 向量化扩展适配时的杂乱无章，必将迎来更加标准化、流程化且极其高效的降维整合与收敛。

对于同样极具分量、代表着一条试图以完全自主研发的硬核逻辑去突破算力封锁体系的新兴 LoongArch（龙架构）而言，其在整个.NET 11 技术前瞻周期内所呈现出的一套游离于微软官方正统发版系统之外，却又在底层开源核心源码逻辑代码集成上呈现出极度繁荣狂飙的独特发展路径，令人震惊地向全球技术社区展示了一种仅仅通过极其过硬的代码提交实力与技术攻坚韧性，自下而上地在全球最顶级的通用基础软件生态库中强行建立并确立了自身技术合法地位与存在感话语权的全新突围范式。借助 Linux 7.0 乃至更具备标志性影响力的 Debian 14 全新系统底层内核对这种新兴架构极其慷慨的、前所未有的特权级调度机制深度协同所带来的并发调度红利，以及基于庞大 128 位 LSX 与 256 位 LASX 高阶内存向量化加速优化逻辑在 JIT 层的逐步精准匹配与最终生产环境落地，LoongArch 在全面支撑起那些直接基于.NET 平台底层技术架构开发的大型企业级强一致性后端并发服务器、对时延极其敏感的微服务数据库引擎以及对于指令吞吐量存在吞噬级要求的高性能云计算前沿探索业务中的工业级绝对商用可行性，已经在这些冰冷但无可争议的技术代码与性能演进脉络中，得到了最为深刻与具有历史穿透力的事实层面的验证。

站在整个数字工业技术架构演变的历史十字路口面向未来，高级计算机软件通用运行时、极其庞杂的底层语言编译器构建重组工具链，与负责将一切抽象逻辑降维到物理世界执行的最终极晶体管处理器硬件微架构之间的“跨层级深度软硬件协同演化（Software-Hardware Co-design）”，将比在过去摩尔定律一枝独秀的任何历史巅峰时期都显得更加残酷、紧密与不可剥离。无论是即时编译引擎（JIT）在面对极其细微的特定微观位操作指令时所必须具备的毫秒级极高动态精确嗅探与决策发射能力，还是以斩断一切历史运行时依赖为唯一目的、正在残酷推进的终极本机提前编译技术（Native AOT），其在面对因为完全不同且高度独立演进的跨异构底层异常上下文物理结构体对齐严重偏差、以及系统底层内核级原生强一致性调用约定（Calling Conventions）差异时，所正在经历的那场犹如在最深黑暗水域中摸爬滚打、甚至鲜血淋漓的极其痛苦的代码磨合与阵痛，都在以最不容置疑的技术规律向全世界证明了一个残酷但极其真实的公理：在这个长期以来由单一巨头指令集架构傲慢垄断的静态旧日秩序已经开始分崩离析的多元计算新纪元中，唯有那些能够以前所未有的宏大包容度，并且真正能够以最小的代码摩擦力与最深度的架构自适应耦合性，去全面、高效且稳定地适配且榨干多元化且割裂复杂的底层异构物理硬件的顶层基础软件设施，才能在即将到来的算力生态大洗牌中，最终赢得全行业开发者的真正顶礼膜拜与长久拥趸。

**引用的链接**
---------

1.  The Great Decoupling: How RISC-V Achieved Architecture Sovereignty in 2026 [https://markets.financialcontent.com/stocks/article/tokenring-2026-2-6-the-great-decoupling-how-risc-v-achieved-architecture-sovereignty-in-2026](https://markets.financialcontent.com/stocks/article/tokenring-2026-2-6-the-great-decoupling-how-risc-v-achieved-architecture-sovereignty-in-2026)
2.  The PC industry is changing: RISC-V goes mainstream : r/hardware - Reddit [https://www.reddit.com/r/hardware/comments/1el2279/the\_pc\_industry\_is\_changing\_riscv\_goes\_mainstream/](https://www.reddit.com/r/hardware/comments/1el2279/the_pc_industry_is_changing_riscv_goes_mainstream/)
3.  NET 11 Preview 1 is now available! - Microsoft Dev Blogs [https://devblogs.microsoft.com/dotnet/dotnet-11-preview-1/](https://devblogs.microsoft.com/dotnet/dotnet-11-preview-1/)
4.  core/release-notes/11.0/preview/preview1/runtime.md at main · dotnet/core · [https://github.com/dotnet/core/blob/main/release-notes/11.0/preview/preview1/runtime.md](https://github.com/dotnet/core/blob/main/release-notes/11.0/preview/preview1/runtime.md)
5.  When will the community release the LoongArch64's SDK package with ARM32/64 and X86/64? · Issue #116293 · dotnet/runtime - [https://github.com/dotnet/runtime/issues/116293](https://github.com/dotnet/runtime/issues/116293)
6.  Box64 Expands into Risc-V and LoongArch territory - Boiling Steam [https://boilingsteam.com/box64-expands-into-risc-v-and-loong-arch-territory/](https://boilingsteam.com/box64-expands-into-risc-v-and-loong-arch-territory/)
7.  Loongson - Wikipedia [https://en.wikipedia.org/wiki/Loongson](https://en.wikipedia.org/wiki/Loongson)
8.  The unofficial yet comprehensive FAQ for LoongArch (last updated 2022-11-23) | write(2) [https://blog.xen0n.name/en/posts/tinkering/loongarch-faq/](https://blog.xen0n.name/en/posts/tinkering/loongarch-faq/)
9.  But RISC-V predates loongarch64 - why did Loongson create a new ISA instead of i... | Hacker News [https://news.ycombinator.com/item?id=43761295](https://news.ycombinator.com/item?id=43761295)
10.  Not just RISC-V, when it comes to performance the Loongson CPUs (with the LoongA... | Hacker News [https://news.ycombinator.com/item?id=43854100](https://news.ycombinator.com/item?id=43854100)
11.  Arch Linux Running Well On LoongArch - Loongson 3B6000 Benchmarks - Phoronix [https://www.phoronix.com/review/arch-linux-loongarch](https://www.phoronix.com/review/arch-linux-loongarch)
12.  Labels · dotnet/runtime · [https://github.com/dotnet/runtime/labels/area-PAL-coreclr](https://github.com/dotnet/runtime/labels/area-PAL-coreclr)
13.  LoongArch: Support for glibc < 2.40 (TLS descriptors) · Issue #119163 · dotnet/runtime [https://github.com/dotnet/runtime/issues/119163](https://github.com/dotnet/runtime/issues/119163)
14.  RISC-V architecture support · Issue #49594 · dotnet/sdk - [https://github.com/dotnet/sdk/issues/49594](https://github.com/dotnet/sdk/issues/49594)
15.  RISC-V support · Issue #36748 · dotnet/runtime - [https://github.com/dotnet/runtime/issues/36748](https://github.com/dotnet/runtime/issues/36748)
16.  The RISC-V Revolution: Open-Source Silicon Challenges ARM and x86 Dominance in 2026 [https://markets.chroniclejournal.com/chroniclejournal/article/tokenring-2026-1-16-the-risc-v-revolution-open-source-silicon-challenges-arm-and-x86-dominance-in-2026](https://markets.chroniclejournal.com/chroniclejournal/article/tokenring-2026-1-16-the-risc-v-revolution-open-source-silicon-challenges-arm-and-x86-dominance-in-2026)
17.  Box64 Expands into RISC-V and LoongArch territory - Hacker News [https://news.ycombinator.com/item?id=46751460](https://news.ycombinator.com/item?id=46751460)
18.  DuckDB on LoongArch [https://duckdb.org/2026/01/06/duckdb-on-loongarch-morefine](https://duckdb.org/2026/01/06/duckdb-on-loongarch-morefine)
19.  .NET 生态系统中LoongArch 与RISC-V 的整合深度分析- 张善友- 博客园 [https://www.cnblogs.com/shanyou/p/19309893](https://www.cnblogs.com/shanyou/p/19309893)
20.  Just-In-Time (JIT) vs. Ahead-Of-Time (AOT) Compilation in .NET Core - Medium [https://medium.com/@syed.zeeshan.ali.jafri\_99339/just-in-time-jit-vs-ahead-of-time-aot-compilation-in-net-core-c7650f1a366a](https://medium.com/@syed.zeeshan.ali.jafri_99339/just-in-time-jit-vs-ahead-of-time-aot-compilation-in-net-core-c7650f1a366a)
21.  .NET vs Native AOT performance comparison : r/dotnet - Reddit [https://www.reddit.com/r/dotnet/comments/1foxtss/net\_vs\_native\_aot\_performance\_comparison/](https://www.reddit.com/r/dotnet/comments/1foxtss/net_vs_native_aot_performance_comparison/)
22.  Testing Your Native AOT Applications - .NET Blog [https://devblogs.microsoft.com/dotnet/testing-your-native-aot-dotnet-apps/](https://devblogs.microsoft.com/dotnet/testing-your-native-aot-dotnet-apps/)
23.  blown away by .NET10 NativeAOT : r/dotnet - Reddit [https://www.reddit.com/r/dotnet/comments/1r9uguu/blown\_away\_by\_net10\_nativeaot/](https://www.reddit.com/r/dotnet/comments/1r9uguu/blown_away_by_net10_nativeaot/)
24.  RISC-V NativeAOT port · Issue #106223 · dotnet/runtime - [https://github.com/dotnet/runtime/issues/106223](https://github.com/dotnet/runtime/issues/106223)
25.  Labels · dotnet/runtime - [https://github.com/dotnet/runtime/labels/arch-riscv](https://github.com/dotnet/runtime/labels/arch-riscv)
26.  Add support for the LoongArch architecture · Issue #518 · rust-lang/compiler-team - [https://github.com/rust-lang/compiler-team/issues/518](https://github.com/rust-lang/compiler-team/issues/518)
27.  Phoronix: Linux Hardware Reviews & Performance Benchmarks, Open-Source News [https://www.phoronix.com/](https://www.phoronix.com/)
28.  LoongArch Ready With New Features In Linux 7.0 - Phoronix [https://www.phoronix.com/news/Linux-7.0-LoongArch](https://www.phoronix.com/news/Linux-7.0-LoongArch)
29.  Loong64 is now an official Debian architecture - LWN.net [https://lwn.net/Articles/1051576/](https://lwn.net/Articles/1051576/)
30.  Linux Performance, Benchmarks & Open-Source News - Phoronix [https://www.phoronix.com/news](https://www.phoronix.com/news)
31.  Dropping support for Arm32 (.NET 9) · dotnet runtime · Discussion #71042 - [https://github.com/dotnet/runtime/discussions/71042](https://github.com/dotnet/runtime/discussions/71042)
32.  Current status of .NET support on HarmonyOS platform · Issue #103627 · dotnet/runtime [https://github.com/dotnet/runtime/issues/103627](https://github.com/dotnet/runtime/issues/103627)
33.  Rust vs Go in 2026 - Rustify [https://rustify.rs/articles/rust-vs-go-in-2025](https://rustify.rs/articles/rust-vs-go-in-2025)
34.  Committing to Rust in the kernel - LWN.net [https://lwn.net/Articles/991062/](https://lwn.net/Articles/991062/)
35.  Microsoft donates the Mono Project to the Wine team - Hacker News [https://news.ycombinator.com/item?id=41371106](https://news.ycombinator.com/item?id=41371106)

欢迎大家扫描下面二维码成为我的客户，扶你上云

![](https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg)