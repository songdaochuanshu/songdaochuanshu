---
layout: post
title: 'Java深拷贝与浅拷贝核心解析'
date: "2025-08-31T00:43:37Z"
---
Java深拷贝与浅拷贝核心解析
===============

​

Java深拷贝与浅拷贝的概念
--------------

浅拷贝（Shallow Copy）只复制对象的引用，而不复制对象本身。拷贝后的对象和原对象共享同一块内存地址中的子对象。修改其中一个对象的非基本类型属性时，另一个对象的对应属性也会被修改。

深拷贝（Deep Copy）会复制对象及其所有子对象，生成一个完全独立的新对象。拷贝后的对象和原对象完全分离，修改其中一个对象的属性不会影响另一个对象。

### 内存分析示例

假设有一个Person类，包含name（String）和address（Address类）属性：

    class Address {
        String city;
        // 构造方法、getter/setter省略
    }
    
    class Person implements Cloneable {
        String name;
        Address address;
        
        @Override
        protected Object clone() throws CloneNotSupportedException {
            return super.clone(); // 默认浅拷贝
        }
    }
    

浅拷贝实现与内存表现
----------

    Person p1 = new Person();
    p1.name = "Alice";
    p1.address = new Address("Beijing");
    
    Person p2 = (Person)p1.clone();
    

### 内存表现：

p1和p2是两个独立对象，但它们的address属性指向同一个Address对象  
修改p2.address.city会影响p1.address.city

深拷贝实现方式
-------

### 方法1：重写clone()

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Person cloned = (Person)super.clone();
        cloned.address = (Address)this.address.clone(); // 递归克隆引用对象
        return cloned;
    }
    

### 方法2：序列化实现

    public Person deepCopy() throws IOException, ClassNotFoundException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);
        
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return (Person)ois.readObject();
    }
    

### 内存表现：

p1和p2完全独立，包括所有引用类型属性  
修改p2.address.city不会影响p1.address.city

性能与适用场景
-------

### 浅拷贝：

性能更好，仅复制引用  
适合引用对象不可变或不需要独立修改的场景

### 深拷贝：

性能开销较大，需要递归复制所有对象  
适合需要完全独立对象的场景，如多线程环境

注意事项
----

String等不可变对象在浅拷贝中是安全的  
数组的clone()方法是浅拷贝  
深拷贝可能导致循环引用问题  
使用第三方库（如Apache Commons Lang的SerializationUtils）可以简化深拷贝实现  
​