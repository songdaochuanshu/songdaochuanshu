---
layout: post
title: '鸿蒙应用开发从入门到实战（四）：ArkTS 语言概述'
date: "2025-09-15T00:42:12Z"
---
鸿蒙应用开发从入门到实战（四）：ArkTS 语言概述
==========================

ArkTS是HarmonyOS优选的主力应用开发语言。ArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是TS的超集。

​ **大家好，我是潘Sir，持续分享IT技术，帮你少走弯路。《鸿蒙应用开发从入门到项目实战》系列文章持续更新中，欢迎关注！**

一、HarmonyOS开发语言ArkTS概述
----------------------

HarmonyOS 应用的主要开发语言是 ArkTS，它由 TypeScript（简称TS）扩展而来，在继承TypeScript语法的基础上进行了一系列优化，使开发者能够以更简洁、更自然的方式开发应用。值得注意的是，TypeScript 本身也是由另一门语言 JavaScript 扩展而来。因此三者的关系如下图所示

​ ArkTS是HarmonyOS优选的主力应用开发语言。ArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是TS的超集。

​ 因此，在学习ArkTS语言之前，**建议开发者具备TS语言开发能力**。

​ 当前，ArkTS在TS的基础上主要扩展了如下能力：

*   基本语法

​ **ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素**的能力，再配合**ArkUI开发框架**中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。

*   状态管理

​ ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活地利用这些能力来实现数据和UI的联动。

*   渲染控制

​ ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。

​ 未来，ArkTS会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。

二、ArkTS基本语法
-----------

### 2.1 基本语法概述

在初步了解了ArkTS语言之后，我们以一个具体的示例来说明ArkTS的基本组成。如下图所示，当开发者点击按钮时，文本内容从“Hello World”变为“Hello ArkUI”。

本示例中，ArkTS的基本组成如下所示

> 自定义变量不能与基础通用属性/事件名重复。

*   装饰器

​ 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，@Component表示自定义组件，@Entry表示该自定义组件为入口组件，@State表示组件中的状态变量，状态变量变化会触发UI刷新。

*   UI描述
    
    以声明式的方式来描述UI的结构，例如build()方法中的代码块。
    
*   自定义组件
    
    可复用的UI单元，可组合其他组件，如上述被@Component装饰的struct Hello。
    
*   系统组件
    

​ ArkUI框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的Column、Text、Divider、Button。

*   属性方法
    
    组件可以通过链式调用配置多项属性，如fontSize()、width()、height()、backgroundColor()等。
    
*   事件方法
    
    组件可以通过链式调用设置多个事件的响应逻辑，如跟随在Button后面的onClick()。
    

除此之外，ArkTS扩展了多种语法范式来使开发更加便捷：

*   @Builder/@BuilderParam
    
    特殊的封装UI描述的方法，细粒度的封装和复用UI描述。
    
*   @Extend/@Styles
    
    扩展内置组件和封装属性样式，更灵活地组合内置组件。
    
*   stateStyles
    
    多态样式，可以依据组件的内部状态的不同，设置不同样式。
    

### 2.2 声明式UI描述

​ ArkTS以声明方式组合和扩展组件来描述应用程序的UI，同时还提供了基本的属性、事件和子组件配置方法，帮助开发者实现应用交互逻辑。

#### 2.2.1 创建组件

根据组件构造方法的不同，创建组件包含有参数和无参数两种方式。

> 创建组件时不需要new运算符。

*   无参数

如果组件的接口定义没有包含必选构造参数，则组件后面的“()”不需要配置任何内容。例如，Divider组件不包含构造参数：

    Column() {
      Text('item 1')
      Divider()
      Text('item 2')
    }
    

*   有参数

如果组件的接口定义包含构造参数，则在组件后面的“()”配置相应参数。

（1）Image组件的必选参数src。

    Image('https://xyz/test.jpg')
    

（2）Text组件的非必选参数content。

    // string类型的参数
    Text('test')
    // $r形式引入应用资源，可应用于多语言场景
    Text($r('app.string.title_value'))
    // 无参数形式
    Text()
    

（3）变量或表达式也可以用于参数赋值，其中表达式返回的结果类型必须满足参数类型要求。

例如，设置变量或表达式来构造Image和Text组件的参数。

    Image(this.imagePath)
    Image('https://' + this.imageUrl)
    Text(`count: ${this.count}`)
    

#### 2.2.2 配置属性

属性方法以“.”链式调用的方式配置系统组件的样式和其他属性，建议每个属性方法单独写一行。

（1）配置Text组件的字体大小。

    Text('test')
      .fontSize(12)
    

（2）配置组件的多个属性。

    Image('test.jpg')
      .alt('error.jpg')    
      .width(100)    
      .height(100)
    

（3）除了直接传递常量参数外，还可以传递变量或表达式。

    Text('hello')
      .fontSize(this.size)
    Image('test.jpg')
      .width(this.count % 2 === 0 ? 100 : 200)    
      .height(this.offset + 100)
    

（4）对于系统组件，ArkUI还为其属性预定义了一些枚举类型供开发者调用，枚举类型可以作为参数传递，但必须满足参数类型要求。

例如，可以按以下方式配置Text组件的颜色和字体样式。

    Text('hello')
      .fontSize(20)
      .fontColor(Color.Red)
      .fontWeight(FontWeight.Bold)
    

#### 2.2.3 配置事件

事件方法以“.”链式调用的方式配置系统组件支持的事件，建议每个事件方法单独写一行。

（1）使用箭头函数配置组件的事件方法。

    Button('Click me')
      .onClick(() => {
        this.myText = 'ArkUI';
      })
    

（2）使用匿名函数表达式配置组件的事件方法，要求使用bind，以确保函数体中的this指向当前组件。

    Button('add counter')
      .onClick(function(){
        this.counter += 2;
      }.bind(this))
    

（3）使用组件的成员函数配置组件的事件方法。

    myClickHandler(): void {
      this.counter += 2;
    }
    ...
    Button('add counter')
      .onClick(this.myClickHandler.bind(this))
    

（4）使用声明的箭头函数，可以直接调用，不需要bind this。

    fn = () => {
      console.info(`counter: ${this.counter}`)
      this.counter++
    }
    ...
    Button('add counter')
      .onClick(this.fn)
    

#### 2.2.4 配置子组件

如果组件支持子组件配置，则需在尾随闭包"{...}"中为组件添加子组件的UI描述。Column、Row、Stack、Grid、List等组件都是容器组件。

（1）以下是简单的Column组件配置子组件的示例。

    Column() {
      Text('Hello')
        .fontSize(100)
      Divider()
      Text(this.myText)
        .fontSize(100)
        .fontColor(Color.Red)
    }
    

（2）容器组件均支持子组件配置，可以实现相对复杂的多级嵌套。

    Column() {
      Row() {
        Image('test1.jpg')
          .width(100)
          .height(100)
        Button('click +1')
          .onClick(() => {
            console.info('+1 clicked!');
          })
      }
    }
    

基本语法中的自定义组件和扩展UI的能力在后续进行介绍。

三、ArkTS状态管理
-----------

### 3.1 状态管理概述

​ 在前文的描述中，我们构建的页面多为静态界面。如果希望构建一个动态的、有交互的界面，就需要引入“状态”的概念。

​ 在上面的示例中，用户与应用程序的交互触发了文本状态变更，状态变更引起了UI渲染，UI从“Hello World”变更为“Hello ArkUI”。

​ 在声明式UI编程框架中，UI是程序状态的运行结果，用户构建了一个UI模型，其中应用的运行时的状态是参数。当参数改变时，UI作为返回结果，也将进行对应的改变。这些运行时的状态变化所带来的UI的重新渲染，在ArkUI中统称为**状态管理机制**。

​ 自定义组件拥有变量，变量必须被装饰器装饰才可以成为状态变量，状态变量的改变会引起UI的渲染刷新。如果不使用状态变量，UI只能在初始化时渲染，后续将不会再刷新。 下图展示了State和View（UI）之间的关系。

*   View(UI)：UI渲染，指将build方法内的UI描述和@Builder装饰的方法内的UI描述映射到界面。
*   State：状态，指驱动UI更新的数据。用户通过触发组件的事件方法，改变状态数据。状态数据的改变，引起UI的重新渲染。

#### 3.1.1 基本概念

*   状态变量：被状态装饰器装饰的变量，状态变量值的改变会引起UI的渲染更新。示例：@State num: number = 1,其中，@State是状态装饰器，num是状态变量。
*   常规变量：没有被状态装饰器装饰的变量，通常应用于辅助计算。它的改变永远不会引起UI的刷新。以下示例中increaseBy变量为常规变量。
*   数据源/同步源：状态变量的原始来源，可以同步给不同的状态数据。通常意义为父组件传给子组件的数据。以下示例中数据源为count: 1。
*   命名参数机制：父组件通过指定参数传递给子组件的状态变量，为父子传递同步参数的主要手段。示例：CompA: ({ aProp: this.aProp })。
*   从父组件初始化：父组件使用命名参数机制，将指定参数传递给子组件。子组件初始化的默认值在有父组件传值的情况下，会被覆盖。示例：

    @Component
    struct MyComponent {
      @State count: number = 0;
      private increaseBy: number = 1;
    
      build() {
      }
    }
    
    @Component
    struct Parent {
      build() {
        Column() {
          // 从父组件初始化，覆盖本地定义的默认值
          MyComponent({ count: 1, increaseBy: 2 })
        }
      }
    }
    

*   初始化子节点：父组件中状态变量可以传递给子组件，初始化子组件对应的状态变量。示例同上。
*   本地初始化：在变量声明的时候赋值，作为变量的默认值。示例：@State count: number = 0。

#### 3.1.2 装饰器总览

ArkUI提供了多种装饰器，通过使用这些装饰器，状态变量不仅可以观察在组件内的改变，还可以在不同组件层级间传递，比如父子组件、跨组件层级，也可以观察全局范围内的变化。根据状态变量的影响范围，将所有的装饰器可以大致分为：

*   管理组件拥有状态的装饰器：组件级别的状态管理，可以观察组件内变化，和不同组件层级的变化，但需要唯一观察同一个组件树上，即同一个页面内。
*   管理应用拥有状态的装饰器：应用级别的状态管理，可以观察不同页面，甚至不同UIAbility的状态变化，是应用内全局的状态管理。

从数据的传递形式和同步类型层面看，装饰器也可分为：

*   只读的单向传递；
*   可变更的双向传递。

ArkUI提供的装饰器如下图，开发者可以灵活地利用这些能力来实现数据和UI的联动。

上图中，Components部分的装饰器为组件级别的状态管理，Application部分为应用的状态管理。开发者可以通过@StorageLink/@LocalStorageLink实现应用和组件状态的双向同步，通过@StorageProp/@LocalStorageProp实现应用和组件状态的单向同步。

**（1）管理组件拥有的状态** ，即图中Components级别的状态管理：

*   @State：@State装饰的变量拥有其所属组件的状态，可以作为其子组件单向和双向同步的数据源。当其数值改变时，会引起相关组件的渲染刷新。
*   @Prop：@Prop装饰的变量可以和父组件建立单向同步关系，@Prop装饰的变量是可变的，但修改不会同步回父组件。
*   @Link：@Link装饰的变量和父组件构建双向同步关系的状态变量，父组件会接受来自@Link装饰的变量的修改的同步，父组件的更新也会同步给@Link装饰的变量。
*   @Provide/@Consume：@Provide/@Consume装饰的变量用于跨组件层级（多层组件）同步状态变量，可以不需要通过参数命名机制传递，通过alias（别名）或者属性名绑定。
*   @Observed：@Observed装饰class，需要观察多层嵌套场景的class需要被@Observed装饰。单独使用@Observed没有任何作用，需要和@ObjectLink、@Prop连用。
*   @ObjectLink：@ObjectLink装饰的变量接收@Observed装饰的class的实例，应用于观察多层嵌套场景，和父组件的数据源构建双向同步。

> 仅@Observed/@ObjectLink可以观察嵌套场景，其他的状态变量仅能观察第一层，详情见各个装饰器章节的“观察变化和行为表现”小节。

**（2）管理应用拥有的状态**，即图中Application级别的状态管理：

*   AppStorage是应用程序中的一个特殊的单例LocalStorage对象，是应用级的数据库，和进程绑定，通过@StorageProp和@StorageLink装饰器可以和组件联动。
*   AppStorage是应用状态的“中枢”，将需要与组件（UI）交互的数据存入AppStorage，比如持久化数据PersistentStorage和环境变量Environment。UI再通过AppStorage提供的装饰器或者API接口，访问这些数据。
*   框架还提供了LocalStorage，AppStorage是LocalStorage特殊的单例。LocalStorage是应用程序声明的应用状态的内存“数据库”，通常用于页面级的状态共享，通过@LocalStorageProp和@LocalStorageLink装饰器可以和UI联动。

**（3）其他状态管理功能**

​ 除了前面提到的组件状态管理和应用状态管理，ArkTS还提供了@Watch和$$来为开发者提供更多功能：

​ @Watch用于监听状态变量的变化。

​ $$运算符：给内置组件提供TS变量的引用，使得TS变量和内置组件的内部状态保持同步。

四、ArkTS渲染控制
-----------

​ ArkUI通过自定义组件的build()函数和@builder装饰器中的声明式UI描述语句构建相应的UI。在声明式描述语句中开发者除了使用系统组件外，还可以使用渲染控制语句来辅助UI的构建，这些渲染控制语句包括控制组件是否显示的条件渲染语句，基于数组数据快速生成组件的循环渲染语句以及针对大数据量场景的数据懒加载语句。

#### 4.1 条件渲染

​ ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，使用if、else和else if渲染对应状态下的UI内容。

#### 4.2 循环渲染

​ ForEach接口基于数组类型数据来进行循环渲染，需要与容器组件配合使用，且接口返回的组件应当是允许包含在ForEach父容器组件中的子组件。例如，ListItem组件要求ForEach的父容器组件必须为List组件。

#### 4.3 数据懒加载

​ LazyForEach从提供的数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。当在滚动容器中使用了LazyForEach，框架会根据滚动容器可视区域按需创建组件，当组件滑出可视区域外时，框架会进行组件销毁回收以降低内存占用。

**《鸿蒙应用开发从入门到项目实战》系列文章持续更新中，欢迎关注！**

  
作者：黑马腾云  
微信公众账号：自学帮  
博客园：[黑马腾云博客](https://www.cnblogs.com/heimatengyun)  
如果你想及时得到个人撰写文章以及著作的消息推送，或者想看看个人推荐的技术资料，可以扫描左边二维码（或者长按识别二维码）关注微信公众号）。  
本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。