---
layout: post
title: 'C 里面如何使用链表 list'
date: "2026-02-26T00:55:56Z"
---
C 里面如何使用链表 list
---------------

c 的世界可能高频业务都依赖 list 增删改查. 这里简单交流下自己在 c 里面使用 list 

**1\. 学生时代, 那会学习 C 数据结构, 比较简单**

struct person {
    int id;
    char name\[64+1\];
    struct person \* next;
};

类似上面这样, 需要什么依赖 next 指针来回调整, 然后手工 print F5 去 debug 熬. 

**2\. 刚工作青年时代, 主要花活, 随大流**

类似

[structc/modular/test/list.h at master · wangzhione/structc](https://github.com/wangzhione/structc/blob/master/modular/test/list.h#L1-L15)

#pragma once

#include "struct.h"

//
// list.h 似魔鬼的步伐, 单链表库
// $LIST 需要嵌入 struct 的第一行
// void \* list = nullptr;      //        create list
// list\_delete(list, fide); // \[可选\] delete list
//
struct $list {
    struct $list \* next;
};

#define $LIST struct $list $node;

或者类似

[ccan/ccan/list/list.h at master · rustyrussell/ccan](https://github.com/rustyrussell/ccan/blob/master/ccan/list/list.h#L11-L44)

/\*\*
 \* struct list\_node - an entry in a doubly-linked list
 \* @next: next entry (self if empty)
 \* @prev: previous entry (self if empty)
 \*
 \* This is used as an entry in a linked list.
 \* Example:
 \*    struct child {
 \*        const char \*name;
 \*        // Linked list of all us children.
 \*        struct list\_node list;
 \*    };
 \*/
struct list\_node
{
    struct list\_node \*next, \*prev;
};

/\*\*
 \* struct list\_head - the head of a doubly-linked list
 \* @h: the list\_head (containing next and prev pointers)
 \*
 \* This is used as the head of a linked list.
 \* Example:
 \*    struct parent {
 \*        const char \*name;
 \*        struct list\_head children;
 \*        unsigned int num\_children;
 \*    };
 \*/
struct list\_head
{
    struct list\_node n;
};

杂技, 理解的心智负担稍微高一点, 但使用上对方有了单元测试, 比较成熟, list 结构问题较少, 除了业务的内存错位自己 debug 稍微麻烦点.  

**3\. 35岁中年之后, 又想起刚开始那会**

[skynet/skynet-src/socket\_server.c at master · cloudwu/skynet](https://github.com/cloudwu/skynet/blob/master/skynet-src/socket_server.c#L64-L80)

类似这样

struct write\_buffer {
    struct write\_buffer \* next;
    const void \*buffer;
    char \*ptr;
    size\_t sz;
    bool userobject;
};

struct write\_buffer\_udp {
    struct write\_buffer buffer;
    uint8\_t udp\_address\[UDP\_ADDRESS\_SIZE\];
};

struct wb\_list {
    struct write\_buffer \* head;
    struct write\_buffer \* tail;
};

需要 list , 还是直接 next 指针来回调整. 

当下各种 ai 加持, 这种方式可能是最简单最直接, 当然 c 写代码相对麻烦, 多做好单元测试.

人生也类似, 兜兜转转一个圈, 那种圈在时空维度看, 是螺旋上升的. 

不知道有没有人好奇, 为什么不直接一开始就上升呢, 可能生命不需要赶着投胎吧, 浪费不是时间, 也不是人生, 也可能是享受到了时间, 享受到了自己来回波动的人生.   
  
: ) Good luckly ~  
  
**4\. 未来时代, 对于个人而言, C 融入自己思维一部分, 可能不再去主动写了.** 

类似婴儿那会记忆, 与其说忘了, 已经存在于脑海最底层机制里面了. 

posted on 2026-02-25 16:19  [喜ω欢](https://www.cnblogs.com/life2refuel)  阅读(73)  评论(0)    [收藏](javascript:void\(0\))  [举报](javascript:void\(0\))