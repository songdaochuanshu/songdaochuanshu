---
layout: post
title: '逆向三剑客：keystone，capstone，unicorn'
date: "2026-01-29T00:54:52Z"
---
逆向三剑客：keystone，capstone，unicorn
===============================

简介
==

**keystone** 是一个**汇编器**，能够将汇编代码转换成硬编码。  
**capstone** 是一个**反汇编器**，能够将硬编码转换为汇编代码。  
**unicorn** 是一个**模拟器**，能够模拟cpu执行汇编指令。

通过这3个工具，能够帮助我们逆向模拟分析代码，绕过动态的反调试，简化静态的vm和混淆的困扰。

环境安装
====

    pip install keystone-engine capstone unicorn
    

这3个工具用法**极其简单**，下面通过示例来演示其用法。

Keystone
========

### 示例

    from keystone import *
    
    CODE = b"INC ECX; ADD EDX, ECX"
    
    try:
        ks = Ks(KS_ARCH_X86, KS_MODE_64)
        
        encoding, count = ks.asm(CODE)
        
        print(f"汇编指令数量: {count}")
        print(f"机器码 (十进制): {encoding}")
        print(f"机器码 (Hex): {''.join(f'{x:02x}' for x in encoding)}")
    
    except KsError as e:
        print(f"ERROR: {e}")
    

### 代码解释

代码流程十分简单：  
**初始化keystone->编译代码->输出结果**

##### 初始化keystone

    ks = Ks(KS_ARCH_X86, KS_MODE_64)
    

初始化`keystone`引擎：

*   第一个参数：选择指令架构例如：x86，arm......
*   第二个参数：选择模式，例如：64位，32位，小端序......

##### 编译代码

将汇编转换为16进制的shellcode

    encoding, count = ks.asm(CODE)
    

*   第一个返回值：机器码指令的数组
*   第二个返回值：汇编指令数量

Capstone
========

`capstone`的用法和`keystone`差不多。

### 示例

    from capstone import *
    
    CODE = b"\xff\xc1\x01\xca"
    
    md = Cs(CS_ARCH_X86, CS_MODE_64)
    
    print("地址\t\t指令\t\t操作数")
    print("-" * 30)
    
    for i in md.disasm(CODE, 0x1000):
        print(f"0x{i.address:x}:\t{i.mnemonic}\t{i.op_str}")
    

### 代码解释

代码流程跟`keystone`差不多：  
**初始化capstone->反编译代码->输出结果**

##### 初始化capstone

    md = Cs(CS_ARCH_X86, CS_MODE_64)
    

初始化`capstone`引擎：

*   第一个参数：选择指令架构例如：x86，arm......
*   第二个参数：选择模式，例如：64位，32位，小端序......

##### 反编译代码

    for i in md.disasm(CODE, 0x1000):
        print(f"0x{i.address:x}:\t{i.mnemonic}\t{i.op_str}")
    

使用方法`disasm`反汇编：

*   第一个参数：机器码
*   第二个参数：第一条指令的基地址
*   返回：一个包含指令对象的数组

unicorn
=======

unicorn提供的方法使用也不复杂，但需要一定的内存基础知识。  
下面用一个案例解释。

### 示例

**情景模拟：** 我逆向过程中发现一个xor加密代码，我需要通过模拟执行，对密文进行解密。  
根据汇编代码可以得知：  
`0x20000`存放密文  
`0x30000`存放结果  
`0x10000`中读取密钥key

    from unicorn import *
    from unicorn.x86_const import *
    import struct
    from keystone import *
    
    ASM_CODE = """
        MOV ECX, 5
        MOV ESI, 0x20000
        MOV EDI, 0x30000
        MOV BL, byte ptr [0x10000]
    loop_start:
        LODSB
        XOR AL, BL
        STOSB
        LOOP loop_start
    """
    
    def get_code():
        ks = Ks(KS_ARCH_X86, KS_MODE_32)
        encoding, count = ks.asm(ASM_CODE)
        return bytes(encoding)
    
    CODE = get_code()
    
    ADDRESS_CODE = 0x400000    
    ADDRESS_KEY  = 0x10000      
    ADDRESS_IN   = 0x20000      
    ADDRESS_OUT  = 0x30000      
    REAL_KEY = 0x77            
    
    CIPHER_TEXT = b"\x3F\x12\x1B\x1B\x18"
    
    def hook_code(uc, access, address, size, value, user_data):
        if address == ADDRESS_KEY:
            key_value = uc.mem_read(address, size)
            print(f"key: {hex(key_value[0])}")
    
    def start_emulation():
        try:
            print("初始化环境...")
            mu = Uc(UC_ARCH_X86, UC_MODE_32)
    
            mu.mem_map(0x0, 1 * 1024 * 1024)
            mu.mem_map(ADDRESS_CODE, 2 * 1024 * 1024)
    
            mu.mem_write(ADDRESS_CODE, CODE)
            mu.mem_write(ADDRESS_IN, CIPHER_TEXT)
            mu.mem_write(ADDRESS_KEY, struct.pack("B", REAL_KEY))
    
            mu.hook_add(UC_HOOK_MEM_READ, hook_code)
            
            mu.emu_start(ADDRESS_CODE, ADDRESS_CODE + len(CODE))
    
            decrypted_text = mu.mem_read(ADDRESS_OUT, 5)
            print(f"解密后的文本: {decrypted_text.decode()}")
    
        except UcError as e:
            print(f"模拟错误: {e}")
    
    if __name__ == "__main__":
        start_emulation()
    

### 代码解释

代码流程：  
**初始化环境->分配虚拟内存->写入数据->添加捕获操作->模拟执行指令->读取内存结果**

##### 初始化环境

这个跟上面的`keystone`和`capstone`一样，就不解释了

    mu = Uc(UC_ARCH_X86, UC_MODE_32)
    

##### 分配虚拟内存

第一行是用于存放**堆内存数据**，第二行是用于存放执行的**代码**

    mu.mem_map(0x0, 1 * 1024 * 1024)
    mu.mem_map(ADDRESS_CODE, 2 * 1024 * 1024)
    

`mem_map`用于初始化虚拟内存

*   第一个参数：内存的虚拟地址基址
*   第二个参数：内存的大小

##### 内写入数据

第一行写入代码，第二行写入密文，第三行写入解密key

    mu.mem_write(ADDRESS_CODE, CODE)
    mu.mem_write(ADDRESS_IN, CIPHER_TEXT)
    mu.mem_write(ADDRESS_KEY, struct.pack("B", REAL_KEY))
    

`mem_write`用于写入虚拟内存

*   第一个参数：写入内存的地址
*   第二个参数：写入内存的数据

##### 添加捕获操作

hook用于捕获数据，这里用于捕获key

    def hook_code(uc, access, address, size, value, user_data):
        if address == ADDRESS_KEY:
            key_value = uc.mem_read(address, size)
            print(f"key: {hex(key_value[0])}")
    mu.hook_add(UC_HOOK_MEM_READ, hook_code)
    

`hook_add`添加hook

*   第一个参数：捕获模式，规定什么时候触发hook，例如：读取内存，中断捕获......
*   第二个参数：触发的回调函数，回调函数各个参数如下：

    def hook_code(uc, access, address, size, value, user_data):
    

*   `uc`：模拟器对象
*   `access`：当前访问类型：`UC_MEM_READ`，`UC_MEM_WRITE`......
*   `address`：当前访问的虚拟地址
*   `size`：当前访问数据大小
*   `value`：access为`UC_MEM_WRITE`，则这里为要写入的值
*   `user_data`：用户在`add_hook`时传进去的自定义数据

##### 模拟执行指令

    mu.emu_start(ADDRESS_CODE, ADDRESS_CODE + len(CODE))
    

*   第一个参数：模拟执行的起始地址
*   第二个参数：模拟执行的代码大小

##### 读取内存结果

    decrypted_text = mu.mem_read(ADDRESS_OUT, 5)
    

*   第一个参数：读取内存的地址
*   第二个参数：读取内存的大小