---
layout: post
title: 'å‰ç«¯æ¡†æ¶æ–‡æ¡£æ–°æ€è·¯ï¼šåŸºäºæºç è§£æçš„è‡ªåŠ¨åŒ–æ–¹æ¡ˆ'
date: "2025-10-20T00:44:06Z"
---
å‰ç«¯æ¡†æ¶æ–‡æ¡£æ–°æ€è·¯ï¼šåŸºäºæºç è§£æçš„è‡ªåŠ¨åŒ–æ–¹æ¡ˆ
======================

é¡¹ç›®èƒŒæ™¯
----

æœ€è¿‘æˆ‘ä»¬å›¢é˜Ÿè‡ªç ”äº†ä¸€ä¸ªåŸºäº **React çš„ H5 å‰ç«¯æ¡†æ¶**ï¼Œé¢†å¯¼è®©æˆ‘æ¥è´Ÿè´£ç¼–å†™æ¡†æ¶çš„ä½¿ç”¨æ–‡æ¡£ã€‚æˆ‘é€‰æ‹©äº† **dumi** æ¥æ­å»ºæ–‡æ¡£ç«™ç‚¹ï¼Œå¤§éƒ¨åˆ†å†…å®¹éƒ½æ˜¯æ‰‹åŠ¨å†™ Markdown æ¥ä»‹ç»å„ç§åŠŸèƒ½ï¼ŒåŒ…æ‹¬ï¼š`åˆå§‹åŒ–`ã€`ç›®å½•ç»“æ„`ã€`ç”Ÿå‘½å‘¨æœŸ`ã€`çŠ¶æ€ç®¡ç†`ã€`æ’ä»¶ç³»ç»Ÿ` ç­‰ç­‰ã€‚

æ¡†æ¶é‡Œæœ‰ä¸ª**å¾ˆé‡è¦çš„å­åŒ…**ï¼Œä¸»è¦è´Ÿè´£å¤šä¸ª App çš„æ¡¥æ¥èƒ½åŠ›ï¼Œæ·±åº¦é›†æˆäº†å„ç«¯ç¯å¢ƒçš„ç›‘æµ‹å’Œæ¡¥æ¥é€»è¾‘ã€‚è¿™ä¸ªå­åŒ…å¯¹å¤–æä¾›äº†ä¸€ä¸ª **App å®ä¾‹å¯¹è±¡**ï¼Œé‡Œé¢å°è£…äº†å¾ˆå¤šåŸç”Ÿèƒ½åŠ›ï¼Œæ¯”å¦‚ï¼š **è®¾ç½®å¯¼èˆªæ **ã€**å½•éŸ³**ã€**ä¿å­˜å›¾ç‰‡åˆ°ç›¸å†Œ** ç­‰

è¿™äº› API ä»£ç æ ¼å¼éƒ½æ¯”è¾ƒç»Ÿä¸€ï¼Œé¢†å¯¼å¸Œæœ›é¿å…åœ¨æ¡†æ¶æºç å’Œæ–‡æ¡£é‡Œé‡å¤å®šä¹‰ç›¸åŒçš„æ¥å£ï¼Œæœ€å¥½èƒ½**ç›´æ¥ä»æºä»£ç è‡ªåŠ¨ç”Ÿæˆæ–‡æ¡£å†…å®¹**ã€‚éœ€è¦æå–çš„ä¿¡æ¯åŒ…æ‹¬ï¼šAPIæ”¯æŒçš„Appç‰ˆæœ¬ã€åŠŸèƒ½æè¿°ã€å¼€å‘çŠ¶æ€ã€ä½¿ç”¨æ–¹å¼ï¼Œå¦‚æœæ˜¯å‡½æ•°çš„è¯è¿˜è¦æœ‰å‚æ•°è¯´æ˜å’Œè¿”å›å€¼è¯´æ˜ã€‚

æˆ‘çš„è§£å†³æ–¹æ¡ˆ
------

ç»è¿‡ä¸€ç•ªæ€è€ƒï¼Œæˆ‘æƒ³åˆ°äº†ä¸€ä¸ªæ–¹æ¡ˆï¼š

**æ ¸å¿ƒæ€è·¯**ï¼šåœ¨ä¸æ”¹åŠ¨æºä»£ç é€»è¾‘çš„å‰æä¸‹ï¼Œé€šè¿‡å¢åŠ æ³¨é‡Šä¿¡æ¯æ¥è¡¥å……æ–‡æ¡£éœ€è¦çš„å…ƒæ•°æ®

å…·ä½“å®ç°è·¯å¾„ï¼š

1.  å®šä¹‰ä¸€å¥—è§„èŒƒçš„æ³¨é‡Šæ ‡ç­¾
2.  ç¼–å†™è§£æè„šæœ¬æå–ä¿¡æ¯ï¼Œç”Ÿæˆ JSON æ–‡ä»¶
3.  åœ¨æ–‡æ¡£é¡¹ç›®ä¸­è¯»å– JSONï¼ŒåŠ¨æ€æ¸²æŸ“æˆ API æ–‡æ¡£

å®šä¹‰æ³¨é‡Šè§„èŒƒ
------

æˆ‘å®šä¹‰äº†ä¸€ç³»åˆ—**æ ‡å‡†çš„æ³¨é‡Šæ ‡ç­¾**ï¼š

*   @appVersionÂ â€”â€” æ”¯æŒè¯¥APIçš„Appç‰ˆæœ¬
*   @descriptionÂ â€”â€” APIçš„åŠŸèƒ½æè¿°
*   @apiTypeÂ â€”â€” APIç±»å‹ï¼Œé»˜è®¤æ˜¯å‡½æ•°ï¼Œå¯é€‰propertyï¼ˆå±æ€§ï¼‰å’Œfunctionï¼ˆå‡½æ•°ï¼‰
*   @usageÂ â€”â€” ä½¿ç”¨ç¤ºä¾‹
*   @paramÂ â€”â€” å‡½æ•°å‚æ•°è¯´æ˜ï¼ˆåªæœ‰å‡½æ•°ç±»å‹éœ€è¦ï¼‰
*   @returnsÂ â€”â€” å‡½æ•°è¿”å›å€¼è¯´æ˜ï¼ˆåªæœ‰å‡½æ•°ç±»å‹éœ€è¦ï¼‰
*   @statusÂ â€”â€” å‘å¸ƒçŠ¶æ€

åœ¨å®é™…ä»£ç ä¸­è¿™æ ·ä½¿ç”¨ï¼Œ**å®Œå…¨ä¸ä¼šå½±å“**åŸæ¥çš„ä¸šåŠ¡é€»è¾‘ï¼š

    const app = {
      /**
       * @appVersion 1.0.0
       * @description åˆ¤æ–­è®¾å¤‡ç±»å‹
       * @apiType property
       * @usage app.platform // notInApp | ios | android | HarmonyOS 
       * @status å·²ä¸Šçº¿ 
       */
       platform: getPlatform(),
       
       /**
       * @appVersion 1.0.6 
       * @description æ³¨å†Œäº‹ä»¶ç›‘å¬
       * @param {Object} options - é…ç½®é€‰é¡¹
       * @param {string} options.title - äº‹ä»¶åç§°
       * @param {Function} options.callback - æ³¨å†Œäº‹ä»¶æ—¶çš„å¤„ç†å‡½æ•°é€»è¾‘
       * @param {Function} options.onSuccess - è®¾ç½®æˆåŠŸçš„å›è°ƒå‡½æ•°ï¼ˆå¯é€‰ï¼‰
       * @param {Function} options.onFail - è®¾ç½®å¤±è´¥çš„å›è°ƒå‡½æ•°ï¼ˆå¯é€‰ï¼‰
       * @param {Function} options.onComplete - æ— è®ºæˆåŠŸå¤±è´¥éƒ½ä¼šæ‰§è¡Œçš„å›è°ƒå‡½æ•°ï¼ˆå¯é€‰ï¼‰
       * @usage app.monitor({ eventName: 'onOpenPage', callback: (data)=>{ console.log('ç«¯ä¸Špushæ¶ˆæ¯', data ) } })
       * @returns {String} id - ç»‘å®šäº‹ä»¶çš„id
       * @status å·²ä¸Šçº¿
       */
    	monitor: ({ onSuccess, onFail, onComplete, eventName = "", callback = () => { } }) => {
    		let _id = uuid();
    		// ä¸šåŠ¡ä»£ç çœç•¥
    		return _id;
    	},
    }
    

è§£æè„šæœ¬
----

æ¥ä¸‹æ¥è¦å†™ä¸€ä¸ª**è§£æè„šæœ¬**ï¼ŒæŠŠæ³¨é‡Šå†…å®¹æå–æˆé”®å€¼å¯¹æ ¼å¼ï¼Œä¸»è¦ç”¨**æ­£åˆ™è¡¨è¾¾å¼**æ¥è§£ææ³¨é‡Šï¼š

    const fs = require('fs');
    const path = require('path');
    
    /**
     * è§£æå‚æ•°æˆ–è¿”å›å€¼æ ‡ç­¾
     * @param {string} content - æ ‡ç­¾å†…å®¹
     * @param {string} type - ç±»å‹ ('param' æˆ– 'returns')
     * @returns {Object} è§£æåçš„å‚æ•°æˆ–è¿”å›å€¼å¯¹è±¡
     */
    function parseParamOrReturn(content, type = 'param') {
      const match = content.match(/{([^}]+)}\s+(\w+)(?:\.(\w+))?\s*-?\s*(.*)/);
      if (!match) return null;
    
      const paramType = match[1];
      const parentName = match[2];
      const childName = match[3];
      const description = match[4].trim();
      const isParam = type === 'param';
    
      if (childName) {
        // åµŒå¥—å‚æ•°æˆ–è¿”å›å€¼ (options.title æˆ– data.result æ ¼å¼)
        return {
          name: parentName,
          type: 'Object',
          description: isParam ? `${parentName} é…ç½®å¯¹è±¡` : `${parentName} è¿”å›å¯¹è±¡`,
          required: isParam ? true : undefined,
          children: [{
            name: childName,
            type: paramType,
            description: description,
            required: isParam ? (!paramType.includes('?') && !description.includes('å¯é€‰')) : undefined
          }]
        };
      } else {
        // æ™®é€šå‚æ•°æˆ–è¿”å›å€¼
        return {
          name: parentName,
          type: paramType,
          description: description,
          required: isParam ? (!paramType.includes('?') && !description.includes('å¯é€‰')) : undefined
        };
      }
    }
    
    /**
     * åˆå¹¶åµŒå¥—å¯¹è±¡
     * @param {Array} items - å‚æ•°æˆ–è¿”å›å€¼æ•°ç»„
     * @returns {Array} åˆå¹¶åçš„æ•°ç»„
     */
    function mergeNestedItems(items) {
      const merged = {};
    
      items.forEach(item => {
        if (item.children) {
          // åµŒå¥—å¯¹è±¡
          if (!merged[item.name]) {
            merged[item.name] = { ...item };
          } else {
            // åˆå¹¶å­å…ƒç´ 
            if (!merged[item.name].children) merged[item.name].children = [];
            merged[item.name].children.push(...item.children);
          }
        } else {
          // æ™®é€šå‚æ•°
          if (!merged[item.name]) {
            merged[item.name] = item;
          }
        }
      });
    
      return Object.values(merged);
    }
    
    /**
     * ä¿å­˜æ ‡ç­¾å†…å®¹åˆ°æ³¨è§£å¯¹è±¡
     */
    function saveTagContent(annotation, tag, content) {
      // ç¡®ä¿ parameters å’Œ returns æ•°ç»„å­˜åœ¨
      if (!annotation.parameters) annotation.parameters = [];
      if (!annotation.returns) annotation.returns = [];
    
      switch (tag) {
        case 'appVersion':
          annotation.appVersion = content;
          break;
        case 'sxzVersion':
          annotation.sxzVersion = content;
          break;
        case 'mddVersion':
          annotation.mddVersion = content;
          break;
        case 'description':
          annotation.description = content;
          break;
        case 'status':
          annotation.status = content;
          break;
        case 'usage':
          annotation.usage = content.trim();
          break;
        case 'apiType':
          // è§£æç±»å‹ï¼šproperty æˆ– method
          annotation.type = content.toLowerCase();
          break;
        case 'param':
          const param = parseParamOrReturn(content, 'param');
          if (param) {
            annotation.parameters.push(param);
            // åˆå¹¶åµŒå¥—å¯¹è±¡
            annotation.parameters = mergeNestedItems(annotation.parameters);
          }
          break;
        case 'returns':
          const returnItem = parseParamOrReturn(content, 'returns');
          if (returnItem) {
            annotation.returns.push(returnItem);
            // åˆå¹¶åµŒå¥—å¯¹è±¡
            annotation.returns = mergeNestedItems(annotation.returns);
          }
          break;
      }
    }
    
    /**
     * è§£æ JSDoc æ³¨é‡Šä¸­çš„æ³¨è§£ä¿¡æ¯ - é€è¡Œè§£æ
     */
    function parseJSDocAnnotation(comment) {
      if (!comment) return null;
    
      const annotation = {};
    
      // æŒ‰è¡Œåˆ†å‰²æ³¨é‡Š
      const lines = comment.split('\n');
      
      let currentTag = '';
      let currentContent = '';
    
      for (const line of lines) {
        // æ¸…ç†è¡Œå†…å®¹ï¼Œç§»é™¤ * å’Œé¦–å°¾ç©ºæ ¼ï¼Œä½†ä¿ç•™å†…éƒ¨çš„æ¢è¡Œæ„å›¾
        const cleanLine = line.replace(/^\s*\*\s*/, '').trimRight();
        
        // è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Šå¼€å§‹ç»“æŸæ ‡è®°
        if (!cleanLine || cleanLine === '/' || cleanLine === '*/') continue;
        
        // æ£€æµ‹æ ‡ç­¾å¼€å§‹
        const tagMatch = cleanLine.match(/^@(\w+)\s*(.*)$/);
        if (tagMatch) {
          // ä¿å­˜å‰ä¸€ä¸ªæ ‡ç­¾çš„å†…å®¹
          if (currentTag) {
            saveTagContent(annotation, currentTag, currentContent);
          }
          
          // å¼€å§‹æ–°æ ‡ç­¾
          currentTag = tagMatch[1];
          currentContent = tagMatch[2];
        } else if (currentTag) {
          // ç»§ç»­å½“å‰æ ‡ç­¾çš„å†…å®¹ï¼Œä½†ä¿ç•™æ¢è¡Œ
          // å¯¹äº @usage æ ‡ç­¾ï¼Œæˆ‘ä»¬ä¿ç•™åŸå§‹æ ¼å¼
          if (currentTag === 'usage') {
            currentContent += '\n' + cleanLine;
          } else {
            currentContent += ' ' + cleanLine;
          }
        }
      }
      
      // ä¿å­˜æœ€åä¸€ä¸ªæ ‡ç­¾çš„å†…å®¹
      if (currentTag) {
        saveTagContent(annotation, currentTag, currentContent);
      }
    
      // ç¡®ä¿ parameters å’Œ returns æ•°ç»„å­˜åœ¨ï¼ˆå³ä½¿ä¸ºç©ºï¼‰
      if (!annotation.parameters) annotation.parameters = [];
      if (!annotation.returns) annotation.returns = [];
    
      return Object.keys(annotation).length > 0 ? annotation : null;
    }
    
    /**
     * ä½¿ç”¨ @apiType æ ‡ç­¾æŒ‡å®šç±»å‹
     */
    function extractAnnotationsFromSource(sourceCode) {
      const annotations = { properties: {}, methods: {} };
    
      // ä½¿ç”¨æ›´ç®€å•çš„é€»è¾‘ï¼šæŒ‰è¡Œåˆ†æ
      const lines = sourceCode.split('\n');
    
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
    
        // æ£€æµ‹ JSDoc æ³¨é‡Šå¼€å§‹
        if (line.startsWith('/**')) {
          let jsdocContent = line + '\n';
          let j = i + 1;
    
          // æ”¶é›†å®Œæ•´çš„ JSDoc æ³¨é‡Š
          while (j < lines.length && !lines[j].trim().startsWith('*/')) {
            jsdocContent += lines[j] + '\n';
            j++;
          }
    
          if (j < lines.length) {
            jsdocContent += lines[j] + '\n'; // åŒ…å«ç»“æŸçš„ */
    
            // æŸ¥æ‰¾æ³¨é‡Šåé¢çš„ä»£ç è¡Œ
            for (let k = j + 1; k < lines.length; k++) {
              const codeLine = lines[k].trim();
              if (codeLine && !codeLine.startsWith('//') && !codeLine.startsWith('/*')) {
                // è§£ææ³¨è§£
                const annotation = parseJSDocAnnotation(jsdocContent);
                if (annotation) {
                  // ä»æ³¨è§£ä¸­è·å–ç±»å‹ï¼ˆproperty æˆ– methodï¼‰
                  let itemType = annotation.type;
                  let name = null;
    
                  // å¦‚æœæ²¡æœ‰æ˜ç¡®æŒ‡å®šç±»å‹ï¼Œé»˜è®¤è®¾ä¸º method
                  if (!itemType) {
                    itemType = 'method';
                  }
    
                  // æå–åç§°
                  const nameMatch = codeLine.match(/^(\w+)\s*[:=]/);
                  if (nameMatch) {
                    name = nameMatch[1];
                  } else {
                    // å¦‚æœæ²¡æœ‰åŒ¹é…åˆ°åç§°ï¼Œå°è¯•å…¶ä»–æ¨¡å¼
                    const funcMatch = codeLine.match(/^(?:async\s+)?(\w+)\s*\(/);
                    if (funcMatch) {
                      name = funcMatch[1];
                    }
                  }
    
                  if (name) {
                    if (itemType === 'property') {
                      annotations.properties[name] = annotation;
                    } else if (itemType === 'method') {
                      annotations.methods[name] = annotation;
                    } else {
                      console.warn(`æœªçŸ¥çš„ç±»å‹: ${itemType}ï¼Œåç§°: ${name}`);
                    }
                  } else {
                    console.warn(`æ— æ³•æå–åç§°: ${codeLine.substring(0, 50)}`);
                  }
                }
                break;
              }
            }
    
            i = j; // è·³è¿‡å·²å¤„ç†çš„è¡Œ
          }
        }
      }
    
      return annotations;
    }
    
    /**
     * ä»æ–‡ä»¶æå–æ³¨è§£
     */
    function extractAnnotationsFromFile(filePath) {
      if (!fs.existsSync(filePath)) {
        console.error('æ–‡ä»¶ä¸å­˜åœ¨:', filePath);
        return { properties: {}, methods: {} };
      }
    
      const sourceCode = fs.readFileSync(filePath, 'utf-8');
      return extractAnnotationsFromSource(sourceCode);
    }
    
    /**
     * æå–æ‰€æœ‰æ–‡ä»¶çš„æ³¨è§£
     */
    function extractAllAnnotations(filePaths) {
      const allAnnotations = {};
    
      filePaths.forEach(filePath => {
        if (fs.existsSync(filePath)) {
          const fileName = path.basename(filePath, '.js');
          console.log(`\n=== å¤„ç†æ–‡ä»¶: ${fileName} ===`);
    
          const annotations = extractAnnotationsFromFile(filePath);
    
          if (Object.keys(annotations.properties).length > 0 ||
            Object.keys(annotations.methods).length > 0) {
            allAnnotations[fileName] = {
              fileName,
              ...annotations
            };
          }
        }
      });
    
      return allAnnotations;
    }
    
    module.exports = {
      parseJSDocAnnotation,
      extractAnnotationsFromSource,
      extractAnnotationsFromFile,
      extractAllAnnotations
    };
    

é›†æˆåˆ°æ„å»ºæµç¨‹
-------

ç„¶ååˆ›å»ºä¸€ä¸ªè„šæœ¬ï¼ŒæŒ‡å®šè¦è§£æçš„æºæ–‡ä»¶ï¼ŒæŠŠç”Ÿæˆçš„ JSON æ–‡ä»¶ **è¾“å‡ºåˆ° build** ç›®å½•é‡Œï¼š

    const { extractAllAnnotations } = require('./jsdoc-annotations');
    const fs = require('fs');
    const path = require('path');
    
    /**
     * ä¸»å‡½æ•° - æå–æ³¨è§£å¹¶ç”ŸæˆJSONæ–‡ä»¶
     */
    function main() {
      const filePaths = [
        path.join(process.cwd(), './app.js'),
        path.join(process.cwd(), './xxx.js'),
        path.join(process.cwd(), './yyy.js'),
      ].filter(fs.existsSync);
    
      if (filePaths.length === 0) {
        console.error('æœªæ‰¾åˆ°ä»»ä½•æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„');
        return;
      }
    
      const annotations = extractAllAnnotations(filePaths);
      const outputPath = path.join(process.cwd(), './build/api-annotations.json');
    
      // ä¿å­˜ä¸ºJSONæ–‡ä»¶
      fs.writeFileSync(outputPath, JSON.stringify(annotations, null, 2));
    }
    
    main();
    

åœ¨Â `package.json`Â é‡Œå®šä¹‰æ„å»ºæŒ‡ä»¤ï¼Œç¡®ä¿Â build çš„æ—¶å€™**è‡ªåŠ¨è¿è¡Œè§£æè„šæœ¬**ï¼š

    {
        "scripts": {
          "build:annotations": "node scripts/extract-annotations.js",
          "build": "(cd template/main-app && npm run build) && npm run build:annotations"
      },
    }
    

æ‰§è¡Œæ•ˆæœï¼šè¿è¡ŒÂ `npm run build`Â åï¼Œä¼šç”Ÿæˆç»“æ„åŒ–çš„ JSON æ–‡ä»¶ï¼š

åœ¨æ–‡æ¡£ä¸­å±•ç¤º
------

æ¡†æ¶é¡¹ç›®å’Œæ–‡æ¡£é¡¹ç›®æ˜¯åˆ†å¼€çš„ï¼ŒæŠŠ JSON æ–‡ä»¶ç”Ÿæˆåˆ° build æ–‡ä»¶å¤¹ï¼Œä¸Šä¼ åˆ°æœåŠ¡å™¨åæä¾›å›ºå®šè®¿é—®è·¯å¾„ã€‚

æœ‰äº†ç»“æ„åŒ–çš„ JSON æ•°æ®ï¼Œç”Ÿæˆæ–‡æ¡£é¡µé¢å°±å¾ˆç®€å•äº†ã€‚åœ¨ dumi æ–‡æ¡£é‡Œï¼ŒæŠŠè§£æé€»è¾‘å°è£…æˆç»„ä»¶ï¼š

    ---
    title: xxx
    order: 2
    ---
    
    ```jsx
    /**
     * inline: true
     */
    import JsonToApi from '/components/jsonToApi/index.jsx';
    
    export default () => <JsonToApi type="app" title="xxx" desc="AppåŸç”Ÿ api å¯¹è±¡"/>;
    ```
    

æ¸²æŸ“æ•ˆæœå¦‚å›¾æ‰€ç¤º

åœ¨å°† JSON æ•°æ®è§£æå¹¶æ¸²æŸ“åˆ°é¡µé¢çš„è¿‡ç¨‹ä¸­ï¼Œæœ‰ä¸¤ä¸ª**å…³é”®çš„æŠ€æœ¯ç‚¹**éœ€è¦ç‰¹åˆ«å…³æ³¨ï¼š

**è¦ç‚¹ä¸€ï¼šä¼˜é›…çš„ä»£ç å±•ç¤ºä½“éªŒ**  
ç›´æ¥ä½¿ç”¨Â `dangerouslySetInnerHTML`Â æ¥å‘ˆç°ä»£ç ç‰‡æ®µä¼šå¯¼è‡´é¡µé¢æ ·å¼ç®€é™‹ã€ç¼ºä¹å¯è¯»æ€§ã€‚æˆ‘ä»¬éœ€è¦å€ŸåŠ©ä»£ç é«˜äº®å·¥å…·æ¥æå‡å±•ç¤ºæ•ˆæœï¼ŒåŒæ—¶æ·»åŠ ä¾¿æ·çš„å¤åˆ¶åŠŸèƒ½ï¼Œè®©å¼€å‘è€…èƒ½å¤Ÿè½»æ¾å¤ç”¨ç¤ºä¾‹ä»£ç ã€‚

    import React from 'react';
    import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
    import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';
    
    const CodeBlock = ({
      children,
      language = 'javascript',
      showLineNumbers = true,
      highlightLines = []
    }) => {
    
      const [copied, setCopied] = React.useState(false);
    
      // å¯é çš„å¤åˆ¶æ–¹æ³•
      const copyToClipboard = async (text) => {
        try {
          // æ–¹æ³•1: ä½¿ç”¨ç°ä»£ Clipboard API
          if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(text);
            return true;
          } else {
            // æ–¹æ³•2: ä½¿ç”¨ä¼ ç»Ÿçš„ document.execCommandï¼ˆå…¼å®¹æ€§æ›´å¥½ï¼‰
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
    
            const success = document.execCommand('copy');
            document.body.removeChild(textArea);
            return success;
          }
        } catch (err) {
          console.error('å¤åˆ¶å¤±è´¥:', err);
          // æ–¹æ³•3: å¤‡ç”¨æ–¹æ¡ˆ - æç¤ºç”¨æˆ·æ‰‹åŠ¨å¤åˆ¶
          prompt('è¯·æ‰‹åŠ¨å¤åˆ¶ä»¥ä¸‹ä»£ç :', text);
          return false;
        }
      };
    
      const handleCopy = async () => {
        const text = String(children).replace(/\n$/, '');
        const success = await copyToClipboard(text);
    
        if (success) {
          setCopied(true);
          setTimeout(() => setCopied(false), 2000);
        }
      };
    
      return (
        <div className="code-container" style={{ position: 'relative', margin: '20px 0' }}>
          {/* è¯­è¨€æ ‡ç­¾ */}
          <div style={{
            background: '#1e1e1e',
            color: '#fff',
            padding: '8px 16px',
            borderTopLeftRadius: '8px',
            borderTopRightRadius: '8px',
            borderBottom: '1px solid #333',
            fontSize: '12px',
            fontFamily: 'monospace',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center'
          }}>
            <span>{language}</span>
            <button
              onClick={handleCopy}
              style={{
                position: 'absolute',
                top: '8px',
                right: '8px',
                background: copied ? '#52c41a' : '#333',
                color: 'white',
                border: 'none',
                padding: '4px 8px',
                borderRadius: '4px',
                fontSize: '12px',
                cursor: 'pointer',
                zIndex: 10,
                transition: 'all 0.3s'
              }}
            >
              {copied ? 'âœ… å·²å¤åˆ¶' : 'ğŸ“‹ å¤åˆ¶'}
            </button>
          </div>
    
          {/* ä»£ç åŒºåŸŸ */}
          <SyntaxHighlighter
            language={language}
            style={vscDarkPlus}
            showLineNumbers={showLineNumbers}
            wrapLines={true}
            lineProps={(lineNumber) => ({
              style: {
                backgroundColor: highlightLines.includes(lineNumber)
                  ? 'rgba(255,255,255,0.1)'
                  : 'transparent',
                padding: '2px 0'
              }
            })}
            customStyle={{
              margin: 0,
              borderTopLeftRadius: 0,
              borderTopRightRadius: 0,
              borderBottomLeftRadius: '8px',
              borderBottomRightRadius: '8px',
              padding: '16px',
              fontSize: '14px',
              lineHeight: '1.5',
              background: '#1e1e1e',
              border: 'none',
              borderTop: 'none'
            }}
            codeTagProps={{
              style: {
                fontFamily: '"Fira Code", "Monaco", "Consolas", "Courier New", monospace',
                fontSize: '14px'
              }
            }}
          >
            {String(children).replace(/\n$/, '')}
          </SyntaxHighlighter>
        </div>
      );
    };
    
    export default CodeBlock;
    

**è¦ç‚¹äºŒï¼šé”šç‚¹å¯¼èˆªæ–¹æ¡ˆ**  
ç”±äºæˆ‘ä»¬æ˜¯é€šè¿‡ç»„ä»¶æ–¹å¼åŠ¨æ€æ¸²æŸ“å†…å®¹ï¼Œæ— æ³•ç›´æ¥ä½¿ç”¨ dumi å†…ç½®çš„é”šç‚¹å¯¼èˆªåŠŸèƒ½ã€‚è¿™å°±éœ€è¦æˆ‘ä»¬è‡ªä¸»å®ç°ä¸€å¥—å¯¼èˆªç³»ç»Ÿï¼Œå¹¶ç¡®ä¿å…¶åœ¨ä¸åŒå±å¹•å°ºå¯¸ä¸‹éƒ½èƒ½ä¿æŒè‰¯å¥½çš„å¯ç”¨æ€§ï¼Œé¿å…å‡ºç°å¸ƒå±€é”™ä¹±çš„é—®é¢˜ã€‚

    import React, { useEffect, useRef } from 'react';
    import { Anchor } from 'antd';
    export default function readJson(props){
    
      const anchorRef = useRef(null);
      const anchorWrapperRef = useRef(null);
      
      useEffect(() => {
      // ä½¿ç”¨æ›´é•¿çš„å»¶è¿Ÿç¡®ä¿ DOM å®Œå…¨æ¸²æŸ“
      const timer = setTimeout(() => {
        const contentElement = document.querySelector('.dumi-default-content');
        const anchorElement = anchorRef.current;
        
        if (!contentElement || !anchorElement) return;
    
        // åˆ›å»ºé”šç‚¹å®¹å™¨
        const anchorWrapper = document.createElement('div');
        anchorWrapper.className = 'custom-anchor-wrapper';
        Object.assign(anchorWrapper.style, {
          position: 'sticky',
          top: '106px',
          width: '184px',
          marginInlineStart: '24px',
          maxHeight: '80vh',
          overflow: 'auto',
          overscrollBehavior: 'contain'
        });
    
        // æ’å…¥åˆ°å†…å®¹å…ƒç´ åé¢
        if (contentElement.nextSibling) {
          contentElement.parentNode.insertBefore(anchorWrapper, contentElement.nextSibling);
        } else {
          contentElement.parentNode.appendChild(anchorWrapper);
        }
    
        // ç§»åŠ¨é”šç‚¹
        anchorWrapper.appendChild(anchorElement);
        
        // è®°å½•é”šç‚¹å®¹å™¨ï¼Œç”¨äºæ¸…ç†
        anchorWrapperRef.current = anchorWrapper;
      }, 500); // 500ms å»¶è¿Ÿï¼Œç¡®ä¿ DOM å®Œå…¨æ¸²æŸ“
    
      return <div ref={anchorRef}>
          <Anchor
            targetOffset={80}
            items={[
              {
                key: 'properties',
                href: '#properties',
                title: 'å±æ€§',
                children: Object.keys(properties).map(item => ({
                  key: item,
                  href: `#${item}`,
                  title: item
                }))
              },
              {
                key: 'methods',
                href: '#methods',
                title: 'æ–¹æ³•',
                children: Object.keys(methods).map(item => ({
                  key: item,
                  href: `#${item}`,
                  title: item
                }))
              }
            ]}
          />
        </div>
    }
    

å½“ç„¶ï¼Œåœ¨é¡µé¢åŠŸèƒ½ä¸Šæˆ‘ä»¬è¿˜å¯ä»¥è¿›ä¸€æ­¥ä¸°å¯Œï¼Œæ¯”å¦‚å¢åŠ å®ç”¨çš„**ç­›é€‰**åŠŸèƒ½ã€‚æ¯”å¦‚å¿«é€ŸæŸ¥çœ‹**ç‰¹å®š App ç‰ˆæœ¬**æ”¯æŒçš„ APIã€ç­›é€‰"å·²ä¸Šçº¿"ã€"å¼€å‘ä¸­"æˆ–"å·²åºŸå¼ƒ"çš„æ¥å£ï¼Œè¿™äº›ç­›é€‰èƒ½åŠ›è®©æ–‡æ¡£ä¸å†æ˜¯é™æ€çš„å‚è€ƒæ‰‹å†Œï¼Œè€Œå˜æˆäº†ä¸€ä¸ªAPI **æ¢ç´¢å·¥å…·**ï¼Œæœ€ç»ˆå‘ˆç°æ•ˆæœå¦‚ä¸‹ï¼š

é€šè¿‡è¿™å¥—**è‡ªåŠ¨åŒ–æ–‡æ¡£æ–¹æ¡ˆ**ï¼Œæˆ‘ä»¬å®ç°äº†**ä»£ç å’Œæ–‡æ¡£çš„å®æ—¶åŒæ­¥**ï¼Œå¤§å¤§å‡å°‘äº†ç»´æŠ¤æˆæœ¬ï¼ŒåŒæ—¶ç»™å¼€å‘è€…æä¾›äº†å‡ºè‰²çš„ä½¿ç”¨ä½“éªŒã€‚ç°åœ¨å¼€å‘åŒå­¦åªéœ€è¦åœ¨ä»£ç é‡Œå†™å¥½æ³¨é‡Šï¼Œæ–‡æ¡£å°±ä¼šè‡ªåŠ¨æ›´æ–°ï¼Œ**å†ä¹Ÿä¸ç”¨æ‹…å¿ƒæ–‡æ¡£è½åäºä»£ç äº†**ã€‚

**å¦‚æœä½ å¯¹å‰ç«¯å·¥ç¨‹åŒ–æœ‰å…´è¶£ï¼Œæˆ–è€…æƒ³äº†è§£æ›´å¤šå‰ç«¯ç›¸å…³çš„å†…å®¹ï¼Œæ¬¢è¿æŸ¥çœ‹æˆ‘çš„å…¶ä»–æ–‡ç« ï¼Œè¿™äº›å†…å®¹å°†æŒç»­æ›´æ–°ï¼Œå¸Œæœ›èƒ½ç»™ä½ å¸¦æ¥æ›´å¤šçš„çµæ„Ÿå’ŒæŠ€æœ¯åˆ†äº«~**