---
layout: post
title: 'AI辅助编程下的软件分层设计：让生成的代码井然有序'
date: "2025-11-05T00:43:26Z"
---
AI辅助编程下的软件分层设计：让生成的代码井然有序
=========================

在人工智能（`AI`）辅助编程日益普及的今天，我们编码的方式正在经历一场前所未有的变革。

AI 工具如 QWenCoder，TreaCN等，能够帮助我们快速生成代码，极大地提升了开发效率。

然而，这也带来了一个新的挑战：

如何确保 AI 生成的代码能够遵循我们精心设计的软件架构，特别是在中小型软件项目中？

如何让AI成为我们的得力伙伴，而不是混乱的制造者？

接下来，咱们一起来看看在AI辅助编程的时候，怎么才能把软件分层设计做得又快又好。

不管是对AI编程充满好奇的新手朋友，还是想提升团队协作效率的老手，希望都能对你有些帮助。

1\. 什么时候需要分层设计
==============

如果你只是写个临时用的小工具或者脚本，用完即扔，那么，**完全不需要**考虑分层设计。

在下面的情况下，我们才需要先考虑分层设计，再去实现代码：

*   **追求模块化和可维护性**：当你希望系统的不同部分可以独立开发、测试和维护时，分层架构是你的不二之选。
*   **需要良好的可扩展性**：随着业务的发展，系统需要不断迭代和扩展。分层架构的松耦合特性使得在不重构整个系统的情况下，添加新功能或替换某一层级的技术实现变得更加容易。
*   **中小型项目或快速迭代**：对于规模不大，追求开发效率的项目，分层架构因其简单明了，易于理解和上手，同样是一个不错的选择。

比如，以我比较熟悉的`python`语言为例，如果要做一个**命令行工具**（不需要连接数据库），大致结构如下：

    your_tool_name/               # 项目根目录 (Project Root)
    ├── docs/                     # 项目文档
    ├── src/                      # 源代码目录 (推荐) 或 your_tool_name/
    │   └── your_tool_name/       # 主包目录 (Main Package)
    │       ├── __init__.py       # 标识这是一个包，并可定义`__version__`
    │       ├── cli.py            # 命令行接口入口点，组织命令组
    │       ├── commands/         # 子命令模块（可选，复杂工具适用）
    │       │   ├── __init__.py
    │       │   ├── command_a.py
    │       │   └── command_b.py
    │       ├── core/             # 核心业务逻辑
    │       │   ├── __init__.py
    │       │   └── logic.py
    │       └── utils/            # 公共辅助函数
    │           ├── __init__.py
    │           ├── file_io.py
    │           └── helpers.py
    ├── tests/                    # 单元测试目录
    │   ├── __init__.py
    │   ├── test_core.py
    │   └── test_commands.py
    ├── scripts/                  # 辅助脚本（如部署脚本）
    ├── .gitignore                # Git忽略文件规则
    ├── LICENSE                   # 开源许可证
    ├── README.md                 # 项目说明文档
    ├── requirements.txt          # 项目依赖列表
    ├── requirements-dev.txt      # 开发环境额外依赖（可选）
    ├── pyproject.toml           # 现代项目配置和依赖管理（推荐）
    └── setup.py                 # 传统打包配置（如果使用pyproject.toml可省略）
    

如果我想做一个略微复杂一些的`Web`项目（基于`Python`的`FastAPI`框架），大致结构可以如下：

    your_fastapi_project/                 # 项目根目录
    ├── app/                             # 应用主目录 (核心包)
    │   ├── __init__.py                 # 标识为Python包
    │   ├── main.py                     # FastAPI应用创建和启动入口（ASGI服务器入口）
    │   ├── core/                       # 核心配置与基础设施
    │   │   ├── __init__.py
    │   │   ├── config.py               # 应用配置（使用Pydantic读取环境变量）
    │   │   ├── dependencies.py         # 全局依赖注入（如数据库会话）
    │   │   ├── exceptions.py           # 全局异常处理器
    │   │   ├── middlewares.py          # 全局中间件（如CORS、日志）
    │   │   └── security.py             # 安全相关（如密码哈希、JWT令牌创建验证）
    │   ├── api/                        # API层（路由层/表现层）
    │   │   ├── __init__.py
    │   │   └── v1/                     # API版本v1（支持多版本共存）
    │   │       ├── __init__.py
    │   │       ├── endpoints/          # 端点模块（按业务模块拆分路由文件）
    │   │       │   ├── __init__.py
    │   │       │   ├── users.py        # 用户相关路由（如 /users/）
    │   │       │   ├── items.py        # 物品相关路由（如 /items/）
    │   │       │   └── ...             # 其他业务模块路由
    │   │       └── router.py           # v1版本路由汇总（聚合所有endpoints中的路由）
    │   ├── models/                     # 数据模型（ORM模型，如使用SQLAlchemy）
    │   │   ├── __init__.py
    │   │   ├── base.py                 # 模型基类（如包含id, create_time的基类）
    │   │   ├── user.py                 # 用户数据模型
    │   │   ├── item.py                 # 物品数据模型
    │   │   └── ...
    │   ├── schemas/                    # Pydantic模式（数据验证与序列化）
    │   │   ├── __init__.py
    │   │   ├── base.py                 # 基础Schema（如分页响应基类）
    │   │   ├── user.py                 # 用户相关的请求/响应模式（如UserCreate, UserResponse）
    │   │   ├── item.py                 # 物品相关的请求/响应模式
    │   │   └── ...
    │   ├── crud/                       # 数据操作层（基础的增删改查操作）
    │   │   ├── __init__.py
    │   │   ├── base.py                 # 基础CRUD类（通用操作）
    │   │   ├── crud_user.py            # 用户数据操作
    │   │   ├── crud_item.py            # 物品数据操作
    │   │   └── ...
    │   ├── services/                   # 业务逻辑层（封装复杂业务规则，可跨CRUD操作）
    │   │   ├── __init__.py
    │   │   ├── user_service.py         # 用户相关业务逻辑（如注册、登录流程）
    │   │   ├── item_service.py         # 物品相关业务逻辑
    │   │   └── ...
    │   ├── db/                         # 数据库相关
    │   │   ├── __init__.py
    │   │   ├── session.py              # 数据库会话管理（如创建engine、SessionLocal）
    │   │   └── base.py                 # 数据库基础（如Declarative Base）
    │   └── utils/                      # 通用工具函数
    │       ├── __init__.py
    │       ├── helpers.py              # 通用辅助函数
    │       └── ...
    ├── tests/                          # 测试目录
    │   ├── __init__.py
    │   ├── conftest.py                 # pytest配置，定义测试夹具（fixtures）
    │   ├── test_api/                   # API接口测试
    │   │   ├── test_users.py
    │   │   ├── test_items.py
    │   │   └── ...
    │   └── test_services/              # 业务逻辑测试
    │       ├── test_user_service.py
    │       └── ...
    ├── migrations/                     # 数据库迁移脚本（如使用Alembic）
    │   ├── versions/                   # 存放迁移版本文件
    │   ├── alembic.ini                 # Alembic配置文件
    │   └── env.py                      # Alembic环境脚本
    ├── static/                         # 静态文件（CSS, JS, Images等）
    ├── templates/                      # 模板文件（如使用Jinja2）
    ├── requirements.txt                # 项目Python依赖列表
    ├── .env                            # 环境变量文件（本地开发，不应提交至Git）
    ├── .env.example                    # 环境变量示例文件（列出所需变量名和格式说明）
    ├── Dockerfile                      # Docker镜像构建文件
    ├── docker-compose.yml              # Docker编排配置（可选）
    └── README.md                       # 项目说明文档
    

2\. 如何让 AI 生成的代码乖乖“分层”？
=======================

**“AI 并不知道你的架构”**，这是一个在 AI 编程时代需要牢记的箴言。

AI 工具生成的代码可能在功能上是正确的，但往往会忽略更广泛的架构模式和设计原则。为了让 AI 成为我们架构的“好帮手”而非“破坏者”，我们需要掌握一些技巧。

2.1. 始于意图，而非代码
--------------

在要求 AI 生成代码之前，先明确意图。

不要直接说“给我写一个用户注册功能”，而是要提供更具体的上下文和边界。

比如，我们可以这样描述：

> “我正在构建一个采用三层架构的电商应用。请为我生成用户注册功能的业务逻辑层代码。这一层需要接收来自表现层的用户数据（用户名、密码、邮箱），进行数据验证，然后调用数据访问层的方法将用户信息存入数据库。注意，不要在业务逻辑层直接编写数据库操作的代码。”

通过清晰地定义代码应该做什么、它所处的上下文以及必须遵守的边界，可以极大地提高 AI 生成代码的准确性和合规性。

2.2. 为 AI 提供充足的“上下文”
--------------------

AI 的记忆力是有限的，它不会像人类一样记住项目的整个架构。

因此，在每次交互中提供必要的上下文至关重要。

就好比将AI当成一位新来的同事，你需要不断地向他同步项目的背景信息。

我们可以通过以下方式来提供上下文：

*   描述你的技术栈、文件夹结构和命名规范。
*   引用包含共享决策的文档，例如 Markdown 文件。
*   在多个提示中复用上下文信息块。

这些内容可以整理成文档，方便代码生成中反复使用。

2.3. 像开发者一样思考，增量构建
------------------

不要指望 AI 一次性为你生成完美的、符合所有架构要求的复杂功能。

更好的方式是像一个经验丰富的开发者那样，将大任务分解成小的、可管理的部分，然后逐步构建和验证。

例如，在开发一个功能时，我们可以：

1.  先让 AI 生成数据访问层的接口和实现
2.  然后是业务逻辑层的服务
3.  最后是表现层的控制器或视图

每一步都进行审查和必要的调整，确保其符合分层原则。

3\. 如何让AI“学习”并理解我们的分层结构？
========================

让 AI 理解我们的软件架构，是确保其生成合规代码的关键。

虽然目前的 AI 还不能完全像人类架构师那样进行高层次的思考和决策，但我们可以通过一些方法，让它成为一个更懂架构的“队友”。

1.  **架构决策记录**：这是记录重要架构决策背后原因的文档。将这些文档提供给 AI，可以让它理解你为什么做出某些设计选择，从而生成更符合意图的代码。
2.  “**活”的文档和代码示例**：将文档与代码放在一起，并保持同步更新。同时，提供清晰的代码示例，展示实现特定任务的“正确方式”。比如，我们甚至可以为AI提供一个遵循分层设计原则的完整功能的代码范例。
3.  **架构定义语言（**`**Architecture Definition Language, ADL**`**）**：对于更复杂的系统，可以考虑使用轻量级的 `ADL` 来描述你的架构。这种方式可以用伪代码的形式定义系统的结构和约束，然后将 ADL 作为提示提供给 AI，让它生成符合架构定义的代码。

4\. 总结
======

总之，在 AI 辅助编程的新时代，软件架构师和开发者的角色正在发生转变。

我们不再是代码的唯一创作者，而是与 AI 协作，共同构建高质量软件的**“指挥家”**。

通过清晰地定义分层架构的边界、为 AI 提供充足的上下文、并利用 AI 工具进行实时的架构审查和监督，我们完全有能力驾驭 AI 的强大力量，同时确保我们软件的结构完整性和长期可维护性。

记住，AI 是一个强大的工具，但最终的架构决策和质量把控，仍然掌握在我们自己的手中。