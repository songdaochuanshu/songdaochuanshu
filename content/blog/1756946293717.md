---
layout: post
title: '【URP】[Unity核心Buffer及其应用]'
date: "2025-09-04T00:38:13Z"
---
【URP】\[Unity核心Buffer及其应用\]
==========================

![【URP】[Unity核心Buffer及其应用]](https://img2024.cnblogs.com/blog/3685400/202509/3685400-20250904000157493-918355285.png) 本文介绍了Unity URP渲染管线中的核心Buffer类型及其应用。主要包括常量缓冲区(存储全局数据)、模板缓冲区(控制渲染区域)、深度缓冲区(管理物体遮挡)和帧缓冲区(存储最终输出)。文章详细说明了各类缓冲区的功能特点、实现方式及优化策略，如常量缓冲区减少数据传输、模板缓冲区实现特效、深度缓冲区优化半透明渲染等。同时提供了具体代码示例和性能优化建议，如分层管理、缓冲区复用等技巧，帮助开发者更好地掌握URP渲染技术，提升游戏渲染效率和质量。

> [【从UnityURP开始探索游戏渲染】](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**专栏-直达**

**‌一、核心 Buffer 类型及用途‌**
=======================

‌常量缓冲区（Constant Buffer）
-----------------------

### ‌**功能**‌

*   存储渲染过程中不变的全局数据（如变换矩阵、光照参数、材质属性）。

### **实现类**‌

*   通过`Shader.SetGlobal`系列方法或`MaterialPropertyBlock`间接管理，底层由`UnityEngine.Rendering.CommandBuffer`控制

### ‌**脚本位置**‌

*   数据注入通常在`ScriptableRenderPass`或`MonoBehaviour`脚本中完成（如`Camera.main.SetGlobalMatrix`）

### ‌**应用位置**‌

*   用于避免每帧重复传输数据，提升 SRP 合批效率。
    
        hlsl
        CBUFFER_START(UnityPerMaterial)
        float4 _Color; // 材质属性
        float4x4 _WorldToCamera; // 视图矩阵
        CBUFFER_END
        
    

### **常量缓冲区更新**‌

    csharp
    // CPU注入数据（如每帧更新VP矩阵）
    Shader.SetGlobalMatrix("_CameraViewProjection", camera.projectionMatrix * camera.worldToCameraMatrix);
    

*   GPU在着色器中通过`CBUFFER_START(UnityPerCamera)`读取

‌模板缓冲区（Stencil Buffer）
----------------------

### ‌**功能**‌

*   通过像素级掩码规则控制渲染区域（如轮廓光、UI 遮罩）。

### **实现类**‌

*   `UnityEngine.Rendering.Universal.RenderTargetHandle`，通过`CreateDepthTexture`和`ConfigureTarget`配置

### ‌**脚本位置**‌

*   URP的`ForwardRendererAsset`配置文件中定义，运行时由`ScriptableRenderer`管理

### ‌**应用逻辑**‌：

*   设置模板规则（如 `Stencil{ Ref 1 Comp Equal }` 仅渲染标记为 1 的区域）
*   用于角色描边、镜子反射等特效。

### 模板缓冲区控制

    hlsl
    Stencil {
        Ref 2
        Comp Equal
        Pass Keep
    } // 仅渲染模板值为2的像素
    

*   由URP的`RenderObjects`特性在`Execute`阶段触发写入

深度缓冲区（Depth Buffer）
-------------------

### ‌**功能**‌

*   存储像素深度值，管理物体前后遮挡关系（默认开启 ZWrite）。

### ‌**优化场景**‌

*   半透明物体关闭 ZWrite 避免深度冲突，如粒子特效。

### **深度缓冲区复用**

    csharp
    // URP Renderer Feature中配置深度纹理
    renderingData.cameraData.requiresDepthTexture = true;
    

*   后处理通过`_CameraDepthTexture`采样深度值

‌帧缓冲区（Frame Buffer）
-------------------

### ‌**功能**‌

*   存储最终渲染输出，支持多渲染目标（MRT）用于后处理。

### **实现类**‌

*   逻辑概念，实际由`RenderTexture`和`Camera.targetTexture`组合实现

### ‌**脚本位置**‌

*   URP渲染管线核心逻辑位于`UniversalRenderPipeline.cs`

### ‌**URP 配置**‌：

    csharp
    // URP Renderer Feature 中配置
    ConfigureCameraTarget(BufferA, BufferB);// 双缓冲区实现运动模糊
    

**‌二、关键应用场景‌**
==============

‌**GraphicsBuffer**‌
--------------------

*   动态地形裁剪时预加载包围盒顶点数据到显存，减少 CPU-GPU 传输。

‌**常量缓冲区**‌
-----------

*   SRP 合批中合并材质属性，降低 Draw Call（如静态场景批量渲染）。

‌**模板缓冲区**‌
-----------

*   通过 `RenderObjects` 特性为特定层级（如“Outline”）启用模板测试。

‌**深度缓冲区**‌
-----------

*   在 Renderer Feature 中访问 `_CameraDepthTexture` 实现屏幕空间阴影。

**‌三、性能优化原则‌**
==============

‌**减少传输**‌
----------

*   静态数据用 `GraphicsBuffer` 一次性上传，动态数据增量更新。

‌**分层管理**‌
----------

*   通过 `Camera.cullingMask` 剔除无关层级，结合距离裁剪降低负载。

‌**缓冲区复用**‌
-----------

*   在 URP Renderer Feature 中共享 `_CameraColorTexture` 避免重复创建

**常量缓冲区**‌
----------

*   单帧内避免频繁更新，合并相关变量到同一`CBUFFER`

**模板/深度**‌
----------

*   通过`Camera.main.depthTextureMode`控制生成策略

**帧缓冲区**‌
---------

*   使用`RenderTexture.GetTemporary`动态分配避免内存泄漏

* * *

> [【从UnityURP开始探索游戏渲染】](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**专栏-直达**

（欢迎_点赞留言_探讨，更多人加入进来能更加完善这个探索的过程，🙏）