---
layout: post
title: '告别 Laravel 缓慢的 Blade！Livewire Blaze 来了，为你的 Laravel 性能提速'
date: "2026-02-27T00:57:23Z"
---
告别 Laravel 缓慢的 Blade！Livewire Blaze 来了，为你的 Laravel 性能提速
=======================================================

你已经优化了查询，加了缓存层，该做的都做了——但页面加载时总觉得哪里不对劲。那种说不清道不明的轻微延迟？问题很可能不在数据库，而在你的 Blade 组件。

好消息是：Livewire 团队刚刚发布了 Laravel 社区期待已久的解决方案 —— Blaze。

Blaze 是什么？
----------

Blaze 是一个 Laravel 包，目标明确：通过编译时优化让 Blade 组件渲染速度大幅提升。它不再在每次请求时都重新评估静态组件，而是在编译阶段就预渲染好 —— 等用户访问页面时，繁重的计算工作早已完成。

他们用数据证明了这一点：

渲染 25,000 个可折叠按钮组件：

*   **未使用 Blaze**：████████████████████████████████████████ 750ms
*   **使用 Blaze**：██ 45ms

约 **17 倍**更快。这不是笔误。

Blade 为什么会变慢？
-------------

每次你调用 `<x-button>`、`<x-card>` 或任何 Blade 组件，Laravel 都要走一遍流程：解析模板、评估属性、执行 PHP 逻辑、输出 HTML。做一两次没问题。但想象一下，一个仪表盘页面有几百行表格数据、一个带 80 个选项的多选下拉框、或者每个卡片上都散布着图标 —— 这些组件每次请求都要从头处理一遍。

这正是 Blaze 要消除的开销。

安装 —— 两分钟上手
-----------

开始只需要一条命令：

    composer require livewire/blaze:^1.0
    

Blaze 的工作原理 —— 三级优化策略
---------------------

Blaze 没有采用一刀切的方案，而是提供了三种不同的优化策略，你可以根据需要选择。

### 优化编译器（默认）

这是基础策略。Blaze 用一个更高效的编译器替换 Blade 默认的编译器，把你的模板编译成更精简的 PHP 函数。不需要额外配置 —— 装完就能受益。根据文档，仅这一项就能为符合条件的组件减少高达 97% 的渲染开销。

### 记忆化（可选）

适合那些用相同属性反复出现的组件 —— 比如图标、头像缩略图、状态徽章或标签碎片。Blaze 第一次渲染时缓存输出结果，之后每次用相同属性调用时都直接复用。不用重新渲染，不用重复计算。

### 编译时折叠（可选）

这是最强力的策略。不是在运行时渲染，Blaze 在 Blade 编译阶段就把组件预渲染成纯静态 HTML。等应用真正运行时，这些组件在某种意义上已经"不存在"了 —— 它们早已被解析完毕。零运行时成本。

@blaze 指令 —— 比你想象的简单
--------------------

要在组件上启用优化，只需在模板文件顶部加上 `@blaze`：

    {{-- resources/views/components/button.blade.php --}}
    
    @blaze
    @props(['variant' => 'primary'])
    
    <button type="button" class="btn btn-{{ $variant }}">
        {{ $slot }}
    </button>
    

如果你想精细控制启用哪些策略：

    {{-- 启用全部（等同于只写 @blaze） --}}
    @blaze(fold: true, memo: true, aware: true)
    
    {{-- 跳过折叠，但保留记忆化 --}}
    @blaze(fold: false, memo: true, aware: false)
    

想一次性优化整个目录而不动单个文件？也可以：

    Blaze::optimize()
        ->in(resource_path('views/components/app'))
        ->in(resource_path('views/components/admin'));
    

什么时候该用 @blaze？
--------------

这是真正关键的部分。不是所有组件都适合加 `@blaze` —— 用错了地方可能导致难以追踪的隐蔽 Bug。

Blaze 提供了一个简单的判断标准。问自己这几个问题：

*   对每个用户渲染结果都一样吗？（不用 `auth()`，不用按用户区分的数据）
*   每次请求渲染结果都一样吗？（不用 CSRF 令牌，不用 `request()->is()`）
*   任何时间点渲染结果都一样吗？（不用 `now()`，不用相对时间戳）
*   只使用你显式传入的属性吗？（不用 session 数据，不查数据库）
*   它渲染的所有子组件也满足上述条件吗？

全部符合 → 加 `@blaze`。有任何一条不符合 → 跳过。

一个简单的判断思路：如果你能把组件丢进设计系统或 Storybook 里、不需要任何应用上下文就能正确渲染，那它就是合适的候选。按钮、卡片、徽章、图标、布局网格 —— 这些是最佳场景。

以下情况**绝对不要**用 `@blaze`：

    {{-- ❌ CSRF 令牌每次请求都变 --}}
    <form method="POST">
        @csrf
        <button type="submit">Submit</button>
    </form>
    
    {{-- ❌ 认证状态是用户特定的 --}}
    @auth
        <p>Welcome back!</p>
    @endauth
    
    {{-- ❌ Session 数据是动态的 --}}
    <div>Hello, {{ session('username') }}</div>
    
    {{-- ❌ 激活链接状态依赖请求 --}}
    @props(['href'])
    
    <a href="{{ $href }}" @class(['active' => request()->is($href)])>
        {{ $slot }}
    </a>
    

聪明的逃生舱：@unblaze
---------------

你可能会遇到这种场景：一个表单输入组件几乎完全是静态的 —— 唯独需要显示验证错误信息。这些错误来自请求，意味着整个组件没法折叠，对吧？

这就是 `@unblaze` 的用武之地。你可以在静态组件里"打洞"，让特定区块保持运行时评估，同时保留周围所有标记的优化：

    {{-- ✅ 表单输入配合 @unblaze 处理错误信息 --}}
    
    @blaze
    
    @props(['name', 'label'])
    
    <div>
        <label>{{ $label }}</label>
        <input type="text" name="{{ $name }}">
        @unblaze
            @if($errors->has($name))
                <span class="text-red-500">{{ $errors->first($name) }}</span>
            @endif
        @endunblaze
    </div>
    

底层实现上：`<div>`、`<label>` 和 `<input>` 在编译时被折叠成静态 HTML。`@unblaze` 区块保持动态。鱼与熊掌 —— 优化和功能兼得。

需要把组件属性传进 `@unblaze` 区块？用 `scope` 参数：

    @blaze
    
    @props(['userId', 'showStatus' => true])
    
    <div>
        {{-- 这里是一大段静态标记 --}}
        @unblaze(scope: ['userId' => $userId, 'showStatus' => $showStatus])
            @if($scope['showStatus'])
                <div>User #{{ $scope['userId'] }} - Last seen: {{ session('last_seen') }}</div>
            @endif
        @endunblaze
    </div>
    

你也可以在一个组件里放多个 `@unblaze` 区块 —— 每个都创建一个独立的动态区域，其余部分保持折叠。

内置分析器 —— 快速定位瓶颈
---------------

Blaze 的一个亮点是内置分析器。不用猜哪个组件拖慢了性能，你能直接拿到火焰图、逐组件耗时和策略分解 —— 开箱即用。

一行代码开启：

    Blaze::debug();
    

这在给应用做优化前后审计时特别有用，或者当你想知道为什么某个特定组件没有被折叠时。

Flux 用户的福音
----------

如果你已经在用 Flux（Livewire 团队出品的 UI 组件库），这基本就是白捡的优化。所有符合条件的 Flux 组件已经标注了 `@blaze` —— 所以你一装上 Blaze，一切就自动开始工作，无需额外配置。

实际的性能预期
-------

那个 17 倍的基准测试是真实的，但要说明背景：那是用 25,000 个完全相同的可折叠组件一次性渲染测出来的。真实应用里，你不太可能遇到这种场景。

根据官方文档，更现实的预期是：

*   **普通页面**（几百个组件）：提升 10–30ms
*   **组件密集型页面**（数据表格、大型下拉框、重复的卡片网格）：提升 50–100ms 以上

听起来可能不夸张，但如果你当前渲染时间是 300ms，降到 240ms，那就是 20% 的提升 —— 乘以每天每个用户的每次请求，累积起来很可观。

小结
--

Blaze 不是万能药 —— 它也没想做成万能药。它是一个专注、设计精良的工具，解决了很多 Laravel 应用在成长过程中默默遇到的特定问题。

它值得尝试的地方在于：对你的要求极低。不用重写模板，不用大规模重构，不用配置负担。如果某个组件无法优化，Blaze 会优雅地回退到正常渲染并继续。它只管干活。

如果你在用 Laravel 构建有大量可复用 UI 组件的应用 —— 尤其是什么设计系统之类的东西 —— Blaze 今天就可以加入你的工具箱。

[告别 Laravel 缓慢的 Blade！Livewire Blaze 来了，为你的 Laravel 性能提速](https://catchadmin.com/post/2026-02/livewire-blaze)