---
layout: post
title: '别再混淆 PHP8.1 中纤程 Fibers 和协程 Coroutines 了 一文搞懂它们的区别'
date: "2025-09-24T00:39:41Z"
---
别再混淆 PHP8.1 中纤程 Fibers 和协程 Coroutines 了 一文搞懂它们的区别
=================================================

别再混淆 PHP8.1 中纤程 Fibers 和协程 Coroutines 了 一文搞懂它们的区别
=================================================

PHP 从早期那个只能写动态网页的简单脚本语言，发展到现在已经走了很远。PHP 8.1 的发布带来了一个特别令人兴奋的新功能：纤程（Fibers）—— 这个强大的特性为语言引入了结构化并发。

但有个问题：很多开发者还是会把`协程`和`纤程（Fibers）`搞混，经常把它们当成一回事。虽然确实有相似的地方，但这两个概念有重要的区别。在设计异步或并发 PHP 应用时，搞清楚这些区别很重要。

让我们来详细分析一下。

[原文链接-别再混淆 PHP8.1 中纤程 Fibers 和协程 Coroutines 了 一文搞懂它们的区别](https://catchadmin.com/post/2025-09/php-coroutines-vs-fibers-zh)

什么是协程？
------

协程是一个通用的编程概念。你可以把它想象成一个特殊的函数，能够在某些地方暂停，然后稍后从暂停的地方继续执行。

在 PHP 中，协程通常通过生成器（yield）来实现。例如：

    <?php
    
    function coroutineExample() {
        echo "Start\n";
        yield;
        echo "Resume\n";
    }
    
    $coroutine = coroutineExample();
    $coroutine->current();  // Start
    $coroutine->next();     // Resume
    

这里，`yield` 允许函数暂停，将控制权返回给调用者，稍后再恢复。

这让协程在异步 I/O、数据管道和惰性求值方面特别有用。像 ReactPHP 和 Amp 这样的库底层就大量使用协程。

流程图：

    ┌─────────────┐
    │ 开始函数     │
    └──────┬──────┘
           │
           ▼
       yield (暂停)
           │
           ▼
      恢复执行
           │
           ▼
       函数结束
    

什么是纤程 Fibers？
-------------

`Fibers` 是 PHP 8.1 中引入的一个更新、更底层的概念。它们是轻量级的执行上下文，可以手动控制暂停和恢复。

与协程不同，`Fibers 不依赖` yield\`。它们使用 Fiber API 来显式挂起：

    <?php
    
    $fiber = new Fiber(function (): void {
        echo "Start\n";
        Fiber::suspend("Paused");
        echo "Resume\n";
    });
    $value = $fiber->start();  // Start
    echo $value . "\n";        // Paused
    $fiber->resume();          // Resume
    

纤程让你对执行流程有完全的控制权。它们让你能写出看起来像同步但实际是异步的代码，而且不会被生成器的各种限制绊住。

流程图：

    ┌─────────────┐
    │ 纤程开始     │
    └──────┬──────┘
           │
           ▼
       挂起 (手动)
           │
           ▼
       恢复 (手动)
           │
           ▼
       再次挂起 (可选)
           │
           ▼
       纤程完成
    

协程 vs Fibers：关键区别
-----------------

方面

协程

Fibers

概念来源

高级语言特性

底层基础组件

实现方式

yield

Fiber 类

使用场景

异步 I/O、管道、迭代

事件循环、异步框架

控制权

调用者通过生成器 API 控制

Fibers 完全控制执行上下文

恢复能力

只能在 yield 处暂停

可以在函数的任意点挂起

限制

不能返回到任意点

更灵活和强大

简而言之：

*   **协程**（生成器）为你提供迭代和类异步模式的便捷语法。
*   **Fibers**提供了在 PHP 中构建强大异步运行时的基础组件。

为什么这对 PHP 开发者很重要？
-----------------

在`Fibers`出现之前，PHP 没有一种干净利落的方式来处理异步工作流，只能用那些看起来很丑的回调链或者各种生成器的奇技淫巧。

有了`Fibers`，像 Amp v3, ReactPHP, webman(2.0 版本支持 Fibers 驱动了) 这样的库现在能让异步代码看起来像同步代码一样：

    <?php
    
    function fetchData(): string {
        // 假装这是异步 I/O
        Fiber::suspend("Waiting for response...");
        return "Data received!";
    }
    
    $fiber = new Fiber(fn() => fetchData());
    echo $fiber->start(); // Waiting for response...
    echo $fiber->resume(); // Data received!
    

这使得 PHP 在并发服务器、实时应用和高性能 API 方面成为更强的竞争者。

总结
--

协程和 Fibers 是相关的，但不是同一个东西：

*   **协程**（通过生成器）是暂停和恢复函数的模式。
*   **Fibers**是实现结构化并发和现代异步运行时的底层基础组件。

把协程想象成菜谱，Fibers 想象成食材。有了 Fibers 这个食材，你可以做出协程这道菜——但反过来就不行了。

如果你现在在用异步 PHP，搞清楚这些区别能帮你为项目选对工具和框架。

👉 你怎么看——Fibers 会把 PHP 带入异步编程的新时代，还是协程依然会是大多数开发者的首选？