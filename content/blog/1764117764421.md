---
layout: post
title: 'docker网络总结'
date: "2025-11-26T00:42:44Z"
---
docker网络总结
==========

转载请注明出处：

### 一、 Docker 网络核心概念

在 Docker 中，网络的核心目标是让容器之间、容器与外部世界（包括宿主机和其他机器）能够进行通信。

Docker 采用了一种可插拔的驱动架构，默认提供了几种网络驱动程序（Driver），每种驱动对应一种网络模式，以适应不同的使用场景。

关键概念：

*   网络命名空间（Network Namespace）：Linux 内核提供的功能，为容器提供独立的网络栈（包括网卡、路由表、iptables规则等），实现网络隔离。
    
*   虚拟以太网设备对（veth pair）：总是成对出现，像一根虚拟的网线，一端放在容器的网络命名空间中（通常命名为 `eth0`），另一端连接到宿主机上的一个虚拟网桥（如 `docker0`）。
    
*   网桥（Bridge）：一个虚拟的网络交换机，容器通过 `veth pair` 连接到它上面，从而实现同网段内的通信。
    

### 二、 常用的 Docker 网络类型（驱动）

当安装 Docker 后，执行 `docker network ls`，会看到几个默认创建的网络。

$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
a123b456c789   bridge    bridge    local
d789e012f345   host      host      local
f345g678h901   none      null      local

详细讲解这几种以及其它常用网络类型。

#### 1\. Bridge 网络（桥接网络）

这是 Docker 的默认网络驱动。如果你不指定网络，容器就会运行在默认的 `bridge` 网络上。

*   特点：
    
    *   隔离性：每个容器分配独立的网络命名空间。
        
    *   私有网络：容器被分配一个私有子网的IP地址（通常是 `172.17.0.0/16`）。
        
    *   NAT：容器默认可以通过宿主的IP地址访问外部网络（通过 `iptables` 的 MASQUERADE 规则）。外部网络无法直接通过IP访问容器内的服务。
        
    *   端口映射：为了让外部能访问容器服务，必须使用 `-p` 或 `-P` 参数将容器端口映射到宿主机端口。
        
*   使用场景：
    
    *   运行单个容器或不需要特殊网络需求的多个容器。
        
    *   需要将容器端口暴露给外部网络访问的场景（如运行一个Web服务器）。
        
*   示例与分析：
    
    \# 运行一个Nginx容器，并将其80端口映射到宿主机的8080端口
    docker run \-d --name my-nginx -p 8080:80 nginx
    
    # 查看默认的bridge网络详情
    docker network inspect bridge
    
    分析：
    
    1.  Docker 会创建一对 `veth` 设备。
        
    2.  一端放入 `my-nginx` 容器的网络命名空间（容器内 `ip addr` 可以看到 `eth0`）。
        
    3.  另一端连接到名为 `docker0` 的宿主机虚拟网桥上。
        
    4.  容器获得一个IP（如 `172.17.0.2`）。
        
    5.  当你在宿主机外访问 `http://<宿主机IP>:8080` 时，流量流向为：外部 -> 宿主机 `8080` 端口 -> `iptables` DNAT规则 -> `docker0` 网桥 -> 容器 `my-nginx` 的 `80` 端口。
        

#### 2\. Host 网络（主机网络）

使用 `--network=host` 参数，容器会共享宿主机的网络命名空间。

*   特点：
    
    *   无隔离：容器直接使用宿主机的IP和端口。
        
    *   高性能：因为没有NAT和网桥开销，网络性能最好。
        
    *   端口冲突：容器使用的端口不能与宿主机上其他进程冲突。
        
*   使用场景：
    
    *   对网络性能要求极高的场景（如高频交易系统、负载均衡器）。
        
    *   需要直接使用宿主机网络栈的特定应用。
        
*   示例与分析：
    
    \# 使用host网络运行Nginx
    docker run \-d --name my-nginx-host --network=host nginx
    
    分析：
    
    1.  容器内 `ip addr` 看到的结果与在宿主机上执行完全一样。
        
    2.  Nginx 服务直接监听在宿主机的 `80` 端口上。
        
    3.  你直接访问 `http://<宿主机IP>:80` 即可，无需也不可以使用 `-p` 参数进行端口映射。
        
        ![image](https://img2024.cnblogs.com/blog/1110857/202511/1110857-20251125230837739-1864569946.png)
        

#### 3\. None 网络（无网络）

使用 `--network=none` 参数，容器将获得自己的网络命名空间，但不进行任何网络配置。

*   特点：
    
    *   极致隔离：容器内只有 `lo`（loopback）回环接口，无法与任何网络（包括其他容器和外部网络）通信。
        
*   使用场景：
    
    *   需要完全离线、保证绝对安全的计算任务。
        
    *   由自定义脚本完全控制其网络配置的极端场景。
        
*   示例与分析：
    
    \# 运行一个无网络的容器
    docker run \-it --network=none --name isolated-container alpine sh
    
    # 进入容器后执行 \`ip addr\`，你将只看到 \`lo\` 设备。
    
    ![1764083141647](https://img2024.cnblogs.com/blog/1110857/202511/1110857-20251125230555283-557883602.png)
    

#### 4\. Container 网络（容器网络）

使用 `--network=container:<容器名|容器ID>` 参数，新创建的容器会与一个已存在的容器共享同一个网络命名空间。

*   特点：
    
    *   网络共享：两个容器使用相同的IP地址、端口空间等，可以通过 `localhost` 直接通信。
        
    *   生命周期绑定：被共享网络的容器停止后，依赖它的容器也会失去网络连接。
        
*   使用场景：
    
    *   Sidecar 模式：例如，一个主应用容器和一个负责日志收集或服务发现的辅助容器。
        
    *   需要对现有容器的网络流量进行监控或操纵的调试工具容器。
        
*   示例与分析：
    

\# 先运行一个主容器
docker run \-d --name web-app nginx

# 运行一个调试工具容器，共享web\-app的网络
docker run \-it --network=container:web-app --name debugger nicolaka/netshoot

# 在debugger容器中，你可以直接 \`curl http://localhost:80\` 来访问web-app的Nginx服务。

分析：

1.  `debugger` 容器没有自己独立的 `eth0`，它和 `web-app` 共用同一个。
    
2.  它们在网络层面就像同一个“进程”，可以通过本地回环地址 `127.0.0.1` 直接通信。
    

#### 5\. Overlay 网络（覆盖网络）

这是用于 Docker Swarm 集群 的网络驱动，它能让多个 Docker 宿主机（节点）上的容器都连接在同一个虚拟网络中，仿佛它们都在同一台机器上。

*   特点：
    
    *   跨主机通信：解决不同宿主机上容器间的直接通信问题。
        
    *   服务发现：内置DNS服务，可以通过服务名解析到容器的IP。
        
    *   负载均衡：Swarm 可以对发布的服务提供内部的负载均衡。
        
*   使用场景：
    
    *   在 Docker Swarm 集群中部署多服务的分布式应用（微服务架构）。
        
    *   需要容器跨物理机/虚拟机进行透明通信的场景。
        
*   示例与分析：
    
    \# 初始化Swarm集群（在Manager节点上）
    docker swarm init
    
    # 创建一个Overlay网络
    docker network create \-d overlay my-overlay-net
    
    # 在Swarm中创建一个服务，使用该Overlay网络
    docker service create \--name web --network my-overlay-net -p 80:80 nginx
    
    分析：
    
    1.  `my-overlay-net` 网络会被同步到Swarm集群的所有节点上。
        
    2.  无论 `web` 服务的副本被调度到哪个节点，它们都能通过 `my-overlay-net` 相互通信。
        
    3.  集群内部可以通过服务名 `web` 进行DNS解析，获得VIP（虚拟IP），实现负载均衡。
        

                ![image](https://img2024.cnblogs.com/blog/1110857/202511/1110857-20251125230418874-330369879.png)

#### 6\. Macvlan 网络

它允许你为容器分配一个物理网络中的MAC地址，使得容器看起来像是物理网络中的一个真实的物理设备。

*   特点：
    
    *   直接暴露：容器直接使用物理网络的IP段，无需端口映射和NAT。
        
    *   需要支持：要求宿主机网络接口支持“混杂模式”。
        
    *   IP管理：需要精细管理IP地址，防止IP冲突。
        
*   使用场景：
    
    *   遗留应用需要直接使用物理网络IP的场景。
        
    *   网络监控工具需要直接监听网络流量。
        
    *   需要容器IP被网络中原有系统直接识别的场景。
        
*   示例与分析：
    
    \# 创建一个Macvlan网络，连接到宿主机的eth0网卡，使用192.168.1.0/24网段
    docker network create \-d macvlan \\
      \--subnet=192.168.1.0/24 \\
      \--gateway=192.168.1.1 \\
      \-o parent=eth0 \\
      my\-macvlan-net
    
    # 运行一个容器并指定IP
    docker run \-it --network=my-macvlan-net --ip=192.168.1.99 --name macvlan-container alpine sh
    
    分析：
    
    1.  容器 `macvlan-container` 会获得IP `192.168.1.99`，并拥有一个唯一的MAC地址。
        
    2.  在同一个局域网内的其他机器，可以直接 `ping 192.168.1.99`，就像ping一台真实的物理机一样。
        

### 三、 总结与对比

网络类型

驱动名

隔离性

性能

适用场景

关键特点

Bridge

`bridge`

命名空间隔离

较好（有NAT开销）

单机容器、需端口映射

默认驱动，需 `-p` 端口映射

Host

`host`

无网络隔离

最佳（无额外开销）

高性能需求、网络工具

直接使用宿主机网络，端口易冲突

None

`null`

完全隔离

\-

安全计算、离线任务

只有loopback接口

Container

`container`

与指定容器共享

好

Sidecar、调试

共享网络命名空间，通过`localhost`通信

Overlay

`overlay`

跨主机虚拟网络

较好（有封装开销）

Docker Swarm集群、微服务

解决跨主机通信，内置服务发现

Macvlan

`macvlan`

物理网络直接暴露

好（无NAT）

遗留应用、网络监控

容器像物理设备，需管理IP

### 四、 最佳实践

1.  生产环境：对于单机部署，可以创建自定义的Bridge网络以获得更好的隔离性和内置的DNS解析（容器间可以通过容器名通信）。对于集群部署，使用 Overlay 网络。
    
2.  网络规划：提前规划好子网，避免IP冲突。
    
3.  服务发现：在自定义Bridge和Overlay网络中，优先使用容器名或服务名进行通信，而不是IP地址。
    
4.  安全性：根据最小权限原则，只为容器配置其必需的网络访问权限。例如，不相关的容器组应使用不同的网络。