---
layout: post
title: '某Websocket反爬逆向分析+请求加解密+还原html'
date: "2025-01-21T00:34:51Z"
---
某Websocket反爬逆向分析+请求加解密+还原html
=============================

![某Websocket反爬逆向分析+请求加解密+还原html](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225819884-1602579673.png) JS逆向分析Websocket，请求加解密，二进制消息解析

网址
==

`aHR0cHM6Ly93d3cueWR4Zi5nb3YuY24vTmV3cy9zaG93TGlzdC80L3BhZ2VfMS5odG1s`

前言
==

工作中遇到的某websocket反爬，比混淆网站还恶心，看到也有其他人在问这个

之前看到其他大佬也弄过这个websocket反爬，但是只是说了下加解密，个人觉得最重要的还是还原最终的html，所以来分享一下过程

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328950-1343209987.png)

目标
==

*   过无限debugger
*   `session`请求加解密
*   `websocket`通信
*   消息结构解析还原成`html`
*   使用Python还原算法

分析过程
====

无限debugger
----------

1.  首先打开F12，刷新页面发现会被断住
2.  右键js文件替换内容
3.  看堆栈往上先随便点几个看看

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328884-1238724679.png)

1.  可以直接找到通过正则检测代码格式化的检测点，这里是个自执行函数，我们需要把整个函数干掉，然后保存刷新页面
2.  发现还是会被断住，老套路直接看堆栈往上找检测点

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328680-1645864317.png)

1.  可以清楚看到定时器在不断检测，直接干掉就行了
2.  刷新页面，到此为止无限debugger就过了，这个站的检测还是很简单的对吧

session请求加解密
------------

*   XHR

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328408-1857217435.png)

*   Payload

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328833-535869976.png)

*   Response

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328062-1177149958.png)

### Payload加密

直接看xhr的堆栈

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328782-1157297182.png)

这个比较简单我就不废话了，看截图就行

跟进去函数后可以看到用到了iv，iv生成就在上面一个函数

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328757-1145505101.png)

往下继续跟，进入这个解密函数，这个解密函数计算iv的时候也用到这个函数

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328790-1723477875.png)

直接跟到下图这个位置可以看到是个AES加密，差不多就结束了，这个是个标准`AES-128-CBC`，直接引库就行了

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328672-233011253.png)

### Response解密

跟加密算法一致，用同一个key解密就行，这里就不再写具体流程了

### Python实现

*   AES-128-CBC

代码抄了晨哥的 😛

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328428-425664620.png)

*   构造请求&加解密

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328451-748410835.png)

*   运行结果

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225329020-397993957.png)

Websocket
---------

### wss链接分析

`wss://www.xxxx.cn/1ywuKELSO2ahQuWZ/pr/rSakD15JVxHzfnpXyZpkf4J5HNjv_CSciPJFAMMxKE0%3D/c/ws/zpgffq9z89/a0c20283-d62c-411a-820b-33e42f1c6082`

*   `1ywuKELSO2ahQuWZ`：固定值
*   `rSakD15JVxHzfnpXyZpkf4J5HNjv_CSciPJFAMMxKE0%3D`：session返回的token值
*   `zpgffq9z89`：网站tab\_id，与请求时保持一致，随机字符串（可固定）
*   `a0c20283-d62c-411a-820b-33e42f1c6082`：uuid，可固定

### Python连接Websocket

*   第三方库：`websocket-client`、`msgpack`
*   代码

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225329007-1814397699.png)

*   结果

这里返回的结果通过msgpack进行解包了，这里就不再赘述了，有兴趣的可以看我晨哥的分析文章讲到了这个[https://mp.weixin.qq.com/s/o5UCJFhBg-4JFdS0aEwDuw](https://mp.weixin.qq.com/s/o5UCJFhBg-4JFdS0aEwDuw)

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328858-267613149.png)

消息结构解析
------

重点来了，这个网站最难的不是`session`的加解密和`websocket`连接，而是websocket收发的消息，页面的内容均是通过websocket返回的`特殊指令`渲染出来的，因此我们从websocket中取想要的数据可能会比较复杂，并且不能通用，我们这里会讲到如何将收到的指令还原成原本的`html`，从而通过`pyquery`或者`bs4`等html解析库来提取数据

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328815-490016413.png)

### 定位websocket接收消息函数

找到ws连接请求，进入第一个调用堆栈

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328731-917107959.png)

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328681-1947736154.png)

在连接下面找到消息回调函数，直接下断点后跟进去

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328818-1702716390.png)

这样我们就找到了ws消息回调函数了

### 分析接收到的数据

单步跟着走一遍

可以直接把指令表拿出来，这样比较清晰，也可以根据对应名称来猜指令的作用

    CommandCodes = {
        "TAB_OPS": 0,
        "DOM_EVENT": 4,
        "DOM_METHOD": 5,
        "RESET_DOM": 6,
        "ADD_DOC_TYPE": 7,
        "ADD_HTML_ELEMENT": 8,
        "ADD_SVG_ELEMENT": 9,
        "ADD_NS_ELEMENT": 10,
        "MOVE_ELEMENT": 11,
        "SHUFFLE_CHILDREN": 12,
        "EDIT_ELEMENT": 13,
        "DELETE_ELEMENT": 14,
        "ADD_STYLE": 15,
        "ADD_TEXT": 16,
        "MODIFY_TEXT": 17,
        "MODIFY_PROPERTY": 18,
        "MODIFY_ATTRIBUTES": 19,
        "SET_SELECTIONS": 20,
        "INSERT_RULE": 21,
        "DELETE_RULE": 22,
        "DISABLED_STYLE": 24,
        "SET_CANVAS_DATA": 23,
        "REPLACE_SYNC": 25,
        "WEBRTC": 30,
        "NAVIGATE": 31,
        "SYNC": 32,
        "SYNC_COOKIE": 34,
        "FILE": 35,
        "TAB_ACTIVE": 42,
        "NATIVE_METHOD": 44,
        "MODIFY_DOC_TYPE": 47,
        "CHANGE_BLOCK": 48,
        "RELOAD": 49,
        "SYNC_ALL_COOKIE": 50,
        "SYNC_WRITE_COOKIE": 51,
        "MEDIA_STATE": 52,
        "DOM_READY": 53,
        "AUGMENT_CSS": 54,
        "MULTI_CMD": 55,
        "REDIRECT_REQUEST": 56,
        "TEXTAREA_RESIZE": 57,
        "SIMPLE_HTML": 58,
        "RENDER_STATE": 59,
        "SYNC_CONFIG_TO_CLIENT_WIC": 60,
        "SYNC_CONFIG_TO_CLIENT_AIC": 61,
        "SYNC_CONFIG_TO_CLIENT_EIC": 62,
        "FRAME_PUSH_STATE": 63
    }
    

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328723-999119980.png)

断到一个53指令码，根据码表来看应该是dom相关的指令，继续单步跟

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328843-774395556.png)

这里将数据传送到其他回调函数了，继续跟进去

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328655-206532379.png)

大概跟了几个函数就跟到这里了，这里比较重要，我们慢慢看

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328867-1504907438.png)

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328644-1221633993.png)

这个应该是将数组形式的消息转换为对象形式，这个消息太短了，看不出效果，我们多接收几个消息看一下

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328639-2099931066.png)

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328639-410971651.png)

这个55指令码对应的指令名是`"MULTI_CMD": 55` ，应该是多条指令的集合，我们还需要对content的多条指令进行转换，才能拿到最终的对象

单步跟了一下后发现会进入到另外一个接收函数

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328680-2128877361.png)

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328946-1436915738.png)

这里就是根据不同指令码来执行不同操作的地方了

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328666-622208.png)

可以看到这个`55`指令码实际上会进行递归执行指令

后面会根据不同指令码来走不同的分支，我这里就直接给结果吧，`"ADD_DOC_TYPE": 7`

这个指令操作会给在html中添加一个dom元素，它这里实际上是将这个指令都放到一个指令队列里面，然后再根据指令队列循环操作dom树来渲染页面元素

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328745-377009571.png)

### 将websocket消息转换为对象

单步跟进之前那个转换指令的函数

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328631-758019779.png)

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328533-1465112590.png)

这里会根据e的指令码映射拿到对应的指令处理器，再执行转换命令

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328812-213908267.png)

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328807-178913703.png)

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328736-1585778211.png)

不同的指令对应不同的转换器，所以这里如果要还原得一个一个抠下来才行

### 使用Python还原指令解析算法

基本上只要对照js来还原就行了

*   指令转换器

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328649-1235492207.png)

*   消息解析

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225329031-202003662.png)

*   运行结果

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328647-946330592.png)

### 使用Pyquery还原HTML

我们需要将上一步转换后的指令队列转换为HTML代码

*   转换代码

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328697-2024206660.png)

*   运行结果

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328783-458325568.png)

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328616-443625653.png)

*   列表页

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328761-1222040126.png)

*   详情页

![](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328606-1465975295.png)

有了html代码后就可以用xpath大法来拿内容了

微信公众号
=====

公众号更新比较快，欢迎关注！  
![image](https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230616341-1563051605.png)

完整源代码
=====

欢迎各位大佬一起完善，有问题可以一起讨论，希望有更好的方案能带俺一手😁  
[https://github.com/Meteo-Pig/CommandSpider](https://github.com/Meteo-Pig/CommandSpider)

> 码字不易，动起你的发财的小手点个赞吧~~