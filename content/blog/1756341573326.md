---
layout: post
title: 'CMake构建学习笔记21-通用的CMake构建脚本'
date: "2025-08-28T00:39:33Z"
---
CMake构建学习笔记21-通用的CMake构建脚本
==========================

通过提取通用逻辑，将CMake构建流程封装为可复用的PowerShell脚本，提升构建配置的维护效率。

在之前使用CMake构建程序的脚本（[CMake构建学习笔记-目录](https://charlee44.com/post.html?id=a1671c83735546cfa5c69b7ae7e37403)）中，大部分内容都有比较强的相似性，那么是不是可以这些相似的内容提取出来作为一个单独的脚本，在构建具体的程序的时候再去调用这个脚本呢？这样做的好处是如果构建的配置有什么变动，就不用每个程序的构建脚本都修改了，只用修改这个通用的脚本就可以了。

具体的脚本cmake-build.ps1如下，适用于PowerShell终端：

    param(
        [string]$SourceLocalPath,
        [string]$BuildDir,
        [string]$Generator,
        [string]$InstallDir,
        [string]$SymbolDir,
        [string[]]$PdbFiles,
        [hashtable]$CMakeCacheVariables,
        [bool]$MultiConfig = $false  # 控制是否使用多配置类型
    )
    
    # 清除旧的构建目录
    if (Test-Path $BuildDir) {
        Remove-Item -Path $BuildDir -Recurse -Force
    }
    New-Item -ItemType Directory -Path $BuildDir
    
    # 构建CMake命令行参数
    $CMakeArgs = @(
        "-B", "`"$BuildDir`"",
        "-G", "`"$Generator`"",
        "-A", "x64"
    )
    
    if ($MultiConfig) {
        $CMakeArgs += "-DCMAKE_CONFIGURATION_TYPES=RelWithDebInfo"
    }
    else {
        $CMakeArgs += "-DCMAKE_BUILD_TYPE=RelWithDebInfo"
    }
    
    $CMakeArgs += (
        "-DCMAKE_PREFIX_PATH=`"$InstallDir`"",
        "-DCMAKE_INSTALL_PREFIX=`"$InstallDir`""
    )
    
    # 添加额外的CMake缓存变量
    foreach ($key in $CMakeCacheVariables.Keys) {
        $CMakeArgs += "-D$key=$($CMakeCacheVariables[$key])"
    }
    
    # 配置CMake
    cmake $SourceLocalPath $CMakeArgs
    
    # 构建阶段，指定构建类型
    cmake --build $BuildDir --config RelWithDebInfo --parallel
    
    # 安装阶段，指定构建类型和安装目标
    cmake --build $BuildDir --config RelWithDebInfo --target install
    
    # 复制符号库
    foreach ($file in $PdbFiles) {  
        Write-Output $file
        if (Test-Path $file) {
            Copy-Item -Path $file -Destination $SymbolDir
        }
        else {
            Write-Output "Warning: PDB file not found: $file"
        }
    }
    
    # 清理构建目录
    #Remove-Item -Path $BuildDir -Recurse -Force
    

这段脚本的关键在于以下几点：

1.  CMake配置参数`$CMakeArgs`。首先是通用配置，`-B`表示生成的目录；`-G`表示生成器，比如"Ninja"或者"Visual Studio 17 2022"；`-A`表示目标平台的架构。然后是构建目标的类型，有的库使用`CMAKE_CONFIGURATION_TYPES`,有的库使用`CMAKE_BUILD_TYPE`，值设置成`RelWithDebInfo`表示Release版本，但是带调试信息。接下来是设置依赖库查找路径`CMAKE_PREFIX_PATH`和安装路径`CMAKE_INSTALL_PREFIX`。最后是添加额外的CMake缓存变量，这些缓存变量通常与要构建的库有关。
2.  使用生成的配置参数`$CMakeArgs`进行项目配置：`cmake $SourceLocalPath $CMakeArgs`。这一步会把设置的参数固定成具体的项目参数，如果使用Visual Studio进行构建，就是生成sln项目。
3.  编译、链接，生成构建目标：`cmake --build $BuildDir --config RelWithDebInfo --parallel`。这里的`--parallel`的意思是并行构建，会采用多线程的方式构建项目，自动决定线程数。
4.  安装构建目标`cmake --build $BuildDir --config RelWithDebInfo --target install`。
5.  最后一步复制符号库的作用是将生成的符号库文件复制到特定的目录中进行管理，这样在程序崩溃之后，可以通过符号库找到相应的代码，便于进行错误排查。

那么有没有具体使用这个cmake-build.ps1脚本的例子呢？后续文章中的程序构建会使用这个脚本，敬请期待。