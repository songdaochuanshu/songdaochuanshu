---
layout: post
title: 'U3D动作游戏开发读书笔记--2.2 编辑器本身的基础知识'
date: "2025-09-13T00:37:05Z"
---
U3D动作游戏开发读书笔记--2.2 编辑器本身的基础知识
=============================

### 2.2 编辑器本身的基础知识

项目顺利开发离不开对开发工具的打磨，为此需要对Unity Editor进行拓展功能的开发，包括一些诸如常量生成器这样辅助性的功能开发，以及通过引擎自带的插件与其他3D软件进行交互式编辑等，以提升开发效率。

#### 2.2.1编辑器工具的编写

编辑器工具开发大致可分为**脚本Inspector的拓展**开发和**独立窗口**开发量大部分。下面就来实战展示一下相关内容。

1.  Inspector行为面板拓展
    
    创建一个敌人类型脚本：
    
    ![image-20250910205517030](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212437000-15471112.png)
    

在编辑器文件夹下新建拓展开发脚本：

在编辑器文件夹下新建拓展开发脚本：

![image-20250910205611118](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212649506-851462485.png)

![image-20250910205600937](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212531919-1077937132.png)

此脚本是对`EnemyTest`脚本Inspector进行拓展开发，简单的设置两个按钮，点击按钮可以将`EnemyTest`脚本的变量进行赋值。其效果如下：

![image-20250910205825001](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212535612-1287770670.png)

点击对应的按钮之后数值会被设成对应值。

不过我们常用的规范写法是如下脚本内容：

      public override void OnInspectorGUI()
            {
                //更新序列化对象
                serializedObject.Update();
                
                var hpProp = serializedObject.FindProperty("hp");
                var speedProp = serializedObject.FindProperty("speed");
                var attackProp = serializedObject.FindProperty("attack");
    
                //检测GUI内容改变
                using (var change = new EditorGUI.ChangeCheckScope())
                {
                    EditorGUILayout.PropertyField(hpProp,new GUIContent("Enemy hp(生命值)"));
                    EditorGUILayout.PropertyField(speedProp,new GUIContent("Enemy speed(移动速度)"));
                    EditorGUILayout.PropertyField(attackProp,new GUIContent("Enemy attack(攻击伤害)"));
                    if (GUILayout.Button("preset1"))
                    {
                        hpProp.intValue = 120;
                        speedProp.floatValue = 15;
                        attackProp.intValue = 200;
                        Debug.Log("preset1");
                    }
                    
                    if (GUILayout.Button("preset2"))
                    {
                        hpProp.intValue = 200;
                        speedProp.floatValue = 10;
                        attackProp.intValue = 150;
                        Debug.Log("preset2");
                    }
    
                    //如果属性值发生了改变 则应用修改
                    if (change.changed)
                    {
                        serializedObject.ApplyModifiedProperties();
                    }
                }
            }
    

![image-20250910224938687](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212542660-1686973799.png)

效果如上图所示；

要点：`using (var change = new EditorGUI.ChangeCheckScope())`的使用；

![image-20250910231656947](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212546859-1301872588.png)

当然我们也可以设定Inspector相关的内容：`PreviewGUI`可以提供监视面板下的内容预览、调试等，使用它需要重写3个方法，代码如下：

![image-20250910225107509](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212550871-1280962336.png)

![image-20250910225136997](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212554350-1402398075.png)

这样子在底部的预览界面可以按照三个回调函数的设置来进行展示；

2.  **使用EditWindow自定义窗口**
    
    请看如下代码：
    
    该脚本在编辑器中通过访问顶部栏Tools的菜单，渲染出自定义的编辑器窗口。窗口打开后，在场景中绘制两个红色的线框，当窗口关闭后，红色线框消失。
    
        namespace LearnBook.Chapter2
        {
            public class BattleDebugerEditorWindow : EditorWindow
            {
                [MenuItem("Tools/Battle Debuger")]
                static void SetUp()
                {
                    GetWindow<BattleDebugerEditorWindow>();
                }
        
                private void OnGUI()
                {
                    if (GUILayout.Button("Create Enemy"))
                    {
                        Debug.Log("Create Enemy");
                    }
                }
                
                private List<Vector3> EnemiesPosList = new List<Vector3>()
                {
                    new Vector3(0, 0, 0),
                    new Vector3(0,5,0)
                };
                
                private void OnEnable()
                {
                    //添加绘制回调方法
                    SceneView.duringSceneGui += CreateEnemiesInView;
                }
        
                void CreateEnemiesInView(SceneView sceneView)
                {
                    // 绘制敌人 视图
                    foreach (var pos in EnemiesPosList)
                    {
                        Handles.color = Color.red;
                        Handles.DrawWireCube(pos, Vector3.one);
                    }
                }
        
                private void OnDestroy()
                {
                    //移除绘制回调方法
                    SceneView.duringSceneGui -= CreateEnemiesInView;
                }
            }
        }
        
    
    ![image-20250910225908021](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212600579-1251367221.png)
    

当窗口绘制出来时，场景中也会绘制两个红色的线框cube，当窗口关闭后不再绘制。

![image-20250910225953575](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212603168-1021712292.png)

#### 2.2.2 关联游戏配置数据

在游戏开发中，策划与程序需要有良好的配置环境来处理数据，可以直接使用ScriptableObject来处理数据，或者通过Excel转JSON的形式将数据表直接从Excel里抓取过来。

使用ScriptableObject

    namespace LearnBook.Chapter2
    {
        [CreateAssetMenu( fileName = "TestScriptableObject", menuName = "Test/TestScriptableObject")]
        public class TestScriptableObject :ScriptableObject
        {
            [Serializable]
            public class GameInfo
            {
                public int IntValue;
                public string Name;
            }
            
            public GameInfo[] GameInfos;
        }
    }
    

我们可以通过在Unity编辑器中 右键菜单栏：Create ---->Test--->TestScriptableObject 创建TestScriptableObject类型的配置文件；

![image-20250910231335780](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212607195-134456910.png)

#### 2.2.3 常量生成器

在项目开发中我们可以对诸如Layer、Tag等编辑器数据进行常量生成，来代替在代码中通过输入字符串生成常量的形式以提高开发效率。

     [MenuItem("Tools/生成常量脚本")]
            private static void GenerateConstFunc()
            {
                var sb = new StringBuilder();
                sb.AppendLine("public class _Const");
                sb.AppendLine("{");
    
                for (int i = 1; i < 32; i++)
                {
                    var name = LayerMask.LayerToName(i);
                    name = name
                        .Replace(" ", "_")
                        .Replace("&", "_")
                        .Replace("/", "_")
                        .Replace(".", "_")
                        .Replace(",", "_")
                        .Replace(";", "_")
                        .Replace("-", "_");
                    if (!string.IsNullOrEmpty(name))
                        sb.AppendFormat("\tpublic const int LAYER_{0} = {1};\n", name.ToUpper(), i);
                }
                sb.AppendLine("\tpublic const string " + ("Tag_Respawn".ToUpper() + " = " + "\"Respawn\";")); 
                sb.AppendLine("\tpublic const string " + ("Tag_Finish".ToUpper() + " = " + "\"Finish\";")); 
                sb.AppendLine("\tpublic const string " + ("Tag_EditorOnly".ToUpper() + " = " + "\"EditorOnly\";")); 
                sb.AppendLine("\tpublic const string " + ("Tag_MainCamera".ToUpper() + " = " + "\"MainCamera\";")); 
                sb.AppendLine("\tpublic const string " + ("Tag_Player".ToUpper() + " = " + "\"Player\";")); 
                sb.AppendLine("\tpublic const string " + ("Tag_GameController".ToUpper() + " = " + "\"GameController\";"));       
                
                //读取项目文件中的标签配置信息
                var asset = UnityEditor.AssetDatabase.LoadAllAssetsAtPath("ProjectSettings/ TagManager.asset");                                        
                //取得自定义Tag
                if ((asset != null) && (asset.Length > 0)) 
                {
                    for (int i = 0; i < asset.Length; i++)
                    {
                        //创建序列化对象
                        var so = new UnityEditor.SerializedObject(asset[i]);
                        var tags = so.FindProperty("tags");
                        //读取具体字段
                        for (int j = 0; j < tags.arraySize; ++j)
                        {
                            var item = tags.GetArrayElementAtIndex(j).stringValue;
                            sb.AppendFormat("\tpublic const string TAG_{0} = \"{1}\";\n", item.ToUpper(), item);
                        }
                    }
                } 
                sb.AppendLine("}"); 
                File.WriteAllText("Assets/GeneratedConst.cs", sb.ToString());
                AssetDatabase.Refresh();
    
            }
    

执行代码方法后生成脚本：

![image-20250910231840252](https://img2024.cnblogs.com/blog/3292471/202509/3292471-20250912212614852-1246225573.png)