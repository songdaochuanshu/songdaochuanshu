---
layout: post
title: 'FFmpeg原始帧处理-滤镜设置视频宽高比'
date: "2025-09-15T00:42:12Z"
---
FFmpeg原始帧处理-滤镜设置视频宽高比
=====================

本文为作者原创，转载请注明出处：[https://www.cnblogs.com/leisure\_chn/p/19089092](https://www.cnblogs.com/leisure_chn/p/19089092)

1\. 视频宽高比的概念：SAR, PAR, DAR
--------------------------

播放器在播放视频时需要保持播放的图像和信源物体宽高比例一致，不一致就会导致图像变形。比如墙上挂有一个正圆形时钟，经摄像机采集、编码器编码、解码器解码、播放器播放后，最终在显示器上呈现的视频，仍然能看到一个正圆形的时钟在滴滴答答走动，这才正常。如果显示器上的时钟变成了椭圆形，那就是视频宽高比没设置好，导致终端和源端不匹配，无法正确还原信源的图像。

与视频宽高比相关的有三个概念：SAR (sample aspect ratio)，PAR (picture aspect ratio) 和 DAR (dispaly aspect ratio)。在不同的文档不同的软件代码中，这三个概念的名称或定义可能存在差异，但这三个核心概念的本质是不变的，本文限定在 H.264 编码流、FFmpeg 工具、PotPlayer 播放器这一组环境中来研究这三个概念。

本文实验环境：

    操作系统：Windows 10
    播放器：PotPlayer 250625(1.7.22570)
    FFmpeg: 8.0
    

### 1.1 SAR (sample aspect ratio)

SAR (sample aspect ratio) 是采样宽高比，是像素采样点所占物理空间的宽和高之比，也可理解为像素点的宽和高之比，表示像素的形状。比如 SAR 为 1:1 表示像素是方形；SAR 为 2:1 表示像素是矩形，像素宽是像素高的 2 倍。既然是采样宽高比，实际在源端图像传感器采集图像时，就根据被采样的实物形状确定了像素形状，确定了 SAR。

在 H.262 和 H.264 标准文档里都提到了 SAR。H.262 标准第 6.3.3 节 “Sequence header”提到了 SAR 相关的语法，也提到了 DAR，但是说得不太清楚，不好理解。H.264 标准第 E.2.1 节 “VUI parameters semantics”提到了 SAR 相关的语法，并描述了 SAR 如何影响播放行为，H.264 对 SAR 的描述要清晰很多，我们来看一下 H.264 标准中的 SAR 语法元素：

**aspect\_ratio\_info\_present\_flag**：值 1 表示接 SPS 的 vui\_parameters 中存在 aspect\_ratio\_idc 语法元素，SAR 将由 aspect\_ratio\_idc 值指定；值 0 表示不存在 aspect\_ratio\_idc，这种情况 SAR 取默认值 1:1。

**aspect\_ratio\_idc**：表示亮度采样点的 SAR (sample aspect ratio，采样宽高比)。等于水平方向上两个相邻亮度采样点的距离和垂直方向两个相邻亮度采样点的距离之比，也就是前面说的像素采样点所占物理空间的宽和高之比。表 E-1 (引处略) 给出了 aspect\_ratio\_idc 取值的含义，比如：值 1 表示 1:1，值 2 表示 12:11，值 3 表示 10:11，值 255 表示扩展 SAR (Extended\_SAR)，SAR 值等于接下来的两个语法元素之比 sar\_width : sar\_height。

**sar\_width, sar\_height**：SAR 的水平尺寸和垂直尺寸，只有当 aspect\_ratio\_idc 值为 255 (表示 Extended\_SAR) 时，这两个语法元素才会存在，此时 SAR 值等于 sar\_width : sar\_height。

**overscan\_info\_present\_flag**：值 1 表示接下来的语法元素 overscan\_appropriate\_flag 存在，值 0 表示不存在。不存在时，视频显示方案未规定。

**overscan\_appropriate\_flag**：值 1 表示图像适合用 overscan (切边) 显示。值 0 表示图像有重要视觉信息不适合 overscan 切边，则用　underscan 补黑边或直接显示 (DAR 与显示窗口宽高比一样，即不用切边也不用补黑边)。这里提到了 overscan 和 underscan 的概念，在 1.4 节详细说明。

因为 H.264 码流里可能存在 SAR 相关的语法元素，所以 SAR 可以从 H.264 码流中获取，若码流中不存在 SAR 语法元素或 SAR 为无效值，则 SAR 取 1:1。

### 1.2 PAR (picture aspect ratio)

PAR (picture aspect ratio) 是图像宽高比，是图像宽度 (单位：像素) 和图像高度 (单位：像素) 之比。比如分辩率是 1280 x 720 的视频，其 PAR 等于 1280:720 = 16:9。

因为 H.264 码流里包含有视频长宽信息，所以 PAR 也能从 H.264 码流中获取。

### 1.3 DAR (dispaly aspect ratio)

DAR (dispaly aspect ratio) 是显示宽高比，是图像在播放器上播放宽度与播放高度之比，告诉播放器应该以什么宽高比例来呈现这幅图像。DAR 是给播放器使用的，播放器按 DAR 来播放视频。

Ｈ.264 码流里不包含 DAR 信息。DAR 是根据 SAR 和 PAR 计算出来的：DAR = SAR x PAR。这个计算关系是很容易理解的。

我们看一下 FFmpeg 中计算 DAR 的代码：

    static void dump_stream_format(const AVFormatContext *ic, int i,
                                   int group_index, int index, int is_output,
                                   int log_level)
    {
        ...
        if (st->sample_aspect_ratio.num &&
            av_cmp_q(st->sample_aspect_ratio, st->codecpar->sample_aspect_ratio)) {
            AVRational display_aspect_ratio;
            av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,
                      st->codecpar->width  * (int64_t)st->sample_aspect_ratio.num,
                      st->codecpar->height * (int64_t)st->sample_aspect_ratio.den,
                      1024 * 1024);
            av_log(NULL, log_level, ", SAR %d:%d DAR %d:%d",
                   st->sample_aspect_ratio.num, st->sample_aspect_ratio.den,
                   display_aspect_ratio.num, display_aspect_ratio.den);
        }
        ...
    }
    

上述代码中，SAR 是 st->sample\_aspect\_ratio.num : st->sample\_aspect\_ratio.den，DAR 是 ( st->codecpar->width : st->codecpar->height ) x ( st->sample\_aspect\_ratio.num : st->sample\_aspect\_ratio.den )，st->codecpar->width : st->codecpar->height 就是 PAR，只是 FFmpeg 没有打印 PAR 这个信息，所以这个计算过程就是 DAR ＝ SAR x PAR。

### 1.4 播放器如何做到播放比例不变形？

视频按 DAR 指定的宽高比呈现在显示器上时，视频的宽高比例就是不变形的。播放器打开视频文件解码播放时，很容易拿到视频的 SAR 和 PAR，根据 SAR 和 PAR 就能计算得到视频的 DAR。当播放器的播放窗口 (小窗口或全屏) 的宽高比和视频 DAR 一样时，视频可以保持 DAR 比例完整填充播放窗口。当播放器的播放窗口的宽高比和视频 DAR 不一样时，播放器要么需要裁切视频的左右边缘或上下边缘，这叫 overscan (过扫描)；要么在视频的左右边缘或上下边缘补黑边，这叫 underscan (欠扫描)。

假设一个视频的 DAR 是 4:3，将播放器的播放窗口设定为一个固定尺寸的方形窗口，那么播放器播放窗口的宽高比就是 1:1。如果以 overscan 切边的方式来播放视频，那么这个视频左右边缘会被切掉 1/3 的画面，如果以 underscan 补黑边的方式来播放视频，那么这个视频的上下边缘会被添加 1/4 的黑边，通过切边或补黑边的方式，视频画面成为 1:1 的方形装进方形播放窗口，这样处理，播放出来的视频内容是不会变形的。播放器是采用 overscan 还是 underscan，根据前述 H.264 中 overscan\_info\_present\_flag 和 overscan\_appropriate\_flag 这两个语法元素确定。播放器会优先使用 underscan 补黑边的方式 (因为这种方式不会丢失视频内容)，除非语法元素中明确指定了要用 overscan 的方式。当然，这也依赖于播放器采取的策略。

如果一个视频文件的 DAR 是 16:9，播放窗口的宽高比例也是 16:9，那么这个视频不需要切边也不需补黑边，直接就能在播放窗口中铺满播放。

如果一个视频文件的 DAR 是 1:1，播放窗口的宽高比例是 16:9，以 underscan 模式播放视频时视频内容的左右边缘会添加黑边，这个黑边是在播放窗口两侧，不是视频文件中自带的黑边，而播放画面中有效视频内容仍然是 1:1 方形的。有的电影文件会在视频内容的顶部和底部包含黑边，营造电影感，这种黑边是视频内容的一部分，和本节所说的播放器 underscan 模式呈现的黑边是两码事。

2\. 使用 FFmpeg 滤镜设置视频宽高比
-----------------------

本节我们用实验来研究一下视频宽高比 SAR、PAR 和 DAR 对播放器播放行为的影响。

我们选用 FFmpeg 自带的测试图 testsrc 来作为源视频文件，后面再使用 FFmpeg 滤镜来修改这个视频文件的 SAR，PAR 和 DAR，看看不同的文件播放起来有什么差异。

先看看 testsrc 测试图长什么样？直接用 ffplay 播放 testsrc 测试图，命令如下：

    ffplay -f lavfi -i testsrc=size=320x320
    

可以看到，testsrc 测试图中有一个计数秒表，中间有一个正圆形：  
![testsrc测试图源](https://cdn.jsdelivr.net/gh/leichn/leichn.github.io/figure/aspect_radio/testsrc_320x320.png)

把 testsrc 测试图编码一段视频文件，命令如下：

    ffmpeg -ss 0:0:0 -t 20 -f lavfi -i testsrc=320x320 -c:v libx264 -pix_fmt yuv420p testsrc_320x320.mp4
    

上述命令中，参数“-f lavfi -i testsrc=320x320”表示选用 testsrc 测试图作源，尺寸设置为 320x320 像素，参数“-ss 0:0:0 -t 20”表示从 0 秒开始录制 20 时长的视频，“-c:v libx264”使用 libx264 编码器编码，“-pix\_fmt yuv420p”指定像素格式为 yuv420p。

看一下我们生成的视频文件的格式：

    PS E:\videos\sar> ffprobe.exe -hide_banner .\testsrc_320x320.mp4
    Input #0, mov,mp4,m4a,3gp,3g2,mj2, from '.\testsrc_320x320.mp4':
      Metadata:
        major_brand     : isom
        minor_version   : 512
        compatible_brands: isomiso2avc1mp41
        encoder         : Lavf61.7.100
      Duration: 00:00:20.00, start: 0.040000, bitrate: 32 kb/s
      Stream #0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(progressive), 320x320 [SAR 1:1 DAR 1:1], 29 kb/s, 25 fps, 25 tbr, 12800 tbn, start 0.040000 (default)
        Metadata:
          handler_name    : VideoHandler
          vendor_id       : [0][0][0][0]
          encoder         : Lavc61.19.101 libx264
    PS E:\videos\sar>
    

可以看到，SAR 是 1:1，DAR 是 1:1，PAR 没直接打印出来，PAR 是 320:320 = 1:1。

### 2.1 setsar/setdar 滤镜设置视频宽高比

setsar 滤镜和 setdar 滤镜是在 FFmpeg 的 vf\_aspect.c 中实现的。

先用 setsar 滤镜设置视频 SAR 为 16:9，命令如下：

    ffmpeg.exe -i .\testsrc_320x320.mp4 -c:v libx264 -vf setsar=sar=16/9 .\testsrc_320x320_sar_16_9.mp4
    

查看视频格式：

    PS E:\videos\sar> ffprobe.exe -hide_banner .\testsrc_320x320_sar_16_9.mp4
    Input #0, mov,mp4,m4a,3gp,3g2,mj2, from '.\testsrc_320x320_sar_16_9.mp4':
      Metadata:
        major_brand     : isom
        minor_version   : 512
        compatible_brands: isomiso2avc1mp41
        encoder         : Lavf62.3.100
      Duration: 00:00:20.00, start: 0.000000, bitrate: 32 kb/s
      Stream #0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(progressive), 320x320 [SAR 16:9 DAR 16:9], 30 kb/s, 25 fps, 25 tbr, 12800 tbn (default)
        Metadata:
          handler_name    : VideoHandler
          vendor_id       : [0][0][0][0]
          encoder         : Lavc62.11.100 libx264
    

可以看到，SAR 为 16:9，PAR 为 320:320 (即 1:1)，DAR 为 16:9，DAR 刚好等于 SAR x PAR。如果 ffprobe 探测某个视频文件格式，打印信息中没在 SAR 和 DAR 信息，说明这个视频文件中没有 SAR 相关语法元素或者 SAR 是无效值，这种情况会将默认值 1:1 用作此视频的 SAR，我们把这种视频文件重新转码一下，通过滤镜选项“-vf setsar=sar=1/1”来设置一下 SAR，转码新生成的视频文件再用 ffprobe 探测一下，就可以看到打印出了 SAR 和 DAR 信息，过程略。

再用 setdar 滤镜设置视频 DAR 为 16:9，命令如下：

    ffmpeg.exe -i .\testsrc_320x320.mp4 -c:v libx264 -vf setdar=dar=16/9 .\testsrc_320x320_dar_16_9.mp4
    

查看视频格式：

    PS E:\videos\sar> ffprobe.exe -hide_banner .\testsrc_320x320_dar_16_9.mp4
    Input #0, mov,mp4,m4a,3gp,3g2,mj2, from '.\testsrc_320x320_dar_16_9.mp4':
      Metadata:
        major_brand     : isom
        minor_version   : 512
        compatible_brands: isomiso2avc1mp41
        encoder         : Lavf62.3.100
      Duration: 00:00:20.00, start: 0.000000, bitrate: 32 kb/s
      Stream #0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(progressive), 320x320 [SAR 16:9 DAR 16:9], 30 kb/s, 25 fps, 25 tbr, 12800 tbn (default)
        Metadata:
          handler_name    : VideoHandler
          vendor_id       : [0][0][0][0]
          encoder         : Lavc62.11.100 libx264
    PS E:\videos\sar>
    

可以看到打印信息和前面 setsar 命令生成的视频文件打印一样。

实际，setdar 滤镜是通过改变视频的 SAR 来改变视频 DAR 的。猜测 setsar 和 setdar 底层行为一样：都改变了 SAR，进而改变  
了 DAR，不改变视频尺寸不改变 PAR。说不定这两个命令生成的文件都一样，来验证一下：

    PS E:\videos\sar> Get-FileHash .\testsrc_320x320_sar_16_9.mp4 -Algorithm MD5
    
    Algorithm       Hash                                                                   Path
    ---------       ----                                                                   ----
    MD5             ED6660476BB251182F8A81584983F583                                       E:\videos\sar\testsrc_320x320_sar_16_9.mp4
    
    PS E:\videos\sar> Get-FileHash .\testsrc_320x320_dar_16_9.mp4 -Algorithm MD5
    
    Algorithm       Hash                                                                   Path
    ---------       ----                                                                   ----
    MD5             ED6660476BB251182F8A81584983F583                                       E:\videos\sar\testsrc_320x320_dar_16_9.mp4
    
    PS E:\videos\sar>
    

果然，testsrc\_320x320\_sar\_16\_9.mp4 和 testsrc\_320x320\_dar\_16\_9.mp4 的 MD5 值一样，这两个文件内容完全一样。

用 PotPlayer 播放一下 testsrc\_320x320\_dar\_16\_9.mp4 文件，效果如下：  
![播放目标比例](https://cdn.jsdelivr.net/gh/leichn/leichn.github.io/figure/aspect_radio/testsrc_320x320_dar_16_9.png)

这是 16:9 的窗口使用 16:9 的比例播放视频的效果。播放器是按 DAR 值 16:9 创建的播放窗口，视频的 DAR 是 16:9，视频和窗口匹配，不需要切边也不需要补黑边。视频内容中的圆变形了，是因为视频本来 DAR 应该是 1:1，我们故意将 DAR 改成了 16:9，按 16:9 的比例播放视频当然变形了，圆成了椭圆。

在 PotPlayer 播放画面上点右键，依次点击 \[属性\] -> \[文件信息\]，查看视频文件信息如下：  
![播放器文件信息](https://cdn.jsdelivr.net/gh/leichn/leichn.github.io/figure/aspect_radio/potplayer_file_info.png)  
播放器根据视频长宽尺寸可以知道 PAR 是 320:320 = 1:1，播放器也是知道 SAR 的，只是没显示出来 (SAR 是 16:9)，根据 PAR 和 SAR 算出了 DAR 是 16:9。

播放器可以设置播放宽高比例，在 PotPlayer 播放画面上点右键，点击 \[比例\]，可以看到有很多比例可以设置：  
![播放器播放比例设置](https://cdn.jsdelivr.net/gh/leichn/leichn.github.io/figure/aspect_radio/potplayer_radio_setting.png)  
播放器默认使用“输出比例(推荐)”，这个“输出比例”指的就是 DAR 值，还有一个“原始比例”是指 PAR。

不要关闭前面的播放窗口，维持播放窗口是 16:9 的比例不变，改变播放比例为 1:1。在播放画面上点右键，点击 \[比例\] -> \[原始比例\]，切换到“原始比例”模式播放视频，效果如下：  
![播放原始比例](https://cdn.jsdelivr.net/gh/leichn/leichn.github.io/figure/aspect_radio/testsrc_320x320_dar_16_9_ratio_1_1_win_16_9.png)

这是 16:9 的窗口使用 1:1 的比例播放视频的效果。视频内容中的圆变回正圆了，因为我们设置了播放比例为“原始比例”，也就是 PAR 值 1:1。16:9 的窗口按 1:1 的比例播放视频不能完全匹配，视频左右两侧添加了 7/16 画面宽度的黑边，这是 underscan 模式。

不要关闭上一步的播放窗口，维持播放比例为 1:1 不变，改变窗口比例为 1:1。在播放画面上点右键，点击 \[屏幕\] -> \[自定义尺寸设置...\]，将屏幕尺寸设置为 400x400 像素，播放效果如下：

![自定义窗口尺寸400x400](https://cdn.jsdelivr.net/gh/leichn/leichn.github.io/figure/aspect_radio/testsrc_320x320_dar_16_9_ratio_1_1_win_400x400.png)  
这是 1:1 的窗口使用 1:1 的比例播放视频的效果。视频和窗口匹配，不需要切边也不需要补黑边。圆也是正圆，没有变形。这个图是用 400x400 的窗口按 PAR 1:1 比例播放 testsrc\_320x320\_dar\_16\_9.mp4 文件的效果，同样在 400x400 播放窗口按 DAR 1:1 比例播放 testsrc\_320x320.mp4 文件具有和上图完全一样的效果。

### 2.2 scale 滤镜设置视频宽高比

来看一下使用 scale 滤镜缩放视频后，视频宽高比发生了哪些变化。

#### 2.3.1 源中 SAR 有效时 scale 的缩放

用 scale 滤镜将 testsrc\_320x320.mp4 放大到 1280x720 尺寸，命令如下：

    ffmpeg.exe -i .\testsrc_320x320.mp4 -c:v libx264 -vf scale=1280x720 .\testsrc_1280x720.mp4
    

查看一下新生成视频文件的格式，如下：

    PS E:\videos\sar> ffprobe.exe -hide_banner .\testsrc_1280x720.mp4
    Input #0, mov,mp4,m4a,3gp,3g2,mj2, from '.\testsrc_1280x720.mp4':
      Metadata:
        major_brand     : isom
        minor_version   : 512
        compatible_brands: isomiso2avc1mp41
        encoder         : Lavf62.3.100
      Duration: 00:00:20.00, start: 0.000000, bitrate: 146 kb/s
      Stream #0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(progressive), 1280x720 [SAR 9:16 DAR 1:1], 143 kb/s, 25 fps, 25 tbr, 12800 tbn (default)
        Metadata:
          handler_name    : VideoHandler
          vendor_id       : [0][0][0][0]
          encoder         : Lavc62.11.100 libx264
    PS E:\videos\sar>
    

testsrc\_320x320.mp4 视频文件的分辨率是 300x300，PAR 是 1:1，SAR 是 1:1，DAR 是 1:1，DAR 值 1:1 表示视频画面显示出来是方形的。转码后生成的 testsrc\_1280x720.mp4 视频文件，分辨率是 1280x720，PAR 是 1280:720 = 16:9，SAR 是 9:16，DAR 是 1:1，DAR 值 1:1 使得新生成的视频在播放时仍然保持方形。所以这个转码命令里，scale 滤镜一方面调整了分辨率，另一方面调整了 SAR，从而使用得 DAR 和源文件保持一致，缩放后的视频播放并不变形。

播放效果如下：  
![scale_1280x720_dar_1_1](https://cdn.jsdelivr.net/gh/leichn/leichn.github.io/figure/aspect_radio/scale_1280x720_dar_1_1.png)

结论：源中 SAR 有效时，scale 滤镜会不止作了分辨率转换，还会调整 SAR 来致力于使新生成的目标视频不变形。

#### 2.3.2 源中 SAR 无效时 scale 的缩放

先制作一个 SAR 为无效值的视频文件：

    ffmpeg -ss 0:0:0 -t 20 -f lavfi -i testsrc=320x320 -vf setsar=0 -c:v libx264 -pix_fmt yuv420p testsrc_sar_na.mp4
    

查看一下新生成视频文件的格式，如下：

    PS E:\videos\sar> ffprobe.exe -hide_banner .\testsrc_sar_na.mp4
    Input #0, mov,mp4,m4a,3gp,3g2,mj2, from '.\testsrc_sar_na.mp4':
      Metadata:
        major_brand     : isom
        minor_version   : 512
        compatible_brands: isomiso2avc1mp41
        encoder         : Lavf62.3.100
      Duration: 00:00:20.00, start: 0.040000, bitrate: 32 kb/s
      Stream #0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(progressive), 320x320, 29 kb/s, 25 fps, 25 tbr, 12800 tbn, start 0.040000 (default)
        Metadata:
          handler_name    : VideoHandler
          vendor_id       : [0][0][0][0]
          encoder         : Lavc62.11.100 libx264
    PS E:\videos\sar>
    

用 scale 滤镜将 testsrc\_sar\_na.mp4 放大到 1280x720 尺寸，命令如下：

    ffmpeg.exe -i .\testsrc_sar_na.mp4 -c:v libx264 -vf scale=1280x720 .\testsrc_1280x720_2.mp4
    

看一下缩放后生成的新文件的视频格式：

    PS E:\videos\sar> ffprobe.exe -hide_banner .\testsrc_1280x720_2.mp4
    Input #0, mov,mp4,m4a,3gp,3g2,mj2, from '.\testsrc_1280x720_2.mp4':
      Metadata:
        major_brand     : isom
        minor_version   : 512
        compatible_brands: isomiso2avc1mp41
        encoder         : Lavf62.3.100
      Duration: 00:00:20.00, start: 0.000000, bitrate: 146 kb/s
      Stream #0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(progressive), 1280x720, 143 kb/s, 25 fps, 25 tbr, 12800 tbn (default)
        Metadata:
          handler_name    : VideoHandler
          vendor_id       : [0][0][0][0]
          encoder         : Lavc62.11.100 libx264
    PS E:\videos\sar>
    

未打印 SAR 和 DAR。这种情况，播放器会将 SAR 当作 1:1，PAR 为 1280:720 = 16:9，DAR 为 SAR x PAR = 16:9。源中 SAR 无效，scale 滤镜只按命令行中的要求调整了分辨率，目标分辨率宽高比与源分辨率宽高比不一样，视频变形了。播放效果如下：

![scale_1280x720_dar_16_9](https://cdn.jsdelivr.net/gh/leichn/leichn.github.io/figure/aspect_radio/scale_1280x720.png)

结论：源中 SAR 无效时，scale 滤镜按指定的目标分辨率作转换，不关注新生成的视频是否变形。

#### 2.3.3 不改变 SAR 情况下的 scale 的缩放

保持源的宽高比 (PAR) 来缩放目标尺寸，命令如下：

    ffmpeg.exe -i .\testsrc_320x320.mp4 -c:v libx264 -vf scale=-1:720 .\testsrc_x720.mp4
    ffmpeg.exe -i .\testsrc_1280x720.mp4 -c:v libx264 -vf scale=-1:360 .\testsrc_x360.mp4
    

上述命令中“-vf scale=-1:720”表示高度设为 720，锁定源的宽高比自动设置宽度；“-vf scale=-1:360”表示高度设为 360，锁定源的宽高比自动设置宽度。

查看上述两条命令新生成的文件的视频格式：

    PS E:\videos\sar> ffprobe.exe -hide_banner testsrc_x720.mp4
    Input #0, mov,mp4,m4a,3gp,3g2,mj2, from 'testsrc_x720.mp4':
      Metadata:
        major_brand     : isom
        minor_version   : 512
        compatible_brands: isomiso2avc1mp41
        encoder         : Lavf62.3.100
      Duration: 00:00:20.00, start: 0.000000, bitrate: 93 kb/s
      Stream #0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(progressive), 720x720 [SAR 1:1 DAR 1:1], 90 kb/s, 25 fps, 25 tbr, 12800 tbn (default)
        Metadata:
          handler_name    : VideoHandler
          vendor_id       : [0][0][0][0]
          encoder         : Lavc62.11.100 libx264
    PS E:\videos\sar>
    PS E:\videos\sar> ffprobe.exe -hide_banner .\testsrc_x360.mp4
    Input #0, mov,mp4,m4a,3gp,3g2,mj2, from '.\testsrc_x360.mp4':
      Metadata:
        major_brand     : isom
        minor_version   : 512
        compatible_brands: isomiso2avc1mp41
        encoder         : Lavf62.3.100
      Duration: 00:00:20.00, start: 0.000000, bitrate: 67 kb/s
      Stream #0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(progressive), 640x360 [SAR 9:16 DAR 1:1], 64 kb/s, 25 fps, 25 tbr, 12800 tbn (default)
        Metadata:
          handler_name    : VideoHandler
          vendor_id       : [0][0][0][0]
          encoder         : Lavc62.11.100 libx264
    PS E:\videos\sar>
    

注意前面生成的这个文件 testsrc\_1280x720.mp4，其分辨率是 1280 x 720，PAR 是 1280:720=16:9，SAR 是 9:16，DAR 是 1:1。经 scale 滤镜缩放后生成的视频文件 testsrc\_x360.mp4，其分辨率是 640 x 360，PAR 是 640:360 = 16:9，SAR 是 9:16，DAR 是 1:1。可见，源中 SAR 有效的情况下，在 scale 滤镜的参数中将长或宽设置为 -1，scale 滤镜将按源分辨率的宽高比来调整缩放后的视频分辨率，这种情况，scale 滤镜只缩放分辨率，而保持 PAR，SAR，DAR 不变，缩放后视频内容不变形。播放效果如下：  
![scale_1280x720_dar_1_1](https://cdn.jsdelivr.net/gh/leichn/leichn.github.io/figure/aspect_radio/scale_1280x720_dar_1_1_2.png)

结论：当将 scale 滤镜参数的长或宽指定为 -1 时，表示此参数由 scale 滤镜自动计算，使目标分辨率代表的图像宽高比和源分辨率的图像宽高比一样，这种情况只做分辨率转换，不需调整 SAR，视频不变形。

3\. 参考资料
--------

\[1\] [Glossary: DAR, PAR, and SAR](https://lists.ffmpeg.org/pipermail/ffmpeg-user/2020-September/050282.html)，[https://lists.ffmpeg.org/pipermail/ffmpeg-user/2020-September/050282.html](https://lists.ffmpeg.org/pipermail/ffmpeg-user/2020-September/050282.html)  
\[2\] [像素纵横比基础知识](https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/design-tools/expression-studio-2/cc294571\(v=expression.10\))，[https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/design-tools/expression-studio-2/cc294571(v=expression.10)](https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/design-tools/expression-studio-2/cc294571\(v=expression.10\))

4\. 修改记录
--------

2025-09-13 V1.0 初稿