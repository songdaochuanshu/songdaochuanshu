---
layout: post
title: 'Rokid AI眼镜开发 —— 戴上Rokid Glasses的你有多强'
date: "2025-11-25T00:41:27Z"
---
Rokid AI眼镜开发 —— 戴上Rokid Glasses的你有多强
====================================

我们team——看看你有多强队在Rokid 杭州赛中做的一款应用是"战斗力识别"，这款产品是基于Rokid AI glasses的 产品，其后台是在灵珠平台上搭建的工作流。先说下设计思路和主要规则：

主要分四大块功能 :

　　1.眼镜侧按键 → 启动拍照  
　　　　●调系统相机  
　　　　●⾃动抓主体（优先⼈脸，没有就中⼼裁剪）  
　　　　●不做跟踪，先保证流程打通

　　2.调⽤ AI API 计算“战⽃⼒”  
　　　　提示词固定，让 AI 返回：  
　　　　●power\_level (1~9999)  
　　　　●穿戴、⽓场、身形等综合分析  
　　　　●JSON 格式输出

　　3.战⼒值 AR Overlay 渲染  
　　　　●数值浮在⼈物头顶，可以按照等级显示A，S， SS，SSS  
　　　　●简要分析在底部框显示

　　4.⾃动⽣成可分享的战⼒截图  
　　　　●原图 + 战⼒值 + 精简分析  
　　　　●保存 PNG 到眼镜/⼿机端  
　　　　●分享到朋友圈/短视频平台

我们做这款产品的理念是：通过大模型的随机性给用户的精神面貌和穿着打扮来评级，不用评分的方式而用评级可以消除焦虑感带来情绪价值，而且大模型的随机性可以带来很多可变的评论给平淡的生活增添趣味，倡导一种积极向上的生活方式，从而打开一种新的人机交互方式，让生活中充满科技感和游戏感的双重趣味体验。

技术架构：灵珠 Agent 的节点工作流设计  
这款应用的技术实现很简单：  
大的方面分两块：  
(一) 工作流设计  
(二) 图片二次开发和朋友圈分享

  
(一)工作流的设计要根据数据流来划分： 眼镜上传图片→AI识别→动态图生成→分享

1\. 视觉识别模块：接收眼镜端回传的图像，经实践验证，我们采用doubao-seed-1-6-vision-250815

2\. 提示词工程：筛选出符合需求的提示词标准,我们告诉AI一个范围,让AI动态生成提示词去准确识别

3\. 输出战力值 并给出评价

4\. 将评价值： 调用AI接口做二次生成通过UmengSDK分享到朋友圈

灵珠平台一览 ： [https://rizon.rokid.com/space/7572813908721795072/dev](https://rizon.rokid.com/space/7572813908721795072/develop)

[elop](https://rizon.rokid.com/space/7572813908721795072/develop)

 

首先要实现这块功能我们先要去了解Rokid的SDK和API提供了哪些能力，我们需要调用哪些能力，根据需求来拆解对应的功能并拆解成task，一步步落地来实现 。  
经过分析灵珠平台的插件，我们需要选用 ： 1. 拍照节点(文字输入) 2. 大模型（视觉识别大模型 + 评测大模型 ）3. 代码节点(python编码) 4.结束节点（输出在眼镜上可显示的文本）  
来浏览下我们的工作流：开始input : String 由用户对话的文字信息以文本的方式作为入参。

视觉识别模型采用：doubao-seed-1-6-vision-250815  
提示词我们有两部分：系统提示词和用户提示词：

  
提示词的时候思路：我们首先得赋予一个角色：社会观察家，被点评的人：上班族。点评的方式规则：先让大模型输出一套评分机制，我们根据大模型给到的机制去做界限的划分为：A，S，SS，SSS。分别针对不同的等级给与锐评或者鼓励，激励机制可以生成徽章来奖励。提示词筛选大模型结果后我们还需要输出格式，我们规定的是json，根据大模型分析的结果让大模型根据他动态的生成结果去用json来封装字段并指定在对应的工作流输出中，还需要限制模型哪些可输出，哪些不可输出。 我们兵分两路小伙伴分别做了两套提示词：都市白领版和游侠版，PK下实际出来的效果然后再最终决定用游侠版 。

然后大模型自己思考出一套评分标准，我们把标准放到工作流的用户提示词慢慢调试使得判断更加符合我们的需求，我们来看看大模型返回的评分机制如何 ： 

详细的提示词如下：

1.系统提示词：

我是一名社会观察家，我站在办公楼，大街上，我喜欢观察来来往往的人员，我希望看到精神能量强的朋友，分析他们的服装穿搭，给他们打分点赞，请分析我这个想法，给出评分的指标方案，能帮助形成正向的情绪反馈并说一些赞美的话并建立不同类似的“勋章”可以放到AI眼镜的用户头像上。
最后请根据你的评价结果以合适的Json格式输出。

2.用户提示词：

你的任务是：
对输入图片进行深度视觉分析，并输出 Markdown 格式的结构化信息。
这些信息将被第二阶段的“战斗力生成器”读取。
请客观公正的分析，不要从鼓励角度去容忍。
? 你的输出必须为 Markdown + 结构化信息

格式如下（必须严格遵守）：

# ? 目标人物视觉分析报告

## 1. 基本信息
\- 性别（推测）：
\- 年龄段（推测）：
\- 朝向（正面/侧面/背面）：
\- 距离（近/中/远）：

## 2. 精神状态分析
\- 眼神状态（清晰描述）：
\- 面部朝气/疲惫程度：
\- 注意力表现：
\- 精神氛围关键词（2–5 个）：

## 3. 微表情特征
\- 主微表情（如：开心、紧张、自信、疑惑…）：
\- 细节表情（眉毛/嘴角/肌肉）：
\- 情绪可信度（0–1）：

## 4. 穿搭风格分析
\- 整体风格（如：街头/学院/职场/运动/潮流…）：
\- 色彩倾向：
\- 局部亮点（配饰/发型/穿搭亮点）：
\- 上身特点：
\- 下身特点：

## 5. 行为与姿态
\- 站姿/坐姿/动作描述：
\- 是否有动态动作（走路/挥手/跳跃）：
\- 气质指标（稳重/活泼/内敛/锋利 等）：

## 6. 额外可识别信息（如有）
\- 场景背景描述（简短）：
\- 可推断的职业/角色（推测）：
\- 其他有价值特征：

## 7. 可用于战斗力评分的关键标签（非常重要）
以列表输出适合“战斗力计算”的标签，每项不超过 5 字，例如：
\- “精神饱满”
\- “穿搭亮眼”
\- “姿态自信”
\- “强存在感”
\- “有点疲惫”

&gt; 请严格输出 Markdown，不要输出其他解释性内容。

? 你必须遵守的逻辑规则

不做严肃评价
所有分析偏娱乐化，不进行真实价值判断。

。
Markdown 输出必须结构化、简洁清晰
不能输出散文，必须按照预设结构。

所有推测必须加“推测”或“可能”
避免高风险断言。

不生成“战斗力值”
此部分只做视觉特征分析

评价模型提示词 ： 基于视觉识别的提示词做二次筛选

你是一款“AR 战斗力识别器”（Dragon Power Scanner），用于根据视觉标签生成幽默、轻松、可社交传播的“战斗力”分析。所有输出内容均为趣味娱乐，不代表真实评价。
请根据{{detailed\_observation}}：进行分析
【总体要求】
\- 战斗力范围：5—999。
\- 内容风格：轻松、动漫化、游戏化、赛博感、玄幻感。
\- 输出格式必须为严格 JSON，不包含多余文字。
\- 不允许任何身材评价、外貌羞辱、种族/政治/敏感内容。
\- 可以夸张类比，但必须保持正向与无冒犯性。
\- 战斗力来源全部为虚构的“气场能量”“风格能量”“精神状态”等娱乐概念。

【战斗力推理权重】（不展示给用户）
\- 精神气场：30%
- 穿搭完整度与风格感：20%
- 表情能量：15%
- 姿态活力：10%
- 风格一致性：15%
- 随机性：10%

【输出 JSON 格式如下：】
{
  "battle\_power": 数值(5\-999),
  "style\_tags": \["标签1", "标签2", ...\],
  "personality\_summary": "一句话的整体总结（有梗、有风格）",
  "power\_reasoning": "一段幽默解释，说明战斗力为何是这个数值，应包含：穿搭、精神状态、姿态、精神气、额外物品等，但保持趣味性",
  "share\_title": "用于分享卡片的标题（8-12字，易传播）",
  "hud\_effect": "推荐的AR HUD动画效果，如：雷电/火焰/机甲/霓虹/龙息/数据流"
}

【风格标签建议】
可从以下类别中自由组合，但不必全部使用：
\- 气质：稳重型 / 元气型 / 干练型 / 赛博感 / 沉稳输出 / 灵感流
\- 动漫职业：雷属性 / 刺客系 / 守护者 / 法师 / 机甲操控者 / 龙息使者
\- Vibe：城市漫游者 / 情绪输出者 / 社交游侠 / 探索者
\- 趣味类：阳光增益 / 幽默 BUFF / 行走的 WiFi / 关键帧行走

【安全限制】
禁止输出任何：
\- 身体/胖瘦相关描述
\- 肤色、种族、国家刻板印象
\- 年龄猜测
\- 政治敏感内容
\- 性暗示内容
\- 真正的能力/专业能力评价
如原始信息涉及敏感维度，自动忽略并以“趣味风格标签”替代。

智能体上执行的效果：

智能体和工作流分别发布并进入提审状态。  
下一步在眼镜真机上调试 ：下载Rokid AI 手机app .  
1 配网：打开蓝牙和wifi 配对成功之后 2. 点击齿轮图标进入智能体调试页面。点击待调试的智能体。  
随后戴上Rokid眼镜就可以看到效果了。  
我们现场还对伙伴进行了战力值检测，活力满满的他在黑客松现场元气满满呢！

我们把评论信息做了精简调优，并将图片运用AI平台进行提示词二次处理调用SDK上传到后台图片分享网站 ，来看看实现的最终效果吧：

UmengSDK分享朋友圈的关键代码实现 ：

import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.widget.Toast
import com.umeng.socialize.ShareAction
import com.umeng.socialize.UMShareListener
import com.umeng.socialize.bean.SHARE\_MEDIA
import com.umeng.socialize.media.UMImage
import com.umeng.socialize.media.UMWeb
import java.io.File

object WXShareUtils {
    /\*\*
     \* 分享到微信朋友圈
     \* @param context 上下文
     \* @param imagePath 动态AI图片本地路径（如GIF/PNG/JPG）
     \* @param title 分享标题
     \* @param desc 分享描述（战力值评论文案）
     \* @param shareUrl 可选：跳转链接（无则填""）
     \*/
    fun shareToWXCircle(
        context: Context,
        imagePath: String,
        title: String \= "我的战力值分析",
        desc: String \= "我的战力值突破天际！快来挑战～",
        shareUrl: String \= ""
    ) {
        // 校验图片文件是否存在
        val imageFile = File(imagePath)
        if (!imageFile.exists()) {
            Toast.makeText(context, "分享图片不存在", Toast.LENGTH\_SHORT).show()
            return
        }

        // 构建分享图片（支持本地文件路径/Bitmap/网络图片）
        val umImage = UMImage(context, imageFile)
        // 若图片是GIF，需指定类型（Umeng支持GIF分享）
        umImage.setThumbnail(UMImage(context, BitmapFactory.decodeFile(imagePath)))

        // 构建分享内容（朋友圈分享优先用UMWeb，支持图文+链接）
        val umWeb = UMWeb(shareUrl)
        umWeb.title \= title
        umWeb.description \= desc
        umWeb.setThumb(umImage) // 缩略图
        umWeb.setMedia(umImage) // 主图（动态AI图片）

        // 执行分享
        ShareAction(context)
            .setPlatform(SHARE\_MEDIA.WEIXIN\_CIRCLE) // 指定朋友圈平台
            .withMedia(umWeb)
            .setCallback(object : UMShareListener {
                // 分享开始回调
                override fun onStart(platform: SHARE\_MEDIA?) {
                    Toast.makeText(context, "开始分享...", Toast.LENGTH\_SHORT).show()
                }

                // 分享成功回调
                override fun onResult(platform: SHARE\_MEDIA?) {
                    Toast.makeText(context, "朋友圈分享成功", Toast.LENGTH\_SHORT).show()
                }

                // 分享失败回调
                override fun onError(platform: SHARE\_MEDIA?, t: Throwable?) {
                    val errorMsg \= t?.message ?: "分享失败"
                    Toast.makeText(context, "分享失败：$errorMsg", Toast.LENGTH\_SHORT).show()
                }

                // 分享取消回调
                override fun onCancel(platform: SHARE\_MEDIA?) {
                    Toast.makeText(context, "已取消分享", Toast.LENGTH\_SHORT).show()
                }
            })
            .share() // 触发分享
    }

    /\*\*
     \* 重载方法：直接传入Bitmap（动态AI图片生成后的Bitmap）
     \*/
    fun shareToWXCircle(
        context: Context,
        bitmap: Bitmap,
        title: String \= "我的战力值分析",
        desc: String \= "我的战力值突破天际！快来挑战～",
        shareUrl: String \= ""
    ) {
        val umImage \= UMImage(context, bitmap)
        umImage.setThumbnail(UMImage(context, bitmap))

        val umWeb \= UMWeb(shareUrl)
        umWeb.title \= title
        umWeb.description \= desc
        umWeb.setThumb(umImage)
        umWeb.setMedia(umImage)

        ShareAction(context)
            .setPlatform(SHARE\_MEDIA.WEIXIN\_CIRCLE)
            .withMedia(umWeb)
            .setCallback(object : UMShareListener {
                override fun onStart(platform: SHARE\_MEDIA?) {
                    Toast.makeText(context, "开始分享...", Toast.LENGTH\_SHORT).show()
                }

                override fun onResult(platform: SHARE\_MEDIA?) {
                    Toast.makeText(context, "朋友圈分享成功", Toast.LENGTH\_SHORT).show()
                }

                override fun onError(platform: SHARE\_MEDIA?, t: Throwable?) {
                    val errorMsg \= t?.message ?: "分享失败"
                    Toast.makeText(context, "分享失败：$errorMsg", Toast.LENGTH\_SHORT).show()
                }

                override fun onCancel(platform: SHARE\_MEDIA?) {
                    Toast.makeText(context, "已取消分享", Toast.LENGTH\_SHORT).show()
                }
            })
            .share()
    }
}

微信回调Activity :

package  power

import android.content.Intent
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.umeng.socialize.UMShareAPI

class WXEntryActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 处理微信回调
        UMShareAPI.get(this).onActivityResult(
            intent,
            intent.getIntExtra("key\_request\_code", 0),
            \-1,
            null
        )
        finish() // 处理完立即关闭Activity
    }

    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        setIntent(intent)
        UMShareAPI.get(this).onActivityResult(
            intent,
            intent?.getIntExtra("key\_request\_code", 0) ?: 0,
            \-1,
            null
        )
        finish()
    }
}

页面中调用分享（示例：动态 AI 图片生成后点击分享按钮）
import android.os.Bundle
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import java.io.File

class ShareActivity : AppCompatActivity() {
    // 动态AI图片本地路径（替换为实际生成的图片路径）
    private val aiImagePath = "/sdcard/Android/data/你的应用包名/files/ai\_power\_image.gif"

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity\_share)

        // 一键分享按钮点击事件
        findViewById&lt;View&gt;(R.id.btn\_share\_circle).setOnClickListener {
            // 方式1：通过图片路径分享
            WXShareUtils.shareToWXCircle(
                context \= this,
                imagePath \= aiImagePath,
                title \= "我的战力值分析",
                desc \= intent.getStringExtra("power\_comment") ?: "我的战力值850，暴击拉满！",
                shareUrl \= "https://你的域名/power\_analysis.html" // 可选跳转链接
            )

            // 方式2：若图片是Bitmap（如动态AI图生成后直接返回Bitmap）
            // val aiBitmap = intent.getParcelableExtra&lt;Bitmap&gt;("ai\_bitmap")
            // aiBitmap?.let {
            //     WXShareUtils.shareToWXCircle(this, it, "我的战力值分析", "战力值850！")
            // }
        }
    }

    // 处理ActivityResult（Android 10+需重写）
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        UMShareAPI.get(this).onActivityResult(requestCode, resultCode, data)
    }
}

View Code

现场小伙伴检测的战斗力最终效果图：

满满的科技感，是不是觉得很有意思呢哈哈。生活中充满了各种奇思妙想，我们要善于发掘，和Rokid Glasses的一次激情碰撞是那么的充满科技感，这是一个连接现实世界和虚拟世界的桥梁，让真实的生活充满魔幻！

转载请注明原作者，原文出处：**https://forum.rokid.com/post/detail/2441**