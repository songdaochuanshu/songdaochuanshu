---
layout: post
title: '并发编程 - 线程同步（八）之自旋锁SpinLock'
date: "2025-02-18T00:35:55Z"
---
并发编程 - 线程同步（八）之自旋锁SpinLock
==========================

SpinLock是C#中轻量级锁，通过自旋避免线程上下文切换。传递时需小心，用ref避免副本问题。适用于高并发且锁持有时间短的场景，避免单核CPU。可自己实现简单自旋锁。

前面对互斥锁Monitor进行了详细学习，今天我们将继续学习，一种更轻量级的锁——自旋锁SpinLock。

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250217173156220-610393625.jpg)

在 C# 中，SpinLock是一个高效的自旋锁实现，用于提供一种轻量级的锁机制。SpinLock通过在等待锁的过程中执行自旋（即不断尝试获取锁）来避免线程上下文切换，从而减少系统开销。

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250217173203925-272654743.png)

SpinLock是一个结构体，使用上和Monitor类很像，都是通过Enter或TryEnter方法持有锁，同时默认支持lockTaken模式，然后通过Exit释放锁。

_**01**_、使用示例
=============

下面我们通过启动10个线程，使用SpinLock锁分别递增共享变量\_counter，最后再打印出共享变量\_counter，代码如下：

    public class SpinLockExample
    {
        //自旋锁
        private static SpinLock _spinLock = new SpinLock();
        //共享资源计数器
        private static int _counter = 0;
        //计数
        public void Count()
        {
            var lockTaken = false;
            try
            {
                //持有锁
                _spinLock.Enter(ref lockTaken);
                //访问并修改共享资源
                _counter++;
                var threadId = Thread.CurrentThread.ManagedThreadId;
                Console.WriteLine($"线程号：{threadId} 递增共享变量 _counter 为：{_counter}");
            }
            finally
            {
                if (lockTaken)
                {
                    //释放锁
                    _spinLock.Exit();
                }
            }
        }
        //打印
        public void Print()
        {
            Console.WriteLine($"---------------------------------------");
            Console.WriteLine($"_counter 最终值为：{_counter}");
        }
    }
    public static void SpinLockRun()
    {
        var example = new SpinLockExample();
        //启动10个线程
        var threads = new Thread[10];
        for (var i = 0; i < threads.Length; i++)
        {
            threads[i] = new Thread(example.Count);
            threads[i].Start();
        }
        for (var i = 0; i < threads.Length; i++)
        {
            threads[i].Join();
        }
        example.Print();
    }
    

不用看也可以预测出结果为10，执行结果如下：

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250217173214595-625361874.png)

另外TryEnter方法也和Monitor类同样支持设置超时时间。

_**02**_、小心传递SpinLock实例
=======================

在传递SpinLock实例时，需要十分小心，这是因为SpinLock是结构体即为值类型，当通过值传递，会导致创建该结构体的副本，复制一个新的实例，而不是传递引用。

如下示例代码：

    public class CopySpinLockExample
    {
        public void Method1(int thread, SpinLock lockCopy)
        {
            var lockTaken = false;
            //尝试获取锁
            lockCopy.Enter(ref lockTaken);
            if (lockTaken)
            {
                Console.WriteLine($"线程 {thread}，成功获取锁");
            }
            else
            {
                Console.WriteLine("线程 {thread}，未获取到锁");
            }
        }
    }
    public static void CopySpinLockRun()
    {
        var example = new CopySpinLockExample();
        SpinLock spinLock = new SpinLock();
        example.Method1(1, spinLock);
        example.Method1(2, spinLock);
        spinLock.Exit();
        Console.WriteLine("主线程，释放锁");
    }
    

这段代码有两个问题是：

1.方法Method1的两次调用中的lockCopy是各不相同的锁，即会导致两次调用都能获取到锁；

2.方法Method1中的lockCop和主方法中spinLock是两个不同的锁，会导致主方法释放锁异常；

我们可以看看代码执行结果：

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250217173224513-553510882.png)

方法两次调用都成功获取锁，同时最后释放锁时抛出了异常。和我们上面说的两个问题完全一致。

而要解决这个问题也很简单，只需要把Method1方法的SpinLock参数前加上ref即可。代码如下：

    public class RefCopySpinLockExample
    {
        public void Method1(int thread, ref SpinLock lockCopy)
        {
            var lockTaken = false;
            //尝试获取锁
            lockCopy.Enter(ref lockTaken);
            if (lockTaken)
            {
                Console.WriteLine($"线程 {thread}，成功获取锁");
                lockCopy.Exit();
                Console.WriteLine($"线程 {thread}，释放锁");
            }
            else
            {
                Console.WriteLine("线程 {thread}，未获取到锁");
            }
        }
        public void Method2(int thread, ref SpinLock lockCopy)
        {
            var lockTaken = false;
            //尝试获取锁
            lockCopy.Enter(ref lockTaken);
            if (lockTaken)
            {
                Console.WriteLine($"线程 {thread}，成功获取锁");
            }
            else
            {
                Console.WriteLine("线程 {thread}，未获取到锁");
            }
        }
    }
    public static void RefCopySpinLockRun()
    {
        var example = new RefCopySpinLockExample();
        SpinLock spinLock = new SpinLock();
        example.Method1(1, ref spinLock);
        example.Method2(2, ref spinLock);
        spinLock.Exit();
        Console.WriteLine("主线程，释放锁");
    }
    

执行结果如下：

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250217173235242-958324669.png)

从结果上可以发现Method中和主方法中的SpinLock锁都是同一个了。

_**03**_、实现原理
=============

从上面代码可以发现从使用上来说，SpinLock和互斥锁Monitor基本一样，那为什么还要SpinLock呢？

首先互斥锁Monitor在获取锁时会阻塞线程，同时线程会进行上下文切换，把CPU资源让出来给其他线程使用，直到锁可用。从这里也可以看出互斥锁Monitor适用锁竞争时间较长的场景，否则线程上下文切换比等待资源消耗代价更高就不划算了。

针对上面提到的问题，就引发了需要一种非阻塞线程的锁方案，因此SpinLock就应用而生。

如何实现非阻塞线程呢？

首先我们需要理解非阻塞的意义，它是为了解决进行线程上下文切换的代价比锁的等待代价更大的问题。说白了就是不要让线程进行上下文切换，比如最简单粗暴的方式就是直接使用while(true){}，使得线程一直处于活动状态。

而SpinLock底层实现原理的确通过使用while(true){}，使得线程原地停留且又不阻塞线程。因为while(true)自动循环的特点才叫自旋锁。当然SpinLock底层实现不止这么简单，比如还用到了原子操作Interlocked.CompareExchange。

总结下来SpinLock 的工作原理，大致分为以下两步：

1.当前线程尝试获取锁，如果获取成功，进入同步代码块。

2.如果未能取锁（即锁已经被另一个线程持有），则当前线程会在一个循环（自旋）中重复尝试，直到获取到锁。

SpinLock主要优势在于它不会将线程挂起即不会发生线程上下文切换，而是让线程在一个循环（自旋）中等待，直到锁被释放后再获取。同样因为线程一直自旋等待，如果线程需要等待时间很长又会导致CPU占用过高以及资源浪费。

结合SpinLock实现原理，有如下建议：

1.在需要大量锁（高并发）并且锁持有时间又非常短的场景下，特别适合使用SpinLock。

2.避免在单核CPU上使用SpinLock，因为自旋等待会浪费CPU资源。

_**04**_、实现一个简单的自旋锁
===================

下面我们可以根据SpinLock实现原理来自己实现一个简单的自旋锁。

大致思路如下：

1.通过在while(true)循环中，使用原子操作Interlocked.CompareExchange进行设置锁，从而实现持有锁方法Enter；

2.通过直接标记锁状态为未锁定状态，来实现锁释放方法Exit；

具体代码如下：

    public class MySpinLock
    {
        // 0 - 未锁定, 1 - 锁定
        private volatile int _isLocked = 0;  
        //获取锁
        public void Enter()
        {
            while (true)
            {
                //使用原子操作检查和设置锁
                if (Interlocked.CompareExchange(ref _isLocked, 1, 0) == 0)
                {
                    //成功获得锁
                    return; 
                }
            }
        }
        //释放锁
        public void Exit()
        {
            //释放锁，直接设置为未锁定状态
            _isLocked = 0;
        }
    }
    

然后把使用示例中的代码SpinLock替换为MySpinLock即可验证我们自己的自旋锁实现，运行结果如下，基本和原生的SpinLock功能一致。

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250217173245009-2083372198.png)

_**注**_：测试方法代码以及示例源码都已经上传至代码库，有兴趣的可以看看。[https://gitee.com/hugogoos/Planner](https://gitee.com/hugogoos/Planner)