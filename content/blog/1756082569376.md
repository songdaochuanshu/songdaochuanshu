---
layout: post
title: 'Solon StateMachine 实现状态机使用示例详解'
date: "2025-08-25T00:42:49Z"
---
Solon StateMachine 实现状态机使用示例详解
==============================

Solon StateMachine是基于Solon Framework的状态机框架，用于管理复杂的状态流转场景。摘要如下： 状态机通过定义状态集合、转移规则和触发事件，精确控制系统行为逻辑。

什么是状态机
------

状态机是计算机科学中的**核心建模工具**，用于描述对象在其生命周期内状态变化的逻辑模型。它通过定义**有限状态集合**、**状态转移规则**和**触发事件**，精确控制系统的行为逻辑。

Solon StateMachine 是 Solon Framework 提供的一个功能强大的状态机框架，可实现复杂的工作流、订单管理等需要状态流转的场景。通过对状态、事件和转移的管理，开发者能够构建出简洁而灵活的状态机逻辑。

使用示例
----

#### 1、导入maven依赖

    <dependency>
        <groupId>org.noear</groupId>
        <artifactId>solon-statemachine</artifactId>
        <version>3.5.0</version>
    </dependency>
    

#### 2、创建订单状态枚举类

    import org.noear.solon.statemachine.State;
    
    public enum OrderStatus implements State{
        WAITING_PAYMENT,//待支付
        WAITING_RECEIVE,//待取货
        FINISHED,//已完成
        CANCELED;//已取消
    }
    

#### 3、创建订单转悠事件枚举类

    import org.noear.solon.statemachine.Event;
    
    public enum OrderEvent implements Event {
        CREATE_ORDER,//创建订单
        PAY_ORDER,//支付订单
        RECEIVE_ORDER,//取货
        CANCEL_ORDER,//取消订单
        FINISH_ORDER//完成订单
    }
    

#### 4、创建订单实体，并实现 EventContext 接口（也可以不实现，改用 EventContext.of(...)）

    public class Order implements EventContext<OrderStatus, Order> {
        private final String orderId;
        private OrderStatus status;
    
        public Order(String orderId, OrderStatus status) {
            this.orderId = orderId;
            this.status = status;
        }
    
        public String getOrderId() {
            return orderId;
        }
    
        public OrderStatus getStatus() {
            return status;
        }
    
        public void setStatus(OrderStatus status) {
            this.status = status;
        }
    
        // for EventContext
    
        @Override
        public OrderStatus getCurrentState() {
            return status;
        }
    
        @Override
        public Order getPayload() {
            return this;
        }
    }
    

#### 5、定义订单状态机组件，并添加状态转移规则。这里是重点了

Solon StateMachine 不管理当前状态，不涉及持久化。具有可复用、多线程安全特性。

    import org.noear.solon.annotation.Managed;
    import org.noear.solon.statemachine.StateMachine;
    
    @Managed
    public class OrderStateMachine extends StateMachine<OrderStatus, OrderEvent,Order> {
        public OrderStateMachine() {
            // 订单待支付 -> 待取货
            addTransition(t -> t
                    .from(OrderStatus.WAITING_PAYMENT)
                    .to(OrderStatus.WAITING_RECEIVE)
                    .on(OrderEvent.PAY_ORDER)
                    .then(c -> c.getPayload().setStatus(c.getTo())));
    
            // 订单待取货 -> 已完成
            addTransition(t -> t
                    .from(OrderStatus.WAITING_RECEIVE)
                    .to(OrderStatus.FINISHED)
                    .on(OrderEvent.FINISH_ORDER)
                    .then(c -> c.getPayload().setStatus(c.getTo())));
    
            // 订单待支付 -> 已取消
            addTransition(t -> t
                    .from(OrderStatus.WAITING_PAYMENT)
                    .to(OrderStatus.CANCELED)
                    .on(OrderEvent.CANCEL_ORDER)
                    .then(c -> c.getPayload().setStatus(c.getTo())));
        }
    }
    

#### 6、创建调用示例服务

Solon StateMachine 在发送事件时，通过 EventContext 传递当前状态和装载。

    @Managed
    public class OrderService {
        @Inject
        private OrderStateMachine orderStateMachine;
    
        //支付
        public Order pay() {
            Order order = new Order("1", OrderStatus.WAITING_RECEIVE);
    
            System.out.println("尝试支付，订单号：" + order.getOrderId());
    
            try {
                //事件： 支付, 状态转换：待支付 → 待发货
                orderStateMachine.sendEvent(OrderEvent.PAY_ORDER, order);
    
                System.out.println("支付成功，订单号：" + order.getOrderId());
            } catch (Exception ex) {
                System.out.println("支付失败, 状态异常，订单号：" + order.getOrderId());
            }
    
            return order;
        }
    }