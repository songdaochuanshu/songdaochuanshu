---
layout: post
title: 'Rust/C/C++ 混合构建 - Buck2构建工具一探究竟'
date: "2025-09-10T00:38:52Z"
---
Rust/C/C++ 混合构建 - Buck2构建工具一探究竟
===============================

Buck2 构建工具一探究竟
==============

Buck2是Meta公司在2023年开源的多语言构建工具，旨在对2013年开源Buck进行全方面的升级改造。目前支持C/C++, Java, Go, Rust, Python, Haskell等语言项目的构建。

主要特性
----

1.  Buck2 的执行速度是Buck1的两倍，核心逻辑使用Rust语言编写。
2.  Buck2 支持C++，Python，Rust构建，但它的设计与语言无关。
3.  Buck2 使用Starlark来编写构建规则，这是一门基于Python增强后的语言，任何语言都可以用一套语言规则来编写构建规则。Buck1的构建规则是直接包含在核心中，Bazel则是把C++/Java都写在了核心里
4.  Buck2 支持远程执行并且是首选，本地执行也被当作一种特殊的远程执行 （这意味着可以预先计算目录哈希等内容，准备发送到远程执行，从而提高效率。）
5.  Buck2的实现是基于虚拟文件系统(virtual file systems)来的。好处是我们可以使虚拟文件系统与完整检出一样快，但具有更快检出和更低磁盘使用率的优点

关键概念
----

1.  **构建规则（build rule）** 构建规则描述如何从一组输入文件生成输出文件。大多数构建规则特定于特定语言或平台。例如，您可以使用 cxx\_binary 规则创建 C++ 二进制文件，但可以使用 android\_binary 规则创建 Android APK。
2.  **构建目标（build target）** 构建目标是唯一标识构建规则的字符串。它可以被认为是 Buck 项目中构建规则的 URI。
3.  **构建文件 （build file）** 构建文件定义一个或多个构建规则。在 Buck 中，构建文件通常命名为 `BUCK`。 `BUCK` 文件类似于`Make`实用程序使用的`Makefile`。在您的项目中，每个可构建的软件单元（例如二进制文件或库）通常都有一个单独的`BUCK`文件。对于大型项目，您可能有数百个`BUCK`文件。
4.  **Buck包** Buck 包包含： Buck 构建文件（BUCK 文件）、与 BUCK 文件位于同一目录或子目录中的所有文件（例如源文件和头文件），前提是这些子目录本身不包含 BUCK 文件。换句话说，BUCK 文件定义了包的根，但 Buck 包可能不包含其所有子目录，因为 Buck 包不重叠或包含其他 Buck 包。

工具链
---

Buck2支持多种语言，所有这些都需要一个工具链，人们可以自定义他们的专用工具链，或者使用官方的默认工具链。默认的工具链由buck2通过`buck2 init`命令生成，即当前目录会生成一个toolchains文件夹。

Playground
----------

如何用Buck2来构建有Rust与C的混合项目， 下面是一个具体项目的主要步骤。

这是一个Rust二进制项目，rust主文件通过链接到C库来访问定义在c中的函数，流程大概几步

1.  通过 `cargo new my-project` 创建项目
2.  修改源码，在`my-project/src` 目录下新增`greet.c`， 并加入

    #include <stdio.h>
    
    void greet(const char *name)
    {
        printf("Hello, %s!\n", name);
    }
    

在`my-project/src/main.rs` 通过FFI让rust访问`greet.c`定义的greet函数

    use std::ffi::CString;
    
    extern "C" {
        fn greet(name: *const std::os::raw::c_char);
    }
    
    fn main() {
        unsafe {
            let c = "world".to_string();
            let c = CString::new(c).unwrap();
            greet(c.as_ptr());
        }
    }
    

1.  编译动态库，`gcc greet.c -shared -o libgreet.so`
2.  在`my-project`下新增`build.rs`, 并加入

    fn main() {
        // dynatic link against libgreet.so'
        // NB: the linker actually looks for a file with a 'lib' prefix
        println!("cargo::rustc-link-search=native=./src");
        println!("cargo::rustc-link-lib=dylib=greet");
        // This will add absolute path of the dynamic library to the rpath
        println!("cargo:rustc-link-arg=-Wl,-rpath,$ORIGIN/../../src");
    }
    

1.  执行`cargo run`, 结果输出`Hello, world!`

以上就是用`Cargo`来构建Rust/C 混合项目的主要步骤了，其主要是通过`build.rs`来实现rust与其他语言的构建，针对c/c++构建，社区提供了`cc`库简化了一些步骤。

如果Buck2来替代`build.rs`, 这不仅可以简化步骤，并且支持更多语言和提供更一致的构建体验

假设安装了buck2，则项目根目录执行`buck2 init`， 这会生成`BUCK`配置文件，需要通过`BUCK`编写规则告诉buck2怎么构建项目

1.  在`BUCK`配置中增加

    cxx_library(
        name = "greet",
        srcs = glob(
            ["src/*.c"],
        )
    )
    
    rust_binary(
        name = "main",
        srcs = glob(
            ["src/*.rs"],
        ),
        deps = [":greet"],
    )
    

在cxx\_library里定一个了构建任务greet，目标是生成动态链接库`lib_greet.so`, 然后定义一个二进制构建任务main, 在字段deps中把前者greet作为它的依赖项。

1.  执行 `buck2 run :main` 即可输出`Hello, world`

    Starting new buck2 daemon...
    Connected to new buck2 daemon.
    Build ID: d3cf0117-a17d-4266-9637-c01f932afb55
    Jobs completed: 76. Time elapsed: 0.9s.
    Cache hits: 0%. Commands: 3 (cached: 0, remote: 0, local: 3)
    BUILD SUCCEEDED
    Hello, world!
    

总结
--

Buck2是一个支持多语言混合构建的集成构建工具，在某种程度上可以替代Cargo项目用来支持其他语言构建用的`build.rs`，让构建提供更一致的构建体验。