---
layout: post
title: '.NET Core 中如何构建一个弹性的 HTTP 请求机制？'
date: "2025-01-22T00:35:34Z"
---
.NET Core 中如何构建一个弹性的 HTTP 请求机制？
===============================

### 1\. 理解弹性 HTTP 请求机制

#### 什么是弹性？

弹性是指系统在面对故障或异常情况时，能够保持或快速恢复到正常状态的能力。在 HTTP 请求的上下文中，弹性意味着当请求失败时，系统能够自动采取一系列措施（如重试、降级、断路等）来确保请求最终成功或优雅地处理失败。

#### 为什么需要弹性 HTTP 请求机制？

在分布式系统中，服务间的依赖关系复杂，任何一个服务的故障都可能导致整个系统的不可用。弹性 HTTP 请求机制可以帮助我们：

*   **提高系统的可用性**：通过重试、断路等策略，减少因瞬态故障导致的系统不可用。
*   **增强用户体验**：通过快速恢复和优雅降级，减少用户感知到的故障时间。
*   **降低运维成本**：通过自动化处理故障，减少人工干预的需求。

#### 弹性机制的核心原则

*   **重试（Retry）**：在请求失败时，自动重试一定次数。
*   **断路器（Circuit Breaker）**：当失败率达到一定阈值时，暂时停止请求，避免雪崩效应。
*   **超时（Timeout）**：设置请求的超时时间，避免长时间等待。
*   **降级（Fallback）**：当请求失败时，提供备用的响应或行为。
*   **负载均衡（Load Balancing）**：将请求分散到多个服务实例，避免单点故障。

### 2\. .NET Core 中的 HTTP 请求基础

#### HttpClient 的使用

在 .NET Core 中，`HttpClient` 是用于发送 HTTP 请求和接收 HTTP 响应的主要类。以下是一个简单的 `HttpClient` 使用示例：

    using System;
    using System.Net.Http;
    using System.Threading.Tasks;
    
    public class HttpClientApplication
    {
        public static async Task Main(string[] args)
        {
            using (HttpClient client = new HttpClient())
            {
                // 发送 GET 请求
                HttpResponseMessage response = await client.GetAsync("https://******");
                if (response.IsSuccessStatusCode)
                {
                    // 读取响应内容
                    string content = await response.Content.ReadAsStringAsync();
                    Console.WriteLine(content);
                }
                else
                {
                    // 输出错误状态码
                    Console.WriteLine($"Error: {response.StatusCode}");
                }
            }
        }
    }
    

#### HttpClientFactory 的引入

`HttpClient` 的直接使用存在一些问题，如 DNS 更新问题和套接字耗尽问题。为了解决这些问题，.NET Core 引入了 `HttpClientFactory`，它提供了更好的 `HttpClient` 生命周期管理和配置选项。

在 `Startup.cs` 中配置 `HttpClientFactory`：

    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            // 注册 HttpClientFactory 并添加一个命名的 HttpClient
            services.AddHttpClient("ResilientClient", client =>
            {
                client.BaseAddress = new Uri("https://******"); // 设置基础地址
                client.DefaultRequestHeaders.Add("Accept", "application/json"); // 设置默认请求头
            });
        }
    
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            // 其他中间件配置
        }
    }
    

在控制器或服务中使用 `HttpClientFactory`：

    using Microsoft.AspNetCore.Mvc;
    using System.Net.Http;
    using System.Threading.Tasks;
    
    [ApiController]
    [Route("[controller]")]
    public class ResilientController : ControllerBase
    {
        private readonly IHttpClientFactory _httpClientFactory;
    
        public ResilientController(IHttpClientFactory httpClientFactory)
        {
            _httpClientFactory = httpClientFactory;
        }
    
        [HttpGet]
        public async Task<IActionResult> Get()
        {
            // 通过名称获取 HttpClient 实例
            var client = _httpClientFactory.CreateClient("ResilientClient");
    
            // 发送 GET 请求
            var response = await client.GetAsync("posts/list");
            if (response.IsSuccessStatusCode)
            {
                var content = await response.Content.ReadAsStringAsync();
                return Ok(content); // 返回成功响应
            }
    
            return StatusCode((int)response.StatusCode); // 返回错误状态码
        }
    }
    

#### 优点：

*   **生命周期管理**：`HttpClientFactory` 自动管理 `HttpClient` 的生命周期，避免套接字耗尽问题。
*   **配置灵活**：可以为不同的 API 配置不同的 `HttpClient` 实例。
*   **DNS 更新支持**：`HttpClientFactory` 会定期刷新 DNS 缓存。

### 3\. 实现基本的重试机制

#### 简单的重试逻辑

在没有使用任何库的情况下，我们可以通过简单的循环来实现重试逻辑：

    public async Task<string> GetDataWithRetryAsync(int maxRetries = 3)
    {
        int retryCount = 0;
        while (true)
        {
            try
            {
                // 发送 GET 请求
                HttpResponseMessage response = await _httpClient.GetAsync("data");
                response.EnsureSuccessStatusCode(); // 确保请求成功
                return await response.Content.ReadAsStringAsync(); // 返回响应内容
            }
            catch (HttpRequestException)
            {
                retryCount++;
                if (retryCount >= maxRetries)
                {
                    throw; // 超过重试次数后抛出异常
                }
            }
        }
    }
    

#### 使用 Polly 实现重试策略

Polly 是一个流行的 .NET 弹性库，提供了丰富的策略来实现重试、断路、超时等功能。以下是一个使用 Polly 实现重试策略的示例：

    using Polly;
    using Polly.Retry;
    
    public class RetryService
    {
        private readonly HttpClient _httpClient;
        private readonly AsyncRetryPolicy<HttpResponseMessage> _retryPolicy;
    
        public RetryService(HttpClient httpClient)
        {
            _httpClient = httpClient;
            // 配置重试策略：最多重试 3 次，每次等待 2 秒
            _retryPolicy = Policy
                .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode) // 处理失败响应
                .Or<HttpRequestException>() // 处理请求异常
                .WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))); // 指数退避
        }
    
        public async Task<string> GetDataWithRetryAsync()
        {
            // 执行重试策略
            HttpResponseMessage response = await _retryPolicy.ExecuteAsync(() => _httpClient.GetAsync("data"));
            response.EnsureSuccessStatusCode(); // 确保请求成功
            return await response.Content.ReadAsStringAsync(); // 返回响应内容
        }
    }
    

#### 重试策略的配置

Polly 允许我们灵活地配置重试策略，包括重试次数、重试间隔等。以下是一个配置指数退避重试策略的示例：

    _retryPolicy = Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .Or<HttpRequestException>()
        .WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
    

### 4\. 处理瞬态故障

#### 什么是瞬态故障？

瞬态故障是指那些暂时性的、通常会自动恢复的故障。例如，网络抖动、服务暂时不可用等。瞬态故障的特点是它们通常是短暂的，重试后可能会成功。

#### 常见的瞬态故障类型

*   **网络抖动**：网络连接不稳定导致的请求失败。
*   **服务暂时不可用**：目标服务因负载过高或维护而暂时不可用。
*   **资源限制**：目标服务因资源限制（如 CPU、内存）而暂时无法处理请求。

#### 使用 Polly 处理瞬态故障

Polly 提供了多种策略来处理瞬态故障，包括重试、断路、超时等。以下是一个结合重试和断路策略的示例：

      // 定义重试策略，当HTTP请求失败时进行重试
      var retryPolicy = Policy
          .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
          .Or<HttpRequestException>()
          // 设置重试次数为3次，每次重试的间隔时间按指数递增（2^retryAttempt秒）
          .WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
    
      // 定义熔断策略，当连续失败次数达到阈值时，熔断一段时间
      var circuitBreakerPolicy = Policy
          .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
          .Or<HttpRequestException>()
          .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)); // 设置熔断条件：连续失败5次后，熔断30秒
    
      // 将重试策略和熔断策略组合成一个综合策略
      var combinedPolicy = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
    
      HttpResponseMessage response = await combinedPolicy.ExecuteAsync(() => _httpClient.GetAsync("data"));
    
    

### 5\. 实现断路器模式

#### 断路器模式的概念

断路器模式是一种用于防止系统因依赖服务故障而崩溃的设计模式。当依赖服务的失败率达到一定阈值时，断路器会打开，停止所有请求，直到依赖服务恢复。

#### 使用 Polly 实现熔断策略

Polly 提供了 `CircuitBreaker` 策略来实现熔断策略。以下是一个使用 Polly 实现熔断策略的示例：

    var circuitBreakerPolicy = Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .Or<HttpRequestException>()
        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)); // 连续失败 5 次后，断路器打开 30 秒
    
    HttpResponseMessage response = await circuitBreakerPolicy.ExecuteAsync(() => _httpClient.GetAsync("data"));
    

#### 配置熔断策略参数

Polly 允许我们配置熔断策略的参数，包括失败次数阈值、断路时间等。以下是一个配置断路器的示例：

    var circuitBreakerPolicy = Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .Or<HttpRequestException>()
        .CircuitBreakerAsync(
            exceptionsAllowedBeforeBreaking: 5, // 允许的失败次数
            durationOfBreak: TimeSpan.FromSeconds(30) // 断路时间
        );
    

### 6\. 超时和超时策略

#### 设置请求超时

在 `HttpClient` 中，我们可以通过 `Timeout` 属性设置请求的超时时间：

    _httpClient.Timeout = TimeSpan.FromSeconds(10); // 设置超时时间为 10 秒
    

#### 使用 Polly 实现超时策略

Polly 提供了 `Timeout` 策略来实现超时控制。以下是一个使用 Polly 实现超时策略的示例：

    var timeoutPolicy = Policy.TimeoutAsync<HttpResponseMessage>(TimeSpan.FromSeconds(10)); // 设置超时时间为 10 秒
    
    HttpResponseMessage response = await timeoutPolicy.ExecuteAsync(() => _httpClient.GetAsync("data"));
    

#### 超时与重试的结合

我们可以将超时策略与重试策略结合使用，以应对因超时导致的请求失败：

    var retryPolicy = Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .Or<HttpRequestException>()
        .WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))); // 重试策略
    
    var timeoutPolicy = Policy.TimeoutAsync<HttpResponseMessage>(TimeSpan.FromSeconds(10)); // 超时策略
    
    var combinedPolicy = Policy.WrapAsync(retryPolicy, timeoutPolicy); // 组合策略
    
    HttpResponseMessage response = await combinedPolicy.ExecuteAsync(() => _httpClient.GetAsync("data"));
    

### 7\. 负载均衡与请求分流

#### 负载均衡的基本概念

负载均衡是指将请求分散到多个服务实例，以避免单点故障和提高系统的可扩展性。常见的负载均衡策略包括轮询、随机、加权轮询等。

#### 在 .NET Core 中实现负载均衡

在 .NET Core 中，我们可以通过配置多个 `HttpClient` 实例来实现负载均衡。以下是一个简单的负载均衡示例：

    public class LoadBalancer
    {
        private readonly List<HttpClient> _httpClients;
        private readonly Random _random = new Random();
    
        public LoadBalancer(IHttpClientFactory httpClientFactory)
        {
            _httpClients = new List<HttpClient>
            {
                httpClientFactory.CreateClient("ServiceInstance1"), // 实例 1
                httpClientFactory.CreateClient("ServiceInstance2"), // 实例 2
                httpClientFactory.CreateClient("ServiceInstance3")  // 实例 3
            };
        }
    
        public async Task<string> GetDataAsync()
        {
            // 随机选择一个 HttpClient 实例
            HttpClient client = _httpClients[_random.Next(_httpClients.Count)];
            HttpResponseMessage response = await client.GetAsync("data");
            response.EnsureSuccessStatusCode();
            return await response.Content.ReadAsStringAsync();
        }
    }
    

#### 请求分流的策略

请求分流是指根据某些条件（如请求内容、用户身份等）将请求分发到不同的服务实例。以下是一个简单的请求分流示例：

    public async Task<string> GetDataAsync(string userId)
    {
        // 根据用户 ID 选择不同的 HttpClient 实例
        HttpClient client = userId.StartsWith("A") ? _httpClients[0] : _httpClients[1];
        HttpResponseMessage response = await client.GetAsync("data");
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadAsStringAsync();
    }
    

### 8\. 监控与日志记录

#### 监控 HTTP 请求的重要性

监控 HTTP 请求可以帮助我们及时发现和解决问题，确保系统的稳定性和可靠性。常见的监控指标包括请求成功率、响应时间、错误率等。

#### 使用 Application Insights 进行监控

Application Insights 是 Azure 提供的一个应用性能管理服务，可以帮助我们监控和分析 HTTP 请求。以下是一个使用 Application Insights 监控 HTTP 请求的示例：

    public class HttpRemoteService
    {
        private readonly HttpClient _httpClient;
        private readonly TelemetryClient _telemetryClient;
    
        public HttpRemoteService(HttpClient httpClient, TelemetryClient telemetryClient)
        {
            _httpClient = httpClient;
            _telemetryClient = telemetryClient;
        }
    
        public async Task<string> GetDataAsync()
        {
            var startTime = DateTime.UtcNow;
            var timer = System.Diagnostics.Stopwatch.StartNew();
    
            try
            {
                HttpResponseMessage response = await _httpClient.GetAsync("data");
                response.EnsureSuccessStatusCode();
                return await response.Content.ReadAsStringAsync();
            }
            catch (Exception ex)
            {
                _telemetryClient.TrackException(ex); // 记录异常
                throw;
            }
            finally
            {
                timer.Stop();
                _telemetryClient.TrackDependency("HTTP", "GET", "data", startTime, timer.Elapsed, true); // 记录依赖调用
            }
        }
    }
    

#### 日志记录的最佳实践

日志记录是监控和调试的重要工具。以下是一些日志记录的最佳实践：

*   **记录关键信息**：如请求 URL、响应状态码、响应时间等。
*   **使用结构化日志**：便于日志的查询和分析。
*   **避免记录敏感信息**：如密码、令牌等。

    public async Task<string> GetDataAsync()
    {
        _logger.LogInformation("正在发送 HTTP GET 请求到 {Url}", "https://api.*****.com/data");
    
        try
        {
            HttpResponseMessage response = await _httpClient.GetAsync("data");
            response.EnsureSuccessStatusCode();
            string content = await response.Content.ReadAsStringAsync();
            _logger.LogInformation("请求成功，响应状态码: {StatusCode}", response.StatusCode);
            return content;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "请求失败: {Message}", ex.Message);
            throw;
        }
    }
    

### 参考资料

*   [**Polly 官方文档**](https://github.com/App-vNext/Polly)
*   [**.NET Core 官方文档**](https://docs.microsoft.com/zh-cn/dotnet/core/)
*   [**Application Insights 官方文档**](https://docs.microsoft.com/zh-cn/azure/azure-monitor/app/app-insights-overview)

### 结语

在 .NET Core 中构建一个弹性的 HTTP 请求机制是一个复杂但值得的任务。希望本文能够帮助你在 .NET Core 中构建一个健壮的 HTTP 请求机制。  
![](https://img2024.cnblogs.com/blog/2063798/202501/2063798-20250121173244361-1429266657.png)