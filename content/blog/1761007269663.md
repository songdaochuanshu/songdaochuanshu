---
layout: post
title: 'PHP 8.5 新特性 闭包可以作为常量表达式了'
date: "2025-10-21T00:41:09Z"
---
PHP 8.5 新特性 闭包可以作为常量表达式了
========================

PHP 8.5 新特性 闭包可以作为常量表达式了
========================

PHP 8.5 又带来了一个让人兴奋的新特性:闭包现在可以作为常量表达式使用了,这意味着它们可以出现在默认参数或属性值中。

你是不是也遇到过这种情况:想在 PHP 中把闭包设置为默认参数值,结果只能想各种变通方案?在 PHP 8.5 中,这个烦恼终于没了。闭包现在可以作为常量表达式——也就是说,它们可以用在任何你之前只能用字面值的地方。

我之前就被这个限制坑过,而且不止一次。现在,你可以在这些地方使用闭包了:

*   默认参数值
*   常量值
*   属性默认值
*   属性参数值
*   还有更多

[PHP 8.5 新特性 闭包可以作为常量表达式了](https://catchadmin.com/post/2025-10/php85-closures-constant-expressions)

默认值
---

以前,我会写这样的代码:

    function someFunction(mixed $someValue, ?callable $callback = null): bool
    {
        $callback ??= fn () => true;
        return $callback($someValue);
    }
    

或者这样:

    final class SomeClass
    {
        private Closure $someCallable;
    
        public function __construct()
        {
            $this->someCallable = function (mixed $value): bool {
                // 待实现
                return true;
            };
        }
    }
    

有了闭包常量表达式,这两个例子都可以简化成:

    function someFunction(
        mixed $someValue,
        callable $callback = static function () { return true; },
    ): bool {
        return $callback($someValue);
    }
    
    final class SomeClass
    {
        private Closure $someCallable = static function (mixed $value): bool {
            // 待实现
            return true;
        };
    }
    

不用再写 `$callback ??=` 这种绕来绕去的代码了。直接把闭包作为默认参数值是我经常要做的事,现在能够通过避免像 `null` 这种无意义的值来精简公共接口,这个改进真的很棒。

属性(Attributes)
--------------

这是另一个很赞的改变——你现在可以直接在属性中定义函数了。比如:

    #[Attribute(Attribute::TARGET_PROPERTY)]
    final readonly class TruthyValidator
    {
        public function __construct(
            public Closure $truthyValidator = static function(mixed $value): bool {
                return (bool) $value;
            }
        ) {
        }
    }
    

这是一个简单的验证器属性,用来检查值是否为真值,默认实现就是把它转成布尔值,让 PHP 自己处理转换。但假如你想把字符串 `'0'` 也当作真值:

    #[TruthyValidator(truthyValidator: static function(string|int|null $value): bool {
        return $value === '0' || $value;
    })]
    public string|int|null $someProperty = null;
    

First-Class Callables
---------------------

严格来说这是一个独立的 RFC,但它是因为投票原因才拆分的,技术上并不是独立的,所以我在同一篇文章里一起介绍。

除了标准的闭包(你可以内联定义函数体),现在你也可以用 first-class callables 作为常量表达式了。这意味着上面所有的例子也都适用于它们。

    <?php
    
    // 定义一个默认验证器
    function defaultValidatorFunction(mixed $value): bool
    {
        return (bool) $value;
    }
    
    // 定义验证器类
    #[Attribute(Attribute::TARGET_PROPERTY)]
    final readonly class TruthyValidator
    {
        public function __construct(
            // 使用 first-class callable 语法分配默认验证器
            public Closure $truthyValidator = defaultValidatorFunction(...),
        ) {
        }
    }
    
    // 定义我们自定义的验证函数
    function truthyValidatorWithoutZeroString(string|int|null $value): bool
    {
        return $value === '0' || $value;
    }
    
    class SomeClassToBeValidated
    {
        // 用 first-class callable 的方式使用它
        #[TruthyValidator(truthyValidator: truthyValidatorWithoutZeroString(...))]
        public string|int|null $someProperty = null;
    }
    

总结
--

我个人真的很喜欢这个新特性,因为它——就像最近的很多其他改进一样——让 PHP 变成了一门更简洁、更一致的语言,减少了各种 hack 和怪异的语法。