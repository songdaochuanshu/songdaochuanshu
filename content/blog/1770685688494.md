---
layout: post
title: '鸿蒙应用开发UI基础第四节：UIAbility 启动模式详解'
date: "2026-02-10T01:08:08Z"
---
鸿蒙应用开发UI基础第四节：UIAbility 启动模式详解
==============================

【学习目标】
------

1.  掌握 multiton、singleton、specified 三种启动模式的核心定义与差异
2.  理解不同模式下 UIAbility 实例的**创建/复用规则**及生命周期联动逻辑
3.  掌握 AbilityStage 的核心作用及与 specified 模式的关联关系
4.  学会在 module.json5 中配置启动模式，及多 Ability 工程的标准化搭建
5.  能通过实操实现三种模式，并验证实例创建/复用的行为差异

【课前铺垫】
------

上一节我们已掌握 UIAbility 的基础生命周期及页面跳转逻辑，其默认启动模式为 **singleton（单实例）**。

实际开发中，不同业务场景（如多标签页、唯一个人中心、按业务维度复用实例）需要不同的实例管理策略，因此鸿蒙提供了三种启动模式，核心解决**「重复启动时，系统是创建新实例还是复用已有实例」**的问题。

【核心问题导入】
--------

*   为什么浏览器打开新标签是新窗口，而打开个人中心始终是同一个窗口？
*   为什么部分页面跳转触发 onCreate，部分仅触发 onNewWant？
*   specified 模式的 instanceKey 作用是什么？为何必须依赖 AbilityStage？
*   如何根据业务场景选择合适的启动模式？

一、核心概念：UIAbility 三种启动模式
-----------------------

UIAbility 的启动模式决定了**系统对实例的管理策略**，鸿蒙官方提供三种标准化模式，覆盖所有业务场景，核心差异集中在**实例数量**和**复用规则**上：

### 1\. singleton（单实例模式）- 全局唯一

*   **核心定义**：该类型 UIAbility 全局仅存在**一个实例**，无论多少次启动，系统都会复用已有实例
*   **核心规则**：首次启动创建实例，后续所有启动请求均路由到已有实例
*   **适用场景**：应用主界面、个人中心、购物车等**需要全局唯一状态**的页面

### 2\. multiton（多实例模式）- 每次新建

*   **核心定义**：每次启动该类型 UIAbility，系统都会**创建新的实例**，实例之间相互独立
*   **核心规则**：无复用逻辑，每次启动均走完整的实例创建生命周期
*   **适用场景**：浏览器多标签页、多窗口文档编辑、多任务处理等**需要独立状态**的页面

> 说明：standard 是 multiton 的曾用名，鸿蒙低版本中使用，功能与 multiton 完全一致

### 3\. specified（指定实例模式）- 按标识复用

*   **核心定义**：系统根据**唯一标识**判断实例复用逻辑，相同标识复用实例，不同标识创建新实例
*   **核心规则**：标识由 AbilityStage 的 onAcceptWant 方法生成，通常绑定业务唯一值（如 instanceKey）
*   **适用场景**：聊天窗口（按联系人ID复用）、商品详情页（按商品ID复用）、按业务维度隔离的实例场景

二、AbilityStage 核心作用与核心方法
------------------------

### 1\. AbilityStage 基础认知

*   AbilityStage 是**模块级的生命周期管理器**，每个 HAP 模块对应一个 AbilityStage 实例，由系统首次加载模块时自动创建
*   若无需监听模块生命周期或处理 specified 模式，无需手动创建，系统使用默认实例；若需实现 specified 模式，**必须手动创建并配置自定义 AbilityStage**

### 2\. AbilityStage 与 specified 模式的关联

specified 模式是**唯一依赖 AbilityStage 的启动模式**，原因是：系统本身无法识别「哪些启动请求需要复用实例」，需通过 AbilityStage 提供**实例唯一标识**，系统根据该标识完成匹配/复用。

### 3\. AbilityStage 核心方法：onAcceptWant

*   作用：**生成并返回 specified 模式的实例唯一标识**，系统根据该标识判断是否复用实例
*   入参：Want 对象（包含启动请求的所有信息，如 abilityName、parameters 等）
*   返回值：字符串类型的唯一标识（相同标识复用实例，不同标识/空字符串创建新实例）
*   核心逻辑：从 Want 参数中提取业务唯一值（如 instanceKey），拼接成全局唯一的标识字符串

三、工程搭建与三种模式落地
-------------

### （一）工程结构规划

基于 `FirstApplication` 工程，新增 2 个 UIAbility（分别对应 multiton/specified 模式）及对应页面，保留原有 EntryAbility（singleton 模式），标准化工程结构如下（新增目录/文件标注★）：

    FirstApplication
    ├── AppScope                 # 应用全局配置目录
    │   └── app.json5            # 全局配置（包名：com.sanxiu.firstapp）
    ├── entry                    # 主模块目录（Entry HAP）
    │   ├── src/main
    │   │   ├── ets              # ArkTS代码核心目录
    │   │   ├── application★     # 自定义AbilityStage目录（specified模式核心）
    │   │   │   └── MyAbilityStage.ets★ # 自定义AbilityStage（实现onAcceptWant）
    │   │   ├── entryability     # 单实例Ability目录（singleton模式）
    │   │   │   └── EntryAbility.ets       # 默认Ability（启动入口）
    │   │   ├── multitonability★ # 多实例Ability目录（multiton模式）
    │   │   │   └── MultitonAbility.ets★   # multiton模式Ability
    │   │   ├── specifiedability★# 指定实例Ability目录（specified模式）
    │   │   │   └── SpecifiedAbility.ets★  # specified模式Ability
    │   │   ├── pages            # Page页面目录
    │   │   │   ├── Index.ets              # 备用首页
    │   │   │   ├── Home.ets★               # 测试首页（启动各模式Ability）
    │   │   │   ├── MultitonPage.ets★       # multiton模式对应页面
    │   │   │   └── SpecifiedPage.ets★      # specified模式对应页面
    │   │   ├── resources        # 静态资源目录（无修改）
    │   │   └── module.json5     # 模块配置文件（新增Ability+配置启动模式+AbilityStage）
    └── 其他目录（构建/测试相关，无修改）
    

### （二）第一步：创建自定义 AbilityStage

#### 1\. 创建步骤

① 选中 `src/main/ets` 目录 → 右键 → New → Directory → 命名为 `application`；  
② 进入 `application` 目录 → 右键 → New → ArkTS File → 命名为 `MyAbilityStage.ets`。

#### 2\. 代码实现

    import { AbilityStage, Want } from '@kit.AbilityKit';
    import { hilog } from '@kit.PerformanceAnalysisKit';
    
    const TAG = '[Sample_StartMode]';
    const DOMAIN = 0x0000;
    
    // 继承系统AbilityStage，实现自定义逻辑
    export default class MyAbilityStage extends AbilityStage {
        // AbilityStage初始化生命周期（模块加载时触发）
        onCreate() {
            hilog.info(DOMAIN, TAG, 'MyAbilityStage 初始化成功');
        }
    
        // 核心方法：为specified模式生成实例唯一标识
        onAcceptWant(want: Want): string {
            hilog.info(DOMAIN, TAG, '开始处理specified模式实例标识');
            
            // 仅对SpecifiedAbility做标识处理，避免影响其他Ability
            if (want && want.abilityName === 'SpecifiedAbility') {
                // 从Want参数中提取业务唯一标识instanceKey
                const instanceKey = want.parameters?.instanceKey;
                // 有有效Key则拼接唯一标识，无则返回空（创建新实例）
                if (instanceKey) {
                    return `SpecifiedAbility_${instanceKey}`;
                }
            }
            
            // 非specified模式/无有效Key，返回空字符串
            return '';
        }
    }
    

### （三）第二步：创建三种模式的 UIAbility 及对应页面

#### 1\. singleton 模式：EntryAbility（默认无需修改）

*   启动模式默认为 singleton，无需在 module.json5 中额外配置
*   核心修改：将默认页面改为测试首页 `pages/Home`，作为所有模式的启动入口

    // entryability/EntryAbility.ets 关键代码
    onWindowStageCreate(windowStage: window.WindowStage): void {
        windowStage.loadContent('pages/Home'); // 改为测试首页
    }
    

#### 2\. multiton 模式：MultitonAbility + MultitonPage

##### （1）创建 MultitonAbility

选中 `src/main/ets` → 右键 → New → Ability → 命名为 `MultitonAbility`，代码实现如下（核心：每次启动触发 onCreate）：

    import { UIAbility, AbilityConstant, Want } from '@kit.AbilityKit';
    import { window } from '@kit.ArkUI';
    import { hilog } from '@kit.PerformanceAnalysisKit';
    import { BusinessError } from '@ohos.base';
    
    const TAG = 'MultitonAbility';
    const DOMAIN = 0x0000;
    
    export default class MultitonAbility extends UIAbility {
        // 每次启动都会触发（多实例模式核心特征）
        onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
            // 生成时间戳作为实例唯一ID，区分不同实例
            const instanceId = `实例ID_${Date.now()}`;
            hilog.info(DOMAIN, TAG, `多实例创建成功：${instanceId}`);
        }
    
        // 加载多实例对应页面
        onWindowStageCreate(windowStage: window.WindowStage): void {
            windowStage.loadContent('pages/MultitonPage')
                .catch((err: BusinessError) => {
                    hilog.error(DOMAIN, TAG, `页面加载失败：${err.message}`);
                });
        }
    }
    

##### （2）创建 MultitonPage

选中 `src/main/ets/pages` → 右键 → New → Page → 命名为 `MultitonPage`，代码实现如下：

    @Entry
    @Component
    struct MultitonPage {
        @State message: string = '多实例（multiton）模式页面';
        // 显示当前实例创建时间，直观区分不同实例
        @State createTime: string = `创建时间：${new Date().toLocaleTimeString()}`;
    
        build() {
            Column({ space: 20, alignItems: ItemAlign.Center }) {
                Text(this.message)
                    .fontSize(30)
                    .fontWeight(FontWeight.Bold);
                    
                Text(this.createTime)
                    .fontSize(20)
                    .fontColor(Color.Blue);
                    
                Text('每次点击启动都会创建新实例，实例相互独立')
                    .fontSize(16)
                    .fontColor(Color.Grey);
            }
            .width('100%')
            .height('100%')
            .justifyContent(FlexAlign.Center);
        }
    }
    

#### 3\. specified 模式：SpecifiedAbility + SpecifiedPage

##### （1）创建 SpecifiedAbility

选中 `src/main/ets` → 右键 → New → Ability → 命名为 `SpecifiedAbility`，代码实现如下（核心：复用实例时触发 onNewWant）：

    import { UIAbility, AbilityConstant, Want } from '@kit.AbilityKit';
    import { window, AppStorage } from '@kit.ArkUI';
    import { hilog } from '@kit.PerformanceAnalysisKit';
    import { BusinessError } from '@ohos.base';
    
    const TAG = 'SpecifiedAbility';
    const DOMAIN = 0x0000;
    
    export default class SpecifiedAbility extends UIAbility {
        private currentInstanceKey: string = 'default';
    
        // 新标识：创建实例时触发
        onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
            this.currentInstanceKey = `${want.parameters?.instanceKey}` || 'default';
            // 同步标识到页面，用于展示
            AppStorage.setOrCreate('instanceKey', `当前实例Key：${this.currentInstanceKey}`);
            hilog.info(DOMAIN, TAG, `指定实例创建成功：${this.currentInstanceKey}`);
        }
    
        // 同标识：复用实例时触发（核心，替代onCreate）
        onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam) {
            this.currentInstanceKey = `${want.parameters?.instanceKey}` || 'default';
            AppStorage.setOrCreate('instanceKey', `当前实例Key：${this.currentInstanceKey}`);
            hilog.info(DOMAIN, TAG, `指定实例复用成功：${this.currentInstanceKey}`);
        }
    
        // 加载指定实例对应页面
        onWindowStageCreate(windowStage: window.WindowStage): void {
            windowStage.loadContent('pages/SpecifiedPage')
                .catch((err: BusinessError) => {
                    hilog.error(DOMAIN, TAG, `页面加载失败：${err.message}`);
                });
        }
    }
    

##### （2）创建 SpecifiedPage

选中 `src/main/ets/pages` → 右键 → New → Page → 命名为 `SpecifiedPage`，代码实现如下（通过 AppStorage 同步实例标识）：

    @Entry
    @Component
    struct SpecifiedPage {
        @State message: string = '指定实例（specified）模式页面';
        // 双向绑定Ability中的实例标识，实时更新
        @StorageLink('instanceKey') instanceKey: string = '当前实例Key：default';
    
        build() {
            Column({ space: 20, alignItems: ItemAlign.Center }) {
                Text(this.message)
                    .fontSize(30)
                    .fontWeight(FontWeight.Bold);
                    
                Text(this.instanceKey)
                    .fontSize(20)
                    .fontColor(Color.Green);
                    
                Text('相同Key复用实例，不同Key创建新实例')
                    .fontSize(16)
                    .fontColor(Color.Grey);
            }
            .width('100%')
            .height('100%')
            .justifyContent(FlexAlign.Center);
        }
    }
    

#### 4\. 测试首页：HomePage（启动各模式 Ability 入口）

修改 `src/main/ets/pages/Home.ets`，实现三个模式的启动按钮代码如下：

    import { common, Want } from '@kit.AbilityKit';
    import { getContext } from '@kit.ArkUI';
    import { BusinessError } from '@ohos.base';
    
    @Entry
    @Component
    struct Home {
        @State message: string = 'UIAbility 启动模式测试';
        // 获取页面上下文，用于启动Ability
        private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
    
        // 启动multiton模式（多实例）
        private launchMultiton() {
            const want: Want = {
                bundleName: 'com.sanxiu.firstapp',
                abilityName: 'MultitonAbility',
                parameters: { timestamp: Date.now().toString() }
            };
            this.context.startAbility(want).catch((err: BusinessError) => {
                console.error('启动多实例失败：', err);
            });
        }
    
        // 启动specified模式（指定实例，传参instanceKey）
        private launchSpecified(key: string) {
            const want: Want = {
                bundleName: 'com.sanxiu.firstapp',
                abilityName: 'SpecifiedAbility',
                parameters: { instanceKey: key }
            };
            this.context.startAbility(want).catch((err: BusinessError) => {
                console.error(`启动指定实例${key}失败：`, err);
            });
        }
    
        build() {
            Column({ space: 15, alignItems: ItemAlign.Center }) {
                Text(this.message)
                    .fontSize(30)
                    .fontWeight(FontWeight.Bold)
                    .margin(20);
                
                // 单实例模式（默认EntryAbility，此处仅作说明）
                Text('singleton：全局唯一（当前首页）')
                    .fontSize(16)
                    .fontColor(Color.Grey);
                
                // 多实例模式启动按钮
                Button('启动multiton（多实例）', { type: ButtonType.Capsule })
                    .width('80%')
                    .height(50)
                    .onClick(() => this.launchMultiton());
                
                // 指定实例模式启动按钮（不同Key）
                Button('启动specified（Key=chat_1001）', { type: ButtonType.Capsule })
                    .width('80%')
                    .height(50)
                    .onClick(() => this.launchSpecified('chat_1001'));
                    
                Button('启动specified（Key=chat_1002）', { type: ButtonType.Capsule })
                    .width('80%')
                    .height(50)
                    .onClick(() => this.launchSpecified('chat_1002'));
                    
                Button('再次启动specified（Key=chat_1001）', { type: ButtonType.Capsule })
                    .width('80%')
                    .height(50)
                    .onClick(() => this.launchSpecified('chat_1001'));
            }
            .width('100%')
            .height('100%')
            .justifyContent(FlexAlign.Center);
        }
    }
    

### （四）第三步：配置文件修改（核心：启动模式 + AbilityStage）

#### 1\. 页面路由注册：main\_pages.json

通过page创建的页面，路由路径自动生成，通过ArkTS File 创建需手动管理路由。  
路由路径：`src/main/resources/base/profile/main_pages.json`

    {
      "src": [
        "pages/Index",
        "pages/Home",
        "pages/MultitonPage",
        "pages/SpecifiedPage"
      ]
    }
    

#### 2\. 模块核心配置：module.json5（启动模式 + AbilityStage 配置）

创建Ability的时候系统会自动在`abilities`创建对应的配置，但需要手动修改启动模式。自定义AbilityStage需手动配置加载路径。修改完成后手动Sync Now同步配置.

    {
      "module": {
        "name": "entry",
        "type": "entry",
        "description": "$string:module_desc",
        "srcEntry": "./ets/application/MyAbilityStage.ets", // 手动新增
        "mainElement": "EntryAbility",
        "deviceTypes": [
          "phone"
        ],
        "deliveryWithInstall": true,
        "installationFree": false,
        "pages": "$profile:main_pages",
        "abilities": [
          {
            "name": "EntryAbility",
            "srcEntry": "./ets/entryability/EntryAbility.ets",
            "description": "$string:EntryAbility_desc",
            "icon": "$media:layered_image",
    //        "label": "$string:EntryAbility_label",
            "startWindowIcon": "$media:app_module_icon",
            "startWindowBackground": "$color:start_window_background",
            "exported": true,
            "launchType": "singleton",  // 默认的启动模式，可以不写
    
            "skills": [
              {
                "entities": [
                  "entity.system.home"
                ],
                "actions": [
                  "ohos.want.action.home"
                ]
              }
            ]
          },
          {
            "name": "MultitonAbility",
            "launchType": "multiton", // 多实例模式
            "srcEntry": "./ets/multitonability/MultitonAbility.ets",
            "description": "$string:MultitonAbility_desc",
            "icon": "$media:layered_image",
            "label": "$string:MultitonAbility_label",
            "startWindowIcon": "$media:startIcon",
            "startWindowBackground": "$color:start_window_background"
          },
          {
            "name": "SpecifiedAbility",
            "launchType": "specified", // 指定模式
            "srcEntry": "./ets/specifiedability/SpecifiedAbility.ets",
            "description": "$string:SpecifiedAbility_desc",
            "icon": "$media:layered_image",
            "label": "$string:SpecifiedAbility_label",
            "startWindowIcon": "$media:startIcon",
            "startWindowBackground": "$color:start_window_background"
          }
        ],
        "extensionAbilities": [
          {
            "name": "EntryBackupAbility",
            "srcEntry": "./ets/entrybackupability/EntryBackupAbility.ets",
            "type": "backup",
            "exported": false,
            "metadata": [
              {
                "name": "ohos.extension.backup",
                "resource": "$profile:backup_config"
              }
            ],
          }
        ]
      }
    }
    

### （五）第四步：配置与功能验证

#### 1\. AbilityStage 配置验证

运行项目后，查看日志控制台，若输出以下日志，说明自定义 AbilityStage 初始化成功：

    [Sample_StartMode] MyAbilityStage 初始化成功
    

#### 2\. 三种模式行为验证

操作

预期现象

验证点

多次点击「启动multiton」

每次生成新窗口，创建时间不同

多实例模式每次触发onCreate

首次点击「Key=chat\_1001」

生成新窗口，显示Key=chat\_1001

指定实例新标识触发onCreate

再次点击「Key=chat\_1001」

复用原有窗口，日志输出“复用成功”

指定实例同标识触发onNewWant

点击「Key=chat\_1002」

生成新窗口，显示Key=chat\_1002

指定实例不同标识触发onCreate

重复返回首页再打开

singleton模式始终为同一个窗口

单实例模式全局唯一

四、核心差异总结：三种启动模式对比
-----------------

特性

singleton（单实例）

multiton（多实例）

specified（指定实例）

实例数量

全局唯一

无限制，每次新建

按标识分组，每组一个

复用规则

始终复用已有实例

永不复用，每次新建

相同标识复用，不同标识新建

核心生命周期

首次onCreate，后续onNewWant

每次启动均onCreate

新标识onCreate，同标识onNewWant

依赖AbilityStage

否

否

是（必须自定义实现）

关键参数

无

无

instanceKey（业务唯一标识）

适用场景

主界面、个人中心、购物车

多标签页、多文档编辑

聊天窗口、商品详情页、按业务隔离

错误码注意

启动中重复调用返回16000082

无

标识不唯一会导致实例错误复用

五、实操关键注意事项
----------

1.  **配置生效规则**：修改 module.json5（启动模式/AbilityStage） 或 AbilityStage 代码后，**热重载/热更新均不生效**，必须**停止应用进程 → 重新运行项目**，否则系统无法识别配置变更。
2.  **AbilityStage 路径校验**：`srcEntry` 路径必须与实际文件路径完全一致，鸿蒙系统**严格区分大小写**，路径错误会导致 AbilityStage 初始化失败。
3.  **instanceKey 判空**：在 AbilityStage 的 onAcceptWant 方法中，必须对 instanceKey 做空值判断，避免因参数缺失导致标识生成失败。
4.  **标识唯一性**：onAcceptWant 返回的标识必须**全局唯一**，建议拼接 AbilityName + 业务唯一值，避免不同 Ability 的标识冲突。
5.  **AppStorage 作用**：specified 模式中，通过 AppStorage + @StorageLink 实现 Ability 与页面的**状态双向同步**，复用实例时页面能实时更新业务标识。
6.  **onNewWant 核心**：specified/singleton 模式中，复用实例时不会触发 onCreate，所有启动参数的处理必须放在 **onNewWant** 方法中，否则会导致参数丢失。

六、内容总结
------

1.  启动模式的**本质**是「系统对 UIAbility 实例的管理策略」，核心解决“创建新实例还是复用已有实例”的问题。
2.  三种模式各有适用场景，核心选择依据是**「业务是否需要唯一实例」**和**「是否需要按业务维度隔离实例」**。
3.  AbilityStage 是**模块级生命周期管理器**，也是 specified 模式的**必要条件**，其核心作用是为 specified 模式生成**实例唯一标识**。
4.  specified 模式的核心逻辑是：**启动传参 instanceKey → AbilityStage 生成唯一标识 → 系统按标识匹配/复用实例 → 复用触发 onNewWant**。
5.  生命周期联动的核心规则：**创建实例触发 onCreate，复用实例触发 onNewWant**，onWindowStageCreate/onForeground 等方法不受启动模式影响，按需触发。

七、代码仓库
------

*   工程名称：FirstApplication
*   仓库地址：[https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git](https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git)

八、下节预告
------

下一节我们将学习 **Context上下文核心讲解与实战**，重点掌握：

1.  理解 Context 核心定位及“应用→模块→组件→UI实例”层级关系，能精准获取各层级 Context 实例；
2.  掌握 5 类 Context 高频核心能力（文件访问、环境监听、加密分区、UI交互、扩展能力），实现基础业务闭环；
3.  明确 Context 能力边界与核心约束（生命周期），规避开发踩坑；
4.  区分不同 Context 适用场景，能结合实际业务选择最优上下文。