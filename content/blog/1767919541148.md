---
layout: post
title: 'FastAPI + SQLiteï¼šä»åŸºç¡€CRUDåˆ°å®‰å…¨å¹¶å‘çš„å®æˆ˜æŒ‡å—'
date: "2026-01-09T00:45:41Z"
---
FastAPI + SQLiteï¼šä»åŸºç¡€CRUDåˆ°å®‰å…¨å¹¶å‘çš„å®æˆ˜æŒ‡å—
==================================

æœ¬æ–‡æä¾›äº†FastAPIç»“åˆSQLiteè¿›è¡Œåç«¯å¼€å‘çš„å®Œæ•´å®æˆ˜æŒ‡å—ã€‚ä¸ä»…æ¶µç›–äº†åŸºç¡€æ¨¡å‹å®šä¹‰å’ŒCRUDæ¥å£æ­å»ºï¼Œæ›´æ·±å…¥æ¢è®¨äº†ç”Ÿäº§ç¯å¢ƒä¸­å¿…å¤‡çš„å®‰å…¨è®¾ç½®ï¼ˆå¦‚OAuth2å¯†ç æµä¸JWTä»¤ç‰Œè®¤è¯ï¼‰å’Œé«˜å¹¶å‘å¤„ç†æ–¹æ¡ˆï¼ˆå¦‚æ•°æ®åº“è¿æ¥æ± é…ç½®ä¸å¼‚æ­¥ä¼˜åŒ–ï¼‰ã€‚é€šè¿‡æ¸…æ™°çš„ä»£ç ç¤ºä¾‹å’Œç”ŸåŠ¨çš„æ¯”å–»ï¼Œå¸®åŠ©ä½ æ„å»ºæ—¢å®‰å…¨åˆé«˜æ•ˆçš„åº”ç”¨ã€‚

ä½ æœ‰æ²¡æœ‰ç»å†è¿‡é¡¹ç›®è¶Šè·‘è¶Šæ…¢ï¼Œæˆ–è€…å› ä¸ºä¸€ä¸ªå°æ¼æ´å¯¼è‡´æ•°æ®æ³„éœ²çš„ææ…Œæ—¶åˆ»ï¼Ÿ

è¯•æƒ³ä¸€ä¸‹ï¼Œä¸€ä¸ªFastAPIé¡¹ç›®ï¼Œç®€å•çš„å†…éƒ¨å·¥å…·ï¼ŒåˆæœŸè¿è¡Œé£å¿«ã€‚ä½†å½“ç”¨æˆ·é‡ä»10ä¸ªå¢åŠ åˆ°100ä¸ªæ—¶ï¼Œå“åº”æ—¶é—´å´å¢åŠ äº†è¿‘10å€ï¼Œè¿˜å·®ç‚¹å› ä¸ºä¸€ä¸ªæœªç»éªŒè¯çš„APIå‚æ•°å¯¼è‡´å…¨è¡¨æ•°æ®è¢«æ„å¤–å¯¼å‡ºã€‚å…¶å®ï¼Œå¾ˆå¤šæ•™ç¨‹åªæ•™æˆ‘ä»¬â€œè·‘èµ·æ¥â€ï¼Œå´æ²¡æ•™æˆ‘ä»¬â€œè·‘å¾—ç¨³ã€è·‘å¾—å®‰å…¨â€ã€‚

ğŸ“Œ æ ¸å¿ƒæ‘˜è¦
-------

æœ¬æ–‡å°†å¸¦ä½ è¶…è¶ŠFastAPI + SQLiteçš„åŸºç¡€CRUDæ­å»ºï¼Œèšç„¦äº**å®‰å…¨é˜²æŠ¤ï¼ˆè®¤è¯ã€æˆæƒã€è¾“å…¥éªŒè¯ï¼‰**ä¸**å¹¶å‘å¤„ç†ï¼ˆæ•°æ®åº“è¿æ¥æ± ã€å¼‚æ­¥ä¼˜åŒ–ï¼‰**ä¸¤å¤§å®æˆ˜ç—›ç‚¹ã€‚ä½ ä¼šè·å¾—ä¸€å¥—å¯ç›´æ¥å¤ç”¨çš„é¡¹ç›®éª¨æ¶ï¼Œå¹¶ç†è§£å…¶èƒŒåçš„è®¾è®¡é€»è¾‘ï¼Œç¡®ä¿ä½ çš„åº”ç”¨åœ¨ä¸šåŠ¡å¢é•¿æ—¶ä¾ç„¶ç¨³å¥ã€‚

ğŸš€ ä¸»è¦å†…å®¹è„‰ç»œ
---------

ğŸ¯ 1. å¿«é€Ÿæ­å»ºï¼š5åˆ†é’Ÿåˆ›å»ºä¸€ä¸ªå¸¦CRUDçš„FastAPIåº”ç”¨

âš¡ æ¨¡å‹å®šä¹‰ã€æ•°æ®åº“è¿æ¥ã€åŸºç¡€API

ğŸ¯ 2. å®‰å…¨ç¬¬ä¸€ï¼šç»™ä½ çš„APIåŠ ä¸Šâ€œé—¨ç¦â€å’Œâ€œç›‘æ§â€

âš¡ OAuth2å¯†ç æµã€JWTä»¤ç‰Œã€ä¾èµ–æ³¨å…¥ä¿æŠ¤è·¯ç”±

ğŸ¯ 3. åº”å¯¹é«˜å¹¶å‘ï¼šåˆ«è®©æ•°æ®åº“è¿æ¥æˆä¸ºç“¶é¢ˆ

âš¡ è¿æ¥æ± é…ç½®ã€å¼‚æ­¥ä¼šè¯ç®¡ç†ã€åå°ä»»åŠ¡

ğŸ¯ 4. å®Œæ•´ä»£ç ä¸é¿å‘æŒ‡å—

âš¡ é¡¹ç›®ç»“æ„ã€å…³é”®é…ç½®ã€å¸¸è§é™·é˜±

ğŸ”§ ç¬¬ä¸€éƒ¨åˆ†ï¼šä¸ºä»€ä¹ˆæ˜¯FastAPI + SQLiteï¼Ÿ
-----------------------------

FastAPIå°±åƒä¸€ä¸ªé«˜æ•ˆã€ç°ä»£çš„é¤å…ç‚¹é¤ç³»ç»Ÿï¼Œä½ ï¼ˆå®¢æˆ·ç«¯ï¼‰é€’ä¸Šèœå•ï¼ˆJSONè¯·æ±‚ï¼‰ï¼Œå¨æˆ¿ï¼ˆåç«¯é€»è¾‘ï¼‰ç«‹åˆ»å¼€åŠ¨ï¼Œå¿«é€Ÿå‡ºé¤ï¼ˆJSONå“åº”ï¼‰ã€‚è€ŒSQLiteï¼Œåˆ™æ˜¯è¿™å®¶é¤å…åˆæœŸæœ€åˆé€‚çš„â€œæœ¬åœ°ä»“åº“â€â€”â€”æ— éœ€å¤æ‚é…ç½®ï¼Œä¸€ä¸ªæ–‡ä»¶æå®šæ‰€æœ‰åº“å­˜ï¼Œå¯¹äºä¸­å°å‹åº”ç”¨æˆ–åŸå‹å¼€å‘æ¥è¯´ï¼Œ**è½»é‡ä¸”å®Œå…¨å¤Ÿç”¨**ã€‚

ä½†é—®é¢˜æ¥äº†ï¼šå½“é¡¾å®¢ï¼ˆå¹¶å‘è¯·æ±‚ï¼‰æš´å¢ï¼Œä»“åº“ç®¡ç†å‘˜ï¼ˆæ•°æ®åº“è¿æ¥ï¼‰æ‰‹å¿™è„šä¹±ï¼›æˆ–è€…æœ‰äººå†’å……æœåŠ¡å‘˜ï¼ˆæœªæˆæƒè®¿é—®ï¼‰è¿›å…¥åå¨ã€‚æˆ‘ä»¬ä»Šå¤©å°±è¦è§£å†³è¿™äº›é—®é¢˜ã€‚

ğŸ›¡ï¸ ç¬¬äºŒéƒ¨åˆ†ï¼šä»åŸºç¡€CRUDåˆ°å®‰å…¨å ¡å’
---------------------

### 1\. æ­å»ºåŸºç¡€æ¡†æ¶

é¦–å…ˆï¼Œå®‰è£…å¿…å¤‡å·¥å…·åŒ…ï¼š

    pip install fastapi uvicorn sqlalchemy databases[aiosqlite] python-jose[cryptography] passlib[bcrypt]

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å®šä¹‰æ•°æ®æ¨¡å‹å¹¶å»ºç«‹è¿æ¥ã€‚SQLAlchemyçš„ORMè®©æˆ‘ä»¬èƒ½ç”¨Pythonç±»æ“ä½œæ•°æ®åº“ï¼š

    # models.py
    from sqlalchemy import Column, Integer, String, create_engine
    from sqlalchemy.ext.declarative import declarative_base
    
    DATABASE_URL = "sqlite:///./test.db"
    # æ³¨æ„ï¼š`check_same_thread=False` ä»…ç”¨äºSQLiteç®€åŒ–ç¤ºä¾‹ï¼Œç”Ÿäº§ç¯å¢ƒéœ€ç”¨æ›´å®‰å…¨çš„æ–¹å¼
    engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
    Base = declarative_base()
    
    class Item(Base):
        __tablename__ = "items"
        id = Column(Integer, primary_key=True, index=True)
        name = Column(String, index=True)
        description = Column(String, nullable=True)
    
    # åˆ›å»ºè¡¨
    Base.metadata.create_all(bind=engine)

ç„¶åï¼Œç¼–å†™FastAPIçš„æ ¸å¿ƒCRUDæ¥å£ï¼š

    # main.py (åŸºç¡€ç‰ˆ)
    from fastapi import FastAPI, Depends, HTTPException
    from sqlalchemy.orm import Session
    from . import models
    from .database import SessionLocal, engine
    
    app = FastAPI()
    
    # ä¾èµ–é¡¹ï¼šè·å–æ•°æ®åº“ä¼šè¯
    def get_db():
        db = SessionLocal()
        try:
            yield db
        finally:
            db.close()
    
    @app.post("/items/")
    def create_item(name: str, description: str = None, db: Session = Depends(get_db)):
        db_item = models.Item(name=name, description=description)
        db.add(db_item)
        db.commit()
        db.refresh(db_item)
        return db_item
    
    @app.get("/items/{item_id}")
    def read_item(item_id: int, db: Session = Depends(get_db)):
        item = db.query(models.Item).filter(models.Item.id == item_id).first()
        if item is None:
            raise HTTPException(status_code=404, detail="Item not found")
        return item
    # ... æ›´æ–°å’Œåˆ é™¤æ¥å£ç±»ä¼¼

### 2\. æ„ç­‘å®‰å…¨é˜²çº¿ ğŸ¯

**è­¦å‘Šï¼šä»¥ä¸‹å®‰å…¨è®¾ç½®æ˜¯ç”Ÿäº§åº”ç”¨çš„åŸºçŸ³ï¼Œåˆ‡å‹¿è·³è¿‡ã€‚**

æŠŠAPIç›´æ¥æš´éœ²åœ¨ç½‘ä¸Šï¼Œå°±åƒæŠŠå®¶é’¥åŒ™æ”¾åœ¨é—¨å«ä¸‹ã€‚æˆ‘ä»¬éœ€è¦**è®¤è¯ï¼ˆä½ æ˜¯è°ï¼‰**å’Œ**æˆæƒï¼ˆä½ èƒ½å¹²ä»€ä¹ˆï¼‰**ã€‚æˆ‘ä»¬é‡‡ç”¨OAuth2å¯†ç æµï¼ˆä¸šç•Œæ ‡å‡†ï¼‰ä¸JWTï¼ˆJSON Web Tokensï¼‰ç»„åˆã€‚

ç¬¬ä¸€æ­¥ï¼Œå¤„ç†å¯†ç ã€‚æ°¸è¿œä¸è¦æ˜æ–‡å­˜å‚¨å¯†ç ï¼

    # security.py
    from passlib.context import CryptContext
    
    pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
    
    def verify_password(plain_password, hashed_password):
        return pwd_context.verify(plain_password, hashed_password)
    
    def get_password_hash(password):
        return pwd_context.hash(password)

ç¬¬äºŒæ­¥ï¼Œåˆ›å»ºå’ŒéªŒè¯JWTä»¤ç‰Œã€‚

    # auth.py
    from jose import JWTError, jwt
    from datetime import datetime, timedelta
    
    SECRET_KEY = "your-secret-key-change-this-in-production" # ğŸ”´ ç”Ÿäº§ç¯å¢ƒå¿…é¡»ç”¨å¼ºå¯†é’¥ä¸”ä»ç¯å¢ƒå˜é‡è¯»å–ï¼
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    
    def create_access_token(data: dict):
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
        credentials_exception = HTTPException(status_code=401, detail="æ— æ•ˆå‡­è¯")
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
        except JWTError:
            raise credentials_exception
        user = db.query(models.User).filter(models.User.username == username).first()
        if user is None:
            raise credentials_exception
        return user

ç¬¬ä¸‰æ­¥ï¼Œç”¨ä¾èµ–é¡¹ä¿æŠ¤è·¯ç”±ã€‚ç°åœ¨ï¼Œåªæœ‰æºå¸¦æœ‰æ•ˆä»¤ç‰Œçš„è¯·æ±‚æ‰èƒ½åˆ›å»ºé¡¹ç›®ï¼š

    @app.post("/secure-items/")
    def create_secure_item(
        item_data: schemas.ItemCreate,
        db: Session = Depends(get_db),
        current_user: models.User = Depends(get_current_user) # ğŸ”’ å…³é”®çš„ä¿æŠ¤å±‚
    ):
        # ç°åœ¨å¯ä»¥å®‰å…¨åœ°åˆ›å»ºï¼Œå› ä¸ºç”¨æˆ·å·²é€šè¿‡è®¤è¯
        ...

âš¡ ç¬¬ä¸‰éƒ¨åˆ†ï¼šé©¯æœå¹¶å‘â€”â€”è¿æ¥æ± ä¸å¼‚æ­¥
-------------------

å½“100ä¸ªé¡¾å®¢åŒæ—¶ç‚¹é¤ï¼Œåªæœ‰1ä¸ªæœåŠ¡å‘˜ï¼ˆæ•°æ®åº“è¿æ¥ï¼‰ä¼šæ€æ ·ï¼Ÿæ‹¥å µï¼SQLiteåœ¨é»˜è®¤è®¾ç½®ä¸‹å¯¹å¹¶å‘çš„æ”¯æŒè¾ƒå¼±ï¼Œä½†é€šè¿‡æ­£ç¡®é…ç½®è¿æ¥æ± ï¼Œå¯ä»¥æå¤§æ”¹å–„ã€‚

**æ ¸å¿ƒï¼šä½¿ç”¨`databases`åº“å’Œå¼‚æ­¥SQLAlchemyã€‚**

    # database_async.py
    from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
    from sqlalchemy.orm import sessionmaker
    
    # ä½¿ç”¨aiosqliteé©±åŠ¨
    ASYNC_DATABASE_URL = "sqlite+aiosqlite:///./test_async.db"
    async_engine = create_async_engine(ASYNC_DATABASE_URL, pool_pre_ping=True, pool_size=10, max_overflow=20)
    
    AsyncSessionLocal = sessionmaker(
        bind=async_engine,
        class_=AsyncSession,
        expire_on_commit=False
    )
    
    async def get_async_db():
        async with AsyncSessionLocal() as session:
            yield session
    
    # åœ¨FastAPIè·¯ç”±ä¸­ä½¿ç”¨
    @app.post("/async-items/", response_model=schemas.Item)
    async def create_async_item(
        item: schemas.ItemCreate,
        db: AsyncSession = Depends(get_async_db)
    ):
        db_item = models.Item(**item.dict())
        db.add(db_item)
        await db.commit()
        await db.refresh(db_item)
        return db_item

**å…³é”®å‚æ•°è§£é‡Šï¼š**

\- `pool_size=10`ï¼šä¿æŒ10ä¸ªå¸¸å¼€è¿æ¥ï¼Œéšæ—¶å¾…å‘½ã€‚

\- `max_overflow=20`ï¼šå…è®¸åœ¨ç¹å¿™æ—¶ä¸´æ—¶åˆ›å»ºæœ€å¤š20ä¸ªé¢å¤–è¿æ¥ã€‚

\- `pool_pre_ping=True`ï¼šè‡ªåŠ¨æ£€æŸ¥è¿æ¥æ˜¯å¦å­˜æ´»ï¼Œé¿å…ä½¿ç”¨å·²æ–­å¼€çš„è¿æ¥ã€‚

**é‡è¦ï¼š**å¯¹äºå‘é€é‚®ä»¶ã€å¤„ç†å¤§æ–‡ä»¶ç­‰**è€—æ—¶ä½†éæ•°æ®åº“å¯†é›†å‹**æ“ä½œï¼ŒåŠ¡å¿…ä½¿ç”¨`BackgroundTasks`ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹ï¼Œå½±å“APIå“åº”é€Ÿåº¦ã€‚

ğŸ§© ç¬¬å››éƒ¨åˆ†ï¼šæ•´åˆä¸é¿å‘æŒ‡å—
---------------

### é¡¹ç›®ç»“æ„å»ºè®®

    your_project/
    â”œâ”€â”€ main.py          # FastAPIåº”ç”¨åˆ›å»ºå’Œè·¯ç”±èšåˆ
    â”œâ”€â”€ models.py        # SQLAlchemyæ•°æ®æ¨¡å‹
    â”œâ”€â”€ schemas.py       # Pydanticè¯·æ±‚/å“åº”æ¨¡å‹ï¼ˆç”¨äºæ•°æ®éªŒè¯ï¼‰
    â”œâ”€â”€ crud.py          # æ ¸å¿ƒçš„æ•°æ®åº“æ“ä½œå‡½æ•°
    â”œâ”€â”€ database.py      # æ•°æ®åº“å¼•æ“å’Œä¼šè¯å·¥å‚ï¼ˆåŒæ­¥/å¼‚æ­¥ï¼‰
    â”œâ”€â”€ auth.py          # è®¤è¯ã€ä»¤ç‰Œç›¸å…³å‡½æ•°
    â”œâ”€â”€ security.py      # å¯†ç å“ˆå¸Œå‡½æ•°
    â””â”€â”€ dependencies.py  # å¯é‡ç”¨çš„FastAPIä¾èµ–é¡¹

### ä¸€ä¸ªå¼ºåŒ–ç‰ˆçš„ä¸»æ–‡ä»¶ç¤ºä¾‹

    # main.py ç²¾ç®€ç¤ºä¾‹
    from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks
    from fastapi.middleware.cors import CORSMiddleware
    from . import models, schemas, crud, auth
    from .database import AsyncSessionLocal, get_async_db
    
    app = FastAPI(title="My Secure API")
    # æ·»åŠ CORSä¸­é—´ä»¶ï¼ˆæ ¹æ®éœ€æ±‚é…ç½®ï¼‰
    app.add_middleware(CORSMiddleware, allow_origins=["*"]) # ç”Ÿäº§ç¯å¢ƒåº”æŒ‡å®šå…·ä½“åŸŸå
    
    @app.post("/token")
    async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: AsyncSession = Depends(get_async_db)):
        user = await authenticate_user(form_data.username, form_data.password, db)
        if not user:
            raise HTTPException(status_code=400, detail="ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")
        access_token = auth.create_access_token(data={"sub": user.username})
        return {"access_token": access_token, "token_type": "bearer"}
    
    @app.get("/users/me/")
    async def read_users_me(current_user: models.User = Depends(auth.get_current_user)):
        return current_user
    
    # å—ä¿æŠ¤çš„ã€å¼‚æ­¥çš„ã€å¸¦åå°ä»»åŠ¡çš„è·¯ç”±ç¤ºä¾‹
    @app.post("/items-with-notify/")
    async def create_item_notify(
        item: schemas.ItemCreate,
        background_tasks: BackgroundTasks,
        db: AsyncSession = Depends(get_async_db),
        current_user: models.User = Depends(auth.get_current_user)
    ):
        db_item = await crud.create_user_item(db=db, item=item, user_id=current_user.id)
        # å‡è®¾æœ‰ä¸ªå‘é€é€šçŸ¥çš„å‡½æ•°
        background_tasks.add_task(send_notification, f"æ–°é¡¹ç›® {item.name} å·²åˆ›å»ºï¼")
        return db_item

### å¿…é¡»ç‰¢è®°çš„é¿å‘ç‚¹

1ï¸âƒ£ **SQLiteé€‚ç”¨äºå¼€å‘ä¸è½»é‡ç”Ÿäº§ã€‚** ç”¨æˆ·é‡å·¨å¤§æˆ–å†™å…¥é¢‘ç¹æ—¶ï¼Œè€ƒè™‘PostgreSQLæˆ–MySQLã€‚

2ï¸âƒ£ **SECRET\_KEYæ˜¯ç”Ÿå‘½çº¿ã€‚** å¿…é¡»é€šè¿‡ç¯å¢ƒå˜é‡ä¼ å…¥ï¼Œä¸”å®šæœŸæ›´æ¢ã€‚

3ï¸âƒ£ **è¿æ¥æ± å‚æ•°éœ€æŒ‰å‹è°ƒæ•´ã€‚** `pool_size`å’Œ`max_overflow`ä¸æ˜¯è¶Šå¤§è¶Šå¥½ï¼Œæ ¹æ®å®é™…è´Ÿè½½æµ‹è¯•æ‰¾åˆ°ç”œèœœç‚¹ã€‚

4ï¸âƒ£ **å–„ç”¨å¼‚æ­¥ï¼ˆasync/awaitï¼‰ã€‚** åœ¨I/Oç­‰å¾…æ—¶é‡Šæ”¾CPUï¼Œä½†ç¡®ä¿æ•´ä¸ªè°ƒç”¨é“¾ï¼ˆæ•°æ®åº“é©±åŠ¨ã€HTTPå®¢æˆ·ç«¯ï¼‰éƒ½æ”¯æŒå¼‚æ­¥ã€‚

5ï¸âƒ£ **éªŒè¯æ‰€æœ‰è¾“å…¥ã€‚** å§‹ç»ˆä½¿ç”¨Pydanticæ¨¡å‹éªŒè¯è¯·æ±‚æ•°æ®ï¼Œè¿™æ˜¯é˜²æ­¢æ³¨å…¥å’Œé”™è¯¯æ•°æ®çš„ç¬¬ä¸€é“é˜²çº¿ã€‚

\---**å†™åœ¨æœ€å**\---  
å¸Œæœ›è¿™ä»½æ€»ç»“èƒ½å¸®ä½ é¿å¼€ä¸€äº›å‘ã€‚å¦‚æœè§‰å¾—æœ‰ç”¨ï¼Œä¸å¦¨ç‚¹ä¸ª èµğŸ‘ æˆ– æ”¶è—â­ æ ‡è®°ä¸€ä¸‹ï¼Œæ–¹ä¾¿éšæ—¶å›é¡¾ã€‚ä¹Ÿæ¬¢è¿å…³æ³¨æˆ‘ï¼Œåç»­ä¸ºä½ å¸¦æ¥æ›´å¤šç±»ä¼¼çš„å®æˆ˜è§£æã€‚æœ‰ä»»ä½•ç–‘é—®æˆ–æƒ³æ³•ï¼Œæˆ‘ä»¬è¯„è®ºåŒºè§ï¼Œä¸€èµ·äº¤æµå¼€å‘ä¸­çš„å„ç§å¿ƒå¾—ä¸é—®é¢˜ã€‚