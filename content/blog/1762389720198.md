---
layout: post
title: '告别漫长GC停顿：深入解析G1如何实现可预测的毫秒级响应'
date: "2025-11-06T00:42:00Z"
---
告别漫长GC停顿：深入解析G1如何实现可预测的毫秒级响应
----------------------------

G1（Garbage-First）垃圾回收器是一款面向服务端应用、为大内存和多处理器系统设计的革命性垃圾回收器。G1的核心设计目标是在满足高吞吐量的同时，建立一个“可预测的停顿时间模型”（Pause-Time Model），让使用者可以明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾回收上的时间大概率不超过N毫秒。这一特性是它与之前回收器（如CMS）最本质的区别。  
在JDK 9发布之后，G1凭借其在性能、停顿时间控制和未来发展潜力上的综合优势，正式取代了经典的Parallel Scavenge + Parallel Old组合，成为服务端模式下的默认垃圾回收器，而一度辉煌的CMS回收器则被正式声明为不推荐使用（Deprecated），并在后续版本中被移除。  
G1的出现，标志着Java虚拟机垃圾回收技术进入了一个更加注重延迟和用户体验的新时代。

**停顿时间模型**  
G1垃圾回收器颠覆了传统分代回收器将堆内存划分为连续的新生代和老年代的物理布局。它将整个Java堆划分为多个大小相等、不要求物理连续的独立区域（Region）。每个Region的大小可以1MB到32MB之间，且必须是2的N次幂。G1会根据堆的初始大小和目标，自动选择最合适的Region大小。每个Region在运行时可以扮演不同的角色：Eden区、Survivor区，或者Old区。对于体积超过一个Region容量一半的超大对象，G1会将其视为巨型对象（Humongous Object），并直接分配到特殊的Humongous区。  
在G1之前的垃圾回收器，无论是CMS还是Parallel Scavenge，其回收范围要么是整个新生代（Minor GC），要么是整个老年代（Major GC）或整个Java堆（Full GC）。这意味着一旦触发老年代回收，其扫描和清理范围就是整个老年代空间，停顿时间会随着老年代空间的增大而线性增加，难以控制。  
G1则彻底打破了这一限制，它回收的最小单元是Region。G1可以根据预设的停顿时间目标，自由地选择任意数量、任意分代的Region组成一个回收集（Collection Set，CSet）来进行回收。G1衡量回收哪个Region的唯一标准，不再是“这个Region属于哪个分代”，而是“回收这个Region的收益有多高”。这个收益指的是花费最小的时间，回收出最大的空间。这正是“Garbage-First”名称的由来：优先回收垃圾最多的Region。  
为了实现这一目标，G1引入了停顿预测模型（Pause Prediction Model）。这个模型基于衰减均值（Decaying Average）理论。衰减均值是一种加权平均的统计方法，它给予近期的数据更高的权重，而历史久远的数据权重则会逐渐衰减。这种方法能更精确地反映系统当前的动态行为。G1在后台会持续监控和记录每一次回收中每个Region的各项指标，例如回收一个Region平均需要多长时间（回收成本）、Region内有多少存活对象（回收收益）等。  
当需要进行垃圾回收时，G1会利用这个模型进行预测：它会从所有候选Region中，按照回收收益从高到低排序，然后开始模拟选择。它会挑选收益最高的Region加入回收集，并累加预估的回收时间，然后继续挑选下一个，直到累加的预估时间即将触及用户设定的停顿时间目标（通过 -XX:MaxGCPauseMillis 参数设定）为止。通过这种方式，G1可以在满足停顿时间目标的前提下，实现垃圾回收效率的最大化，达到了性能与延迟的精妙平衡。  

**记忆集**  
为了支持对任意Region集合进行独立的回收，G1必须解决一个关键问题：如何高效地处理跨Region的对象引用。例如，当回收Region A时，必须知道是否有其他Region（如Region B、C）中的对象正引用着Region A中的对象。如果存在这样的引用，那么Region A中的被引用对象就不能被回收。为了跟踪这些跨Region引用，G1为每个Region都维护了一个名为记忆集（Remembered Set，RSet）的数据结构。  

在记忆集的设计中，通常有两种视角：一种是记录“谁指向我”（points-into），另一种是记录“我指向谁”（points-out）。G1的RSet采用的是前者，即每个Region的RSet记录了“有哪些其他的Region中的对象引用了当前Region中的对象”。具体实现上，G1的底层仍然依赖于卡表。  
如上图所示，Region1和Region3中的对象都引用了Region2中的对象，因此在Region2首先使用points-into的RSet记录了这两个引用。这个RSet其实是一个哈希表结构，key是别的Region的起始地址，value是一个集合，里面的元素是卡表的index。  
举例来说，如果Region 2的RSet里有一项的key是Region 1，value里有index为1234的卡页，它的意思就是Region 1的一个卡页里有引用指向Region 2。所以对Region 2来说，该RSet记录的是points-into的关系；而卡表仍然记录了points-out的关系。  
当回收Region2时，只需扫描其RSet，就能快速找到所有需要保留的存活对象，而无需全堆扫描。  
这种设计的代价是显著的内存开销。堆中每一个Region，无论新旧，都必须配备一份自己的卡表和RSet。这导致G1的记忆集以及相关的辅助数据结构可能会占据整个堆容量的20%甚至更多。这是G1为实现可预测停顿时间所付出的空间成本。

**Young GC And Mixed GC**  
G1垃圾回收器提供了两种垃圾回收模式：Young GC和Mixed GC，这两种模式都会暂停应用线程。  
1）Young GC：此模式的回收范围仅限于所有年轻代的Region（Eden + Survivor）。当Eden区被占满，无法为新对象分配空间时，就会触发一次Young GC。G1会根据停顿时间目标动态地调整年轻代Region的数量（即年轻代内存的大小），从而间接控制Young GC的耗时。回收过程会将存活对象复制到Survivor区或晋升到Old区，与传统的Minor GC类似。  
2）Mixed GC：这是G1最具特色的回收模式。它不仅会回收所有年轻代的Region，还会额外回收一部分老年代的Region。Mixed GC的触发时机通常是在老年代的堆占用比例达到某个阈值（由 -XX:InitiatingHeapOccupancyPercent参数控制，默认为45%）之后，由全局并发标记（Global Concurrent Marking）阶段统计出回收收益最高的一批老年代Region。在执行时，Mixed GC会根据用户设定的停顿时间目标，在新生代之外，优先选择那些垃圾最多的老年代Region加入回收集（CSet），一起进行回收。  
必须强调，Mixed GC不等于Full GC。它是一种增量式的、部分回收老年代的机制，旨在通过多次、小规模的回收来逐步清理老年代，避免出现长时间的Full GC停顿。然而，如果应用程序的内存分配速率过快，导致Mixed GC的清理速度跟不上对象晋升到老年代的速度，最终老年代被填满，G1将不得不放弃其优雅的回收方式，触发一次后备的、单线程的Full GC（Serial Old GC） 来整理整个堆。

**工作过程**  
G1的完整工作过程可以划分为以下几个核心阶段，其中并发标记是与应用程序并发执行的，而其他阶段则需要暂停应用线程。  
1）初始标记（Initial Marking）：一个短暂的停顿阶段。这个阶段仅标记出从GC Roots（如栈上的本地变量、静态变量等）能直接关联到的对象。它的耗时非常短。  
2）并发标记（Concurrent Marking）：此阶段与应用程序并发执行，不产生停顿。G1会从初始标记阶段找到的对象出发，开始递归遍历整个堆中的对象图，找出所有存活的对象。G1采用原始快照算法，保证在并发标记开始时存活的对象，无论在标记过程中引用关系如何变化，最终都会被认为是存活的。这种机制的副作用是可能产生一些浮动垃圾，这些垃圾只能等到下一次回收周期才能被清理。  
3）最终标记（Final Marking）：一个短暂的停顿阶段。由于并发标记阶段应用线程仍在运行，可能会修改对象的引用关系，原始快照算法会将这些变化记录下来。此阶段的目的就是处理这些在并发标记期间产生的日志，对标记结果进行修正。  
4）筛选回收（Live Data Counting and Evacuation）：一个核心的停顿阶段，负责真正的垃圾清理。在此阶段，G1首先会对各个Region的存活对象数量和回收价值进行精确统计（Live Data Counting）。然后，基于其停顿时间预测模型，选择一组回收价值最高的Region组成回收集（CSet）。最后，G1会将CSet中所有Region里的存活对象通过复制算法拷贝到新的、空闲的Region中，并清空CSet中的所有旧Region。这个复制的过程天然地完成了内存碎片的整理，一举两得。  

G1的优势主要体现在停顿时间的可预测性和空间的高效整合。G1的停顿时间与回收集的大小有关，而非整个Java堆的大小，这使得停顿时间更加可控。同时，G1在全局范围内采用整理算法，在局部Region之间采用复制算法，这两种算法都能有效避免内存碎片的产生，从而杜绝了因碎片过多而触发的耗时Full GC。  
然而，G1也存在一些缺点。首先，G1在运行过程中需要执行复杂的并发操作（如并发标记）和维护写屏障，这些都会消耗额外的处理器资源。其次，为了实现高效的垃圾回收，G1需要维护Region、RSet、卡表等复杂数据结构，这会占用一部分内存空间。最后，如果垃圾产生的速度远远超过G1的回收速度（尤其是Mixed GC的回收速度），可能会导致堆迅速填满，最终退化为非常缓慢的Full GC。  
根据业界的实践经验，对于小内存应用（例如堆大小小于4GB），传统的CMS甚至Parallel GC在吞吐量上的表现往往优于G1。然而，当Java堆大小超过一个临界点时，G1在控制停顿时间上的优势便开始凸显。这个优劣势的转换点通常在6GB至8GB之间。

**未完待续**

**很高兴与你相遇！如果你喜欢本文内容，记得关注哦**

本文来自博客园，作者：[poemyang](https://www.cnblogs.com/poemyang/)，转载请注明原文链接：[https://www.cnblogs.com/poemyang/p/19194401](https://www.cnblogs.com/poemyang/p/19194401)

posted on 2025-11-05 18:27  [poemyang](https://www.cnblogs.com/poemyang)  阅读(46)  评论(0)    [收藏](javascript:void\(0\))  [举报](javascript:void\(0\))