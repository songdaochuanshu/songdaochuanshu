---
layout: post
title: '从零开始的函数式编程(2) —— Church Boolean 编码'
date: "2025-02-12T00:36:13Z"
---
从零开始的函数式编程(2) —— Church Boolean 编码
==================================

> \[!quote\] 关于λ表达式……  
> 详见[λ表达式](https://www.cnblogs.com/oberon-zjt0806/p/18708237)

> ⚠ **本文导出自Obsidian**，可能存在格式偏差（例如链接、Callout等）  
> 本文地址：[https://www.cnblogs.com/oberon-zjt0806/p/18710283](https://www.cnblogs.com/oberon-zjt0806/p/18710283)

目录

*   [λ演算与λ代数](#λ演算与λ代数)
    *   [Church 编码](#church-编码)
        *   [Church-Boolean 逻辑编码](#church-boolean-逻辑编码)
            *   [条件选择函数](#条件选择函数)
            *   [真与假 | True | False](#真与假--true--false)
            *   [逻辑运算 | AND | OR | NOT](#逻辑运算--and--or--not)
                *   [合取 | 且 | AND](#合取--且--and)
                *   [析取 | 或 | OR](#析取--或--or)
                *   [反转 | 非 | NOT](#反转--非--not)

λ演算与λ代数
=======

上一整节我们利用λ符号体系构建了一套表达式系统，从这里开始，我们将正式开始利用这套系统进行代数应用，在进行演算之前，需要先利用符号体系构建一个**代数运算系统**。

> \[!note\] 命名终究只是命名  
> 虽然我们之前使用了很多诸如`(+ x 1)`等等这样的形式，但它们只是我们定义的命名，所以无论是`x`还是`+`和`1`，都**只是一个记号**而已，尽管我们根据以往的经验为这些符号赋予了某些我们所熟知的含义，但在当前的λ演算语境下，这些东西都还**没定义**过。

Church 编码
---------

为了使λ演算能够**具体应用**到计算机和程序上，那么就意味着λ代数系统必须能够表示如下两种东西——

*   **数值**（逻辑值、整数……）
*   **运算**（算符、函数、操作……）

也就是说，这些东西要在λ演算中**映射为λ表达式**（使用表达式来表示）。

> \[!tip\]  
> 粗暴地说，Church编码就是**一种**把数值和运算**编码为λ表达式**的过程。
> 
> *   但注意！Church编码**并非唯一**的编码方式，还有其他的编码方式，如**Scott编码**等。
> *   Church编码的特点在于以**数值**表示为**起点**进行编码，并在基础上构建其他编码。

### Church-Boolean 逻辑编码

> \[!abstract\] Church-Boolean 编码汇总  
> 为了方便查阅，这里将本节所有的编码定义列出来，正文是比较冗长的推导过程
> 
>     DEF T = λx.λy.x
>     DEF F = λx.λy.y
>     DEF AND = λP.λQ.(P Q P)
>     DEF OR = λP.λQ.(P P Q)
>     DEF NOT = λP.λQ.(P F T)
>     

首先我们需要通过Church编码构建出**布尔运算系统**。之所以先选择布尔代数，是因为布尔代数的结构简单，性质清晰，比较容易构建。

**布尔代数**（Boolean Algebra）包含的内容非常简单——

*   布尔域\\(\\mathbb B\\)中只包含**两个元素**\\(\\mathrm T\\)和\\(\\mathrm F\\)
*   支持三种基本运算\\(\\wedge\\) 、\\(\\vee\\)、\\(\\neg\\) 。
*   运算对域封闭，且对于\\(\\wedge\\)和\\(\\vee\\)都在\\(\\mathbb B\\)上分别存在上界和下界

#### 条件选择函数

在介绍Church-Boolean中的真假值前，我们先来考察**条件选择函数**，所谓条件选择函数就是下面这样的一个三元函数——

\\\[\\operatorname{COND} (c,x,y) = \\begin{cases} x, &c=\\mathrm{T} \\\\ y, &c=\\mathrm{F} \\end{cases} \\\]

其中\\(c\\)是条件值，条件选择函数根据\\(c\\)的值就在\\(x\\)和\\(y\\)中做出选择。可以发现，实际上，这个条件选择函数就对应了大多数编程语言中的**三元运算符**`c ? x : y`。

我们将这个运算表示为`IF-THEN-ELSE`形式，可以表示为——

    IF c THEN x ELSE y
    

可以发现这里分为3个子部——

*   `IF c` ：判断`c`的条件；
*   `THEN x`：当`c == true`被满足时，选择`x`；
*   `ELSE y`：上述条件不成立时，选择`y`；

至此，我们可以把这三个部分**抽象**为**三个λ表达式**。

    DEF cond = λc.λx.λy.(c x y)
    

由于**真假值**承载于`c`中，因此我们就利用`c`来对真假值进行编码。

#### 真与假 | True | False

基于上面的想法，我们就能够通过Church编码定义出逻辑的真值`T`和假值`F`。讨论`c`的情况，根据定义，`cond`函数应当满足——

    cond T x y => λc.λx.λy.(c x y) T x y => λx.λy.(T x y) x y => T x y => x
    COND F x y => λc.λx.λy.(c x y) T x y => λx.λy.(F x y) x y => F x y => y
    

观察**倒数两步归约**，我们发现

*   欲使`T x y => x`，那么就要求`(T x) y`必须发生**η归约**。
    *   也就是说`(T x)`中**约束不生效**，可以构建自由表达式`(T x) == λb.x`
        *   再脱去对`x`的运用，解开约束对，意味着我们需要引入一个新的约束变量
        *   于是我们就可以得到`T == λa.λb.a`。
*   欲使`F x y => y`，那么就要求`(F x) y`必须发生**β归约**。
    *   而且更进一步地，`(F x) == identity == λb.b`
        *   类似地，再脱去对`x`的运用，解开约束对，引入另外的约束变量 `λa`
        *   于是`F == λa.λb.b`

> \[!tip\] 反归约技巧  
> 我们知道对于运用`(f x)`进行归约时，会将`f`中受约束的变量替换为参数`x`，例如`(λa.a x) => x`  
> 那么，反过来对于已知的某一表达式`x`如果想要引入约束，或者把`x`作为参数提出来，那么就需要引入新的不冲突的约束命名，`x => (λy.y x)`。  
> 利用这种性质在已知`(f x)`的情况下可以展开`f == λa.(f a)`

^9b9507

经过α转换，将`a`更名为`x`，`b`更名为`y`，我们就可以得出`T`和`F`的定义

    DEF T = λx.λy.x
    DEF F = λx.λy.y
    

这种定义下的`T`和`F`被映射为λ函数，因此可以作为一种条件选择函数来运用。

可以将上述定义代入表达式`(c x y)`通过\[\[λ表达式#归约 消解|归约\]\]来证明这个编码的**正确性**——

> \[!warning\] 注意  
> 归约化简时，不要忘记**变量约束的右结合律**和**函数运用的左结合律**

    (T T F) => (λx.λy.x λx.λy.x λx.λy.y)
        β|=> (λx.λy.(λx.λy.x) λx.λy.y) 
        α|=> (λy.(λa.λb.a) λx.λy.y)
        η|=> (λa.λb.a)
        α|=> (λx.λy.x) => T
    
    (F T F) => (λx.λy.y λx.λy.x λx.λy.y)
        η|=> (λy.y λx.λy.y)
        β|=> (λx.λy.y) => F // alternatively, ==> identity F => F
    

#### 逻辑运算 | AND | OR | NOT

接下来要对**逻辑运算**进行Church编码，这里先给出三种**基本逻辑运算**的**真值表**——

A

B

A **AND** B

A **OR** B

**NOT** A

F

F

F

F

T

F

T

F

T

T

T

F

F

T

F

T

T

T

T

F

XOR、NAND之类的都可以在这三种基本运算的基础上组合出来。所以我们姑且只定义上面三个基本运算即可。

在正式开始之前，我们先考察一个东西——既然`T`和`F`都被映射为**函数**，那么意味着他们可以**相互**作为函数和参数**构成约束对**进行运用，那么约束对能否**归约**，以及归约后的**结果**是什么，这里给出两个基本函数相互运用的归约结果——

    T T => (λx.λy.x) (λx.λy.x) β|=> λy.(λx.λy.x) α|=> λy.(λa.λb.a) => λy.T
    T F => (λx.λy.x) (λx.λy.y) β|=> λy.(λx.λy.y) α|=> λy.(λa.λb.b) => λy.F
    [i.e.]  T P => λy.P
            T P Q => P
    F T => (λx.λy.y) (λx.λy.x) η|=> λy.y => identity
    F F => (λx.λy.y) (λx.λy.y) η|=> λy.y => identity
    [i.e.]  F P => λy.y => identity
            F P Q => Q
    

^6686a8

需要注意的是，归约结果中的`T`和`F`中的`x`和`y`和外层约束的`y`**没有任何关系**，而是出现了**命名冲突**（如果要展开那么需要进行一次**α转换**），所以实际上这里的`T`是**自由表达式**。在上面的归约过程中，我们可以归纳出如下性质——

*   如果以`T`作为函数运用`(T P)`（其中`P,Q in {T, F}`），那么会通过**β归约**将`x`替换为`P`从而得到一个新的函子`λy.P`，且`Q`不受`y`的约束。
    *   把这个结果`λy.P`再作为函数并传入参数`Q`构成约束对，那么下一步将发生**η归约**，消去`λy`约束，最终只会剩下`P`（`T P Q => λy.Q Q => Q`）
*   如果以`F`作为函数，那么由于`F`的`λx`并**没有进行约束**，所以先进行**η归约**，消去`λx`约束，最终总会留下`λy.y`，好巧不巧地，这正好是**恒等函数**`identity`
    *   那接下来就很清晰了，如果再传入参数`Q`，由于`identity`的性质，或者直接通过**β归约**替换，则会只留下后面的这个参数`P`（`F P Q => identity Q => λy.y Q => Q`）

![image](https://img2024.cnblogs.com/blog/1648849/202502/1648849-20250211231401741-1340106613.png)

完成上面的工作有助于我们通过Church编码来**定义逻辑运算**。

##### 合取 | 且 | AND

首先来看一下合取运算，合取的要求是只有当两个输入均为`T`，才可以被归约为`T`，其他情形全部为`F`——

    AND T Q => Q
        AND T => (F P)
    AND F Q => F
        AND F => (T P)
    

观察上面的形式，对于`AND P Q` ，我们可以做出如下归纳

*   当`P==T`时，`AND P Q => AND T Q => Q`
    *   这种情况对应\[\[#^6686a8|上面\]\]的`(F P)`，于是`AND T Q => F P Q`
*   当`P==F`时，`AND P Q => AND F Q => F`
    *   这种情况对应\[\[#^6686a8|上面\]\]的`(T P)`，于是`AND F Q => T P Q`

> \[!question\] 麻烦了  
> 目前我们归纳出的结论是`AND P == (NOT P) P`，然而问题在于我们还**没有定义过**`NOT`， 这怎么办呢？

> \[!tip\] 还好  
> `AND`满足**交换律**，也就是说应当有`AND P Q == AND Q P`

通过交换律将`AND P Q`换成`AND Q P`，不影响先前的结论，除了讨论对象此时从`AND P`变成了`AND Q`。

    AND Q P[P:=T] => Q
        AND Q => (T Q)
    AND Q P[P:=F] => AND Q F => F
        AND Q => (F Q)
    AND Q => (P Q)
    

终于我们可以得出`AND`的Church编码——

    DEF AND = λP.λQ.(P Q P)
    

##### 析取 | 或 | OR

与合取**类似**，析取也具有**交换律**，并且我们也可以**效仿刚才**的过程完成`OR`的定义，首先考察

    OR T Q => T
        OR T => (T P)
    OR F Q => Q
        OR F => (F P)
    

这次无需交换律了，直接替换就能够得到`OR`的定义——

    DEF OR = λP.λQ.(P P Q)
    

##### 反转 | 非 | NOT

`NOT`比较特别，因为`NOT`是一个**一元**运算，需要单独讨论。

    NOT T == NOT λx.λy.x => F == λx.λy.y
    NOT F == NOT λx.λy.y => T == λx.λy.x
    

简单来说，输入的参数是选择其中一个，那么`NOT`的输出总是选择另外一个。考虑到真假值`T`和`F`均是通过`cond`定义的，那么，如果**直接反转**`cond`的**定义**是不是就能够得到相反的输出？

    cond == λc.λx.λy.(c x y)
    ncond == λc.λx.λy.(c y x)
    

于是我们得到了**一种**`NOT`的定义形式

    DEF NOT1 = λP.λx.λy.(P y x)
    

这个形式看起来比较底层，我们能不能利用已有的**逻辑值**来定义呢？

再次考察 `cond P` ——

    cond P => λP.λx.λy.(P x y) P => λx.λy.(P x y)
    

如果考虑将`x`替换为`F`，`y`替换为`T`，也能达成同样的效果，于是我们进一步提供参数——

    cond P F T => λx.λy.(P x y) F T => P F T
    

于是我们得到了**另一种**`NOT`的定义——

    DEF NOT2 = λP.(P F T)
    

通过归约可证明，`NOT1 <=> NOT2`

至此，两个逻辑值和三个基本逻辑运算被**定义完毕**，Church-Boolean编码完成，可以使用λ表达式进行逻辑演算了。

> \[!question\] 思考  
> 不妨试试用类似的方式定义出更多的逻辑运算，例如异或`XOR`、与非`NAND`等……

* * *

作者：[Oberon](https://www.cnblogs.com/oberon-zjt0806/)

出处：[https://www.cnblogs.com/oberon-zjt0806/](https://www.cnblogs.com/oberon-zjt0806/)

本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文连接，否则保留追究法律责任的权利。