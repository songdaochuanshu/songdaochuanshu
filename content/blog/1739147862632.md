---
layout: post
title: 'SQL注入之时间盲注'
date: "2025-02-10T00:37:42Z"
---
SQL注入之时间盲注
==========

SQL注入之时间盲注
==========

一、时间盲注原理
--------

时间盲注技术的核心在于巧妙地运用数据库中的时间延迟函数（例如 `MySQL` 的 `SLEEP()` 函数或 `PostgreSQL` 的 `PG_SLEEP()` 函数）来验证注入条件的有效性。当注入条件成立时，数据库会执行这些延迟函数，从而导致页面响应时间显著增加；反之，若条件不成立，则不会产生延迟效果。这项技术之所以被称为“盲注”，原因在于它并不能直接将查询结果反馈到页面或接口返回值中，而是依赖于SQL语句执行所产生的时间延迟来间接推断数据内容。

二、时间盲注方法
--------

时间盲注的方法主要是利用 `if(booleans, true_value, false_value)` 函数 和 `sleep(seconds)` 函数组合来获取数据库内容。  
**常见语句**

    SELECT IF(SUBSTRING((SELECT DATABASE()), 1, 1) = 'a', SLEEP(5), 1)
    

    SELECT IF(ASCII(SUBSTRING((SELECT DATABASE()), 1, 1)) < 100, SLEEP(5), 1)
    

**解析**

`IF(booleans, true_value, false_value)` 函数：

*   `booleans`：这是一个布尔表达式，用于确定要返回哪个值。如果条件为真（非零和非 `NULL`），则返回 `true_value`。
*   `true_value`：如果条件为真，则 `IF` 函数返回这个值。
*   `false_value`：如果条件为假（零或 `NULL`），则 `IF` 函数返回这个值。

`SUBSTRING(string, start, length)` 函数：

*   `string`：要从中提取子字符串的原始字符串。
*   `start`：子字符串的起始位置。在SQL中，这个位置通常是从1开始的。如果`start`为负数，则表示从字符串的尾部开始计数。
*   `length`：要提取的字符数。这是一个可选参数。如果省略此参数，则将从起始位置提取到字符串的末尾。

`SLEEP(seconds)` 函数：

*   `seconds`：数据库暂停秒数。

`ASCII(char)` 函数：

*   `char`： 想要转换为ASCII码的单个字符。

通过对这两条语句的解析，我们可以得出以下结论：

*   **第一条语句**：判断数据库名称的第一个字符是否为 `a`。如果是，则数据库会暂停5秒；如果不是，则返回数据 `1`。
*   **第二条语句**：判断数据库名称第一个字符的ASCII码是否小于100（字符 `a` 的ASCII码为97）。如果是，则数据库会暂停5秒；如果不是，则返回数据 `1`。

相比之下，作者更倾向于使用第二种方法，因为通过ASCII码结合二分查找法，可以更高效地定位目标字符。二分查找的时间复杂度为 `O(log n)`，而传统的遍历法时间复杂度为 `O(n)`，前者在效率上具有明显优势。  
![image](https://img2024.cnblogs.com/blog/2972727/202502/2972727-20250208173903996-227845971.png)

三、时间盲注实例
--------

在Pikachu平台上进行实践时，我们在输入框内输入了特定的SQL注入测试字符串：`' and sleep(5) #`。

![image](https://img2024.cnblogs.com/blog/2972727/202502/2972727-20250208163332354-92058207.png)

发现接口35秒多才返回，与平常的检索时间多了35秒。虽然查询语句延时了，但不是我们规定的5秒，而是35秒，这是为什么呢？

为了探究原因，我们对生成的SQL语句进行了深入分析：

    SELECT id, username, email FROM member WHERE username LIKE '%' AND SLEEP(5) #%'
    

在 `WHERE` 子句中，多个表达式通过 `AND` 连接时，数据库通常会采用短路逻辑（Short-Circuit Evaluation）来优化计算：  
如果某个表达式为 `FALSE`，则后续的表达式无需再计算，因为整个条件已经确定为 `FALSE`。

基于这一逻辑，我们推断出接口响应延迟35秒的原因：在数据库中，满足`username LIKE '%'`条件的数据记录多达7条。为了验证这一推断，我们直接连接数据库进行了查询，结果确实发现了7条匹配记录。  
![image](https://img2024.cnblogs.com/blog/2972727/202502/2972727-20250208171319791-1532702094.png)

接下来，我们决定继续进行时间盲注攻击，但为了提高效率，我们需要调整策略，确保`username LIKE '%'`表达式能够精确匹配到唯一一条记录。例如，我们可以将表达式修改为`username LIKE '%vince'`，即在输入框中输入：`vince' and sleep(5) #`。

![image](https://img2024.cnblogs.com/blog/2972727/202502/2972727-20250208171657154-1590398699.png)

此时，接口的响应时间终于恢复到了我们预期的5秒多。

随后，我们利用`if()`函数来尝试获取数据库中的信息。在输入框中，我们输入了如下字符串：`vince' and IF(SUBSTRING((SELECT DATABASE()), 1, 1) = 'p', SLEEP(5), 1) #`  
![image](https://img2024.cnblogs.com/blog/2972727/202502/2972727-20250208174213382-1173224560.png)

这条语句用于判断数据库名称的首位字符是否为'p'。如果判断为真，则接口响应会延迟5秒；否则，响应将立即返回。通过这种方法，我们可以逐步推断出数据库名称的每一位字符。至于后续如何获取数据库第二位及更多位字符的操作，原理相同，此处不再赘述。