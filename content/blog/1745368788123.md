---
layout: post
title: '.NET 原生驾驭 AI 新基建实战系列（四）：Qdrant  ── 实时高效的向量搜索利器'
date: "2025-04-23T00:39:48Z"
---
.NET 原生驾驭 AI 新基建实战系列（四）：Qdrant ── 实时高效的向量搜索利器
=============================================

向量数据库作为一种专为现代AI应用设计的新型存储技术，能够高效地管理和检索高维数据，成为智能应用开发中的关键基础设施。本文将深入探讨 Qdrant 这个开源、高性能的向量数据库，重点介绍其如何与 .NET 生态系统结合，为开发者提供强大的工具支持。我们将从安装配置到代码实现，再到实际应用场景，全面展示 Qdrant 在 .NET 中的使用方式。

* * *

一、Qdrant 简介
-----------

Qdrant 是一款专为 AI 和 ML 应用打造的开源向量数据库，旨在提供高效的向量存储和相似性搜索能力。它以高性能、灵活性和易用性为核心设计理念，支持实时查询、元数据过滤和分布式部署，非常适合需要处理大规模高维数据的场景。无论是语义搜索、推荐系统还是多媒体内容检索，Qdrant 都能为开发者提供可靠的支持。

### 1.1 Qdrant 的核心特点

Qdrant 的独特优势体现在以下几个方面：

*   **开源与高性能**：Qdrant 遵循 Apache 2.0 许可，完全开源，开发者可以自由使用和定制。它针对高维向量数据进行了深度优化，确保在大规模数据集上的查询性能。
    
*   **实时性与灵活性**：支持实时向量搜索，并允许在查询时结合元数据过滤，满足复杂的业务逻辑需求。
    
*   **分布式架构**：支持水平扩展，可以部署在多节点集群上，提升系统的可伸缩性和可靠性。
    
*   **多语言支持**：通过 REST API 和 gRPC 接口，Qdrant 能够与多种编程语言无缝集成，包括通过 C# 客户端支持 .NET。
    
*   **易于集成**：官方提供的 `Qdrant.Client` NuGet 包让 Qdrant 在 .NET 项目中的接入变得简单高效。
    

### 1.2 Qdrant 的核心概念

Qdrant 是一个开源向量数据库，专为存储、搜索和管理高维向量设计，广泛应用于人工智能和机器学习领域，尤其是嵌入向量存储和相似性搜索。以下是其核心概念的整理：

*   嵌入（Embeddings）
    

嵌入是将原始数据（如文本、图像）转化为高维向量的过程，这些向量捕捉数据的语义信息，是向量数据库的核心数据类型。

*   相似性搜索（Similarity Search）
    

相似性搜索是查找与查询向量最相似的向量的过程，Qdrant 使用近似最近邻（ANN）算法实现高效搜索。

*   集合（Collections）
    

集合是向量的逻辑分组，类似于传统数据库中的表，包含特定配置（如向量维度和距离度量）。

*   点（Points）
    

点是集合中的单个条目，包含向量、唯一 ID 和可选的元数据（负载），是存储和检索的基本单元。

*   负载（Payload）
    

负载是与向量关联的元数据（JSON 格式），提供额外上下文并支持搜索时的过滤。

*   距离度量（Distance Metrics）
    

距离度量用于衡量向量间的相似性，Qdrant 支持欧几里得距离、余弦相似度和点积等多种方式。

*   索引（Indexing）
    

索引是加速向量搜索的数据结构，Qdrant 使用 HNSW（层次可导航小世界）算法实现高效近似最近邻搜索。

*   过滤（Filtering）
    

过滤允许基于负载元数据添加搜索条件，实现更精确的检索结果。

*   API
    

Qdrant 提供 RESTful 和 gRPC API，用于向量插入、搜索和集合管理等操作。

*   分布式部署（Distributed Deployment）
    

Qdrant 支持分布式部署，多节点协同处理大规模数据和高并发请求，提升可扩展性和性能。

### 1.3 Qdrant 的工作机制

Qdrant 的核心在于其高效的向量索引和搜索技术。它采用了 HNSW（Hierarchical Navigable Small World）等先进算法来构建向量索引，支持多种距离度量方式，如欧几里得距离、余弦相似度和内积。开发者可以将文本、图像或其他数据的嵌入（embeddings）存储在 Qdrant 中，通过相似性搜索快速找到最相关的结果。这种机制特别适用于需要理解数据深层语义的场景，与传统的关键字匹配方式形成了鲜明对比。

![](https://files.mdnice.com/user/4969/da6b1f6f-5638-41d1-8025-169923df0308.png)

与 Chroma 类似，Qdrant 的设计也强调了易用性和性能，但它在分布式支持和实时性上更进一步，为需要高可用性和低延迟的应用提供了额外的优势。

* * *

二、在 .NET 中安装与配置 Qdrant 环境
-------------------------

要在 .NET 项目中使用 Qdrant，开发者需要安装其 C# 客户端库并完成基本配置。以下是详细的步骤，确保从零开始的开发者也能顺利上手。

### 2.1 安装 Qdrant.Client NuGet 包

Qdrant 提供了官方的 C# 客户端库，可以通过 NuGet 包管理器轻松安装，**注意以下包存在预览版，所以需要加上预览标识**：

*   `Qdrant.Client`，
    
*   `Microsoft.SemanticKernel.Connectors.Qdrant`
    
*   `Microsoft.Extensions.AI`
    
*   `Microsoft.Extensions.AI.Ollama`
    

1.  **命令行安装**： 在 Visual Studio 的“包管理器控制台”中运行以下命令：
    
        Install-Package Qdrant.Client
        Install-Package Microsoft.SemanticKernel.Connectors.Qdrant  --prerelease
        Install-Package Microsoft.Extensions.AI  --prerelease
        Install-Package Microsoft.Extensions.AI.Ollama  --prerelease
    
2.  **图形界面安装**：
    
    *   右键点击 .NET 项目，选择“管理 NuGet 包”。
        
    *   在搜索框中输入 `Qdrant.Client`等包，选择官方包。
        
    *   点击“安装”，等待安装完成。
        
    

安装成功后，项目会自动引用 `Qdrant.Client`，为后续开发奠定基础。

### 2.2 配置 Qdrant 客户端

在使用 Qdrant 之前，需要初始化一个 `QdrantClient` 实例，并指定连接参数。以下是一个简单的配置示例：

    using Qdrant.Client;
    
    var vectorStore = new QdrantVectorStore(new QdrantClient("localhost"));

*   `host`：Qdrant 服务的地址，默认值为 `localhost`。如果服务部署在远程服务器上，需要替换为实际 IP 或域名。
    
*   `port`：Qdrant 的默认端口为 `6334`，可根据实际部署调整。
    

### 2.3 启动 Qdrant 服务

Qdrant 客户端需要连接到一个运行中的 Qdrant 实例。开发者可以通过以下方式启动服务：

*   **Docker 部署**： 使用以下命令在本地运行 Qdrant：
    
        docker run -d -p 6333:6333 -p 6334:6334 qdrant/qdrant
    
*   **手动运行**： 从 Qdrant 的 GitHub 仓库下载二进制文件，解压后执行：
    
        ./qdrant
    

![](https://files.mdnice.com/user/4969/c363722c-d175-4ed4-9b17-ba81aa84c745.png)

服务启动后，.NET 客户端即可通过指定的地址和端口与之通信。与 Chroma 类似，Qdrant 的安装过程简单明了，但其 Docker 支持和分布式特性为大规模部署提供了更多选择。

*   UI界面
    

大家可以打开地址：`http://localhost:6333/dashboard#/welcome`，查看UI界面

![](https://files.mdnice.com/user/4969/91dd9365-76dd-4471-870a-f9640c7b4297.png)

### 2.4 安装Ollama并配置相关模型

*   安装mxbai-embed-large用于生成嵌入向量
    

![](https://files.mdnice.com/user/4969/6d026f65-f0c3-47ea-9a4b-b0543bb348fb.png)

* * *

三、Qdrant 在 .NET 中的代码示例
----------------------

为了让开发者快速掌握 Qdrant 的使用方法，以下提供了一系列实用的代码示例，涵盖创建集合、添加数据、执行查询和元数据过滤等核心功能。

### 3.1 创建集合

在 Qdrant 中，集合（Collection）是存储向量的基本单位。以下代码展示了如何创建一个名为`skhotels`的集合：

首先需要创建`Hotel`实体，注意`DescriptionEmbedding`字段的`Dimensions`数值为384，这与我们使用的模型有关，模型发生变化，这个数值也要发生变化。

    using Microsoft.Extensions.VectorData;
    
    namespace QdrantVectorTest;
    
    /// <summary>
    /// 
    /// </summary>
    public class Hotel
    {
        /// <summary>
        /// Gets or sets the hotel identifier.
        /// </summary>
        /// <value>
        /// The hotel identifier.
        /// </value>
        [VectorStoreRecordKey]
        public ulong HotelId { get; set; }
    
        /// <summary>
        /// Gets or sets the name of the hotel.
        /// </summary>
        /// <value>
        /// The name of the hotel.
        /// </value>
        [VectorStoreRecordData(IsFilterable = true)]
        public string HotelName { get; set; }
    
        /// <summary>
        /// Gets or sets the description.
        /// </summary>
        /// <value>
        /// The description.
        /// </value>
        [VectorStoreRecordData(IsFullTextSearchable = true)]
        public string Description { get; set; }
    
        /// <summary>
        /// Gets or sets the description embedding.
        /// </summary>
        /// <value>
        /// The description embedding.
        /// </value>
        [VectorStoreRecordVector(Dimensions: 384, DistanceFunction.CosineSimilarity, IndexKind.Hnsw)]
        public ReadOnlyMemory<float>? DescriptionEmbedding { get; set; }
    
        /// <summary>
        /// Gets or sets the tags.
        /// </summary>
        /// <value>
        /// The tags.
        /// </value>
        [VectorStoreRecordData(IsFilterable = true)]
        public string[] Tags { get; set; }
    }

    using Microsoft.Extensions.AI;
    using Microsoft.SemanticKernel.Connectors.Qdrant;
    using Qdrant.Client;
    using QdrantVectorTest;
    #pragma warning disable SKEXP0001
    
    var vectorStore = new QdrantVectorStore(new QdrantClient("localhost"));
    var collection = vectorStore.GetCollection<ulong, Hotel>("skhotels");
    
    await collection.CreateCollectionIfNotExistsAsync();

集合创建成功：

![](https://files.mdnice.com/user/4969/3fcc86a0-359e-48d3-8d49-297a1f0545a1.png)

### 3.2 添加向量嵌入生成算法

这里通过`Ollama`使用`all-minilm`作为向量嵌入生成算法模型

    async Task<ReadOnlyMemory<float>> GenerateEmbeddingAsync(string descriptionText)
    {
        IEmbeddingGenerator<string, Embedding<float>> generator =
            new OllamaEmbeddingGenerator(new Uri("http://localhost:11434/"), "all-minilm");
    
        var embedding = await generator.GenerateEmbeddingVectorAsync(descriptionText);
    
        return embedding;
    }

### 3.2 添加向量数据

向集合中添加点（points）时，需要指定 ID、向量和可选的元数据（payload）。以下示例展示了如何添加两篇文档的向量和元数据：

    string descriptionText = "一个高档的参加团队聚会的地方";
    ulong hotelId = 1;
    
    await collection.UpsertAsync(new Hotel
    {
        HotelId = hotelId,
        HotelName = "Bulgari",
        Description = descriptionText,
        DescriptionEmbedding = await GenerateEmbeddingAsync(descriptionText),
        Tags = new[] { "luxury", "pool" }
    });

### 3.3 执行相似性搜索

通过向量查询，可以找到与给定向量最相似的点。以下代码展示了如何检索与查询向量最接近的两篇文章：

    
    ReadOnlyMemory<float> searchVector = await GenerateEmbeddingAsync("我需要找一家高档酒店");
    
    var searchResult = await collection.VectorizedSearchAsync(searchVector, new() { Top = 1 });
    
    await foreach (var record in searchResult.Results)
    {
        Console.WriteLine("描述信息: " + record.Record.Description);
        Console.WriteLine("匹配分数: " + record.Score);
    }

输出如下：

![](https://files.mdnice.com/user/4969/1497bc63-88ce-4c46-a935-6104fce7f96f.png)

* * *

四、Qdrant 应用场景
-------------

### 4.1 语义搜索系统

在企业文档管理系统中，传统的关键字搜索难以捕捉用户意图的深层含义。通过将文档内容转换为嵌入并存储在 Qdrant 中，开发者可以实现语义搜索。例如，用户输入“如何提高团队协作效率”，系统能够返回与团队管理、协作工具相关的内容，而不仅仅是包含“效率”一词的文档。

### 4.2 个性化推荐引擎

在电商平台中，Qdrant 可以存储用户行为和商品特征的向量表示。例如，将用户的浏览历史和商品描述转换为嵌入，通过相似性搜索为用户推荐相关产品。这种方法能够捕捉用户兴趣的细微变化，提供更精准的推荐体验。

### 4.3 多媒体内容检索

在图像或视频管理应用中，Qdrant 可以存储多媒体内容的嵌入向量。例如，用户上传一张风景照片，系统能够快速返回视觉上相似的图像，适用于内容推荐、版权检测等场景。与 Chroma 类似，Qdrant 在这一领域表现出色，但其分布式支持使其更适合处理大规模多媒体数据。

### 4.4 智能问答系统

在客户支持应用中，Qdrant 可以存储常见问题及其答案的向量表示。用户提问时，系统通过向量搜索返回最匹配的答案，提升响应速度和准确性。这种应用与 Chroma 的 NLP 场景类似，但 Qdrant 的实时性使其在高并发场景中更具优势。

* * *

五、Qdrant 与 .NET 生态系统的集成
-----------------------

Qdrant 不仅可以通过 C# 客户端直接使用，还能与 .NET 生态中的其他工具深度结合，提升开发效率：

*   **Semantic Kernel**：微软推出的 AI 开发框架支持与 Qdrant 集成，开发者可以将其作为向量存储，用于构建复杂的 AI 工作流。
    
*   **ASP.NET Core**：通过依赖注入机制，Qdrant 客户端可以轻松集成到 Web 应用中，为实时智能功能提供支持。
    
*   **Entity Framework 风格的扩展**：借助 `Microsoft.Extensions.VectorData`，Qdrant 可以与 .NET 的标准化数据访问接口协作，简化开发流程。
    

这些集成特性与 Chroma 在 .NET 中的应用方式相似，但 Qdrant 的分布式支持和 gRPC 接口为其带来了额外的灵活性。

* * *

六、性能优化技巧
--------

为了在 .NET 中充分发挥 Qdrant 的潜力，开发者可以采用以下优化策略：

*   **索引优化**：调整 HNSW 参数（如 `m` 和 `ef_construction`），在查询速度和精度之间找到最佳平衡。
    
*   **分布式部署**：对于大规模数据，利用 Qdrant 的集群功能分片存储和并行查询，提升吞吐量。
    
*   **本地缓存**：在 .NET 应用中为热点查询添加缓存层，减少对 Qdrant 的直接请求。
    

这些技巧虽与 Chroma 的性能优化建议有异曲同工之妙，但 Qdrant 的分布式特性为其在大规模场景中的优化提供了更多可能性。

* * *

七、Qdrant 的未来发展展望
----------------

随着向量数据库在 AI 驱动应用中的重要性日益凸显，Qdrant 作为一款开源项目展现出广阔的前景：

*   **功能增强**：未来可能支持更多索引类型和距离度量，满足多样化的应用需求。
    
*   **性能突破**：通过算法优化，进一步提升大规模数据集的处理能力。
    
*   **云原生支持**：推出官方托管服务，降低部署门槛，为 .NET 开发者提供开箱即用的解决方案。
    
*   **生态融合**：与 .NET 的深度集成可能带来更多专用工具和文档，提升开发体验。
    

与 Chroma 的发展方向类似，Qdrant 也在不断演进，但其分布式架构和实时性为其在企业级应用中赢得了一席之地。

* * *

八、结语
----

Qdrant 作为一款高性能、开源的向量数据库，为 .NET 开发者提供了一个强大的工具，用于构建高效的智能应用。从简单的安装配置到丰富的代码示例，再到多样化的应用场景，Qdrant 展示了其在语义搜索、推荐系统和多媒体检索等领域的潜力。通过与 .NET 生态系统的无缝集成，开发者可以快速将其融入现有项目，释放 AI 技术的价值。未来，随着 Qdrant 的持续发展，其在 .NET 社区中的影响力将进一步扩大，为智能应用的创新提供更多可能。

本文来自博客园，作者：[AI·NET极客圈](https://www.cnblogs.com/code-daily/)，转载请注明原文链接：[https://www.cnblogs.com/code-daily/p/18840212](https://www.cnblogs.com/code-daily/p/18840212)

  
![](https://images.cnblogs.com/cnblogs_com/blogs/272929/galleries/2447197/o_250311050355_AI.NET%20Logo.png)

欢迎关注我的公众号，作为.NET程序员，我们聚焦人工智能技术，深入探讨AI的前沿应用与发展趋势，为你立体呈现人工智能的无限可能，让我们共同携手走在科技最前沿。