---
layout: post
title: 'PCI9x5x驱动移植支持PCI9054在win7下使用2'
date: "2026-01-22T00:46:24Z"
---
PCI9x5x驱动移植支持PCI9054在win7下使用2
=============================

接上文，本文章继续记录中泰联创的数据采集卡驱动翻新过程。

中断初始化部分代码移植
-----------

分析PLX9x5x源码可知，中断初始化调用流程如下：  
PLxEvtDeviceAdd-PLxInitializeDeviceExtension-PLxInterruptCreate  
其中具体初始化代码在PLxInterruptCreate函数中，这部分是纯框架流程无需修改，直接就可以使用：

    NTSTATUS
    PLxInterruptCreate(
        IN PDEVICE_EXTENSION DevExt
        )
    {
        ......
    }
    

WdfInterruptCreate函数将创建设备中断对象，后续和中断相关操作都要用到DevExt->Interrupt。  
WdfInterruptCreate函数成功返回之后，WDF框架会在系统加载设备时连接中断，连接中断后调用PLxEvtInterruptEnable函数；系统卸载设备时调用PLxEvtInterruptDisable函数后断开中断。

示例程序已经在PLxEvtInterruptEnable函数中对中断寄存器进行了使能操作，这一点PCI9054和PCI9656兼容，所以延用此代码即可，同时需要加上本地总线的中断使能。

    	intCSR.bits.LocalIntInputEnable = TRUE;
    

示例程序已经在PLxEvtInterruptDisable函数中对中断寄存器进行了禁止操作，这一点PCI9054和PCI9656兼容，所以延用此代码即可。

    	intCSR.bits.LocalIntInputEnable = FALSE;
    

对于中泰联创的老产品上使能和禁止中断操作，则打算转移到应用层进行，这样可以增加驱动的适配性。

中断事件代码部分移植
----------

老驱动在应用层创建事件句柄，传输给内核，在对应中断发生时触发事件句柄，从而简化应用层编程，新驱动需要实现这个功能，

### 1\. 公共定义 (Public.h)

在 `Public.h` 中定义相关的 IOCTL 和常量：

    #define EVENT_COUNT                3L
    #define EVENT_SFifo                0L
    #define EVENT_ALARM                1L
    #define EVENT_TRIP                 2L
    
    #define PCI8KPLX_IOCTL_OPEN_IRQ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)
    #define PCI8KPLX_IOCTL_CLOSE_IRQ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)
    

### 2\. 设备上下文扩展 (Private.h)

在 `DEVICE_EXTENSION` 结构体中添加用于存储内核事件对象的指针数组：

    typedef struct _DEVICE_EXTENSION {
        // ... 现有成员 ...
        
        //用于存储内核事件对象指针
        PKEVENT m_Events[EVENT_COUNT];
        
    } DEVICE_EXTENSION, *PDEVICE_EXTENSION;
    

### 3\. IOCTL 处理逻辑 (Control.c)

在 `PLxEvtIoDeviceControl` 中添加对 `PCI8KPLX_IOCTL_OPEN_IRQ`和`PCI8KPLX_IOCTL_CLOSE_IRQ` 的分发:

    /**
     * 主设备控制入口点
     */
    VOID
    PLxEvtIoDeviceControl(……)
    {
        ……
    
        switch (IoControlCode) {
            case PCI8KPLX_IOCTL_OPEN_IRQ:
                status = PCI8KPLX_IOCTL_OPEN_IRQ_Handler(Request, devExt);
                break;
            case PCI8KPLX_IOCTL_CLOSE_IRQ:
                status = PCI8KPLX_IOCTL_CLOSE_IRQ_Handler(Request, devExt);
                break;
    
            // ... 其他 case ...
            
            default:
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
        }
    
        WdfRequestComplete(Request, status);
    }
    

并实现处理函数：

    /**
     * 功能：将应用层传入的 ULONG 句柄数组转换为内核 PKEVENT 对象数组
     * 注意：此方法使用固定大小的数组，适用于事件类型和数量固定的场景。
     *      对硬件寄存器的操作放在应用层dll中。
     * 兼容性：使用 (HANDLE)(ULONG_PTR)ulH 确保 32 位应用在 64 位系统上的兼容性。
     */
    NTSTATUS
    PCI8KPLX_IOCTL_OPEN_IRQ_Handler(
        _In_ WDFREQUEST Request,
        _In_ PDEVICE_EXTENSION DevExt
    )
    {
        NTSTATUS status = STATUS_SUCCESS;
        PULONG pBuff = NULL; // 指向输入缓冲区，其中包含 EVENT_COUNT 个 ULONG 句柄
        size_t bufferSize = 0;
        ULONG i;
    
        // 1. 获取输入缓冲区 (预期包含 EVENT_COUNT 个 ULONG 句柄)
        status = WdfRequestRetrieveInputBuffer(Request, sizeof(ULONG) * EVENT_COUNT, (PVOID*)&pBuff, &bufferSize);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    
        // 2. 遍历并处理句柄
        for (i = 0; i < EVENT_COUNT; i++) {
            ULONG ulH = pBuff[i];
            HANDLE h = (HANDLE)(ULONG_PTR)ulH; // 关键转换，确保64位兼容性
    
            if (h != NULL) {
                // 如果该位置已存在引用的事件对象，先释放旧引用
                if (DevExt->m_Events[i] != NULL) {
                    ObDereferenceObject(DevExt->m_Events[i]);
                    DevExt->m_Events[i] = NULL;
                }
    
                // 将用户态句柄转换为内核事件对象指针
                status = ObReferenceObjectByHandle(
                    h,
                    EVENT_MODIFY_STATE,
                    *ExEventObjectType,
                    UserMode,
                    (PVOID*)&DevExt->m_Events[i],
                    NULL
                );
    
                if (!NT_SUCCESS(status)) {
                    DevExt->m_Events[i] = NULL;
                    break; // 如果某个句柄转换失败，停止处理并返回错误
                }
            }
        }
    
        return status;
    }
    
    /**
     * 事件句柄清理函数 (固定数组版)
     * 功能：释放 m_Events 数组中所有存储的事件对象引用，并将指针置为 NULL。
     * 注意：此操作会清除所有已注册的事件句柄。
     */
    NTSTATUS
    PCI8KPLX_IOCTL_CLOSE_IRQ_Handler(
        _In_ WDFREQUEST Request,
        _In_ PDEVICE_EXTENSION DevExt
    )
    {
        NTSTATUS status = STATUS_SUCCESS;
        ULONG i;
        //本函数不需要和应用层交互，所以用不到这个参数
    	UNREFERENCED_PARAMETER(Request);
        // 为了保证操作的原子性，可能需要在此处添加设备级的锁，如果 m_Events 访问需要同步的话
        // WdfWaitLockAcquire(DevExt->SomeLock, NULL);
    
        // 遍历 m_Events 数组
        for (i = 0; i < EVENT_COUNT; i++) {
            if (DevExt->m_Events[i] != NULL) {
                // 释放对该事件对象的引用，防止内存泄漏
                ObDereferenceObject(DevExt->m_Events[i]);
                // 清空指针
                DevExt->m_Events[i] = NULL;
            }
        }
    
        // WdfWaitLockRelease(DevExt->SomeLock);
    
        // 此 IOCTL 通常没有输出数据，不需要调用 WdfRequestSetInformation
        // 直接返回成功状态
        return status;
    }
    

### 4\. 清理事件防止内存泄漏

在 PlxCleanupDeviceExtension 中进行清理

    VOID
    PlxCleanupDeviceExtension(
        _In_ PDEVICE_EXTENSION DevExt
    )
    {
        ULONG i;
    
        // 遍历并释放事件对象
        for (i = 0; i < EVENT_COUNT; i++) {
            if (DevExt->m_Events[i] != NULL) {
                ObDereferenceObject(DevExt->m_Events[i]);
                DevExt->m_Events[i] = NULL; // 清空指针是个好习惯
            }
        }
    
        // ... 其他清理代码 ...
    }
    

### 5\. 中断触发逻辑 (IsrDpc.c 参考)

在 DPC (如 `PLxEvtInterruptDpc`) 中，根据硬件状态触发相应的事件：

    // 示例：触发 SFIFO 触发值事件
    if (DevExt->m_Events[EVENT_SFifo] != NULL) {
        KeSetEvent(DevExt->m_Events[EVENT_SFifo], IO_NO_INCREMENT, FALSE);
    }
    

5\. 注意事项
--------

1.  **64位兼容性**：代码中使用了 `(HANDLE)(ULONG_PTR)ulH`，确保了 32 位应用程序在 64 位系统下运行时的句柄对齐。
2.  **资源释放**：在驱动卸载或设备清理回调（如 `PlxEvtDeviceCleanup`）中，应遍历 `m_Events` 并对非空元素调用 `ObDereferenceObject`，以防止内核内存泄漏。
3.  **固定大小限制**：此方案使用固定大小的数组 `m_Events[EVENT_COUNT]`，如果应用层需要管理的事件数量超过 `EVENT_COUNT`，则需要增大该常量并重新编译驱动和应用层。
4.  **应用层兼容性**：此方案假定应用层发送的是 `ULONG` 类型的句柄数组。它主要兼容发送此类数组的32位应用。如果64位应用也发送相同的 `ULONG` 数组（例如，应用层未区分位数），则其句柄必须是有效的32位兼容值（如WoW64子系统提供的句柄）。

应用层要做的和中断相关的事情
--------------

老驱动中使用内核变量来保存一些数据，会增加驱动复杂度，所以都转移到应用层，和中断有关的有控制字，变量，因此在dll中声明全局变量

    //本来是内核中需要保存的内容，改成应用层保存
    ULONG g_ulCtrlWord[MAX_CARD_COUNT];
    //为了后面方便阅读代码，将赋值和读取都封装成函数
    void SetCtrlWord(ULONG cardNo, ULONG ulCtrlWord) {
    	if (cardNo > MAX_CARD_COUNT)
    		return;
    	g_ulCtrlWord[cardNo] = ulCtrlWord;
    }
    
    ULONG GetCtrlWord(ULONG cardNo) {
    	if (cardNo > MAX_CARD_COUNT)
    		return 0;
    	return g_ulCtrlWord[cardNo];
    }
    

老驱动中有一个InitIRQ函数，只是操作了控制字变量，新驱动将内核操作修改成应用层的变量操作

    //改变控制字中的中断相关位	
        unsigned long ulCtrlWord = GetCtrlWord(cardNO);
    	ulCtrlWord = SET_ULONG_BITS( ulCtrlWord, IRQ_MASK, IRQ, irqSource );
        SetCtrlWord(cardNO, ulCtrlWord);
    

老驱动中使用OpenIRQ将中断相关事件传递到内核，同时在内核中设置PCI9054的本地控制字使能FPGA中断。新驱动中内核只是接收中断相关事件，然后在应用层使能FPGA中断。

    //在DeviceIoControl之后将控制字写入硬件	
    //使能之前设置好的中断
    WRITED(cardNO, OFF_CTRLWORD, GetCtrlWord(cardNO));
    

接下来要移植应用层访问硬件寄存器的代码