---
layout: post
title: 'MySQL 筛选条件放 ON 后 vs 放 WHERE 后'
date: "2025-12-10T00:44:43Z"
---
MySQL 筛选条件放 ON 后 vs 放 WHERE 后
=============================

ON 决定如何 "连接" 表，WHERE 决定连接后 "显示" 哪些行。 这个根本区别导致了在 LEFT JOIN / RIGHT JOIN 外连接中，条件放置位置会产生巨大影响；而在 INNER JOIN 中，效果通常 等价。

今天我们来讲讲数据库筛选条件放 **ON** 后和放 **WHERE** 后的区别。

**ON** 决定如何 "连接" 表，**WHERE** 决定连接后 "显示" 哪些行。 这个根本区别导致了在 **LEFT JOIN** / **RIGHT JOIN** 外连接中，条件放置位置会产生巨大影响；而在 **INNER JOIN** 中，效果通常 **等价**。

**ON** 条件匹配 **被驱动表** 的行，生成 "临时关联结果集"。LEFT JOIN 会保留 **驱动表** 所有行，匹配不上的 **被驱动表** 字段填充为 **NULL**。

**WHERE** 会对 "临时关联结果集" 进行条件过滤，删除不满足的行。

接下来我们搞两张测试表，一目了然。

    -- 用户表（驱动表，左表）
    CREATE TABLE `ysjz_user` (
      `id` int(11) NOT NULL AUTO_INCREMENT,
      `name` varchar(20) DEFAULT NULL,
      `age` int(11) DEFAULT NULL,
      PRIMARY KEY (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
    INSERT INTO `ysjz_user` VALUES (1,'张三',18),(2,'李四',25),(3,'王五',30);
    
    -- 订单表（被驱动表，右表）
    CREATE TABLE `ysjz_order` (
      `id` int(11) NOT NULL AUTO_INCREMENT,
      `user_id` int(11) DEFAULT NULL,
      `amount` decimal(10,2) DEFAULT NULL,
      PRIMARY KEY (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
    INSERT INTO `ysjz_order` VALUES (1,1,100),(2,2,200),(3,2,300),(4,4,500); -- 注：user_id=4无对应用户

**场景一：**使用 **INNER JOIN**，查询 年龄 > 20 的用户及其订单。

**写法1：**条件放 **ON** 后

    SELECT u.*, o.* 
    FROM `ysjz_user` u
    INNER JOIN `ysjz_order` o ON u.id = o.user_id AND u.age > 20;

![场景一写法12](https://img2024.cnblogs.com/blog/1171560/202512/1171560-20251209220401310-1034297923.png)

**写法2：**条件放 **WHERE** 后

    SELECT u.*, o.* 
    FROM `ysjz_user` u
    INNER JOIN `ysjz_order` o ON u.id = o.user_id 
    WHERE u.age > 20;

![场景一写法12](https://img2024.cnblogs.com/blog/1171560/202512/1171560-20251209220401310-1034297923.png)

两种写法的 **结果一致**。**写法1** 更高效，因少关联了 年龄 ≤ 20 的用户。

**场景二：**使用 **LEFT JOIN**，**保留所有用户**，同时显示 年龄 > 20 的用户及其订单（≤ 20 的用户订单显示为 NULL）。

**写法1：**条件放 **ON** 后（符合要求）

    SELECT u.*, o.* 
    FROM `ysjz_user` u
    LEFT JOIN `ysjz_order` o ON u.id = o.user_id AND u.age > 20;

![场景二写法1](https://img2024.cnblogs.com/blog/1171560/202512/1171560-20251209220457864-1184638392.png)

**写法2：**条件放 **WHERE** 后（跟要求不符）

    SELECT u.*, o.* 
    FROM `ysjz_user` u
    LEFT JOIN `ysjz_order` o ON u.id = o.user_id
    WHERE u.age > 20;

![场景二写法2](https://img2024.cnblogs.com/blog/1171560/202512/1171560-20251209220521860-304789419.png)

写法2 将 张三 过滤了，并没有 保留所有用户。

**场景三：**使用 **LEFT JOIN**，**保留所有用户**，同时显示 订单金额 > 200 的订单（无符合条件订单的用户填充为 NULL）。

**写法1：**条件放 **ON** 后（符合要求）

    SELECT u.*, o.* 
    FROM `ysjz_user` u
    LEFT JOIN `ysjz_order` o ON u.id = o.user_id AND o.amount > 200;

![场景三写法1](https://img2024.cnblogs.com/blog/1171560/202512/1171560-20251209220546156-1408082303.png)

**写法2：**条件放 **WHERE** 后（跟要求不符）

    SELECT u.*, o.* 
    FROM `ysjz_user` u
    LEFT JOIN `ysjz_order` o ON u.id = o.user_id 
    WHERE o.amount > 200;

![场景三写法2](https://img2024.cnblogs.com/blog/1171560/202512/1171560-20251209220608050-1181484514.png)

写法2 过滤了 无符合条件订单的用户。

场景二 和 场景三 其实相差不大，只是条件作用的表不一样。

**ON** 后面优先放 "表之间的关联键"（如 u.id = o.user\_id），非关联的筛选条件（如 u.age > 20）是否放 **ON** 后，取决于是否要保留驱动表的行。

总结：**ON 管关联，WHERE 管过滤；LEFT JOIN 用 ON 保行，INNER JOIN 用 ON 提效**。

别人的嘴你堵不住，但自己的心却任由自己掌控。-- 烟沙九洲

​