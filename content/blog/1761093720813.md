---
layout: post
title: 'LangChain4j 比 SolonAI 强在哪？弱在哪？'
date: "2025-10-22T00:42:00Z"
---
LangChain4j 比 SolonAI 强在哪？弱在哪？
==============================

本文对比了Java生态中两大AI框架LangChain4j和Solon AI的差异。功能方面，二者都支持LLM、RAG和MCP接口，但LangChain4j功能更丰富，尤其是RAG适配更全面。使用体验上，Solon AI明显更简洁，如流式对话仅需单行代码，而LangChain4j需要多步配置。此外，LangChain4j文档不全、学习曲线陡峭。建议简单场景选Solon AI以快速开发，复杂定制需求则选择更灵活的LangChain4j，但需接受其复杂性和高学习成本。两者也可配合使用。

LangChain4j 和 Solon AI 是 Java 生态中实现大模型应用开发的重要框架，但二者的区别是啥？生产级别又该使用哪种框架？令很多人犯了难，所以本文就来浅聊一下，希望给大家在技术选型时有一个简单的参考。

### 一、功能对比

LangChain4j 和 Solon AI 的功能是比较类似的，甚至两者可以配合使用，例如使用 Solon AI 实现 MCP 服务器端，再使用 LangChain4j 实现 MCP 客户端调用 Solon AI，二者可以无缝对接。而且，都可以嵌入到任何第三方框架中使用。那二者的区别是啥呢？

接口或体验

LangChain4j

Solon AI

LLM 接口

有

有

LLM 体验

复杂

简单

RAG 接口

有

有

RAG 体验

复杂

简单

MCP 接口

有

有

MCP 体验

复杂

简单

总体来说，LangChain4j 提供的功能更多，尤其是 RAG 方面，提供了更丰富的适配。

### 二、使用和学习成本

LangChain4j 的使用和学习成本比 Solon AI 高很多，举个例子，例如 Solon AI 要实现流式对话，只需要一行代码就搞定了：

    @Produces("text/event-stream")
    @Mapping("/streamChat")
    public Flux<String> streamChat(String msg) {
        return Flux.from(chatModel.stream(msg).map(resp -> resp.getContent()));
    }
    

而 LangChain4j 实现步骤如下：

*   添加 langchain4j-reactor 依赖。
*   设置配置文件，配置 streaming-chat-model api-key 和 model-name。
*   创建 AI Service 并返回 Flux 对象。
*   调用 Ai Service 才能实现流式输出。

类似的场景还有很多，例如 Solon AI 实现 MCP Client 只需要添加依赖，然后：

*   一行就构建 mcp 客户端
*   一行 defaultToolsAdd 或 toolsAdd 设置就可以实现了与 llm 的整合

如下代码：

    McpClientProvider mcpTools = McpClientProvider.builder()
                    .channel(McpChannel.STREAMABLE)
                    .apiUrl("http://localhost:8080/mcp")
                    .build();
                    
    ChatModel chatModel = ChatModel.of("http://127.0.0.1:11434/api/chat") //使用完整地址（而不是 api_base）
                .provider("ollama")
                .model("llama3.2")
                .defaultToolsAdd(mcpTools) 
                .build();
    

但 LangChain4j 的实现就非常复杂了，除了添加依赖之后，你还需要：

*   创建传输协议 McpTransport。
*   创建 MCP 客户端 McpClient。
*   创建 Tools（提供者）对象 ToolProvider。
*   构建 AiService。
*   执行 MCP Server 调用。

具体实现代码如下：

    @Mapping("/chat")
    public String chat(String question) {
        // 1.创建传输协议
        McpTransport transport = new HttpMcpTransport.Builder()
                .sseUrl("http://localhost:8686/sse")
                .logRequests(true) // if you want to see the traffic in the log
                .logResponses(true)
                .build();
        // 2.创建 MCP 客户端
        McpClient mcpClient = new DefaultMcpClient.Builder()
                .transport(transport)
                .build();
        // 3.创建 Tools（提供者）对象
        ToolProvider toolProvider = McpToolProvider.builder()
                .mcpClients(List.of(mcpClient))
                .build();
        // 4.构建 AiService
        ToolsAiService aiService = AiServices.builder(ToolsAiService.class)
                .chatLanguageModel(chatModel)
                .toolProvider(toolProvider)
                .build();
        // 5.调用 MCP Server
        return aiService.chat(question);
    }
    

除了 LangChain4j 的使用复杂之外，源代码量很大，LangChain4j 的文档也不全，要么是没有关键实现代码案例、要么是干脆文档写的都是错的，LangChain4j 的坑比较多，最后只能通过看最新的源码才能解决和使用相关功能，所以 LangChain4j 学习和使用成本是非常高的。

### 三、小结

如果是简单功能、开发周期又紧可以使用 Solon AI；如果功能复杂，且定制型要求比较多，可以使用功能和灵活度更高的 LangChain4j。但使用 LangChain4j 这就意味着你需要忍受 LangChain4j 不够简洁的写法，以及学习和使用成本比较高的问题。