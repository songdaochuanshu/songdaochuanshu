---
layout: post
title: 'SpringBoot 2.x æ¥å…¥éæ ‡å‡†SSEæ ¼å¼å¤§æ¨¡å‹æµå¼å“åº”å®è·µ'
date: "2025-02-25T00:37:13Z"
---
SpringBoot 2.x æ¥å…¥éæ ‡å‡†SSEæ ¼å¼å¤§æ¨¡å‹æµå¼å“åº”å®è·µ ğŸš€
=====================================

è¿‘æœŸDeepSeekç­‰å›½äº§å¤§æ¨¡å‹çƒ­åº¦æŒç»­æ”€å‡ï¼Œå…¶å…³æ³¨åº¦ç”šè‡³è¶…è¿‡äº†OpenAIï¼ˆè¢«æˆç§°ä¸ºCloseAIï¼‰ã€‚åœ¨`SpringBoot3.x`ç¯å¢ƒä¸­ï¼Œå¯ä»¥ä½¿ç”¨å®˜æ–¹çš„Spring AIè½»æ¾æ¥å…¥ï¼Œä½†å¯¹äºä»åœ¨ä½¿ç”¨**JDK8**å’Œ**SpringBoot2.7.3**çš„ä¼ä¸šçº§åº”ç”¨æ¥è¯´ï¼Œå¾€å¾€éœ€è¦è‡ªå®šä¹‰å®ç°ã€‚ç‰¹åˆ«æ˜¯å½“å¤§æ¨¡å‹å›¢é˜Ÿè¿”å›çš„æ•°æ®æ ¼å¼ä¸ç¬¦åˆæ ‡å‡†SSEè§„èŒƒæ—¶ï¼Œæ›´éœ€è¦çµæ´»å¤„ç†ã€‚æœ¬æ–‡å°†åˆ†äº«æˆ‘ä»¬çš„å®æˆ˜è§£å†³æ–¹æ¡ˆã€‚

* * *

ğŸ“¦ å¼•å…¥Gradleä¾èµ–
-------------

æ ¸å¿ƒä¾èµ–è¯´æ˜ï¼š

*   `spring-boot-starter-web`ï¼šåŸºç¡€Webæ”¯æŒ
*   `spring-boot-starter-webflux`ï¼šå“åº”å¼ç¼–ç¨‹æ”¯æŒï¼ˆWebClientæ‰€åœ¨æ¨¡å—ï¼‰

    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    

* * *

ğŸŒ WebClienté…ç½®è¦ç‚¹
----------------

åˆå§‹åŒ–æ—¶ç‰¹åˆ«æ³¨æ„Headeré…ç½®ï¼š

    @Bean
    public WebClient init() {
        return WebClient.builder()
                .baseUrl(baseUrl)
                .defaultHeader(HttpHeaders.AUTHORIZATION, "Bearer " + openAi)
                // âš ï¸ å¿…é¡»è®¾ç½®ä¸ºJSONæ ¼å¼
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }
    

> ğŸš¨ å…³é”®è¸©å‘ç‚¹ï¼šåˆå§‹è®¾ç½®`MediaType.TEXT_EVENT_STREAM_VALUE`ä¼šå¯¼è‡´è¯·æ±‚å¤±è´¥ï¼Œå¿…é¡»ä½¿ç”¨`APPLICATION_JSON_VALUE`

* * *

ğŸ§  æ ¸å¿ƒå¤„ç†é€»è¾‘
---------

### æµå¼è¯·æ±‚å…¥å£

    @GetMapping(value = "/stream/chat", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> streamChatEnhanced(@RequestParam("prompt") String prompt) {
        // è¯·æ±‚ä½“æ„å»º
        String requestBody = String.format("""
            {
                "model": "%s",
                "messages": [{"role": "user", "content": "%s"}],
                "stream": true
            }
            """, model, prompt);
                                           
        return webClient.post()
                // è¯·æ±‚é…ç½®
                .uri("/v1/chat/completions")
                .bodyValue(requestBody)
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(DataBuffer.class)  // ğŸ”‘ å…³é”®é…ç½®ç‚¹
                .transform(this::processStream)
                // é‡è¯•å’Œè¶…æ—¶é…ç½®
                .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)))
                .timeout(Duration.ofSeconds(180));
                // é”™è¯¯å¤„ç†
                .doOnError(e -> log.error("Stream error", e))
                .doFinally(signal -> log.info("Stream completed: {}", signal));
    }
    

### æŠ€æœ¯åŸç†è¯´æ˜

å½“ä½¿ç”¨`bodyToFlux(DataBuffer.class)`æ—¶ï¼š

*   âœ… è·å¾—åŸå§‹å­—èŠ‚æµæ§åˆ¶æƒ
*   âŒ é¿å…è‡ªåŠ¨SSEæ ¼å¼è§£æï¼ˆé€‚ç”¨äºéæ ‡å‡†å“åº”ï¼‰
*   ğŸ“¡ åŠ¨æ€æ•°æ®æµå¤„ç†ï¼šç±»ä¼¼Java Streamï¼Œä½†æ•°æ®æŒç»­è¿½åŠ 

* * *

ğŸ”§ éæ ‡å‡†SSEæ•°æ®å¤„ç†
-------------

### æ ¸å¿ƒå¤„ç†æµç¨‹

    private Flux<String> processStream(Flux<DataBuffer> dataBufferFlux) {
        return dataBufferFlux
                .transform(DataBufferUtils::join)          // å­—èŠ‚æµåˆå¹¶
                .map(buffer -> {                          // å­—èŠ‚è½¬å­—ç¬¦ä¸²
                    String content = buffer.toString(StandardCharsets.UTF_8);
                    DataBufferUtils.release(buffer);
                    return content;
                })
                .flatMap(content ->                       // å¤„ç†ç²˜åŒ…é—®é¢˜
                    Flux.fromArray(content.split("\\r?\\n\\r?\\n")))
                .filter(event -> !event.trim().isEmpty()) // è¿‡æ»¤ç©ºäº‹ä»¶
                .map(event -> {                           // æ ¼å¼æ ‡å‡†åŒ–å¤„ç†
                    String trimmed = event.trim();
                    if (trimmed.startsWith("data:")) {
                        String substring = trimmed.substring(5);
                        return substring.startsWith(" ") ? substring.substring(1) : substring;
                    }
                    return trimmed;
                })
                .filter(event -> !event.startsWith("data:")); // äºŒæ¬¡è¿‡æ»¤
    }
    

### ä¸‰å¤§å…³é”®æŠ€æœ¯ç‚¹

1.  **ç²˜åŒ…å¤„ç†**  
    é€šè¿‡`split("\\r?\\n\\r?\\n")`è§£å†³ç½‘ç»œä¼ è¾“ä¸­çš„æ¶ˆæ¯è¾¹ç•Œé—®é¢˜ï¼Œç¤ºä¾‹åŸå§‹æ•°æ®ï¼š
    
        data:{response1}\n\ndata:{response2}\n\n
        
    
2.  **æ ¼å¼å…¼å®¹å¤„ç†**  
    è‡ªåŠ¨å»é™¤æœåŠ¡ç«¯å¯èƒ½è¿”å›çš„`data:`å‰ç¼€ï¼ŒåŒæ—¶ä¿ç•™Springè‡ªåŠ¨æ·»åŠ SSEå‰ç¼€çš„èƒ½åŠ›
    
3.  **åŒé‡è¿‡æ»¤æœºåˆ¶**  
    ç¡®ä¿æœ€ç»ˆè¾“å‡ºä¸åŒ…å«ä»»ä½•æ®‹ç•™çš„SSEæ ¼å¼æ ‡è¯†
    

* * *

âš ï¸ ç‰¹åˆ«æ³¨æ„
-------

å½“æ¥å£è®¾ç½®`produces = MediaType.TEXT_EVENT_STREAM_VALUE`æ—¶ï¼š

*   Spring WebFluxä¼šè‡ªåŠ¨æ·»åŠ `data:` å‰ç¼€
    
*   å‰ç«¯æ”¶åˆ°çš„æ ¼å¼ç¤ºä¾‹ï¼š
    
        data: {å®é™…å†…å®¹}
        
    
*   è‹¥æ‰‹åŠ¨æ·»åŠ 
    
        data: 
        
    
    å‰ç¼€ä¼šå¯¼è‡´é‡å¤ï¼š
    
        data: data: {é”™è¯¯å†…å®¹}  // âŒ é”™è¯¯æ ¼å¼
        
    

* * *

ğŸ› ï¸ å®Œæ•´å®ç°ä»£ç 
----------

    // åŒ…å£°æ˜å’Œå¯¼å…¥...
    
    @Service
    @Slf4j
    public class OpenAiService {
        // é…ç½®é¡¹å’Œåˆå§‹åŒ–
        private String openAiApiKey = "sk-xxxxxx";
        
        private String baseUrl = "https://openai.com/xxxx";
    
        private String model = "gpt-4o";
    
        private WebClient webClient;
    
        @PostConstruct
        public void init() {
            webClient = WebClient.builder()
                    .baseUrl(baseUrl)
                    .defaultHeader(HttpHeaders.AUTHORIZATION, "Bearer " + openAiApiKey)
                    .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                    .build();
        }
    
        @GetMapping(value = "/stream/chat", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
        public Flux<String> streamChatEnhanced(@RequestParam("prompt") String prompt) {
            // æ„å»ºè¯·æ±‚ä½“
            String requestBody = String.format("""
                    {
                        "model": "gpt-4o-mini",
                        "messages": [{"role": "user", "content": "%s"}],
                        "stream": true
                    }
                    """, prompt);
                                               
            // å‘é€æµå¼è¯·æ±‚
            return webClient.post()
                .uri("/v1/chat/completions")
                .bodyValue(requestBody)
                .retrieve()
                .onStatus(HttpStatusCode::isError, response ->
                        response.bodyToMono(String.class)
                                .flatMap(error -> Mono.error(new RuntimeException("API Error: " + error)))
                )
                .bodyToFlux(DataBuffer.class)
                .transform(this::processStream)
                .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)))
                .timeout(Duration.ofSeconds(180))
                .doOnError(e -> log.error("Stream error", e))
                .doFinally(signal -> log.info("Stream completed: {}", signal));
        }
    
        private Flux<String> processStream(Flux<DataBuffer> dataBufferFlux) {
            return dataBufferFlux
                    // ä½¿ç”¨å­—èŠ‚æµå¤„ç†
                    .transform(DataBufferUtils::join)
                    .map(buffer -> {
                        String content = buffer.toString(StandardCharsets.UTF_8);
                        DataBufferUtils.release(buffer);
                        return content;
                    })
                    // æŒ‰ SSE äº‹ä»¶è¾¹ç•Œï¼Œé˜²æ­¢ç²˜åŒ…çš„é—®é¢˜
                    .flatMap(content -> Flux.fromArray(content.split("\\r?\\n\\r?\\n")))
                    // è¿‡æ»¤ç©ºäº‹ä»¶
                    .filter(event -> !event.trim().isEmpty())
                    // è§„èŒƒ SSE äº‹ä»¶æ ¼å¼
                    .map(event -> {
                        String trimmed = event.trim();
    
                        // ç”±äºwebfluxè®¾ç½®äº†"produces = MediaType.TEXT_EVENT_STREAM_VALUE",
                        // æ‰€ä»¥åœ¨è¿”å›æ•°æ®æ—¶ä¼šè‡ªåŠ¨æ·»åŠ â€œdata:â€ï¼Œå› æ­¤å¦‚æœè¿”å›çš„æ ¼å¼å¸¦äº†â€œdata:â€éœ€è¦æ‰‹åŠ¨å»é™¤
                        if (trimmed.startsWith("data:")) {
                            trimmed = trimmed.replaceFirst("data:","").trim();
                        }
                        return trimmed;
                    })
                    .filter(event -> !event.startsWith("data:"));
        }
    }