---
layout: post
title: '解密 Navicat 密码神器：NavicatPassword 的技术实现与架构解析'
date: "2026-01-27T00:49:27Z"
---
解密 Navicat 密码神器：NavicatPassword 的技术实现与架构解析
==========================================

在日常的开发、运维工作中，Navicat作为一款主流的多数据库管理工具，几乎是每个数据库从业者的标配。但很多人都遇到过这样的痛点：Navicat会将数据库连接密码加密存储在本地配置文件中，一旦忘记密码，想要找回就成了一件麻烦事。基于此，我开发了**NavicatPassword**——一款基于Avalonia框架的跨平台Navicat密码解密工具，本文将从技术实现、架构设计、核心功能等维度，全面解析这个项目的开发思路与落地细节。

一、项目背景与核心价值
-----------

### 1\. 解决的核心痛点

Navicat的数据库连接密码并非明文存储，而是通过AES算法加密后写入`.ncx`格式的XML配置文件中。一旦用户忘记密码，常规方式只能重新配置连接，效率极低。本项目只作为学习研究使用，不做其他使用。

### 2\. 项目核心价值

*   **跨平台运行**：基于Avalonia与.NET 8，支持Windows、macOS、Linux全平台；
*   **多场景解密**：支持配置文件批量解析、单条连接解密、手动输入密文解密三种模式；
*   **易用性拉满**：现代化UI界面，支持深色模式，操作流程极简；
*   **轻量高效**：无需复杂依赖，基于.NET原生能力实现核心算法，解密速度毫秒级。

二、技术栈选型与考量
----------

NavicatPassword的技术栈选择围绕「跨平台、低耦合、高性能」三个核心目标，具体选型如下：

技术领域

选型

选型考量

前端UI框架

Avalonia UI

替代WPF的跨平台UI框架，API与WPF高度兼容，原生支持多平台、深色模式、响应式布局

后端开发语言

C# (.NET 8)

.NET 8跨平台能力强，性能优异，原生支持加密算法、XML解析等核心能力

架构模式

MVVM (CommunityToolkit.Mvvm)

解耦UI与业务逻辑，简化数据绑定、命令管理，提升代码可维护性

加密算法

AES-128-CBC

匹配Navicat官方的加密标准，保证解密准确性

数据存储

SQLite

轻量级嵌入式数据库，用于保存用户的解密设置、历史记录等

配置文件解析

.NET XmlDocument/XDocument

原生XML解析能力，高效处理Navicat的.ncx配置文件

三、项目架构设计（MVVM）
--------------

项目严格遵循MVVM架构模式，代码目录结构与职责划分清晰，核心目录如下（对应项目`NavicatPassword/`目录）：

    NavicatPassword/
    ├── Views/          # 视图层：UI界面（Axaml文件），仅负责展示，无业务逻辑
    │   ├── MainView.axaml       # 主界面（解密操作核心页面）
    ├── ViewModels/     # 视图模型层：连接View与Model，处理UI交互逻辑
    │   ├── MainViewModel.cs     # 主界面逻辑（文件选择、批量解密、单条解密）
    ├── Services/       # 服务层：核心业务逻辑封装
    │   ├── SystemService.cs # 密码解密核心服务
    ├── Utils/          # 工具层：解密方法
    └── App.axaml.cs    # 应用入口，全局配置

### 各层核心职责

1.  **View（视图层）**：仅通过Axaml定义UI结构，通过数据绑定绑定ViewModel的属性和命令，无任何业务代码；
2.  **ViewModel（视图模型层）**：通过`ObservableProperty`（CommunityToolkit.Mvvm特性）实现属性通知，通过`ICommand`处理按钮点击、文件选择等UI交互，调用Service层完成核心逻辑；
3.  **Service（服务层）**：封装核心业务逻辑（解密、文件解析），是项目的「业务核心」，ViewModel仅调用Service，不直接处理业务；
4.  **Model（模型层）**：定义数据结构，如数据库连接信息、应用配置等，仅承载数据，无业务逻辑。

这种架构的优势在于：**UI与业务逻辑完全解耦**，后续无论是修改界面样式，还是优化解密算法，都无需改动其他层的代码，可维护性和扩展性大幅提升。

四、核心功能实现解析
----------

### 1\. 密码解密核心算法（AES-128-CBC）

Navicat的密码加密采用固定的Key和IV，这是解密的关键。项目的核心解密代码如下，且完全基于.NET原生`System.Security.Cryptography`实现：

    using System.Security.Cryptography;
    using System.Text;
    
    namespace NavicatPassword.Services;
    
    public static class NavicatDecryptService
    {
        // Navicat固定的Key和IV（核心！）
        private static readonly byte[] _key = Encoding.UTF8.GetBytes("libcckeylibcckey");
        private static readonly byte[] _iv = Encoding.UTF8.GetBytes("libcciv libcciv ");
    
        ///
        /// 解密Navicat加密的密码字节数组
        ///
        ///加密后的字节数组
        ///明文密码
        ///解密失败时抛出异常
        public static string DecryptNavicatPassword(byte[] cipherBytes)
        {
            if (cipherBytes == null || cipherBytes.Length == 0)
            {
                throw new ArgumentException("加密字节数组不能为空", nameof(cipherBytes));
            }
    
            try
            {
                using Aes aes = Aes.Create();
                // 匹配Navicat的加密模式：CBC + PKCS7填充
                aes.Mode = CipherMode.CBC;
                aes.Padding = PaddingMode.PKCS7;
                aes.Key = _key;
                aes.IV = _iv;
    
                // 创建解密器并执行解密
                ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);
                byte[] plainBytes = decryptor.TransformFinalBlock(cipherBytes, 0, cipherBytes.Length);
    
                // 转换为UTF8明文
                return Encoding.UTF8.GetString(plainBytes);
            }
            catch (Exception ex)
            {
                throw new ArgumentException("解密失败，可能是密文格式错误", ex);
            }
        }
    
        ///
        /// 重载：解密Base64编码的密文字符串
        ///
        ///Base64密文
        /// 明文密码
        public static string DecryptNavicatPassword(string cipherBase64)
        {
            byte[] cipherBytes = Convert.FromBase64String(cipherBase64);
            return DecryptNavicatPassword(cipherBytes);
        }
    }

#### 关键细节说明：

*   **固定Key/IV**：Navicat所有版本均使用`libcckeylibcckey`（Key）和`libcciv libcciv` （IV），这是解密的核心前提；
*   **填充模式**：必须使用`PKCS7`（而非`PKCS5`），否则解密结果会出现乱码；
*   **异常处理**：针对空值、格式错误等场景做了容错，保证用户体验。

### 2\. .ncx配置文件解析

Navicat的`.ncx`文件是XML格式，核心是`<Connection>`节点，包含连接名称、地址、加密密码等信息。解析逻辑封装在`NcxFileParserService`中，核心步骤如下：

    using System.Xml.Linq;
    using NavicatPassword.Models;
    
    namespace NavicatPassword.Services;
    
    public class NcxFileParserService
    {
        ///
        /// 解析.ncx配置文件，提取所有数据库连接信息
        ///
        ///配置文件路径
        /// 数据库连接列表
        public List ParseNcxFile(string filePath)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException("配置文件不存在", filePath);
            }
            XDocument doc = XDocument.Load(filePath);
            var connections = new List();
            // 遍历所有Connection节点
            foreach (var connNode in doc.Descendants("Connection"))
            {
                var connection = new NavicatConnection
                {
                    Name = connNode.Attribute("Name")?.Value ?? string.Empty,
                    Host = connNode.Element("Host")?.Value ?? string.Empty,
                    Port = connNode.Element("Port")?.Value ?? string.Empty,
                    Database = connNode.Element("Database")?.Value ?? string.Empty,
                    // 加密密码是Base64编码的字符串
                    CipherPassword = connNode.Element("Password")?.Value ?? string.Empty
                };
                // 自动解密（可选）
                if (!string.IsNullOrEmpty(connection.CipherPassword))
                {
                    try
                    {
                        connection.PlainPassword = NavicatDecryptService.DecryptNavicatPassword(connection.CipherPassword);
                    }
                    catch
                    {
                        connection.PlainPassword = "解密失败";
                    }
                }
                connections.Add(connection);
            }
            return connections;
        }
    }

解析逻辑的核心是提取`<Connection>`节点的属性和子节点值，并自动调用解密方法生成明文密码，最终封装为`NavicatConnection`模型返回给ViewModel，由View展示。

五、跨平台适配要点
---------

基于Avalonia和.NET 8，项目的跨平台适配几乎「零成本」，但仍有几个关键细节需要注意：

1.  **文件路径适配**：不同系统的Navicat配置文件路径不同，自动适配：Windows：`C:\Users\{用户名}\Documents\Navicat\`
2.  **UI适配**：Avalonia的布局系统原生支持响应式，通过`Grid`、`StackPanel`等布局控件，保证在不同分辨率、不同系统下的UI一致性；深色模式通过Avalonia的`ThemeVariant`实现，无需单独开发。
3.  **发布打包**：通过`.NET Publish`命令可一键打包不同平台的可执行文件：
    
        # Windows (x64)
        dotnet publish -c Release -r win-x64 --self-contained true -o publish/win
        
        # macOS (x64)
        dotnet publish -c Release -r osx-x64 --self-contained true -o publish/macos
        
        # Linux (x64)
        dotnet publish -c Release -r linux-x64 --self-contained true -o publish/linux
    

六、使用场景与落地效果
-----------

### 1\. 核心使用场景

*   **开发人员找回密码**：忘记Navicat连接密码，快速解析配置文件找回；
*   **运维批量管理**：批量解析服务器上的Navicat配置文件，统一管理数据库连接密码；
*   **测试环境核查**：验证测试环境数据库密码是否符合规范，提升安全合规性；
*   **已通过测试版本**：[Navicat Premium Lite (Free)](https://www.navicat.com/products#navicat-premium-lite) _17.3.6版本。_

附：项目快速上手
--------

### 从源码构建

    # 克隆仓库
    git clone https://gitee.com/dingshuanglei/NavicatPassword.gitorgit clone https://github.com/dingshuanglei/NavicatPassword.git
    
    # 进入目录
    cd NavicatPassword
    
    # 构建项目
    dotnet build -c Release
    
    # 运行
    dotnet run --project NavicatPassword/NavicatPassword.csproj

### 核心操作流程

1.  选择Navicat的`.ncx`配置文件，自动解析所有连接；
2.  批量解密/单条解密，查看明文密码；
3.  或手动输入密文，一键解密。

* * *

技术的价值在于解决实际问题，NavicatPassword的开发过程，既是对Avalonia跨平台开发的实践，也是对「工具类项目」架构设计的探索。希望本文能为大家带来一些启发，也欢迎大家参与项目的开源共建～

\* { margin: 0; padding: 0; box-sizing: border-box } body { font-family: "Microsoft YaHei", Arial, sans-serif; line-height: 1.8; color: rgba(51, 51, 51, 1); max-width: 1200px; margin: 0 auto; padding: 20px; background-color: rgba(248, 249, 250, 1) } h1 { font-size: 2.2rem; color: rgba(44, 62, 80, 1); margin: 20px 0 30px; border-bottom: 2px solid rgba(52, 152, 219, 1); padding-bottom: 10px } h2 { font-size: 1.8rem; color: rgba(52, 73, 94, 1); margin: 25px 0 15px; border-left: 4px solid rgba(52, 152, 219, 1); padding-left: 10px } h3 { font-size: 1.4rem; color: rgba(74, 101, 131, 1); margin: 20px 0 10px } p { margin: 10px 0; font-size: 1rem } strong { color: rgba(231, 76, 60, 1) } ul { margin: 10px 0 10px 40px } li { margin: 5px 0 } table { width: 100%; border-collapse: collapse; margin: 20px 0; background-color: rgba(255, 255, 255, 1); border-radius: 4px; overflow: hidden; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) } th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid rgba(221, 221, 221, 1) } th { background-color: rgba(52, 152, 219, 1); color: rgba(255, 255, 255, 1); font-weight: bold } tr:hover { background-color: rgba(245, 245, 245, 1) } pre { background-color: rgba(45, 45, 45, 1); color: rgba(204, 204, 204, 1); padding: 15px; border-radius: 4px; overflow-x: auto; margin: 15px 0; font-family: "Consolas", "Monaco", monospace } code { font-family: "Consolas", "Monaco", monospace; background-color: rgba(232, 244, 253, 1); padding: 2px 4px; border-radius: 2px; color: rgba(231, 76, 60, 1) } pre code { background-color: rgba(0, 0, 0, 0); color: rgba(204, 204, 204, 1); padding: 0 } .code-csharp { color: rgba(169, 183, 198, 1) } .code-bash { color: rgba(137, 198, 79, 1) } hr { border-top: 1px solid rgba(221, 221, 221, 1); border-right: none; border-bottom: none; border-left: none; margin: 30px 0 }

作者：[丁双磊](https://www.cnblogs.com/dingshuanglei/)

出处：[https://www.cnblogs.com/dingshuanglei](https://www.cnblogs.com/dingshuanglei/)

本文版权归作者和博客园共有，欢迎转载，但必须给出原文链接，并保留此段声明，否则保留追究法律责任的权利。