---
layout: post
title: '链表的基本操作，用链表实现线性表'
date: "2025-12-26T00:44:35Z"
---
链表的基本操作，用链表实现线性表
================

链表

增删改查  
指针指向等于地址赋值  
定义一个链表结构体

    typedef struct _NODE_ {
    	int number;
    	struct _NODE* next; 
    }Node,*Lintlist;
    

这里的node是对节点命名时的数据类型  
Linklist是对该链表命名时的数据类型  
初始化  
1.建立一个链表  
2.申请一个头节点

    Linklist init(Linklist l) {
    	Node* head = (Node*)malloc(sizeof(Node));
    	if (head == NULL) {
    		printf("内存分配失败");
    		return NULL;
    	}
    	head->next = NULL;
    	return head;
    }
    

在主函数中调用是

    Linklist l=NULL;
    l = init(l);
    

也可以  
`Linklist l=init(l);`

当然在这里也可以这样来  
在这里函数的参数有没有都可以，因为其本质要的是申请的这个节点的地址也就是head的值  
在主函数中他会把这个返回值赋值给l；  
包括这里的函数类型也可以换成Node\*如下

    Node* init() {
    	Node* head = (Node*)malloc(sizeof(Node));
    	if (head == NULL) {
    		printf("内存分配失败");
    		return NULL;
    	}
    	head->next = NULL;
    	return head;
    }
    

在主函数中调用就是  
`Linklist l=init();`

增加操作  
分为三种，分别为头插法，尾插法，以及在指定位置增加，  
这里分为三种操作的一个原因就是增加可读性  
还有一个原因是这样能帮助我们写代码  
不需要判断各种临界情况  
代码不会复杂，相对简单。

头插法

    Linklist head_add(Linklist l, int m) {
    	Node* s = (Node*)malloc(sizeof(Node));
    	if (s == NULL) {
    		printf("内存分配失败");
    		return l;
    	}
    	s->next = l->next;
    	s->number = m;
    	l->next = s;
    	return l;
    }
    

在这里有两个点需要注意  
第一点，头指针的指针域数值在改变的时候不能让链表断裂，比如

    l->next = s;
    s->next = l->next;
    

在这里我们先让头指针的指针域指向了s  
但这里就会导致一个问题，我们原本在这个指针域里面存储的地址丢了  
我们再执行  
`s->next = l->next;`  
就会 让s的next指向自己  
就会导致后续链表的断裂  
所以我们在改变链表的指针域时，最重要的就是不能让链表断裂，即不能让数据丢失

第二点  
在返回值上，我们其实可以让返回值为void  
因为在这个函数里面其实我们没有动l的值  
l里面是一个指针，而这个指针指向了一个我们声明的结构体类型的数据  
我们是根据这个指针访问这个结构体类型的数据，然后更改这个结构体内的一些数据  
我们并没有对l这个变量里面存储的数据进行改变  
所以我们可以用void  
而在上面我们用Link list这个作为返回值的原因是  
在我们对l的理解中，l指的是这个链表  
对于这个链表实际上是发生了变化的  
所以我们在这里用了返回值  
接下来的尾插法和指定位置插入都有这个问题。

尾插法  
1.找到未节点  
2.构建一个节点插在为节点后面

    Linklist rear_add(Linklist l, int m) {
    	Node* p = l;
    	while (p->next) {
    		p = p->next;
    	}
    	
    	
    	Node* s = (Node*)malloc(sizeof(Node));
    	if (s == NULL) {
    		printf("内存分配失败");
    		
    		return l;
    	}
    	s->number = m;
    	s->next = NULL;
    	p->next = s;
    	return l;
    }
    

指定位置插入  
1.找到指定位置（这里可以来一个find函数）  
接下来的操作是基于find函数进行的  
find函数在后面紧挨着  
2.通过find函数的返回值确认后续操作  
3，如果是NULL则没有找的该数据，无法执行插入操作  
4.找到之后，就构建新的节点插入

    Linklist rear_add(Linklist l, int m) {
    	Node* p = l;
    	while (p->next) {
    		p = p->next;
    	}
    	
    	
    	Node* s = (Node*)malloc(sizeof(Node));
    	if (s == NULL) {
    		printf("内存分配失败");
    		return l;
    	}
    	s->number = m;
    	s->next = NULL;
    	p->next = s;
    	return l;
    }
    

查，  
找到指定数据的节点，然后根据查找结果确定返回值

    Node* find(Linklist l, int k) {
    	
    	Node* q = l->next;
    	while (q && q->number != k) {
    	
    		q = q->next;
    	}
    	return q;
    }
    

删，  
删除指定数据，在这里不能通过查找函数，是因为在删除操作里我们要涉及前面的一个节点的指针域  
在双向链表中就可以通过find函数进行查找了，因为在双向链表中，节点内包含着前节点的地址

    Linklist delet(Linklist l, int k) {
    	//k为删减的值
    	Node* p = l;
    	Node* q = l->next;
    	while (q && q->number != k) {
    		p = q;
    		q = q->next;
    	}
    	if (q==NULL) {
    		printf("未找到该数据，不能执行删除操作\n");
    		return l;
    	}
    	p->next = q->next;
    	
    	free(q);
    	q = NULL;
    	return l;
    }
    
    

改，  
最简单的操作，可以选择通过find函数也可以直接查找，因为这个函数不涉及指针的改变

    Linklist change(Linklist l, int k,int m) {
    	Node* p = find(l, k);
    	if (p == NULL) {
    		printf("未找到该数据，不能实行数据更改操作\n");
    		return l;
    	}
    	p->number = m;
    	return l;
    }
    
    

输出函数  
输出链表值

    void printff(Linklist l) {
    	Node* p = l->next;
    	while (p) {
    		printf("%d ", p->number);
    		p = p->next;
    	}
    	printf("\n");
    }
    

下面时主函数的调用

    int main() 
    {
    	Linklist l=NULL;
    	l = init(l);
    	l = head_add(l, 3);
    	l = head_add(l, 9);
    	l = head_add(l, 5);
    	printff(l);
    	l = rear_add(l, 8);
    	l = rear_add(l, 4);
    	l = rear_add(l, 6);
    	printff(l);
    	l = inadd(l,3, 15);
    	l = inadd(l, 10, 16);
    	l = inadd(l, 9, 12);
    	printff(l);
    	l = delet(l, 4);
    	l = delet(l, 8);
    	l = delet(l, 16);
    	printff(l);
    	l = change(l, 4, 43);
    	printff(l);
    	return 0;
    }