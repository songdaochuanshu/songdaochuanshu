---
layout: post
title: 'AsyncLocal的妙用'
date: "2025-01-11T00:36:23Z"
---
AsyncLocal的妙用
=============

`AsyncLocal<T>`是一个在.NET中用来在同步任务和异步任务中保持全局变量的工具类。

它允许你在不同线程的同一个对象中保留一个特定值，这样你可以在不同的函数和任务中访问这个值。

这是在实现异步任务中维持一致性和优雅性的一种重要手段。

#### 用法

**创建一个AsyncLocal实例：**

你可以使用`AsyncLocal<T>`来创建一个特定类型的实例，比如：

    AsyncLocal<string> asyncLocalString = new AsyncLocal<string>();
    

**设置值：**

你可以通过`Value`属性设置或者读取值：

    asyncLocalString.Value = "Hello, AsyncLocal!";
    

**读取值：**

在任务中的任意位置，你都可以读取这个值：

    Console.WriteLine(asyncLocalString.Value);
    

**实例分享与给值变更：**

在不同任务和串行任务中，`AsyncLocal` 实例的值是不一样的：

    asyncLocalString.Value = "Main Task";
    Task.Run(() =>
    {
        asyncLocalString.Value = "Child Task";
        Console.WriteLine(asyncLocalString.Value); // 输出 "Child Task"
    });
    Console.WriteLine(asyncLocalString.Value); // 输出 "Main Task"

#### 场景

**数据传递：**

异步任务中，通过`AsyncLocal`进行全局数据传递而无需通过参数传递。这对于学习和复用代码很有帮助。

**上下文管理：**

在ASP.NET Core中，`AsyncLocal` 可用于管理用户请求上下文，实现不同请求之间的传递。当你需要保存一些请求相关的信息时，这是一种很有效的方法。

**百分比信息保存：**

记录不同任务和串行任务中的特定信息，说明这些任务是如何分布的。这在分析和跟踪异步操作时应对特别有用。

**系统日志和跟踪：**

`AsyncLocal` 可用于在异步任务中保存和分享日志和跟踪信息，以便在运行时采集最有益的信息，有助于问题跟踪和分析。

#### 示例：保存日志和租户信息

以下是一个使用`AsyncLocal`保存日志和租户信息的示例：

    using System;
    using System.Threading;
    using System.Threading.Tasks;
    
    public class LogContext
    {
        public string StackTrace { get; set; }
        public string UserInfo { get; set; }
    }
    
    public class TenantContext
    {
        public string Name { get; set; }
    }
    
    public class Program
    {
        private static AsyncLocal<LogContext> _logContext = new AsyncLocal<LogContext>();
        private static AsyncLocal<TenantContext> _tenantContext = new AsyncLocal<TenantContext>();
    
        public static async Task Main(string[] args)
        {
            _logContext.Value = new LogContext { StackTrace = "Main Stack Trace", UserInfo = "User1" };
            _tenantContext.Value = new TenantContext { Name = "Tenant A" };
    
            Console.WriteLine($"Initial Log Context: {_logContext.Value.StackTrace}, User: {_logContext.Value.UserInfo}, Tenant: {_tenantContext.Value.Name}");
    
            await Task.Run(() => LogAndProcess(new LogContext { StackTrace = "Child Stack Trace", UserInfo = "User2" }, new TenantContext { Name = "Tenant B" }));
    
            Console.WriteLine($"After Task Log Context: {_logContext.Value.StackTrace}, User: {_logContext.Value.UserInfo}, Tenant: {_tenantContext.Value.Name}");
        }
    
        private static void LogAndProcess(LogContext logContext, TenantContext tenant)
        {
            _logContext.Value = logContext;
            _tenantContext.Value = tenant;
    
            Console.WriteLine($"In Task Log Context: {_logContext.Value.StackTrace}, User: {_logContext.Value.UserInfo}, Tenant: {_tenantContext.Value.Name}");
    
            // Simulate some processing
            Task.Delay(1000).Wait();
    
            Console.WriteLine($"After Processing Log Context: {_logContext.Value.StackTrace}, User: {_logContext.Value.UserInfo}, Tenant: {_tenantContext.Value.Name}");
        }
    }
    

在这个示例中，`AsyncLocal` 用于保存日志和租户信息，确保在不同的任务上下文中正确传递和使用这些信息。