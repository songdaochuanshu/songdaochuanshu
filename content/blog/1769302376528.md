---
layout: post
title: '开发 Java MCP 就像写 Controller 一样简单，还支持 Java 8'
date: "2026-01-25T00:52:56Z"
---
开发 Java MCP 就像写 Controller 一样简单，还支持 Java 8
==========================================

Solon-AI框架为Java开发者提供了便捷的MCP协议集成方案，使老版本Java项目也能接入AI Agent生态。通过注解开发、动态构建工具、协议代理转换等特性，开发者无需研究复杂协议即可快速构建MCP服务端。框架还支持反向通讯和“三合一”客户端，实现了完整的AI能力整合，大幅降低了Java应用接入群体智能的门槛。

在 AI 应用开发从“单机对话”迈向“群体智能（Agent）”的当下，MCP（Model Context Protocol） 协议的出现，为大模型连接外部世界统一了“插座”。

但，当 Anthropic 的 MCP 协议火遍 AI 圈时，很多 Java 开发者看了一眼官方 SDK 的环境要求（Java 17+）便望而却步。难道 Java 8、Java 11 的老项目注定要与 AI Agent 时代无缘吗？

Solon-AI 给出了截然不同的答案。 在这里，开发一个标准的 MCP Server，不需要你去研究复杂的 JSON-RPC 通讯逻辑，也不需要升级你的 JDK。只需要几个注解，就像写普通的 Web 控制器一样简单。

一、 为什么 Java 开发者需要 MCP？
----------------------

在 MCP 出现之前，虽然各大模型都支持 Tool Call，但由于缺乏统一标准，开发者不得不针对不同厂商编写互不兼容的私有接口适配代码。MCP 的出现，为模型与工具之间建立了一套通用的“通讯语言”。

### MCP 彻底改变了游戏规则：

*   一次编写，到处运行：你写的 MCP Server 可以同时给 Claude Desktop、IDE 或你自己的 Solon 应用使用。
*   生态复用：GitHub 上现成的 Python/Node.js MCP 工具，Java 开发者现在可以通过 Solon-AI 的 McpClient 瞬间“拿来主义”。

二、 Solon-AI：为 MCP 而生的 Java 框架
-----------------------------

Solon-AI 是 Java 生态中率先深度集成 MCP 协议的开发框架。它不仅简化了服务端的构建，更通过高度抽象的客户端接口，让 Java 应用具备了强大的 AI 整合能力。

### 核心依赖：

    <dependency>
        <groupId>org.noear</groupId>
        <artifactId>solon-ai-mcp</artifactId>
    </dependency>
    

### 1\. 像写 Controller 一样写 Mcp Server

在 Solon-AI 中，你不需要研究复杂的 JSON-RPC 协议，也不需要手撸难以维护的原生 MCP Java SDK 代码。通过 `@ToolMapping`、`@ResourceMapping` 和 `@PromptMapping`，你可以将任何 Java 方法快速转变为 AI 可识别的工具。

    @McpServerEndpoint(name = "it-tools", channel = McpChannel.STREAMABLE, mcpEndpoint = "/mcp")
    public class MyMcpServer {
        @ToolMapping(description = "查询服务器负载")
        public String getServerLoad(@Param("serverId") String id， @Header("token") String token) {
            return "Server " + id + " load is 15%";
        }
    }
    

提示：启动项目后，即可使用 McpClientProvider 或 Claude Desktop 连接端点进行测试。

### 2、除了注解开发外，支持“动态构建”：

对于需要动态加载工具的场景，Solon-AI 提供了灵活的 Builder 模式，支持在运行时编排 AI 技能。

    @Configuration
    public class McpServerConfig {
        @Bean("mcp-weather")
        public McpServerEndpointProvider serverEndpoint() {
            McpServerEndpointProvider serverEndpoint = McpServerEndpointProvider.builder()
                    .name("mcp-weather")
                    .channel(McpChannel.STDIO)
                    .build();
                    
            FunctionToolDesc weatherTool = new FunctionToolDesc("get_weather")
                    .description("获取指定城市的天气情况")
                    .stringParamAdd("location", "根据用户提到的地点推测城市")
                    .doHandle(map -> {
                        return "24度";
                    });
    
            serverEndpoint.addTool(new MethodToolProvider(weatherTool));
    
            return serverEndpoint;
        }
    }
    

### 3、强大的协议代理转换

这是 Solon-AI 的一大绝活：支持跨协议代理。例如，你可以将本地运行的 STDIO 工具通过 Solon 包装，转为更适合集群部署的 STREAMABLE\_STATELESS（无状态流）传输。

    @McpServerEndpoint(channel = McpChannel.STREAMABLE_STATELESS, mcpEndpoint = "/mcp")
    public class McpServerTool implements ToolProvider {
        private McpClientProvider stdioToolProvider = McpClientProvider.builder()
                .channel(McpChannel.STDIO) //表示使用 stdio
                .command("npx")
                .args("-y", "@gitee/mcp-gitee@latest")
                .addEnvVar("GITEE_API_BASE", "https://gitee.com/api/v5")
                .addEnvVar("GITEE_ACCESS_TOKEN", "<your personal access token>")
                .build();
    
        @Override
        public Collection<FunctionTool> getTools() {
            return stdioToolProvider.getTools();
        }
    }
    

### 4、支持“反向通讯”，比如：Sampling 采样

MCP 不仅仅是“模型调工具”，还支持“工具调模型”。Solon-AI 完整支持了 Sampling（采样） 能力，允许服务端在执行工具时，反向请求客户端协助处理。

    //客户端
    public class SamplingClientDemo {
        public void test() {
            McpClientProvider clientProvider = McpClientProvider.builder()
                    .url("http://localhost:8080/mcp")
                    .customize(spec -> {
                        spec.capabilities(McpSchema.ClientCapabilities.builder().sampling().build());
                        spec.sampling(req -> Mono.just(McpSchema.CreateMessageResult.builder()
                                .content(new McpSchema.TextContent("test"))
                                .build()));
                    })
                    .build();
    
    
            clientProvider.callToolAsText("demo", Utils.asMap("a", 1))
                    .getContent();
        }
    }
    
    //服务端
    @McpServerEndpoint(channel = McpChannel.STREAMABLE, mcpEndpoint = "/mcp")
    public class SamplingServerDemo {
        //可以注入 exchange（实现反向通讯：服务端向客户端请求）
        @ToolMapping(description = "复杂任务拆解")
        public Mono<McpSchema.CreateMessageResult> demo(McpAsyncServerExchange exchange) {
            // 服务端向客户端请求 AI 采样决策
            return exchange.createMessage(McpSchema.CreateMessageRequest.builder()
                .messages(Collections.singletonList(McpSchema.PromptMessage.builder()
                    .role(McpSchema.Role.USER)
                    .content(new McpSchema.TextContent("请帮我拆解这个任务..."))
                    .build()))
                .build());
        }
    }
    

### 5\. “三合一”的超级客户端

McpClientProvider 实现了 Solon AI 体系内的 `ToolProvider`、`ResourceProvider` 和 `PromptProvider`。这意味着：连接一个 Server，即刻获得全量 AI 能力包。

    McpClientProvider clientProvider = McpClientProvider.builder()
                    .channel(McpChannel.STREAMABLE)
                    .url("http://localhost:8080/mcp")
                    .build();
    
    //获取所有工具原语
    clientProvider.getTools();
    //获取所有模板原语
    clientProvider.getResources();
    //获取所有资源模板原语
    clientProvider.getResourceTemplates();
    //获取所有提示词原语
    clientProvider.getPrompts();
    

为 ChatModel 赋能：

    ChatModel chatModel = ChatModel.of(apiUrl)
            .defaultToolAdd(clientProvider) // 添加为默认工具
            .build();
            
    ReActAgent agent = ReActAgent.of(chatModel);
    

为 ReActAgent 赋能：

    ChatModel chatModel = ChatModel.of(apiUrl)
            .build();
            
    ReActAgent agent = ReActAgent.of(chatModel)
            .defaultToolAdd(clientProvider) //添加为默认工具
            .build();
    

三、生产级的稳健性
---------

在生产环境下，连接的稳定性与响应速度至关重要：

*   自愈能力：内置心跳检测（Ping），链路断开自动重连，确保 Agent 永不失联。
*   高性能缓存：支持工具列表与资源元数据缓存，减少网络开销，让 AI 响应“秒开”。
*   多通道支持：无论是跨进程的 STDIO 模式，还是跨网络的 STREAMABLE 模式，Solon-AI 都能丝滑切换。
*   Skill 赋能：通过 MCP 获取的原语可直接转化为 **Solon AI Skills**，构建高度模块化的 Agent 技能树。

四、借助 Skills 实现智能加载（智能分发）
------------------------

通过 Solon AI Skills 的智能路由，你可以避免模型因工具过多而产生幻觉，同时注入本地业务指令。

    import org.noear.solon.ai.chat.skill.Skill;
    import org.noear.solon.ai.chat.skill.SkillDesc;
    import org.noear.solon.ai.mcp.McpChannel;
    import org.noear.solon.ai.mcp.client.McpClientProvider;
    
    public class McpSkillDemo {
        public void test() {
            // 1. 创建 MCP 客户端，从远端获取工具生态
            // 这里假设远端 Server 提供了如 "restart_server", "query_log" 等运维工具
            McpClientProvider devopsMcpProvider = McpClientProvider.builder()
                    .channel(McpChannel.STREAMABLE)
                    .url("http://devops-center:8080/mcp")
                    .build();
    
            // 2. 使用 SkillDesc 将 MCP 工具集包装成一个“智能运维技能”
            Skill devopsSkill = SkillDesc.builder("devops-skill")
                    .description("高级运维管理技能，支持服务器状态查询与故障处理")
                    
                    // 智能分发：只有当用户提问包含“服务器”、“重启”、“日志”时才激活此技能
                    .isSupported("服务器", "重启", "日志", "负载")
                    
                    // 动态指令：为技能注入特殊的 System Prompt 引导
                    .instruction(prompt -> {
                        return "你现在是一名高级架构师。在执行重启操作前，请务必确认操作人的权限。";
                    })
                    
                    // 挂载工具：核心一步！直接将 MCP 获取的所有工具注入到该技能中
                    .toolAdd(devopsMcpProvider) 
                    
                    // 钩子函数：当技能被挂载到会话时触发逻辑（如：记录审计日志）
                    .onAttach(prompt -> {
                        System.out.println("检测到运维相关指令，DevOps 技能已就绪...");
                    })
                    .build();
    
            // 3. 应用技能：将技能交给 Agent
            ChatModel chatModel = ChatModel.of(apiUrl).build();
            
            ReActAgent agent = ReActAgent.of(chatModel)
                    .defaultSkillAdd(devopsSkill) // 添加包装后的技能
                    .build();
    
            // 此时 Agent 只有在聊到运维话题时，才会通过 MCP 协议去调用对应的远端工具
            agent.prompt("帮我查一下 server-01 的负载情况").call();
        }
    }
    

五、 Solon-AI + MCP 的典型场景
-----------------------

### 场景 A：企业私有数据助手

通过 Solon-AI 构建一个 MCP Server，将企业的 ERP、CRM 系统通过 `@ResourceMapping` 暴露。AI 助手可以直接读取实时业务数据，而无需你手动编写复杂的数据抓取逻辑。

### 场景 B：跨语言工具链整合

你的团队可能有用 Python 写的算法脚本，现在只需将其包装成一个 MCP Server，Solon-AI 的客户端就能通过标准协议调用它，打破 Java 与 Python 的隔离。

### 场景 C：智能 IDE 与本地自动化

利用 Solon-AI 的 STDIO 通道，你可以编写 Java 程序作为本地插件，直接接入 Claude Desktop 或其他支持 MCP 的编辑器，实现用自然语言操控本地系统。

### 六、 开启你的 MCP 之旅

Solon-AI 不仅仅是在追赶趋势，它正在重新定义 Java 开发 AI 应用的体验。轻量、强大、兼容 Java 8 到 Java 25，这就是 Solon-AI。