---
layout: post
title: 'spring boot3--自动配置与手动配置'
date: "2026-01-28T00:46:26Z"
---
spring boot3--自动配置与手动配置
=======================

springboot自动配置
==============

自动配置了大量组件，配置信息可以在application.properties文件中修改。

当添加了特定的Starter POM后，springboot会根据类路径上的jar包来自动配置bean（比如：springboot发现类路径上的MyBatis相关类，springboot会自动配置MyBatis相关的bean）。

springboot使用默认配置来设置这些功能，开发人员也可以自定义配置来覆盖默认配置。

这些配置信息如何生效的？
------------

通过@ConfigurationProperties注解将配置信息注入到组件中的属性类的。属性类一般以Properties结尾。比如tomcat组件的ServerProperties类，就是将配置信息中server开头的配置注入到属性中，比如server.port=8080会被绑定到属性中

    @ConfigurationProperties("server")
    public class ServerProperties {
        private @Nullable Integer port;
        private @Nullable InetAddress address;
      .....
    }
    

自动配置是按需加载的
----------

springboot提供很多自动配置类，这些自动配置不是全部生效，它是按需加载的，导入了哪个启动器，则该启动器对应的配置类才会被加载。

任何启动器都会关联一个启动器：spring-boot-Starter，它是springboot框架最核心的启动器。

spring-boot-Starter又关联引入spring-boot-auto从figure。所有的自动配置类都在这里。

自动配置类用来创建相应的组件。

按需加载如何实现？
---------

使用条件注解可以实现按需加载。

条件注解基于某些条件决定是否应该创建一个bean。这些注解通常用在自动配置类上，以确保只有在特定条件满足时才会应用相应的配置。

条件注解可以用在类上，也可以用在方法上。

常见的条件注解有：

*   @ConditionalOnClass 指定类存在时才创建bean
*   @ConditionalOnMissingClass 指定类不存在时才创建bean
*   @ConditionalOnBean 容器中存在指定bean时才创建bean
*   @ConditionalOnMissingBean 容器中不存在指定bean时才创建bean
*   @ConditionalOnProperty 配置文件中存在指定属性时，才创建bean
*   @ConditionalOnResource 指定资源存在时才创建bean
*   @ConditionalOnWebApplication 应用程序是Web应用时才创建bean
*   @ConditionalOnNotWebApplication 应用程序不是Web应用时才创建bean

修改默认的包扫描规则
----------

修改扫描规则有2种方式：

在主入口类上添加以下注解的任意一个都可以修改包扫描规则（扫描com包及其子孙包）

1.      @ComponentScan("com")
        
    
2.      @SpringBootApplication(scanBasePackages = "com")
        
    

自动配置的实现原理
=========

1.  程序从main方法开始执行，主入口类上使用@SpringBootApplication进行标注
    
2.  @SpringBootApplication是复合注解，代表以下三个注解的功能
    
    a. @SpringBootConfiguration:它被@Configuration标注。表明主入口类是一个配置类，此时该配置开始加载。
    
    b. @ComponentScan 默认扫描主入口类所在包及其子孙包，因此spring-boot-autoconfigure 自动配置类是无法加载的，那么这些自动配置类又是怎么生效的呢？
    
    c. **@EnableAutoConfiguration 该注解的作用就是启用自动配置**
    
3.  @EnableAutoConfiguration 被@Import({AutoConfigurationImportSelector.class})标注
    

​ @Import({AutoConfigurationImportSelector.class})的作用是将AutoConfigurationImportSelector作为一个bean加载到Ioc容器中

​ 这个bean的作用是：负责收集和选择所有符合条件的自动配置类。

总结
--

1.  运行环境准备阶段
    *   引入Web启动器
    *   最终传递引入了自动配置的jar包
    *   自动配置的jar包中有152个自动配置类，到此运行环境准备完毕
2.  运行阶段
    *   @EnableAutoConfiguration 启用自动配置，将152个自动配置类全部加载到Ioc容器中。然后根据开发场景筛选出必须得自动配置类
    *   自动配置类加载了很多组件
    *   每个组件需要的数据来自属性类
    *   属性类的属性来自配置文件

总之一句话。导入启动器，修改配置文件。就可以完成对应功能的开发。

springmvc配置
===========

    # 让springboot的静态资源处理失效
    spring.web.resources.add-mappings=false
    # 配置静态资源的访问URL
    spring.mvc.static-path-pattern=/**
    #  静态资源文件存储位置默认配置
    spring.web.resources.static-locations=classpath:/META-INF/resources/, classpath:/resources/, classpath:/static/, classpath:/public/
    
    

springboot对静态资源是如何处理的？

什么样的URL ？访问哪个位置上的资源文件？

webjars
-------

webjars是现在前后端分离中比较重要的一种静态资源打包方式。

webjars是一种常用的前端库（如jQuery）打包成jar包的形式，方便在java程序中使用。

webjars提供了一种标准化的方式来管理前端库，使其更容易集成到java项目中，并且可以利用Maven的依赖管理功能。

    <!--        webjars,将前端库打成jar包-->
            <dependency>
                <groupId>org.webjars.npm</groupId>
                <artifactId>vue</artifactId>
                <version>3.5.12</version>
            </dependency>
    

默认规则是：当请求路径是/wbjars/\*\*,则会去classpath:/MEAT-INF/resources/webjars/找。

静态资源缓存处理
--------

静态资源缓存是指浏览器的缓存行为，浏览器可以缓存（js、CSS、图片、声音、视频）到浏览器中，下一次用户访问同样的资源就直接从缓存中获取，不再从服务器获取，这样能减少服务器压力，提高相应效率。

可以通过配置来修改默认的缓存机制。

    ＃静态资源缓存设置
    ＃缓存有效期设置
    spring.web.resources.cache.period=3600
    # 缓存控制设置
    spring.web.resources.cache.cachecontrol.max-age=20
    # 是否启用最后一次修改时间的比对
    spring.web.resources.cache.use-last-modified=true
    

静态index.html的支持
---------------

spring会自动处理位于静态资源目录下的index.html（文件名必须是index.html），使其成为应用程序的主页。

注意：此时不能配置静态资源访问url（spring.mvc.static-path-pattern），必须使用默认的配置

favicon.ico
-----------

将favicon.ico放在静态资源根目录下，就会自动生效。

spring boot的web手动配置（静态资源处理）
===========================

编写代码的方式
-------

### 第一种方式 实现WebMvcConfigurer接口

    // 添加这个注解后，表示不再使用springboot提供的默认配置
    // @EnableWebMvc
    @Configuration
    public class WebConfig implements WebMvcConfigurer {
        
        // 静态资源处理需要重写的方法
        @Override
        public void addResourceHandlers(ResourceHandlerRegistry registry) {
            // 使用注册器registry 绑定 pathPatterns 以及真实的静态资源文件存储路径
            registry.addResourceHandler("/abc/**") // 配置路径访问模式
                    .addResourceLocations("classpath:/static1/", "classpath:/static2/", "classpath:/static3/"); // 配置静态资源路径
        }
    }
    

### 第二种方式

    @Configuration
    public class WebConfig2 {
    
        @Bean
        public WebMvcConfigurer addResourceHandlers() {
            return new WebMvcConfigurer() {
                @Override
                public void addResourceHandlers(ResourceHandlerRegistry registry) {
                    registry.addResourceHandler("/abc/**") // 配置路径访问模式
                            .addResourceLocations("classpath:/static1/", "classpath:/static2/", "classpath:/static3/"); // 配置静态资源路径
                }
            };
        }
    }
    

web请求的路径匹配
==========

    # 前端请求的url 匹配到controller中的某个方法
    # 使用ant风格的路径匹配规则，默认值是path_pattern_matcher
    # path_pattern_matcher兼容且支持ant风格
    # 在ant风格中** 可以出现在任何位置，但在path_pattern_matcher风格中，** 只能出现在末尾
    # spring6 下的ant风格 ** 也只能出现在末尾
    spring.mvc.pathmatch.matching-strategy=ant_path_matcher
    

本文来自博客园，作者：[NE\_STOP](https://www.cnblogs.com/alineverstop/)，转载请注明原文链接：[https://www.cnblogs.com/alineverstop/p/19537574](https://www.cnblogs.com/alineverstop/p/19537574)