---
layout: post
title: 'Java类加载机制深度解析：从.class文件到JVM运行时'
date: "2025-12-02T00:43:32Z"
---
Java类加载机制深度解析：从.class文件到JVM运行时
==============================

首先先贴上一张Java类加载的思维导图

![image](https://img2024.cnblogs.com/blog/3556374/202512/3556374-20251201224219340-1332035105.png)

### 一、Java 程序运行流程

在Java中，一个程序的起点是`.java`源文件，它经由`javac`编译器编译为字节码`.class`文件。随后，Java虚拟机（JVM）负责加载这些字节码文件，并将其转换为与操作系统交互的机器指令来执行。我们可以用以下流程图来概括这个宏观过程：

![image](https://img2024.cnblogs.com/blog/3556374/202512/3556374-20251201224329425-1831889120.png)

### 二、类的生命周期与类加载

而我们今天要深入剖析的，正是JVM将`.class`文件中的二进制数据读入内存，并转换成JVM可以使用的运行时数据结构的整个过程——**类加载**。要理解类加载，就离不开类的完整生命周期。下图展示了包含类生命周期的完整视图：

![image](https://img2024.cnblogs.com/blog/3556374/202512/3556374-20251201224323770-782886793.png)

从上图可见，我们通常所说的“类加载”是一个广义概念，它主要指生命周期中“加载”和“连接”两大阶段，具体可细分为以下五个核心部分：

1.  **加载**
    
    加载是“类加载”过程的第一步。主要完成三件事：
    
    *   通过类的全限定名获取定义此类的二进制字节流。
    *   将这个字节流所代表的静态存储结构转换为**方法区**的运行时数据结构。
    *   在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区该类的各种数据的访问入口。
    
    > **注意**：Class文件的来源非常广泛，不仅仅是本地文件系统，还可以来自ZIP/JAR包、网络、运行时计算生成（动态代理）或其它文件（JSP生成）等。
    
2.  **验证**
    
    验证是连接阶段的第一步，目的是确保Class文件的字节流信息符合JVM规范，不会危害JVM自身安全。它包含四个检验动作：
    
    *   **文件格式验证**：验证字节流是否符合Class文件格式规范（如魔数、主次版本号等），这一步在加载阶段即可发生。
    *   **元数据验证**：对字节码描述的信息进行语义分析，确保符合Java语言规范（如是否有父类、是否继承了final类等）。
    *   **字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的（如保证跳转指令不会跳转到方法体以外的字节码上）。
    *   **符号引用验证**：发生在解析阶段，确保解析动作能正常执行（如通过全限定名能找到对应的类、访问性是否合法等）。
3.  **准备**
    
    准备阶段是正式为**类变量（被static修饰的变量）** 分配内存并设置初始值的阶段。这些变量所使用的内存都在方法区中进行分配。
    
    *   **重要概念**：此阶段设置的通常是数据类型的**零值**。例如，`public static int value = 123;`，在准备阶段后，`value`的初始值是`0`，而非`123`。将`value`赋值为`123`的`putstatic`指令是在程序编译后，存放于`<clinit>()`类构造器方法中，所以赋值的动作是在**初始化**阶段才会执行。
    *   **特殊情况**：如果类字段的字段属性表中存在`ConstantValue`属性（即被`static final`修饰的常量），那么在准备阶段变量便会被初始化为指定的值。例如，`public static final int value = 123;`在准备阶段后，`value`的值就是`123`。
4.  **解析**
    
    解析阶段是JVM将常量池内的**符号引用**替换为**直接引用**的过程。
    
    *   **符号引用**：以一组符号来描述所引用的目标，与JVM实现的内存布局无关。
        
    *   **直接引用**：可以是直接指向目标的指针、相对偏移量或能间接定位到目标的句柄，与JVM的内存布局相关。
        
    *   **解析策略**：
        
        *   **静态解析**：如果符号引用在加载时就已经明确具体的目标，那么在解析阶段就可以完成替换。
        *   **动态解析**：对于一些在编译期无法确定的引用（如多态、接口实现），则要推迟到第一次实际使用时（运行时）再完成解析。
5.  **初始化**
    
    这是类加载过程的最后一步。此阶段才真正开始执行类中定义的Java程序代码（或字节码）。JVM会执行`<clinit>()`方法，该方法是由编译器自动收集类中的所有**类变量的赋值动作**和**静态语句块**中的语句合并产生的。JVM会保证在子类的`<clinit>()`方法执行前，父类的`<clinit>()`方法已经执行完毕。
    

* * *

### **三、Java类加载器**

类加载器是实现“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作的代码模块。

JVM提供了三层类加载器，它们之间以**组合关系**协同工作：

1.  **启动类加载器（Bootstrap Class Loader）** ：
    
    *   由C++实现，是JVM自身的一部分。
    *   负责加载`<JAVA_HOME>/lib`目录下，或被`-Xbootclasspath`参数指定的路径中的核心类库（如`rt.jar`、`charsets.jar`等）。
    *   它是所有类加载器的父加载器。
2.  **扩展类加载器（Extension Class Loader）** ：
    
    *   由Java实现，是`sun.misc.Launcher$ExtClassLoader`类。
    *   负责加载`<JAVA_HOME>/lib/ext`目录下，或`java.ext.dirs`系统变量所指定的路径中的所有类库。
    *   它是应用程序类加载器的父加载器。
3.  **应用程序类加载器（Application Class Loader）** ：
    
    *   由Java实现，是`sun.misc.Launcher$AppClassLoader`类。
    *   负责加载用户类路径（ClassPath）上所指定的类库。它是程序中默认的类加载器。

除了这三个系统提供的类加载器，用户还可以通过继承`java.lang.ClassLoader`类的方式，定制自己的类加载器，以满足特殊的需求（如热部署、从网络或加密文件中加载类等）。

### **四、双亲委派模型**

#### **1\. 工作流程**

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器（这里的父子关系一般通过**组合**而非继承来实现）。它的**工作流程**是：

当一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求**委派**给父类加载器去完成。每一层的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。

只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

#### **2\. 核心优势**

*   **避免类的重复加载**：确保一个类在JVM中全局唯一。父加载器加载过了，子加载器就不会再加载一次。
*   **保证程序安全**：防止核心API库被随意篡改。例如，用户自定义一个`java.lang.Object`类，双亲委派机制会保证最终由启动类加载器加载核心的`Object`类，而用户自定义的`Object`类不会被加载，从而防止了恶意代码的注入。

#### **3\. 破坏双亲委派模型**

双亲委派模型并非强制性约束。在某些场景下它会被打破，例如：

*   **SPI（Service Provider Interface）机制**：如JDBC。核心接口在`rt.jar`中由启动类加载器加载，但具体实现（如MySQL驱动）在ClassPath下，需要由应用类加载器加载。这就引入了**线程上下文类加载器**来逆向委托子加载器去加载实现类。
*   **OSGi**、**JNDI**等模块化热部署技术，也需要动态调整类加载器的委托关系。