---
layout: post
title: 'VTK开发笔记（四）：示例Cone，创建圆锥体，在Qt窗口中详解复现对应的Demo'
date: "2025-09-23T00:38:37Z"
---
VTK开发笔记（四）：示例Cone，创建圆锥体，在Qt窗口中详解复现对应的Demo
=========================================

前言
==

  vtk的了解学习途径跟随代码中的示例，循序渐进。  
  本篇详细解析Cone.exe，后在Qt中复现一样的。

Demo
====

  

自带示例：Cone.exe
=============

  显示效果  
  

  

示例所在位置
------

  

示例代码深度解析
--------

    int main()
    {
        // 步骤一：创建圆锥体数据源
        vtkConeSource *cone = vtkConeSource::New();
        cone->SetHeight( 3.0 );
        cone->SetRadius( 1.0 );
    cone->SetResolution( 10 );
    
        // 步骤二：创建多边形数据映射器（注意：可以在数据源和映射器之间插入中间过滤器）
        vtkPolyDataMapper *coneMapper = vtkPolyDataMapper::New();
    coneMapper->SetInputConnection(cone->GetOutputPort() );
    
        // 步骤三：创建一个演员来代表圆锥体。演员协调映射器图形图元的渲染。actor还通过vtkProperty实例引用属性，并包含一个内部转换矩阵。我们将此actor的映射器设置为上面创建的coneMapper。 
        vtkActor *coneActor = vtkActor::New();
    coneActor->SetMapper( coneMapper );
    
        // 步骤四：创建渲染器并为其分配演员。渲染器就像一个视口。它是屏幕上窗口的一部分或全部，负责绘制它所拥有的演员。我们还在此处设置了背景颜色。  
    vtkRenderer *ren1= vtkRenderer::New();
    ren1->AddActor( coneActor );
    ren1->SetBackground( 0.1, 0.2, 0.4 );
    
    // 步骤五：创建渲染窗口，它将显示在屏幕上。使用AddRenderer将渲染器放入渲染窗口。将渲染器大小设置为300像素乘300像素。  
    vtkRenderWindow *renWin = vtkRenderWindow::New();
      renWin->AddRenderer( ren1 );
      renWin->SetSize( 300, 300 );
        // 步骤六：现在我们循环360度，每次渲染圆锥体。
        int i;
        for (i = 0; i < 360; ++i)
        {
            // render the image
            renWin->Render();
            // rotate the active camera by one degree
            ren1->GetActiveCamera()->Azimuth( 1 );
        }
        // 释放对象
        cone->Delete();
        coneMapper->Delete();
        coneActor->Delete();
        ren1->Delete();
        renWin->Delete();
    
        return 0;
    }
    

复现Demo
======

  有一个很重要的点，这个示例代码是阻塞时的循环刷新，与Qt的基于消息的编程处理方式不一样，这是过程式的编程，我们复刻示例，保持一块Demo就一个函数，否则的话，可以使用Qt定时器来实现更新位置就可以了。

步骤一：创建圆锥体数据源
------------

  

步骤二：创建多边形映射器
------------

  

  

步骤三：创建演员类（类似osg模型结点）
--------------------

  

  

步骤四：创建渲染器
---------

  

  

步骤五：设置渲染器到渲染窗口
--------------

  

步骤六：用Qt的方式实现不阻塞又是过程化旋转
----------------------

  

  

Demo源码
======

VTKWidget.cpp
-------------

    void VTKWidget::test_demo3_createCone()
    {
        // 步骤一：创建圆锥体数据源
        vtkSmartPointer<vtkConeSource> pConeSource =
                VTKManager::createConeSource(0, 0, 0, 10, 30, 10);
        // 步骤二：创建多边形映射器
    #if 0
        vtkSmartPointer<vtkPolyDataMapper> pPolyDataMapper =
                VTKManager::createPolyDataMapper(pConeSource);
    #else
        vtkSmartPointer<vtkPolyDataMapper> pPolyDataMapper =
                VTKManager::createPolyDataMapper(pConeSource->GetOutputPort());
    #endif
        // 步骤三：创建演员
        vtkSmartPointer<vtkActor> pActor =
                VTKManager::createActor(pPolyDataMapper);
        // 步骤四：创建渲染器
        vtkSmartPointer<vtkRenderer> pRenderer =
                VTKManager::createRenderer(pActor, 0.1, 0.2, 0.4);
    
        // 步骤五：渲染器添加到QVTKWidget渲染
        _pQVTKWidget->GetRenderWindow()->AddRenderer(pRenderer);
    
    
        // 步骤六：过程循环的方式实现旋转
        QElapsedTimer elapsedTimer;
        for(int index = 0; index < 360; index++)
        {
            LOG << index;
            // render the image
            _pQVTKWidget->GetRenderWindow()->Render();
    
            elapsedTimer.start();
            while(elapsedTimer.elapsed() < 10)
            {
                qApp->processEvents();
            }
            // 渲染器相机绕焦点旋转
            VTKManager::rotateAzimuth(pRenderer, 1);
        }
    }
    

VTKManager.cpp
--------------

    vtkSmartPointer<vtkConeSource> VTKManager::createConeSource(double x, double y, double z, double r, int h, int n)
    {
        // 步骤一：智能指针定义
        vtkSmartPointer<vtkConeSource> pConeSource;
        // 步骤二：智能指针实例化
        pConeSource = vtkSmartPointer<vtkConeSource>::New();
        // 步骤三：设置中心坐标
        pConeSource->SetCenter(x, y, z);
        // 步骤三：设置半径
        pConeSource->SetRadius(r);
        // 步骤四：设置圆锥的高度
        pConeSource->SetHeight(h);
        // 步骤五：设置圆锥球体的经度分辨率，即横向的切片数量（横向/水平精细度）
        pConeSource->SetResolution(n);
    
        return pConeSource;
    }
    
    vtkSmartPointer<vtkPolyDataMapper> VTKManager::createPolyDataMapper(vtkConeSource *pConeSource)
    {
        // 步骤一：智能指针定义
        vtkSmartPointer<vtkPolyDataMapper> pPolyDataMapper;
        // 步骤二：智能指针实例化
        pPolyDataMapper = vtkSmartPointer<vtkPolyDataMapper>::New();
        // 步骤三：设置
        pPolyDataMapper->SetInputConnection(pConeSource->GetOutputPort());
    
        return pPolyDataMapper;
    }
    
    vtkSmartPointer<vtkPolyDataMapper> VTKManager::createPolyDataMapper(vtkAlgorithmOutput *pAlgorithmOutput)
    {
        // 步骤一：智能指针定义
        vtkSmartPointer<vtkPolyDataMapper> pPolyDataMapper;
        // 步骤二：智能指针实例化
        pPolyDataMapper = vtkSmartPointer<vtkPolyDataMapper>::New();
        // 步骤三：设置
        pPolyDataMapper->SetInputConnection(pAlgorithmOutput);
    
        return pPolyDataMapper;
    }
    vtkSmartPointer<vtkActor> VTKManager::createActor(vtkPolyDataMapper *pPolyDataMapper)
    {
        // 步骤一：智能指针定义
        vtkSmartPointer<vtkActor> pActor;
        // 步骤二：智能指针实例化
        pActor = vtkSmartPointer<vtkActor>::New();
        // 步骤三：设置映射器
        pActor->SetMapper(pPolyDataMapper);
    
        return pActor;
    }
    vtkSmartPointer<vtkRenderer> VTKManager::createRenderer(vtkActor *pActor, double r, double g, double b)
    {
        // 步骤一：智能指针定义
        vtkSmartPointer<vtkRenderer> pRenderer;
        // 步骤二：智能指针实例化
        pRenderer = vtkSmartPointer<vtkRenderer>::New();
        // 步骤三：设置映射器
        pRenderer->AddActor(pActor);
        // 步骤四：设置背景色
        pRenderer->SetBackground(r, g, b);
    
        return pRenderer;
    }
    
    void VTKManager::rotateAzimuth(vtkRenderer *pRenderer, double angle)
    {
        pRenderer->GetActiveCamera()->Azimuth(angle);
    }
    

工程模板v1.2.0
==========