---
layout: post
title: 'Spring使用el表达式'
date: "2025-12-01T00:53:51Z"
---
Spring使用el表达式
=============

Spring使用el表达式
-------------

### 0\. 背景

在项目中需要一个可动态执表达式的功能.项目本身是基于`Springboot`,可直接使用Spring提供的核心模块`Spring Expression Language`(SpEL). 在测试前,需要了解一些基本前置条件

*   整体可以按照java语法编写脚本串
*   只支持单条语句执行
*   表达式串中,内部字符串可以使用单引号,双引号(需要转义)
*   表达默认导入的包为`java.lang.*`,如果是其他包下的对象,需要使用包名和类名详细可以查看类`StandardTypeLocator`对应的构造函数

以下 1 到 10 章节为每个语法的测试代码以及执行结果.如果对测试代码和结果不敢兴趣可以快速移动到文末**总结**部分.对所有语法的一个简单汇总.这里只说明基本使用,下一篇会讲一些**安全相关的**防止RCE攻击.以及一些**扩展能力**

### 1\. 调用静态方法

语法:`T(class)`,比如`T(Runtime)`就是获取到类`Runtime`.分别需要测试测试`java.lang.*` 和其他包下的对象调用方式

    	public void testExecClassMethod() {
        String classMethodExpr = "T(Runtime).getRuntime().exec('calc')";
        ExpressionParser elParser = new SpelExpressionParser();
        Object value = elParser.parseExpression(classMethodExpr).getValue();
        System.out.println("(  java.lang)执行类方法T(class): " + value);
        // 需要 包名+类名
        String otherJarMethodExpr = "T(org.apache.commons.lang.StringEscapeUtils).escapeHtml('小游戏 地心侠士')";
        Object thridJarValue = elParser.parseExpression(otherJarMethodExpr).getValue();
        System.out.println("(非java.lang)执行类方法T(class): " + thridJarValue);
    	}
    

以上代码执行结果如下

    (  java.lang)执行类方法T(class): Process[pid=31572, exitValue="not exited"]
    (非java.lang)执行类方法T(class): &#23567;&#28216;&#25103; &#22320;&#24515;&#20384;&#22763;
    

从执行结果可知道,动态执行脚本是很危险的操作,一部小心就被别人利用,导致RCE攻击.比如上边第一个测试代码轻松调用计算器功能.

### 2\. 调用实例方法

语法:`#root.method(args)` 或者`#变量名.method(args)`或者直接`methodName(args)`

    public void testInstanceMethod() {
      String elExpr = "substring(4,8)+' 小游戏 '+(333+333)";
      String elLengthExpr = "#root.length()";
      String testStr = "小游戏 地心侠士";
      System.out.println("===测试字符串===");
      System.out.println(testStr);
      ExpressionParser elParser = new SpelExpressionParser();
      Object strLen = elParser.parseExpression(elLengthExpr).getValue(testStr);
      Object value = elParser.parseExpression(elExpr).getValue(testStr);
      System.out.println("===使用getValue传入具体的对象==");
      System.out.println(elLengthExpr + ": " + strLen);
      System.out.println(elExpr + ":" + value);
      StandardEvaluationContext ctx = new StandardEvaluationContext();
      ctx.setRootObject(testStr);
      ctx.setVariable("var", testStr);
      value = elParser.parseExpression(elExpr).getValue(ctx);
      strLen = elParser.parseExpression(elLengthExpr).getValue(ctx);
      Object varVal = elParser.parseExpression("#var." + elExpr).getValue(ctx);
      System.out.println("===使用ctx传入变量和root对象==");
      System.out.println(elLengthExpr + " :  " + strLen);
      System.out.println(elExpr + " : " + value);
      System.out.println("#var." + elExpr + " : " + varVal);
    }
    

以上代码执行结果如下:

    ===测试字符串===
    小游戏 地心侠士
    ===使用getValue传入具体的对象==
    #root.length(): 8
    substring(4,8)+' 小游戏 '+(333+333):地心侠士 小游戏 666
    ===使用ctx传入变量和root对象==
    #root.length() :  8
    substring(4,8)+' 小游戏 '+(333+333) : 地心侠士 小游戏 666
    #var.substring(4,8)+' 小游戏 '+(333+333) : 地心侠士 小游戏 666
    

从执行结果可以知道,在传递具体实例对象是,就是调用 `setRootObject` ,针对根对象,可以使用`#root.methodName(args)`也可以直接调用方法 `methodName(args)`

### 3\. 调用构造函数

语法:`new className()` 测试 String 构造函数,日期格式化构造函数同`java`日期对象结合,已经一个简单pojo对象

    public void testInstanceCtor() {
      String strCtor = "new String('小游戏 地心侠士')";
      ExpressionParser elParser = new SpelExpressionParser();
      Object strVal = elParser.parseExpression(strCtor).getValue();
      System.out.println(strCtor + ": " + strVal);
      String cotrExpr = "new java.text.SimpleDateFormat('yyyy-MM-dd HH:mm:ss')";
      SimpleDateFormat df = (SimpleDateFormat) elParser.parseExpression(cotrExpr).getValue();
      System.out.println("当前时间: " + df.format(new Date()));
      String innerEl = "new com.herbert.script.SpringElScript.ElTestObject('小游戏','地心侠士')";
      ElTestObject value = elParser.parseExpression(innerEl).getValue(ElTestObject.class);
      System.out.println(value);
      ElTestObject javaObj = new ElTestObject("小游戏", "地心侠士");
      Object gameName = elParser.parseExpression("gameName").getValue(javaObj);
      System.out.println("获取java对象上的值:" + gameName);
    }
    

以上代码,执行结果如下

    new String('小游戏 地心侠士'): 小游戏 地心侠士
    当前时间: 2025-11-29 21:54:55
    ElTestObject [gameType=小游戏, gameName=地心侠士]
    获取java对象上的值:地心侠士
    

从这是结果可以知道`getValue`初始的后的对象,已经就是java对象,可以直接获取对象属性.两者之间,可以**相互穿插**调用.

针对 Map 和 List 构造函数,也提供了一种内联的方式初始方式  
Map 语法:`{key:value}`  
List 语法:`{value1,value2,value3}`

    public void testInlineMapAndList() {
      String initMap = "{'gameType':'小游戏','gameName':'地心侠士'}";
      String initList = "{'小游戏','地心侠士'}";
      ExpressionParser elParser = new SpelExpressionParser();
      Map map = elParser.parseExpression(initMap).getValue(Map.class);
      System.out.println("===通过{key:value}初始的内容===");
      System.out.println(String.format("%s : %s ", map.get("gameType"), map.get("gameName")));
      List lst = elParser.parseExpression(initList).getValue(List.class);
      System.out.println("===通过{value,value}初始的内容===");
      System.out.println(String.format("%s : %s ", lst.get(0), lst.get(1)));
    }
    

执行结果如下:

    ===通过{key:value}初始的内容===
    小游戏 : 地心侠士 
    ===通过{value,value}初始的内容===
    小游戏 : 地心侠士 
    

### 4\. 获取SpringBean

语法:`@beanName`,如果不在Spring环境,需要实现一个`BeanResolver`接口,这里只测试Spring环境中.

在Springboot中注册一个bean

    @Bean
    public Map elMap() {
      Map elMap = new HashMap();
      elMap.put("gameType", "小游戏");
      elMap.put("gameName", "地心侠士");
      return elMap;
    }
    

测试代码如下,这个特别地方需要使用`BeanFactoryResolver`包装 `applicationContext` 放到`context`中

    @Autowired
    ApplicationContext applicationContext;
    
    public void testSpringBean() {
      Consumer<Map> printMap = map -> {
      	System.out.println(map.get("gameType") + ": " + map.get("gameName"));
      };
      System.out.println("=====使用 Autowired 获取到bean内容=======");
      printMap.accept(elMap);
      Map ctxElMap = (Map) applicationContext.getBean("elMap");
      System.out.println("=====使用 applicationContext 获取到bean内容=======");
      printMap.accept(ctxElMap);
    
      String beanStr = "@elMap";
      ExpressionParser elParser = new SpelExpressionParser();
      StandardEvaluationContext elContext = new StandardEvaluationContext();
      // 注册spring BeanResolver
      elContext.setBeanResolver(new BeanFactoryResolver((BeanFactory) applicationContext));
      Map convertMap = (Map) elParser.parseExpression(beanStr).getValue(elContext);
      System.out.println("=====使用 el 获取到bean内容(BeanResolver)=======");
      printMap.accept(convertMap);
    }
    

执行结果如下:

    =====使用 Autowired 获取到bean内容=======
    小游戏: 地心侠士
    =====使用 applicationContext 获取到bean内容=======
    小游戏: 地心侠士
    =====使用 el 获取到bean内容(BeanResolver)=======
    小游戏: 地心侠士
    

### 5\. 获取List元素

语法:`list[index]`

    public void testGetListValue() {
      ArrayList<String> datas = new ArrayList<>();
      datas.add("小游戏");
      datas.add("地心侠士");
      String listEL = "'使用Variable '+#ary[0] +' :  '+#ary[1]";
      System.out.println("==SPEL 获取LIST采用 对象[index] 方式==");
      ExpressionParser elParser = new SpelExpressionParser();
      StandardEvaluationContext elContext = new StandardEvaluationContext();
      elContext.setVariable("ary", datas);
      Object value = elParser.parseExpression(listEL).getValue(elContext);
      System.out.println(value);
      // 测试rootObje
      elContext.setRootObject(datas);
      listEL = "'使用rootObjet: '+#root[0] + ' : '+#root[1]";
      value = elParser.parseExpression(listEL).getValue(elContext);
      System.out.println(value);
      System.out.println("数组'[1]'获取到的值:"+elParser.parseExpression("[1]").getValue(elContext));
    }
    

执行结果如下:

    ==SPEL 获取LIST采用 对象[index] 方式==
    使用Variable 小游戏 :  地心侠士
    使用rootObjet: 小游戏 : 地心侠士
    数组'[1]'获取到的值:地心侠士
    

### 6\. 获取Map元素

语法:`map[key]`或者`map.get(key)`

    public void testGetMapEntryValue() {
      String beanStr = "@elMap.get('gameType')+' : ' + @elMap.get('gameName')";
      ExpressionParser elParser = new SpelExpressionParser();
      StandardEvaluationContext elContext = new StandardEvaluationContext();
      elContext.setBeanResolver(new BeanFactoryResolver((BeanFactory) applicationContext));
      Object mapvalue = elParser.parseExpression(beanStr).getValue(elContext);
      System.out.println("===SPEL 获取Map采用 对象.get('mapkey') 方式===");
      System.out.println(mapvalue);
      mapvalue = elParser.parseExpression("@elMap['gameType']+' : '+@elMap['gameName']").getValue(elContext);
      System.out.println("===SPEL 获取Map采用 对象['mapkey'] 方式===");
      System.out.println(mapvalue);
      }
    

执行结果如下:

    ===SPEL 获取Map采用 对象.get('mapkey') 方式===
    小游戏 : 地心侠士
    ===SPEL 获取Map采用 对象['mapkey'] 方式===
    小游戏 : 地心侠士
    

### 7\. 集合筛选

语法:

*   `list.?[condition]` 过滤集合
*   `list.^[condition]` 返回过滤后的第一个
*   `list.$[condition]` 返回过滤后的最后一个
*   `list.![condition]` 投影,类似flatmap,会改变筛选集合类型

    public void testCollectionFilterAndFlatMap() {
      List datas = Arrays.asList(new String[] { "小游戏", "地心侠士1", "地心侠士2" });
      Map mapData = new HashMap() {
      	{
      		put("gameType", "小游戏");
      		put("gameName", "地心侠士");
      	}
      };
      String el = "#root.?[#this.contains('地心侠士')]";
      System.out.println("===筛选List===");
      ExpressionParser elParser = new SpelExpressionParser();
      List filterList = elParser.parseExpression(el).getValue(datas, List.class);
      filterList.forEach(System.out::println);
      System.out.println("===list快速获取第一个===");
      el = "#root.^[#this.contains('地心侠士')]";
      Object value = elParser.parseExpression(el).getValue(datas);
      System.out.println(value);
      System.out.println("===list快速获取最后一个===");
      el = "#root.$[#this.contains('地心侠士')]";
      value = elParser.parseExpression(el).getValue(datas);
      System.out.println(value);
      System.out.println("===筛选Map按key筛选===");
      el = "#root.?[key=='gameName']";
      Map filterMap = elParser.parseExpression(el).getValue(mapData, Map.class);
      filterMap.keySet().forEach(System.out::println);
      System.out.println("===筛选Map按value筛选===");
      el = "#root.?[value=='地心侠士']";
      filterMap = elParser.parseExpression(el).getValue(mapData, Map.class);
      filterMap.keySet().forEach(System.out::println);
      System.out.println("===提取Map所有Value===");
      el = "#root.![value]";
      List flatMapList = elParser.parseExpression(el).getValue(mapData, List.class);
      flatMapList.forEach(System.out::println);
    }
    

执行结果如下:

    ===筛选List===
    地心侠士1
    地心侠士2
    ===list快速获取第一个===
    地心侠士1
    ===list快速获取最后一个===
    地心侠士2
    ===筛选Map按key筛选===
    gameName
    ===筛选Map按value筛选===
    gameName
    ===提取Map所有Value===
    小游戏
    地心侠士
    

### 8\. 实例赋值

语法: `=` 赋值 或者调用 `Expression#setValue`

    public void testAssignmentValue() {
      ElTestObject obj = new ElTestObject();
      String elExpr = "gameName";
      ExpressionParser elParser = new SpelExpressionParser();
      elParser.parseExpression(elExpr).setValue(obj, "地心侠士");
      System.out.println("使用EL setValue :" + obj.getGameName());
            
      elExpr="gameName=#change";
      StandardEvaluationContext ctx = new StandardEvaluationContext(obj);
      ctx.setVariable("change", "小游戏");
      elParser.parseExpression(elExpr).getValue(ctx);
      System.out.println("使用EL = 赋值:" +obj.getGameName());
    }
    

执行结果如下:

    使用EL setValue :地心侠士
    使用EL = 赋值:小游戏
    

### 9\. 特殊语法

特殊语法为EL特有,在标准java中不支持的语法

#### 9.1 空判断语法 `?:'a'`,如果值为空则返回'a'

    public void testNullShort() {
     String nullStr = "null?:'空值出现'";
     ExpressionParser elParser = new SpelExpressionParser();
     Object value = elParser.parseExpression(nullStr).getValue();
     System.out.println("?: 空值表达式值: " + value);
    }
    

执行结果如下:

    ?: 空值表达式值: 空值出现
    

#### 9.2 安全导航操作符`?.aa`,如果属性值aa不为空返回aa否则返回null

    public void testSafeNav() {
      	ElTestObject t = new ElTestObject();
      	t.setGameName("地心侠士");
      	String el = "gameName?.substring(0,2)";
      	ExpressionParser elParser = new SpelExpressionParser();
      	System.out.println("至空前运行结果: "+ elParser.parseExpression(el).getValue(t));
      	t.setGameName(null);
      	System.out.println("至空后运行结果: "+ elParser.parseExpression(el).getValue(t));
      	try {
      		System.out.println("至空后不使用结果: "+ elParser.parseExpression("gameName.substring(0,1)").getValue(t));
      	} catch (Exception e) {
      		System.out.println("未使用?.表达式,出现NPE异常");
      	}		
      }
    

执行结果如下:

    至空前运行结果: 地心
    至空后运行结果: null
    未使用?.表达式,出现NPE异常
    

#### 9.3 属性可以使用索引方式访问,特殊如`String[0]`,可以返回第一个字符,类似`charAt(index)`

    public void testIndexAccess() {
      ElTestObject obj = new ElTestObject("小游戏", "地心侠士");
      String el = "['gameName']";
      ExpressionParser elParser = new SpelExpressionParser();
      System.out.println("===使用[]访问属性===");
      Object value = elParser.parseExpression(el).getValue(obj);
      System.out.println(value);
      System.out.println("===使用[]访问String===");
      el = "[1]+#root.length";
      value = elParser.parseExpression(el).getValue("地心侠士");
      System.out.println("el[1]: "+value);
      System.out.println("charAt(1): "+"地心侠士".charAt(1));
    }
    

执行结果如下:

    ===使用[]访问属性===
    地心侠士
    ===使用[]访问String===
    el[1]: 心4
    charAt(1): 心
    

#### 9.4 字符串支持 `*` `-` 操作符,但是特别注意**\-**只支持单字符串.

    public void testStringOperator() {
      String el = "'地心侠士 '*2";
      ExpressionParser elParser = new SpelExpressionParser();
      Object value = elParser.parseExpression(el).getValue();
      System.out.println("===*操作符效果===");
      System.out.println(value);
      el = "'c'-2";
      value = elParser.parseExpression(el).getValue();
      System.out.println("===-操作符效果===");
      System.out.println(value);
    }
    

执行结果如下:

    ===*操作符效果===
    地心侠士 地心侠士 
    ===-操作符效果===
    a
    

#### 9.5 操作符 `< <= > >= == !=` 同 `lt le gt ge eq ne`; `&& || !` 同 `and or not`; `/ %`同 `div mod` 这三组都是等价的; 在使用中需要**前后添加一个空格**

    public void testSameOperator() {
      String el = "1 gt 2";
      ExpressionParser elParser = new SpelExpressionParser();
      Object value = elParser.parseExpression(el).getValue();
      System.out.println("=== > 换成 gt ===");
      System.out.println(value);
      el = "2 >1 and 2>2";
      value = elParser.parseExpression(el).getValue();
      System.out.println("=== && 换 and ===");
      System.out.println(value);
      el = "4 div 2";
      value = elParser.parseExpression(el).getValue();
      System.out.println("=== / 换 div ===");
      System.out.println(value);
    }
    

执行结果如下:

    === > 换成 gt ===
    false
    === && 换 and ===
    false
    === / 换 div ===
    2
    

#### 9.6 操作符支持 `between` 和 正则 `matches`

    public void  testbetweenMatch() {
      String el = "'b' between {'a','c'}";
      ExpressionParser elParser = new SpelExpressionParser();
      Object value = elParser.parseExpression(el).getValue();
      System.out.println("===b 是否在 ac 之间===");
      System.out.println(value);
      el="'123' matches '^\\d{3}$'";
      value = elParser.parseExpression(el).getValue();
      System.out.println("===matches 检测三位数字 ===");
      System.out.println(value);
    }
    

输出结果如下:

    ===b 是否在 ac 之间===
    true
    ===matches 检测三位数字 ===
    true
    

### 10\. 总结

语法汇总:

*   `T(className)` 获取class对象
*   `new className(xx,xx)` 创建对象
*   `@beanName` 获取bean对象
*   `{value1,value2}` 简便创建数组
*   `{'key1':'value'}` 简便创建map
*   `#root`获取根对象`#variable`获取变量`#this`获取当前对象,集合筛选中使用
*   `method()` 或者 `#variable.method` 调用方法
*   `property` 或者 `#variable.property` 获取属性
*   `[index]`或者`[propertyName]`获取集合元素或对象属性
*   `list.?[condition]`筛选集合元素
*   `list.?^[condition]`返回筛选后的第一个元素
*   `list.?$[condition]`返回筛选后的最后一个元素
*   `list.![propertyName]`集合投影
*   `?:'value'`空值判类似`if(value==null){value='value'}`
*   `property?.method()` 安全导航操作符,如果属性值不为空则返回属性值,否则返回null
*   `setValue` 或者 '=' 属性赋值
*   `+` `-` `*` `/` `%` `<` `<=` `>` `>=` `==` `!=` `&&` `||` `!` `between` `matches` `instanceof` 操作符,支持等价的转义符:`lt le gt ge eq ne and or not div mod`
*   `string * number` 表述复制nubmer个string

以上是基本的取值,赋值,筛选的基本操作语法.下期分享**安全和扩展**,如果需要完整测试代码,请在微信公众号:**小满小慢** 回复**spel**获取完整测试代码.

原文地址: [https://mp.weixin.qq.com/s/6nXCJjrX2zAudd4KpFkANQ](https://mp.weixin.qq.com/s/6nXCJjrX2zAudd4KpFkANQ)

转载请注明来源

作者:[杨瀚博](http://home.cnblogs.com/u/yfrs/)

QQ:464884492