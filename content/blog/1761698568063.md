---
layout: post
title: '【硬件测试】基于FPGA的8PSK+帧同步系统开发与硬件片内测试,包含高斯信道,误码统计,可设置SNR'
date: "2025-10-29T00:42:48Z"
---
【硬件测试】基于FPGA的8PSK+帧同步系统开发与硬件片内测试,包含高斯信道,误码统计,可设置SNR
===================================================

1.算法[硬件测试](https://so.csdn.net/so/search?q=%E7%A1%AC%E4%BB%B6%E6%B5%8B%E8%AF%95&spm=1001.2101.3001.7020 "硬件测试")效果
-----------------------------------------------------------------------------------------------------------------

硬件ila测试结果如下：（完整代码运行后无水印）：

vio设置SNR=30db

vio设置SNR=15db

硬件测试操作步骤可参考程序配套的操作视频。

2.算法涉及理论知识概要
------------

随着通信技术的不断发展，相位调制技术因其高频谱效率和抗干扰能力而广泛应用于无线通信系统中。其中，8PSK（8相位相移键控）作为一种高阶调制方式，具有更高的频谱效率和更强的抗干扰能力，因此备受关注。然而，8PSK调制解调的实现复杂度较高，需要高效的数字信号处理技术。现场可编程门阵列（FPGA）作为一种可编程逻辑器件，具有高度的灵活性和并行处理能力，非常适合实现复杂的数字信号处理算法。

### 2.1 8PSK调制原理

8PSK调制是一种相位调制方式，其基本原理是通过改变载波的相位来传递信息。在8PSK中，一个符号周期内的相位变化有8种可能的状态，分别对应3个比特的信息。因此，8PSK调制可以看作是一种将3个比特映射到一个符号的映射方式。具体地，假设输入的比特序列为b2b1b0，则对应的8PSK符号可以表示为：

S(t)=Acos(2πfct+θk) （1）

其中，A是载波的振幅，fc是载波的频率，θk是第k个符号的相位，k=0,1,...,7。θk的取值由输入的比特序列b2b1b0决定，具体的映射关系如表1所示。

表1：8PSK映射关系

  

其星座图如下所示：

2.2 帧同步  
在数字通信中，信息通常是以帧为单位进行组织和传输的。帧同步的目的是确定每一帧的起始位置，以便接收端能够正确地解调出每帧中的数据。

设发送的帧结构为：帧同步码 + 信息码元序列 。帧同步码是具有特定规律的码序列，用于接收端识别帧的起始。

帧同步的过程就是在接收序列中寻找与帧同步码匹配的位置，一旦找到匹配位置，就确定了帧的起始位置，后续的码元就可以按照帧结构进行正确的划分和处理。

3.Verilog核心程序
-------------

\`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2024/11/04 19:54:30
// Design Name: 
// Module Name: tops\_hdw
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////
 
 
module tops\_hdw(
 
input i\_clk,
input i\_rst,
output reg \[3:0\] led
);
    
 
 
//产生模拟测试数据
wire o\_msg;
wire\[1:0\]o\_en;
signal signal\_u(
.i\_clk (i\_clk),
.i\_rst (~i\_rst),
.o\_bits(o\_msg),
.o\_en  (o\_en)
);
 
 
//设置SNR
wire signed\[7:0\]o\_SNR;
vio\_0 your\_instance\_name (
  .clk(i\_clk),                // input wire clk
  .probe\_out0(o\_SNR)  // output wire \[7 : 0\] probe\_out0
);
 
wire\[2:0\]o\_ISET;
wire signed\[15:0\]o\_I8psk;
wire signed\[15:0\]o\_Q8psk;
wire signed\[15:0\]o\_Ifir\_T;
wire signed\[15:0\]o\_Qfir\_T;
wire signed\[31:0\]o\_mod\_T;
wire signed\[15:0\]o\_Nmod\_T;
wire signed\[31:0\]o\_modc\_R;
wire signed\[31:0\]o\_mods\_R;
wire signed\[31:0\]o\_Ifir\_R;
wire signed\[31:0\]o\_Qfir\_R;
wire  \[2:0\]o\_wbits;
wire       o\_bits;
wire \[1:0\]o\_bits\_head;
wire \[7:0\]o\_peak;
wire  o\_en\_data;
wire  o\_en\_pn;
wire  o\_frame\_start;
wire signed\[31:0\]o\_error\_num;
wire signed\[31:0\]o\_total\_num;  
 
TOPS\_8PSK TOPS\_8PSK\_u(
.i\_clk  (i\_clk),
.i\_rst  (~i\_rst),
.i\_SNR  (o\_SNR),
.i\_en   (o\_en),
.i\_dat  (o\_msg),
.o\_ISET (o\_ISET),
.o\_I8psk(o\_I8psk),
.o\_Q8psk(o\_Q8psk),
.o\_Ifir\_T (o\_Ifir\_T),
.o\_Qfir\_T (o\_Qfir\_T),
.o\_mod\_T  (o\_mod\_T),
.o\_Nmod\_T(o\_Nmod\_T),
.o\_modc\_R (o\_modc\_R),
.o\_mods\_R (o\_mods\_R),
.o\_Ifir\_R (o\_Ifir\_R),
.o\_Qfir\_R (o\_Qfir\_R),
.o\_wbits(o\_wbits),
.o\_bits (o\_bits),
.o\_bits\_head(o\_bits\_head),
.o\_peak(o\_peak),
.o\_en\_data(o\_en\_data),
.o\_en\_pn(o\_en\_pn),
.o\_frame\_start(o\_frame\_start),
.o\_error\_num(o\_error\_num),
.o\_total\_num(o\_total\_num)
);
 
 
 
 
 
//ila篇内测试分析模块140
//ila篇内测试分析模块140
ila\_0 ila\_u (
	.clk(i\_clk), // input wire clk
	.probe0({ 
	        o\_msg,o\_SNR,o\_I8psk\[15:6\],o\_Q8psk\[15:6\],//30
	        o\_Nmod\_T,o\_Ifir\_R\[27:14\],o\_Qfir\_R\[27:14\],o\_wbits,//48
	        o\_error\_num\[15:0\],o\_total\_num\[23:0\],//40
	        //28
            o\_en\_pn,
            o\_en\_data,
            o\_peak,
            o\_bits\_head,
            o\_bits
	         })
	);	
 
endmodule
0sj2\_065m

4.开发板使用说明和如何移植不同的开发板
--------------------

注意：硬件片内测试是指发射接收均在一个板子内完成，因此不需要定时同步模块。

在本课题中，使用的[开发板](https://so.csdn.net/so/search?q=%E5%BC%80%E5%8F%91%E6%9D%BF&spm=1001.2101.3001.7020 "开发板")是：

如果你的开发板和我的不一样，可以参考代码包中的程序移植方法进行移植。

5.完整算法代码文件获得
------------

V