---
layout: post
title: '编写一个Buildroot 内核驱动'
date: "2026-01-19T00:50:08Z"
---
编写一个Buildroot 内核驱动
==================

编写一个Buildroot 内核驱动
==================

> PS:内核驱动只能在**/kernel/drivers/**目录下

![image-20260117082757215](https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173751023-892940144.png)

Makefile文件的编写
-------------

> 主要注意Makefile文件的编写（路径，包含）
> 
> 在该路径下先新建一个用户内核驱动文件夹，用于存放用户编写的驱动
> 
> **user\_rk3566\_-kernel-driver**
> 
> 进入该文件夹，新建一个02序号用户驱动文件夹，用于存放02驱动
> 
> **02\_kernel\_helloworld**
> 
> 编写kernel/drivers/user\_rk3566\_-kernel-driver/02\_kernel\_helloworld路径下的Makefile（添加驱动源文件**02\_kernel\_helloworld.c**进编译）
> 
>     vim Makefile
>     
> 
> Makefile：
> 
>     #obj-y :内核驱动
>     #obj-m :模块驱动
>     obj-y += 02_hello_world.o
>     
> 
> 返回到**kernel/drivers/user\_rk3566\_-kernel-driver**路径，添加Makefile（添加驱动源文件的文件夹**02\_kernel\_helloworld/**进编译）
> 
> Makefile：
> 
>     #添加驱动文件所在文件夹进编译，需要带“/”符号，表示目录（文件夹）
>     obj-y += 02_kernel_helloworld/
>     
> 
> 返回到**kernel/drivers**路径，添加Makefile（添加驱动源文件的文件夹user\_rk3566\_-kernel-driver/进编译）
> 
> Makefile：
> 
>     obj-y +=/user_rk3566_-kernel-driver/
>     
> 
> 随便找个地方，把文件夹路径丢进去

![image-20260118171936747](https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173754308-308553245.png)

> OK,由于SDK路径的Makefile文件已经将kernel/drivers路径添加，我们就不需要自己手动添加
> 
> 以上就是所需要添加的Makefile文件。
> 
> 主要目的是告诉make工具在**kernel/drivers/user\_rk3566\_-kernel-driver/02\_kernel\_helloworld**路径下是我们的驱动源代码**02\_kernel\_helloworld.c**，需要添加进编译

驱动文件编写
------

> 进入该02\_kernel\_helloworld，开始驱动编写
> 
>     vim 02_hello_world.c 
>     
> 
> 02\_hello\_world.c
> 
>     #include <linux/module.h>     /* 模块相关宏和函数 */
>     #include <linux/kernel.h>     /* printk日志函数 */
>     
>     /* 加载函数（驱动入口），当驱动被 insmod 加载时自动执行 */
>     static int __init helloworld_init(void)
>     {
>         printk("02_helloworld_init\r\n"); // 内核日志打印
>         return 0; // 返回0代表加载成功
>     }
>     
>     /* 卸载函数（驱动出口），当驱动被 rmmod 卸载时自动执行 */
>     static void __exit helloworld_exit(void)
>     {
>         printk("02_helloworld_exit\r\n");
>     }
>     
>     /* 下面这两行，告诉内核入口和出口分别是哪两个函数 */
>     module_init(helloworld_init);
>     module_exit(helloworld_exit);
>     
>     /* 这3个是模块信息声明 */
>     MODULE_LICENSE("GPL v2");               /* 模块许可证 */
>     
>     

编译
--

我们需要返回到kernel内核文件夹的上一个路径

在我这是SDK/，这里包含了编译脚本，须在这里运行编译命令

    ./build.sh kernel
    

![image-20260118172404378](https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173751745-1600325666.png)

编译成功

![image-20260118172442489](https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173752421-1683639729.png)

返回源代码路径查看编译文件（可选）

![image-20260118163216910](https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173752940-2085711302.png)

可以看到，内核驱动编译后，不会像模块驱动那样生成**.ko**文件

实际，驱动相关的内容已经编译进内核镜像中（root.img）

![image-20260118172723586](https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173753283-1927509773.png)

运行
--

将该镜像烧录，等板子运行后查看日志

    dmesg | grep -E hello
    

![image-20260118173111518](https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173753691-118600053.png)

可以看到驱动上电后自动运行，这就是和模块驱动的一个显著区别，不需要手动挂载

修改完后，git提交一下代码更改（可选）

    git add .
    git commit -m"修改说明"
    git pull
    git push