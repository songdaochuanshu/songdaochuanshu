---
layout: post
title: 'ã€URPã€‘Unity[è§†å·®è´´å›¾]æ¨¡æ‹Ÿ[é£æ ¼åŒ–åœ°å½¢]å®è·µ'
date: "2025-10-26T00:43:58Z"
---
ã€URPã€‘Unity\[è§†å·®è´´å›¾\]æ¨¡æ‹Ÿ\[é£æ ¼åŒ–åœ°å½¢\]å®è·µ
===============================

![ã€URPã€‘Unity[è§†å·®è´´å›¾]æ¨¡æ‹Ÿ[é£æ ¼åŒ–åœ°å½¢]å®è·µ](https://img2024.cnblogs.com/blog/3685400/202510/3685400-20251025013342157-1628314864.png) é™¡å³­è§†å·®è´´å›¾(Steep Parallax Mapping)å®ç°åŸç† é™¡å³­è§†å·®è´´å›¾é€šè¿‡â€Œåˆ†å±‚æ·±åº¦æ¯”è¾ƒâ€Œå’Œâ€ŒåŠ¨æ€UVåç§»â€ŒæŠ€æœ¯å¢å¼ºå²©çŸ³è¡¨é¢ç«‹ä½“æ„Ÿ. â€Œè§†è§’è‡ªé€‚åº”åˆ†å±‚é‡‡æ ·â€Œ æ ¹æ®è§†çº¿ä¸è¡¨é¢æ³•çº¿çš„å¤¹è§’åŠ¨æ€åˆ†

> [ã€ä»UnityURPå¼€å§‹æ¢ç´¢æ¸¸æˆæ¸²æŸ“ã€‘](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**ä¸“æ -ç›´è¾¾**

**é™¡å³­è§†å·®è´´å›¾(Steep Parallax Mapping)å®ç°åŸç†**
======================================

é™¡å³­è§†å·®è´´å›¾é€šè¿‡â€Œ**åˆ†å±‚æ·±åº¦æ¯”è¾ƒ**â€Œå’Œâ€Œ**åŠ¨æ€UVåç§»**â€ŒæŠ€æœ¯å¢å¼ºå²©çŸ³è¡¨é¢ç«‹ä½“æ„Ÿ.

â€Œ**è§†è§’è‡ªé€‚åº”åˆ†å±‚é‡‡æ ·**â€Œ
---------------

*   æ ¹æ®è§†çº¿ä¸è¡¨é¢æ³•çº¿çš„å¤¹è§’åŠ¨æ€åˆ†é…é‡‡æ ·å±‚æ•°ï¼ˆå¹³è§†è§†è§’å¢åŠ è‡³12å±‚ï¼Œä¿¯è§†è§†è§’å‡å°‘è‡³5å±‚ï¼‰ï¼Œè§£å†³æ ‡å‡†è§†å·®è´´å›¾åœ¨å¹³è§†è§’åº¦ä¸‹çš„å¤±çœŸé—®é¢˜

â€Œ**æ·±åº¦å›¾æ¢¯åº¦ä¿®æ­£**â€Œ
-------------

*   å¼•å…¥`_LayerBias`å‚æ•°ï¼ˆæ¨èå€¼0.2-0.4ï¼‰è°ƒæ•´UVåç§»é‡è®¡ç®—å…¬å¼ï¼Œé¿å…é™¡å³­åŒºåŸŸå‡ºç°é‡‡æ ·æ–­è£‚ï¼š

$\\Delta UV=\\frac{ParallaxScale \\cdot ViewDir\_{xy}}{(ViewDir\_z+LayerBias) \\cdot LayerCount}$

â€Œ**é£æ ¼åŒ–æ·±åº¦å¢å¼º**â€Œ
-------------

*   åœ¨æœ€ç»ˆæ’å€¼é˜¶æ®µä½¿ç”¨`pow(weight,2)`å¼ºåŒ–è½®å»“å¯¹æ¯”åº¦ï¼Œé…åˆrampè´´å›¾å®ç°å¡é€šåŒ–å…‰å½±è¿‡æ¸¡æ•ˆæœ

* * *

**URP HLSLå®Œæ•´å®ç°ä»£ç **
==================

**å…³é”®ç‰¹æ€§è¯´æ˜**
----------

*   â€Œ**åŠ¨æ€å±‚æ•°ä¼˜åŒ–**â€Œï¼šé€šè¿‡`lerp(_MaxLayers, _MinLayers, saturate(dot(float3(0,0,1), viewDirTS)))`å®ç°å¹³è§†è§†è§’è‡ªåŠ¨å¢åŠ é‡‡æ ·ç²¾åº¦
    
*   â€Œ**æŠ—å¤±çœŸå¤„ç†**â€Œï¼š`_LayerBias`å‚æ•°ä¿®æ­£é™¡å³­è¡¨é¢çš„UVåç§»è®¡ç®—ï¼Œé¿å…é‡‡æ ·æ–­è£‚
    
*   â€Œ**é£æ ¼åŒ–å¢å¼º**â€Œï¼šrampè´´å›¾æ§åˆ¶å…‰å½±è¿‡æ¸¡ï¼Œè¾¹ç¼˜å…‰å¼ºåŒ–è½®å»“ç«‹ä½“æ„Ÿ
    
*   StylizedRockParallax.shader
    
        Shader "Universal Render Pipeline/StylizedRockParallax"
        {
            Properties
            {
                [Header(Base Textures)]
                _MainTex("Albedo (RGB)", 2D) = "white" {}
                _NormalMap("Normal Map", 2D) = "bump" {}
                _HeightMap("Height Map", 2D) = "white" {}
                _RampTex("Stylized Ramp", 2D) = "white" {}
        
                [Header(Parallax Settings)]
                _ParallaxScale("Depth Scale", Range(0, 0.15)) = 0.08
                _LayerBias("Layer Bias", Range(0.1, 0.5)) = 0.3
                _MinLayers("Min Layers", Int) = 5
                _MaxLayers("Max Layers", Int) = 12
        
                [Header(Stylized Lighting)]
                _RimPower("Rim Power", Range(1, 10)) = 3
                _ShadowTint("Shadow Tint", Color) = (0.3,0.3,0.4,1)
            }
        
            SubShader
            {
                Tags { "RenderType"="Opaque" "RenderPipeline"="UniversalPipeline" }
        
                HLSLINCLUDE
                #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
                #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
        
                TEXTURE2D(_MainTex);    SAMPLER(sampler_MainTex);
                TEXTURE2D(_NormalMap);  SAMPLER(sampler_NormalMap);
                TEXTURE2D(_HeightMap);  SAMPLER(sampler_HeightMap);
                TEXTURE2D(_RampTex);    SAMPLER(sampler_RampTex);
        
                float _ParallaxScale;
                float _LayerBias;
                int _MinLayers, _MaxLayers;
                float _RimPower;
                float4 _ShadowTint;
        
                // é™¡å³­è§†å·®æ˜ å°„æ ¸å¿ƒç®—æ³•
                float2 SteepParallaxMapping(float3 viewDirTS, float2 uv)
                {
                    // åŠ¨æ€å±‚æ•°è®¡ç®—ï¼ˆå¹³è§†è§†è§’å¢åŠ å±‚æ•°ï¼‰
                    int numLayers = (int)lerp(_MaxLayers, _MinLayers, saturate(dot(float3(0,0,1), viewDirTS)));
                    float layerHeight = 1.0 / numLayers;
                    float2 deltaUV = _ParallaxScale * viewDirTS.xy / (viewDirTS.z + _LayerBias) / numLayers;
        
                    // å…‰çº¿æ­¥è¿›åˆå§‹åŒ–
                    float currentLayerHeight = 0;
                    float2 currentUV = uv;
                    float currentDepth = 1 - SAMPLE_TEXTURE2D(_HeightMap, sampler_HeightMap, currentUV).r;
        
                    // åˆ†å±‚æ·±åº¦æ£€æµ‹
                    [loop]
                    for (int i = 0; i < _MaxLayers; ++i) {
                        if (currentLayerHeight >= currentDepth) break;
                        currentUV -= deltaUV;
                        currentDepth = 1 - SAMPLE_TEXTURE2D(_HeightMap, sampler_HeightMap, currentUV).r;
                        currentLayerHeight += layerHeight;
                    }
        
                    // é£æ ¼åŒ–æ’å€¼ä¿®æ­£
                    float2 prevUV = currentUV + deltaUV;
                    float prevDepth = currentDepth - layerHeight;
                    float weight = pow((currentLayerHeight - currentDepth) / (prevDepth - currentDepth + 0.001), 2);
                    return lerp(currentUV, prevUV, saturate(weight * 1.5));
                }
        
                // é£æ ¼åŒ–å…‰ç…§è®¡ç®—
                half3 StylizedShading(float3 normalWS, float3 viewDirWS, float NdotL)
                {
                    float rim = pow(1 - saturate(dot(normalWS, viewDirWS)), _RimPower);
                    float2 rampUV = float2(NdotL * 0.5 + 0.5, 0.5);
                    half3 rampColor = SAMPLE_TEXTURE2D(_RampTex, sampler_RampTex, rampUV).rgb;
                    return lerp(rampColor * _ShadowTint.rgb, rampColor, saturate(NdotL + rim));
                }
                ENDHLSL
        
                Pass
                {
                    HLSLPROGRAM
                    #pragma vertex vert
                    #pragma fragment frag
        
                    struct Attributes
                    {
                        float4 positionOS : POSITION;
                        float2 uv : TEXCOORD0;
                        float3 normalOS : NORMAL;
                        float4 tangentOS : TANGENT;
                    };
        
                    struct Varyings
                    {
                        float4 positionCS : SV_POSITION;
                        float2 uv : TEXCOORD0;
                        float3 viewDirTS : TEXCOORD1;
                        float3 normalWS : TEXCOORD2;
                        float3 viewDirWS : TEXCOORD3;
                        float4 shadowCoord : TEXCOORD4;
                    };
        
                    Varyings vert(Attributes IN)
                    {
                        Varyings OUT;
                        VertexPositionInputs posInput = GetVertexPositionInputs(IN.positionOS.xyz);
                        OUT.positionCS = posInput.positionCS;
        
                        VertexNormalInputs normInput = GetVertexNormalInputs(IN.normalOS, IN.tangentOS);
                        float3 viewDirWS = GetWorldSpaceViewDir(posInput.positionWS);
                        OUT.viewDirTS = TransformWorldToTangent(viewDirWS, 
                            normInput.tangentWS, normInput.bitangentWS, normInput.normalWS);
                        OUT.normalWS = normInput.normalWS;
                        OUT.viewDirWS = viewDirWS;
                        OUT.shadowCoord = GetShadowCoord(posInput);
                        OUT.uv = IN.uv;
                        return OUT;
                    }
        
                    half4 frag(Varyings IN) : SV_Target
                    {
                        // è®¡ç®—é™¡å³­è§†å·®UV
                        float2 parallaxUV = SteepParallaxMapping(normalize(IN.viewDirTS), IN.uv);
        
                        // é‡‡æ ·çº¹ç†
                        half4 albedo = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, parallaxUV);
                        half3 normalTS = UnpackNormal(SAMPLE_TEXTURE2D(_NormalMap, sampler_NormalMap, parallaxUV));
        
                        // è½¬æ¢æ³•çº¿åˆ°ä¸–ç•Œç©ºé—´
                        float3x3 TBN = float3x3(
                            normalize(cross(IN.normalWS, IN.viewDirWS)),
                            normalize(IN.normalWS),
                            normalize(IN.viewDirWS)
                        );
                        float3 normalWS = mul(TBN, normalTS);
        
                        // å…‰ç…§è®¡ç®—
                        Light mainLight = GetMainLight(IN.shadowCoord);
                        float NdotL = saturate(dot(normalWS, mainLight.direction));
                        half3 lighting = StylizedShading(normalWS, normalize(IN.viewDirWS), NdotL);
        
                        return half4(albedo.rgb * lighting * mainLight.color, 1);
                    }
                    ENDHLSL
                }
            }
        }
        
    

**æè´¨é…ç½®**
========

å‚æ•°ç»„åˆ

é£æ ¼åŒ–æ•ˆæœ

`_ParallaxScale=0.05` + `_RimPower=5`

è½»åº¦å‡¹å‡¸+æŸ”å’Œè¾¹ç¼˜å…‰

`_ParallaxScale=0.1` + `_LayerBias=0.4`

å¼ºçƒˆå‡¹å‡¸+æŠ—å¤±çœŸå¤„ç†

`_ShadowTint=(0.4,0.2,0.6)`

ç´«è‰²è°ƒé˜´å½±å¢å¼ºé£æ ¼åŒ–è¡¨ç°

* * *

> [ã€ä»UnityURPå¼€å§‹æ¢ç´¢æ¸¸æˆæ¸²æŸ“ã€‘](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**ä¸“æ -ç›´è¾¾**  
> ï¼ˆæ¬¢è¿_ç‚¹èµç•™è¨€_æ¢è®¨ï¼Œæ›´å¤šäººåŠ å…¥è¿›æ¥èƒ½æ›´åŠ å®Œå–„è¿™ä¸ªæ¢ç´¢çš„è¿‡ç¨‹ï¼ŒğŸ™ï¼‰