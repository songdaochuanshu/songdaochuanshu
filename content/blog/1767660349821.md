---
layout: post
title: '一文入门 Spring Security with 单点登录(jasig)'
date: "2026-01-06T00:45:49Z"
---
一文入门 Spring Security with 单点登录(jasig)
=====================================

2018-6-18

\[\[后端栈/Java SE/Java\]\]

Spring Security 是什么?
====================

人们使用Spring Secruity的原因有很多, 单大部分都发现了javaEE的Servlet规范或EJB规范中的安全功能缺乏典型企业应用场景所需的深度;  
提到这些规范, 重要的是要认识到他们在WAR或EAR级别无法移植; 因此如果你更换服务器环境, 这里有典型的大量工作去重新配置你的应用程序员安全到新的目标环境; 使用Spring Security 解决了这些问题, 也为你提供许多其他有用的, 可定制的安全功能;

正如你可能知道的两个应用程序的两个主要区域是"认证"和"授权"（或者访问控制）; 这两个主要区域是Spring Security 的两个目标; "认证", 是建立一个他声明的主题的过程（一个"主体"一般是指用户, 设备或一些可以在你的应用程序中执行动作的其他系统）; "授权"指确定一个主体是否允许在你的应用程序执行一个动作的过程; 为了抵达需要授权的店, 主体的身份已经有认证过程建立; 这个概念是通用的而不只在Spring Security中;

> 参考: [中文文档](https://springcloud.cc/spring-security-zhcn.html#what-is-acegi-security)  
> [英文文档 4.2](https://docs.spring.io/spring-security/site/docs/4.2.7.RELEASE/reference/htmlsingle/#what-is-acegi-security)

Spring 3.X MVC + Security
=========================

copy of xxx 的一些jar包的版本  
spring core = 3.0.5  
spring security core = 3.0.5  
spring web = 3.0.5

For maven
---------

Maven项目 如果tomcat不加载maven lib, 右键项目 `Web Deployment Assembly`加进去

完整配置.

     <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    
    <modelVersion>4.0.0</modelVersion>
    <groupId>myproject</groupId>
    <artifactId>springsecurity</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>war</packaging>
    <name>springsecurity</name>
    
    <dependencies>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-web -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
            <version>3.0.5.RELEASE</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>3.0.5.RELEASE</version>
        </dependency>
        <!-- spring security -->
       <dependency>
             <groupId>org.springframework.security</groupId>
             <artifactId>spring-security-core</artifactId>
             <version>3.0.5.RELEASE</version>
         </dependency>
         <dependency>
             <groupId>org.springframework.security</groupId>
             <artifactId>spring-security-web</artifactId>
             <version>3.0.5.RELEASE</version>
         </dependency>
         <dependency>
             <groupId>org.springframework.security</groupId>
             <artifactId>spring-security-config</artifactId>
             <version>3.0.5.RELEASE</version>
         </dependency>
         <dependency>
             <groupId>org.springframework.security</groupId>
             <artifactId>spring-security-taglibs</artifactId>
             <version>3.0.5.RELEASE</version>
         </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.1</version>
                <configuration>
                    <source>1.7</source>
                    <target>1.7</target>
                </configuration>
            </plugin>
            <plugin>
                <artifactId>maven-war-plugin</artifactId>
                <version>2.4</version>
                <configuration>
                    <warSourceDirectory>webapp</warSourceDirectory>
                </configuration>
            </plugin>
        </plugins>
    </build>
    
    </project>
    

*   写一个控制器

    @Controller
    @RequestMapping("/user")
    public class UserController {
        
        
        @RequestMapping(value = "/login")
        public ModelAndView login() {
            System.out.println("login");
            ModelAndView model = new ModelAndView();
            model.addObject("title", "login");
            model.addObject("message", "This is hello page!");
            model.setViewName("login");
            
            return model;
    
        }
        
        
        @RequestMapping(value = { "/", "/welcome" }, method = RequestMethod.GET)
        public ModelAndView welcomePage() {
            System.out.println("welcomePage");
            ModelAndView model = new ModelAndView();
            model.addObject("title", "Spring  Hello World");
            model.addObject("message", "This is welcome page!");
            model.setViewName("hello");
            
            return model;
        }
        @RequestMapping(value = "/admin", method = RequestMethod.GET)
        public ModelAndView adminPage() {
            System.out.println("adminPage");
            ModelAndView model = new ModelAndView();
            model.addObject("title", "Spring  Hello World");
            model.addObject("message", "This is protected page!");
            model.setViewName("admin");
            
            return model;
    
        }
    }
    
    

> 两个公开页面hello 不需要限制, 而admin 需要限制访问

*   在web.xml增加spring Security过滤器

    <filter>
        <filter-name>springSecurityFilterChain</filter-name>
        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>springSecurityFilterChain</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    

*   spring Security配置  
    在spring-mvc.xml引入命名空间(xmlns:security), 一般而言都是单独一个`applicationContext-security.xml`文件, 在初始spring ioc的时候引入

    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml,classpath:applicationContext-security.xml</param-value>
    </context-param>
    

*   spring Security的简单配置

    省略..头部.
    <security:http auto-config="true">
        <security:form-login login-page="/login.jsp" default-target-url="/springsecurity/user/admin.htm" />
        <!-- 表示匿名用户可以访问 -->
        <security:intercept-url pattern="/login.jsp" access="IS_AUTHENTICATED_ANONYMOUSLY"/>
        <security:intercept-url pattern="/user/welcome*" access="IS_AUTHENTICATED_ANONYMOUSLY"/>
        <!-- 访问下面URL需要 ROLE_USER 权限 -->
        <security:intercept-url pattern="/**" access="ROLE_USER" />
    </security:http>
    <security:authentication-manager>
        <security:authentication-provider>
            <security:user-service>
                <security:user name="user" password="user" authorities="ROLE_USER"/>
                <security:user name="admin" password="admin" authorities="ROLE_USER, ROLE_ADMIN"/>
            </security:user-service>
        </security:authentication-provider>
    </security:authentication-manager>
    
    </beans> 
    

测试
--

*   访问任何一个能被springSecurityFilterChain拦截的url 即可看到登陆页面

> 使用上`<security:user-service>`元素配置的用户名跟密码即可登陆  
> 登陆后 访问`<a href="../j_spring_security_logout" /> Logout</a>`退出

认证过程
====

Spring Security, 这是一种基于 Spring AOP 和 Servlet 过滤器的安全框架;

Spring Security的核心类主要包括以下几个：  
`SecurityContextHolder`: 存放身份信息的容器  
`Authentication`: 身份信息的抽象接口  
`AuthenticationManager` : 身份认证器，认证的核心接口  
`UserDetailsService` ： 一般用于从数据库中加载身份信息  
`UserDetails` : 相比 Authentication，有更详细的身份信息

1.  用户使用用户名和密码进行登录;
2.  Spring Security 将获取到的用户名和密码封装成一个实现了 Authentication 接口的 `UsernamePasswordAuthenticationToken;`
3.  将上述产生的 token 对象传递给 `AuthenticationManager` 进行登录认证;
4.  `AuthenticationManager` 认证成功后将会返回一个封装了用户权限等信息的 Authentication 对象;
5.  通过调用 `SecurityContextHolder.getContext().setAuthentication(...)` 将 `AuthenticationManager` 返回的 `Authentication` 对象赋予给当前的 SecurityContext;

成功与失败的额外处理
==========

*   form-login 元素的 authentication-success-handler-ref 对应一个 `AuthencticationSuccessHandler` 实现类的引用;
    
    *   如果指定了 authentication-success-handler-ref, 登录认证成功后会调用指定 `AuthenticationSuccessHandler` 的 `onAuthenticationSuccess` 方法; 我们需要在该方法体内对认证成功做一个处理, 然后返回对应的认证成功页面; 使用了 之前的那些 default-target-url 之类的就都不起作用了
*   同样通过 form-login 元素的authentication-failure-url 来指定登录失败后的页面(对应`AuthenticationFailureHandler` 接口)
    
    *   需要注意的是登录失败后的页面跟登录页面一样也是需要配置成在未登录的情况下可以访问, 否则登录失败后请求失败页面时又会被 Spring Security 重定向到登录页面;

    ..掐头..
          <!-- ...handler-ref 认证 成功 失败的处理器 --> 
          <security:form-login login-page="/login.jsp" default-target-url="/springsecurity/user/admin.htm"
            authentication-success-handler-ref="authSuccessHandler"
           authentication-failure-handler-ref ="authFailureHandler" />
          <!-- 表示匿名用户可以访问 -->
          <security:intercept-url pattern="/login.jsp" access="IS_AUTHENTICATED_ANONYMOUSLY"/>
          <security:intercept-url pattern="/user/welcome*" access="IS_AUTHENTICATED_ANONYMOUSLY"/>
           <!-- 访问下面URL需要 ROLE_USER 权限 -->
          <security:intercept-url pattern="/**" access="ROLE_USER" />
          <!-- 指定退出登陆后的重定向url-->
          <security:logout logout-success-url="/login.jsp" />
       </security:http>
       
        <!-- 认证成功的 处理bean -->
       <bean id="authSuccessHandler" class="net.bean.AuthenticationSuccessHandlerImpl" />
       <!-- 认证失败的 处理bean -->
       <bean id="authFailureHandler" class="net.bean.AuthenticationFailureHandlerImpl" />
    ..去尾..
    

> 参考: [https://www.w3cschool.cn/springsecurity/4lwn1ihz.html](https://www.w3cschool.cn/springsecurity/4lwn1ihz.html)

退出登录 logout
===========

*   在 http 元素下定义**logout** 元素
    
    *   这样 Spring Security 将自动为我们添加用于处理退出登录的过滤器 `LogoutFilter` 到FilterChain;
    *   当我们指定了 http 元素的 auto-config 属性为 true 时**logout** 定义是会自动配置的, 此时我们默认退出登录的 URL 为 "/j\_spring\_security\_logout", 可以通过 logout 元素的 logout-url 属性来改变退出登录的默认地址;

> 参考: [https://www.w3cschool.cn/springsecurity/g86w1iig.html](https://www.w3cschool.cn/springsecurity/g86w1iig.html)

  
  

* * *

  
  

细谈认证过程
======

完整过程图

1.SpringSecurityFilterChain
---------------------------

首先客户端一个请求到达 Spring Security 的入口过滤器是: SecurityContextPersistenceFilter (默认实现是: `org.springframework.security.web.DefaultSecurityFilterChain`)  
它其实是一个代理维持着多个`FilterChain`, 这些过滤器, 过滤链都是被spring容器管理着,可以非常方便热插拔.

关于FilterChain 见:**DelegatingFilterProxy 简介**

2.UsernamePasswordAuthenticationFilter
--------------------------------------

如果未登陆,如 `UsernamePasswordAuthenticationFilter, CasAuthenticationFilter`..过滤器负责获取到的用户名和密码封装成一个实现了Authentication接口的 UsernamePasswordAuthenticationToken;

> 见`org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter` 源码, 85行

    public Authentication attemptAuthentication(HttpServletRequest request,
            HttpServletResponse response) throws AuthenticationException {
        if (postOnly && !request.getMethod().equals("POST")) {
            throw new AuthenticationServiceException(
                    "Authentication method not supported: " + request.getMethod());
        }
        //获取用户名密码
        String username = obtainUsername(request);
        String password = obtainPassword(request);
    
        if (username == null) {
            username = "";
        }
    
        if (password == null) {
            password = "";
        }
    
        username = username.trim();
        //封装 UsernamePasswordAuthenticationToken; 
        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(
                username, password);
    
        // Allow subclasses to set the "details" property
        setDetails(request, authRequest);
        //使用 AuthenticationManager 认证
        return this.getAuthenticationManager().authenticate(authRequest);
    }
    

3.Authentication
----------------

将上述产生的 token 对象传递给 AuthenticationManager 进行登录认证;

4.AuthenticationManager
-----------------------

`AuthenticationManager`并不认证,而是调用AuthenticationProvider的列表认证

> 见`org.springframework.security.authentication.ProviderManager::doAuthentication`源码

5.AuthenticationProvider
------------------------

`AuthenticationProvider` 接口的`public abstract Authentication authenticate(Authentication paramAuthentication) throws AuthenticationException;`方法是真正在处理认证逻辑的地方

> 它持有一个`UserDetailsService`,用于加载用户信息,**简而言之,改变认证,实现 AuthenticationProvider, 改变信息来源, 实现UserDetailsService即可**

> 认证成功: 后会补充Authentication详细的角色权限等 返回给AuthenticationManager

> 认证失败: 抛出`AuthenticationException`

> 未知: 返回`null`,这将交给下一个Provider认证

> 还有一点 xml 配置`<authentication-provider>` 会默认实例化一个`DaoAuthenticationProvider`加入到认证流程中,它持有`PasswordEncoder`加密是在这一步. xml配置 在`authentication-provider`的节点下 `password-encoder`

    <authentication-provider user-service-ref="userDetailsService" >
        <password-encoder hash="md5">
            <!-- <salt-source user-property="username"/>  无盐-->
        </password-encoder>
    </authentication-provider>
    

> 见`org.springframework.security.authentication.ProviderManager::doAuthentication`源码

1.  在`AuthenticationManager`中, 只要有一个Provider认证成功, 就不会再继续做更多验证, 将返回的Authentication对象赋予给当前的SecurityContext;

*   如果全部认证失败, 抛出`AuthenticationException`异常, 这会被`ExceptionTransactionFilter` Catch 到并返回一个失败页面

> 见`org.springframework.security.authentication.ProviderManager::doAuthentication`源码

6.ExceptionTranslationFilter
----------------------------

认证异常处理

`org.springframework.security.web.access.ExceptionTranslationFilter`

    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
    			throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;
    
        try {
            chain.doFilter(request, response);
    
            logger.debug("Chain processed normally");
        }
        catch (IOException ex) {
            throw ex;
        }
        catch (Exception ex) {
            //catch 所有异常
            // Try to extract a SpringSecurityException from the stacktrace
            Throwable[] causeChain = throwableAnalyzer.determineCauseChain(ex);
            // 拿到异常类型
            RuntimeException ase = (AuthenticationException) throwableAnalyzer
                    .getFirstThrowableOfType(AuthenticationException.class, causeChain);
    
            if (ase == null) {
                ase = (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(
                        AccessDeniedException.class, causeChain);
            }
    
            if (ase != null) {
                if (response.isCommitted()) {
                    throw new ServletException("Unable to handle the Spring Security Exception because the response is already committed.", ex);
                }
                //处理 security 类型异常/ 即: org.springframework.security.access.AccessDeniedException 和 org.springframework.security.core.AuthenticationException;
                handleSpringSecurityException(request, response, chain, ase);
            }
            else {
                // Rethrow ServletExceptions and RuntimeExceptions as-is
                if (ex instanceof ServletException) {
                    throw (ServletException) ex;
                }
                else if (ex instanceof RuntimeException) {
                    throw (RuntimeException) ex;
                }
    
                // Wrap other Exceptions. This shouldn't actually happen
                // as we've already covered all the possibilities for doFilter
                throw new RuntimeException(ex);
            }
        }
    }
    
    
    private void handleSpringSecurityException(HttpServletRequest request,
            HttpServletResponse response, FilterChain chain, RuntimeException exception)
            throws IOException, ServletException {
        if (exception instanceof AuthenticationException) {
            logger.debug(
                    "Authentication exception occurred; redirecting to authentication entry point",
                    exception);
    
            sendStartAuthentication(request, response, chain,
                    (AuthenticationException) exception);
        }
        else if (exception instanceof AccessDeniedException) {
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            if (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) {
                logger.debug(
                        "Access is denied (user is " + (authenticationTrustResolver.isAnonymous(authentication) ? "anonymous": "not fully authenticated") + "); redirecting to authentication entry point",
                        exception);
    
                sendStartAuthentication(
                        request,
                        response,
                        chain,
                        new InsufficientAuthenticationException(
                            messages.getMessage(
                                "ExceptionTranslationFilter.insufficientAuthentication",
                                "Full authentication is required to access this resource")));
            }
            else {
                logger.debug(
                        "Access is denied (user is not anonymous); delegating to AccessDeniedHandler",
                        exception);
    
                accessDeniedHandler.handle(request, response,
                        (AccessDeniedException) exception);
            }
        }
    }
    
    
    

  
  

Tomcat 过滤链的生成
=============

在tomcat 源码

org.apache.catalina.core.StandardWrapperValve
---------------------------------------------

    
     @Override
    public final void invoke(Request request, Response response)
        throws IOException, ServletException {
        ....
    
        MessageBytes requestPathMB = request.getRequestPathMB();
        DispatcherType dispatcherType = DispatcherType.REQUEST;
        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;
        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,
                requestPathMB);
        // Create the filter chain for this request// 这个ApplicationFilterChain 实现了 FilterChain
        ApplicationFilterChain filterChain =
                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);
    

关键在:

org.apache.catalina.core.ApplicationFilterFactory::createFilterChain
--------------------------------------------------------------------

    public static ApplicationFilterChain createFilterChain(ServletRequest request,
                Wrapper wrapper, Servlet servlet) {
    
            // If there is no servlet to execute, return null
            if (servlet == null)
                return null;
    
            // Create and initialize a filter chain object
            ApplicationFilterChain filterChain = null;
            if (request instanceof Request) {
                Request req = (Request) request;
                if (Globals.IS_SECURITY_ENABLED) {
                    // Security: Do not recycle
                    filterChain = new ApplicationFilterChain();
                } else {
                    filterChain = (ApplicationFilterChain) req.getFilterChain();
                    if (filterChain == null) {
                        filterChain = new ApplicationFilterChain();
                        req.setFilterChain(filterChain);
                    }
                }
            } else {
                // Request dispatcher in use
                filterChain = new ApplicationFilterChain();
            }
    
            filterChain.setServlet(servlet);
            filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());
    
            // Acquire the filter mappings for this Context
            StandardContext context = (StandardContext) wrapper.getParent();
            FilterMap filterMaps[] = context.findFilterMaps();
    
            // If there are no filter mappings, we are done
            if ((filterMaps == null) || (filterMaps.length == 0))
                return filterChain;
    
            // Acquire the information we will need to match filter mappings
            DispatcherType dispatcher =
                    (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);
    
            String requestPath = null;
            Object attribute = request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);
            if (attribute != null){
                requestPath = attribute.toString();
            }
    
            String servletName = wrapper.getName();
    
            // Add the relevant path-mapped filters to this filter chain //关键是这个Map , 其中就有 springSecurityFilterChain
            for (FilterMap filterMap: filterMaps) {
                if (!matchDispatcher(filterMap, dispatcher)) {
                    continue;
                }
                if (!matchFiltersURL(filterMap, requestPath))
                    continue;
                ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)
                        context.findFilterConfig(filterMap.getFilterName());
                if (filterConfig == null) {
                    // FIXME - log configuration problem
                    continue;
                }
                filterChain.addFilter(filterConfig);
            }
    
            // Add filters that match on servlet name second
            for (FilterMap filterMap: filterMaps) {
                if (!matchDispatcher(filterMap, dispatcher)) {
                    continue;
                }
                if (!matchFiltersServlet(filterMap, servletName))
                    continue;
                ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)
                        context.findFilterConfig(filterMap.getFilterName());
                if (filterConfig == null) {
                    // FIXME - log configuration problem
                    continue;
                }
                filterChain.addFilter(filterConfig);
            }
    
            // Return the completed filter chain
            return filterChain;
        }
    

DelegatingFilterProxy 简介 & 与预定义的过滤器
===================================

Spring Security本质上是一连串的Filter, 然后又以一个独立的Filter的形式插入到Filter Chain里

实际上FilterChainProxy下面可以有多条Filter Chain, 来针对不同的URL做验证, 而Filter Chain中所拥有的Filter则会根据定义的服务自动增减; 所以无需要显示再定义这些Filter, 除非想要实现自己的逻辑;

可以往这个链加入, 例如: 验证码过滤器

Spring Security 已经定义了一些 Filter, 不管实际应用中你用到了哪些, 它们应当保持如下顺序;

1.  ChannelProcessingFilter, 如果你访问的 channel 错了, 那首先就会在 channel 之间进行跳转, 如 http 变为 https;
    
2.  `SecurityContextPersistenceFilter`, 在一开始进行 request 的时候就可以在 SecurityContextHolder 中建立一个 SecurityContext, 然后在请求结束的时候, 任何对 SecurityContext 的改变都可以被 copy 到 HttpSession;  
    **负责将 SecurityContextHolder 中的登陆用户信息 (默认保存在ThreadLocal) 加载到,SecurityContext`SecurityContextHolder.getContext()`!!**
    
3.  ConcurrentSessionFilter, 因为它需要使用 SecurityContextHolder 的功能, 而且更新对应 session 的最后更新时间, 以及通过 SessionRegistry 获取当前的 SessionInformation 以检查当前的 session 是否已经过期, 过期则会调用 LogoutHandler;
    
4.  认证处理机制, 如 UsernamePasswordAuthenticationFilter, CasAuthenticationFilter, BasicAuthenticationFilter 等, 以至于 SecurityContextHolder 可以被更新为包含一个有效的 Authentication 请求;
    
5.  SecurityContextHolderAwareRequestFilter, 它将会把 HttpServletRequest 封装成一个继承自 HttpServletRequestWrapper 的 SecurityContextHolderAwareRequestWrapper, 同时使用 SecurityContext 实现了 HttpServletRequest 中与安全相关的方法;
    
6.  JaasApiIntegrationFilter, 如果 SecurityContextHolder 中拥有的 Authentication 是一个 JaasAuthenticationToken, 那么该 Filter 将使用包含在 JaasAuthenticationToken 中的 Subject 继续执行 FilterChain;
    
7.  RememberMeAuthenticationFilter, 如果之前的认证处理机制没有更新 SecurityContextHolder, 并且用户请求包含了一个 Remember-Me 对应的 cookie, 那么一个对应的 Authentication 将会设给 SecurityContextHolder;
    
8.  AnonymousAuthenticationFilter, 如果之前的认证机制都没有更新 SecurityContextHolder 拥有的 Authentication, 那么一个 AnonymousAuthenticationToken 将会设给 SecurityContextHolder;
    
9.  ExceptionTransactionFilter, 用于处理在 FilterChain 范围内抛出的 AccessDeniedException 和 AuthenticationException, 并把它们转换为对应的 Http 错误码返回或者对应的页面;
    
10.  FilterSecurityInterceptor, 保护 Web URI, 并且在访问被拒绝时抛出异常;
     

> [参考: W3C 翻译的文档](https://www.w3cschool.cn/springsecurity/4j1s1iid.html)

过滤器链位置 一览
---------

> 5.0文档  
> [Table 6.1. Standard Filter Aliases and Ordering](https://docs.spring.io/spring-security/site/docs/5.0.13.RELEASE/reference/htmlsingle/)

Alias

Filter Class

Namespace Element or Attribute

CHANNEL\_FILTER

ChannelProcessingFilter

http/intercept-url@requires-channel

SECURITY\_CONTEXT\_FILTER

SecurityContextPersistenceFilter

http

CONCURRENT\_SESSION\_FILTER

ConcurrentSessionFilter

session-management/concurrency-control

HEADERS\_FILTER

HeaderWriterFilter

http/headers

CSRF\_FILTER

CsrfFilter

http/csrf

LOGOUT\_FILTER

LogoutFilter

http/logout

X509\_FILTER

X509AuthenticationFilter

http/x509

PRE\_AUTH\_FILTER

AbstractPreAuthenticatedProcessingFilter Subclasses

N/A

CAS\_FILTER

CasAuthenticationFilter

N/A

FORM\_LOGIN\_FILTER

UsernamePasswordAuthenticationFilter

http/form-login

BASIC\_AUTH\_FILTER

BasicAuthenticationFilter

http/http-basic

SERVLET\_API\_SUPPORT\_FILTER

SecurityContextHolderAwareRequestFilter

http/@servlet-api-provision

JAAS\_API\_SUPPORT\_FILTER

JaasApiIntegrationFilter

http/@jaas-api-provision

REMEMBER\_ME\_FILTER

RememberMeAuthenticationFilter

http/remember-me

ANONYMOUS\_FILTER

AnonymousAuthenticationFilter

http/anonymous

SESSION\_MANAGEMENT\_FILTER

SessionManagementFilter

session-management

EXCEPTION\_TRANSLATION\_FILTER

ExceptionTranslationFilter

http

FILTER\_SECURITY\_INTERCEPTOR

FilterSecurityInterceptor

http

SWITCH\_USER\_FILTER

SwitchUserFilter

N/A

过滤器顺序/位置/作用
-----------

> 5.0文档  
> [14.3 Filter Ordering](https://docs.spring.io/spring-security/site/docs/5.0.13.RELEASE/reference/htmlsingle/)

The order that filters are defined in the chain is very important. Irrespective of which filters you are actually using, the order should be as follows:

`ChannelProcessingFilter`, because it might need to redirect to a different protocol

`SecurityContextPersistenceFilter`, so a SecurityContext can be set up in the SecurityContextHolder at the beginning of a web request, and any changes to the SecurityContext can be copied to the HttpSession when the web request ends (ready for use with the next web request)  
so 没有经过`SecurityContextPersistenceFilter` 是用不了 SecurityContextHolder的!!!

`ConcurrentSessionFilter`, because it uses the SecurityContextHolder functionality and needs to update the SessionRegistry to reflect ongoing requests from the principal

_Authentication_ processing mechanisms - `UsernamePasswordAuthenticationFilter`, `CasAuthenticationFilter`, `BasicAuthenticationFilter` etc - so that the SecurityContextHolder can be modified to contain a valid Authentication request token

The `SecurityContextHolderAwareRequestFilter`, if you are using it to install a Spring Security aware HttpServletRequestWrapper into your servlet container

The `JaasApiIntegrationFilter`, if a JaasAuthenticationToken is in the SecurityContextHolder this will process the FilterChain as the Subject in the JaasAuthenticationToken

`RememberMeAuthenticationFilter`, so that if no earlier authentication processing mechanism updated the SecurityContextHolder, and the request presents a cookie that enables remember-me services to take place, a suitable remembered Authentication object will be put there

`AnonymousAuthenticationFilter`, so that if no earlier authentication processing mechanism updated the SecurityContextHolder, an anonymous Authentication object will be put there  
`ExceptionTranslationFilter`, to catch any Spring Security exceptions so that either an HTTP error response can be returned or an appropriate AuthenticationEntryPoint can be launched

`FilterSecurityInterceptor`, to protect web URIs and raise exceptions when access is denied

SecurityContextHolder 工作模式(SecurityContext 保存的位置)
-------------------------------------------------

    public class SecurityContextHolder {
    	// ~ Static fields/initializers
    	// =====================================================================================
    
    	public static final String MODE_THREADLOCAL = "MODE_THREADLOCAL";
    	public static final String MODE_INHERITABLETHREADLOCAL = "MODE_INHERITABLETHREADLOCAL";
    	public static final String MODE_GLOBAL = "MODE_GLOBAL";
    	public static final String SYSTEM_PROPERTY = "spring.security.strategy";
    	private static String strategyName = System.getProperty(SYSTEM_PROPERTY);
    	private static SecurityContextHolderStrategy strategy;
    	private static int initializeCount = 0;
        ...
    
    
    
    }
    

可通过 `spring.security.strategy` 配置

`MODE_THREADLOCAL`: 缺省工作模式, 保存在ThreadLocal  
`MODE_INHERITABLETHREADLOCAL`: 存储在线程中, 但子线程可以获取到父线程中的  
`MODE_GLOBAL`: 全局策略, 所有线程都获取

实例 一个项目例子
=========

主要配置部分

    <http auto-config="false" access-denied-page="/login.htm" entry-point-ref="authenticationEntryPoint">
    		<intercept-url pattern="/images/*" filters="none"/>
    		<intercept-url pattern="/style/*" filters="none"/>
    		<intercept-url pattern="/login.htm*" filters="none"/>
    		<intercept-url pattern="/login.jsp*" filters="none"/>
    		<intercept-url pattern="/logout.jsp" filters="none"/>
    		<intercept-url pattern="/index/map.sh*" filters="none"/>
    		<intercept-url pattern="/map/map_topic/topicList.sh*" filters="none"/>
    		<intercept-url pattern="/map/searchNearby.sh*" filters="none"/>
    		<intercept-url pattern="/solr/*" filters="none"/>
    		<intercept-url pattern="/mobileRest/*" filters="none"/>
    		<intercept-url pattern="/**" access="ROLE_USER"/>
            <!-- 验证码过滤器, spring 安全过滤器链 有默认的过滤器而且还是有默认顺序位置的(position这个属性指定)-->
    		<custom-filter ref="captchaAuthenticaionFilter" position="FORM_LOGIN_FILTER" />
    		<!--成功注销后跳转到的页面; -->
    		<logout logout-success-url="/login.htm" />
    		<http-basic />
    	</http>
    
    

1.**entry-point-ref**
---------------------

    认证入口点, 在过滤链, 检验失败的时候, 引导到登陆页面,其配置.  
    

            <beans:bean id="authenticationEntryPoint" class="net.jk.auth.JKLoginUrlAuthenticationEntryPoint">
                <beans:property name="loginFormUrl" value="/login.jsp" />
                <beans:property name="ajaxLoginFormUrl" value="ajaxLogin.htm" />
            </beans:bean>
    

2.**captchaAuthenticaionFilter**
--------------------------------

见上: _细谈认证过程_的第二步  
\> 如果未登陆,如 UsernamePasswordAuthenticationFilter, CasAuthenticationFilter..过滤器负责获取到的用户名和密码封装成一个实现了Authentication接口的 UsernamePasswordAuthenticationToken;

            <beans:bean id="captchaAuthenticaionFilter" class="org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter">
            <!-- 注入认证管理-->
                <beans:property name="authenticationManager" ref="authenticationManager" />
                <!-- 成功与失败的处理-->
                <beans:property name="authenticationFailureHandler" ref="authenticationFailureHandler" />
                <beans:property name="authenticationSuccessHandler" ref="authenticationSuccessHandler" />
                <beans:property name="filterProcessesUrl" value="/j_spring_security_check" />
            </beans:bean>
    

3.**authenticationManager**
---------------------------

见上: _细谈认证过程_的第五步  
\> `AuthenticationManager`并不认证,而是调用AuthenticationProvider的列表认证

        <!-- 认证管理 它应该持有DetailsService,AuthenticationProvider,如果没有AuthenticationProvider 配置默认会实例DaoAuthenticationProvider -->
            <authentication-manager alias="authenticationManager">
                <authentication-provider user-service-ref="userDetailsService" />
            </authentication-manager>
    

> `AuthenticationProvider` 接口的`public abstract Authentication authenticate(Authentication paramAuthentication) throws AuthenticationException;`方法是真正在处理认证逻辑的  
> 它持有一个`UserDetailsService`,用于加载用户信息,简而言之: 改变认证 实现AuthenticationProvider; 改变信息来源 实现UserDetailsService  
> 认证成功: 后会补充Authentication详细的角色权限等 返回给AuthenticationManager  
> 认证失败: 抛出`AuthenticationException`  
> 未知: 返回`null`,这将交给下一个Provider认证  
> `<authentication-provider>` 会默认实例化一个`DaoAuthenticationProvider`

4.**userDetailsService**
------------------------

在注解中

    @Service("userDetailsService")
    public class LoadUserDetailsService implements UserDetailsService{
        ...
        //`UserDetailsService`,用于加载用户信息
    	@Override
    	public UserDetails loadUserByUsername(String loginid)
    			throws UsernameNotFoundException, DataAccessException {
    		final List<GrantedAuthority> grantedAuthorities = new ArrayList<GrantedAuthority>();//这是角色规则
    		if(StringUtils.isBlank(loginid))throw new UsernameIsEmptyException("请输入用户名! ");
    		Bs_user user=bs_userDao.findByLoginId(loginid);
    		if(user==null)throw new UsernameNotFoundException("UserDetailsService.usernameNotFound");
    		grantedAuthorities.add(new GrantedAuthorityImpl(AuthConstants.ROLE_USER));
    		List<String> permissionCode=bs_roleService.findPermissionCodeByAccount(loginid);
    		if(permissionCode!=null && !permissionCode.isEmpty()){
    			for(String code:permissionCode){
    				grantedAuthorities.add(new GrantedAuthorityImpl(code));
    			}
    		}
    	...
            //返回详细信息, 最终认证会在默认的 DaoAuthenticationProvider
    		return (UserDetails) authuser;
    	}
        	...
    

Remember-Me 记住登陆
================

10.4 Remember-Me Interfaces and Implementations (3.0)

Remember-Me, 不是在基本验证身份验证的时候使用, 在`AbstractAuthenticationProcessingFilter`过滤器基类  
它有个`RememberMeServices`引用在**适当的时候调用** =.=

> Remember-me authentication is not used with basic authentication, given it is often not used with HttpSessions. Remember-me is used with UsernamePasswordAuthenticationFilter, and is implemented via hooks in the AbstractAuthenticationProcessingFilter superclass. The hooks will invoke a concrete RememberMeServices at the appropriate times. The interface looks like this:

在Spring Security的过滤器链里, `RememberMeAuthenticationFilter` 是排在`UsernamePasswordAuthenticationFilter` 之后的. 在第一次登录时(如果勾选了remember me), 在验证信息正确后, AbstractAuthenticationProcessingFilter(UsernamePasswordAuthenticationFilter的父类)最后会调用一个叫successfulAuthentication()的方法:

注意几点:

1.  在 `authenticationManager` 里要加多一个authentication provider -- RememberMeAuthenticationProvider;
2.  要为`UsernamePasswordAuthenticationFilter`的 rememberMeServices属性指定一个实例;  
    3) `RememberMeAuthenticationProvider` 和`TokenBasedRememberMeServices`都要为它们的key属性指定一个唯一的值. 这个值可以用应用名加一个不少于36位长度的随机字符串. 这个key是用来识别当前应用的唯一值.
3.  在提交登录表单的时候, 一定要加多一个名的 `_spring_security_remember_me` 的参数名(可以改), 值可以是"true", "yes", "on"或"1".

前端页面表单
------

     <input type="checkbox" name="remember-me"  value="true"/> Remember me
     <!-- _spring_security_remember_me 远古版本 -->
     <input type="checkbox" name="_spring_security_remember_me"  value="true"/> Remember me
    

配置(基于xml)
---------

    <http auto-config="false" access-denied-page="/login.htm"
    		entry-point-ref="authenticationEntryPoint">
        <intercept-url pattern="/images/*" filters="none"/>
    .......
            <!-- 插入 过滤链-->
            <custom-filter ref="rememberMeFilter" position="REMEMBER_ME_FILTER" /> -->
            <custom-filter ref="captchaAuthenticaionFilter" position="FORM_LOGIN_FILTER" />
            
    .......
    </http>
    
     <!-- dv2它其实是继承UsernamePasswordAuthenticationFilter(捕获用户密码 填充Authentication 见上认证流程) -->
    <beans:bean id="captchaAuthenticaionFilter" class="net.jk.auth.service.CaptchaAuthenticationFilter">
        <beans:property name="authenticationManager" ref="authenticationManager" />
        <beans:property name="authenticationFailureHandler" ref="authenticationFailureHandler" />
        <beans:property name="authenticationSuccessHandler" ref="authenticationSuccessHandler" />
         <!-- rememberMeServices (生成cookie的入口)
         RememberMeAuthenticationFilter是排在UsernamePasswordAuthenticationFilter之后的. 在第一次登录时(如果勾选了remember me), 在验证信息正确后, AbstractAuthenticationProcessingFilter(UsernamePasswordAuthenticationFilter的父类)最后会调用一个叫successfulAuthentication()的方法 -->
        <beans:property name="rememberMeServices" ref="tokenBasedRememberMeServices" />
    
        <beans:property name="filterProcessesUrl" value="/j_spring_security_check" />
    </beans:bean>
    
     <!-- 需要一个过滤器, (这应该是 认证的入口)插入到过滤链中 -->
    <beans:bean id="rememberMeFilter" class="org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter">
    	<beans:property name="authenticationManager" ref="authenticationManager" />
    	<beans:property name="rememberMeServices" ref="tokenBasedRememberMeServices" />
    </beans:bean>
    
    <!-- 认证提供器(认证) -->
    <beans:bean id="rememberMeAuthenticationProvider" class="org.springframework.security.authentication.RememberMeAuthenticationProvider">
    	<beans:property name="key" value="1C6D97ACA4924F81926E7B302D14DB6D"/>
    </beans:bean>
    
     <!-- RememberMeServices (生成cookie) -->
    <beans:bean id="tokenBasedRememberMeServices" class="org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices">
    	<beans:property name="key" value="1C6D97ACA4924F81926E7B302D14DB6D" />
    	<beans:property name="userDetailsService" ref="userDetailsService" />
    </beans:bean>
    

登陆后 , 默认应该会有一个 SPRING\_SECURITY\_REMEMBER\_ME\_COOKIE 名字的cookie

*   remember-me属性详解  
    remember-me属性是spring security命名空间中实现自动登录的专属配置项,它有如下属性

1.  key: 这个"key"属性用来辨别分辨不同项目的cookie
2.  authentication-success-handler-ref 指向一个AuthenticationSuccessHandler
3.  data-source-ref 指向一个DataSource数据源
4.  remember-me-cookie: cookie存放的名称.默认为’remember-me’.
5.  remember-me-parameter: 触发自动登录的请求参数名称.默认为’remember-me’.
6.  services-alias: 声明一个内部定义的RememberMeServices的bean的别名,提供给程序的其他bean使用
7.  services-ref: 指向一个RememberMeServices,可以自定义实现自己的自动登录逻辑
8.  token-repository-ref: 指向一个PersistentTokenRepository bean,用来实现持久化令牌的自动登录
9.  token-validity-seconds: cookie存在的时间周期,单位为秒
10.  use-secure-cookie: 是否设置"secure"标志,具体使用不详
11.  user-service-ref: 指向一个UserDetailsService的bean

[spring-security 3.0.8 远古版本文档](https://docs.spring.io/spring-security/site/docs/3.0.8.RELEASE/reference/remember-me.html)  
[参考spring-security 文档](https://spring.io/projects/spring-security#learn): Remember-Me Authentication 章节

在代码中设置 SecurityContextHolder 为登陆状态
==================================

    ///load userDetails ...
    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
    SecurityContextHolder.getContext().setAuthentication(authentication);
    
    

SecurityContextHolder 的原理
-------------------------

`SecurityContextHolder` 用于存储安全上下文(security context)的信息，即一个存储身份信息，认证信息等的容器。  
SecurityContextHolde 默认使用 `ThreadLocal` 策略来存储认证信息，即一种与线程绑定的策略，每个线程执行时都可以获取该线程中的安全上下文(security context)，各个线程中的安全上下文互不影响。

Sectrity 配置 (Java Bean形式)
=========================

    @Configuration
    public class DefaultSecurityConfig extends WebSecurityConfigurerAdapter {
        @Override
        protected void configure(HttpSecurity httpSecurity) throws Exception {
        log.info("当前使用安全配置是: default");
        httpSecurity.headers().frameOptions().disable();//iframe 
        ExpressionInterceptUrlRegistry eiur=httpSecurity
            // 禁用 CSRF
            .csrf().disable()
            // 授权异常
            .exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint() ).and()
            .addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)
            // 不创建会话
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
            // 过滤请求
            .authorizeRequests()
            .antMatchers(
                    HttpMethod.GET,
                    "/*.html",
                    "/**/*.html",
                    "/**/*.css",
                    "/**/*.js"
            ).anonymous()
    
    
            // 支付宝回调
            .antMatchers("/api/aliPay/return").anonymous()
            .antMatchers("/api/aliPay/notify").anonymous()
            //微信公众号回调
            .antMatchers("/api/wechat/core").permitAll()
            
            //登陆接口
            .antMatchers("/auth/**").permitAll()
            
            // swagger start
            .antMatchers("/swagger-ui.html").anonymous()
            .antMatchers("/swagger-resources/**").anonymous()
            .antMatchers("/webjars/**").anonymous()
            .antMatchers("/*/api-docs").anonymous()
            .antMatchers("/*/api-docs-ext").anonymous()
            // swagger end
    
            // 接口限流测试
            .antMatchers("/test/**").anonymous()
            .antMatchers(HttpMethod.OPTIONS, "/**").anonymous()
    
            .antMatchers("/druid/**").anonymous()
            //rest接口
            .antMatchers("/api/rest/**").anonymous();
    
            //除此之外所有地址都需要验证
            httpSecurity.authorizeRequests().anyRequest().authenticated();
        }
    
        ...
    }
    

**一个简单内存认证**

    @Configuration
    @Order(1)
    public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
        @Bean
        public UserDetailsService userDetailsService()  {
            // ensure the passwords are encoded properly
            User.UserBuilder users = User.withDefaultPasswordEncoder();
            InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
            manager.createUser(users.username("yang").password("123..").roles("USER").build());
            //manager.createUser(users.username("admin").password("dfgddd").roles("USER","ADMIN").build());
            return manager;
        }
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.formLogin()
                    .successForwardUrl("/index.html")
                    .and()
                    .authorizeRequests().anyRequest().authenticated();
        }
    }
    
    

集成单点登陆(**jasig**)
=================

服务端
---

官下载页 - [https://www.apereo.org/programs/software/cas](https://www.apereo.org/programs/software/cas)  
GitHub - [https://github.com/apereo/cas](https://github.com/apereo/cas)

下载其发布版包,例: cas-server-webapp-4.0.0 - (\_v\_resouces/cas-server-4.0.0-release.zip)  
一般而言仅需要其编译好的即可,例:`cas-server-webapp-4.0.0.war` 和数据源支持 `cas-server-support-jdbc-4.0.0.jar`  
解压war把support-jdbc放到lib下,还有使用的数据库驱动,比如`mysql-connector-java-5.0.8-bin.jar`

*   服务端配置  
    找到./WEB-INF/deployerConfigContext.xml 文件,修改

1.  注释

        <bean id="primaryAuthenticationHandler"
              class="org.jasig.cas.authentication.AcceptUsersAuthenticationHandler">
            <property name="users">
                <map>
                    <entry key="casuser" value="Mellon"/>
                </map>
            </property>
        </bean>
    

2.  增加

    <!-- from 数据库 -->
    <bean id="dataSource"
            class="org.springframework.jdbc.datasource.DriverManagerDataSource">
            <property name="driverClassName" value="net.sourceforge.jtds.jdbc.Driver" />
            <property name="url"
                value="jdbc.url=jdbc:jtds:sqlserver://127.0.0.1:1433/asp-gdagri-auth;useUnicode=true;charset=GB2312" />
            <property name="username" value="user_dev" />
            <property name="password" value="user@dev" />
        </bean>
        
        <bean id="primaryAuthenticationHandler"
              class="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"
              p:dataSource-ref="dataSource"
              p:passwordEncoder-ref="MD5PasswordEncoder"
              p:sql="select password from bs_role where name=?" />
              
        <bean id="MD5PasswordEncoder" class="org.jasig.cas.authentication.handler.DefaultPasswordEncoder">
            <constructor-arg index="0">
                <value>MD5</value>
            </constructor-arg>
        </bean>
    

> `p:sql`应该是指定查询语句

### 一些配置

### ticketExpirationPolicies.xml

ticket 过期策略配置

    
    
    <!-- TGT 配置-->
    	<bean id="serviceTicketExpirationPolicy" class="org.jasig.cas.ticket.support.MultiTimeUseOrTimeoutExpirationPolicy">
        
    		<!-- This argument is the number of times that a ticket can be used before its considered expired. 
            (ticket 在过期前[下 过期时间 参数] 可以使用的次数)
            -->
    		<constructor-arg
    			index="0"
    			value="999999999" />
    		
    		<!-- This argument is the time a ticket can exist before its considered expired.  
            ( 过期时间 单位:毫秒)
            -->
    		<constructor-arg
    			index="1"
    			value="100000" />
    	</bean>
    	<!--ST 配置 -->
    	<bean id="grantingTicketExpirationPolicy" class="org.jasig.cas.ticket.support.TimeoutExpirationPolicy">
    		<!-- This argument is the time a ticket can exist before its considered expired. 
            (ticket 在不活跃的时候过期时间 毫秒)
             -->
    		<constructor-arg
    			index="0"
    			value="7200000" />
    	</bean>
    
    

[参考](https://www.cnblogs.com/gao241/p/3367869.html)

#### TGC: Ticket Granting Cookie

CAS 会将生成的 TGT 放在 session 中, 而 TGC 就是这个 session 的唯一标识(sessionId), 可以认为是 TGT 的key, 为 TGT 就是 TGC 的 value, TGC 以 cookie 的形式保存在浏览器中, 每个请求都会尝试携带 TGC; （每个服务都会在 session 和 cookie 中保存对应的 TGT 和 TGC）

#### TGT: Ticket Granting Ticket

TGT 是CAS 为用户签发的登录 ticket, 也是用于验证用户登录成功的唯一方式; TGT 封装了 Cookie 值以及 Cookie 值对应的用户信息, CAS 通过 Cookie 值（TGC）为 key 查询缓存中有无 TGT（TGC:TGT（key:value））, 如果有的话就说明用户已经登录成;

#### ST: Service Ticket

ST 是当用户访问某一服务时提供的 ticket; 用户在访问其他服务时, 发现没有 cookie 或 ST , 那么就会302到 CAS 服务器获取 ST; 然后会携带着 ST 302 回来;

客户端 (XML形式配置)
-------------

1.  首先需要做的是将应用的登录认证入口改为使用`CasAuthenticationEntryPoint`;

      <!-- 指定登录入口为casEntryPoint -->
       <security:http  entry-point-ref="casEntryPoint">
          ...
       </security:http>
    

2.  所以首先我们需要配置一个`CasAuthenticationEntryPoint`对应的bean, 然后指定需要进行登录认证时使用该`AuthenticationEntryPoint`;

    <!-- 认证的入口 -->
    
       <bean id="casEntryPoint"
    
          class="org.springframework.security.cas.web.CasAuthenticationEntryPoint">
    
          <!-- Cas Server的登录地址, elim是我的计算机名 -->
    
          <property name="loginUrl" value="https://elim:8443/cas/login" />
    
          <!-- service相关的属性 -->
    
          <property name="serviceProperties" ref="serviceProperties" />
       </bean>
    

3.  配置CasAuthenticationEntryPoint时需要指定一个`ServiceProperties`, 该对象主要用来描述service（Cas概念）相关的属性, 主要是指定在Cas Server认证成功后将要跳转的地址;

    <!-- 指定service相关信息 -->
       <bean id="serviceProperties"class="org.springframework.security.cas.ServiceProperties">
          <!-- Cas Server认证成功后的跳转地址, 这里要跳转到我们的Spring Security应用, 之后会由CasAuthenticationFilter处理, 默认处理地址为/j_spring_cas_security_check -->
          //<!>本地地址了, 这里开始就是本地Spring Security 流程了, 再由 cas filter 封装 UsernamePasswordAuthenticationToken 
          //再到 AuthenticationManager, 到 AuthenticationProvider 流程..
          <property name="service"
             value="http://elim:8080/app/j_spring_cas_security_check" />
    
       </bean>
    

4.  之后我们需要配置一个`CasAuthenticationFilter`, 并将其放置在Filter链表中CAS\_FILTER的位置, 以处理Cas Server认证成功后的页面跳转, 用以在Spring Security中进行认证;

> 该Filter会将Cas Server传递过来的ticket（Cas概念）封装成一个`Authentication`（对应UsernamePasswordAuthenticationToken, 其中ticket作为该Authentication的password）, 然后传递给`AuthenticationManager`进行认证;

      <security:http entry-point-ref="casEntryPoint">
          ...
            <!-- 定义CasAuthenticationFilter 并将其放置在Filter链表中CAS_FILTER的位置-->
          <security:custom-filter ref="casFilter" position="CAS_FILTER"/>
          ...
       </security:http>
       <bean id="casFilter" class="org.springframework.security.cas.web.CasAuthenticationFilter">
          <property name="authenticationManager" ref="authenticationManager" />
          <!-- 指定处理地址, 不指定时默认将会是"/j_spring_cas_security_check" -->
          <property name="filterProcessesUrl" value="/j_spring_cas_security_check"/>
       </bean>
    

5.  `CasAuthenticationFilter`会将封装好的包含Cas**Server传递过来的ticket的Authentication**对象传递给**AuthenticationManager进行认证**;

    <security:authentication-manager alias="authenticationManager">
    <!-- 给AuthenticationManager 提供一个 认证 ; 参考: 细谈认证过程 5-->
          <security:authentication-provider ref="casAuthenticationProvider"/>
    
       </security:authentication-manager>
    

6.  默认的AuthenticationManager实现类为ProviderManager, 而ProviderManager中**真正进行认证的是AuthenticationProvider**;

所以接下来我们要在AuthenticationManager中配置一个能够处理**CasAuthenticationFilter传递过来的Authentication对象的AuthenticationProvider实现,** `CasAuthenticationProvider`;

    <!> 真正认证逻辑bean 
     <bean id="casAuthenticationProvider"
    
       class="org.springframework.security.cas.authentication.CasAuthenticationProvider">
          <!-- 通过username来加载UserDetails -->
          <property name="authenticationUserDetailsService">
             <beanclass="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper">
                <!-- 真正加载UserDetails的UserDetailsService实现 -->
                <constructor-arg ref="userDetailsService" />
             </bean>
          </property>
    
          <property name="serviceProperties" ref="serviceProperties" />
    
          <!-- 配置TicketValidator在登录认证成功后验证ticket -->
          <property name="ticketValidator">
    
             <bean class="org.jasig.cas.client.validation.Cas20ServiceTicketValidator">
                <!-- Cas Server访问地址的前缀, 即根路径-->
                <constructor-arg index="0" value="https:// elim:8443/cas" />
             </bean>
          </property>
          <property name="key" value="key4CasAuthenticationProvider" />
    
       </bean>
    

**CasAuthenticationProvider首先会利用TicketValidator**（Cas概念）对Authentication中包含的ticket信息进行认证;

认证通过后将利用持有的`AuthenticationUserDetailsService` 根据认证通过后回传的Assertion对象中拥有的username加载用户对应的UserDetails,

即主要是加载用户的相关权限信息GrantedAuthority; 然后构造一个 CasAuthenticationToken进行返回; 之后的逻辑就是正常的Spring Security的逻辑了;

访问测试

> [http://127.0.0.1/cas-server/login](http://127.0.0.1/cas-server/login)  
> [https://127.0.0.1:8443/cas-server/login](https://127.0.0.1:8443/cas-server/login)

客户端 (Java Bean形式配置)
-------------------

    <!-- security 对CAS支持 -->
    <dependency>
    	<groupId>org.springframework.security</groupId>
    	<artifactId>spring-security-cas</artifactId>
    </dependency>
    

        //入口点
       @Bean
    	public CasAuthenticationEntryPoint casAuthenticationEntryPoint() {
    		CasAuthenticationEntryPoint casAuthenticationEntryPoint = new CasAuthenticationEntryPoint();
    		casAuthenticationEntryPoint.setLoginUrl(casProperties.getServerPrefix()+casProperties.getServerLogin());
    		casAuthenticationEntryPoint.setServiceProperties(serviceProperties());
    		return casAuthenticationEntryPoint;
    	}
        // 本地缓存认证
        @Bean
      	public CasLocalCacheAuthenticationFilter casLocalCacheAuthenticationFilter()  {
        	CasLocalCacheAuthenticationFilter ccaf;
        	try {
        		ccaf = new CasLocalCacheAuthenticationFilter(casProperties, redisTemplate, casUserDetailsService());
    		} catch (Exception e) {
    			e.printStackTrace();
    			throw new RuntimeException(e.getMessage() );
    		}
      		return ccaf;
      	}
        // cas 认证过滤器
        @Bean
    	public CasAuthenticationFilter casAuthenticationFilter() throws Exception {
    		CasAuthenticationFilter casAuthenticationFilter = new CasAuthenticationFilter();
    		casAuthenticationFilter.setAuthenticationManager(authenticationManager());
    		casAuthenticationFilter.setFilterProcessesUrl(casProperties.getAppLogin());
    		casAuthenticationFilter.setAuthenticationSuccessHandler(casAuthenticationSuccessHandler());
    		return casAuthenticationFilter;
    	}
    
        ////////////认证相关处理
        @Bean
        @Override
    	protected AuthenticationManager authenticationManager() {
    		List<AuthenticationProvider> p = new ArrayList<AuthenticationProvider>(1);
    		p.add(casAuthenticationProvider());
    		ProviderManager authenticationManager = new ProviderManager(p);
    		return authenticationManager;
    	}
        @Bean
    	public CasAuthenticationProvider casAuthenticationProvider() {
    		CasAuthenticationProvider casAuthenticationProvider = new CasAuthenticationProvider();
    		try {
    			casAuthenticationProvider.setAuthenticationUserDetailsService(casUserDetailsService());
    		} catch (Exception e) {
    			e.printStackTrace();
    			throw new RuntimeException(e.getMessage() );
    		}
    		casAuthenticationProvider.setServiceProperties(serviceProperties());
    		casAuthenticationProvider.setTicketValidator(cas20ServiceTicketValidator());
    		casAuthenticationProvider.setKey("jk_www_123ProviderKey");
    		return casAuthenticationProvider;
    	}
    	@Bean
    	public Cas20ServiceTicketValidator cas20ServiceTicketValidator() {
    		return new Cas20ServiceTicketValidator(casProperties.getServerPrefix());
    	}
    	
    	@Bean
    	public ServiceProperties serviceProperties() {
    		ServiceProperties serviceProperties = new ServiceProperties();
    		serviceProperties.setService(casProperties.getAppPrefix()+ casProperties.getAppLogin());
    		serviceProperties.setAuthenticateAllArtifacts(true);
    		return serviceProperties;
    	}
        @Bean
    	public CasAuthenticationSuccessHandler casAuthenticationSuccessHandler()  {
        	CasAuthenticationSuccessHandler casAuthenticationSuccessHandler = new CasAuthenticationSuccessHandler(this.casProperties, redisTemplate);
    		return casAuthenticationSuccessHandler;
    	}
        
        // 本地 UserDetailsService
    	@Bean	
    	@ConditionalOnMissingBean( value={AuthenticationUserDetailsService.class} )
     	public AuthenticationUserDetailsService casUserDetailsService() throws Exception {
     		return new CasUserDetailsServiceImp();
     	}
         //登出
        @Bean
    	public CasLogoutFilter casLogoutFilter() {
    		return new CasLogoutFilter(casProperties, redisTemplate);
    	}
        
        //配置
        @Override
        protected void configure(HttpSecurity httpSecurity) throws Exception {
          	log.info("当前使用安全配置是: cas");
        	ExpressionInterceptUrlRegistry eiur=httpSecurity
                    // 禁用 CSRF
                    .csrf().disable()
                    // 授权异常
                    .exceptionHandling().authenticationEntryPoint(casAuthenticationEntryPoint() ).and()
                    // 不创建会话
                    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
        	//
    		    	httpSecurity
    					.formLogin()
    					.loginProcessingUrl(casProperties.getAppLogin());
                    // 防止iframe 造成跨域
                    .and().headers().frameOptions().disable();
            httpSecurity
            		.addFilterAt(casLogoutFilter(), LogoutFilter.class)
                    .addFilterBefore(casAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
                    .addFilterBefore(casLocalCacheAuthenticationFilter(), CasAuthenticationFilter.class);
          
        }
    

定义一个 CasProperties 配置类,用于将properties文件指定的内容注入以方便使用

    public class CasProperties {
    	private String serverPrefix;
    	private String serverLogin;
    	private String serverLogout;
    	//
    	private String appPrefix;
    	private String appLogin;
    	private String appLogout;
    
    

### 注意1 CasAuthenticationFilter

CasAuthenticationFilter 认证过滤器

    @Bean
    public CasAuthenticationFilter casAuthenticationFilter() throws Exception {
        CasAuthenticationFilter casAuthenticationFilter = new CasAuthenticationFilter();
        //根据 spring securiry 步骤 authenticationManager 会调用 Provider list 认证 规则
        //所以还要把CasAuthenticationProvider  注给 authenticationManager, 最好覆盖父的方法, 自己写.. 先不管了
        List<AuthenticationProvider> p = new ArrayList<AuthenticationProvider>(1);
        p.add(casAuthenticationProvider());
        ProviderManager authenticationManager = new ProviderManager(p);
        casAuthenticationFilter.setAuthenticationManager(authenticationManager);
        casAuthenticationFilter.setFilterProcessesUrl(casProperties.getAppLogin());//cas 的回调 登陆地址
        return casAuthenticationFilter;
    }
    

### 注意2 CasAuthenticationProvider

这仍是 spring 框架内的扩展; 这个Provider 需要几个实现?

要引 jasig client

    <!-- https://mvnrepository.com/artifact/org.jasig.cas.client/cas-client-core -->
    <dependency>
        <groupId>org.jasig.cas.client</groupId>
        <artifactId>cas-client-core</artifactId>
        <version>xxx</version>
    </dependency>
    
    

    
    casAuthenticationProvider.setServiceProperties(serviceProperties());//cas 服务器配置
    casAuthenticationProvider.setTicketValidator(cas20ServiceTicketValidator()); // 验证实现 , jasig client 已实现
    casAuthenticationProvider.setAuthenticationUserDetailsService(casUserDetailsService());//这是登陆成功之后 加载本应用的 用户详细信息
    casAuthenticationProvider.setKey("casAuthenticationProviderKey"); //key  可以标识它(Provider)先前已认证的令牌, 避免重复验证,参考源码105
    

    
    if (authentication instanceof CasAuthenticationToken) {
    			if (this.key.hashCode() == ((CasAuthenticationToken) authentication)
    					.getKeyHash()) {
    				return authentication;
    			}
    			else {
    				throw new BadCredentialsException(
    						messages.getMessage("CasAuthenticationProvider.incorrectKey",
    								"The presented CasAuthenticationToken does not contain the expected key"));
    			}
    		}
    

[官方wiki?](https://apereo.atlassian.net/wiki/spaces/CASC/overview)  
[https://www.jianshu.com/p/2ba25bd3a5cb?tdsourcetag=s\_pctim\_aiomsg](https://www.jianshu.com/p/2ba25bd3a5cb?tdsourcetag=s_pctim_aiomsg)  
[https://blog.csdn.net/cl\_andywin/article/details/53998986](https://blog.csdn.net/cl_andywin/article/details/53998986)

踩坑指南
====

anonymous 和 permitAll
---------------------

    .antMatchers("/auth/ttx").anonymous()
    .antMatchers("/auth/ttp").permitAll()
    

`anonymous()` 允许匿名/不检验权限/经过Security 过滤链; 同XMl的`<intercept-url pattern="/auth/ttx*" access="IS_AUTHENTICATED_ANONYMOUSLY"/>`

`permitAll()` 完全免登/不经过Security 过滤链; 同XMl的`<intercept-url pattern="/auth/ttp*" filters="none" />`

antMatchers 的配置规则
-----------------

Examples

`com/t?st.jsp` — matches `com/test.jsp` but also `com/tast.jsp` or `com/txst.jsp`  
`com/*.jsp` — matches all .jsp files in the com directory

`com/**/test.jsp` — matches all test.jsp files underneath the com path

`org/springframework/**/*.jsp` — matches all .jsp files underneath the org/springframework path

`org/**/servlet/bla.jsp` — matches org/springframework/servlet/bla.jsp but also org/springframework/testing/

`servlet/bla.jsp and` org/servlet/bla.jsp

`com/{filename:\\w+}.jsp` will match com/test.jsp and assign the value test to the filename variable

**最具的规则, 应该排在最前面!**

失败时不调用 authenticationEntryPoint 入口的问题
-------------------------------------

    
    protected void configure(HttpSecurity httpSecurity) throws Exception {
    httpSecurity.headers().frameOptions().disable();//iframe 
    ExpressionInterceptUrlRegistry eiur=httpSecurity
            // 禁用 CSRF
            .csrf().disable()
            // 授权异常
            .exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint() ).and()
            .addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)
    

参见上: `细谈认证过程`

自定义 `authenticationTokenFilter` 认证实现时

1.  `ExceptionTransactionFilter` 基本在过滤最后面, 没办法处理FilterChain中Filter 的异常, 它主要是处理Action 抛出的异常, 如是认证相关异常(即 `AccessDeniedException` 和 `AuthenticationException`) 它就会处理翻译并会调到 `authenticationEntryPoint`
    
2.  如果认证失败: 没有任何处理会继续回调链 `chain.doFilter(request, response)`;**注意在httpSecurity 末尾追加 `authenticated()` 兜底(除此之外都需要验证), 否则会以未登陆状态访问到Action!**
    

     //除此之外的 所有地址都需要验证(兜底)
    httpSecurity.authorizeRequests().anyRequest().authenticated();
    

权限问题
----

### 记一 FilterSecurityInterceptor 奇怪的权限拦截!

#### 项目调试过程记录

_项目接口调用, 在`JwtAuthorizationTokenFilter` 认证成功,过滤链最后一个`org.springframework.security.web.access.intercept.FilterSecurityInterceptor` 权限投票失败,`AccessDeniedException: Access is denied`异常问题调试_  
被异常翻译过滤器`org.springframework.security.web.access.ExceptionTranslationFilter`, 翻译为403;

`FilterSecurityInterceptor` 该过滤器用于控制method级别的权限控制.也就是处理 `@PreAuthorize` 注解的过滤器

*   org.springframework.security.access.vote.AffirmativeBased

_最终调到`org.springframework.security.access.vote.AffirmativeBased::decide` 方法_

    public void decide(Authentication authentication, Object object,
    			Collection<ConfigAttribute> configAttributes) throws AccessDeniedException {
    		int deny = 0;
    
    for (AccessDecisionVoter voter: getDecisionVoters()) {
        //只有一个 org.springframework.security.web.access.expression.WebExpressionVoter , 它投拒绝
        int result = voter.vote(authentication, object, configAttributes);
        switch (result) {
        case AccessDecisionVoter.ACCESS_GRANTED:
            return;
    
        case AccessDecisionVoter.ACCESS_DENIED:
            deny++;
    
            break;
    
        default:
            break;
        }
    }
    

**AffirmativeBased** 的逻辑是这样的:  
（1）只要有AccessDecisionVoter的投票为ACCESS\_GRANTED则同意用户进行访问;  
（2）如果全部弃权也表示通过;  
（3）如果没有一个人投赞成票, 但是有人投反对票, 则将抛出AccessDeniedException;

**AffirmativeBased** 的投票接口列表(**AccessDecisionVoter**)只有一个\*

`org.springframework.security.web.access.expression.WebExpressionVoter`

*   AccessDecisionVoter

`AccessDecisionVoter.vote()`方法的返回结果会是AccessDecisionVoter中定义的三个常量之一; ACCESS\_GRANTED表示同意, ACCESS\_DENIED表示拒绝, ACCESS\_ABSTAIN表示弃权; 如果一个AccessDecisionVoter不能判定当前Authentication是否拥有访问对应受保护对象的权限, 则其vote()方法的返回值应当为弃权ACCESS\_ABSTAIN;

_最最终在 `ReflectivePropertyAccessor$OptimalPropertyAccessor.read` 方法, 反射调用回 `WebSecurityExpressionRoot[SecurityExpressionRoot.isAnonymous()]`方法的返回值_

isAnonymous 顾名思义, 是否匿名...

#### 解决方式

HttpSecurity 的配置 `.antMatchers("/auth/*").anonymous()` (允许匿名用户, 而登陆用户不是匿名用户?) ..使用`permitAll` 替代之.

    //例如
    .antMatchers("/auth/ttx").anonymous()
    .antMatchers("/auth/ttp").permitAll()
    

### 记二 接口403无权限的问题!

#### @PreAuthorize 接口权限注解

一般而言在 controller 通过`@PreAuthorize` 注解访问权限,  
它调用的是在 `org.springframework.security.access.expression.SecurityExpressionRoot`里面的方法判断权限的 (EL表达式);

> 记得需启用`@EnableGlobalMethodSecurity(prePostEnabled = true)`

最终是在 `org.springframework.security.access.prepost.PreInvocationAuthorizationAdviceVoter::vote`方法投票

    public int vote(Authentication authentication, MethodInvocation method,
            Collection<ConfigAttribute> attributes) {
    
        // Find prefilter and preauth (or combined) attributes
        // if both null, abstain
        // else call advice with them
    
        PreInvocationAttribute preAttr = findPreInvocationAttribute(attributes);
    
        if (preAttr == null) {
            // No expression based metadata, so abstain
            return ACCESS_ABSTAIN;
        }
        //org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice
        boolean allowed = preAdvice.before(authentication, method, preAttr);
    
        return allowed ? ACCESS_GRANTED: ACCESS_DENIED;
    }
    
    
    //org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice :: before
    	public boolean before(Authentication authentication, MethodInvocation mi,
    			PreInvocationAttribute attr) {
    		PreInvocationExpressionAttribute preAttr = (PreInvocationExpressionAttribute) attr;
    		EvaluationContext ctx = expressionHandler.createEvaluationContext(authentication,
    				mi);
    		Expression preFilter = preAttr.getFilterExpression();
    		Expression preAuthorize = preAttr.getAuthorizeExpression();
    
    		if (preFilter != null) {
    			Object filterTarget = findFilterTarget(preAttr.getFilterTarget(), ctx, mi);
    
    			expressionHandler.filter(filterTarget, preFilter, ctx);
    		}
    
    		if (preAuthorize == null) {
    			return true;
    		}
            //这里执行 Spring EL表达式 
    		return ExpressionUtils.evaluateAsBoolean(preAuthorize, ctx);
    	}
    
    
    
    // org.springframework.expression.spel.standard.SpelExpression::getValue 方法
    public <T> T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType) throws EvaluationException {
    		Assert.notNull(context, "EvaluationContext is required");
    
    		if (this.compiledAst != null) {
    			try {
    				Object result = this.compiledAst.getValue(context.getRootObject().getValue(), context);
    				if (expectedResultType != null) {
    					return ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);
    				}
    				else {
    					return (T) result;
    				}
    			}
    			catch (Throwable ex) {
    				// If running in mixed mode, revert to interpreted
    				if (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {
    					this.interpretedCount = 0;
    					this.compiledAst = null;
    				}
    				else {
    					// Running in SpelCompilerMode.immediate mode - propagate exception to caller
    					throw new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);
    				}
    			}
    		}
    
    		ExpressionState expressionState = new ExpressionState(context, this.configuration);
    		TypedValue typedResultValue = this.ast.getTypedValue(expressionState);
    		checkCompile(expressionState);
    		return ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);
    	}
    ///最最终 org.springframework.expression.spel.support.ReflectiveMethodExecutor::execute 方法 反射调用
    @Override
    public TypedValue execute(EvaluationContext context, Object target, Object... arguments) throws AccessException {
        try {
            this.argumentConversionOccurred = ReflectionHelper.convertArguments(
                    context.getTypeConverter(), arguments, this.originalMethod, this.varargsPosition);
            if (this.originalMethod.isVarArgs()) {
                arguments = ReflectionHelper.setupArgumentsForVarargsInvocation(
                        this.originalMethod.getParameterTypes(), arguments);
            }
            ReflectionUtils.makeAccessible(this.methodToInvoke);
            
            /**
    //this.methodToInvoke = public abstract boolean org.springframework.security.access.expression.SecurityExpressionOperations.hasAnyRole(java.lang.String[]) // 这是个抽象类, 实际调用 见下
    // target = org.springframework.security.access.expression.method.MethodSecurityExpressionRoot
    // arguments = ADMIN ... 角色代码数组
           **/
            Object value = this.methodToInvoke.invoke(target, arguments);
            return new TypedValue(value, new TypeDescriptor(new MethodParameter(this.originalMethod, -1)).narrow(value));
        }
        catch (Exception ex) {
            throw new AccessException("Problem invoking method: " + this.methodToInvoke, ex);
        }
    }
    //实际调用的是 org.springframework.security.access.expression.SecurityExpressionRoot 对象
    

#### 解决方式

注意 `org.springframework.security.access.expression.SecurityExpressionRoot` 有个属性它默认带`private String defaultRolePrefix = "ROLE_";`前缀 我\*!

定义一个 `GrantedAuthorityDefaults` bean 可以解决它

    @Bean
    GrantedAuthorityDefaults grantedAuthorityDefaults() {
        // Remove the ROLE_ prefix
        return new GrantedAuthorityDefaults("");
    }
    

预防老年痴呆，保持终身学习! —— [daidaidaiyu](https://www.cnblogs.com/dddy/)