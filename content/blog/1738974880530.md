---
layout: post
title: '并发编程 - 线程同步（四）之原子操作Interlocked详解一'
date: "2025-02-08T00:34:40Z"
---
并发编程 - 线程同步（四）之原子操作Interlocked详解一
=================================

本文介绍Interlocked类的使用，包括Read、Increment、Decrement和Add方法，适用于多线程环境安全操作变量，解决了非原子操作导致的线程安全问题，并提供示例代码。

上一章我们了解了原子操作Interlocked类的设计原理及简单介绍，今天我们将对Interlocked的使用进行详细讲解。

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250207092939280-420007594.jpg)

在此之前我们先学习一个概念——原子操作。

_**01**_、Read方法
===============

该方法用于原子的读取64位值，有分别针对long类型和ulong类型的两个重载方法；

对于64位系统，64位数据类型的读取本身就是原子操作；而对于32位系统，64位数据类型的读取需要至少两个原子指令，因此在32位系统可以通过Read方法对64位数据类型进行原子读取。

用法也很简单，示例如下：

    private static long _readValue = 0;
    public static void ReadRun()
    {
        var thread = new Thread(ModifyReadValue);
        thread.Start();
        Thread.Sleep(100);
        var value = Interlocked.Read(ref _readValue);
        Console.WriteLine("原子读取long类型变量: " + value);
    }
    static void ModifyReadValue()
    {
        _readValue = 88;
        Console.WriteLine("修改long类型变量: " + _readValue);
    }
    

运行结果如下：

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250207092932229-874151228.png)

因为系统环境原因无法模拟出32位系统效果，因此这里只是给了个简单使用示例。

_**02**_、Increment方法
====================

该方法用于原子的递增指定的变量，并返回递增后的新值。该方法有4个重载方法，分别为long、ulong、int和uint四种数据类型；该方法适用于多线程环境中需要安全递增变量的场景，如计数器、资源管理等。

对于加法操作，无论是i+1,还是i++或++i，都不是线程安全的，最终可能会生成3条CPU指令，整个操作过程大致如下：

1.将 i 的值加载到寄存器，即从内存中读取i；

2.将寄存器中值加1，即i值加1；

3.最后将寄存器中值回写到i，即完成i值的变更；

而在这编码层面为1行代码，而CPU层面为3行指令的操作中，随时都有可能被线程调度器打断，而导致其他线程同时对i进行操作，最终导致竞争条件，最后数据错乱。

下面我们来举个例子，启动100个线程，分别对一个共享变量进行1000次递增1，最后打印出共享变量，运行这个示例9次观察每次运行结果，代码如下：

    private static long _incrementValue = 0;
    public static void IncrementRun()
    {
        //运行9次测试，观察每次结果
        for (var i = 1; i < 10; i++)
        {
            //启动100个线程，对变量进行递增
            var threads = new Thread[100];
            for (var j = 0; j < threads.Length; j++)
            {
                threads[j] = new Thread(ModifyIncrementValue);
                threads[j].Start();
            }
            //等待所有线程执行完成
            foreach (var thread in threads)
            {
                thread.Join();
            }
            //最后打印结果
            Console.WriteLine($"第 {i} 运行结果: {_incrementValue}");
            _incrementValue = 0;
        }
    }
    static void ModifyIncrementValue()
    {
        for (var i = 0; i < 1000; i++)
        {
            ++_incrementValue;
        }
    }
    

先看下执行结果：

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250207092921203-1884641789.png)

可以发现每次的运行结果都不相同，并且结果也不对。这就是因为++i操作并不是原子操作，是线程不安全的。

只需要把上面代码：

    ++_incrementValue;
    

改为：

    Interlocked.Increment(ref _incrementValue);
    

即可解决上面的问题，修改过后，我们再来看看执行结果：

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250207092912443-834303041.png)

_**03**_、Decrement方法
====================

该方法用于原子的递减指定的变量，并返回递减后的新值。该方法同样有4个重载方法，分别为long、ulong、int和uint四种数据类型；

该方法和Increment方法基本一样，区别就是一个是递增一个是递减，因此用法可以直接参考Increment方法，这里就不做详细讲解了。

_**04**_、Add方法
==============

该方法用于原子的对两个变量求和，将第一个变量替换为两者和，并返回操作后第一个变量的新值。该方法同样有4个重载方法，分别为long、ulong、int和uint四种数据类型；

虽然这个方法叫求和是加法，但是只需要把第2个参数变为负数，既可以实现减法。简单来说该方法可以实现原子的对两个变量求和与求差。

上面Increment方法和Decrement方法，只能对变量每次进行递增递减1，而能随意加减，可以通过Add方法实现两个变量进行加减。

下面我们用代码实现累加和累减示例用来说明Add使用方法，就不展示线程安全差异了，可以参考Increment方法中的示例，自己写一个线程不安全的示例。

    private static long _addValue = 0;
    public static void AddRun()
    {
        for (var j = 0; j < 1000; j++)
        {
            //_addValue =_ addValue + j;
            Interlocked.Add(ref _addValue, j);
        }
        Console.WriteLine($"累加结果: {_addValue}");
        _addValue = 0;
        for (var j = 0; j < 1000; j++)
        {
            //_addValue =_ addValue - j;
            Interlocked.Add(ref _addValue, -j);
        }
        Console.WriteLine($"累减结果: {_addValue}");
    }
    

执行结果如下：

![](https://img2024.cnblogs.com/blog/386841/202502/386841-20250207092902587-1160289413.png)

_**注**_：测试方法代码以及示例源码都已经上传至代码库，有兴趣的可以看看。[https://gitee.com/hugogoos/Planner](https://gitee.com/hugogoos/Planner)