---
layout: post
title: '.NET 10 & C# 14 New Features 新增功能介绍-扩展成员Extension Members'
date: "2026-02-20T00:55:58Z"
---
.NET 10 & C# 14 New Features 新增功能介绍-扩展成员Extension Members
=========================================================

C# 14 引入了对扩展成员（Extension Members）的增强支持，本质上是对传统“扩展方法”模型的一次语言级升级，使其可以定义的不再仅限于方法，

而是可以扩展更多成员形态（例如属性、运算符等）。

**一、从扩展方法到扩展成员**

早在 C# 3.0 中，就引入了“扩展方法（Extension Methods）”，其底层机制是：

*   必须定义在 static class
    
*   方法必须是 static
    
*   第一个参数使用 this T
    

public static class StringExtensions
{
    public static bool IsNullOrEmptyEx(this string value)
        \=> string.IsNullOrEmpty(value);
}

从本质上看：

> 编译器在语法层面做“糖化处理”，最终仍然是静态方法调用。

LINQ就是最大的应用场景。

**二、C# 14中引入扩展成员和示例说明**

C# 14 允许在更自然的语法结构中声明扩展成员，不再局限于“静态类 + this 参数”模式，而是支持类似：

public static class Enumerable
{
    // Extension block
    extension<TSource>(IEnumerable<TSource> source) // extension members for IEnumerable<TSource>
    {
        // Extension property:
        public bool IsEmpty => !source.Any();

        // Extension method:
        public IEnumerable<TSource> Where(Func<TSource, bool\> predicate) { ... }
    }

    // extension block, with a receiver type only
    extension<TSource>(IEnumerable<TSource>) // static extension members for IEnumerable<Source>
    {
        // static extension method:
        public static IEnumerable<TSource> Combine(IEnumerable<TSource> first, IEnumerable<TSource> second) { ... }

        // static extension property:
        public static IEnumerable<TSource> Identity => Enumerable.Empty<TSource>();

        // static user defined operator:
        public static IEnumerable<TSource> operator + (IEnumerable<TSource> left, IEnumerable<TSource> right) => left.Concat(right);
    }
}

定义的是一个 extension block，目标类型是：IEnumerable<TSource>

代码分成两类 extension block：　　

1.  **实例扩展成员**
    
2.  **静态扩展成员**
    

① 实例扩展成员：extension<TSource>(IEnumerable<TSource> source) 

*   source 是接收者（receiver）
    
*   类似旧语法的 this IEnumerable<TSource> source
    
*   但语法更接近真正“为类型添加成员”
    

 扩展属性：public bool IsEmpty => !source.Any();

 编译器会生成：public static bool get\_IsEmpty<TSource>(IEnumerable<TSource> source)

 代码调用：list.IsEmpty

 会被编译为：Enumerable.get\_IsEmpty(list)

 其本质仍然是：

> 静态方法 + 语法糖绑定

但在语义层面：它已经不再是“工具方法”，而是“类型能力”。

扩展方法：public IEnumerable<TSource> Where(Func<TSource, bool> predicate)

即增强原有LINQ的Where功能

如果系统中已有 System.Linq.Enumerable.Where：

*   实例成员优先
    
*   然后才是 extension block
    
*   再是 using 引入的扩展方法
    

 不会破坏已有 API，只是参与候选集。

② 静态扩展成员

extension<TSource>(IEnumerable<TSource>)

这里没有 receiver 变量名。

> 为类型本身添加“静态扩展成员”

找一个静态扩展方法

public static IEnumerable<TSource> Combine(...)

代码调用：IEnumerable<int>.Combine(a, b);

编译器会转化为：Enumerable.Combine(a, b);

再看一个静态扩展属性

public static IEnumerable<TSource> Identity

代码调用：IEnumerable<int>.Identity

这在旧扩展方法体系中是无法表达的。

再看一个扩展运算符

public static IEnumerable<TSource> operator +

这是 C# 14 的重大增强点。现在你可以写：

var result = list1 + list2;

等价于：Enumerable.op\_Addition(list1, list2);

**三、底层编译机制**

 **不修改 CLR 元数据**

*   不改变 IEnumerable<T>
    
*   不增加真实成员
    

 **IL 仍然是静态方法**

   所有成员都会生成： public static ...

 **语义绑定由编译器完成**

扩展成员解析规则：

1.  实例真实成员
    
2.  同 namespace extension block
    
3.  using 导入 extension block
    

 **四、与传统扩展方法对比**

   ![image](https://img2024.cnblogs.com/blog/23525/202602/23525-20260218111804828-477864692.png)

同时，零运行时开销。

*   无反射
    
*   无动态代理
    
*   无装饰器
    
*   无运行时注入
    

 完全编译期绑定。

> 编译器级语义增强，不改变运行时类型结构。

 以上分享给大家。

周国庆

20260218