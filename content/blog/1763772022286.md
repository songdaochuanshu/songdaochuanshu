---
layout: post
title: '一次编译器优化的陷阱'
date: "2025-11-22T00:40:22Z"
---
一次编译器优化的陷阱
==========

本文分享自天翼云开发者社区《[一次编译器优化的陷阱](https://www.ctyun.cn/developer/article/462372091191365)》.作者：江\*\*\*\*禄

某次问题排查，最终隐掉完所有业务逻辑后， 化简为如下的简单代码：

来看一下，这个的bcount is zero 会打印吗？

    #include <time.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <cstring>
    #include <string.h>
    #include <unistd.h>
    
    int
    main(void)
    {
      int bcount = 2;
    
      while (bcount < 1296005092) {
         if (bcount < 1296005092) {
           printf("b %lld (%d)%x is <  than %lld\n",bcount,bcount, bcount,1296005092);
         } else {
           printf("b %lld (%d)%x is >= than %lld\n",bcount,bcount,bcount, 1296005092);
         }
         sleep(1);
    
         if (bcount == 0) {
          printf("bcount is zero\r\n");
           return -1;
         }
         bcount *= 2;
      }
    
      return 0;
    }
    

这个demo代码的逻辑为：

while循环中比较bcount与1296005092的大小，当bcount >=1296005092或者 bcount为0，结束循环。

使用gcc  -O2优化编译后，查看demo程序的输出如下，可以看到，会导致一直在while死循环， 原因是bcount为int 。 然后待比较的那个数 刚好卡

在一个区间，具体如下：当bcount ==0x80000000时候，bcount最高位为1， 这样该数为负数，小于待比较的数1296005092，注意：

上一次循环中，由于上一个值0x40000000的时候刚好比1296005092小，然后此次循环结果为负数，而下一个循环这个int溢出结果为0 ，所以一直

卡在这里。那么问题就变成了：其中的bcount==0 不会生效？？

使用-O1编译后，查看demo代码的输出如下， 可以看到while循环中可以判断到bcount为0.

结论
--

简化代码，对比两者汇编代码的区别如下,

可以看到在gcc的O2优化等级上，如果是乘2运算，优化后的代码认为结果不应该为0。

到此为止，这里如果将代码中的bcount乘2运算，替换为左移一位，在O2模式下编译，while循环也可以正常退出。

这里应该是gcc的O2等级以上优化逻辑有bug，在整数乘法运算下，编译器认为不可能出现结果为0，将代码中与0的判断优化掉，导致优化后的代码

逻辑不符合预期。