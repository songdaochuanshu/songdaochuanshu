---
layout: post
title: 'python代码封装成可执行文件'
date: "2025-12-02T00:43:33Z"
---
python代码封装成可执行文件
================

首先确保python源码可以成功运行  
之后执行命令如下  
python -m pip install pyinstaller  
先使用命令下载安装pyinstaller打包工具  
之后直接在脚本所在的目录下执行打包命令(打包成单个exe文件)  
pyinstaller -F -w -i icon.ico your\_script\_name.py

\-F：打包成单个可执行文件（方便分发）  
\-w：不显示控制台窗口（GUI 程序必备）  
\-i icon.ico：设置程序图标（可选，需提前准备.ico 格式图标）  
your\_script\_name.py：你的脚本文件名（比如email\_sender.py）  
执行成功后会在目录中生成个dist文件  
将dist文件夹中的 exe 文件（及所需配置文件）分发给用户，双击即可运行，无需安装 Python 或任何依赖！

注意事项  
1\. 运行路径问题：打包后的 exe 会在自身所在目录读写文件（如email\_config.json、secret.key），需确保这些文件与 exe 同目录  
2\. 杀毒软件误报：部分杀毒软件可能误报打包后的 exe，可添加信任  
3\. 兼容性：在 32 位系统打包的 exe 可在 32/64 位系统运行，64 位系统打包的 exe 仅能在 64 位系统运行

  
我的python代码如下:

import sys
import smtplib
import time
import datetime
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header
from email.utils import formataddr
import json
import os
from cryptography.fernet import Fernet
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
QLineEdit, QTextEdit, QPushButton, QLabel, QFileDialog,
QComboBox, QDateTimeEdit, QCheckBox, QTableWidget,
QTableWidgetItem, QMessageBox, QGroupBox, QSpinBox)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QFont
import pandas as pd

# -------------------------- 工具类 --------------------------
class EmailConfig:
"""邮箱配置管理（加密保存）"""
CONFIG\_FILE \= "email\_config.json"
KEY\_FILE \= "secret.key"

@classmethod
def generate\_key(cls):
"""生成加密密钥"""
if not os.path.exists(cls.KEY\_FILE):
key \= Fernet.generate\_key()
with open(cls.KEY\_FILE, "wb") as f:
f.write(key)
return open(cls.KEY\_FILE, "rb").read()

@classmethod
def encrypt(cls, data):
"""加密数据"""
key \= cls.generate\_key()
fernet \= Fernet(key)
return fernet.encrypt(data.encode()).decode()

@classmethod
def decrypt(cls, encrypted\_data):
"""解密数据"""
key \= cls.generate\_key()
fernet \= Fernet(key)
return fernet.decrypt(encrypted\_data.encode()).decode()

@classmethod
def save\_config(cls, sender\_email, password, smtp\_server, smtp\_port):
"""保存配置"""
config \= {
"sender\_email": sender\_email,
"password": cls.encrypt(password),
"smtp\_server": smtp\_server,
"smtp\_port": smtp\_port
}
with open(cls.CONFIG\_FILE, "w", encoding="utf-8") as f:
json.dump(config, f, indent\=2)

@classmethod
def load\_config(cls):
"""加载配置"""
if not os.path.exists(cls.CONFIG\_FILE):
return None
with open(cls.CONFIG\_FILE, "r", encoding="utf-8") as f:
config \= json.load(f)
config\["password"\] = cls.decrypt(config\["password"\])
return config

class EmailSender:
"""邮件发送核心类"""
@staticmethod
def create\_email(sender, receiver, subject, content, is\_html=False, attachments=None):
"""创建邮件对象"""
msg \= MIMEMultipart()
# 发件人/收件人/主题
msg\["From"\] = formataddr(("自动邮件助手", sender))
msg\["To"\] = receiver if isinstance(receiver, str) else ",".join(receiver)
msg\["Subject"\] = Header(subject, "utf-8")

# 正文
msg.attach(MIMEText(content, "html" if is\_html else "plain", "utf-8"))

# 附件
if attachments:
for file\_path in attachments:
if os.path.exists(file\_path):
with open(file\_path, "rb") as f:
part \= MIMEText(f.read(), "base64", "utf-8")
part\["Content-Type"\] = "application/octet-stream"
filename \= os.path.basename(file\_path)
part\["Content-Disposition"\] = f'attachment; filename="{filename}"'
msg.attach(part)
return msg

@staticmethod
def send\_email(smtp\_server, smtp\_port, sender\_email, password, receiver\_email, subject, content, is\_html=False, attachments=None):
"""发送单封邮件"""
try:
# 创建邮件
msg = EmailSender.create\_email(sender\_email, receiver\_email, subject, content, is\_html, attachments)

# 连接SMTP服务器
server = smtplib.SMTP\_SSL(smtp\_server, smtp\_port) if smtp\_port == 465 else smtplib.SMTP(smtp\_server, smtp\_port)
server.login(sender\_email, password)

# 发送邮件（支持多个收件人）
receivers = \[receiver\_email\] if isinstance(receiver\_email, str) else receiver\_email
server.sendmail(sender\_email, receivers, msg.as\_string())
server.quit()
return True, "发送成功"
except Exception as e:
return False, str(e)

# -------------------------- 线程类（避免UI卡死） --------------------------
class SendEmailThread(QThread):
"""邮件发送线程"""
finish\_signal \= pyqtSignal(bool, str) # 单个发送结果
log\_signal = pyqtSignal(str, str, str) # 日志信号（时间、收件人、状态）
all\_finish\_signal = pyqtSignal() # 全部发送完成

def \_\_init\_\_(self, config, receivers, subject, content, is\_html, attachments, delay=1):
super().\_\_init\_\_()
self.config \= config # 邮箱配置
self.receivers = receivers # 收件人列表
self.subject = subject
self.content \= content
self.is\_html \= is\_html
self.attachments \= attachments
self.delay \= delay # 发送间隔（避免被邮箱服务器限流）
self.is\_running = True

def stop(self):
self.is\_running \= False

def run(self):
for receiver in self.receivers:
if not self.is\_running:
self.log\_signal.emit(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), receiver, "发送取消")
break

success, msg \= EmailSender.send\_email(
smtp\_server\=self.config\["smtp\_server"\],
smtp\_port\=self.config\["smtp\_port"\],
sender\_email\=self.config\["sender\_email"\],
password\=self.config\["password"\],
receiver\_email\=receiver.strip(),
subject\=self.subject,
content\=self.content,
is\_html\=self.is\_html,
attachments\=self.attachments
)

log\_time \= datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
log\_status \= f"成功: {msg}" if success else f"失败: {msg}"
self.log\_signal.emit(log\_time, receiver.strip(), log\_status)

# 发送间隔
time.sleep(self.delay)

self.all\_finish\_signal.emit()

class TimerSendThread(QThread):
"""定时发送线程"""
timer\_signal \= pyqtSignal(str) # 倒计时信号
start\_send\_signal = pyqtSignal() # 开始发送信号

def \_\_init\_\_(self, target\_time):
super().\_\_init\_\_()
self.target\_time \= target\_time
self.is\_running \= True

def stop(self):
self.is\_running \= False

def run(self):
while self.is\_running:
now \= datetime.datetime.now()
diff \= (self.target\_time - now).total\_seconds()
if diff <= 0:
self.start\_send\_signal.emit()
break

# 计算倒计时
hours = int(diff // 3600)
minutes \= int((diff % 3600) // 60)
seconds \= int(diff % 60)
self.timer\_signal.emit(f"{hours:02d}:{minutes:02d}:{seconds:02d}")
time.sleep(1)

# -------------------------- 主窗口类 --------------------------
class AutoEmailSender(QMainWindow):
def \_\_init\_\_(self):
super().\_\_init\_\_()
self.setWindowTitle("自动邮件发送助手")
self.setGeometry(100, 100, 1000, 700)
self.setMinimumSize(800, 600)

# 初始化变量
self.attachments = \[\] # 附件列表
self.receivers = \[\] # 收件人列表
self.send\_thread = None
self.timer\_thread \= None

# 加载配置
self.config = EmailConfig.load\_config()

# 初始化UI
self.init\_ui()

def init\_ui(self):
"""构建UI界面"""
central\_widget \= QWidget()
self.setCentralWidget(central\_widget)
main\_layout \= QVBoxLayout(central\_widget)
main\_layout.setSpacing(15)
main\_layout.setContentsMargins(20, 20, 20, 20)

# 1. 邮箱配置区域
config\_group = QGroupBox("邮箱配置")
config\_group.setFont(QFont("Arial", 11))
config\_layout \= QGridLayout(config\_group)

# 标签和输入框
labels = \["发件人邮箱", "授权码/密码", "SMTP服务器", "SMTP端口"\]
self.config\_inputs \= {}
smtp\_servers \= {
"QQ邮箱": ("smtp.qq.com", 465),
"163邮箱": ("smtp.163.com", 465),
"Gmail": ("smtp.gmail.com", 587),
"企业邮箱": ("smtp.exmail.qq.com", 465)
}

self.smtp\_combo \= QComboBox()
self.smtp\_combo.addItems(smtp\_servers.keys())
self.smtp\_combo.currentTextChanged.connect(self.on\_smtp\_change)
self.port\_input \= QSpinBox()
self.port\_input.setRange(1, 65535)

# 加载默认SMTP配置
default\_smtp = "QQ邮箱"
self.smtp\_combo.setCurrentText(default\_smtp)
self.on\_smtp\_change(default\_smtp)

# 添加到布局
for i, label\_text in enumerate(labels):
label \= QLabel(label\_text)
label.setFont(QFont("Arial", 10))
config\_layout.addWidget(label, i, 0, 1, 1)

if label\_text == "SMTP服务器":
config\_layout.addWidget(self.smtp\_combo, i, 1, 1, 2)
elif label\_text == "SMTP端口":
config\_layout.addWidget(self.port\_input, i, 1, 1, 2)
else:
input\_box \= QLineEdit()
input\_box.setFont(QFont("Arial", 10))
if label\_text == "授权码/密码":
input\_box.setEchoMode(QLineEdit.EchoMode.Password)
self.config\_inputs\[label\_text\] \= input\_box
config\_layout.addWidget(input\_box, i, 1, 1, 2)

# 保存配置按钮
save\_btn = QPushButton("保存配置")
save\_btn.clicked.connect(self.save\_config)
config\_layout.addWidget(save\_btn, 4, 1, 1, 2)

# 加载已保存的配置
if self.config:
self.config\_inputs\["发件人邮箱"\].setText(self.config\["sender\_email"\])
self.config\_inputs\["授权码/密码"\].setText(self.config\["password"\])
self.smtp\_combo.setCurrentText(self.get\_smtp\_name(self.config\["smtp\_server"\]))
self.port\_input.setValue(self.config\["smtp\_port"\])

main\_layout.addWidget(config\_group)

# 2. 收件人区域
receiver\_group = QGroupBox("收件人管理")
receiver\_group.setFont(QFont("Arial", 11))
receiver\_layout \= QVBoxLayout(receiver\_group)

# 收件人输入框和按钮
receiver\_hbox = QHBoxLayout()
self.receiver\_input \= QLineEdit()
self.receiver\_input.setPlaceholderText("输入单个收件人邮箱，或用逗号分隔多个邮箱")
self.receiver\_input.setFont(QFont("Arial", 10))
add\_receiver\_btn \= QPushButton("添加")
add\_receiver\_btn.clicked.connect(self.add\_receiver)
import\_btn \= QPushButton("导入文件")
import\_btn.clicked.connect(self.import\_receivers)
clear\_receiver\_btn \= QPushButton("清空")
clear\_receiver\_btn.clicked.connect(self.clear\_receivers)

receiver\_hbox.addWidget(self.receiver\_input)
receiver\_hbox.addWidget(add\_receiver\_btn)
receiver\_hbox.addWidget(import\_btn)
receiver\_hbox.addWidget(clear\_receiver\_btn)

# 收件人列表
self.receiver\_table = QTableWidget()
self.receiver\_table.setColumnCount(1)
self.receiver\_table.setHorizontalHeaderLabels(\["已添加收件人"\])
self.receiver\_table.horizontalHeader().setStretchLastSection(True)
self.receiver\_table.setFont(QFont("Arial", 10))

receiver\_layout.addLayout(receiver\_hbox)
receiver\_layout.addWidget(self.receiver\_table)
main\_layout.addWidget(receiver\_group)

# 3. 邮件内容区域
content\_group = QGroupBox("邮件内容")
content\_group.setFont(QFont("Arial", 11))
content\_layout \= QVBoxLayout(content\_group)

# 主题
subject\_hbox = QHBoxLayout()
subject\_label \= QLabel("主题：")
subject\_label.setFont(QFont("Arial", 10))
self.subject\_input \= QLineEdit()
self.subject\_input.setFont(QFont("Arial", 10))
subject\_hbox.addWidget(subject\_label)
subject\_hbox.addWidget(self.subject\_input)

# 正文
content\_label = QLabel("正文：")
content\_label.setFont(QFont("Arial", 10))
self.content\_edit \= QTextEdit()
self.content\_edit.setFont(QFont("Arial", 10))
self.content\_edit.setPlaceholderText("支持HTML格式（需勾选下方选项）")

# HTML选项
self.html\_checkbox = QCheckBox("使用HTML格式")
self.html\_checkbox.setFont(QFont("Arial", 10))

content\_layout.addLayout(subject\_hbox)
content\_layout.addWidget(content\_label)
content\_layout.addWidget(self.content\_edit)
content\_layout.addWidget(self.html\_checkbox)
main\_layout.addWidget(content\_group)

# 4. 附件区域
attachment\_group = QGroupBox("附件管理")
attachment\_group.setFont(QFont("Arial", 11))
attachment\_layout \= QVBoxLayout(attachment\_group)

attachment\_hbox \= QHBoxLayout()
self.attachment\_label \= QLabel("未添加附件")
self.attachment\_label.setFont(QFont("Arial", 10))
add\_attach\_btn \= QPushButton("添加附件")
add\_attach\_btn.clicked.connect(self.add\_attachment)
clear\_attach\_btn \= QPushButton("清空附件")
clear\_attach\_btn.clicked.connect(self.clear\_attachments)

attachment\_hbox.addWidget(self.attachment\_label)
attachment\_hbox.addStretch()
attachment\_hbox.addWidget(add\_attach\_btn)
attachment\_hbox.addWidget(clear\_attach\_btn)

attachment\_layout.addLayout(attachment\_hbox)
main\_layout.addWidget(attachment\_group)

# 5. 发送控制区域
control\_group = QGroupBox("发送控制")
control\_group.setFont(QFont("Arial", 11))
control\_layout \= QHBoxLayout(control\_group)

# 定时发送
self.timer\_checkbox = QCheckBox("定时发送")
self.timer\_checkbox.setFont(QFont("Arial", 10))
self.timer\_checkbox.stateChanged.connect(self.toggle\_timer)
self.timer\_edit \= QDateTimeEdit()
self.timer\_edit.setDateTime(datetime.datetime.now())
self.timer\_edit.setFont(QFont("Arial", 10))
self.timer\_edit.setEnabled(False)
self.countdown\_label \= QLabel("倒计时：--:--:--")
self.countdown\_label.setFont(QFont("Arial", 10, QFont.Weight.Bold))

# 发送间隔
delay\_label = QLabel("发送间隔（秒）：")
delay\_label.setFont(QFont("Arial", 10))
self.delay\_spin \= QSpinBox()
self.delay\_spin.setRange(1, 60)
self.delay\_spin.setValue(3)
self.delay\_spin.setFont(QFont("Arial", 10))

# 发送/停止按钮
self.send\_btn = QPushButton("开始发送")
self.send\_btn.clicked.connect(self.start\_send)
self.send\_btn.setFont(QFont("Arial", 10, QFont.Weight.Bold))
self.stop\_btn \= QPushButton("停止发送")
self.stop\_btn.clicked.connect(self.stop\_send)
self.stop\_btn.setFont(QFont("Arial", 10, QFont.Weight.Bold))
self.stop\_btn.setEnabled(False)

control\_layout.addWidget(self.timer\_checkbox)
control\_layout.addWidget(self.timer\_edit)
control\_layout.addWidget(self.countdown\_label)
control\_layout.addStretch()
control\_layout.addWidget(delay\_label)
control\_layout.addWidget(self.delay\_spin)
control\_layout.addSpacing(20)
control\_layout.addWidget(self.send\_btn)
control\_layout.addWidget(self.stop\_btn)

main\_layout.addWidget(control\_group)

# 6. 日志区域
log\_group = QGroupBox("发送日志")
log\_group.setFont(QFont("Arial", 11))
log\_layout \= QVBoxLayout(log\_group)

self.log\_table \= QTableWidget()
self.log\_table.setColumnCount(3)
self.log\_table.setHorizontalHeaderLabels(\["时间", "收件人", "状态"\])
self.log\_table.horizontalHeader().setStretchLastSection(True)
self.log\_table.setFont(QFont("Arial", 10))

log\_layout.addWidget(self.log\_table)
main\_layout.addWidget(log\_group, 1) # 占剩余空间

def on\_smtp\_change(self, smtp\_name):
"""SMTP服务器选择变化"""
smtp\_servers \= {
"QQ邮箱": ("smtp.qq.com", 465),
"163邮箱": ("smtp.163.com", 465),
"Gmail": ("smtp.gmail.com", 587),
"企业邮箱": ("smtp.exmail.qq.com", 465)
}
server, port \= smtp\_servers\[smtp\_name\]
self.port\_input.setValue(port)

def get\_smtp\_name(self, server):
"""根据服务器地址获取SMTP名称"""
smtp\_servers \= {
"smtp.qq.com": "QQ邮箱",
"smtp.163.com": "163邮箱",
"smtp.gmail.com": "Gmail",
"smtp.exmail.qq.com": "企业邮箱"
}
return smtp\_servers.get(server, "企业邮箱")

def save\_config(self):
"""保存邮箱配置"""
sender\_email \= self.config\_inputs\["发件人邮箱"\].text().strip()
password \= self.config\_inputs\["授权码/密码"\].text().strip()
smtp\_server \= {
"QQ邮箱": "smtp.qq.com",
"163邮箱": "smtp.163.com",
"Gmail": "smtp.gmail.com",
"企业邮箱": "smtp.exmail.qq.com"
}\[self.smtp\_combo.currentText()\]
smtp\_port \= self.port\_input.value()

if not sender\_email or not password:
QMessageBox.warning(self, "警告", "发件人邮箱和密码不能为空！")
return

EmailConfig.save\_config(sender\_email, password, smtp\_server, smtp\_port)
self.config \= EmailConfig.load\_config()
QMessageBox.information(self, "成功", "配置保存成功！")

def add\_receiver(self):
"""添加收件人"""
receiver\_text \= self.receiver\_input.text().strip()
if not receiver\_text:
QMessageBox.warning(self, "警告", "请输入收件人邮箱！")
return

# 支持逗号分隔多个邮箱
receivers = \[r.strip() for r in receiver\_text.split(",") if r.strip()\]
for receiver in receivers:
if receiver not in self.receivers:
self.receivers.append(receiver)
self.update\_receiver\_table()

self.receiver\_input.clear()

def import\_receivers(self):
"""导入收件人文件（TXT/Excel）"""
file\_path, \_ \= QFileDialog.getOpenFileName(self, "选择收件人文件", "", "文件 (\*.txt \*.xlsx \*.xls)")
if not file\_path:
return

try:
receivers \= \[\]
if file\_path.endswith(".txt"):
with open(file\_path, "r", encoding="utf-8") as f:
receivers \= \[line.strip() for line in f if line.strip()\]
else: # Excel
df = pd.read\_excel(file\_path)
receivers \= df.iloc\[:, 0\].dropna().astype(str).tolist()

# 去重并添加
new\_receivers = \[r for r in receivers if r not in self.receivers\]
self.receivers.extend(new\_receivers)
self.update\_receiver\_table()
QMessageBox.information(self, "成功", f"导入成功！新增 {len(new\_receivers)} 个收件人")
except Exception as e:
QMessageBox.warning(self, "错误", f"导入失败：{str(e)}")

def update\_receiver\_table(self):
"""更新收件人表格"""
self.receiver\_table.setRowCount(len(self.receivers))
for i, receiver in enumerate(self.receivers):
item \= QTableWidgetItem(receiver)
item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
self.receiver\_table.setItem(i, 0, item)

def clear\_receivers(self):
"""清空收件人"""
self.receivers.clear()
self.update\_receiver\_table()

def add\_attachment(self):
"""添加附件"""
file\_paths, \_ \= QFileDialog.getOpenFileNames(self, "选择附件", "", "所有文件 (\*.\*)")
if not file\_paths:
return

self.attachments.extend(\[f for f in file\_paths if f not in self.attachments\])
self.update\_attachment\_label()

def update\_attachment\_label(self):
"""更新附件标签"""
if not self.attachments:
self.attachment\_label.setText("未添加附件")
else:
self.attachment\_label.setText(f"已添加 {len(self.attachments)} 个附件：{', '.join(\[os.path.basename(f) for f in self.attachments\[:3\]\])}{'...' if len(self.attachments) > 3 else ''}")

def clear\_attachments(self):
"""清空附件"""
self.attachments.clear()
self.update\_attachment\_label()

def toggle\_timer(self):
"""切换定时发送状态"""
self.timer\_edit.setEnabled(self.timer\_checkbox.isChecked())

def start\_send(self):
"""开始发送邮件"""
# 验证配置
if not self.config:
QMessageBox.warning(self, "警告", "请先配置并保存邮箱信息！")
return

# 验证收件人
if not self.receivers:
QMessageBox.warning(self, "警告", "请添加至少一个收件人！")
return

# 验证邮件内容
subject = self.subject\_input.text().strip()
content \= self.content\_edit.toPlainText().strip()
if not subject or not content:
QMessageBox.warning(self, "警告", "主题和正文不能为空！")
return

# 定时发送
if self.timer\_checkbox.isChecked():
target\_time \= self.timer\_edit.dateTime().toPyDateTime()
now \= datetime.datetime.now()
if target\_time <= now:
QMessageBox.warning(self, "警告", "定时时间必须晚于当前时间！")
return

# 启动定时线程
self.timer\_thread = TimerSendThread(target\_time)
self.timer\_thread.timer\_signal.connect(self.update\_countdown)
self.timer\_thread.start\_send\_signal.connect(self.do\_send)
self.timer\_thread.start()
self.send\_btn.setEnabled(False)
self.stop\_btn.setEnabled(True)
QMessageBox.information(self, "提示", f"定时发送已设置！将在 {target\_time.strftime('%Y-%m-%d %H:%M:%S')} 开始发送")
else:
# 立即发送
self.do\_send()

def do\_send(self):
"""执行发送（真正的发送逻辑）"""
# 构建配置
send\_config = {
"sender\_email": self.config\["sender\_email"\],
"password": self.config\["password"\],
"smtp\_server": self.config\["smtp\_server"\],
"smtp\_port": self.config\["smtp\_port"\]
}

# 获取邮件信息
subject = self.subject\_input.text().strip()
content \= self.content\_edit.toPlainText().strip()
is\_html \= self.html\_checkbox.isChecked()
delay \= self.delay\_spin.value()

# 启动发送线程
self.send\_thread = SendEmailThread(send\_config, self.receivers, subject, content, is\_html, self.attachments, delay)
self.send\_thread.log\_signal.connect(self.add\_log)
self.send\_thread.all\_finish\_signal.connect(self.send\_finish)
self.send\_thread.start()

# 更新按钮状态
self.send\_btn.setEnabled(False)
self.stop\_btn.setEnabled(True)
self.countdown\_label.setText("发送中...")

def stop\_send(self):
"""停止发送"""
if self.timer\_thread and self.timer\_thread.isRunning():
self.timer\_thread.stop()
self.timer\_thread.wait()
self.countdown\_label.setText("倒计时：--:--:--")

if self.send\_thread and self.send\_thread.isRunning():
self.send\_thread.stop()
self.send\_thread.wait()

self.send\_btn.setEnabled(True)
self.stop\_btn.setEnabled(False)
self.add\_log(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), "系统", "发送已取消")

def send\_finish(self):
"""发送完成"""
self.send\_btn.setEnabled(True)
self.stop\_btn.setEnabled(False)
self.countdown\_label.setText("发送完成！")
QMessageBox.information(self, "提示", "所有邮件发送完成！")

def add\_log(self, time\_str, receiver, status):
"""添加发送日志"""
row \= self.log\_table.rowCount()
self.log\_table.insertRow(row)

# 时间
time\_item = QTableWidgetItem(time\_str)
time\_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
self.log\_table.setItem(row, 0, time\_item)

# 收件人
receiver\_item = QTableWidgetItem(receiver)
receiver\_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
self.log\_table.setItem(row, 1, receiver\_item)

# 状态（成功绿色，失败红色）
status\_item = QTableWidgetItem(status)
if "成功" in status:
status\_item.setForeground(Qt.GlobalColor.green)
else:
status\_item.setForeground(Qt.GlobalColor.red)
status\_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
self.log\_table.setItem(row, 2, status\_item)

# 滚动到最后一行
self.log\_table.scrollToBottom()

def update\_countdown(self, countdown\_str):
"""更新倒计时"""
self.countdown\_label.setText(f"倒计时：{countdown\_str}")

def closeEvent(self, event):
"""关闭窗口时停止线程"""
if self.send\_thread and self.send\_thread.isRunning():
self.send\_thread.stop()
self.send\_thread.wait()
if self.timer\_thread and self.timer\_thread.isRunning():
self.timer\_thread.stop()
self.timer\_thread.wait()
event.accept()

# -------------------------- 主函数 --------------------------
if \_\_name\_\_ == "\_\_main\_\_":
app \= QApplication(sys.argv)
window \= AutoEmailSender()
window.show()
sys.exit(app.exec())

以上是一个邮件群发系统,方便同事联系客户,进行群发