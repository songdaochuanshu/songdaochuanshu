---
layout: post
title: 'Spring IOC 源码学习 一文学习完整的加载流程'
date: "2026-01-14T00:47:34Z"
---
Spring IOC 源码学习 一文学习完整的加载流程
===========================

IOC 的入口说明
=========

ApplicationContext 对象
---------------------

**in short 可以理解为作为具现化的 IOC 的对象根接口, 它是一个重量级的对象, 整个应用期间应该保持单例**

官文 Container Overview: [https://docs.spring.io/spring-framework/reference/core/beans/basics.html](https://docs.spring.io/spring-framework/reference/core/beans/basics.html)

> The `org.springframework.context.ApplicationContext` interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on the components to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata can be represented as annotated component classes, configuration classes with factory methods, or external XML files or Groovy scripts.

> `org.springframework.context.ApplicationContext` 接口代表 Spring IoC 容器，负责实例化、配置和组装 bean。容器通过读取配置元数据来获取实例化、配置和组装组件的指令。配置元数据可以表示为带注解的组件类、具有工厂方法的配置类，或外部 XML 文件或 Groovy 脚本。

Several implementations of the `ApplicationContext` interface are part of core Spring. In stand-alone applications, it is common to create an instance of [`AnnotationConfigApplicationContext`](https://docs.spring.io/spring-framework/docs/7.0.1/javadoc-api/org/springframework/context/annotation/AnnotationConfigApplicationContext.html) or [`ClassPathXmlApplicationContext`](https://docs.spring.io/spring-framework/docs/7.0.1/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html).

> `ApplicationContext` 接口有多个实现 , 是Spring 核心的一部分。在独立应用程序中，通常创建 [`AnnotationConfigApplicationContext`](https://docs.spring.io/spring-framework/docs/7.0.1/javadoc-api/org/springframework/context/annotation/AnnotationConfigApplicationContext.html) or [`ClassPathXmlApplicationContext`](https://docs.spring.io/spring-framework/docs/7.0.1/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html) 的实例。

XML和注解 配置的 ApplicationContext
-----------------------------

我们通常使用 Spring IOC 配置容器的方式一般有两种: 1. 通过XML配置文件, 2. 基于注解的形式配置, 它们分别是入口类不一样.

1.  基于XML配置, 实际有两个类实现 **ClassPathXmlApplicationContext** 还有一个是 **FileSystemXmlApplicationContext** (很少用就是了) 它们主要的代码逻辑都是在它父 `AbstractXmlApplicationContext` 中.
    
2.  基于注解的形式配置, [Annotation-based configuration](https://docs.spring.io/spring-framework/reference/core/beans/annotation-config.html) 基于 Spring 自定义, 使用[`AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/reference/core/beans/factory-extension.html#beans-factory-extension-bpp-examples-aabpp) 处理解析相关注解的实现, 另外 JSR 330 中标准的注解也是它处理的.
    

本博文以 XML 加载作为源码入口点进行分析:

上汇总大图
=====

真的很大的大图..

看不清, 请使用原生浏览器打开链接: [https://img2024.cnblogs.com/blog/3723410/202601/3723410-20260113220603061-1916535706.jpg](https://img2024.cnblogs.com/blog/3723410/202601/3723410-20260113220603061-1916535706.jpg)

XML 实例入口
========

实例代码
----

`org.yang.learn.spring.dto.Address`

    package org.yang.learn.spring.dto;
    
    import org.springframework.beans.BeansException;
    import org.springframework.beans.factory.config.BeanPostProcessor;
    
    /**
     * @author yangfh
     * @date 2023-12-14 21:30
     **/
    public class Address  {
    	String city;
    	String country;
    	String street;
    
    	public Address() {
    		System.out.println("Address 无参构造函数: "+ this.toString());
    	}
    
    	public Address(String city, String country, String street) {
    		this.city = city;
    		this.country = country;
    		this.street = street;
    		System.out.println("Address 构造函数: "+ this.toString());
    	}
    	... getter  setter ...
    }
    
    

`org.yang.learn.spring.dto.User`

    package org.yang.learn.spring.dto;
    
    import org.springframework.beans.BeansException;
    import org.springframework.beans.factory.DisposableBean;
    import org.springframework.beans.factory.InitializingBean;
    import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
    import org.springframework.beans.factory.config.BeanPostProcessor;
    import org.springframework.core.PriorityOrdered;
    import org.springframework.lang.Nullable;
    
    /**
     * @author yangfh
     * @date 2023-12-14 21:30
     **/
    public class User implements InitializingBean, DisposableBean {
    	private Long id;
    	private String username;
    	private String email;
    	private Address address;
    	private Long age;
    
    	public User() {
    		System.out.println("User 无参构造函数: "+ this.toString());
    	}
    
    	public User(Long id, String username, String email, Address address) {
    		this.id = id;
    		this.username = username;
    		this.email = email;
    		this.address = address;
    		System.out.println("User 有参构造函数: "+ this.toString());
    	}
    
    	public void initMethod(){
    		System.out.println("User initMethod");
    	}
    
    	public void destroyMethod(){
    		System.out.println("User destroyMethod");
    	}
    
    	@Override
    	public void afterPropertiesSet() throws Exception {
    		System.out.println("User afterPropertiesSet");
    	}
    
    	@Override
    	public void destroy() throws Exception {
    		System.out.println("User destroy");
    	}
    	
    	
    	... getter  setter ...
    }
    

`org.yang.learn.spring.dto.UserServiceImpl`

    public class UserServiceImpl implements BeanPostProcessor, BeanFactoryPostProcessor, ApplicationContextAware {
    	public UserServiceImpl(){
    		System.out.println("UserServiceImpl 无参构造");
    	}
    
    	@Override
    	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    		System.out.println("UserServiceImpl postProcessBeforeInitialization 增强处理 ["+beanName+"]");
    		return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);
    	}
    
    	@Override
    	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    		System.out.println("UserServiceImpl postProcessAfterInitialization 增强处理 ["+beanName+"]");
    		return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);
    	}
    
    	@Override
    	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
    		System.out.println("UserServiceImpl postProcessBeanFactory beanFactory 增强处理 ["+beanFactory+"]");
    	}
    
    	@Override
    	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
    		System.out.println("UserServiceImpl setApplicationContext ");
    	}
    }
    

`application.xml`

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
    	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    	   xmlns:context="http://www.springframework.org/schema/context"
    	   xmlns:aop="http://www.springframework.org/schema/cache"
    	   xsi:schemaLocation="http://www.springframework.org/schema/beans
    		https://www.springframework.org/schema/beans/spring-beans.xsd
    		http://www.springframework.org/schema/context
    		https://www.springframework.org/schema/context/spring-context.xsd
    		http://www.springframework.org/schema/cache
    		http://www.springframework.org/schema/cache/spring-cache.xsd">
    
    	<bean id="address" class="org.yang.learn.spring.dto.Address" >
    		<constructor-arg value="深圳"/>
    		<constructor-arg value="罗湖"/>
    		<constructor-arg value="xxx街道101号"/>
    	</bean>
    	<bean id="user" class="org.yang.learn.spring.dto.User" init-method="initMethod" destroy-method="destroyMethod" >
    		<property name="username" value="张三"></property>
    		<property name="age" value="9764534"></property>
    	</bean>
    	<bean id="userService" class="org.yang.learn.spring.dto.UserServiceImpl" >
    	</bean>
    
    </beans>
    
    
    

    public static void main(String[] args) throws Exception {
    	System.out.println("===========================容器启动===============================\n");
    	ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
    	System.out.println("\n==========================容器完成================================");
    	User user = context.getBean("user", User.class);
    	System.out.println("获取容器的user Bean: "+user);
    	context.close();
    }
    

容器的创建 (ClassPathXmlApplicationContext)
--------------------------------------

`org.springframework.context.support.ClassPathXmlApplicationContext#ClassPathXmlApplicationContext(java.lang.String)`  
`org.springframework.context.support.ClassPathXmlApplicationContext#ClassPathXmlApplicationContext(java.lang.String[], boolean, org.springframework.context.ApplicationContext)`

    /**
     * Create a new ClassPathXmlApplicationContext with the given parent,
     * loading the definitions from the given XML files.
     * @param configLocations array of resource locations
     * @param refresh whether to automatically refresh the context,
     * loading all bean definitions and creating all singletons.
     * Alternatively, call refresh manually after further configuring the context.
     * @param parent the parent context
     * @throws BeansException if context creation failed
     * @see #refresh()
     */
    public ClassPathXmlApplicationContext(
    		String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)
    		throws BeansException {
    	/**
    	 * 调用父类构造, 初始了一些对象和字段属性, 例如:
    	 *  1. 当前 context 的属性初始化:
    	 *   - 存储BeanFactoryPostProcessor(BFPP)的集合  {@link org.springframework.context.support.AbstractApplicationContext#beanFactoryPostProcessors}
    	 *	 - id 容器ID, displayName 容器名称,  closed, active 容器关闭启动 活动的 AtomicBoolean标识符 ; {@link org.springframework.context.support.AbstractApplicationContext#id}
    	 *   - startupShutdownMonitor 容器锁对象, 在容器'刷新'和'销毁'时需要锁住(同步)的 {@link AbstractApplicationContext#startupShutdownMonitor}
    	 *    shutdownHook; JVM 的 HOOK {@link AbstractApplicationContext#shutdownHook}
    	 *
    	 *  2. 如果有父容器,则设置父容器,还会合并配置;
    	 *  {@link org.springframework.context.support.AbstractApplicationContext#setParent(org.springframework.context.ApplicationContext)}
    	 *
    	 *  3. 创建支持ant风格解析的资源解析器,支持通配符的类似`"classpath*:applicationContext-*.xml"` 这种, 解析容器所需要的 xml, yml, properties 等配置文件; `spring.profiles.active` 的变量 也是由这个解析器进行处理
    	 * 	解析容器所需要的 xml, yml, properties 等配置文件;  {@link AbstractApplicationContext#AbstractApplicationContext()}
    	 */
    	super(parent);
    	/**
    	 * 解析路径, 路径中支持表达式的变量, 例如: 文件名 application-${env}.xml 环境对象里面有env变量会替换之
    	 */
    	setConfigLocations(configLocations);
    	if (refresh) {
    		refresh();
    	}
    }
    

### 总结

调用父类构造, 初始了一些对象和字段属性, 例如:

1.  当前 context 的属性初始化:

*   存储 BeanFactoryPostProcessor(BFPP) 的集合
*   id 容器ID, displayName 容器名称, closed, active 容器关闭启动 活动的 AtomicBoolean标识符 ;
*   `startupShutdownMonitor` 容器锁对象, 在容器'刷新'和'销毁'时需要锁住(同步)的
*   shutdownHook; JVM 的 HOOK

2.  如果有父容器,则设置父容器,还会合并配置;

3.  创建支持ant风格解析的资源解析器,支持通配符的类似`"classpath*:applicationContext-*.xml"` 这种, 解析容器所需要的 xml, yml, properties 等配置文件; `spring.profiles.active` 的变量 也是由这个解析器进行处理  
    解析容器所需要的 xml, yml, properties 等配置文件;

refresh() 方法
------------

这个是重点方法, 几乎整个生命周期的代码, 都可以在这个方法内找到, 所以代码断点 书签 调试, 都给它干上..

`org.springframework.context.support.AbstractApplicationContext#refresh`

`org.springframework.context.support.AbstractApplicationContext#refresh`

    
    	@Override
    	public void refresh() throws BeansException, IllegalStateException {
    		// 容器刷新, 执行时, 需要锁住
    		synchronized (this.startupShutdownMonitor) {
    			//记录容器 启动时间, 步骤 用于分析性能的 (不重要)
    			StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");
    
    			// Prepare this context for refreshing.
    			/**
    			 * 一, (ApplicationContext)的预准备工作;
    			 * 容器刷新前的准备工作
    			 * 1. 设置容器的一些状态标志符;设置启动时间, 活动标志符; {@link AbstractApplicationContext#prepareRefresh()}
    			 * 2. 获取或者创建 Environment 对象; 加载 System.getProperties(); {@see AbstractApplicationContext#environment}
    			 * 3. 验证环境是否包含某配置; 手动添加配置. {@link AbstractApplicationContext#initPropertySources()}
    			 * 4. 准备存储 事件监听器 和 事件 的集合容器, 默认为空 {@link AbstractApplicationContext#prepareRefresh()};
    			 */
    			prepareRefresh();
    
    			// Tell the subclass to refresh the internal bean factory.
    			/**
    			 * 二, 创建 BeanFactory;
    			 * 1. 销毁之前的 beanFactory (如果有的话) {@link AbstractRefreshableApplicationContext#refreshBeanFactory()}
    			 * 2. 实例化/创建 beanFactory, 这里是实例类是 `DefaultListableBeanFactory` {@link org.springframework.context.support.AbstractRefreshableApplicationContext#createBeanFactory}
    			 * 3. 设置 beanFactory 忽略  BeanNameAware, BeanClassLoaderAware, BeanFactoryAware这三个Aware的接口 {@link AbstractAutowireCapableBeanFactory#AbstractAutowireCapableBeanFactory()}
    			 * 		因为在初始化Bean时, 会直接调用它们(而不是通过通过 BeanPostProcessor扩展的Aware机制调用) {@link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)}
    			 * 4. 设置 beanFactory 序列化ID, 名称 {@link AbstractRefreshableApplicationContext#refreshBeanFactory()}
    			 * 5. 扩展点, 定制化这个 BeanFactory 例如: 是否允许 BeanDefinition 覆盖; 是否自动处理循环依赖;
    			 * 6. 创建(XML解析器/读取器) XmlBeanDefinitionReader, 并初始化; 留下扩展点, 扩展Reader 例如 是否验证xml等 {@link AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory)}
    			 * 7. 创建相关对象DocumentLoader, BeanDefinitionDocumentReader,BeanDefinitionParserDelegate {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions(org.w3c.dom.Document, org.springframework.core.io.Resource)}
    			 * 		{@link DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions(Element)}
    			 *    加载/解析 XML标签/元素/属性等将其封装为 一个个 BeanDefinition 对象
    			 * 8. 将 BeanDefinitions 注册到 registry {@link BeanDefinitionReaderUtils#registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry)}
    			 */
    			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
    
    			/**
    			 * 三,(BeanFactory)预准备工作;
    			 * {@link AbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory)}
    			 * 1. 为 beanFactory 设置 bean 的类加载器 {@link ConfigurableBeanFactory#setBeanClassLoader(ClassLoader)}
    			 * 2. 为 beanFactory 设置 bean 的 StandardBeanExpressionResolver (表达式(Spring EL)解析器) {@link ConfigurableBeanFactory#setBeanExpressionResolver(BeanExpressionResolver)}
    			 *   关于 (Spring EL)解析器: StandardBeanExpressionResolver 的设计是组合优于继承, 内部有两个 SpelExpressionParser(真正解析的) SpelParserConfiguration(配置类)
    			 * 3. 为 beanFactory 设置 PropertyEditorRegistrar (主要为 Bean 设置属性的管理类){@link ConfigurableBeanFactory#addPropertyEditorRegistrar(PropertyEditorRegistrar)}
    			 * 		 *  PropertyEditorRegistrar 这个主要为 Bean 设置属性的管理类, 比如, 日期类型的数据: 可以是特定格式的字符串, 数字, 还可以是时间戳...
    			 * 		 *  Spring 为 bean 填充属性, 使用 BeanWrapperImpl 包装了一下(装饰模式)
    			 * 		 *  BeanWrapperImpl 实现了 PropertyEditorRegistry, 可以往里面注册 PropertyEditor, 可以自定义属性的转换, 编辑逻辑
    			 * 4. 给 beanFactory 添加一个 处理Aware的 BeanPostProcessor (ApplicationContextAwareProcessor) 并忽略掉这7个接口的自动注入:{@link ConfigurableBeanFactory#addBeanPostProcessor(BeanPostProcessor)}
    			 * 		EnvironmentAware.class, EmbeddedValueResolverAware.class, ResourceLoaderAware.class, ApplicationEventPublisherAware.class, MessageSourceAware.class, ApplicationContextAware.class, ApplicationStartupAware.class
    			 * 5. 指定内置的 BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext {@link ConfigurableListableBeanFactory#registerResolvableDependency(Class, Object)}
    			 * 		这几个Bean对象,  自动注入的 Primary
    			 * 6. 给 beanFactory 添加一个 BeanPostProcessor (ApplicationListenerDetector)TODO (事件监听相关)
    			 * 7. 给 beanFactory 添加一个 BeanPostProcessor(LoadTimeWeaverAwareProcessor) TODO (AOP AspectJ 织入处理相关的)
    			 * 8. beanFactory中如果没有以下名称的 bean, 则直接给 BeanFactory 的一级缓存, 注册几个环境对象 Bean {@link SingletonBeanRegistry#registerSingleton(String, Object)}
    			 *  名称常量分别是:
    			 *  org.springframework.context.ConfigurableApplicationContext#ENVIRONMENT_BEAN_NAME
    			 *  org.springframework.context.ConfigurableApplicationContext#SYSTEM_PROPERTIES_BEAN_NAME
    			 *  org.springframework.context.ConfigurableApplicationContext#SYSTEM_ENVIRONMENT_BEAN_NAME
    			 *  org.springframework.context.ConfigurableApplicationContext#APPLICATION_STARTUP_BEAN_NAME
    			 *
    			 */
    			// Prepare the bean factory for use in this context.
    			prepareBeanFactory(beanFactory);
    
    			try {
    				// Allows post-processing of the bean factory in context subclasses.
    				/**
    				 * 四, beanFactory 已经准备好了, 设计目的是给(Context)子类预留一个扩展点, 在此时这里所有的 Bean 已经被注册了, 尚未实例化任何bean;
    				 * BeanPostProcessors
    				 * (这里是空实现)
    				 */
    				postProcessBeanFactory(beanFactory);
    
    				StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
    
    				// Invoke factory processors registered as beans in the context.
    				/**
    				 * 五, 调用 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor
    				 * 若是注册的bean definition 实现了这两个接口, 则会调用(getBean)实例化它, 再调用相应的接口方法;
    				 * (注意一下 BeanDefinitionRegistryPostProcessor 是继承自 BeanFactoryPostProcessor的)
    				 * 总的来说 调用的优先级是:
    				 * 1. 调用接口的优先级:
    				 *    1. 优先调用(子类) BeanDefinitionRegistryPostProcessor
    				 *    2. 再调用(父类) BeanFactoryPostProcessor
    				 * 2. 调用添加的方式的优先级:
    				 *    1. 优先调用外部入参, 即直接通过{@link AbstractApplicationContext#addBeanFactoryPostProcessor(org.springframework.beans.factory.config.BeanFactoryPostProcessor)} 代码添加的
    				 *    2. 再调用容器中实现 BeanFactoryPostProcessor 或者 BeanDefinitionRegistryPostProcessor 的 Bean
    				 * 见: {@link org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List)}
    				 *
    				 * 值得一提的是:  Spring 对于支持 SPEL表达式, 就是通过 `PropertySourcesPlaceholderConfigurer` 这种方式扩展实现的
    				 * {@link org.springframework.context.support.PropertySourcesPlaceholderConfigurer}
    				 */
    				invokeBeanFactoryPostProcessors(beanFactory);
    
    				// Register bean processors that intercept bean creation.
    				/**
    				 *  六, 注册 BeanPostProcessor (BPP)处理器;
    				 *
    				 *  1. 拿到所有 BeanPostProcessor 类型的 bean
    				 *  2. 实例化 BeanPostProcessor
    				 *  	优先实例化 实现了 PriorityOrdered 接口的, 在实例化其它的(BPP)
    				 *  3. 进行分类存到集合 {@link PostProcessorRegistrationDelegate#registerBeanPostProcessors(ConfigurableListableBeanFactory, AbstractApplicationContext)}
    				 *   	* 对 BeanPostProcessor 进行分类存起来,  再调用, 每个集合分别是
    				 * 		 * 1. priorityOrderedPostProcessors //有实现(PriorityOrdered)排序接口的
    				 * 		 * 2. internalPostProcessors //Spring内部的bean, 见: Spring将bean分为三种角色
    				 * 		 * 3. orderedPostProcessorNames //实现 Ordered 接口
    				 * 		 * 4. nonOrderedPostProcessorNames //没有指定顺序, 无序的
    				 *  这有一点, Spring 对 BeanDefinition 分成三种角色:
    				 *  	1. 用户定义的 业务相关的 Bean Bean (ROLE_APPLICATION)
    				 *      2. 较复杂的 (ROLE_SUPPORT) 较复杂的, 支持 AOP、事务等功能的内部实现?  (不重要, 不要每一个细节都扣...)
    				 *      3. Spring 内置的(ROLE_INFRASTRUCTURE)
    				 *
    				 *  4. 排序并注册到 beanFactory
    				 *    	1. 这里按实现(PriorityOrdered)排序接口的、@Ordered注解的 等排序存起来. 实际调用的顺序 其实就是存起来的顺序
    				 *      2. 另外 BeanPostProcessor 接口粗粒度太大了, Spring 还细分一些子接口:
    				 *         1. SmartInstantiationAwareBeanPostProcessor 它提供了更高级的Bean实例化控制方法。主要作用在于允许对Bean的实例化过程进行更精细的控制和定制。
    				 *         2. MergedBeanDefinitionPostProcessor 在合并Bean定义（MergedBeanDefinition）之后但在实例化Bean之前，允许对合并后的Bean定义进行修改、调整或附加元数据。
    				 *         3. DestructionAwareBeanPostProcessor 它允许在Bean被销毁之前（例如，容器关闭或特定作用域的Bean销毁）执行一些操作。
    				 *         等等以上也会存起来
    				 *      3. 最终调用 BPP是在 {@link AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)} 实例初始化其他Bean调用
    				 */
    				registerBeanPostProcessors(beanFactory);
    
    				beanPostProcess.end();
    
    				// Initialize message source for this context.
    				/**
    				 * 七, 初始化国际化(I18N) 信息源;
    				 * 里面很简单:
    				 * 1. 如果beanFactory中有名称为 messageSource 的Bean定义 ，就使用这bean作物国际化消息源
    				 * 如果没有则默认使用 org.springframework.context.support.DelegatingMessageSource 并注册到 beanFactory
    				 */
    				initMessageSource();
    
    				// Initialize event multicaster for this context.
    				/**
    				 * 八, 初始化事件多播器;
    				 * 1. 如果 beanFactory 中包含名称为 applicationEventMulticaster 的bean定义, 则使用这个Bean作为事件多播器;
    				 *   如果不包含则创建 SimpleApplicationEventMulticaster作为事件多播器;
    				 * 2.创建SimpleApplicationEventMulticaster其实就是初始化了一个,用于存放/管理 ApplicationListener 监听器(观察者)的类, 并注册到 beanFactory
    				 * 	主要是 {@link org.springframework.context.event.AbstractApplicationEventMulticaster#defaultRetriever} 用于存放/管理 各个监听器的(观察者)
    				 *  {@link org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType) }调用容器发布事件
    				 */
    				initApplicationEventMulticaster();
    
    				// Initialize other special beans in specific context subclasses.
    				/**
    				 * 九, 给子类(Context)留下一个扩展点
    				 * 没什么好说的, 这里是空实现
    				 */
    				onRefresh();
    
    				// Check for listener beans and register them.
    				/**
    				 * 十, 向多播器注册监听器;
    				 * 1. 向多播器中注册 在context中的监听器(观察者);
    				 * 2. 向多播器中注册 在beanFactory中的bean是监听器(ApplicationListener.class)的(观察者)
    				 * 3. 广播 this.earlyApplicationEvents 属性中的事件;
    				 * 为什么?
    				 * 因为有可能 在容器生命周期中调用了当前 `AbstractApplicationContext#publishEvent` 发布事件, 但是多播器没有初始化完成, 所以会将事件存在this.earlyApplicationEvents 中;
    				 * 待容器初始化完成后在流程  {@link org.springframework.context.support.AbstractApplicationContext#registerListeners()} 中会发布存在这里面的事件
    				 * (例如: 在 BeanFactoryPostProcessor 的业务逻辑触发容器的广播事件, 这时候多播器都不存在)
    				 * @see AbstractApplicationContext#prepareRefresh()
    				 */
    				registerListeners();
    
    				// Instantiate all remaining (non-lazy-init) singletons.
    				/**
    				 * 十一, 实例化剩下的所有单例bean
    				 *
    				 * 1. 为 beanFactory 设置类型转换器(ConversionService) 属性填充时会用到 {@link AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)}
    				 * 2. 为 beanFactory 添加变量解析器 (StringValueResolver)
    				 * 	如果 beanFactory 上下文中不包含 "默认的变量解析器 (类似 PropertySourcesPlaceholderConfigurer) 解析类似 '${}' 这样的变量 "
    				 * 	则使用环境对象(ConfigurableEnvironment)中的 ConfigurablePropertyResolver实现来作为 StringValueResolver 添加进去
    				 * 3. 冻结配置, 此后就不再允许更改 beanDefinition 了
    				 * 4. 实例化所有剩余的 (非lazy-init) 单例 Bean
    				 * 5. 处理 FactoryBean 类型的bean {@link DefaultListableBeanFactory#preInstantiateSingletons()}
    				 * 	如果该bean是 FactoryBean, 则在 bean name 前面加一个 '&' 前缀, 先获取/实例化 FactoryBean 本身;
    				 * 	(注意一下 FactoryBean 生成对象是不遵循 Spring 的bean生命周期的)
    				 * 	这有两个对象, 如何获取? getBean(beanName) :
    				 * 	1. 传入 FactoryBean 的 name 返回的是其 getObject 的目标对象实例;
    				 * 	2. 如果想获取 FactoryBean 本身实例, 则前面需要加一个 '&' 前缀;
    				 * 6. 尝试从当前容器 一 二 三级缓存获取 {@link AbstractBeanFactory#doGetBean(String, Class, Object[], boolean)}
    				 * 7. 处理 AOP 代理对象生成 {@link AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])}
    				 * 8. 在JVM层面实例化对象 {@link AbstractAutowireCapableBeanFactory#doCreateBean(String, RootBeanDefinition, Object[])}
    				 * 	1.真正在jvm层面实例化对象;
    				 * 		1. 如果该 BeanDefinition 有配置 instanceSupplier属性(java.util.function.Supplier),
    				 * 		 将使用其Supplier#get方法的返回, 作为实例对象
    				 * 		2. 如果该 BeanDefinition 有配置 factory-method 将使用该方法返回的, 作为实例对象
    				 * 		 这里这里包括'静态工厂'和'实例工厂'的处理(通过bd的factoryBeanName 进行判断, 如果存在则是'实例工厂')
    				 * 		3. 使用反射实例化, 根据策略实例化Bean对象 {@link org.springframework.beans.factory.support.SimpleInstantiationStrategy}
    				 * 		- 使用有参构造函数注入,创建 (new)
    				 * 		- 使用无参构造函数创建 (new)
    				 * 		- 工厂方法实例化 ('静态工厂' '实例工厂' )
    				 * 		`<bean  factory-bean="bookFactoryBean"  factory-method="getBook()"/>`
    				 * 		静态工厂: factory-bean 若是 全限定类名 则使用 BookFactoryBean::getBook 的静态方法返回的对象
    				 * 		实例工厂:  factory-bean 若是 bean 名 则使用该实例方法返回的对象
    				 * 	2. 用 BeanWrapper 包装原始bean (装饰模式)
    				 * 	3. 初始化 BeanWrapper
    				 * 		1. 给 BeanWrapper 设置了, ConversionService
    				 * 		2. 给 BeanWrapper 注册了, 当前 bean factory (propertyEditorRegistrars)中的全部 PropertyEditor
    				 * 		3. 处理 MergedBeanDefinitionPostProcessor 的接口回调 {@link AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class, String)}
    				 * 		调用 添加在 context 中 BeanPostProcessor 的 MergedBeanDefinitionPostProcessor 的接口回调
    				 * 		解析到诸如`@Autowired`之类的注解 (Metadata)元信息,合并到BeanDefinition中
    				 * 	4. 填充Bean属性 {@link AbstractAutowireCapableBeanFactory#populateBean(String, RootBeanDefinition, BeanWrapper)}
    				 * 		1. 如果是AOP, pointcut, advice相关的, synthetic 会配置为 true  调用 BeanPostProcessor 的子接口 InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation
    				 * 		(作用是 在实例化之后，属性填充之前执行操作, 可以拦截属性填充操作)
    				 * 		2. 处理注解的  byName 或者 byType 注入的属性
    				 * 		3. 回调所有 InstantiationAwareBeanPostProcessor#postProcessProperties 方法
    				 * 		比如, `@Autowired` 的处理对应实现类: {@link org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor}
    				 * 		(作用是: 在工厂将属性值应用到给定bean之前，对它们进行处理)
    				 * 		注意这里也只是解析, 并没有设置进去, 实际赋值方法见: {@link AbstractAutowireCapableBeanFactory#applyPropertyValues(java.lang.String, org.springframework.beans.factory.config.BeanDefinition, org.springframework.beans.BeanWrapper, org.springframework.beans.PropertyValues)}
    				 * 	5.初始化Bean对象 {@link AbstractAutowireCapableBeanFactory#initializeBean(String, Object, RootBeanDefinition)}
    				 * 		1. 先调用这三个 BeanNameAware, BeanClassLoaderAware, BeanFactoryAware {@link AbstractAutowireCapableBeanFactory#invokeAwareMethods(String, Object)}
    				 * 		这三个是在创建BeanFactory 时忽略的三个 Aware 接口
    				 * 		2. 调用所有 BeanPostProcessors#postProcessBeforeInitialization (作用: 在Bean初始化之前调用) {@link AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization(Object, String)}
    				 * 		3. 调用 init-method 方法 {@link AbstractAutowireCapableBeanFactory#invokeInitMethods(String, Object, RootBeanDefinition)}
    				 * 		4. 调用所有 BeanPostProcessors#postProcessAfterInitialization (作用: 在Bean初始化之后调用) {@link AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization(Object, String)}
    				 * 	6. 注册 bean销毁的工作(如果需要){@link AbstractBeanFactory#registerDisposableBeanIfNecessary(String, Object, RootBeanDefinition)}
    				 * 			1. org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor#postProcessBeforeDestruction(Object,String) BPP接口
    				 * 			2. org.springframework.beans.factory.DisposableBean 接口
    				 * 			3. 自定义 destroy方法
    				 * 			(在容器关闭时会调用会按这个顺序调用)
    				 *
    				 */
    				finishBeanFactoryInitialization(beanFactory);
    
    				// Last step: publish corresponding event.
    				/**
    				 * 十二, 完成容器刷新
    				 * 1. 清理各种缓存资源
    				 * 2. 为当前上下文初始化生命周期处理器
    				 * 3. 发布 ContextRefreshedEvent (Context 完成刷新)事件
    				 */
    				finishRefresh();
    			}
    
    			catch (RuntimeException | Error ex ) {
    				if (logger.isWarnEnabled()) {
    					logger.warn("Exception encountered during context initialization - " +
    							"cancelling refresh attempt: " + ex);
    				}
    				// Destroy already created singletons to avoid dangling resources.
    				destroyBeans();
    
    				// Reset 'active' flag.
    				cancelRefresh(ex);
    
    				// Propagate exception to caller.
    				throw ex;
    			}
    
    			finally {
    				contextRefresh.end();
    			}
    		}
    	}
    

一. (ApplicationContext)的预准备工作
-----------------------------

ApplicationContext 的预准备工作, 容器刷新前的准备工作  
`org.springframework.context.support.AbstractApplicationContext#prepareRefresh`

    /**
    	 * Prepare this context for refreshing, setting its startup date and
    	 * active flag as well as performing any initialization of property sources.
    	 * 容器刷新前的准备工作
    	 * 1. 设置容器的一些状态标志符;设置启动时间, 活动标志符; {@link AbstractApplicationContext#prepareRefresh()}
    	 * 2. 获取或者创建 Environment 对象; 加载 System.getProperties(); {@see AbstractApplicationContext#environment}
    	 * 3. 验证环境是否包含某配置; 手动添加配置. {@link AbstractApplicationContext#initPropertySources()}
    	 * 4. 准备存储 事件监听器 和 事件 的集合容器, 默认为空 {@link AbstractApplicationContext#prepareRefresh()};
    	 */
    	protected void prepareRefresh() {
    		// 设置容器的一些状态标志符;设置启动时间, 活动标志符;
    		// Switch to active.
    		this.startupDate = System.currentTimeMillis();
    		this.closed.set(false);
    		this.active.set(true);
    
    		if (logger.isDebugEnabled()) {
    			if (logger.isTraceEnabled()) {
    				logger.trace("Refreshing " + this);
    			}
    			else {
    				logger.debug("Refreshing " + getDisplayName());
    			}
    		}
    
    		// Initialize any placeholder property sources in the context environment.
    		//留给子类扩展的方法: 验证环境是否包含某配置; 手动添加配置;...
    		initPropertySources();
    
    		// Validate that all properties marked as required are resolvable:
    		/**
    		 *  验证必须的存在的配置. 例如调用 `setRequiredProperties("iot.config.thread")`之后, 在这里会验证是否存在 iot.config.thread 配置,否则会抛出异常 MissingRequiredPropertiesException
    		 * 	 {@link ConfigurablePropertyResolver#setRequiredProperties(String...) }
    		 */
    		getEnvironment().validateRequiredProperties();
    
    		// s tore pre-refresh ApplicationListeners...
    		//存储监听器的集合初始化; this.earlyApplicationEvents(刷新前的监听器)
    		if (this.earlyApplicationListeners == null) {
    			//如果为空,则添加 this.applicationListeners 在boot中是有值的
    			this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
    		}
    		else {
    			// 如果不为空, 则清空; 注意这是 content 的复用方法 Refresh()
    			// Reset local application listeners to pre-refresh state.
    			this.applicationListeners.clear();
    			this.applicationListeners.addAll(this.earlyApplicationListeners);
    		}
    
    		// Allow for the collection of early ApplicationEvents,
    		// to be published once the multicaster is available...
    		this.earlyApplicationEvents = new LinkedHashSet<>();
    	}
    

### 总结

1.  设置容器的一些状态标志符;设置启动时间, 活动标志符;
2.  获取或者创建 Environment 对象; 加载 System.getProperties();
3.  验证环境是否包含某配置; 手动添加配置.
4.  准备存储 事件监听器 和 事件 的集合容器, 默认为空 {@link AbstractApplicationContext#prepareRefresh()};

二. 创建 BeanFactory - obtainFreshBeanFactory()
--------------------------------------------

### 创建 BeanFactory

第一步当然是创建存储Bean的容器啦..  
`org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory`  
`org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory`

    /**
    	 * This implementation performs an actual refresh of this context's underlying
    	 * bean factory, shutting down the previous bean factory (if any) and
    	 * initializing a fresh bean factory for the next phase of the context's lifecycle.
    	 */
    	@Override
    	protected final void refreshBeanFactory() throws BeansException {
    		// 如果有 则销毁之前的 BeanFactory
    		if (hasBeanFactory()) {
    			destroyBeans();
    			closeBeanFactory();
    		}
    		try {
    			// <!> 创建 DefaultListableBeanFactory
    			DefaultListableBeanFactory beanFactory = createBeanFactory();
    			// 设置 beanFactory 序列化ID
    			beanFactory.setSerializationId(getId());
    			// 定制化 BeanFactory <!> 可扩展点
    			customizeBeanFactory(beanFactory);
    			/**
    			 * 加载 BeanDefinitions <!>重点
    			 * 1. 创建(XML解析器/读取器) XmlBeanDefinitionReader, 并初始化; 留下扩展点, 扩展Reader 例如 是否验证xml等
    			 * 2. 创建相关对象DocumentLoader, BeanDefinitionDocumentReader,BeanDefinitionParserDelegate
    			 *    加载解析 XML的标签/元素/属性 等并且将其封装为 一个个 BeanDefinition 对象
    			 * 3. 将 BeanDefinitions 注册到 registry
    			 */
    			loadBeanDefinitions(beanFactory);
    			this.beanFactory = beanFactory;
    		}
    		catch (IOException ex) {
    			throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
    		}
    	}
    

### 创建 XmlBeanDefinitionReader

`XmlBeanDefinitionReader` 这个对象是用来读取 xml 配置的

`org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory)`

    /**
     * Loads the bean definitions via an XmlBeanDefinitionReader.
     *
     *  1. 创建(XML解析器/读取器) XmlBeanDefinitionReader {@link AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory)}
     *    - 给 beanDefinitionReader 设置环境对象, 可以让 XmlBeanDefinitionReader 做变量表达式解析比如 ${jdbc.url}
     *    - 给 beanDefinitionReader 设置 BeanFactory
     * 	  - 给 beanDefinitionReader 设置 要用于解析的SAX实体解析器; (SAX全称 Simple API for XML，既是一种接口，也是一种软件包。它是一种XML解析的替代方法)
     * 			注意这里加载了两个对象: 1. BeansDtdResolver (XSD,DTD解析器); 2. PluggableSchemaResolver  映射(本地文件xsd检验) 'META-INF/spring.schemas'文件信息
     * 			例如, context 命名空间xml检验的映射:
     * 			<code> http\://www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context.xsd</code>
     * 			@see DelegatingEntityResolver#DelegatingEntityResolver(java.lang.ClassLoader)
     * {@link AbstractXmlApplicationContext#initBeanDefinitionReader(XmlBeanDefinitionReader)}
     *  2. 调用扩展点方法, 扩展/定制 XmlBeanDefinitionReader
     *  3. 加载 BeanDefinitions <!>
     *
     * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader
     * @see #initBeanDefinitionReader
     * @see #loadBeanDefinitions
     */
    @Override
    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
    	// Create a new XmlBeanDefinitionReader for the given BeanFactory.
    	/**
    	 * 创建(XML解析器/读取器) XmlBeanDefinitionReader {@link AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory)}
    	 * 注意传过去的 DefaultListableBeanFactory 它实现了 BeanDefinitionRegistry 作为 Registry 传递进去
    	 * 最后解析出来的 BeanDefinition, 使用该 Registry 作为注册中心
    	 */
    	XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
    	// Configure the bean definition reader with this context's
    	// resource loading environment.
    	// 给 beanDefinitionReader 设置环境对象, 可以让 XmlBeanDefinitionReader 做变量表达式解析比如 ${jdbc.url}
    	beanDefinitionReader.setEnvironment(getEnvironment());
    	// 给 beanDefinitionReader 设置 BeanFactory
    	beanDefinitionReader.setResourceLoader(this);
    	/**
    	 * 给 beanDefinitionReader 设置 要用于解析的SAX实体解析器; (SAX全称 Simple API for XML，既是一种接口，也是一种软件包。它是一种XML解析的替代方法)
    	 * 		注意这里加载了两个对象: 1. BeansDtdResolver (XSD,DTD解析器); 2. PluggableSchemaResolver  映射(本地文件xsd检验) 'META-INF/spring.schemas'文件信息
    	 * 				例如, context 命名空间xml检验的映射: `http\://www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context.xsd`
    	 * 		使用这两个解析器避免从网络下载DTD或XSD,解析器会根据这些模式定义验证配置文件的结构是否正确。如果验证失败，容器将无法启动
    	 * @see DelegatingEntityResolver#DelegatingEntityResolver(java.lang.ClassLoader)
    	 */
    	beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));
    
    	// Allow a subclass to provide custom initialization of the reader,
    	// then proceed with actually loading the bean definitions.
    	/**
    	 * 调用扩展点方法, 扩展/定制 XmlBeanDefinitionReader {@link AbstractXmlApplicationContext#initBeanDefinitionReader(XmlBeanDefinitionReader)}
    	 */
    	initBeanDefinitionReader(beanDefinitionReader);
    	
    	/**
    	 * 加载 BeanDefinitions, 并注册到 Registry 中, 这个步骤, 为了复用代码嵌套的方法非常多, 总结一下关键点
    	 * 1. 为了代码复用,多个方法重载 配置文件路径 (String参数), 多配置文件(数组参数) , 在统一转为 `org.springframework.core.io.Resource` 对象去迭代
    	 * 		最终读取配置文件的输入流在 {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.support.EncodedResource)}
    	 * 2.
    	 */
    	loadBeanDefinitions(beanDefinitionReader);
    }
    

#### 自定义命名空间处理器

注意一点 `XmlBeanDefinitionReader` 持有 一个 `namespaceHandlerResolver`, 默认它的创建逻辑是在  
`org.springframework.beans.factory.xml.XmlBeanDefinitionReader#createDefaultNamespaceHandlerResolver`

    
    /**
    	 * Create the default implementation of {@link NamespaceHandlerResolver} used if none is specified.
    	 * <p>The default implementation returns an instance of {@link DefaultNamespaceHandlerResolver}.
    	 * @see DefaultNamespaceHandlerResolver#DefaultNamespaceHandlerResolver(ClassLoader)
    	 */
    	protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() {
    		ResourceLoader resourceLoader = getResourceLoader();
    		ClassLoader cl = (resourceLoader != null ? resourceLoader.getClassLoader() : getBeanClassLoader());
    		// 解析自定义标签的 NamespaceHandlerResolver 命名空间 handle 映射
    		//
    		return new DefaultNamespaceHandlerResolver(cl);
    	}
    

### 加载 BeanDefinition 到容器

这一步 为了复用, 嵌套的方法非常多, 这里列出关键方法

#### 转为数组参数迭代

数组方式迭代以支持多配置文件

    	/**
    	 * Load the bean definitions with the given XmlBeanDefinitionReader.
    	 * <p>The lifecycle of the bean factory is handled by the {@link #refreshBeanFactory}
    	 * method; hence this method is just supposed to load and/or register bean definitions.
    	 *
    	 * 根据资源文件数组迭代加载解析
    	 * 		加载 Resource[] 形式的配置文件
    	 * 		加载 String[] 形式的配置文件
    	 *
    	 * @param reader the XmlBeanDefinitionReader to use
    	 * @throws BeansException in case of bean registration errors
    	 * @throws IOException if the required XML document isn't found
    	 * @see #refreshBeanFactory
    	 * @see #getConfigLocations
    	 * @see #getResources
    	 * @see #getResourcePatternResolver
    	 */
    	protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
    		//加载 Resource[] 形式的配置文件
    		Resource[] configResources = getConfigResources();
    		if (configResources != null) {
    			reader.loadBeanDefinitions(configResources);
    		}
    		//加载 String[] 形式的配置文件
    		String[] configLocations = getConfigLocations();
    		if (configLocations != null) {
    			reader.loadBeanDefinitions(configLocations);
    		}
    	}
    

#### 转为 Resource

统一转为 `Resource` 对象以方便加载

    	/**
    	 * Load bean definitions from the specified resource location.
    	 * <p>The location can also be a location pattern, provided that the
    	 * ResourceLoader of this bean definition reader is a ResourcePatternResolver.
    	 * @param location the resource location, to be loaded with the ResourceLoader
    	 * (or ResourcePatternResolver) of this bean definition reader
    	 * @param actualResources a Set to be filled with the actual Resource objects
    	 * that have been resolved during the loading process. May be {@code null}
    	 * to indicate that the caller is not interested in those Resource objects.
    	 * @return the number of bean definitions found
    	 * @throws BeanDefinitionStoreException in case of loading or parsing errors
    	 * @see #getResourceLoader()
    	 * @see #loadBeanDefinitions(org.springframework.core.io.Resource)
    	 * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])
    	 */
    	public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {
    		ResourceLoader resourceLoader = getResourceLoader();
    		if (resourceLoader == null) {
    			throw new BeanDefinitionStoreException(
    					"Cannot load bean definitions from location [" + location + "]: no ResourceLoader available");
    		}
    		if (resourceLoader instanceof ResourcePatternResolver resourcePatternResolver) {
    			// Resource pattern matching available.
    			try {
    				/**
    				 * 对于变量处理 在 {@link org.springframework.context.support.AbstractRefreshableConfigApplicationContext#setConfigLocations(String...)} 已经处理过一遍了, 这里又处理一遍?
    				 *
    				 * 这里的重点是: 将 String 路径 转为Resourced对象, 处不处理变量无所谓, 不是重点
    				 * 处理文件名包含变量表达式的, 例如: application-${active}.xml, 用环境对象变量替换之
    				 */
    				Resource[] resources = resourcePatternResolver.getResources(location);
    				int count = loadBeanDefinitions(resources);
    				if (actualResources != null) {
    					Collections.addAll(actualResources, resources);
    				}
    				if (logger.isTraceEnabled()) {
    					logger.trace("Loaded " + count + " bean definitions from location pattern [" + location + "]");
    				}
    				return count;
    			}
    			catch (IOException ex) {
    				throw new BeanDefinitionStoreException(
    						"Could not resolve bean definition resource pattern [" + location + "]", ex);
    			}
    		}
    		else {
    			// Can only load single resources by absolute URL.
    			Resource resource = resourceLoader.getResource(location);
    			int count = loadBeanDefinitions(resource);
    			if (actualResources != null) {
    				actualResources.add(resource);
    			}
    			if (logger.isTraceEnabled()) {
    				logger.trace("Loaded " + count + " bean definitions from location [" + location + "]");
    			}
    			return count;
    		}
    	}
    

#### 转为 EncodedResource

转为 `EncodedResource` 对象以解决编码  
`org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource)`

    /**  
     * 将 Resource 包装为 EncodedResource 加载, 应该主要是解决编码的问题  
     * Load bean definitions from the specified XML file.  
     * @param resource the resource descriptor for the XML file  
     * @return the number of bean definitions found  
     * @throws BeanDefinitionStoreException in case of loading or parsing errors  
     */@Override  
    public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {  
        return loadBeanDefinitions(new EncodedResource(resource));  
    }
    
    

#### 读取配置文件输入流

`org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.support.EncodedResource)`

    /**
    	 * 校验一下, 这里解决循环导入
    	 * Load bean definitions from the specified XML file.
    	 * @param encodedResource the resource descriptor for the XML file,
    	 * allowing to specify an encoding to use for parsing the file
    	 * @return the number of bean definitions found
    	 * @throws BeanDefinitionStoreException in case of loading or parsing errors
    	 */
    	public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
    		Assert.notNull(encodedResource, "EncodedResource must not be null");
    		if (logger.isTraceEnabled()) {
    			logger.trace("Loading XML bean definitions from " + encodedResource);
    		}
    
    		//使用Set存储已加载的配置资源
    		Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();
    
    		// 当遇到循环 import definitions 时抛出异常
    		if (!currentResources.add(encodedResource)) {
    			throw new BeanDefinitionStoreException(
    					"Detected cyclic loading of " + encodedResource + " - check your import definitions!");
    		}
    		// 获得配置文件的输入流; 这里真正的开始读
    		try (InputStream inputStream = encodedResource.getResource().getInputStream()) {
    			InputSource inputSource = new InputSource(inputStream);
    			if (encodedResource.getEncoding() != null) {
    				inputSource.setEncoding(encodedResource.getEncoding());
    			}
    			return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
    		}
    		catch (IOException ex) {
    			throw new BeanDefinitionStoreException(
    					"IOException parsing XML document from " + encodedResource.getResource(), ex);
    		}
    		finally {
    			currentResources.remove(encodedResource);
    			if (currentResources.isEmpty()) {
    				this.resourcesCurrentlyBeingLoaded.remove();
    			}
    		}
    	}
    

#### 创建 BeanDefinitionDocumentReader

`org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions`

    /**
    	 * Register the bean definitions contained in the given DOM document.
    	 * Called by {@code loadBeanDefinitions}.
    	 * <p>Creates a new instance of the parser class and invokes
    	 * {@code registerBeanDefinitions} on it.
    	 * @param doc the DOM document
    	 * @param resource the resource descriptor (for context information)
    	 * @return the number of bean definitions found
    	 * @throws BeanDefinitionStoreException in case of parsing errors
    	 * @see #loadBeanDefinitions
    	 * @see #setDocumentReaderClass
    	 * @see BeanDefinitionDocumentReader#registerBeanDefinitions
    	 */
    	public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
    		/**
    		 *  这里又创建了一个 BeanDefinitionDocumentReader 对象, 用来读取/解析 Document
    		 */
    		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
    		int countBefore = getRegistry().getBeanDefinitionCount();
    
    		/**
    		 * 解析并注册 bean definitions 到 Registry 中
    		 * <br />
    		 * 解析XML自定义标签 需要注意一下, 这里的第2个参数创建的 XmlReaderContext;
    		 * 		它从这里创建了 {@link XmlBeanDefinitionReader#getNamespaceHandlerResolver()} 命名空间处理器解析器, 后续解析到对应的命名空间处理, 调用其 NamespaceHandler#parse 进行解析
    		 * 		它默认读取的配置是 `META-INF/spring.handlers`
    		 * 		例如:
    		 * 		spring-context 模块的中 `META-INF/spring.handlers` 定义的handles有如下这些
    		 * http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler
    		 * http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler
    		 * http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler
    		 * http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler
    		 * http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler
    		 *
    		 * 		spring-aop 模块的中 `META-INF/spring.handlers` 定义的handles有如下这些
    		 * http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler
    		 */
    		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
    		// 返回解析 bean definitions 的数量
    		return getRegistry().getBeanDefinitionCount() - countBefore;
    	}
    

#### 递归嵌套加载

`org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions`

    /**
    	 * Register each bean definition within the given root {@code <beans/>} element.
    	 *  在给定的(beans)根元素中注册每个bean定义, 这里的 Element 是 xml 根元素
    	 */
    	@SuppressWarnings("deprecation")  // for Environment.acceptsProfiles(String...)
    	protected void doRegisterBeanDefinitions(Element root) {
    		// Any nested <beans> elements will cause recursion in this method. In
    		// order to propagate and preserve <beans> default-* attributes correctly,
    		// keep track of the current (parent) delegate, which may be null. Create
    		// the new (child) delegate with a reference to the parent for fallback purposes,
    		// then ultimately reset this.delegate back to its original (parent) reference.
    		// this behavior emulates a stack of delegates without actually necessitating one.
    		/**
    		 * 在此方法中，任何嵌套的<beans>元素都将导致递归调用
    		 *   为了正确地传播和保存<beans>默认属性，请跟踪当前(父)委托(它可能为空)。
    		 *   创建新的(子)委托，并将其引用到父(父)委托用于回退目的，然后最终将 this.delegate重置为其原始(父)引用。
    		 *   此行为模拟委托堆栈，而实际上不需要委托堆栈。
    		 *
    		 * 应该是嵌套解析/递归时, 都用这一个 delegate解析, 保存状态, 用于传递上下文的参数;
    		 */
    		BeanDefinitionParserDelegate parent = this.delegate;
    		/**
    		 * 委托 namespaceHandlerResolver
    		 */
    		this.delegate = createDelegate(getReaderContext(), root, parent);//parent 委派, 上级的parent
    
    		/**
    		 * 是否默认命名空间; 这里是 xml 的命名空间解析判断
    		 *    简而言之默认命名空间判定是: http://www.springframework.org/schema/beans 或者是 org/springframework/beans/factory/xml/spring-beans.dtd 其DTD定义的标签
    		 *    如:
    		 *    <beans..></beans>, <bean></bean>, <import resource="" /> 这些标签是默认命名空间
    		 *    <tx:TAG ...> , <aop:TAG ...> 这些标签不是默认命名空间
    		 */
    		if (this.delegate.isDefaultNamespace(root)) {
    			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
    			if (StringUtils.hasText(profileSpec)) {
    				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
    						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
    				// We cannot use Profiles.of(...) since profile expressions are not supported
    				// in XML config. See SPR-12458 for details.
    				if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
    					if (logger.isDebugEnabled()) {
    						logger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec +
    								"] not matching: " + getReaderContext().getResource());
    					}
    					return;
    				}
    			}
    		}
    		// 前置-钩子方法, 预留扩展, 这里是空实现
    		preProcessXml(root);
    		// 真正解析逻辑
    		parseBeanDefinitions(root, this.delegate);
    		// 后置-钩子方法, 预留扩展, 这里是空实现
    		postProcessXml(root);
    
    		this.delegate = parent;
    	}
    

#### 解析默认命名空间

    /**
    	 * Parse the elements at the root level in the document:
    	 * "import", "alias", "bean".
    	 * @param root the DOM root element of the document
    	 */
    	protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    		if (delegate.isDefaultNamespace(root)) {
    			NodeList nl = root.getChildNodes();
    			for (int i = 0; i < nl.getLength(); i++) {
    				Node node = nl.item(i);
    				if (node instanceof Element ele) {//是否 是元素标签
    					/**
    					 * 处理默认命名空间的标签, 有如下四个
    					 * <import></import>, <alias></alias>, <bean></bean>, <beans></beans>
    					 *
    					 */
    					if (delegate.isDefaultNamespace(ele)) {
    						parseDefaultElement(ele, delegate);
    					}
    					else {
    						/**
    						 * 处理 非默认命名空间的标签;
    						 * 	注意这里包括 <context:bean ...> <aop:xx ...> <tx:xx ...> 等等所有指定命名空间的xml配置
    						 */
    						delegate.parseCustomElement(ele);
    					}
    				}
    			}
    		}
    		else {
    			delegate.parseCustomElement(root);
    		}
    	}
    

`org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseDefaultElement`

    /**
    	 * 默认命名空间的处理
    	 * @param ele
    	 * @param delegate
    	 */
    	private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
    		// 默认命名空间的 import 元素处理
    		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
    			importBeanDefinitionResource(ele);
    		}
    		// 默认命名空间的 alias 元素处理
    		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
    			processAliasRegistration(ele);
    		}
    		// 默认命名空间的 bean 元素处理
    		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
    			processBeanDefinition(ele, delegate);
    		}
    		// 默认命名空间的 beans 元素处理
    		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
    			// recurse
    			doRegisterBeanDefinitions(ele);
    		}
    	}
    

#### 解析自定义标签

`org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element, org.springframework.beans.factory.config.BeanDefinition)`

    	/**
    	 * 主要逻辑是 拿到元素的命名空间URI, 再从 XmlReaderContext 找到对应的 NamespaceHandler 调用解析 `parse`方法解析到 BeanDefinition 返回
    	 *  Parse a custom element (outside the default namespace).
    	 * @param ele the element to parse
    	 * @param containingBd the containing bean definition (if any)
    	 * @return the resulting bean definition
    	 */
    	@Nullable
    	public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {
    		//拿到 命名空间URI
    		String namespaceUri = getNamespaceURI(ele);
    		if (namespaceUri == null) {
    			return null;
    		}
    		/**
    		 * 拿到对应命名空间的 Handler , this.readerContext 是在
    		 * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions(org.w3c.dom.Document, org.springframework.core.io.Resource) 创建的
    		 * 		它会从父属性的 namespaceHandlerResolver 中拿到命名空间处理器, 调用NamespaceHandler#parse 进行解析
    		 * 		它默认读取的配置是 `META-INF/spring.handlers` 文件
    		 *
    		 * spring 对于 注解 AOP TX事务 的支持, 均是同个这种方式扩展的, 但这些不属IOC内容, 本篇不作说明..
    		 */
    		NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
    		if (handler == null) {
    			error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", ele);
    			return null;
    		}
    		// 调用 Handler 解析, 返回的是 BeanDefinition;
    		return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));
    	}
    

#### 注册 BeanDefinition 到 Registry

`org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#processBeanDefinition`

    /**
    	 * Process the given bean element, parsing the bean definition
    	 * and registering it with the registry.
    	 *
    	 * - 处理bean元素，解析 BeanDefinition 并将其注册到注册中心。
    	 * - 其实就是往 DefaultListableBeanFactory 的这两个集合属性添加:
    	 * 		1. 这个list 存储所有的 bean definition 名称 {@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNames}
    	 * 		2. 这个map存储所有的BeanDefinition, key是bean主name, value是BeanDefinition {@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap}
    	 */
    	protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    		/**
    		 * 对于 BeanDefinitionHolder 其实它就是一个DTO对象, 它包含以下属性:
    		 * 	private final BeanDefinition beanDefinition;//Bean  beanDefinition
    		 * 	private final String beanName; 				//Bean 名称
    		 *  private final String[] aliases;				//Bean 别名列表
    		 *
    		 */
    		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    
    		// 此时, 就完成了 对 BeanDefinition 解析了
    		if (bdHolder != null) {
    			/**
    			 * 装饰 BeanDefinition（如果需要）, 类似于:
    			 * 		<bean id="user" class="..">
    			 *  		<myBean:user username="这是 Spring"/>
    			 * 		</bean>
    			 *  对应`myBean:user` 这种自定义标签进行处理;
    			 *  后面会找到对应的命名空间 Handler (NamespaceHandler) 进行处理 : NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
    			 */
    			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
    			try {
    				/**
    				 * 注册到 Registry
    				 */
    				// Register the final decorated instance.
    				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
    			}
    			catch (BeanDefinitionStoreException ex) {
    				getReaderContext().error("Failed to register bean definition with name '" +
    						bdHolder.getBeanName() + "'", ele, ex);
    			}
    			// Send registration event.
    			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    		}
    	}
    

`org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition`

    /**
    	 * Register the given bean definition with the given bean factory.
    	 * @param definitionHolder the bean definition including name and aliases
    	 * @param registry the bean factory to register with
    	 * @throws BeanDefinitionStoreException if registration failed
    	 */
    	public static void registerBeanDefinition(
    			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
    			throws BeanDefinitionStoreException {
    
    		// Register bean definition under primary name.
    		/**
    		 * 以 beanName 向 Register 注册
    		 * 其实就是往 DefaultListableBeanFactory 的这两个集合属性添加:
    		 * 1. 这个list 存储所有的 bean definition 名称 {@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNames}
    		 * 2. 这个map存储所有的BeanDefinition, key是bean主name, value是BeanDefinition {@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap}
    		 */
    		String beanName = definitionHolder.getBeanName();
    		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
    
    		/**
    		 * 向 Register 注册别名列表
    		 * 其实就是 {@link org.springframework.core.SimpleAliasRegistry#aliasMap}
    		 * 在这个 map存储bean 的别名, key是别名, value 是bean主name;
    		 */
    		// Register aliases for bean name, if any.
    		String[] aliases = definitionHolder.getAliases();
    		if (aliases != null) {
    			for (String alias : aliases) {
    				registry.registerAlias(beanName, alias);
    			}
    		}
    	}
    

至此, BeanDefinition 算是成功解析, 并注册到 Register 中了

### 总结

1.  销毁之前的 beanFactory (如果有的话)
2.  实例化/创建 beanFactory, 这里是实例类是 `DefaultListableBeanFactory`
3.  设置 beanFactory 忽略 BeanNameAware, BeanClassLoaderAware, BeanFactoryAware这三个Aware的接口 {@link AbstractAutowireCapableBeanFactory#AbstractAutowireCapableBeanFactory()}  
    因为在初始化Bean时, 会直接调用它们(而不是通过通过 BeanPostProcessor扩展的Aware机制调用)
4.  设置 beanFactory 序列化ID, 名称
5.  扩展点, 定制化这个 BeanFactory 例如: 是否允许 BeanDefinition 覆盖; 是否自动处理循环依赖;
6.  创建(XML解析器/读取器) XmlBeanDefinitionReader, 并初始化; 留下扩展点, 扩展Reader 例如 是否验证xml等
7.  创建相关对象DocumentLoader, BeanDefinitionDocumentReader,BeanDefinitionParserDelegate {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions(org.w3c.dom.Document, org.springframework.core.io.Resource)}  
    {@link DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions(Element)}  
    加载/解析 XML标签/元素/属性等将其封装为 一个个 BeanDefinition 对象
8.  将 BeanDefinitions 注册到 registry

三. (BeanFactory)预准备工作
---------------------

`org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory`

    	/**
    	 * Configure the factory's standard context characteristics,
    	 * such as the context's ClassLoader and post-processors.
    	 * @param beanFactory the BeanFactory to configure
    	 */
    	protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    		// Tell the internal bean factory to use the context's class loader etc.
    		/**
    		 * 为 beanFactory 设置 bean 的类加载器
    		 */
    		beanFactory.setBeanClassLoader(getClassLoader());
    		/**
    		 * 为 beanFactory 设置 bean 的表达式(Spring EL)解析器
    		 * 默认风格是: `#{var}`  当然这些 前缀 后缀都是可以自定义
    		 * 关于 (Spring EL)解析器: StandardBeanExpressionResolver 的设计是组合优于继承, 内部有两个 SpelExpressionParser(真正解析的) SpelParserConfiguration(配置类)
    		 */
    		beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
    
    		/**
    		 *  为 beanFactory 设置 PropertyEditorRegistrar
    		 *  这个主要为 Bean 设置属性的管理类, 比如, 日期类型的数据: 可以是特定格式的字符串, 数字, 还可以是时间戳...
    		 *  Spring 为 bean 填充属性, 使用 BeanWrapperImpl 包装了一下(装饰模式)
    		 *  BeanWrapperImpl 实现了 PropertyEditorRegistry, 可以往里面注册 PropertyEditor, 可以自定义属性的转换, 编辑逻辑
    		 */
    		beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
    
    		/**
    		 * 添加一个 BeanPostProcessor 回调, 作用是如果Bean实现这些接口:
    		 * (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
    		 * 				bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
    		 * 				bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware ||
    		 * 				bean instanceof ApplicationStartupAware)
    		 *  它负责调用其对应 Aware 的方法, 给Bean 注入对象
    		 *
    		 * in short 就是给 bean 设置 上下文, 内置的对象; 注意是 (postProcessBeforeInitialization)
    		 */
    		// Configure the bean factory with context callbacks.
    		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
    
    		/**
    		 * 因为上面由 ApplicationContextAwareProcessor 负责注入 7个接口
    		 * 这里就忽略掉这7个接口的自动注入
    		 * 		EnvironmentAware.class, EmbeddedValueResolverAware.class, ResourceLoaderAware.class,
    		 * 		ApplicationEventPublisherAware.class, MessageSourceAware.class, ApplicationContextAware.class, ApplicationStartupAware.class
    		 */
    		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
    		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
    		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
    		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
    		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
    		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
    		beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);
    
    		/**
    		 * 类似 @Primary, 当有多个的相同类型的时候, 指定谁优先注入
    		 * 指定内置的 BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext
    		 *  几个Bean对象,  自动注入的 Primary
    		 * registerResolvableDependency
    		 */
    		// BeanFactory interface not registered as resolvable type in a plain factory.
    		// MessageSource registered (and found for autowiring) as a bean.
    		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
    		beanFactory.registerResolvableDependency(ResourceLoader.class, this);
    		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
    		beanFactory.registerResolvableDependency(ApplicationContext.class, this);
    
    		// Register early post-processor for detecting inner beans as ApplicationListeners.
    		/**
    		 * TODO 时间监听器相关
    		 */
    		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
    
    		/**
    		 * TODO  这里是 AOP AspectJ处理
    		 * LoadTimeWeaver (AOP的加载时织入)
    		 */
    		// Detect a LoadTimeWeaver and prepare for weaving, if found.
    		if (!NativeDetector.inNativeImage() && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
    			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
    			// Set a temporary ClassLoader for type matching.
    			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    		}
    
    		/**
    		 * beanFactory 中如果没有以下这些名称的 bean 则 直接给 BeanFactory 的一级缓存, 注册几个默认环境 Bean
    		 */
    		// Register default environment beans.
    		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
    			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
    		}
    		if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
    			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
    		}
    		if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
    			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
    		}
    		if (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) {
    			beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());
    		}
    	}
    

### 总结

{@link AbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory)}

1.  为 beanFactory 设置 bean 的类加载器
2.  为 beanFactory 设置 bean 的 StandardBeanExpressionResolver (表达式(Spring EL)解析器) {@link ConfigurableBeanFactory#setBeanExpressionResolver(BeanExpressionResolver)}  
    关于 (Spring EL)解析器: StandardBeanExpressionResolver 的设计是组合优于继承, 内部有两个 SpelExpressionParser(真正解析的) SpelParserConfiguration(配置类)
3.  为 beanFactory 设置 PropertyEditorRegistrar (主要为 Bean 设置属性的管理类){@link ConfigurableBeanFactory#addPropertyEditorRegistrar(PropertyEditorRegistrar)}  
    PropertyEditorRegistrar 这个主要为 Bean 设置属性的管理类, 比如, 日期类型的数据: 可以是特定格式的字符串, 数字, 还可以是时间戳...  
    Spring 为 bean 填充属性, 使用 BeanWrapperImpl 包装了一下(装饰模式)  
    BeanWrapperImpl 实现了 PropertyEditorRegistry, 可以往里面注册 PropertyEditor, 可以自定义属性的转换, 编辑逻辑
4.  给 beanFactory 添加一个 处理Aware的 BeanPostProcessor (ApplicationContextAwareProcessor) 并忽略掉这7个接口的自动注入:{@link ConfigurableBeanFactory#addBeanPostProcessor(BeanPostProcessor)}  
    EnvironmentAware.class, EmbeddedValueResolverAware.class, ResourceLoaderAware.class, ApplicationEventPublisherAware.class, MessageSourceAware.class, ApplicationContextAware.class, ApplicationStartupAware.class
5.  指定内置的 BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext {@link ConfigurableListableBeanFactory#registerResolvableDependency(Class, Object)}  
    这几个Bean对象, 自动注入的 Primary
6.  给 beanFactory 添加一个 BeanPostProcessor (ApplicationListenerDetector)TODO (事件监听相关)
7.  给 beanFactory 添加一个 BeanPostProcessor(LoadTimeWeaverAwareProcessor) TODO (AOP AspectJ 织入处理相关的)
8.  beanFactory中如果没有以下名称的bean, 则直接给 BeanFactory 的一级缓存, 注册几个环境对象 Bean {@link SingletonBeanRegistry#registerSingleton(String, Object)}  
    名称常量分别是:  
    org.springframework.context.ConfigurableApplicationContext#ENVIRONMENT\_BEAN\_NAME  
    org.springframework.context.ConfigurableApplicationContext#SYSTEM\_PROPERTIES\_BEAN\_NAME  
    org.springframework.context.ConfigurableApplicationContext#SYSTEM\_ENVIRONMENT\_BEAN\_NAME  
    org.springframework.context.ConfigurableApplicationContext#APPLICATION\_STARTUP\_BEAN\_NAME

四. postProcessBeanFactory 扩展点调用
-------------------------------

beanFactory 已经准备好了, 给子类(Context)预留一个扩展点;

`org.springframework.context.support.AbstractApplicationContext#postProcessBeanFactory` (这里是空实现)

    /**
     * Modify the application context's internal bean factory after its standard
     * initialization. The initial definition resources will have been loaded but no
     * post-processors will have run and no derived bean definitions will have been
     * registered, and most importantly, no beans will have been instantiated yet.
     * <p>This template method allows for registering special BeanPostProcessors
     * etc in certain AbstractApplicationContext subclasses.
     * @param beanFactory the bean factory used by the application context
     */
    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    }
    

五. 调用 BeanFactoryPostProcessor 处理器
----------------------------------

`org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors`

    /**
    	 * Instantiate and invoke all registered BeanFactoryPostProcessor beans,
    	 * respecting explicit order if given.
    	 * <p>Must be called before singleton instantiation.
    	 */
    	protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    		/**
    		 * 调用 BeanFactory 内的所有 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor
    		 */
    		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
    
    		/**
    		 * LOAD_TIME_WEAVER_BEAN_NAME bean 是AOP相关的.
    		 * 在 GraalVM 中能编译为本地代码, 不支持AOP的
    		 */
    		// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
    		// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
    		if (!NativeDetector.inNativeImage() && beanFactory.getTempClassLoader() == null &&
    				beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {//这里 beanFactory 不包含 LOAD_TIME_WEAVER_BEAN_NAME
    			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
    			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    		}
    	}
    

`org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>)`

    	/**
    	 * 注意一点 BeanDefinitionRegistryPostProcessor 是继承自 BeanFactoryPostProcessor的
    	 * 总的来说, 调用的时候优先级是:
    	 * 1. 调用接口的优先级
    	 * 优先调用(子类) BeanDefinitionRegistryPostProcessor
    	 * 再调用(父类) BeanFactoryPostProcessor
    	 *
    	 * 2. 调用添加的方式的优先级
    	 * 优先调用外部入参类, 即直接通过 {@link AbstractApplicationContext#addBeanFactoryPostProcessor(org.springframework.beans.factory.config.BeanFactoryPostProcessor)} 代码添加的
    	 * 再调用容器中 实现 BeanFactoryPostProcessor或者 BeanDefinitionRegistryPostProcessor 的 Bean
    	 */
    	public static void invokeBeanFactoryPostProcessors(
    			ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {
    
    		// WARNING: Although it may appear that the body of this method can be easily
    		// refactored to avoid the use of multiple loops and multiple lists, the use
    		// of multiple lists and multiple passes over the names of processors is
    		// intentional. We must ensure that we honor the contracts for PriorityOrdered
    		// and Ordered processors. Specifically, we must NOT cause processors to be
    		// instantiated (via getBean() invocations) or registered in the ApplicationContext
    		// in the wrong order.
    		//
    		// Before submitting a pull request (PR) to change this method, please review the
    		// list of all declined PRs involving changes to PostProcessorRegistrationDelegate
    		// to ensure that your proposal does not result in a breaking change:
    		// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22
    
    		// Invoke BeanDefinitionRegistryPostProcessors first, if any.
    		/**
    		 * 存储已经调用 BeanDefinitionRegistryPostProcessor 过的 bean name
    		 * 避免重复处理
    		 */
    		Set<String> processedBeans = new HashSet<>();
    
    		if (beanFactory instanceof BeanDefinitionRegistry registry) {
    
    			/**
    			 * 存储 BeanFactoryPostProcessor 的集合, 后面统一调用
    			 */
    			List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
    
    			/**
    			 * 存储已经调用过的 BeanDefinitionRegistryPostProcessor 集合
    			 */
    			List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();
    
    			/**
    			 * 先调用外部入参的 BeanDefinitionRegistryPostProcessor (代码添加的)
    			 */
    			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
    				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor registryProcessor) {
    					// 这就调了
    					registryProcessor.postProcessBeanDefinitionRegistry(registry);
    					// 是 BeanDefinitionRegistryPostProcessor 接口 存入registryProcessors
    					registryProcessors.add(registryProcessor);
    				}
    				else {
    					// 不是 BDRPP  是 BeanFactoryPostProcessor(BFPP) 存入regularPostProcessors, 后面在统一调用
    					regularPostProcessors.add(postProcessor);
    				}
    			}
    
    			// Do not initialize FactoryBeans here: We need to leave all regular beans
    			// uninitialized to let the bean factory post-processors apply to them!
    			// Separate between BeanDefinitionRegistryPostProcessors that implement
    			// PriorityOrdered, Ordered, and the rest.
    			/**
    			 * 当前将调用的 BeanDefinitionRegistryPostProcessor 集合
    			 */
    			List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();
    
    			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
    			// 1. 先调用 实现PriorityOrdered (排序)的 BDRPP
    			String[] postProcessorNames =
    					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    			for (String ppName : postProcessorNames) {
    				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
    					//<!> beanFactory.getBean, 先走实例化bean流程;
    					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
    					processedBeans.add(ppName);
    				}
    			}
    			//排序
    			sortPostProcessors(currentRegistryProcessors, beanFactory);
    			registryProcessors.addAll(currentRegistryProcessors);
    			//调用 BDRPP
    			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    			//调完了就清调
    			currentRegistryProcessors.clear();
    
    			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
    			// 2. 再调用 实现 Ordered (排序)的 BDRPP
    			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    			for (String ppName : postProcessorNames) {
    				if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
    					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
    					processedBeans.add(ppName);
    				}
    			}
    			sortPostProcessors(currentRegistryProcessors, beanFactory);
    			registryProcessors.addAll(currentRegistryProcessors);
    			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    			currentRegistryProcessors.clear();
    
    			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
    			// 3. 再调用在容器中实现 BeanDefinitionRegistryPostProcessors (BDRPP)的
    			boolean reiterate = true;
    			while (reiterate) {
    				reiterate = false;
    				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    				for (String ppName : postProcessorNames) {
    					if (!processedBeans.contains(ppName)) {
    						currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
    						processedBeans.add(ppName);
    						reiterate = true;
    					}
    				}
    				sortPostProcessors(currentRegistryProcessors, beanFactory);
    				registryProcessors.addAll(currentRegistryProcessors);
    				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());
    				currentRegistryProcessors.clear();
    			}
    			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
    			invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
    			// 3. 最后再调用BeanFactoryPostProcessor(BFPP)
    			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
    		}
    
    		else {
    			// Invoke factory processors registered with the context instance.
    			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
    		}
    
    		// Do not initialize FactoryBeans here: We need to leave all regular beans
    		// uninitialized to let the bean factory post-processors apply to them!
    		String[] postProcessorNames =
    				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
    
    		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
    		// Ordered, and the rest.
    		List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
    		List<String> orderedPostProcessorNames = new ArrayList<>();
    		List<String> nonOrderedPostProcessorNames = new ArrayList<>();
    		for (String ppName : postProcessorNames) {
    			if (processedBeans.contains(ppName)) {
    				// skip - already processed in first phase above
    			}
    			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
    				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
    			}
    			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
    				orderedPostProcessorNames.add(ppName);
    			}
    			else {
    				nonOrderedPostProcessorNames.add(ppName);
    			}
    		}
    
    		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
    		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
    		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
    
    		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.
    		List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
    		for (String postProcessorName : orderedPostProcessorNames) {
    			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    		}
    		sortPostProcessors(orderedPostProcessors, beanFactory);
    		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
    
    		// Finally, invoke all other BeanFactoryPostProcessors.
    		List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
    		for (String postProcessorName : nonOrderedPostProcessorNames) {
    			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    		}
    		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
    
    		// Clear cached merged bean definitions since the post-processors might have
    		// modified the original metadata, e.g. replacing placeholders in values...
    		beanFactory.clearMetadataCache();
    	}
    

### 总结

若是注册的bean definition 实现了这两个接口, 则会调用(getBean)实例化它, 再调用相应的接口方法;  
(注意一下 BeanDefinitionRegistryPostProcessor 是继承自 BeanFactoryPostProcessor的)  
总的来说 调用的优先级是:

1.  调用接口的优先级:
    1.  优先调用(子类) BeanDefinitionRegistryPostProcessor
    2.  再调用(父类) BeanFactoryPostProcessor
2.  调用添加的方式的优先级:
    1.  优先调用外部入参, 即直接通过{@link AbstractApplicationContext#addBeanFactoryPostProcessor(org.springframework.beans.factory.config.BeanFactoryPostProcessor)} 代码添加的
    2.  再调用容器中实现 BeanFactoryPostProcessor 或者 BeanDefinitionRegistryPostProcessor 的 Bean  
        见:

> 值得一提的是: Spring 对于支持 SPEL表达式, 就是通过 `PropertySourcesPlaceholderConfigurer` 这种方式扩展实现的

六. 注册 BeanPostProcessor (BPP)处理器
--------------------------------

`org.springframework.context.support.AbstractApplicationContext#registerBeanPostProcessors`  
`org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext)`

    /**
    	 *  in short:
    	 *  1. 拿到所有实现 BeanPostProcessor 的 bean, 然后进行分类存起来
    	 *  这有一点, Spring 对 BeanDefinition 分成三种角色:
    	 *  	1. 用户定义的 Bean (ROLE_APPLICATION)
    	 *      2. 较复杂的 (ROLE_SUPPORT) 较复杂的? 通常是一个外部配置
    	 *      3. Spring 内置的(ROLE_INFRASTRUCTURE)
    	 *  2. 如果实现了 BeanPostProcessor 则会实例化这个bean, 但注意这里只是注册,并不会调用BeanPostProcessor的相关方法
    	 *
    	 *  另外 BeanPostProcessor 粗粒度太大, Spring 还细分一些子接口:
    	 *  - SmartInstantiationAwareBeanPostProcessor 它提供了更高级的Bean实例化控制方法。主要作用在于允许对Bean的实例化过程进行更精细的控制和定制。
    	 *  - MergedBeanDefinitionPostProcessor 在合并Bean定义（MergedBeanDefinition）之后但在实例化Bean之前，允许对合并后的Bean定义进行修改、调整或附加元数据。
    	 *  - DestructionAwareBeanPostProcessor 它允许在Bean被销毁之前（例如，容器关闭或特定作用域的Bean销毁）执行一些操作。
    	 */
    	public static void registerBeanPostProcessors(
    			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {
    
    		// WARNING: Although it may appear that the body of this method can be easily
    		// refactored to avoid the use of multiple loops and multiple lists, the use
    		// of multiple lists and multiple passes over the names of processors is
    		// intentional. We must ensure that we honor the contracts for PriorityOrdered
    		// and Ordered processors. Specifically, we must NOT cause processors to be
    		// instantiated (via getBean() invocations) or registered in the ApplicationContext
    		// in the wrong order.
    		//
    		// Before submitting a pull request (PR) to change this method, please review the
    		// list of all declined PRs involving changes to PostProcessorRegistrationDelegate
    		// to ensure that your proposal does not result in a breaking change:
    		// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22
    		/**
    		 * 拿到所有实现 BeanPostProcessor 的 bean名称
    		 */
    		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);
    
    		// Register BeanPostProcessorChecker that logs an info message when
    		// a bean is created during BeanPostProcessor instantiation, i.e. when
    		// a bean is not eligible for getting processed by all BeanPostProcessors.
    		/**
    		 * 计算 BeanPostProcessor(BPP) 的总数.
    		 * +1 是什么操作? 原因是: 下一行,又加了一个 BeanPostProcessorChecker
    		 */
    		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
    		// BeanPostProcessorChecker 这个BeanPostProcessor, 没啥实际作用, 就是记录了一些日志;
    		beanFactory.addBeanPostProcessor(
    				new BeanPostProcessorChecker(beanFactory, postProcessorNames, beanProcessorTargetCount));
    		// Separate between BeanPostProcessors that implement PriorityOrdered,
    		// Ordered, and the rest.
    		/**
    		 * 对 BeanPostProcessor 进行分类存起来,  再调用, 每个集合分别是
    		 * 1. priorityOrderedPostProcessors //有实现(PriorityOrdered)排序接口的
    		 * 2. internalPostProcessors //Spring内部的bean, 见: Spring将bean分为三种角色
    		 * 3. orderedPostProcessorNames //实现 Ordered 接口
    		 * 4. nonOrderedPostProcessorNames //没有指定顺序, 无序的
    		 */
    		List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
    		List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();
    		List<String> orderedPostProcessorNames = new ArrayList<>();
    		List<String> nonOrderedPostProcessorNames = new ArrayList<>();
    		for (String ppName : postProcessorNames) {
    			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
    				/**
    				 * 注意, 若 bean 实现了 PriorityOrdered 接口, 则会优先实例化它;
    				 */
    				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
    				priorityOrderedPostProcessors.add(pp);
    				if (pp instanceof MergedBeanDefinitionPostProcessor) {
    					internalPostProcessors.add(pp);
    				}
    			}
    			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
    				orderedPostProcessorNames.add(ppName);
    			}
    			else {
    				nonOrderedPostProcessorNames.add(ppName);
    			}
    		}
    
    		// First, register the BeanPostProcessors that implement PriorityOrdered.
    		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
    		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);
    
    		// Next, register the BeanPostProcessors that implement Ordered.
    		List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
    		for (String ppName : orderedPostProcessorNames) {
    			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
    			orderedPostProcessors.add(pp);
    			if (pp instanceof MergedBeanDefinitionPostProcessor) {
    				internalPostProcessors.add(pp);
    			}
    		}
    		sortPostProcessors(orderedPostProcessors, beanFactory);
    		registerBeanPostProcessors(beanFactory, orderedPostProcessors);
    
    		/**
    		 * 注册所有常规BeanPostProcessors
    		 * 这里 getBean 实例化bean !;
    		 */
    		// Now, register all regular(常规) BeanPostProcessors.
    		List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
    		for (String ppName : nonOrderedPostProcessorNames) {
    			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
    			nonOrderedPostProcessors.add(pp);
    			if (pp instanceof MergedBeanDefinitionPostProcessor) {
    				internalPostProcessors.add(pp);
    			}
    		}
    		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);
    
    		/**
    		 * 最后, 注册所有 内置 BeanPostProcessor
    		 */
    		// Finally, re-register all internal BeanPostProcessors.
    		sortPostProcessors(internalPostProcessors, beanFactory);
    		registerBeanPostProcessors(beanFactory, internalPostProcessors);
    
    		//最后再放一个 ApplicationListenerDetector 让它在最后 (不是重点, 见名应该是事件相关的)
    		// Re-register post-processor for detecting inner beans as ApplicationListeners,
    		// moving it to the end of the processor chain (for picking up proxies etc).
    		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
    	}
    

### 总结

1.  拿到所有 BeanPostProcessor 类型的 bean
2.  实例化 BeanPostProcessor  
    优先实例化 实现了 PriorityOrdered 接口的, 在实例化其它的(BPP)
3.  进行分类存到集合 {@link PostProcessorRegistrationDelegate#registerBeanPostProcessors(ConfigurableListableBeanFactory, AbstractApplicationContext)}  
    对 BeanPostProcessor 进行分类存起来, 再调用, 每个集合分别是
    1.  priorityOrderedPostProcessors //有实现(PriorityOrdered)排序接口的
    2.  internalPostProcessors //Spring内部的bean, 见: Spring将bean分为三种角色
    3.  orderedPostProcessorNames //实现 Ordered 接口
    4.  nonOrderedPostProcessorNames //没有指定顺序, 无序的  
        这有一点, Spring 对 BeanDefinition 分成三种角色:
        *   用户定义的 业务相关的 Bean Bean (ROLE\_APPLICATION)
        *   较复杂的 (ROLE\_SUPPORT) 较复杂的, 支持 AOP、事务等功能的内部实现? (不重要, 不要每一个细节都扣...)
        *   Spring 内置的(ROLE\_INFRASTRUCTURE)
4.  排序并注册到 beanFactory
    1.  这里按实现(PriorityOrdered)排序接口的、@Ordered注解的 等排序存起来. 实际调用的顺序 其实就是存起来的顺序
    2.  另外 BeanPostProcessor 接口粗粒度太大了, Spring 还细分一些子接口:
        1.  SmartInstantiationAwareBeanPostProcessor 它提供了更高级的Bean实例化控制方法。主要作用在于允许对Bean的实例化过程进行更精细的控制和定制。
        2.  MergedBeanDefinitionPostProcessor 在合并Bean定义（MergedBeanDefinition）之后但在实例化Bean之前，允许对合并后的Bean定义进行修改、调整或附加元数据。
        3.  DestructionAwareBeanPostProcessor 它允许在Bean被销毁之前（例如，容器关闭或特定作用域的Bean销毁）执行一些操作。  
            等等以上也会存起来
5.  最终调用 BPP是在 {@link AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)} 实例初始化其他Bean调用

七. 初始化国际化(I18N) 信息源
-------------------

`org.springframework.context.support.AbstractApplicationContext#initMessageSource`

    /**
    	 * Initialize the MessageSource.
    	 * Use parent's if none defined in this context.
    	 * 主要是对I18N国际化的处理，
    	 */
    	protected void initMessageSource() {
    		/**
    		 * //拿到 bean factory
    		 */
    		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    		/**
    		 * 是否有定义名称为 MESSAGE_SOURCE_BEAN_NAME 的 Bean
    		 *  {@link org.springframework.context.support.AbstractApplicationContext#MESSAGE_SOURCE_BEAN_NAME }
    		 */
    		if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
    			this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
    			// Make MessageSource aware of parent MessageSource.
    			if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource hms &&
    					hms.getParentMessageSource() == null) {
    				// Only set parent context as parent MessageSource if no parent MessageSource
    				// registered already.
    				/**
    				 * 如果有的话，就使用该定义的MessageSource 处理消息国际化
    				 */
    				hms.setParentMessageSource(getInternalParentMessageSource());
    			}
    			if (logger.isTraceEnabled()) {
    				logger.trace("Using MessageSource [" + this.messageSource + "]");
    			}
    		}
    		else {
    			/**
    			 *  如果没有 MESSAGE_SOURCE_BEAN_NAME 则默认使用 DelegatingMessageSource;
    			 *  注册到 beanFactory
    			 */
    			// Use empty MessageSource to be able to accept getMessage calls.
    			DelegatingMessageSource dms = new DelegatingMessageSource();
    			dms.setParentMessageSource(getInternalParentMessageSource());
    			//注意这 Context属性
    			this.messageSource = dms;
    			beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
    			if (logger.isTraceEnabled()) {
    				logger.trace("No '" + MESSAGE_SOURCE_BEAN_NAME + "' bean, using [" + this.messageSource + "]");
    			}
    		}
    	}
    

### 总结

很简单:

1.  如果beanFactory中有名称为 messageSource 的Bean定义，就使用这bean作物国际化消息源  
    如果没有则默认使用 org.springframework.context.support.DelegatingMessageSource 并注册到 beanFactory

用于国际化的, 不重要, 本屌作为社会底层牛马, 暂未做过跨国项目

八. 初始化事件多播器
-----------

`org.springframework.context.support.AbstractApplicationContext#initApplicationEventMulticaster`

    	/**
    	 * Initialize the ApplicationEventMulticaster.
    	 * Uses SimpleApplicationEventMulticaster if none defined in the context.
    	 * @see org.springframework.context.event.SimpleApplicationEventMulticaster
    	 */
    	protected void initApplicationEventMulticaster() {
    		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    		/**
    		 * 1. 如果 beanFactory 中包含名称为 APPLICATION_EVENT_MULTICASTER_BEAN_NAME的bean定义, 则使用这个 ApplicationEventMulticaster 作为 事件多播器
    		 * 如果不包含则创建 SimpleApplicationEventMulticaster作为事件多播器;
    		 */
    		if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
    			this.applicationEventMulticaster =
    					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
    			if (logger.isTraceEnabled()) {
    				logger.trace("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");
    			}
    		}
    		else {
    			/**
    			 * 2. 创建 SimpleApplicationEventMulticaster 作为默认的事件多播器 (Event Channel)
    			 *  其实就是初始化了一个 用于存放/管理 ApplicationListener 监听器(观察者)的类
    			 *   在Spring 事件机制中, 在容器发布事件时 `this.applicationEventMulticaster.multicastEvent(new ObjectEvent());`
    			 *  @see org.springframework.context.event.AbstractApplicationEventMulticaster#defaultRetriever 用户存放/管理 各个监听器的(观察者)
    			 *  @see AbstractApplicationContext#publishEvent(Object, ResolvableType) 调用容器发布事件
    			 *
    			 *  这个 applicationEventMulticaster 除了在容器发布事件时用它, 在注册监听器时直接用它 {@link AbstractApplicationContext#registerListeners()}
    			 */
    			this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
    			/**
    			 * 将其注册到 beanFactory;
    			 * 注意 这是实例, 它直接放到一级缓存中.
    			 */
    			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
    			if (logger.isTraceEnabled()) {
    				logger.trace("No '" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + "' bean, using " +
    						"[" + this.applicationEventMulticaster.getClass().getSimpleName() + "]");
    			}
    		}
    	}
    

### 总结

1.  如果 beanFactory 中包含名称为 applicationEventMulticaster 的bean定义, 则使用这个Bean作为事件多播器;  
    如果不包含则创建 SimpleApplicationEventMulticaster作为事件多播器;
2.  创建SimpleApplicationEventMulticaster其实就是初始化了一个,用于存放/管理 ApplicationListener 监听器(观察者)的类, 并注册到 beanFactory

*   主要是 {@link org.springframework.context.event.AbstractApplicationEventMulticaster#defaultRetriever} 用于存放/管理 各个监听器的(观察者)
*   {@link org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType) }调用容器发布事件

参考此前的博客 - [Spring 中的Event机制](https://www.cnblogs.com/dddy/p/19191523 "发布于 2025-11-04 22:25")

九. 给子类(Context)留下一个扩展点
----------------------

没什么好说的, 这里是空实现

`org.springframework.context.support.AbstractApplicationContext#onRefresh`

    /**
     * Template method which can be overridden to add context-specific refresh work.
     * Called on initialization of special beans, before instantiation of singletons.
     * <p>This implementation is empty.
     * @throws BeansException in case of errors
     * @see #refresh()
     */
    protected void onRefresh() throws BeansException {
    	// For subclasses: do nothing by default.
    }
    

十. 向多播器注册监听器
------------

`org.springframework.context.support.AbstractApplicationContext#registerListeners`

    /**
    	 * Add beans that implement ApplicationListener as listeners.
    	 * Doesn't affect other listeners, which can be added without being beans.
    	 */
    	protected void registerListeners() {
    		/**
    		 * 1. 向多播器中注册 在context中的监听器(观察者)
    		 */
    		// Register statically specified listeners first.
    		for (ApplicationListener<?> listener : getApplicationListeners()) {
    			getApplicationEventMulticaster().addApplicationListener(listener);
    		}
    
    		// Do not initialize FactoryBeans here: We need to leave all regular beans
    		// uninitialized to let post-processors apply to them!
    		/**
    		 *  2. 向多播器中注册 在beanFactory中的bean是监听器(ApplicationListener.class)的(观察者)
    		 *  注意:
    		 *  2.1 这里是会先从 BeanFactory (getBeanNamesForType)获取是 ApplicationListener.class 的 bean name
    		 *  2.2 注意只是查找匹配类型的 bean 名称, 没有实例化 存的也是 bean name;
    		 */
    		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    		for (String listenerBeanName : listenerBeanNames) {
    			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    		}
    
    		/**
    		 * 3. 广播 this.earlyApplicationEvents 属性中的事件;
    		 * 为什么?
    		 * 因为有可能 在容器生命周期中调用了当前 `AbstractApplicationContext#publishEvent` 发布事件, 但是多播器没有初始化完成, 所以会将事件存在this.earlyApplicationEvents 中;
    		 * 待容器初始化完成后, 	在流程  {@link org.springframework.context.support.AbstractApplicationContext#registerListeners()} 中会发布存在这里面的事件
    		 * (例如: 在 BeanFactoryPostProcessor 的业务逻辑触发容器的广播事件, 这时候多播器都不存在, 也不知道有哪些 bean作为观察者)
    		 * @see AbstractApplicationContext#prepareRefresh()
    		 */
    		// Publish early application events now that we finally have a multicaster...
    		Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
    		this.earlyApplicationEvents = null;//下一步 multicastEvent 后就没用了, 赋 null 释放资源.
    		if (!CollectionUtils.isEmpty(earlyEventsToProcess)) {
    			for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
    				getApplicationEventMulticaster().multicastEvent(earlyEvent);
    			}
    		}
    	}
    

### 总结

1.  向多播器中注册 在context中的监听器(观察者);
2.  向多播器中注册 在beanFactory中的bean是监听器(ApplicationListener.class)的(观察者)
3.  广播 this.earlyApplicationEvents 属性中的事件;  
    为什么?
    
    *   因为有可能 在容器生命周期中调用了当前 `AbstractApplicationContext#publishEvent` 发布事件, 但是多播器没有初始化完成, 所以会将事件存在this.earlyApplicationEvents 中; 这里多播器已经准备 会发布存在这里面的事件 (例如: 在 BeanFactoryPostProcessor 的业务逻辑触发容器的广播事件, 这时候多播器都不存在)
    
    *   @see AbstractApplicationContext#prepareRefresh()

十一. 实例化剩下的所有单例bean
------------------

### 准备类型转换器 变量解析器等

`org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization`

    /**
    	 * Finish the initialization of this context's bean factory,
    	 * initializing all remaining singleton beans.
    	 */
    	protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    		// Initialize conversion service for this context.
    		/**
    		 *
    		 * 1. 为 beanFactory 初始化类型转换器(ConversionService)
    		 *   注意: 在 Spring 中`ConversionService` 是用于类型转换的服务接口, 它是转换类型的入口点, 但是真正的转换逻辑功能 则由 Converter 和 GenericConverter 接口的实现处理的
    		 */
    		if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
    				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
    			beanFactory.setConversionService(
    					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
    		}
    
    		// Register a default embedded value resolver if no BeanFactoryPostProcessor
    		// (such as a PropertySourcesPlaceholderConfigurer bean) registered any before:
    		// at this point, primarily for resolution in annotation attribute values.
    		/**
    		 * 2. 如果 beanFactory 上下文中不包含 "默认的变量解析器 (类似 PropertySourcesPlaceholderConfigurer) 解析类似 '${}' 这样的变量 "
    		 * 则使用环境对象(ConfigurableEnvironment)中的 ConfigurablePropertyResolver实现来作为 StringValueResolver 添加进去
    		 */
    		if (!beanFactory.hasEmbeddedValueResolver()) {
    			beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));
    		}
    		// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
    		/**
    		 * 3. 先实例化化 LoadTimeWeaverAware bean，以便尽早注册它们的转换器。
    		 * TODO AOP 相关的
    		 */
    		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    		for (String weaverAwareName : weaverAwareNames) {
    			getBean(weaverAwareName);
    		}
    
    		// Stop using the temporary ClassLoader for type matching.
    		// 停止使用临时ClassLoader进行类型匹配
    		beanFactory.setTempClassLoader(null);
    
    		// Allow for caching all bean definition metadata, not expecting further changes.
    		/**
    		 * 4. 冻结配置, 这时候就不再允许更改 beanDefinition 了; (其实就是 clearMetadataCache 和 设置了一个标识符)
    		 */
    		beanFactory.freezeConfiguration();
    
    		// Instantiate all remaining (non-lazy-init) singletons.
    		/**
    		 * 5. 实例化所有剩余的 (非lazy-init) 单例 Bean
    		 */
    		beanFactory.preInstantiateSingletons();
    	}
    

### 处理 FactoryBean 等

`org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons`

    @Override
    	public void preInstantiateSingletons() throws BeansException {
    		if (logger.isTraceEnabled()) {
    			logger.trace("Pre-instantiating singletons in " + this);
    		}
    		// Iterate over a copy to allow for init methods which in turn register new bean definitions.
    		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.
    		/**
    		 *  所有已注册的Bean name 列表;
    		 *  这里复制一份, 方便遍历;
    		 */
    		List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);
    
    		// Trigger initialization of all non-lazy singleton beans...
    		for (String beanName : beanNames) {
    			/**
    			 * 合并到父类的 BeanDefinition 得到 RootBeanDefinition, 放入缓存中.
    			 * (每一个Bean都有 RootBeanDefinition, 没有的话 getMergedLocalBeanDefinition 会创建一个, 并放入缓存中)
    			 *
    			 * 为什么需要往上缓存 RootBeanDefinition ?
    			 * 实例化一个对象的时候, 肯定是先实例化父对象, 有父对象才能实例子对象
    			 */
    			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
    			//如果该 bean 是: 非抽象, 是单例, 非懒加载
    			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
    				/**
    				 * 如果该bean是 FactoryBean, 则在 bean name 前面加一个 '&' 前缀, 先获取/实例化 FactoryBean 本身;
    				 *  注意一下 FactoryBean 生成对象是不遵循 Spring 的bean生命周期的
    				 *
    				 * 这有两个对象, 如何获取? getBean(beanName) :
    				 * 1. 传入 FactoryBean 的 name 返回的是其 getObject 的目标对象实例;
    				 * 2. 如果想获取 FactoryBean 本身实例, 则前面需要加一个 '&' 前缀;
    				 *
    				 */
    				if (isFactoryBean(beanName)) {
    					/**
    					 * 获取/实例化 factoryBean 本身
    					 */
    					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
    					if (bean instanceof SmartFactoryBean<?> smartFactoryBean
    							&& smartFactoryBean.isEagerInit()) {
    						/**
    						 * 如果是 SmartFactoryBean 并且 是急加载:
    						 * 则再获取/实例化该 FactoryBean 的目标对象
    						 */
    						getBean(beanName);
    					}
    				}
    				else {
    					getBean(beanName);
    				}
    			}
    		}
    
    		// Trigger post-initialization callback for all applicable beans...
    		for (String beanName : beanNames) {
    			Object singletonInstance = getSingleton(beanName);
    			if (singletonInstance instanceof SmartInitializingSingleton smartSingleton) {
    				StartupStep smartInitialize = getApplicationStartup().start("spring.beans.smart-initialize")
    						.tag("beanName", beanName);
    				smartSingleton.afterSingletonsInstantiated();
    				smartInitialize.end();
    			}
    		}
    	}
    

### 尝试从 一 二 三级缓存中获取

`org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)`  
`org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean`

    /**
    	 * Return an instance, which may be shared or independent, of the specified bean.
    	 * @param name the name of the bean to retrieve
    	 * @param requiredType the required type of the bean to retrieve
    	 * @param args arguments to use when creating a bean instance using explicit arguments
    	 * (only applied when creating a new instance as opposed to retrieving an existing one)
    	 * @param typeCheckOnly whether the instance is obtained for a type check,
    	 * not for actual use
    	 * @return an instance of the bean
    	 * @throws BeansException if the bean could not be created
    	 */
    	@SuppressWarnings("unchecked")
    	protected <T> T doGetBean(
    			String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
    			throws BeansException {
    
    		/**
    		 *
    		 * 转换 bean name; 如果名称中带 BeanFactory.FACTORY_BEAN_PREFIX, 则会去掉它;
    		 * {@link BeanFactory#FACTORY_BEAN_PREFIX}
    		 */
    		String beanName = transformedBeanName(name);
    		Object beanInstance;
    		// Eagerly check singleton cache for manually registered singletons.
    		/**
    		 * 尝试从当前容器 一 二 三级缓存获取
    		 */
    		Object sharedInstance = getSingleton(beanName);
    		if (sharedInstance != null && args == null) {
    			/**
    			 * 如果缓存中有
    			 */
    			if (logger.isTraceEnabled()) {
    				if (isSingletonCurrentlyInCreation(beanName)) {
    					logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
    							"' that is not fully initialized yet - a consequence of a circular reference");
    				}
    				else {
    					logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
    				}
    			}
    			/**
    			 * 如果拿到的Bean是 FactoryBean 实现, 则会调用 `T getObject() throws Exception` 获取其对象
    			 * 再将目标对象放入org.springframework.beans.factory.support.FactoryBeanRegistrySupport#factoryBeanObjectCache缓存中
    			 * 最终在 {@link org.springframework.beans.factory.support.FactoryBeanRegistrySupport#doGetObjectFromFactoryBean}
    			 */
    			beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null);
    		}
    		else {
    			/**
    			 * 如果缓存中没有
    			 */
    
    			/**
    			 *  判断该bean是否在创建中 (循环创建), 用的是一个ThreadLocal
    			 *  {@link org.springframework.beans.factory.support.AbstractBeanFactory#prototypesCurrentlyInCreation}
    			 */
    			// Fail if we're already creating this bean instance:
    			// We're assumably within a circular reference.
    			if (isPrototypeCurrentlyInCreation(beanName)) {
    				throw new BeanCurrentlyInCreationException(beanName);
    			}
    			/**
    			 * 优先尝试从 父 BeanFactory中拿, 类似类加载器的双亲委托机制
    			 * 一般 父容器都是空的
    			 */
    			// Check if bean definition exists in this factory.
    			BeanFactory parentBeanFactory = getParentBeanFactory();
    			if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
    				// Not found -> check parent.
    				String nameToLookup = originalBeanName(name);
    				if (parentBeanFactory instanceof AbstractBeanFactory abf) {
    					return abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
    				}
    				else if (args != null) {
    					// Delegation to parent with explicit args.
    					return (T) parentBeanFactory.getBean(nameToLookup, args);
    				}
    				else if (requiredType != null) {
    					// No args -> delegate to standard getBean method.
    					return parentBeanFactory.getBean(nameToLookup, requiredType);
    				}
    				else {
    					return (T) parentBeanFactory.getBean(nameToLookup);
    				}
    			}
    
    			/**
    			 * 标记该 bean为创建中或者已创建;
    			 * 其实就是用 Set集合 {@link org.springframework.beans.factory.support.AbstractBeanFactory#alreadyCreated} 存起来
    			 */
    			if (!typeCheckOnly) {
    				markBeanAsCreated(beanName);
    			}
    
    			/**
    			 * 记录器 (打印某些关键过程日志, 收集分析, 不重要)
    			 */
    			StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate")
    					.tag("beanName", name);
    			try {
    				if (requiredType != null) {
    					beanCreation.tag("beanType", requiredType::toString);
    				}
    				/**
    				 * 拿到其 RootBeanDefinition (完整的Bean元数据描述)
    				 */
    				RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
    				//检查BeanDefinition, 就判断一下是该bean 否抽象类
    				checkMergedBeanDefinition(mbd, beanName, args);
    
    				/**
    				 * 如果存在依赖配置, 则先创建依赖的Bean
    				 * (即XML的 <bean id="..." depends-on="" ...></bean> 配置)
    				 */
    				// Guarantee initialization of beans that the current bean depends on.
    				String[] dependsOn = mbd.getDependsOn();
    				if (dependsOn != null) {
    					for (String dep : dependsOn) {
    						if (isDependent(beanName, dep)) {
    							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
    									"Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
    						}
    						registerDependentBean(dep, beanName);
    						try {
    							getBean(dep);
    						}
    						catch (NoSuchBeanDefinitionException ex) {
    							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
    									"'" + beanName + "' depends on missing bean '" + dep + "'", ex);
    						}
    					}
    				}
    
    				// Create bean instance.
    				if (mbd.isSingleton()) {
    					/**
    					 * 如果是单例的 Bean
    					 * =============================
    					 */
    
    					/**
    					 * 注意 传递一个 '创建Bean' 的Lambda函数/对象 (ObjectFactory)
    					 * getSingleton 的逻辑是:
    					 * 	 1. 尝试从一级缓存中拿
    					 * 	 2. 将Bean Name 添加到 创建中状态的集合 记录起来;
    					 * 	  {@link org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonsCurrentlyInCreation}
    					 *   3. 调用 ObjectFactory#getObject() 回调回来 createBean
    					 *   4. 如果是新创建的添加到一级缓冲中
    					 */
    					sharedInstance = getSingleton(beanName, () -> {
    						try {
    							/**
    							 * 见: {@link AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])}
    							 */
    							return createBean(beanName, mbd, args);
    						}
    						catch (BeansException ex) {
    							// Explicitly remove instance from singleton cache: It might have been put there
    							// eagerly by the creation process, to allow for circular reference resolution.
    							// Also remove any beans that received a temporary reference to the bean.
    							destroySingleton(beanName);
    							throw ex;
    						}
    					});
    					beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
    				}
    				else if (mbd.isPrototype()) {
    					/**
    					 * 如果是原型的 Bean
    					 * =============================
    					 */
    					// It's a prototype -> create a new instance.
    					Object prototypeInstance = null;
    					try {
    						beforePrototypeCreation(beanName);
    						prototypeInstance = createBean(beanName, mbd, args);
    					}
    					finally {
    						afterPrototypeCreation(beanName);
    					}
    					beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
    				}
    
    				else {
    					String scopeName = mbd.getScope();
    					if (!StringUtils.hasLength(scopeName)) {
    						throw new IllegalStateException("No scope name defined for bean '" + beanName + "'");
    					}
    					Scope scope = this.scopes.get(scopeName);
    					if (scope == null) {
    						throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
    					}
    					try {
    						Object scopedInstance = scope.get(beanName, () -> {
    							beforePrototypeCreation(beanName);
    							try {
    								return createBean(beanName, mbd, args);
    							}
    							finally {
    								afterPrototypeCreation(beanName);
    							}
    						});
    						beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
    					}
    					catch (IllegalStateException ex) {
    						throw new ScopeNotActiveException(beanName, scopeName, ex);
    					}
    				}
    			}
    			catch (BeansException ex) {
    				beanCreation.tag("exception", ex.getClass().toString());
    				beanCreation.tag("message", String.valueOf(ex.getMessage()));
    				cleanupAfterBeanCreationFailure(beanName);
    				throw ex;
    			}
    			finally {
    				beanCreation.end();
    				if (!isCacheBeanMetadata()) {
    					clearMergedBeanDefinition(beanName);
    				}
    			}
    		}
    
    		/**
    		 * 适配转换为 需求的目标类型 requiredType
    		 * 多态: 子类是可以向上转型的
    		 */
    		return adaptBeanInstance(name, beanInstance, requiredType);
    	}
    

### 处理InstantiationAwareBeanPostProcessor AOP代理

`org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])`

    /**
    	 * Central method of this class: creates a bean instance,
    	 * populates the bean instance, applies post-processors, etc.
    	 * @see #doCreateBean
    	 */
    	@Override
    	protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
    			throws BeanCreationException {
    
    		if (logger.isTraceEnabled()) {
    			logger.trace("Creating instance of bean '" + beanName + "'");
    		}
    		RootBeanDefinition mbdToUse = mbd;
    
    		// Make sure bean class is actually resolved at this point, and
    		// clone the bean definition in case of a dynamically resolved Class
    		// which cannot be stored in the shared merged bean definition.
    		/**
    		 * 1. 解析到 BeanDefinition 的 Class
    		 */
    		Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
    		/**
    		 * 2. 创建BeanDefinition 复制一份 RootBeanDefinition
    		 */
    		if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
    			mbdToUse = new RootBeanDefinition(mbd);
    			mbdToUse.setBeanClass(resolvedClass);
    		}
    
    		// Prepare method overrides.
    		try {
    			/**
    			 * 3. 准备和验证 lookup-method 和 replace-method;
    			 * 注意: 这里只是标记, 真正处理是在实例化时, 选择策略生成一个CgLib的代理对象 {@link org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy}
    			 * 关于它们的作用见笔记 [[Spring lookup-method 和 replace-method.md]]
    			 */
    			mbdToUse.prepareMethodOverrides();
    		}
    		catch (BeanDefinitionValidationException ex) {
    			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
    					beanName, "Validation of method overrides failed", ex);
    		}
    
    		try {
    			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
    			/**
    			 * 4. 给 BeanPostProcessors 一个返回(用户自定义, 如果有AOP, 则会 用户代理 再 Spring代理)代理实例的机会;
    			 * 调用 InstantiationAwareBeanPostProcessor 的
    			 * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation(java.lang.Class, java.lang.String)}
    			 * 和
    			 * {@link InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation(java.lang.Class, java.lang.String)}
    			 * 可以自定义创建 bean动态代理实例返回 (AOP相关)
    			 *  
    			 * 见笔记:
    			 * [[BeanPostProcessor接口.md]]
    			 * [[Spring 中的AOP]]
    			 *
    			 * 注意, 这里的逻辑:
    			 * 如果其 InstantiationAwareBeanPostProcessor 返回不为null, 则直接使用这个bean实例返回了, 不走 doCreateBean等下面的流程
    			 * (注意的注意! 如果有用户自定义的拦截创建, 甚至优先Spring的AOP代理创建)
    			 */
    			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
    			if (bean != null) {
    				return bean;
    			}
    		}
    		catch (Throwable ex) {
    			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
    					"BeanPostProcessor before instantiation of bean failed", ex);
    		}
    
    		try {
    			/**
    			 * 继续
    			 */
    			Object beanInstance = doCreateBean(beanName, mbdToUse, args);
    			if (logger.isTraceEnabled()) {
    				logger.trace("Finished creating instance of bean '" + beanName + "'");
    			}
    			return beanInstance;
    		}
    		catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
    			// A previously detected exception with proper bean creation context already,
    			// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
    			throw ex;
    		}
    		catch (Throwable ex) {
    			throw new BeanCreationException(
    					mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", ex);
    		}
    	}
    

### 真正在jvm层面实例化对象

`org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean`

    /**
    	 * Actually create the specified bean. Pre-creation processing has already happened
    	 * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.
    	 * <p>Differentiates between default bean instantiation, use of a
    	 * factory method, and autowiring a constructor.
    	 *
    	 * 真正的 在JVM层 创建Bean实例
    	 *
    	 * @param beanName the name of the bean
    	 * @param mbd the merged bean definition for the bean
    	 * @param args explicit arguments to use for constructor or factory method invocation
    	 * @return a new instance of the bean
    	 * @throws BeanCreationException if the bean could not be created
    	 * @see #instantiateBean
    	 * @see #instantiateUsingFactoryMethod
    	 * @see #autowireConstructor
    	 *
    	 */
    	protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
    			throws BeanCreationException {
    
    		// Instantiate the bean.
    		BeanWrapper instanceWrapper = null;
    		if (mbd.isSingleton()) {
    			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
    		}
    		if (instanceWrapper == null) {
    			/**
    			 *  1. 真正在jvm层面实例化对象;
    			 *    1.1 如果该 BeanDefinition 有配置 instanceSupplier属性(java.util.function.Supplier),
    			 * 		 将使用其Supplier#get方法的返回, 作为实例对象
    			 *    1.2 如果该 BeanDefinition 有配置 factory-method 将使用该方法返回的, 作为实例对象
    			 * 		 这里这里包括'静态工厂'和'实例工厂'的处理(通过bd的factoryBeanName 进行判断, 如果存在则是'实例工厂')
    			 * 	  1.3 使用反射实例化, 根据策略实例化Bean对象 {@link org.springframework.beans.factory.support.SimpleInstantiationStrategy}
    			 * 	   - 使用有参构造函数注入,创建 (new)
    			 * 	   - 使用无参构造函数创建 (new)
    			 * 	   - 工厂方法实例化 ('静态工厂' '实例工厂' )
    			 * 	     `<bean  factory-bean="bookFactoryBean"  factory-method="getBook()"/>`
    			 * 	        静态工厂: factory-bean 若是 全限定类名 则使用 BookFactoryBean::getBook 的静态方法返回的对象
    			 * 	        实例工厂:  factory-bean 若是 bean 名 则使用该实例方法返回的对象
    			 *
    			 * 	{@link AbstractAutowireCapableBeanFactory#createBeanInstance(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])}
    			 *  2. 用BeanWrapper 包装原始bean (装饰模式)
    			 *  初始化 BeanWrapper
    			 * 	 2.1 给 BeanWrapper 设置了, ConversionService
    			 *   2.2 给 BeanWrapper 注册了, 当前 bean factory (propertyEditorRegistrars)中的全部 PropertyEditor
    			 * {@link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#instantiateBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition)}
    			 *
    			 */
    			instanceWrapper = createBeanInstance(beanName, mbd, args);
    		}
    		/**
    		 * 获取 BeanWrapper中的原始 Bean 实例
    		 */
    		Object bean = instanceWrapper.getWrappedInstance();
    		/**
    		 * 获取 Bean Class类型
    		 */
    		Class<?> beanType = instanceWrapper.getWrappedClass();
    		if (beanType != NullBean.class) {
    			mbd.resolvedTargetType = beanType;
    		}
    
    		// Allow post-processors to modify the merged bean definition.
    		synchronized (mbd.postProcessingLock) {
    			if (!mbd.postProcessed) {
    				try {
    					/**
    					 * 3. 处理 MergedBeanDefinitionPostProcessor 的接口回调
    					 * 调用 添加在 context 中 BeanPostProcessor 的 MergedBeanDefinitionPostProcessor 的接口回调
    					 * 解析到诸如`@Autowired`之类的注解 (Metadata)元信息,合并到BeanDefinition中
    					 *
    					 * 注意在当前步骤中,只是解析,并注册(修改)到 BeanDefinition 中, 并没有调用;
    					 *
    					 * 例如:
    					 *  1. 处理 `@Autowired` `@Value`, `@Inject`
    					 * 对应处理类是 `org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor`
    					 * 这个 真正处理是在填充属性时, [[回调所有 InstantiationAwareBeanPostProcessor#postProcessProperties 方法]] {@link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, org.springframework.beans.BeanWrapper)}
    					 * 负责查找相应的注解方法信息, 封装为 Metadata 元数据(使用集合存起来), 再将这些 Metadata 元数据, 注册(修改)到 BeanDefinition 中
    					 *
    					 *  2. 处理 `@Resource`
    					 * 对应处理类 `org.springframework.context.annotation.CommonAnnotationBeanPostProcessor`
    					 *
    					 *  3. 处理 `init-method`, `@PostConstruct`, `@PreDestroy`
    					 * 对应处理类 `org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor`
    					 *
    					 */
    					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
    				}
    				catch (Throwable ex) {
    					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
    							"Post-processing of merged bean definition failed", ex);
    				}
    				mbd.markAsPostProcessed();
    			}
    		}
    
    		// Eagerly cache singletons to be able to resolve circular references
    		// even when triggered by lifecycle interfaces like BeanFactoryAware.
    		/**
    		 * 判断当前:  是否单例 && 是否允许循环依赖 && 是否正在创建过程中
    		 *(循环依赖AOP)
    		 */
    		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
    				isSingletonCurrentlyInCreation(beanName));
    		if (earlySingletonExposure) {
    			if (logger.isTraceEnabled()) {
    				logger.trace("Eagerly caching bean '" + beanName +
    						"' to allow for resolving potential circular references");
    			}
    			/**
    			 * 放到三级缓存(三级缓存 存放Lambda)
    			 * <!> 循环依赖 AOP :这里其实就是会调用到 AutoProxyCreator 在其进行判断是否需要, 最终会调用到 createProxy 进行动态代理对象创建
    			 * {@link org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#getEarlyBeanReference(java.lang.Object, java.lang.String)}
    			 *
    			 */
    			addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
    		}
    
    		// Initialize the bean instance.
    		Object exposedObject = bean;
    		try {
    			/**
    			 * 2.填充Bean属性
    			 * 如果是AOP, pointcut, advice相关的, synthetic 会配置为 true
    			 *   1. 调用 BeanPostProcessor 的子接口 InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation
    			 * 	 (作用是 在实例化之后，属性填充之前执行操作, 可以拦截属性填充操作)
    			 */
    			populateBean(beanName, mbd, instanceWrapper);
    			/**
    			 * 3.初始化Bean对象
    			 *   1.先调用这三个 BeanNameAware, BeanClassLoaderAware, BeanFactoryAware
    			 * 	  这三个是在创建BeanFactory 时忽略的三个 Aware 接口
    			 *   2. 调用所有 BeanPostProcessors#postProcessBeforeInitialization (作用: 在Bean初始化之前调用)
    			 *   3. 调用 init-method 方法
    			 *   4. 调用所有 BeanPostProcessors#postProcessAfterInitialization (作用: 在Bean初始化之后调用)
    			 */
    			exposedObject = initializeBean(beanName, exposedObject, mbd);
    		}
    		catch (Throwable ex) {
    			if (ex instanceof BeanCreationException bce && beanName.equals(bce.getBeanName())) {
    				throw bce;
    			}
    			else {
    				throw new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);
    			}
    		}
    
    		if (earlySingletonExposure) {
    			/**
    			 * 循环依赖AOP 相关 (循环依赖AOP)
    			 * =======================
    			 */
    
    			/**
    			 * 再从缓存中拿一次获取并替换,是因为有可能是被代理(earlySingletonReference)
    			 */
    			Object earlySingletonReference = getSingleton(beanName, false);
    			if (earlySingletonReference != null) {
    				/**
    				 *  (循环依赖AOP)
    				 *  注意: 这个bean是原始实例, 再从缓存中拿一次,是因为有可能是被代理(earlySingletonReference)
    				 */
    				if (exposedObject == bean) {
    					// 不一致就是被代理了
    					exposedObject = earlySingletonReference;
    				}
    				else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
    					String[] dependentBeans = getDependentBeans(beanName);
    					Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
    					for (String dependentBean : dependentBeans) {
    						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
    							actualDependentBeans.add(dependentBean);
    						}
    					}
    					if (!actualDependentBeans.isEmpty()) {
    						throw new BeanCurrentlyInCreationException(beanName,
    								"Bean with name '" + beanName + "' has been injected into other beans [" +
    										StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
    										"] in its raw version as part of a circular reference, but has eventually been " +
    										"wrapped. This means that said other beans do not use the final version of the " +
    										"bean. This is often the result of over-eager type matching - consider using " +
    										"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.");
    					}
    				}
    			}
    		}
    
    		// Register bean as disposable.
    		try {
    			/**
    			 * 注册 bean销毁的工作(如果需要)
    			 * 1. org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor#postProcessBeforeDestruction(Object,String) BPP接口
    			 * 2. org.springframework.beans.factory.DisposableBean 接口
    			 * 3. 自定义 destroy方法
    			 * 在容器关闭时会调用会按这个顺序调用
    			 */
    			registerDisposableBeanIfNecessary(beanName, bean, mbd);
    		}
    		catch (BeanDefinitionValidationException ex) {
    			throw new BeanCreationException(
    					mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
    		}
    
    		return exposedObject;
    	}
    

### 实例化 构造函数的细节

    
    	/**
    	 * 实例化详细过程
    	 * 
    	 * Create a new instance for the specified bean, using an appropriate instantiation strategy:
    	 * factory method, constructor autowiring, or simple instantiation.
    	 * @param beanName the name of the bean
    	 * @param mbd the bean definition for the bean
    	 * @param args explicit arguments to use for constructor or factory method invocation
    	 * @return a BeanWrapper for the new instance
    	 * @see #obtainFromSupplier
    	 * @see #instantiateUsingFactoryMethod
    	 * @see #autowireConstructor
    	 * @see #instantiateBean
    	 *
    	 */
    	protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
    		// Make sure bean class is actually resolved at this point.
    		// 确保Class 是可以实例化的
    		Class<?> beanClass = resolveBeanClass(mbd, beanName);
    		/**
    		 * 验证一下构造方法 访问修饰符
    		 */
    		if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
    			throw new BeanCreationException(mbd.getResourceDescription(), beanName,
    					"Bean class isn't public, and nonpublic access not allowed: " + beanClass.getName());
    		}
    		/**
    		 * 如果该 BeanDefinition 有配置 instanceSupplier属性(java.util.function.Supplier),
    		 * 将使用其Supplier#get方法的返回, 作为实例对象
    		 */
    		Supplier<?> instanceSupplier = mbd.getInstanceSupplier();
    		if (instanceSupplier != null) {
    			return obtainFromSupplier(instanceSupplier, beanName, mbd);
    		}
    
    		/**
    		 * 如果该 BeanDefinition 有配置 factory-method 将使用该方法的返回 作为实例对象
    		 * 这里这里包括'静态工厂'和'实例工厂'的处理(通过bd的factoryBeanName 进行判断, 如果存在则是'实例工厂')
    		 *
    		 * 静态工厂(注意 工厂方法是static方法)
    		 * <bean id="user" class="org.yang.User"  factory-method="createUser"/>
    		 *
    		 * 实例工厂(注意 工厂对象是一个实例, 使用该实例方法返回的)
    		 * <bean id="userFactory" class="org.yang.UserFactory"/>
    		 *  <! -- factory-bean 指向实例工厂 Bean -->
    		 * <bean id="user" class="org.yang.User" factory-bean="userFactory" factory-method="createUser"/>
    		 *
    		 */
    		if (mbd.getFactoryMethodName() != null) {
    			return instantiateUsingFactoryMethod(beanName, mbd, args);
    		}
    
    		/**
    		 *  =======================
    		 *  in short : 下面主要逻辑就是 找到一个合适的构造函数和注入方式, 然后存起来, 通过反射实例化
    		 *  如果下次还需要就直接根据情况直接执行(仅原型Bean才有重复创建的情况)
    		 */
    		// Shortcut when re-creating the same bean...
    		/**
    		 * 是否已经解析/创建过了
    		 */
    		boolean resolved = false;
    		/**
    		 * 是否需要自动注入
    		 */
    		boolean autowireNecessary = false;
    		if (args == null) {
    			synchronized (mbd.constructorArgumentLock) {
    				/**
    				 * 类似一个缓存机制, 后面在 {@link org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(org.springframework.beans.factory.support.RootBeanDefinition, java.lang.String, org.springframework.beans.factory.BeanFactory)}
    				 * 解析过程中会给它赋值存起来; 下面就根据解析的情况执行
    				 */
    				if (mbd.resolvedConstructorOrFactoryMethod != null) {
    					resolved = true;
    					autowireNecessary = mbd.constructorArgumentsResolved;
    				}
    			}
    		}
    		/**
    		 * 已经解析过了, 根据解析的情况, 执行
    		 */
    		if (resolved) {
    			if (autowireNecessary) {
    				/**
    				 * 使用有参构造函数注入,创建 (new)
    				 */
    				return autowireConstructor(beanName, mbd, null, null);
    			}
    			else {
    				/**
    				 * 使用无参构造函数注入,创建 (new)
    				 */
    				return instantiateBean(beanName, mbd);
    			}
    		}
    		/**
    		 * 首次解析创建Bean
    		 * =============================
    		 */
    
    		// Candidate constructors for autowiring?
    		/**
    		 * 从 BeanPostProcessors 里面推断构造方法
    		 * SmartInstantiationAwareBeanPostProcessor 接口可以对 '构造方法注入的选择' 进行调整(推荐?)
    		 * {@link org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors(java.lang.Class, java.lang.String)}
    		 *
    		 */
    		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
    		/**
    		 * 自动转配的方式, 有五种 (见 {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory}的几个常量):
    		 *  1. AUTOWIRE_NO = 0; 未指定, 不注入
    		 * 	2. AUTOWIRE_BY_NAME = 1; byName
    		 * 	3. AUTOWIRE_BY_TYPE = 2; byType
    		 * 	4. AUTOWIRE_CONSTRUCTOR = 3; by构造
    		 *  5. AUTOWIRE_AUTODETECT = 4;(将弃用)
    		 *
    		 */
    		if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
    				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
    			/**
    			 * 使用有参构造函数注入,创建
    			 */
    			return autowireConstructor(beanName, mbd, ctors, args);
    		}
    
    		// Preferred constructors for default construction?
    		/**
    		 *  没有找到合适的构造函数, 如果mbd有配置 首选的构造函数, 就用它
    		 */
    		ctors = mbd.getPreferredConstructors();
    		if (ctors != null) {
    			return autowireConstructor(beanName, mbd, ctors, null);
    		}
    
    		// No special handling: simply use no-arg constructor.
    		/**
    		 * 使用无参构造函数注入,创建
    		 */
    		return instantiateBean(beanName, mbd);
    	}
    

### 填充属性

    /**
    	 * Populate the bean instance in the given BeanWrapper with the property values
    	 * from the bean definition.
    	 * @param beanName the name of the bean
    	 * @param mbd the bean definition for the beanT
    	 * @param bw the BeanWrapper with bean instance
    	 */
    	protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
    		// 验证一下入参
    		if (bw == null) {
    			if (mbd.hasPropertyValues()) {
    				throw new BeanCreationException(
    						mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");
    			}
    			else {
    				// Skip property population phase for null instance.
    				return;
    			}
    		}
    
    		if (bw.getWrappedClass().isRecord()) {
    			if (mbd.hasPropertyValues()) {
    				throw new BeanCreationException(
    						mbd.getResourceDescription(), beanName, "Cannot apply property values to a record");
    			}
    			else {
    				// Skip property population phase for records since they are immutable.
    				return;
    			}
    		}
    
    		// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
    		// state of the bean before properties are set. This can be used, for example,
    		// to support styles of field injection.
    		/**
    		 * 如果是AOP, pointcut, advice相关的, synthetic 会配置为 true
    		 * 1. 调用 BeanPostProcessor 的子接口 InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation
    		 * (作用是 在实例化之后，属性填充之前执行操作, 可以拦截属性填充操作)
    		 */
    		if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
    			for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
    				if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
    					//postProcessAfterInstantiation 返回 false , 拦截属性填充;
    					return;
    				}
    			}
    		}
    		/**
    		 * 包含一个或多个{@link PropertyValue}对象的Holder，通常针对特定目标bean的一次更新
    		 * 可以理解为: 该bean所有属性的描述
    		 */
    		PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);
    
    		/**
    		 * 获取自动注入的方式
    		 */
    		int resolvedAutowireMode = mbd.getResolvedAutowireMode();
    		if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
    			/**
    			 * 2. 处理注解的  byName 或者 byType 注入的属性
    			 * (有注解才会走这个分支)
    			 * ===============================
    			 */
    			MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
    			// Add property values based on autowire by name if applicable.
    			if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
    				/**
    				 * 通过名称注入
    				 */
    				autowireByName(beanName, mbd, bw, newPvs);
    			}
    			// Add property values based on autowire by type if applicable.
    			if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
    				/**
    				 * 通过类型注入
    				 */
    				autowireByType(beanName, mbd, bw, newPvs);
    			}
    			pvs = newPvs;
    		}
    		/**
    		 *  3. 回调所有 InstantiationAwareBeanPostProcessor#postProcessProperties 方法
    		 *  比如, `@Autowired` 的处理对应实现类: {@link org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor}
    		 *  (作用是: 在工厂将属性值应用到给定bean之前，对它们进行处理)
    		 * 	 注意这里也只是解析, 并没有设置进去, 实际赋值方法见下: {@link AbstractAutowireCapableBeanFactory#applyPropertyValues(java.lang.String, org.springframework.beans.factory.config.BeanDefinition, org.springframework.beans.BeanWrapper, org.springframework.beans.PropertyValues)}
    		 *
    		 */
    		if (hasInstantiationAwareBeanPostProcessors()) {
    			if (pvs == null) {
    				pvs = mbd.getPropertyValues();
    			}
    			for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
    				PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
    				if (pvsToUse == null) {
    					return;
    				}
    				pvs = pvsToUse;
    			}
    		}
    
    		boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);
    		if (needsDepCheck) {
    			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
    			checkDependencies(beanName, mbd, filteredPds, pvs);
    		}
    		/**
    		 * 4. 解析BeanDefinition的描述值, 反射调用 赋值 bean 属性 (将解析到的 pvs 赋值到 bw)
    		 */
    		if (pvs != null) {
    			applyPropertyValues(beanName, mbd, bw, pvs);
    		}
    	}
    

### 初始化 调用 init-method Aware BPP方法

`org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)`

    /**
    	 * Initialize the given bean instance, applying factory callbacks
    	 * as well as init methods and bean post processors.
    	 * <p>Called from {@link #createBean} for traditionally defined beans,
    	 * and from {@link #initializeBean} for existing bean instances.
    	 * @param beanName the bean name in the factory (for debugging purposes)
    	 * @param bean the new bean instance we may need to initialize
    	 * @param mbd the bean definition that the bean was created with
    	 * (can also be {@code null}, if given an existing bean instance)
    	 * @return the initialized bean instance (potentially wrapped)
    	 * @see BeanNameAware
    	 * @see BeanClassLoaderAware
    	 * @see BeanFactoryAware
    	 * @see #applyBeanPostProcessorsBeforeInitialization
    	 * @see #invokeInitMethods
    	 * @see #applyBeanPostProcessorsAfterInitialization
    	 */
    	@SuppressWarnings("deprecation")
    	protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
    
    		/**
    		 * 先调用这三个 BeanNameAware, BeanClassLoaderAware, BeanFactoryAware
    		 * 这三个是在创建 BeanFactory 时忽略的三个 Aware 接口
    		 * { @link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#AbstractAutowireCapableBeanFactory() }
    		 *
    		 */
    		invokeAwareMethods(beanName, bean);
    
    		Object wrappedBean = bean;
    		if (mbd == null || !mbd.isSynthetic()) {
    			/**
    			 * 调用所有 BeanPostProcessors#postProcessBeforeInitialization
    			 * (作用 在Bean初始化之前调用)
    			 * 比如 Spring 中Aware属性的设置, 是通过这种方式扩展的
    			 * - org.springframework.context.support.ApplicationContextAwareProcessor
    			 * 对应调用 ApplicationContextAware, EnvironmentAware, ApplicationEventPublisherAware 等Aware方法
    			 *
    			 */
    			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
    		}
    
    		try {
    			/**
    			 * 调用 init-method 方法
    			 */
    			invokeInitMethods(beanName, wrappedBean, mbd);
    		}
    		catch (Throwable ex) {
    			throw new BeanCreationException(
    					(mbd != null ? mbd.getResourceDescription() : null), beanName, ex.getMessage(), ex);
    		}
    		if (mbd == null || !mbd.isSynthetic()) {
    			/**
    			 * 调用所有 BeanPostProcessors#postProcessAfterInitialization
    			 * (作用 在Bean初始化之后调用)
    			 *
    			 * - AspectJAwareAdvisorAutoProxyCreator.class
    			 * org.springframework.aop.config.internalAutoProxyCreator 对应的类有根据情况有三个可能
    			 *   InfrastructureAdvisorAutoProxyCreator.class,
    			 *   AspectJAwareAdvisorAutoProxyCreator.class,
    			 *   AnnotationAwareAspectJAutoProxyCreator.class
    			 *
    			 *  如果需要代理, 这里会真正的对原始 bean 进行代理  进行代理的创建 createProxy
    			 *
    			 */
    			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    		}
    
    		return wrappedBean;
    	}
    

### 总结

    1. 为 beanFactory 设置类型转换器(ConversionService) 属性填充时会用到 {@link AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)}
    2. 为 beanFactory 添加变量解析器 (StringValueResolver)
    	如果 beanFactory 上下文中不包含 "默认的变量解析器 (类似 PropertySourcesPlaceholderConfigurer) 解析类似 '${}' 这样的变量 "
    	则使用环境对象(ConfigurableEnvironment)中的 ConfigurablePropertyResolver实现来作为 StringValueResolver 添加进去
    3. 冻结配置, 此后就不再允许更改 beanDefinition 了
    4. 实例化所有剩余的 (非lazy-init) 单例 Bean
    5. 处理 FactoryBean 类型的bean {@link DefaultListableBeanFactory#preInstantiateSingletons()}
    	如果该bean是 FactoryBean, 则在 bean name 前面加一个 '&' 前缀, 先获取/实例化 FactoryBean 本身;
    	(注意一下 FactoryBean 生成对象是不遵循 Spring 的bean生命周期的)
    	这有两个对象, 如何获取? getBean(beanName) :
    	1. 传入 FactoryBean 的 name 返回的是其 getObject 的目标对象实例;
    	2. 如果想获取 FactoryBean 本身实例, 则前面需要加一个 '&' 前缀;
    6. 尝试从当前容器 一 二 三级缓存获取 {@link AbstractBeanFactory#doGetBean(String, Class, Object[], boolean)}
    7. 处理 AOP 代理对象生成 {@link AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])}
    8. 在JVM层面实例化对象 {@link AbstractAutowireCapableBeanFactory#doCreateBean(String, RootBeanDefinition, Object[])}
    	1.真正在jvm层面实例化对象;
    		1. 如果该 BeanDefinition 有配置 instanceSupplier属性(java.util.function.Supplier),
    		 将使用其Supplier#get方法的返回, 作为实例对象
    		2. 如果该 BeanDefinition 有配置 factory-method 将使用该方法返回的, 作为实例对象
    		 这里这里包括'静态工厂'和'实例工厂'的处理(通过bd的factoryBeanName 进行判断, 如果存在则是'实例工厂')
    		3. 使用反射实例化, 根据策略实例化Bean对象 {@link org.springframework.beans.factory.support.SimpleInstantiationStrategy}
    		- 使用有参构造函数注入,创建 (new)
    		- 使用无参构造函数创建 (new)
    		- 工厂方法实例化 ('静态工厂' '实例工厂' )
    		`<bean  factory-bean="bookFactoryBean"  factory-method="getBook()"/>`
    		静态工厂: factory-bean 若是 全限定类名 则使用 BookFactoryBean::getBook 的静态方法返回的对象
    		实例工厂:  factory-bean 若是 bean 名 则使用该实例方法返回的对象
    	2. 用BeanWrapper 包装原始bean (装饰模式)
    	3. 初始化 BeanWrapper
    		1. 给 BeanWrapper 设置了, ConversionService
    		2. 给 BeanWrapper 注册了, 当前 bean factory (propertyEditorRegistrars)中的全部 PropertyEditor
    		3. 处理 MergedBeanDefinitionPostProcessor 的接口回调 {@link AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class, String)}
    		调用 添加在 context 中 BeanPostProcessor 的 MergedBeanDefinitionPostProcessor 的接口回调
    		解析到诸如`@Autowired`之类的注解 (Metadata)元信息,合并到BeanDefinition中
    	4. 填充Bean属性 {@link AbstractAutowireCapableBeanFactory#populateBean(String, RootBeanDefinition, BeanWrapper)}
    		1. 如果是AOP, pointcut, advice相关的, synthetic 会配置为 true  调用 BeanPostProcessor 的子接口 InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation
    		(作用是 在实例化之后，属性填充之前执行操作, 可以拦截属性填充操作)
    		2. 处理注解的  byName 或者 byType 注入的属性
    		3. 回调所有 InstantiationAwareBeanPostProcessor#postProcessProperties 方法
    		比如, `@Autowired` 的处理对应实现类: {@link org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor}
    		(作用是: 在工厂将属性值应用到给定bean之前，对它们进行处理)
    		注意这里也只是解析, 并没有设置进去, 实际赋值方法见: {@link AbstractAutowireCapableBeanFactory#applyPropertyValues(java.lang.String, org.springframework.beans.factory.config.BeanDefinition, org.springframework.beans.BeanWrapper, org.springframework.beans.PropertyValues)}
    	5. 初始化Bean对象 {@link AbstractAutowireCapableBeanFactory#initializeBean(String, Object, RootBeanDefinition)}
    		1. 先调用这三个 BeanNameAware, BeanClassLoaderAware, BeanFactoryAware {@link AbstractAutowireCapableBeanFactory#invokeAwareMethods(String, Object)}
    		这三个是在创建BeanFactory 时忽略的三个 Aware 接口
    		2. 调用所有 BeanPostProcessors#postProcessBeforeInitialization (作用: 在Bean初始化之前调用) {@link AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization(Object, String)}
    		3. 调用 init-method 方法 {@link AbstractAutowireCapableBeanFactory#invokeInitMethods(String, Object, RootBeanDefinition)}
    		4. 调用所有 BeanPostProcessors#postProcessAfterInitialization (作用: 在Bean初始化之后调用) {@link AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization(Object, String)}
    	6. 注册 bean销毁的工作(如果需要){@link AbstractBeanFactory#registerDisposableBeanIfNecessary(String, Object, RootBeanDefinition)}
    		1. org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor#postProcessBeforeDestruction(Object,String) BPP接口
    		2. org.springframework.beans.factory.DisposableBean 接口
    		3. 自定义 destroy方法
    		(在容器关闭时会调用会按这个顺序调用)
    
    

十二 完成容器刷新
---------

`org.springframework.context.support.AbstractApplicationContext#finishRefresh`

    /**  
     * Finish the refresh of this context, invoking the LifecycleProcessor's * onRefresh() method and publishing the * {@link org.springframework.context.event.ContextRefreshedEvent}.  
     */
     protected void finishRefresh() {  
       
    }
    

### 总结

1.  清理各种缓存
2.  为当前上下文初始化生命周期处理器
3.  发布 ContextRefreshedEvent (Context 完成刷新)事件

关于 Bean 的继承(parent属性)
=====================

这里的继承和 java 语法中的继承没有任何关系, 不过思路是相通的; child bean 会继承 parent bean 的所有配置, 也可以覆盖一些配置, 当然也可以新增额外的配置;

Spring 中提供了继承自 AbstractBeanDefinition 的 ChildBeanDefinition 来表示 child bean;

看如下一个例子:

    <bean id="inheritedTestBean" abstract="true" class="org.springframework.beans.TestBean">
        <property name="name" value="parent"/>
        <property name="age" value="1"/>
    </bean>
    
    <bean id="inheritsWithDifferentClass" class="org.springframework.beans.DerivedTestBean"
            parent="inheritedTestBean" init-method="initialize">
    
        <property name="name" value="override"/>
    </bean>
    
    

parent bean 设置了 `abstract="true"` 所以它不会被实例化, child bean**(inheritsWithDifferentClass)**继承了 parent bean**(inheritedTestBean)** 的 `name` `age` 两个属性, 但是对 `name` 属性进行了覆写, 增加了`init-method`;

**in short: 即配置继承, child bean 会继承 scope, 构造器参数值, 属性值, init-method, destroy-method 等等配置**

    @Configuration
    public class WebConfigBeans {
    	
    	@Autowired
    	private RequestMappingHandlerAdapter handlerAdapter;
    	
    	@PostConstruct
    	public void initEditableValidation(){
    		//获得 RequestMappingHandler 中的 ConfigurableWebBindingInitializer
    		ConfigurableWebBindingInitializer initializer =(ConfigurableWebBindingInitializer)handlerAdapter.getWebBindingInitializer();
    		if(initializer.getConversionService()!=null){
    			GenericConversionService genericConversionService=(GenericConversionService)initializer.getConversionService();
    			//添加自定义转换器
    			genericConversionService.addConverter(new StringToDateConverter());
    		}
    	}
    	
    }
    

关于 FactoryBean
==============

`org.springframework.beans.factory.FactoryBean` 适用于 Bean 的创建过程比较复杂的场景, 比如数据库连接池的创建;

我们假设现在需要创建一个 Person 的 Bean, 首先我们需要一个 Car 的实例, 我们这里假设 Car 的实例创建很麻烦, 那么我们可以把创建 Car 的复杂过程包装起来:

**注意: 使用FactoryBean 完全自定义创建Bean, 不会走Bean生命周期的各种 Processor回调.**

    public class MyCarFactoryBean implements FactoryBean<Car>{
        private String make; 
        private int year ;
    
        public void setMake(String m){ this.make =m ; }
    
        public void setYear(int y){ this.year = y; }
    
        public Car getObject(){ 
          // 这里我们假设 Car 的实例化过程非常复杂, 反正就不是几行代码可以写完的那种
          CarBuilder cb = CarBuilder.car();
    
          if(year!=0) cb.setYear(this.year);
          if(StringUtils.hasText(this.make)) cb.setMake( this.make ); 
          return cb.factory(); 
        }
    
        public Class<Car> getObjectType() { return Car.class ; } 
    
        public boolean isSingleton() { return false; }
    }
    

装配的时候是怎么配置的:

    <bean class = "com.javadoop.MyCarFactoryBean" id = "car">
      <property name = "make" value ="Honda"/>
      <property name = "year" value ="1984"/>
    </bean>
    <bean class = "com.javadoop.Person" id = "josh">
      <property name = "car" ref = "car"/>
    </bean>
    

**简而言之 就是实现 FactoryBean的接口的bean, 有几个方法:`T getObject()` ,`Class<?> getObjectType();` `default boolean isSingleton()`, 用来封装创建复杂的bean**

关于循环依赖的处理
=========

为什么要需要三级缓存?
-----------

`singletonObjects`:  
第一级缓存, 里面放置的是已经实例化好的单例对象, 是单例缓存池（singletonObjects）

`earlySingletonObjects`:  
第二级缓存, 里面存放的是提早曝光的单例对象, 早期对象（earlySingletonObjects）. 简单粗暴的说就是new的对象, 可是这个对象还没填充属性

`singletonFactories`:  
第三级缓存, 里面存放的是将要被实例化的对象的对象工厂（存放 bean 工厂对象）, 是一个包裹对象`ObjectFactory(registeredSingletons)`, 经过getObject获取到早期对象.

正常来讲, 处理循环依赖, 类似交换变量, 只需要一级缓存就可以了; 加上单例缓存池, 两级缓存池即可;

    function swap(a, b){
    	temp = a;
    	a = b;
    	b = temp;
    }
    

例如: `Aservice` 依赖 Bservice, `Bservice` 依赖 `Aservice`.

创建 `Aservice` 时, 将生成A的lambda放入三级缓存, 填充属性 `Bservice`, 一二三级缓存中都没,  
去创建 `Bservice`, 将生成B的lambda放入三级缓存, 填充 `Aservice` 属性, 发现三级缓存中有A, 执行A的lambda生成 `Aservice` 对象, 放入二级缓存(不能放一级这时候A的Bservice属性还是null), 并删除A的三级缓存,  
继续执行B的 lambda 生成 `Bservice` 对象, 放入一级缓存, 并删除B的三级缓存;  
创建 `Aservice` 的流程中获取到Bservice对象之后, 把二级缓存的 `Aservice` 对象删除, 并放入一级缓存.

第三级缓存是处理 AOP 增强的bean 问题:  
**因为不知道当前对象什么时候会被引用, 所以只能在第一次引用的时候来判断对象是否需要被代理, 所以它是一个lambda表达式**

关于生命周期
======

Spring中的Bean生命周期
----------------

Spring中的Bean生命周期可以分为以下几个阶段:

1.  实例化（Instantiation）: 在这个阶段, Spring容器根据Bean的配置信息创建Bean实例. 通常, 这是通过构造函数或工厂方法来完成的.
2.  属性赋值（Property Assignment）: 在实例化之后, Spring容器将会对Bean的属性进行赋值. 这可以通过setter方法、注解、或构造函数参数来实现.
3.  Aware接口回调（Aware Interface Callbacks）: 在属性赋值之后, Spring容器会检查Bean是否实现了Aware接口. 如果实现了, 容器会调用相应的Aware接口回调方法, 让Bean获取与容器相关的额外信息.
4.  初始化（Initialization）: 在属性赋值完成后, Spring容器会调用Bean的初始化回调方法. 这可以通过实现InitializingBean接口的afterPropertiesSet()方法或在配置文件中声明的自定义初始化方法来实现.
5.  BeanPostProcessor回调（BeanPostProcessor Callbacks）: 在Bean初始化之前和之后, Spring容器会调用注册的BeanPostProcessor接口的方法. 这允许您在Bean的初始化过程中进行自定义处理, 如添加额外的逻辑或对Bean进行代理包装.
6.  使用（Bean in Use）: 在初始化完成后, Bean就可以被应用程序使用了
7.  销毁（Destruction）: 当容器关闭或者从容器中移除Bean时, 会触发Bean的销毁. 这可以通过实现 DisposableBean 接口的destroy()方法或在配置文件中声明的自定义销毁方法来实现.

实例化 -> 填充属性 -> 各种Aware  
\-> 调用 BeanPostProcessor (初始前)  
\-> 调用 InitializingBean -> 调用自定义 init-method  
\-> 调用 BeanPostProcessor (初始后)  
<使用>  
\-> 调用 DisposableBean -> 调用自定义 destroy-method

预防老年痴呆，保持终身学习! —— [daidaidaiyu](https://www.cnblogs.com/dddy/)