---
layout: post
title: 'GitLab Package依赖管理：从 Dependabot 到 Renovate 的迁移实践和两者对比'
date: "2025-11-20T00:41:32Z"
---
GitLab Package依赖管理：从 Dependabot 到 Renovate 的迁移实践和两者对比
=====================================================

GitLab 依赖管理：从 Dependabot 到 Renovate 的迁移实践
=========================================

前言
--

在现代前端项目中，依赖管理是一个不可忽视的重要环节。关于GitLab Dependabot如何配置的中文资料几乎没有，英文资料也比较少，而且绝大部分是关于GitHub Dependabot的配置。GitLab Dependabot可以理解为Debuff版本的GitHub Dependabot，功能上有所欠缺。经过实验，目前最佳实践是GitLab Renovate。就GitHub而言，我认为Dependabot和Renovate这两者都非常强大。  
如果你用的是GitHub，可以无脑使用Dependabot，因为它高度集成，配置起来很简单。

目录
--

1.  [背景：为什么需要依赖管理工具](#%E8%83%8C%E6%99%AF)
2.  [GitLab Dependabot 配置与问题](#dependabot%E9%85%8D%E7%BD%AE)
3.  [Renovate 解决方案](#renovate%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)
4.  [两者对比分析](#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90)
5.  [迁移步骤与注意事项](#%E8%BF%81%E7%A7%BB%E6%AD%A5%E9%AA%A4)
6.  [总结与建议](#%E6%80%BB%E7%BB%93)

1\. 背景：为什么需要依赖管理工具
------------------

### 项目背景

我们的项目是一个大型 NX Monorepo，包含：

*   **前端**：Angular 17+ 微前端架构，使用 PrimeNG UI 组件库
*   **后端**：NestJS 10+ RESTful API
*   **依赖数量**：100+ NPM packages
*   **核心框架**：Angular、NX、NestJS、TypeScript、PrimeNG

### 依赖管理的挑战

在这样的项目中，手动管理依赖更新面临诸多问题：

1.  **Peer Dependency 冲突**：Angular 生态的包（如 `@angular/core`、`@angular/forms` 等）必须保持相同版本
2.  **安全漏洞**：及时发现和修复依赖中的安全问题
3.  **更新频率**：Angular、NX 等框架每月都有更新，手动跟进成本高
4.  **测试负担**：每次更新需要完整的回归测试

因此，我们需要一个自动化工具来：

*   ✅ 自动检测依赖更新
*   ✅ 创建 Merge Request（MR）
*   ✅ 提供 Changelog 和 Release Notes
*   ✅ 支持私有 NPM Registry
*   ✅ **关键需求**：将相关包（如所有 Angular 包）组合到一个 MR 中

2\. GitLab Dependabot 配置与问题
---------------------------

### 2.1 Dependabot 简介

我最初选择了 [dependabot-gitlab](https://gitlab.com/dependabot-gitlab/dependabot) 这个社区项目，它是 GitHub Dependabot 的 GitLab 移植版本。

### 2.2 配置详解

#### GitLab CI/CD 配置

在 `.gitlab-ci.yml` 中添加 Dependabot Job：

    dependabot:
      stage: dependencies
      image:
        name: andrcuns/dependabot-gitlab-npm:3.70.0-alpha.1
        entrypoint: ['']
      variables:
        # GitLab 连接设置
        SETTINGS__GITLAB_URL: $CI_SERVER_URL
        SETTINGS__STANDALONE: 'true'
        RAILS_ENV: 'production'
        SECRET_KEY_BASE: 'dependabot-standalone-secret-key-base-placeholder'
    
        # 身份验证 Token
        SETTINGS__GITLAB_ACCESS_TOKEN: $GITLAB_DEPENDABOT_TOKEN
        SETTINGS__CREDENTIALS__GITLAB_ACCESS_TOKEN: $GITLAB_DEPENDABOT_TOKEN
        SETTINGS__GITHUB_ACCESS_TOKEN: $GITHUB_ACCESS_TOKEN
        SETTINGS__CREDENTIALS__GITHUB_ACCESS_TOKEN: $GITHUB_ACCESS_TOKEN
    
        # 私有 NPM Registry Token
        GITLAB_INSTALL_PACKAGE_TOKEN: $GITLAB_INSTALL_PACKAGE_TOKEN
        FONTAWESOME_TOKEN: $FONTAWESOME_TOKEN
    
        # 日志和配置
        SETTINGS__LOG_LEVEL: 'info'
        SETTINGS__LOG_COLOR: 'true'
        SETTINGS__DRY_RUN: 'false'
        SETTINGS__CONFIG_LOCAL_FILENAME: '$CI_PROJECT_DIR/.gitlab/dependabot.yml'
    
      script:
        - cd /home/dependabot/app
        - bundle exec rake "dependabot:update[$CI_PROJECT_PATH,npm,/]"
    
      rules:
        # 通过 Pipeline Schedule 触发
        - if: '$CI_PIPELINE_SOURCE == "schedule" && $SCHEDULE_NAME == "dependabot"'
          when: always
    
      allow_failure: true
      timeout: 1h
    

**关键配置说明**：

变量

说明

`SETTINGS__GITLAB_ACCESS_TOKEN`

GitLab Token，需要 `api`、`read_user`、`write_repository` 权限

`SETTINGS__GITHUB_ACCESS_TOKEN`

GitHub Token，用于获取 Changelog

`GITLAB_INSTALL_PACKAGE_TOKEN`

私有 GitLab Package Registry Token

`FONTAWESOME_TOKEN`

FontAwesome Pro Token

#### Dependabot 配置文件

创建 `.gitlab/dependabot.yml`：

    version: 2
    
    # 私有 Registry 配置
    registries:
      private-npm:
        type: npm-registry
        url: https://gitlab.com/api/v4/projects/43909703/packages/npm
        token: ${{GITLAB_INSTALL_PACKAGE_TOKEN}}
      fontawesome-npm:
        type: npm-registry
        url: https://npm.fontawesome.com
        token: ${{FONTAWESOME_TOKEN}}
    
    updates:
      - package-ecosystem: 'npm'
        directory: '/'
        registries:
          - private-npm
          - fontawesome-npm
        open-pull-requests-limit: 5
        commit-message:
          prefix: 'chore(dependencies): :arrow_up:'
          include: 'scope'
        labels:
          - 'dependencies'
        allow:
          - dependency-type: 'all'
    

**配置参数说明**：

参数

值

说明

`package-ecosystem`

`npm`

监控 NPM 依赖

`directory`

`/`

监控根目录

`open-pull-requests-limit`

`5`

最多同时打开 5 个 MR

`commit-message.prefix`

`chore(dependencies): :arrow_up:`

Commit 消息前缀

`labels`

`dependencies`

MR 标签

**Commit 消息示例**：

    chore(dependencies): :arrow_up: bump @angular/core from 17.3.10 to 17.3.12
    

### 2.3 遇到的核心问题

#### 问题 1：分组功能不可用

GitHub Dependabot 支持 `groups` 配置来将相关包组合到一个 MR 中：

    # 这个配置在 GitHub Dependabot 中有效
    # 但在 GitLab Dependabot 中不起作用！
    groups:
      angular:
        patterns:
          - '@angular/*'
          - '@angular-devkit/*'
    

**实际结果**：即使配置了`groups`，GitLab Dependabot仍然会为每个包创建独立的MR，导致我的build stage无法通过，并且执行`npm ci --cache .npm --prefer-offline`时出现报错。

#### 问题 2：Peer Dependency 冲突

由于无法分组，导致以下问题：

    # MR 1 合并：@angular/core@17.3.12
    # MR 2 尝试合并：@angular/forms@17.3.11
    
    # 构建失败！
    npm ERR! peer dep missing: @angular/core@17.3.11, required by @angular/forms@17.3.11
    

**影响**：

*   ❌ Build Stage 失败
*   ❌ 需要手动调整多个 MR 的合并顺序
*   ❌ 极大增加了维护成本

#### 问题 3：其他限制

1.  **Alpha 版本不稳定**：必须使用 `3.70.0-alpha.1`，没有稳定版本
2.  **性能问题**：生成MR的速度远慢于Renovate，一个任务运行时间更长。
3.  **配置不够灵活**：无法针对 Major/Minor/Patch 设置不同策略
4.  **社区支持有限**：非官方项目，问题响应慢

相关 Issue：[GitLab Dependabot #151 - Group updates not working](https://gitlab.com/dependabot-gitlab/dependabot/-/issues/151)

### 2.4 工作流程

graph LR A\[Pipeline Schedule\] --> B\[启动 Docker 容器\] B --> C\[读取配置文件\] C --> D\[扫描 package.json\] D --> E\[检查版本更新\] E --> F{有更新?} F -->|是| G\[创建独立 MR\] F -->|否| H\[结束\] G --> I\[达到 MR 上限?\] I -->|是| H I -->|否| E

**限制**：每个包一个 MR，无法分组！

3\. Renovate 解决方案
-----------------

### 3.1 Renovate 简介

[Renovate](https://docs.renovatebot.com/) 是一个功能强大的依赖管理工具，支持多种平台（GitHub、GitLab、Bitbucket）和语言。GitLab 官方提供了 [Renovate Runner 模板](https://gitlab.com/gitlab-com/gl-infra/renovate/renovate-runner)。

### 3.2 配置详解

#### GitLab CI/CD 配置

在 `.gitlab-ci.yml` 中添加 Renovate Job（需要先引入模板）：

    # 引入 GitLab 官方 Renovate 模板
    include:
      - project: 'renovate-bot/renovate-runner'
        file: '/templates/renovate.gitlab-ci.yml'
    
    stages:
      - dependencies  # 其他 stages...
    
    renovate:
      stage: dependencies
      variables:
        # GitLab Token（复用 Dependabot 的 Token）
        RENOVATE_TOKEN: $GITLAB_DEPENDABOT_TOKEN
    
        # GitHub Token（用于获取 Changelog）
        RENOVATE_GITHUB_COM_TOKEN: $GITHUB_ACCESS_TOKEN
    
        # 目标仓库（禁用自动发现）
        RENOVATE_REPOSITORIES: $CI_PROJECT_PATH
    
        # 日志级别（测试阶段使用 debug）
        LOG_LEVEL: debug
    
        # 跳过 Onboarding PR
        RENOVATE_ONBOARDING: "false"
    
        # 允许无配置文件运行
        RENOVATE_REQUIRE_CONFIG: "false"
    
        # 使用完整镜像（包含 NX 等工具）
        CI_RENOVATE_IMAGE: ghcr.io/renovatebot/renovate:full
    
        # 私有 NPM Registry 配置
        RENOVATE_NPMRC: |
          @fortawesome:registry=https://npm.fontawesome.com/
          //npm.fontawesome.com/:_authToken=${FONTAWESOME_TOKEN}
          @private:registry=https://gitlab.com/api/v4/projects/43909703/packages/npm/
          //gitlab.com/api/v4/projects/43909703/packages/npm/:_authToken=${GITLAB_INSTALL_PACKAGE_TOKEN}
    
      rules:
        # 复用 Dependabot 的 Pipeline Schedule
        - if: '$CI_PIPELINE_SOURCE == "schedule" && $SCHEDULE_NAME == "dependabot"'
          when: always
        # 支持手动触发
        - if: '$CI_PIPELINE_SOURCE == "web"'
          when: manual
    

**关键配置说明**：

变量

说明

`RENOVATE_TOKEN`

GitLab Token（复用 Dependabot 的 Token）

`RENOVATE_GITHUB_COM_TOKEN`

GitHub Token（复用）

`RENOVATE_REPOSITORIES`

指定目标仓库，禁用自动扫描

`LOG_LEVEL`

`debug` 模式便于排查问题

`RENOVATE_NPMRC`

私有 Registry 配置（支持多行）

`CI_RENOVATE_IMAGE`

使用 `full` 镜像支持 NX Monorepo

#### Renovate 配置文件

创建根目录下的 `renovate.json`：

    {
      "$schema": "https://docs.renovatebot.com/renovate-schema.json",
      "extends": ["config:base"],
      "baseBranches": ["develop"],
      "timezone": "Europe/Berlin",
    
      // Rate Limiting
      "prConcurrentLimit": 10,
      "prHourlyLimit": 5,
      "branchConcurrentLimit": 30,
    
      // MR 格式化
      "labels": ["dependencies"],
      "commitMessagePrefix": "chore(dependencies): ⬆️",
      "commitMessageAction": "bump",
      "commitMessageExtra": "to {{newVersion}}",
    
      // 自动合并设置
      "gitLabAutomerge": false,
      "platformAutomerge": false,
    
      // 核心功能：包分组规则
      "packageRules": [
        {
          "groupName": "Angular",
          "matchPackagePatterns": [
            "^@angular/",
            "^@angular-devkit/",
            "^@angular-eslint/",
            "^@schematics/angular$"
          ],
          "automerge": false
        },
        {
          "groupName": "NX",
          "matchPackagePatterns": ["^@nx/", "^nx$"],
          "automerge": false
        },
        {
          "groupName": "NestJS",
          "matchPackagePatterns": ["^@nestjs/"],
          "automerge": false
        },
        {
          "groupName": "PrimeNG",
          "matchPackagePatterns": ["^primeng$", "^@primeng/", "^primeicons$"],
          "automerge": false
        },
        {
          "groupName": "TypeScript",
          "matchPackagePatterns": ["^typescript$", "^@types/"],
          "automerge": false
        }
      ],
    
      // NPM 配置
      "npm": {},
    
      // 安全漏洞告警
      "vulnerabilityAlerts": {
        "enabled": true
      }
    }
    

### 3.3 配置详解

#### 基础配置

字段

值

说明

`$schema`

`https://docs.renovatebot.com/renovate-schema.json`

JSON Schema 支持 IDE 自动补全

`extends`

`["config:base"]`

继承官方推荐配置

`baseBranches`

`["develop"]`

MR 目标分支

`timezone`

`"Europe/Berlin"`

时区设置

#### Rate Limiting（频率限制）

字段

值

说明

`prConcurrentLimit`

`10`

最多同时 10 个 MR

`prHourlyLimit`

`5`

每小时最多 5 个新 MR

`branchConcurrentLimit`

`30`

最多 30 个分支

**作用**：防止 Renovate 一次性创建过多 MR，导致 CI/CD 资源耗尽。

#### Commit 消息格式

字段

值

说明

`commitMessagePrefix`

`"chore(dependencies): ⬆️"`

Commit 前缀

`commitMessageAction`

`"bump"`

动作词

`commitMessageExtra`

`"to {{newVersion}}"`

版本信息

**生成的 Commit 消息示例**：

    chore(dependencies): ⬆️ bump @angular/core to 17.3.12
    

#### 自动合并设置

字段

值

说明

`gitLabAutomerge`

`false`

不使用 GitLab 自动合并

`platformAutomerge`

`false`

Renovate 不自动合并

**区别**：

*   `gitLabAutomerge`：利用 GitLab 的 "Auto-merge when pipeline succeeds" 功能
*   `platformAutomerge`：Renovate 自己通过 API 执行合并

**建议**：测试阶段设为 `false`，待稳定后可针对 Patch 版本启用自动合并。

#### 包分组规则（核心功能）

这是解决 Dependabot 问题的关键！

**Angular 分组示例**：

    {
      "groupName": "Angular",
      "matchPackagePatterns": [
        "^@angular/",           // 匹配 @angular/*
        "^@angular-devkit/",    // 匹配 @angular-devkit/*
        "^@angular-eslint/",    // 匹配 @angular-eslint/*
        "^@schematics/angular$" // 精确匹配 @schematics/angular
      ],
      "automerge": false
    }
    

**工作原理**：

1.  Renovate 扫描所有依赖
2.  根据 `matchPackagePatterns` 正则表达式匹配包名
3.  将匹配的包归入同一组
4.  创建**一个 MR** 包含所有更新

**实际效果**：

    ✅ 一个 MR：renovate/angular
      ├─ @angular/core: 17.3.10 → 17.3.12
      ├─ @angular/forms: 17.3.10 → 17.3.12
      ├─ @angular/common: 17.3.10 → 17.3.12
      ├─ @angular-devkit/build-angular: 17.3.10 → 17.3.12
      └─ 其他 Angular 包...
    

**其他分组规则**：

分组名

匹配模式

原因

NX

`^@nx/`, \`^nx

分组名

\--------

\----------

\------

NX 插件必须与核心版本匹配

NestJS

`^@nestjs/`

NestJS 模块相互依赖

PrimeNG

`^primeng$`, `^@primeng/`, `^primeicons$`

UI 组件库版本一致性

TypeScript

`^typescript$`, `^@types/`

类型定义与编译器版本匹配

### 3.4 工作流程

graph LR A\[Pipeline Schedule\] --> B\[Renovate Runner 启动\] B --> C\[读取 renovate.json\] C --> D\[扫描依赖\] D --> E\[检查更新\] E --> F{应用分组规则} F --> G\[创建分组 MR\] G --> H\[添加 Changelog\] H --> I\[CI/CD 测试\] I --> J{测试通过?} J -->|是| K\[人工 Review\] J -->|否| L\[MR 标记失败\] K --> M\[手动 Merge\]

4\. 两者对比分析
----------

### 4.1 功能对比表

功能

GitLab Dependabot

GitLab Renovate

说明

**分组更新**

❌ 不支持

✅ 完全支持

Renovate 的核心优势

**Peer Dependency 处理**

❌ 问题严重

✅ 自动正确处理

Angular 等框架必需

**私有 Registry**

✅ 支持

✅ 支持

都支持

**Changelog 集成**

✅ 支持

✅ 支持

都支持

**Rate Limiting**

⚠️ 单一限制

✅ 多维度限制

Renovate 更灵活

**自动合并**

❌ 不支持

✅ 支持

Renovate 支持条件自动合并

**配置灵活性**

⚠️ 有限

✅ 非常灵活

Renovate 配置项更多

**性能**

⚠️ 较慢（需 1h 超时）

✅ 较快

Renovate 更轻量

**稳定性**

⚠️ Alpha 版本

✅ 稳定版本

Renovate 更成熟

**官方支持**

❌ 社区项目

✅ GitLab 官方模板

Renovate 可靠性更高

**学习成本**

⚠️ 中等

⚠️ 中等

配置复杂度相当

**调试难度**

⚠️ 较难

✅ 容易

Renovate 日志更清晰

### 4.2 配置对比

#### 两者通用配置

##### 配置pipeline schedule

在Settings → CI/CD → Variables中，需要创建一个 GitHub 令牌和一个 GitLab 令牌。GitLab 令牌需要读写权限，而 GitHub 令牌只需要只读权限。  
![Screenshot 2025-11-18 155656](https://img2024.cnblogs.com/blog/1201453/202511/1201453-20251119212346099-341123591.png)  
在Build → Pipeline Schedules中，我们需要创建一个“Schedule”。“Schedule\_Name”可配可不配置。  
![image](https://img2024.cnblogs.com/blog/1201453/202511/1201453-20251119211946128-1445703784.png)  
![image](https://img2024.cnblogs.com/blog/1201453/202511/1201453-20251119212017852-295080990.png)

#### Dependabot 配置文件位置

    .gitlab/dependabot.yml    # YAML 格式
    

#### Renovate 配置文件位置

    renovate.json             # JSON 格式，根目录
    

#### 分组配置对比

**Dependabot（不生效）**：

    groups:
      angular:
        patterns:
          - '@angular/*'
    

**Renovate（生效）**：

    {
      "packageRules": [
        {
          "groupName": "Angular",
          "matchPackagePatterns": ["^@angular/"]
        }
      ]
    }
    

### 4.3 实际案例对比

#### 场景：Angular 17.3.10 → 17.3.12 更新

**Dependabot 表现**：  
![image](https://img2024.cnblogs.com/blog/1201453/202511/1201453-20251119212724013-1880990179.png)

    ❌ 创建 15 个独立 MR：
      - MR #1: @angular/core 17.3.10 → 17.3.12
      - MR #2: @angular/forms 17.3.10 → 17.3.12
      - MR #3: @angular/common 17.3.10 → 17.3.12
      - ...（共 15 个）
    
    问题：
    1. 手动合并顺序复杂
    2. 容易出现 Peer Dependency 冲突
    3. CI/CD 资源消耗大（15 次 Pipeline）
    

**Renovate 表现**：  
![image](https://img2024.cnblogs.com/blog/1201453/202511/1201453-20251119212758932-810548664.png)  
![image](https://img2024.cnblogs.com/blog/1201453/202511/1201453-20251119212820550-509801858.png)

    ✅ 创建 1 个 MR：
      - MR #1: chore(dependencies): ⬆️ bump Angular to 17.3.12
        包含所有 15 个 Angular 相关包
    
    优势：
    1. 一键合并
    2. 无 Peer Dependency 冲突
    3. 只触发 1 次 Pipeline
    

### 4.4 Token 配置对比

#### Dependabot

    # 需要配置多个变量
    SETTINGS__GITLAB_ACCESS_TOKEN: $GITLAB_DEPENDABOT_TOKEN
    SETTINGS__CREDENTIALS__GITLAB_ACCESS_TOKEN: $GITLAB_DEPENDABOT_TOKEN
    SETTINGS__GITHUB_ACCESS_TOKEN: $GITHUB_ACCESS_TOKEN
    SETTINGS__CREDENTIALS__GITHUB_ACCESS_TOKEN: $GITHUB_ACCESS_TOKEN
    # 可忽略，公司内部的npm所需要的key
    GITLAB_INSTALL_PACKAGE_TOKEN: $GITLAB_INSTALL_PACKAGE_TOKEN
    FONTAWESOME_TOKEN: $FONTAWESOME_TOKEN
    

#### Renovate

    # 更简洁的配置
    RENOVATE_TOKEN: $GITLAB_DEPENDABOT_TOKEN
    RENOVATE_GITHUB_COM_TOKEN: $GITHUB_ACCESS_TOKEN
    
    # Registry Token 通过 RENOVATE_NPMRC 统一配置
    # 可忽略，公司内部的npm所需要的key
    RENOVATE_NPMRC: |
      @fortawesome:registry=https://npm.fontawesome.com/
      //npm.fontawesome.com/:_authToken=${FONTAWESOME_TOKEN}
      @private:registry=https://gitlab.com/api/v4/projects/43909703/packages/npm/
      //gitlab.com/api/v4/projects/43909703/packages/npm/:_authToken=${GITLAB_INSTALL_PACKAGE_TOKEN}
    

**Renovate 优势**：

*   ✅ 变量更少
*   ✅ 配置更清晰
*   ✅ 支持 `.npmrc` 标准格式

5\. 迁移步骤与注意事项
-------------

### 5.1 迁移前准备

#### 1\. 验证现有 Token 权限

确保以下 Token 已配置且有效：

Token

权限要求

位置

`GITLAB_DEPENDABOT_TOKEN`

`api`, `read_user`, `write_repository`

GitLab Settings → CI/CD → Variables

`GITHUB_ACCESS_TOKEN`

`read:packages`

同上

`GITLAB_INSTALL_PACKAGE_TOKEN`

私有 Package Registry 读取权限

同上

`FONTAWESOME_TOKEN`

FontAwesome Pro 订阅 Token

同上

#### 2\. 备份现有配置

    # 创建备份分支
    git checkout -b backup/dependabot-config
    git add .gitlab-ci.yml .gitlab/dependabot.yml
    git commit -m "backup: dependabot configuration"
    git push origin backup/dependabot-config
    

### 5.2 迁移步骤

#### 步骤 1：引入 Renovate 模板

修改 `.gitlab-ci.yml`：

    # 在文件开头添加
    include:
      - project: 'renovate-bot/renovate-runner'
        file: '/templates/renovate.gitlab-ci.yml'
    

#### 步骤 2：添加 Renovate Job

    renovate:
      stage: dependencies
      variables:
        RENOVATE_TOKEN: $GITLAB_DEPENDABOT_TOKEN
        RENOVATE_GITHUB_COM_TOKEN: $GITHUB_ACCESS_TOKEN
        RENOVATE_REPOSITORIES: $CI_PROJECT_PATH
        LOG_LEVEL: debug
        RENOVATE_ONBOARDING: "false"
        RENOVATE_REQUIRE_CONFIG: "false"
        CI_RENOVATE_IMAGE: ghcr.io/renovatebot/renovate:full
        RENOVATE_NPMRC: |
          @fortawesome:registry=https://npm.fontawesome.com/
          //npm.fontawesome.com/:_authToken=${FONTAWESOME_TOKEN}
          @private:registry=https://gitlab.com/api/v4/projects/43909703/packages/npm/
          //gitlab.com/api/v4/projects/43909703/packages/npm/:_authToken=${GITLAB_INSTALL_PACKAGE_TOKEN}
      rules:
        - if: '$CI_PIPELINE_SOURCE == "schedule" && $SCHEDULE_NAME == "dependabot"'
          when: always
        - if: '$CI_PIPELINE_SOURCE == "web"'
          when: manual
    

#### 步骤 3：创建 renovate.json

根目录创建 `renovate.json`（参考前文完整配置）。

#### 步骤 4：注释 Dependabot Job

    # dependabot:
    #   stage: dependencies
    #   image:
    #     name: andrcuns/dependabot-gitlab-npm:3.70.0-alpha.1
    #   ...（保留配置以便回滚）
    

#### 步骤 5：测试运行

    # 方式 1：等待 Pipeline Schedule 自动触发
    # 方式 2：手动触发
    # GitLab UI → CI/CD → Pipelines → Run Pipeline → 选择 renovate job
    

#### 步骤 6：检查 Pipeline 日志

    # 查看 Renovate 日志
    # 1. 进入 Pipeline 详情页
    # 2. 点击 renovate job
    # 3. 查看日志输出
    
    # 关键日志：
    # ✅ "INFO: Repository started"
    # ✅ "INFO: Dependency extraction complete"
    # ✅ "INFO: Branch created: renovate/angular"
    # ✅ "INFO: Merge request created"
    

### 5.3 注意事项

#### 1\. 首次运行可能创建大量 MR

**原因**：Renovate 会扫描所有过期依赖。

**解决方案**：

    {
      "prCreation": "not-pending",  // 等待 status checks 通过再创建 MR
      "prConcurrentLimit": 3        // 首次运行限制为 3 个
    }
    

#### 2\. Monorepo 支持

对于 NX Monorepo，确保使用 `full` 镜像：

    CI_RENOVATE_IMAGE: ghcr.io/renovatebot/renovate:full
    

该镜像包含：

*   ✅ Node.js
*   ✅ NX CLI
*   ✅ pnpm/yarn
*   ✅ Git

#### 3\. 私有 Registry 配置

**错误示例**：

    # ❌ 错误：使用单引号会导致变量不展开
    RENOVATE_NPMRC: |
      //npm.fontawesome.com/:_authToken='${FONTAWESOME_TOKEN}'
    

**正确示例**：

    # ✅ 正确：不使用引号
    RENOVATE_NPMRC: |
      //npm.fontawesome.com/:_authToken=${FONTAWESOME_TOKEN}
    

#### 4\. Debug 日志

测试阶段启用 Debug 日志：

    LOG_LEVEL: debug
    

生产环境改为：

    LOG_LEVEL: info
    

#### 5\. 分组规则测试

**测试方法**：

    # 1. 临时修改某个依赖版本（模拟过期）
    npm install @angular/core@17.3.10
    
    # 2. 触发 Renovate
    # 3. 检查是否创建了分组 MR
    

### 5.4 回滚方案

如果 Renovate 出现问题，可快速回滚：

    # .gitlab-ci.yml
    
    # 注释 Renovate
    # renovate:
    #   stage: dependencies
    #   ...
    
    # 取消注释 Dependabot
    dependabot:
      stage: dependencies
      image:
        name: andrcuns/dependabot-gitlab-npm:3.70.0-alpha.1
      ...
    

6\. 总结与建议
---------

### 6.1 关键收获

1.  **分组功能是核心需求**：对于 Angular、NX 等强 Peer Dependency 的生态系统，分组更新是必需功能
2.  **Renovate 更成熟**：官方支持、稳定版本、配置灵活
3.  **迁移成本低**：可以复用 Dependabot 的 Token 和 Schedule
4.  **效果显著**：从每周处理 10+ 个 MR 降低到 2-3 个

### 6.2 最佳实践建议

#### 1\. 分组策略

    {
      "packageRules": [
        // 框架级别分组（推荐）
        { "groupName": "Angular", "matchPackagePatterns": ["^@angular/"] },
        { "groupName": "NX", "matchPackagePatterns": ["^@nx/", "^nx$"] },
    
        // 可选：按更新类型分组
        {
          "groupName": "Patch Updates",
          "matchUpdateTypes": ["patch"],
          "automerge": true  // Patch 版本可自动合并
        },
        {
          "groupName": "Major Updates",
          "matchUpdateTypes": ["major"],
          "automerge": false  // Major 版本必须人工审核
        }
      ]
    }
    

#### 2\. Rate Limiting 配置

    {
      "prConcurrentLimit": 10,      // 总 MR 数量
      "prHourlyLimit": 5,           // 每小时新 MR 数量
      "branchConcurrentLimit": 30,  // 总分支数量
      "schedule": ["after 10pm", "before 5am"]  // 夜间执行
    }
    

#### 3\. 自动合并策略

    {
      "packageRules": [
        {
          "matchUpdateTypes": ["patch"],
          "matchCurrentVersion": "!/^0/",  // 排除 0.x.x 版本
          "automerge": true,
          "gitLabAutomerge": true
        }
      ]
    }
    

#### 4\. 安全漏洞优先处理

    {
      "vulnerabilityAlerts": {
        "enabled": true,
        "labels": ["security", "dependencies"]
      },
      "packageRules": [
        {
          "matchDatasources": ["npm"],
          "matchUpdateTypes": ["patch"],
          "matchCurrentVersion": "!/^0/",
          "prPriority": 10  // 高优先级
        }
      ]
    }
    

### 6.3 适用场景

#### 推荐使用 Renovate

*   ✅ NX Monorepo 项目
*   ✅ Angular/React/Vue 等前端项目
*   ✅ 需要分组更新的项目
*   ✅ 需要精细化控制的项目

#### 可以使用 Dependabot

*   ⚠️ 小型单体项目
*   ⚠️ 无 Peer Dependency 要求
*   ⚠️ 依赖数量少（< 20 个）

### 6.4 未来优化方向

1.  **启用自动合并**：对 Patch 版本启用 `automerge`
2.  **细化分组规则**：按功能模块分组（如 UI 库、工具库）
3.  **集成 Slack 通知**：MR 创建时自动通知团队
4.  **配置 Dashboard**：使用 Renovate Dashboard 可视化依赖状态

参考资源
----

*   [Renovate 官方文档](https://docs.renovatebot.com/)
*   [GitLab Renovate Runner](https://gitlab.com/gitlab-com/gl-infra/renovate/renovate-runner)
*   [Renovate Configuration Options](https://docs.renovatebot.com/configuration-options/)
*   [GitLab Dependabot Issue #151](https://gitlab.com/dependabot-gitlab/dependabot/-/issues/151)
*   [NX Monorepo 最佳实践](https://nx.dev/recipes/other/root-level-scripts)

* * *

附录：完整配置文件
---------

### renovate.json（生产环境）

    {
      "$schema": "https://docs.renovatebot.com/renovate-schema.json",
      "extends": ["config:base"],
      "baseBranches": ["develop"],
      "timezone": "Europe/Berlin",
      "schedule": ["after 10pm every weekday", "before 5am every weekday"],
      "prConcurrentLimit": 10,
      "prHourlyLimit": 5,
      "branchConcurrentLimit": 30,
      "labels": ["dependencies"],
      "commitMessagePrefix": "chore(dependencies): ⬆️",
      "commitMessageAction": "bump",
      "commitMessageExtra": "to {{newVersion}}",
      "gitLabAutomerge": false,
      "platformAutomerge": false,
      "packageRules": [
        {
          "groupName": "Angular",
          "matchPackagePatterns": [
            "^@angular/",
            "^@angular-devkit/",
            "^@angular-eslint/",
            "^@schematics/angular$"
          ],
          "automerge": false
        },
        {
          "groupName": "NX",
          "matchPackagePatterns": ["^@nx/", "^nx$"],
          "automerge": false
        },
        {
          "groupName": "NestJS",
          "matchPackagePatterns": ["^@nestjs/"],
          "automerge": false
        },
        {
          "groupName": "PrimeNG",
          "matchPackagePatterns": ["^primeng$", "^@primeng/", "^primeicons$"],
          "automerge": false
        },
        {
          "groupName": "TypeScript",
          "matchPackagePatterns": ["^typescript$", "^@types/"],
          "automerge": false
        },
        {
          "matchUpdateTypes": ["patch"],
          "matchCurrentVersion": "!/^0/",
          "automerge": true,
          "gitLabAutomerge": true
        }
      ],
      "vulnerabilityAlerts": {
        "enabled": true,
        "labels": ["security"]
      }
    }
    

* * *

希望这篇文章对您的依赖管理工作有所帮助！如有问题欢迎在评论区交流。

  
作者：[Rest探路者](http://www.cnblogs.com/Java-Starter/)  
出处：[http://www.cnblogs.com/Java-Starter/](http://www.cnblogs.com/Java-Starter/)  
本文版权归作者和博客园共有，欢迎转载，但未经作者同意请保留此段声明，请在文章页面明显位置给出原文连接  
Github：[https://github.com/cjy513203427](https://github.com/cjy513203427)