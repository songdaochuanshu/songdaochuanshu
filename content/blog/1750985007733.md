---
layout: post
title: '《数据资产管理核心技术与应用》读书笔记- 第六章-数据监控与告警（一）'
date: "2025-06-27T00:43:27Z"
---
《数据资产管理核心技术与应用》读书笔记- 第六章-数据监控与告警（一）
===================================

《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，全书共分10章，第1章主要让读者认识数据资产，了解数据资产相关的基础概念，以及数据资产的发展情况。第2～8章主要介绍大数据时代数据资产管理所涉及的核心技术，内容包括元数据的采集与存储、数据血缘、数据质量、数据监控与告警、数据服务、数据权限与安全、数据资产管理架构等。第9～10章主要从实战的角度介绍数据资产管理技术的应用实践，包括如何对元数据进行管理以发挥出数据资产的更大潜力，以及如何对数据进行建模以挖掘出数据中更大的价值。

****关注清哥聊技术公众号，了解更多技术文章****

图书介绍：[数据资产管理核心技术与应用](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%90%86%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/64748553?fr=ge_ala)

今天主要是给大家分享一下第六章的内容：

**第六章的标题为数据监控与告警 **\->  **关注清哥聊技术公众号，了解更多技术文章******

在数据资产管理中，数据监控与告警和数据质量通常是同等的重要，在采集到质量的数据后，不仅需要对质量的数据进行监控，而且当数据质量低于一定的阈值时，还需要主动进行告警通知到对应的数据管理员进行及时处理。然而数据监控与告警不仅体现在数据质量上，还体现在数据链路、数据任务、数据服务、数据处理资源等很多监控中。数据监控不仅能够及时告警发现问题，还可以在定位问题时，通过监控数据来追踪问题。

*   数据质量：监控数据的准确性、完整性、一致性、可靠性等，当数据质量低于阈值时，及时触发告警。
*   数据链路：监控数据的实时链路和T+1链路，比如当数据链路出现中断时，立即触发告警，通知对应的数据开发和相关运维人员进行干预处理。
*   数据任务：数据处理的任务一般包括实时任务和离线任务两种，比如当实时任务运行停止或者报错时也或者是离线任务运行失败时，发送告警通知到相关的数据开发和运维人员进行问题定位处理。
*   数据服务：数据服务是提供数据使用的最常见的方式之一，通过对数据服务的监控以及当数据服务出现问题时及时告警通知，可以很大程度的提高数据服务的稳定性。
*   数据处理资源：数据任务的处理需要服务器资源、存储资源、网络资源等很多硬件资源，如果硬件资源出现瓶颈了而我们自己却不知道，那么势必会影响数据处理的速度和及时性，所以需要对这些硬件资源进行监控，比如服务器的CPU、内存资源不够用时，也或者是数据存储资源不够时，需要及时告警通知运维人员进行扩容或者别的干预处理。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

内容思维导图如下：

**一、 数据监控与告警的技术实现**

      监控与告警 其实不止是发生在数据资产管理中，在传统的IT运维和软件系统的维护中，都会存在监控与告警。监控一般是指以时序的方式去轮询采集待监控目标的相关数据，然后存储在合适的介质中，通过监控系统将这些采集到的监控数据进行简单的指标处理，然后从监控的视角展示出来的一种方式，如下图所示。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

告警是指在监控的基础上，通过配置阈值，当监控的数据指标满足阈值的条件时，主动推送消息通知给对应的接收人员，如下图所示。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

 

监控数据一般具有如下特点：

*   数据只做插入，基本不会存在数据的修改更新，就像日志数据一样，因为采集到的监控数据通常是根据时间时序变化的，并且在某一个时刻的数据是固定不会发生变化的。
*   数据量大，因为监控数据一般都是秒级进行采集的，所以随着时间的日积月累，数据量会越来越大。
*   数据不需要长期存储，比如1年前的监控数据，通常已经不存在太大的价值，可以对这些历史监控数据进行归档或者让数据自动过期删除以节省存储成本。
*   数据查询时需要快速查询并且一般是根据时间范围来进行时序查询，通常只会做一些简单的指标聚合操作（比如查询最新数据、平均值、最大值、最小值等），不会存在太复杂的指标运算，所以不会消耗很大的CPU计算资源。
*   写多读少，这点很容易理解，因为监控数据只是在监控时查询使用，并不会存在大量的查询场景和大量的并发查询，而监控数据需要按照时间序列持续的进行采集，所以会持续的存在大量的数据写入。
*   通常是数据顺序读取，一般是在指定查询的时间范围内读取一段连续的数据。

基于以上特点，监控数据一般最适合存储在时序数据库中，因为时序数据库通常具有如下特征：

*   列式存储，数据易压缩，可以缩小存储成本。
*   支持自动删除历史过期数据，不需要人工进行删除和干预。
*   支持水平扩展和数据分片，因为单节点存储数据或者查询和写入数据时，容易存在瓶颈。
*   高写入性能，比如支持批量写入提交，但是通常不支持数据更新。
*   支持针对时间序列类型的数据的高效便捷查询，能够快速地检索出指定时间范围内的数据，并且还支持聚合查询和时序分析等各种复杂的查询。

常见的开源的时序数据库包括Graphite、InfluxDB、Prometheus、OpenTSDB等多种，其中Prometheus、Graphite是被广泛用于监控数据的存储。

监控还有一个重要的环节就是数据采集，而且监控的目标很多，所以数据采集需要适配很多监控目标。

*   不同的监控目标，往往网络协议、连接方式以及获取数据的方式基本都不一样。
*   不同的监控目标，往往采集到的数据格式也不一样，所以数据采集后，还需要对数据做基础化的统一出来，针对不同类型的数据，在存储时，需要选用不同的数据类型来存储。

在数据监控中，常见的监控目标包括数据链路、数据任务、数据质量、数据服务、数据处理资源等。

**1、 数据链路监控：针对数据处理的实时链路和离线链路做监控。**

*   实时链路：在大数据处理中，实时链路一般都是通过实时数据流处理组件来实现的，常见的代表性技术组件就是Spark和Flink，实时链路监控中一般需要采集的核心数据指标如下表所示。

表

**监控数据类型**

**描述**

数据记录数/秒

采集实时流每秒处理的数据记录数

数据的字节数/秒

采集实时流每秒处理的数据字节数

数据记录的处理时长

采集实时流处理数据记录的耗时

数据记录的积压量

采集实时数据在处理时，数据记录的积压情况

数据记录的延迟

采集数据记录的延迟，在实时数据处理中，数据的延迟一般是指数据的当前处理时间减去数据的发生时间得到的差值，差值越大，延迟就越大。

在Spark中，实时流处理组件主要是通过Spark  Structured Streaming 来实现的，Spark Structured Streaming是一个基于Spark SQL引擎的可扩展支持容错的实时流处理引擎，使用微批处理引擎进行处理，该引擎将数据流作为一系列微小批次作业进行处理，从而实现低至100毫秒的端到端延迟 以达到理论上的实时处理效果，相关的官方技术文档介绍链接为：[https://spark.apache.org/docs/3.5.0/structured-streaming-programming-guide.html](https://spark.apache.org/docs/3.5.0/structured-streaming-programming-guide.html)，在该链接对应的文档中，有介绍到如何采集到Spark Structured Streaming的监控数据，如下图所示。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

在文档中，提供了如下三种方式来获取Spark Structured Streaming的监控数据

*   Reading Metrics Interactively：直接通过Spark Structured Streaming提供的streamingQuery.lastProgress()和streamingQuery.status()方法来直接获取实时流处理的状态和相关的指标，获取到的指标数据格式示例如下所示，通过解析如下所示的JSON数据，就可以获取到相关的监控数据指标。
*   Reporting Metrics programmatically using Asynchronous APIs：通过Spark Structured Streaming底层Jar包提供的API来直接读取监控指标数据。在Spark Structured Streaming底层代码中提供了org.apache.spark.sql.streaming.StreamingQueryListener 这个抽象类来对外提供实时流在每个微批处理过程中的指标查询，在该抽象类中主要提供了如下表所示的三个核心方法。

{  
          "id":  "ce011fdc-8762-4dcb-84eb-a77333e28109",  
          "runId":  "88e2ff94-ede0-45a8-b687-6316fbef529a",  
          "name":  "MyQuery",  
          "timestamp":  "2016-12-14T18:45:24.873Z",  
          "numInputRows":  10,  
          "inputRowsPerSecond":  120,  
          "processedRowsPerSecond":  200,  
          "durationMs":  {  
                    "triggerExecution":  3,  
                    "getOffset":  2  
          },  
          "eventTime":  {  
                    "watermark":  "2016-12-14T18:45:24.873Z"  
          },  
          "stateOperators":  \[  
  
          \],  
          "sources":  \[  
                    {  
                              "description":  "KafkaSource\[Subscribe\[topic-0\]\]",  
                              "startOffset":  {  
                                        "topic-0":  {  
                                                  "2":  0,  
                                                  "4":  1,  
                                                  "1":  1,  
                                                  "3":  1,  
                                                  "0":  1  
                                        }  
                              },  
                              "endOffset":  {  
                                        "topic-0":  {  
                                                  "2":  0,  
                                                  "4":  115,  
                                                  "1":  134,  
                                                  "3":  21,  
                                                  "0":  534  
                                        }  
                              },  
                              "numInputRows":  10,  
                              "inputRowsPerSecond":  120,  
                              "processedRowsPerSecond":  200  
                    }  
          \],  
          "sink":  {  
                    "description":  "MemorySink"  
          }  
}

表

**方法**

**描述**

def onQueryStarted(event : org.apache.spark.sql.streaming.StreamingQueryListener.QueryStartedEvent)

实时流查询的开始，该方法一般用于做数据的初始化

def onQueryProgress(event : org.apache.spark.sql.streaming.StreamingQueryListener.QueryProgressEvent)

实时流查询的处理，该方法一般用于获取实际的需要查询到数据指标。常见的指标包括：

*   numInputRows:每个微批读取到的待处理的数据记录数
*   inputRowsPerSecond：每秒读取到的待处理的数据记录数
*   processedRowsPerSecond：每秒处理的数据记录数
*   durationMs：实时流处理的持续时长
*   batchDuration：实时流每个微批处理的耗时
*   numOutputRows：实时流每个微批处理完后输出的记录数

def onQueryTerminated(event : org.apache.spark.sql.streaming.StreamingQueryListener.QueryTerminatedEvent)

实时流查询的结束，该方法一般用于做数据的销毁

从表中可以看到，每个微批次的实时流查询都会包括开始、处理、结束这三个阶段，在实际采集监控数据时，只需要继承org.apache.spark.sql.streaming.StreamingQueryListener 这个抽象类，并且覆写该抽象类中提供的onQueryStarted、onQueryProgress、onQueryTerminated这三个抽象方法即可，如下图所示，实现类需要生效的话，还需要通过sparkSession.streams.addListener将实现类添加到监听中，这样每个微批的实时流处理中，都会执行一次实现类来读取需要监控的数据指标。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

 

*   Reporting Metrics using Dropwizard：Spark底层支持使用Dropwizard库来采集数据指标，只需要在SparkSession中通过设置spark.sql.Streaming.metricsEnabled来启用该配置，如下所示。

spark.conf.set("spark.sql.streaming.metricsEnabled", "true")

或者

spark.sql("SET spark.sql.streaming.metricsEnabled=true")

启用了上述配置后，SparkSession将会通过Dropwizard向Spark中配置的监控数据接收器（比如Ganglia、Graphite、JMX等）上报指标数据。

Flink也是一个常用的实时流处理组件，应用非常广泛，在Flink的官方网址https://nightlies.apache.org/flink/flink-docs-release-1.18/docs/ops/metrics/#system-metrics中也提供了其对应的可以采集的监控数据指标的介绍文档，如下图所示。

在文档中包含了大量的监控数据指标说明，其中的核心指标如下图所示：《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

每个核心指标的解释如下：

*   numRecordsIn：实时流接收到的记录数
*   numRecordsInPerSecond：实时流任务每秒接收到的记录数
*   numRecordsOut：实时流任务输出的记录数
*   numRecordsOutPerSecond：实时流任务每秒输出的记录数
*   numLateRecordsDropped：实时流任务每秒延迟的记录数

从上面的数据指标可以看到，Flink可以获取到的核心监控数据指标和Spark Structured Streaming非常的类似，只是两种不同的技术组件定义的指标名称不一致，但是本质的含义几乎是一样的。

在Flink的官方网址[https://nightlies.apache.org/flink/flink-docs-release-1.18/docs/deployment/metric\_reporters/](https://nightlies.apache.org/flink/flink-docs-release-1.18/docs/deployment/metric_reporters/)中定义了其监控数据指标可以支持的接收器，并且详细介绍了如何来配置将监控的数据指标输出到对应的接收器中，如下图所示。

从图中可以看到FLink支持将监控数据指标直接输出到JMX、Graphite、InfluxDB、Prometheus、PrometheusPushGateway、StatsD、Datadog、Slf4j中，其中Graphite、InfluxDB、Prometheus 都是常见的时序数据库。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

*   离线链路：在大数据处理中，离线链路一般都是批处理任务，批处理任务大多也都是通过Spark、Flink、Hive等技术组件来实现的，其中Spark、Flink 本身就是既支持实时流处理，也支持离线的批处理。离线链路监控中一般需要采集的核心数据指标如下表所示。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

表

**监控数据类型**

**描述**

离线读取的数据记录数

离线链路每次读取的待处理的数据量

离线输出的数据记录数

离线链路每次处理完后输出的数据量

离线读取的数据字节数

离线链路每次读取的待处理的数据的大小，单位为Byte

离线写入的数据字节数

离线链路每次写入目标存储的数据的大小，单位为Byte

**2、 数据任务监控：数据处理的任务一般包含实时任务和离线任务两种，所以数据任务监控时，需要对实时和离线任务都进行监控。**

*   实时任务：实时任务一般是7\*24 小时持续都处于运行状态的任务，实时任务一般需要监控的核心数据指标如下表所示。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

表

**监控数据类型**

**描述**

任务运行的总时长

 实时任务持续运行的累计时长

任务日志中的异常数

实时任务输出的日志中，统计到的异常数

任务失败重试的次数

指任务运行失败时，自动重试的次数

*   离线任务：离线任务一般是指批处理任务，可以是T+1运行的任务或者轮询间隔运行的任务，比如每小时运行一次等，离线任务一般需要监控的核心数据指标如下表所示。

表

**监控数据类型**

**描述**

任务运行的总时长

 离线任务持续运行的累计时长，即每次批处理任务运行的耗时的累加

任务单次运行的时长

离线任务每次运行的耗时

任务单次运行的结果

离线任务运行的最终结果是成功或者失败

任务失败重试的次数

指任务运行失败时，自动重试的次数

任务日志中的异常数

离线任务输出的日志中，统计到的异常数

数据任务的监控指标数据采集实现的方式通常如下图5-1-8所示，数据任务通常是运行在专门的数据任务编排系统或者数据任务调度平台中，因此任务运行的相关的指标数据，可以直接从任务调度平台中获取，获取的方式可以从日志文件或者任务调度平台的数据库中直接抓取，当然如果对应的任务调度平台有相关的API接口，建议通过调用API接口的方式来采集数据，因为直接直连别的系统平台的数据库并不是一种很安全的访问方式。

**3、 数据质量监控**

通过第4章节中介绍的内容来采集到数据的质量数据后，就可以直接对质量的数据配置告警规则，在满足规则时，直接触发告警，如下图所示。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

**4、 数据服务监控**

数据服务是数据资产对外提供使用的一种形式，也是直接面向数据使用的用户的，所以数据服务的监控也非常重要，如果监控到服务出现故障，需要及时告警通知运维工程师或者平台管理员，数据服务监控的技术架构实现一般如下图5-1-10所示。

*   数据服务的数据监控指标通常主要是通过异步监听数据服务的日志的方式来获取， 之所以需要通过异步的方式来获取数据，是因为如果采用同步的方式获取数据，会影响API服务的调用耗时以及稳定性，采集到的原始数据可以先发送到消息队列中，因为消息队列可以做到削峰填谷，可以通过消息队列解决数据峰值时的处理压力，保证了整体链路的稳定性，从数据服务中通过日志可以获取到监控指标如下表所示。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

表

**指标数据类型**

**描述**

服务被调用的开始时间戳

 一般指数据服务端收到请求的时间戳

服务被调用的结束时间戳

一般指数据服务端处理完请求的时间戳

服务被调用的耗时

一般是通过服务被调用的结束时间戳减去服务被调用的开始时间戳获取到的耗时时长

服务被调用的结果

服务调用是成功还是失败

服务的调用IP

服务调用方请求时的客户端IP地址

服务在调用过程中发生的异常或者报错

获取调用过程中发生的异常或者报错信息，方便在发生问题时，做问题分析和定位

服务被调用时的失败次数

统计单位时间内，服务调用失败的次数统计

服务的调用次数

统计单位时间内，服务的总调用次数

*   通过探针的方式轮询对API服务做健康检查，每次探针检测的结果就是需要采集的健康数据，比如如果持续1分钟探针检查到API服务都是失败的，那么此时就需要去看API服务是否宕机了。每次探针检测的耗时也是一项重要的监控指标，因为耗时的时长可以衡量一个服务当前调用的快慢以及数据服务被调用的压力，如果压力过大，那么探针探测时的时长一般也会越长，如下图所示。

**5、 数据处理资源监控：一般是指数据处理时消耗的服务器或者别的硬件资源的监控，通常需要采集到的监控指标如下表所示。**

表

**指标数据类型**

**描述**

内存使用率

一般用于衡量服务器的内存的使用情况，已经使用的内存除以总的内存，就可以得到内存的使用率

虚拟内存的使用率

在服务器如果开启了虚拟内存的使用时，可以获取到虚拟内存的使用情况，虚拟内存通常不是真正的物理内存，通过是通过磁盘空间交换出来的存储空间，其读写的性能会比较慢，所以虚拟内存的使用率也是一个非常重要的监控指标，在虚拟内存使用率很高时，代表了数据处理可能在变慢以及物理内存已经严重不够用了。

CPU使用率

一般用于衡量服务器的处理能力，当CPU 使用率过高时，通常就代表了服务器的处理能力已经达到了上限了。

I/O 读取

读取磁盘等外部存储介质时，单位时间内读取到的字节数，一般用于衡量I/O的读取能力是否很高或者已经达到了上限。

I/O写入

写入磁盘等外部存储介质时，单位时间内写入的字节数，一般用于衡量I/O的写入能力是否很高或者已经达到了上限。

网络流量流入

一般指从外部访问当前服务器的所产生的网络流量，单位为字节

网络流量流出

一般是指当前服务器访问外部数据或者资源所产生的网络流量，单位为字节。

数据处理资源监控的技术架构实现一般如下图所示。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

从图中可以看到采集数据时，一般是通过SNMP协议来获取数据，SNMP是Simple Network Management Protocol的简写，即简单网络管理协议，可以用于服务器、工作站、路由器、交换机等常见的硬件设备中。通过SNMP协议采集数据的流程通常如下图所示。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

从图中可以看到SNMP协议的采集是基于管理站点和代理站点之间的通信，通过管理站点发送指令给代理站点来获取待采集的数据信息，代理站点接收到管理站点的指令后，会根据指令的内容收集需要的数据信息并将其包装成SNMP协议要求的数据格式返回给管理站点，管理站点在接收到代理站点的返回的响应内容后，会对其进行解析，解析时会根据SNMP协议定义的格式，提取相关的需要数据指标信息。《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

SNMP采集数据的的方式包括如下两种：

*   轮询采集：管理站点以周期性的轮询的方式给代理站点发送请求来获取相关的需要采集的数据，这种方式可以保证对监控设备的连续不间断的监控，但是对网络带宽消耗会较大，并且代理站点的负载压力会过大。
*   推送采集：当待采集的设备存在数据更变时，代理站点主动向管理站点发送通知，管理站点接到通知后对数据进行解析处理。

数据监控与告警的核心技术实现就在于监控数据的采集，在采集到了数据链路、数据任务、数据质量、数据服务、数据处理资源等待监控目标的相关数据并且存储到合适的存储介质中后，就可以定义相关的数据指标，然后选择相关的数据指标配置告警阈值，在达到告警阈值后，发送告警通知给对应的接收人员，如下图所示。

未完待续......《数据资产管理核心技术与应用》是清华大学出版社出版的一本图书，作者为张永清等著

作者的原创文章，转载须注明出处。原创文章归作者所有，欢迎转载，但是保留版权。对于转载了博主的原创文章，不标注出处的，作者将依法追究版权，请尊重作者的成果。

作者的原创文章，转载须注明出处。原创文章归作者所有，欢迎转载，但是保留版权。对于转载了博主的原创文章，不标注出处的，作者将依法追究版权，请尊重作者的成果。