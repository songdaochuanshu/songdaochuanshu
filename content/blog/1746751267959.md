---
layout: post
title: '迭代器失效：99%的C++程序员都会踩的坑 !'
date: "2025-05-09T00:41:07Z"
---
迭代器失效：99%的C++程序员都会踩的坑 !
=======================

大家好，我是小康。

> 你踩过这个坑吗？为什么我的程序明明很简单，却总是莫名其妙地崩溃！

嘿，各位 C++ 爱好者们，今天咱们聊一个几乎所有 C++ 程序员都会踩的坑——迭代器失效。无论你是刚入门的新手，还是写了好几年代码的老司机，这个问题都可能让你的程序莫名其妙地崩溃。不过别担心，读完这篇文章，你一定会恍然大悟："哦！原来是这么回事！"

> 微信搜索 「跟着小康学编程」，关注我，后续还有更多硬核技术文章分享，带你玩转 Linux C/C++ 编程！😆

迭代器到底是个啥？
---------

先别急着谈"失效"，咱们得先弄明白迭代器是啥玩意儿。

想象一下，迭代器就像是一个"指针"，指向容器（比如vector、list）中的某个元素。通过迭代器，我们可以访问、修改容器中的元素，还能在容器中移动（前进或后退）。

简单来说，迭代器就是容器和算法之间的桥梁，让你能够不关心容器内部结构，就能轻松遍历和操作容器中的元素。

    vector<int> nums = {1, 2, 3, 4, 5};
    // it就是一个迭代器，指向vector的第一个元素
    auto it = nums.begin(); 
    cout << *it << endl; // 输出1
    

什么是迭代器失效？
---------

现在到了关键问题：什么是迭代器失效？

简单讲，**当你对容器进行了某些操作后，原先有效的迭代器变得无效了，再使用这个迭代器就会导致未定义行为（通常是程序崩溃）**，这就是迭代器失效。

就好比你拿着一把钥匙（迭代器）去开一个门（访问容器元素），但有人趁你不注意把锁换了（容器结构改变），你的钥匙自然就不管用了。

常见的迭代器失效场景
----------

### 1\. vector中的迭代器失效

vector 是最常用的 STL 容器，也是迭代器失效最容易发生的地方。

#### 场景一：添加元素(push\_back)导致的失效

    vector<int> nums = {1, 2, 3};
    auto it = nums.begin(); // it指向1
    nums.push_back(4);      // 可能导致迭代器失效
    cout << *it << endl;    // 危险操作！可能崩溃
    

为啥会失效？因为 vector 在内存中是连续存储的，当空间不够时，会重新分配一块更大的内存，并把原来的元素复制过去。这时候，原来的内存地址就变了，之前的迭代器自然就失效了。

就像你正在看一本书，突然有人把这本书拿走换了一本新的放在原处——你手指的位置自然就不对了。

#### 场景二：insert 操作导致的失效

说到 vector 添加元素，咱们可不能忘了另一个常用的操作——insert！这家伙比 push\_back 还要狡猾呢！

    vector<int> nums = {1, 2, 3, 4, 5};
    auto it = nums.begin() + 2; // it指向元素3
    nums.insert(nums.begin(), 0); // 在最前面插入0
    cout << *it << endl; // 危险操作！it已经失效了
    

为啥 insert 更容易让人踩坑？因为 insert 有双重杀伤力：

首先，和 push\_back 一样，如果 vector 容量不够，insert会导致重新分配内存，所有迭代器就全军覆没了。

其次，即使没有重新分配内存，insert也会让插入位置及其后面的所有元素向后挪位置，这会使这些位置的迭代器全部"串位"。

打个比方，就像你排队时，突然有人插队到你前面，你和你后面的人都被迫向后移了一位——原来记录的位置信息就全乱套了！

记住这个简单规则：

*   如果 insert 导致扩容：所有迭代器都 GG
*   如果 insert 不导致扩容：插入位置及其后面的迭代器都 GG

#### 场景三：删除元素导致的失效

    vector<int> nums = {1, 2, 3, 4, 5};
    for (auto it = nums.begin(); it != nums.end(); ++it) {
        if (*it == 3) {
            nums.erase(it); // 迭代器失效
            cout << *it << endl;    // 不要继续使用it，危险操作！可能崩溃 
        }
    }
    

问题在哪？当你删除了一个元素后，该位置后面的所有元素都会前移，原来的迭代器就指向了一个错误的位置。

### 2\. list中的迭代器失效

list 是双向链表，它的迭代器失效情况比 vector 要简单些。

    list<int> myList = {1, 2, 3, 4, 5};
    auto it = myList.begin();
    ++it; // it指向2
    myList.erase(it); // 删除2，it失效
    // 不能再使用it 
    

对于 list，只有被删除节点的迭代器会失效，其他节点的迭代器仍然有效。这是因为 list 是链表结构，删除一个节点不会影响其他节点的内存位置。

### 3\. map/set中的迭代器失效

map 和 set 是基于红黑树实现的，它们的迭代器失效规则和 list 类似。

    map<int, string> myMap = {{1, "one"}, {2, "two"}, {3, "three"}};
    auto it = myMap.begin();
    myMap.erase(it); // it失效
    // 不能再使用it
    

同样，只有被删除元素的迭代器会失效，其他元素的迭代器仍然有效。

> 微信搜索 「跟着小康学编程」，关注我，后续还有更多硬核技术文章分享，带你玩转 Linux C/C++ 编程！😆

如何避免迭代器失效的坑？
------------

知道了问题所在，我们该如何避免呢？这里有几个实用技巧：

### 技巧一：使用 erase 和 insert 的返回值

大多数容器的 erase 方法都会返回下一个有效迭代器，insert会返回指向新插入元素的迭代器，我们可以利用这一点。

    // erase的返回值
    vector<int> nums = {1, 2, 3, 4, 5};
    for (auto it = nums.begin(); it != nums.end(); ) {
        if (*it == 3) {
            it = nums.erase(it); // erase返回下一个有效迭代器
        } else {
            ++it;
        }
    }
    
    // insert的返回值
    vector<int> nums2 = {1, 2, 3, 4};
    auto it2 = nums2.begin();
    it2 = nums2.insert(it2 + 2, 100); // it2现在指向新插入的100
    cout << *it2 << endl; // 输出100
    

这个技巧在需要连续操作容器时特别有用，可以保持迭代器始终有效。

### 技巧二：先记录再删除

    vector<int> nums = {1, 2, 3, 4, 5};
    vector<int> toRemove;
    
    // 先标记要删除的元素
    for (int i = 0; i < nums.size(); ++i) {
        if (nums[i] == 3) {
            toRemove.push_back(i);
        }
    }
    
    // 从后往前删除（避免索引变化）
    for (int i = toRemove.size() - 1; i >= 0; --i) {
        nums.erase(nums.begin() + toRemove[i]);
    }
    

### 技巧三：使用稳定的容器操作

一些容器操作不会导致迭代器失效，可以优先使用这些操作。

    // 对于list，splice操作不会导致迭代器失效
    list<int> myList = {1, 2, 3, 4, 5};
    list<int> anotherList = {10, 20};
    auto it = myList.begin();
    ++it; // it指向2
    myList.splice(myList.end(), anotherList); // 不会导致it失效
    cout << *it << endl; // 仍然是2
    

实战案例：解决常见迭代器失效问题
----------------

### 案例一：删除 vector 中的偶数

错误写法：

    vector<int> nums = {1, 2, 3, 4, 5, 6};
    for (auto it = nums.begin(); it != nums.end(); ++it) {
        if (*it % 2 == 0) {
            nums.erase(it); // 错误！迭代器失效
        }
    }
    

正确写法：

    vector<int> nums = {1, 2, 3, 4, 5, 6};
    for (auto it = nums.begin(); it != nums.end(); ) {
        if (*it % 2 == 0) {
            it = nums.erase(it);
        } else {
            ++it;
        }
    }
    

### 案例二：在遍历的同时添加元素

错误写法：

    vector<int> nums = {1, 2, 3};
    for (auto it = nums.begin(); it != nums.end(); ++it) {
        if (*it == 2) {
            nums.push_back(4); // 错误！可能导致迭代器失效
        }
    }
    

正确写法(使用下标)：

    vector<int> nums = {1, 2, 3};
    int size = nums.size(); // 先记录原始大小
    for (int i = 0; i < size; ++i) {
        if (nums[i] == 2) {
            nums.push_back(4); // 使用索引而非迭代器
        }
    }
    

总结
--

迭代器失效看起来很复杂，但只要记住几个简单的规则，就能轻松避开这个坑：

1.  **vector**: 插入或删除元素后，该位置及其后面的迭代器都会失效；如果重新分配内存，所有迭代器都会失效。
2.  **list/forward\_list**: 只有被删除元素的迭代器会失效。
3.  **map/set/multimap/multiset**: 只有被删除元素的迭代器会失效。
4.  **unordered\_map/unordered\_set**: 插入操作可能导致所有迭代器失效（rehash）；删除操作只会导致被删除元素的迭代器失效。

实际编程中，优先考虑使用现代 C++ 的算法和容器操作，比如`remove_if`和`erase`的组合，往往能更优雅地解决问题：

    vector<int> nums = {1, 2, 3, 4, 5, 6};
    // 一行代码删除所有偶数
    nums.erase(remove_if(nums.begin(), nums.end(), 
        [](int x) { return x % 2 == 0; }),
        nums.end());
    

怎么样，迭代器失效这个坑，你现在是不是已经有底了？下次写代码的时候，别忘了提醒自己：容器变了，迭代器可能就不靠谱了！

* * *

踩坑不止于此，一起深度探索 C++！
------------------

看完了这篇文章，是不是感觉对迭代器失效有了全新的认识？其实 C++ 的坑远不止这一个，每一个坑背后都有精彩的技术原理和解决方案。

想要避开更多 C++ 开发中的隐藏陷阱，掌握那些让代码更高效、更优雅的技巧吗？欢迎关注我的公众号「**跟着小康学编程**」！

在这里，我会用同样接地气的语言，继续为你解锁：

*   那些让面试官眼前一亮的 C/C++ 核心知识
*   大厂实战中总结的性能优化秘诀
*   计算机基础知识的趣味解读
*   以及更多像"迭代器失效"这样的实战踩坑指南

学习编程就像破解谜题，每掌握一个知识点，都是打开新世界的一把钥匙。我希望能和你一起，把复杂的问题变简单，把枯燥的技术变有趣！

如果这篇文章对你有帮助，欢迎 **点赞、收藏、关注**，也欢迎在评论区分享你踩过的 C++ 坑！

下期见！👨‍💻

#### 怎么关注我的公众号？

**扫码即可关注**。

![](https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png)

哦对了，我还建了个技术交流群，大家一起聊技术、解答问题。卡壳了？不懂的地方？随时在群里提问！不只是我，群里还有一堆技术大佬随时准备帮你解惑。一起学，才有动力嘛！

![](https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png)