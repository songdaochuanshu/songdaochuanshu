---
layout: post
title: 'å¤©å¤©ç”¨lockï¼Œä¸å¥½å¥‡ä»–åˆ°åº•æ€ä¹ˆå·¥ä½œçš„å— â€”ä»ReentrantLock åˆ°AQS'
date: "2025-07-07T00:46:35Z"
---
å¤©å¤©ç”¨lockï¼Œä¸å¥½å¥‡ä»–åˆ°åº•æ€ä¹ˆå·¥ä½œçš„å— â€”ä»ReentrantLock åˆ°AQS

æ–°æ‰‹å­¦ä¹ ï¼Œè‹¥æœ‰ä¸å¯¹ï¼Œæ¬¢è¿å¤§ä½¬ è°ƒæ•™ğŸ¥°ğŸ¥°ğŸ¥°

### ReentrantLock

æˆ‘ä»¬ç»å¸¸ç”¨çš„ `*ReentrantLock*`æ˜¯å¹²ä»€ä¹ˆçš„å‘¢ æˆ‘è®¤ä¸ºè¿™æ˜¯ä¸€ä¸ªå‰å°/é—¨é¢ï¼ˆç±»ä¼¼è®¾è®¡æ¨¡å¼ä¸­çš„é—¨é¢æ¨¡å¼ï¼‰æ ¹æ®æˆ‘ä»¬çš„å…¥å‚åˆ›å»ºä¸€ä¸ª`FairSync` OR `NonfairSync` ã€‚`sync` æ‹…ä»»é”çš„lock()å’Œrelease()ã€‚

        private final Sync sync;
       
        public ReentrantLock() {
            sync = new NonfairSync();
        }
    
        public ReentrantLock(boolean fair) {
            sync = fair ? new FairSync() : new NonfairSync();
        }
    
    

é‚£æœ‰äººå¯èƒ½å°±é—®äº†å•¥æ˜¯å…¬å¹³é”(`FairSync`)? å•¥æ˜¯éå…¬å¹³é”(`NonfairSync`)?

å°±æ‹¿å•†åœºè¯•åƒä¸¾ä¾‹å­ï¼Œå‰è€…å°±æ˜¯å¤§å®¶éƒ½å¥½å¥½æ’é˜Ÿï¼Œåè€…æ˜¯æ–°æ¥çš„çœ‹è¯•åƒå°æ ·è¿˜æœ‰ï¼Œç›´æ¥æ‹¿èµ°**ä¸å‚ä¸æ’é˜Ÿ**ï¼Œé‚£æ˜¾ç„¶åé¢çš„äººå°±ä¼š_é¥¥é¥¿_ å•Šã€‚é‚£éå…¬å¹³é”æœ‰ä»€ä¹ˆæ„ä¹‰å‘¢ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œå½“å•†åœºäººæ»¡ä¸ºæ‚£äº†ï¼Œä½ å»æ’åˆ°è¯•åƒçš„åé¢éƒ½è¦æŒ¤è¿‡æ¥ï¼ŒæŒ¤è¿‡å»ã€‚æ˜¾ç„¶ä½ åœ¨å…¨å±€ä¸Šå½±å“äº†å•†åœºçš„å®¢æµåŠ¨ï¼Œå¦‚æœä½ ç›´æ¥å» _å·è¢­ï¼(é©¬ä¿å›½éŸ³)_ æ˜¾ç„¶åœ¨å•†åœºå…¨å±€ä¸Šæ¥è¯´æ˜¯æœ€ä¼˜çš„ã€‚

åŠ é”
--

### AQSå…¥é˜Ÿ

å› ä¸º`FairSync` å’Œ`NonfairSync` å·®çš„ä¸æ˜¯å¾ˆå¤§ï¼Œ æˆ‘ä»¬å°±ç€é‡è®²`NonfairSync`

é‚£ä½ è¯´é‚£æˆ‘ç¼ºçš„è¿™å—`FairSync`è°ç»™æˆ‘è¡¥å•Šï¼Œ_æƒ³è¦å°±è‡ªå·±æ¥æ‹¿( æŒ‡è‡ªå·±çœ‹æºç ) ç»´å‰å°”éŸ³_

        
    //java.util.concurrent.locks.ReentrantLock
        static final class NonfairSync extends Sync {
            private static final long serialVersionUID = 7316153563782823691L;
    
            final void lock() {
                if (compareAndSetState(0, 1))
                    setExclusiveOwnerThread(Thread.currentThread());
                else
                    acquire(1);
            }
    

å¯è§å¦‚æœCASæˆåŠŸçº¿ç¨‹å°±ç›´æ¥è·å¾—é”äº†ï¼Œä¸æˆåŠŸå°±èµ°äº† `acquire()` å› ä¸º`Sync extends AbstractQueuedSynchronizer`è®©æˆ‘ä»¬æ¥çœ‹çœ‹`acquire()`

    // java.util.concurrent.locks.AbstractQueuedSynchronizer
         public final void acquire(int arg) {
            if (!tryAcquire(arg) &&
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
                selfInterrupt();
        }
    

`tryAcquire()` è·å–é”å¤±è´¥è¿›å…¥AQSç­‰å¾…é˜Ÿåˆ—

AQSç»ˆäºæ˜¯éœ²å‡ºé¸¡è„šäº†`acquireQueued(addWaiter(Node.EXCLUSIVE), arg))`

AQSï¼ˆAbstractQueuedSynchronizerï¼‰æŠ½è±¡é˜Ÿåˆ—åŒæ­¥å™¨ï¼Œåå­—æ˜¯ä¸æ˜¯å¾ˆé«˜å¤§ä¸Šï¼Œæˆ‘ä»¬åˆ«ç®¡

å°±æ˜¯å•†åœºè€å¤§çˆ·ã€è€å¤§å¦ˆæ’é˜Ÿè´­ç‰©ï¼ˆå…ˆè¿›å…ˆå‡ºçš„åŒå‘é“¾è¡¨ï¼‰ã€‚

è®©æˆ‘ä»¬çœ‹çœ‹nodeå…·æœ‰çš„å±æ€§

        static final class Node {
            // å…±æœ‰é”ï¼Ÿ
            static final Node SHARED = new Node();
            // ç‹¬å é”ï¼Ÿ
            static final Node EXCLUSIVE = null;
    
            // çº¿ç¨‹è¢«å–æ¶ˆ
            static final int CANCELLED =  1;
            // çº¿ç¨‹å¤„äºæ¿€æ´»æ€
            static final int SIGNAL    = -1;
            // çº¿ç¨‹åœ¨ç­‰å¾…ä¸­
            static final int CONDITION = -2;
            /**
             * waitStatus value to indicate the next acquireShared should
             * unconditionally propagate
             */
            static final int PROPAGATE = -3;
    
    

è®©æˆ‘ä»¬å†çœ‹çœ‹`addWaiter()` é€šè¿‡CASç¡®ä¿æˆåŠŸåŠ å…¥æœ€åä¸€ä¸ªèŠ‚ç‚¹ã€‚

        private Node addWaiter(Node mode) {
            Node node = new Node(Thread.currentThread(), mode);
            // Try the fast path of enq; backup to full enq on failure
            Node pred = tail;
            if (pred != null) {
                node.prev = pred;
                if (compareAndSetTail(pred, node)) {
                    pred.next = node;
                    return node;
                }
            }
            enq(node);   //  å¯¹AQSè¿›è¡Œåˆå§‹åŒ–å†åŠ å…¥
            return node;
        }
    

`enq()` å¯¹é˜Ÿåˆ—è¿›è¡Œåˆå§‹åŒ–ï¼Œæ·»åŠ ä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼ˆé¿å…ç©ºæŒ‡é’ˆï¼‰

        private Node enq(final Node node) {
            for (;;) {
                Node t = tail;
                if (t == null) { // Must initialize
                    if (compareAndSetHead(new Node()))
                        tail = head;
                } else {
                    node.prev = t;
                    if (compareAndSetTail(t, node)) {
                        t.next = node;
                        return t;
                    }
                }
            }
        }
    

### AQSå‡ºé˜Ÿ

è®©æˆ‘ä»¬å›åˆ° `acquire()`

        public final void acquire(int arg) {
            if (!tryAcquire(arg) &&
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
                selfInterrupt();
        }
    

ä¹°èœå¤§å¦ˆä¹ŸæŒºæ€¥çš„ï¼Œè¦æ’é˜Ÿå°±ä¼šå‚¬å‰é¢å¿«ç‚¹ï¼Œäºæ˜¯æ‹æ‹å‰é¢çš„äººï¼Œè¯´å¾€å‰å‚¬ä¸€ä¸‹ã€‚ï¼ˆå°‘æ•°æƒ…å†µï¼‰å‰é¢çš„äººä¹Ÿå¾ˆæ€¥ï¼Œçœ‹ç€æ—¶é—´æ¥ä¸åŠçƒ§èœäº†ï¼Œå°±è‡ªæš´è‡ªå¼ƒï¼Œç›´æ¥ç¦»å¼€äº†ï¼Œç©ºå‡ºäº†ä½ç½®ã€‚

        final boolean acquireQueued(final Node node, int arg) {
            boolean failed = true;
            try {
                boolean interrupted = false;
                for (;;) {
                    final Node p = node.predecessor();
                    if (p == head && tryAcquire(arg)) {
                        setHead(node);
                        p.next = null; // help GC
                        failed = false;
                        return interrupted;
                    }
                    if (shouldParkAfterFailedAcquire(p, node) &&
                        parkAndCheckInterrupt())
                        interrupted = true;
                }
                
            // å¤–éƒ¨ä¸­æ–­ï¼Œæˆ–çº¿ç¨‹å–æ¶ˆç­‰å¾…
            } finally {
                if (failed)
                    cancelAcquire(node);
            }
        }
    

åé¢çš„äººçœ‹åˆ°å‰é¢æœ‰ç©ºä½ï¼Œå°±å¾€å‰èµ°å†å‚¬å‰é¢çš„äººã€‚çœ‹åˆ°å‰é¢çš„äººå·²ç»åœ¨å‚¬å‰é¢çš„äººï¼Œä»–å°±ä¸å‚¬äº†ï¼Œå‚¬ç©ä¹‹åè‡ªå·±å°±èƒ½å¾…æœºäº†ï¼ˆå¹²ç€æ€¥ä¹Ÿæ²¡ç”¨ï¼‰ã€‚

ä¸ºä»€ä¹ˆä¼š _çœ‹åˆ°å‰é¢çš„äººå·²ç»åœ¨å‚¬å‰é¢çš„äºº_ å¯èƒ½æœ‰ä¸¤ä¸ªèŠ‚ç‚¹è¢«åŒæ—¶åŠ å…¥

        private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
            int ws = pred.waitStatus;
            if (ws == Node.SIGNAL)// å‰é¢çš„äººå·²ç»åœ¨é—®äº†
                return true;
            if (ws > 0) {        // å–æ¶ˆèŠ‚ç‚¹ï¼Œç©ºå‡ºä½ç½®ï¼Œå¾€å‰æŒª
                do {
                    node.prev = pred = pred.prev;
                } while (pred.waitStatus > 0);
                pred.next = node;
            } else {
                compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
            }
            return false;
        }
    

è§£é”
--

æˆ‘ä»¬æ¥çœ‹çœ‹é”çš„é‡Šæ”¾é˜Ÿåˆ—é˜Ÿåˆ—ä¸ºç©ºåˆ™è°ƒç”¨`unparkSuccessor(h)` ï¼Œä¸ºä»€ä¹ˆ waitStateä»¥ç­‰äº0åšæ ‡è®°ï¼Œä¸”çœ‹ä¸‹æ–‡

        public final boolean release(int arg) {
            if (tryRelease(arg)) {
                Node h = head;
                if (h != null && h.waitStatus != 0) // æ£€æŸ¥AQSæ˜¯å¦åˆå§‹åŒ–ï¼Œæˆ–é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
                    unparkSuccessor(h);
                return true;
            }
            return false;
        }
    

waitStateç­‰äº0å¯ç®€å•çœ‹åšï¼Œå·²ç»å®Œæˆäº†ä»–ä½œä¸ºè§£é”ä¿¡å·çš„èŒè´£ï¼ŒåŒæ—¶è¿™å’Œ -1æ˜¯ä¸ä¸€æ ·çš„ï¼Œ

\-1 æ˜¯æœªçŸ¥çš„å¾€å‰å‚¬ï¼ˆä¸çŸ¥é“å‰é¢å¥½æ²¡å¥½ï¼‰ï¼Œ0æ˜¯è‚¯å®šçš„è¯´å‰é¢æœ‰ä¸€ä¸ªç©ºä½ï¼Œå¹¶ä¸”æ˜¯headæŒ‡é’ˆè‡ªå‘çš„ï¼Œä¸ä¼šä¼ é€’ã€‚

    private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        if (ws < 0)
            compareAndSetWaitStatus(node, ws, 0); // é‡ç½® waitStatusä¸º 0
        Node s = node.next;
        if (s == null || s.waitStatus > 0) {
            s = null;
            for (Node t = tail; t != null && t != node; t = t.prev) // å¦‚æœä½ è§‚å¯Ÿåˆ°äº†è¿™æ®µçš„å¥‡æ€ªä¹‹å¤„ï¼Œæˆ‘ä¹Ÿæ²¡åŠæ³•è§£é‡Šï¼Œçœ‹äº†æ–‡ç« ä¹Ÿçœ‹åˆ°ä¸æ˜¯å¾ˆæ˜ç™½ï¼Œå°±ä¸è¯¯å¯¼äººäº†ã€‚ç›¸å…³å†…å®¹åœ¨ java.util.concurrent.locks.AbstractQueuedSynchronizer#cancelAcquire 
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread); // å”¤é†’ä¸‹ä¸€ä¸ªçº¿ç¨‹
    }
    

é˜Ÿåˆ—è¢« `unpark()` å”¤é†’ï¼Œé˜Ÿä¼å¯ä»¥å‘å‰ç§»åŠ¨äº†

å¦‚æœè§‰å¾—æœ‰å¸®åˆ°ä½ 

ç‚¹ä¸ªèµå†èµ°å‘—baby ğŸ¥°ğŸ¥°ğŸ¥°

* * *

_å‚è€ƒæ–‡ç« ï¼š_

[ä¸å¯ä¸è¯´çš„Javaâ€œé”â€äº‹](https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect)  
[ä»ReentrantLockçš„å®ç°çœ‹AQSçš„åŸç†åŠåº”ç”¨](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)