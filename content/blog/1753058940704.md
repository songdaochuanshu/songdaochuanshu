---
layout: post
title: 'Docker 磁盘占用分析和清理方法'
date: "2025-07-21T00:49:00Z"
---
Docker 磁盘占用分析和清理方法
------------------

2025-07-21 07:23  [曾左](https://www.cnblogs.com/zengzuo613)  阅读(24)  评论(0)    [收藏](javascript:void\(0\))  [举报](javascript:void\(0\))

本地或测试环境使用 Docker 时，常出现 Docker 占用磁盘空间大，导致系统磁盘资源不足等问题。基于此，总结了 Docker 磁盘占用分析及清理方法。

一、分析方法
------

### 1\. 使用 docker system 分析占用整体分布

    [root@linux7 data]# docker system df 
    TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
    Images              181                 81                  182.2GB             131.9GB (72%)
    Containers          349                 23                  565GB               156.7GB (27%)
    Local Volumes       91                  37                  4.706GB             2.67MB (0%)
    Build Cache         11                  0                   199.7MB             199.7MB
    
    [root@linux7 data]# docker system df -v  # -v 输出分布明细
    

（1）TYPE：表示 Docker 资源类型，包括 Images（镜像文件）、Containers（容器）、Local Volumes（本地数据卷）和 Build Cache（构建缓存）。

（2）TOTAL：表示该类型资源的总数量。

（3）ACTIVE：表示当前正在使用的资源数量。

（4）SIZE：表示该类型资源占用的磁盘空间总量。

（5）RECLAIMABLE：表示未占用可以回收的磁盘空间大小及百分比。

### 2\. 分析各类资源具体占用

（1）查看镜像占用并其排序

    [root@linux7 data]# docker images --format "{{.Repository}}:{{.Tag}}\t{{.Size}}" | sort -k 2 -h -r
    

（2）查看容器占用并其排序

    [root@linux7 data]# docker ps -a --format "{{.ID}}\t{{.Names}}\t{{.Size}}" | sort -k 3 -h -r 
    

（3）查看卷占用

    [root@linux7 data]# docker volume ls # 查看卷占用
    
    [root@linux7 data]# docker volume inspect <VOLUME_NAME>  # 查看具体卷详情
    
    [root@linux7 data]# du -sh <MOUNT_POINT> #查看卷真实占用磁盘大小
    

二、清理方法
------

### 1\. 清理未运行的容器

(1) 列出所有容器

    [root@linux7 data]# docker ps
    CONTAINER ID   IMAGE          COMMAND       STATUS      NAMES
    a1b2c3d4e5f6   nginx:latest   "nginx -g"    Exited      my-nginx
    
    [root@linux7 data]# docker ps -a # -a 输出所有容器，含已停止
    

(2) 清理指定容器

    [root@linux7 data]# docker rm <CONTAINER_ID>  # 清理已停止的容器
    
    [root@linux7 data]# docker rm -f <CONTAINER_ID>  # 强制清理（运行中的容器也会被停止并清理）
    

(3) 清理所有已停止的容器

    [root@linux7 data]#  docker container prune # 清理所有处于停止状态的容器
    
    [root@linux7 data]#  docker container prune -f # 强制清理所有处于停止状态的容器，跳过确认
    
    [root@linux7 data]#  docker container prune --filter "until=24h" # 仅清理 24 小时前停止的容器
    

### 2\. 清理未使用的镜像

(1) 列出所有镜像

    [root@linux7 data]# docker images
    REPOSITORY          TAG       IMAGE ID       CREATED        SIZE
    nginx               latest    abc123456      2 weeks ago    133MB
    ubuntu              20.04     def789012      1 month ago    72.8MB
    

(2) 清理指定镜像

    [root@linux7 data]# docker rmi <IMAGE_ID>  # 按 ID 清理
    
    [root@linux7 data]# docker rmi -f <IMAGE_ID> # 强制清理（即使被容器引用）
    
    [root@linux7 data]# docker rmi nginx:latest  # 按名称清理
    

(3) 清理所有未使用的镜像

命令格式：`docker image prune [OPTIONS]`，默认情况下会清理所有未被容器引用的悬空镜像（dangling images）。

常用选项：

`-a, --all`：清理所有未被使用的镜像，含悬空镜像。

`-f, --force`：不提示确认，直接清理。

`--filter`：支持条件过滤需清理的镜像。

`--dry-run`：仅显示将要清理的镜像，不实际执行清理。

使用示例：

    [root@linux7 data]# docker image prune # 清理悬空镜像
    
    [root@linux7 data]# docker image prune -a # 清理所有未被使用的镜像，含悬空镜像
    
    [root@linux7 data]# docker image prune -af # 强制清理不提示确认
    
    [root@linux7 data]# docker image prune --filter "until=24h" # 使用过滤器清理
    
    [root@linux7 data]# docker image prune --dry-run # 仅显示将要清理的镜像，不实际执行清理，清理操作不可逆，【建议】先使用`--dry-run`查看将要清理的镜像
    

### 3\. 清理未使用的网络

(1) 列出所有网络

    [root@linux7 data]# docker network ls
    NETWORK ID          NAME                DRIVER              SCOPE
    9e14a4176c29        bridge              bridge              local
    65b36b928672        host                host                local
    99c1c095900c        none                null                local
    
    [root@linux7 data]# docker network inspect host # 查看
    

(2) 清理指定网络

    [root@linux7 data]# docker network rm <NETWORK_ID | NAME> <NETWORK_ID | NAME>  # 清理已停止的网络
    

(3) 清理所有已停止的网络

    [root@linux7 data]# docker network prune
    

### 4\. 清理 Docker 所有未使用的资源

docker system prune 是 Docker 提供的系统级清理命令，主要用于清理不再使用的 Docker 对象（悬空资源）。

**清理范围：**

（1）停止的容器

（2）未被任何容器引用的网络

（3）悬空的镜像（未被标记且未被任何容器引用的镜像层）

（4）悬空的构建缓存

**参数详解：**

（1）--all / -a：清理所有未使用的镜像（而不仅仅是悬空镜像）

（2）--force / -f：跳过确认提示直接执行清理

（3）--volumes：清理未被容器使用的卷，务必谨慎

（4）--filter：按条件过滤要删除的对象

**示例：**

    [root@linux7 data]# docker system prune # 标准清理
    
    [root@linux7 data]# docker system prune -a -f # 强制清理所有未使用资源
    
    [root@linux7 data]# docker system prune --volumes # 清理未被容器使用的卷，务必谨慎
    
    [root@linux7 data]# docker system prune --filter "until=48h" # 清理超过 48 小时未被使用的资源。
    

三、相关知识点
-------

### 1\. 悬空镜像（Dangling Images）

（1）定义：指没有标签且没有被任何容器引用的镜像层。

（2）特征：通常显示为`<none>:<none>`的镜像。

（3）查看方法：

    [root@linux7 data]# docker images -f "dangling=true"
    

（4）产生场景：

多阶段构建时的中间镜像：当使用 Dockerfile 进行多阶段构建时，每个`FROM`语句都会产生一个中间镜像。构建完成后，这些中间镜像会变成悬空状态。

构建失败残留：构建过程中如果失败，可能会留下未完成的镜像层，这些也会成为悬空镜像。

重新构建同名镜像：当构建一个与现有镜像同名但不同内容的新镜像时，旧镜像会失去标签变成悬空镜像。

镜像标签变更：使用`docker tag`命令修改镜像标签后，原镜像如果没有其他标签引用，就会变成悬空镜像。

使用`docker commit`创建新镜像：基于容器创建新镜像后，原基础镜像如果没有其他引用，可能变成悬空状态。

### 2\. 未使用镜像（Unused Images）

（1）定义：指当前没有被任何容器使用的镜像（无论是否有标签），所以所有悬空镜像都属于未使用镜像。

（2）特征：可能有明确的镜像标签；但没有任何运行或停止的容器基于该镜像。