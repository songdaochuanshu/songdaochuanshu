---
layout: post
title: 'AD 侦查-MSRPC'
date: "2025-04-29T00:40:19Z"
---
AD 侦查-MSRPC
===========

> 本文通过 Google 翻译 [AD Recon – MSRPC (135/539)](https://juggernaut-sec.com/ad-recon-msrpc/) 这篇文章所产生，本人仅是对机器翻译中部分表达别扭的字词进行了校正及个别注释补充。

导航
--

*   [0 前言](#id0)
*   [1 MSRPC（远程过程调用）– Port 135](#id1)
*   [2 初始枚举 – Nmap 扫描](#id2)
*   [3 枚举 RPC 端点 – rpcdump.py](#id3)
    *   [3.1 查找有趣的服务](#id3.1)
*   [4 映射 RPC 端点 – rpcmap.py](#id4)
    *   [4.1 通过 MSRPC 检索网络接口的 IPs 地址](#id4.1)
        *   [4.1.1 枚举 IPv6 地址](#id4.1.1)
*   [5 使用 Metasploit 枚举 RPC](#id5)
    *   [5.1 auxiliary/scanner/dcerpc/endpoint\_mapper](#id5.1)
    *   [5.2 auxiliary/scanner/dcerpc/hidden](#id5.2)
    *   [5.3 auxiliary/scanner/dcerpc/management](#id5.3)
    *   [5.4 auxiliary/scanner/dcerpc/tcp\_dcerpc\_auditor](#id5.4)
*   [6 最后的想法](#id6)

* * *

**

0、前言

**
------------

在这篇文章中，我们将介绍几种不同的工具，用来枚举运行在 TCP/UDP 135 端口上的 MSRPC 服务。

首先，我们会简要介绍 MSRPC 并概述其工作原理；其次，在 Windows 10 主机上执行 nmap 扫描并发现 MSRPC 服务正在运行；然后，使用 rpcdump.py 工具枚举 RPC 端点，同时了解如何查找特定的服务；接着，使用 rpcmap.py 工具映射 RPC 端点。（遗憾的是，Windows 10 主机不允许匿名访问。于是，我们把精力集中在了 DC 上，这样运气可能会好一些。）

在映射 RPC 端点之后，我们发现了一个有趣的 RPC 服务正在运行且可以被利用。于是，利用公开的漏洞，我们提取到了 DC 自身的一些网络接口及其对应的 IP 地址。

在提取到 IP 地址列表之后，我们对其进行逐一检查，于是再次得到了一个可访问的 IPv6 地址。这意味着，枚举范围将再次扩大。于此同时，我们也将了解一些可以用来枚举 IPv6 地址的工具用法。

最后，我们将探索可用于枚举 MSRPC 的四个不同的 Metasploit 模块。

**

1、MSRPC（远程过程调用）– Port 135

**
---------------------------------

微软远程过程调用 (MSRPC) 是一种通信协议，它用于向网络中另一台计算机上的程序请求服务。换句话说，MSRPC 调用远程系统上的其它进程，就像是在本地系统中调用它们一样。这是通过“客户端-服务器”或“请求-响应”模型实现的。

> 如果想更详细地了解 RPC 的工作原理，请查看[维基百科](https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8)。

RPC 端点映射器可通过 TCP 和 UDP 135 端口、使用空会话或验证会话（TCP 139 和 445）的 SMB (管道)以及监听 TCP 593 端口的 web 服务进行访问。此外，在 49xxx 上打开 RPC 端口也很常见，而这些端口又被称为“随机分配的高 TCP 端口”。

> 注：TCP端口 593 是 **RPC over HTTP**（通常叫 **RPC over HTTP v1/v2**，后来也叫 **RPC over HTTPS**）使用的标准端口。

MSRPC 服务使用 IPC 机制（如 命名管道、NetBIOS、Winsock）在客户端和服务器之间建立通信，协议 `IPC$、TCP、UDP、HTTP` 用于提供对服务的访问，了解这一点对于理解基于 SMB 进行的 MSRPC 访问至关重要。

> 注：（1）IPC 机制（**Inter-Process Communication**，进程间通信）是一种在**不同进程之间交换数据或信号**的机制。（2）`IPC$` 是 Windows 电脑都会打开的默认共享，同时它也是 SMB 管道协议提供访问 RPC 服务的一个代表。

然而，在这篇文章中，我们会将注意力尽可能多地集中在对 135 端口的枚举上，而关于 SMB 的 RPC 则会在下一篇文章中再详细介绍。

此外，由于 RPC 是用于从网络中的另一台主机请求远程服务的服务，因此，作为攻击者我们应该考虑如何将特制的输入传递给应用程序以在目标系统上执行任意代码。

**

2、初始枚举 – Nmap 扫描

**
------------------------

首先，假设我们有一台 Windows 10 的目标机器，其 IP 地址为 172.16.1.200，然后使用 **nmap** 对其进行 TCP 扫描。

    nmap -A -sV -sC -T4 172.16.1.200 -p- -oN tcp_full.nmap
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193547970-1233123570.png)

从上面的输出中可以看到，端口 135 以及高 RPC 端口是开放的，那么接下来就让我们开始 RPC 服务的枚举吧。

**

3、枚举 RPC 端点 – rpcdump.py

**
--------------------------------

我们可以与 135 端口交互，以查询 RPC 定位器服务和各个 RPC 端点。这样，我们就能对通过 TCP、UDP、HTTP 和 SMB 命名管道运行的有趣服务进行分类。

RPC 定位器服务能被访问主要是通过以下五种**协议绑定**类型：

*   **ncacn\_ip\_tcp** — TCP 端口 135
*   **ncadg\_ip\_udp** — UDP 端口 135
*   **ncacn\_http** — RPC over HTTP 通过 TCP 端口 80、593 或其它端口
*   **ncacn\_np** — SMB 命名管道 `\pipe\epmapper`
*   **ncalrpc** — 基于本机的**本地 RPC 通信**协议（不走网络，以上 4 种是通过网络进行的）

> **ncacn\_ip\_tcp** 和 **ncacn\_np** 是我们在枚举过程中最常见的协议绑定，但理解其它绑定也很重要。

可以用来远程查询 RPC 定位器服务的最佳工具是 rpcdump.py，它是[Impacket](https://github.com/SecureAuthCorp/impacket) 脚本集合的一个脚本。

该脚本会转储目标上注册的 RPC **端点**和**协议绑定**列表。此外，它还会尝试将转储的列表与已知端点列表进行匹配。

> 注：端点在 rpcdump 的结果中是指“Protocol、Provider、UUID、Bindings”的综合，但实际上只是“UUID、Bindings”的综合，而协议绑定列表仅指 Bindings 中的值。工具 rpcdump.py 转储读到的信息应该只有 UUID、Bindings 有值，至于说 Protocol、Provider 中也会出现的值，应该是工具匹配已知 RPC UUID 列表并处理之后的结果。

    rpcdump.py 172.16.1.200 -p 135
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193549444-1253904803.png)

从上面可以看到，rpcdump.py 能够收集目标机器上所有的端点，即目标系统上运行的服务及其绑定的协议列表。总共转储了 334 个使用端点映射器分配了 RPC 端口号的端点（334 个正在运行的且注册了 RPC 的服务）。

> RPC 端点映射器允许 RPC 客户端读取以确定当前分配给特定 RPC 服务的端口号。客户端只有知道了特定服务对应的协议绑定列表，然后才能去和该服务进行通信。

#### **

3.1、查找有趣的服务

**

在上面的 334 个服务中，我们看到的大多都是一些仅在主机内部运行的服务，因此我们应该查找一些可以为我们提供潜在攻击的**特定远程服务**。例如，可以检查 Print Spooler 打印服务是否在运行，如果在运行，我们就可以远程利用 PrintNightmare 并获得 SYSTEM shell。

    rpcdump.py 172.16.1.200 -p 135 | egrep 'MS-RPRN|MS-PAR'
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193548144-1026599917.png)

有返回值，则表明该主机很可能会受到 PrintNightmare 的攻击！

> 有关 PrintNightmare 漏洞的更多信息，可查看该[帖子](https://www.cnblogs.com/kqdssheng/p/18753135)。

现在我们已经了解了如何远程转储目标主机上的端点列表，那么接下来就可以更进一步，以尝试发现一些有趣的端点映射。

**

4、映射 RPC 端点 – rpcmap.py

**
-------------------------------

可以用来枚举 MSRPC 的另一个工具是 **rpcmap.py**，它也来自 Impacket 脚本集合。

Rpcmap.py 会扫描正在监听的 DCE/RPC 接口，并绑定到 MGMT 接口以获取接口 UUID 列表。如果 MGMT 接口不可用，它就会使用已知的外部接口 UUID 列表，并尝试绑定到每个接口。因此，该工具将识别目标系统上开放的 DCE/RPC 接口。

> 注：rpcmap.py 首先尝试远程绑定到 RPC 的 MGMT 接口，成功的话就能获取到目标机器上的大量的 UUID 接口，然后再逐一对这些接口发起远程绑定请求，请求成功的则记录下来。如果绑定 MGMT 接口失败，那么它就使用一份已知的 UUID 列表，然后去逐一尝试去发起绑定请求，同样也是成功的记录下来。【关于 MGMT 的概念可查看本文 5.3 小节处的注释】
> 
> 因此，这种方式很像是一种 UUID 爆破，它和 rpcdump.py 的端点转储还不太一样。但这种方式的好处就是：（1）隐藏的 UUID 通过转储无法发现，但它能爆破出来。（2）最终记录出来的 UUID 基本都是 ncacn\_ip\_tcp 这样的可以通过网络远程通信的。

> 注：DCE/RPC 即 Distributed Computing Environment / Remote Procedure Calls，分布式计算环境 / 远程过程调用，它们都属于 RPC 的称呼。

通俗来讲，**rpcdump.py** 能够转储端点和绑定，而 **rpcmap.py** 可以用来确定端点映射是否可以通过远程绑定。

接下来，我们从枚举绑定在 ncacn\_ip\_tcp（TCP port 135）上的映射开始。

    rpcmap.py 'ncacn_ip_tcp:172.16.1.200'
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193546976-554469101.png)

不幸的是，在默认情况下，我们无法以匿名身份枚举加入了域的 Windows 10 机器。

然而，Windows Server 计算机并非总是如此。通常情况下，它们默认允许我们在 MSRPC 级别进行匿名访问。

因此，我们将把重点转移到域控制器上，看看通过匿名会话可以找到些什么。

    rpcmap.py 'ncacn_ip_tcp:172.16.1.5'
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193548336-253401999.png)

Amazing！我们能够匿名转储端点映射，在获得这些端点的服务信息后，我们可以在线搜索，看看其中是否有任何服务容易受到远程溢出攻击。

> 远程溢出漏洞在旧版 Windows 中更为常见。话虽如此，但最近有一个值得关注的漏洞：**[CVE-2022-26809](https://www.bleepingcomputer.com/news/microsoft/critical-windows-rpc-cve-2022-26809-flaw-raises-concerns-patch-now/ "CVE-2022-26809")**

在这个[网站](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/c25391af-f59e-40da-885e-cc84076673e4)中，我们可以用它来引用 UUID 值来确定它们的分配情况。具体来说，我们应该特别关注的是 IObjectExporter 的 RPC 接口的 UUID，也就是 IOXIDResolver（在土豆攻击中使用过）。

**IObjectExporter – {99fcfec4-5260-101b-bbcb-00aa0021347a}**

#### **

4.1、通过 MSRPC 检索网络接口的 IPs 地址

**

发现 IObjectExporter 服务正在运行后，我们可以使用一个很酷的技巧来提取目标主机上所有网络接口的 IP 地址。然后根据提取到的网络接口，我们很可能会发现另外一种可以转移到其它网络的方式，也可能会提供 IPv6 地址。

如果发现 IPv6 地址，就可以使用它来尝试在主机上找到要枚举/利用的其它服务。此时，需要使用此[脚本](https://github.com/mubix/IOXIDResolver)进行。

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193547982-1500743715.png)

    ./IOXIDResolver.py -t 172.16.1.5
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193548394-1289340246.png)

BOOM！通过脚本，我们成功发现了另一个网络的 IP 地址 10.0.3.15。这可能是在后渗透阶段一个潜在的突破机会，但在此时它基本不会有什么作用。还是把目光看向对应 172.16.1.5 接口的 IPv6 地址吧。

令人惊讶的是，这在 Windows 10 主机上也能正常工作，尽管我们使用 rpcmap.py 时被拒绝访问。

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193548742-1866352195.png)

###### **

4.1.1、枚举 IPv6 地址

**

首先，通过 ping IPv6 地址以确保我们可以与其进行通信。

    ping -c 3 2607:fea8:9961:d700:7d6d:b8f1:231e:c614
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193548687-353403137.png)

Perfect！ping 是成功的。

然后，我们使用 nmap 查找任何以前未被发现的开放端口，选项 -6 表示支持 IPv6 地址。

    nmap -6 -A -sV -sC -T4 2607:fea8:9961:d700:7d6d:b8f1:231e:c614 -p- -oN tcp_ipv6.nmap
    

我们希望可以找到一个只在 IPv6 上运行不在 IPv4 上运行的新的有趣的服务，但经过扫描我们并没有发现这个服务。

例如，如果我们发现 445 端口在 IPv6 上开放，而在 IPv4 上未开放，那我们仍然可以使用许多用于攻击 IPv4 的工具去攻击 IPv6。这是因为许多工具基本都添加了对 IPv6 的支持，因为 IPv6 在当今的现代网络中是至关重要的。

下面仅举几个工具，以展示在面对 IPv6 地址时它们是如何使用的。

    smbclient -L 2607:fea8:9961:d700:7d6d:b8f1:231e:c614 -N
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193549039-1299528411.png)

    crackmapexec smb 2607:fea8:9961:d700:7d6d:b8f1:231e:c614 --shares -u '' -p ''
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193548862-1956636897.png)

好了，让我们回到正文。

除了上面介绍的 Impacket 工具 rpcdump.py 和 rpcmap.py 之外，可以用来枚举端口 135 上的 MSRPC 的另一个好工具是 **Metasploit**。

**

5、使用 Metasploit 枚举 RPC

**
------------------------------

Metasploit 有一些非常好的模块，可以完成我们用 rpcdump.py 和 rpcmap.py 所能完成的大量工作，甚至更多。

首先，让我们使用以下命令启动 Metasploit：

    msfconsole -q
    

然后使用以下命令来查看所有 RPC 枚举脚本：

    search auxiliary/scanner/dcerpc
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193548985-2050933917.png)

通过搜索，我们找到了 8 个辅助模块，然而，并非所有这些模块都对我们的枚举有用。

对于我们当前的枚举，我们将把重点放在使用端口 135 的四个模块上，它们分别是：

*   **auxiliary/scanner/dcerpc/endpoint\_mapper**
*   **auxiliary/scanner/dcerpc/hidden**
*   **auxiliary/scanner/dcerpc/management**
*   **auxiliary/scanner/dcerpc/tcp\_dcerpc\_auditor**

接下来，让我们看看每个模块的实际示例！

#### **

5.1、auxiliary/scanner/dcerpc/endpoint\_mapper

**

Endpoint\_mapper 模块会查询远程系统的 EndPoint Mapper 服务，以确定哪些服务可用。其功能与 rpcdump.py 类似。

    use auxiliary/scanner/dcerpc/endpoint_mapper
    show options
    set RHOSTS 172.16.1.200
    exploit
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193550003-1406735130.png)

#### **

5.2、auxiliary/scanner/dcerpc/hidden

**

该模块将查询端点映射器并列出所有 ncacn\_tcp RPC 服务的列表。然后，它将连接到每个服务，并使用管理 API 列出该端口上可访问的所有其他 RPC 服务。

> 注：正常基于 RPC 的服务会把自己的接口信息注册到 135 端口上的端点映射器上，但一些 RPC 服务（为测试接口、故意隐藏管理接口、厂商私有扩展）不走标准注册流程导致普通扫描器就扫不出来。这时客户端可以根据一些已知的隐藏接口的 UUID 强行与其发起绑定请求，若回复则标识接口存在，反之接口不存在。
> 
> 端口 135处运行的服务是 RPC 端点映射器服务，而那些注册了 RPC 的服务则可以称为 RPC 服务。

任何被发现连接到 TCP 端口但未在端点映射器中列出的 RPC 服务都将被显示和分析，以确定是否允许匿名访问。

    use auxiliary/scanner/dcerpc/hidden
    show options
    set RHOSTS 172.16.1.200
    exploit
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193549280-1042513394.png)

从上面可以看到，在针对 Windows 10 机器进行测试时，所有接口的匿名访问都被拒绝。

然而，当瞄准 DC 时，会发现一些隐藏的服务。

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193549194-715997860.png)

这很酷，因为它为我们提供了额外的 UUID，而这些 UUID 是我们从转储端点中无法获得的。希望这些隐藏的服务能映射到存在漏洞的服务。

#### **

5.3、auxiliary/scanner/dcerpc/management

**

该模块可用于从远程管理接口 DCERPC 服务获取信息。

> 注：
> 
> MGMT（RPC management）：管理所有注册到 RPC 的服务的 UUID，相当于一个档案管理员。
> 
> EPM（RPC endpoint\_mapper）：根据客户端提供的接口UUID，告诉客户端这个 UUID 接口在什么地方监听。相当于一个指路人。
> 
> MGMT 接口是列出/管理所有注册的 RPC 接口信息；EPM 是帮助客户端根据 UUID 找到 RPC 服务位置的访问端口。

    use auxiliary/scanner/dcerpc/management
    show options
    set RHOSTS 172.16.1.200
    exploit
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193548802-82962320.png)

再次，当面向 Windows 10 主机时，匿名访问会被拒绝。

而当面向 DC 时，我们的运气会更好一些，并且匿名访问是可以接受的。

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193547861-520194563.png)

#### **

5.4、auxiliary/scanner/dcerpc/tcp\_dcerpc\_auditor

**

该模块允许我们确定哪些 DCERPC 服务可通过 TCP 端口访问。

> 注：该模块会爆破一份内置的 UUID 列表（里面是常见的、危险的、敏感的DCE/RPC接口UUID，比如MS-SAMR、MS-LSAD、MS-DRSR），然后对每一个 UUID 尝试进行 Bind 请求操作，若成功则记录该 UUID，从而找出暴露的 RPC 接口。

    use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
    show options
    set RHOSTS 172.16.1.200
    exploit
    

![](https://img2024.cnblogs.com/blog/1503193/202504/1503193-20250428193548515-1335213932.png)

有趣的是，它连接到 IObjectExporter，这正是我们之前使用 rpcmap.py 在 DC 上找到的。然后我们利用它来提取所有适配器 IP。

此外，当使用 rpcmap.py 拒绝访问时，可以用它来确认该服务是否正在运行。

**

6、最后的想法

**
---------------

如您所见，在端口 135 上可以进行一些相当不错的枚举，它提供给了我们很多东西，因此绝对是一个不应该被忽视的端口。

作为攻击者，我们应该始终尝试以**匿名的方式**在任何可能的地方进行枚举。像如 MSRPC 这样的服务，当它允许匿名访问时，它会提供大量的信息，而这些信息可能有助于我们找到凭据，甚至在系统上获得立足点。