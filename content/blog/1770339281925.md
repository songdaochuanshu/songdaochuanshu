---
layout: post
title: '推荐 .NET 8.0 开源项目伪微服务框架'
date: "2026-02-06T00:54:41Z"
---
推荐 .NET 8.0 开源项目伪微服务框架
======================

前言
--

嘿，小伙伴们！最近看到了一个 .NET 8.0 的小项目伪微服务框架，非常适合想要快速搭建小型应用项目或是想要学习.NET 8.0及新的技术，但又不知道从哪里学起的朋友。这个框架可以帮助我们简化开发流程，同时还能适应不断变化的需求。

它虽然简化了很多复杂的微服务特性，但仍保留了关键的微服务理念，让我们可以专注于业务逻辑而不是底层细节，并且达到实操效果。

想要快速上手 .NET 8.0，不妨试试这个框架。项目已经在 GitHub 上开源了，欢迎大家前来围观、提供建议或贡献代码。希望这个框架能够帮助更好的帮助我们工作中遇到的问题。

项目介绍
----

为什么说是伪微服务框架，常见微服务框架可能还包括服务容错、服务间的通信、服务追踪和监控、服务注册和发现等等，而这里为了在使用中的更简单，将很多东西进行了简化或者省略了。

**简化微服务概念**：作者虽然称为“伪微服务”，但本框架依然具备一些关键的微服务特性，如模块化设计和服务解耦。它通过减少复杂的服务间通信、容错机制和服务发现等功能，使开发更加高效且易于管理。

**技术栈**：集成了一些比较实用的新技术，包括EF Core、Redis、RabbitMQ和MySQL，确保应用高效又能应对高并发场景。

**易用性**：该框架的目标是尽可能地简化开发过程，提供完整的接口和文档，能够迅速上手，并将更多精力集中在业务逻辑上。

**持续优化**：尽管目前仍处于早期阶段，但作者承诺将持续改进和完善该项目。这包括但不限于引入更多高级特性、增强现有功能以及提升整体性能。

项目核心
----

**对象映射**：使用 `AutoMapper` 自动处理对象之间的映射，让你无需手动编写繁琐的转换代码。

**查询封装**：通过 `Ardalis.Specification` 和 `LinqKit.Core` 封装 EF Core 查询，让数据获取变得更简单直观。

**数据库交互**：在 EF Core 中重写了 `SaveChangesInterceptor`，实现了软删除功能，并自动管理创建时间和更新时间字段。

**整体架构**：采用了整洁的架构设计，便于理解和维护。

**业务功能**：已经预置了一些基本的业务功能，开箱即用。

**依赖注入**：内置了依赖注入容器，方便管理组件和服务。

**认证与授权**：使用双 token 实现了安全登录和无感知的前端 token 刷新。

**分布式 ID 生成**：集成了 `Snowflake` 分布式 ID 生成器，确保全局唯一标识符。

**缓存与锁**：通过 Redis 实现了分布式缓存和分布式锁，提高了系统的可用性和并发性能。

**消息队列**：利用 `RabbitMQ` 封装了异步任务处理机制，如文件上传和下载。

**定时任务**：结合 `Cronos` 和 `BackgroundService` 实现了秒级定时任务。

**数据初始化**：使用 `BackgroundService` 进行数据初始化，比如字典数据的加载。

**日志记录**：采用 `Serilog` 记录异常日志，并通过 Docker 部署实现日志的可视化监控。

**操作日志**：通过自定义过滤器和反射记录操作日志，便于追踪用户行为。

**权限验证**：实现了权限验证过滤器，确保用户只能访问被授权的资源。

**统一响应格式**：使用 `IAsyncResultFilter` 统一了返回给前端的数据格式。

**Excel 操作**：集成 `EPPlus` 库，支持 Excel 导入和导出。

**一键部署**：支持使用 `goploy` 快速部署前后端应用。

**API 文档**：通过 `Swagger` 自动生成 RESTful API 文档，方便前端和后端开发人员协作。

**配置加载**：自动加载 `appsettings.json` 文件中的配置信息。

项目框架
----

通过Github下载项目源码，我们可以查看项目框架，具体如下图所示：

![](https://img2024.cnblogs.com/blog/576536/202408/576536-20240823165609019-1106450563.png)

1、Libraries

包含各种外部类库，对其深加工使用在项目中

2、Services/Basic

微服务基础支撑子系统

3、Services/NCDP

微服务业务子系统

4、Services/SystemService

微服务系统服务（包括数据库的更新、定时任务、数据初始化、Swagger承载、RabbitMQ队列事件处理器等）

5、sun.Core

sun.Core作为了中转，其他外部或者自己封装的类库，在引用的时候都是在sun.Core中进行的引用。

算是间接引用，来简化项目中的依赖关系。

同时在sun.Core也封装了一些核心组件和服务。

![](https://img2024.cnblogs.com/blog/576536/202408/576536-20240823165855661-1876970856.png)

6、sun.Infrastructure

主要封装一些通用的方法，以及基础设施组件，供外部使用。

![](https://img2024.cnblogs.com/blog/576536/202408/576536-20240823165907878-476029284.png)

项目说明
----

关于项目详细使用情况可以查看作者整理的文章链接 https://www.cnblogs.com/aehyok/p/18058032 ，希望能够帮助大家更好的理解项目和学习知识点，提升自己的技术能力，下面只展示了部分内容。

#### 1、业务功能

目前基本实现的功能包括：用户管理、角色管理、区域管理、查看日志（登录日志和操作日志）、菜单管理、权限控制、系统管理等功能。

![](https://img2024.cnblogs.com/blog/576536/202408/576536-20240823165950242-344963990.png)

#### 2、生成文档工具

Swagger 生成REST APIs文档工具包含可以承载多个微服务项目，通过右上角进行切换，便可以查看当前微服务项目的接口文档，并可以进行测试

测试接口直接可在swagger ui上进行

统一添加接口中的Header参数

通过对Swagger UI进行部分的自定义，使的更好的适配自己的项目，比如添加登录，这样接口便直接可以在swagger UI上面进行。

![](https://img2024.cnblogs.com/blog/576536/202408/576536-20240823170029758-1450910516.png)

#### 3、分布式雪花Id生成器

Snowflake 所使用的开源类库：https://github.com/stulzq/snowflake-net

/// <summary>
/// 分布式雪花Id生成器
/// </summary>
public class SnowFlake
{
    /// <summary>
    /// 通过静态类只实例化一次IdWorker 否则生成的Id会有重复
    /// </summary>
    private static readonly Lazy<IdWorker> \_instance = new(() =>
    {
        var commonOptions = App.Options<CommonOptions>();

        return new IdWorker(commonOptions.WorkerId, commonOptions.DatacenterId);
    });

    public static IdWorker Instance = \_instance.Value;
}

其中 WorkerId和DatacenterId保持不同的话，例如两个微服务WorkerId一个为1一个为2,那么在同一毫秒数生成的Id肯定是不同的。

同一个IdWorker在一个毫秒中可以生成4096个序列号 足够大型系统使用了，不怕重复的问题。

#### 4、分布式缓存和分布式锁

Redis 统一封装实现分布式缓存和分布式锁，所使用的开源类库：https://github.com/2881099/csredis

目前主要封装了几个常用的接口方法

public interface IRedisService
{
    /// <summary>
    /// 查看服务是否运行
    /// </summary>
    /// <returns></returns>
    bool PingAsync();

    /// <summary>
    /// 根据key获取缓存
    /// </summary>
    /// <param name="key"></param>
    /// <returns></returns>
    Task<T> GetAsync<T>(string key);



    /// <summary>
    /// 设置指定key的缓存值(不过期)
    /// </summary>
    /// <param name="key"></param>
    /// <param name="value"></param>
    /// <returns></returns>
    Task<bool\> SetAsync(string key, object value);

    /// <summary>
    /// 设置指定key的缓存值(可设置过期时间和Nx、Xx)
    /// </summary>
    /// <param name="key"></param>
    /// <param name="value"></param>
    /// <param name="expire"></param>
    /// <param name="exists"></param>
    /// <returns></returns>
    Task<bool\> SetAsync(string key, object value, TimeSpan expire, RedisExistence? exists = null);

    /// <summary>
    /// 设置指定key的缓存值(可设置过期秒数和Nx、Xx)
    /// </summary>
    /// <param name="key"></param>
    /// <param name="value"></param>
    /// <param name="expireSeconds">过期时间单位为秒</param>
    /// <param name="exists"></param>
    /// <returns></returns>
    Task<bool\> SetAsync(string key, object value, int expireSeconds = -1, RedisExistence? exists = null);

    /// <summary>
    /// 删除Key
    /// </summary>
    /// <param name="key"></param>
    /// <returns></returns>
    Task<long\> DeleteAsync(string key);


    Task<Dictionary<string,string\>> ScanAsync();
}

主要是为了保持与redis cli中的方法一致，选了这个类库，当然你也可以选择其他的类库 还是蛮多的。

同时还封装了一个接口用于前端监测所有的key和value。

public async Task<dynamic\> ScanAsync(PagedQueryModelBase model)
{
    List<string\> list = new List<string\>();

    //根沐model.Keyword进行模糊匹配
    var scanResult = await RedisHelper.ScanAsync(model.Page, $"\*{model.Keyword}\*", model.Limit);
    list.AddRange(scanResult.Items);

    var values = await RedisHelper.MGetAsync(list.ToArray());

    var resultDictionary = list.Zip(values, (key, value) => new { key, value })
                                    .ToDictionary(item \=> item.key, item => item.value);
    dynamic result = new ExpandoObject();
    result.Items \= resultDictionary;
    result.Cursor \= scanResult.Cursor;  // 下一次要通过这个Cursor获取下一页的keys
   return result;
}

#### 5、自动化部署

通过google/zx使用nodejs开发了一个脚本，用于自动化部署

可以参考Github的地址：https://github.com/aehyok/zx-deploy

主要是用于开发环境，通过

pnpm sun-baisc
pnpm sun\-ncdp
pnpm sun\-systemserivce

当然你还可以通过组合命令进行部署，例如想一起部署三个服务

pnpm sun-all

    其实就是  

"pnpm sun-ncdp && 
pnpm sun-basic && 
pnpm sun\-systemservice"

这里我用的`&&`相当于上面三个命令串行执行，先执行sun-ncdp,再执行sun-basic,最后执行sun-systemservice。

如果你的电脑或者服务器性能足够好，可以使用`&`符号，这样就是并行执行，三个服务同时启动，这样可以节省时间。

以上仅展示了项目的部分内容，还有许多其他的技术应用和功能需要大家去发现。

然后我们可以下载源码参考文档并进行实际操作，以便全面了解整个项目的技术应用和特性。

项目地址
----

Github：https://github.com/aehyok/.NET8.0

最后
--

如果你觉得这篇文章对你有帮助，不妨点个赞支持一下！你的支持是我继续分享知识的动力。如果有任何疑问或需要进一步的帮助，欢迎随时留言。也可以加入微信公众号 **\[DotNet技术匠\]** 社区，与其他热爱技术的同行一起交流心得，共同成长！

![](https://img2024.cnblogs.com/blog/576536/202408/576536-20240813102419584-1596250541.png)