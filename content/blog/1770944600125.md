---
layout: post
title: 'Lab4-Lab: traps && MIT6.1810操作系统工程【持续更新】 _'
date: "2026-02-13T01:03:20Z"
---
Lab4-Lab: traps && MIT6.1810操作系统工程【持续更新】 \_
===========================================

Lab: traps
==========

​ 在这一个lab当中[6.1810 / Fall 2025](https://pdos.csail.mit.edu/6.828/2025/labs/traps.html)它要求我们理解xv6当中函数调用时的堆栈情况以及如何操控内存寻找多级函数调用的起始，更重要的是它带我们直观地感受到了**中断的全过程**。

​ 在此之前，官网给出了一些提示：

*   在开始编程之前， [请阅读xv6教程的第4章](https://pdos.csail.mit.edu/6.828/2025/xv6/book-riscv-rev5.pdf)，以及相关的源码文件`kernel/trampoline.S`。
*   `kernel/trap.c`当中是处理所有中断的代码。

RISC-V assembly (简单)
--------------------

​ 在这个lab当中，要求我们阅读一些汇编代码，并且了解c语言的某些语句对应的汇编是怎样的，同时了解不同寄存器的不同职责（例如**ra**寄存器是存放返回地址的寄存器）。然后带我们了解了一下编译器在编译代码时，如何优化/简化我们的代码。最后带我们直观地理解了一下大端模式和小端模式的区别以及两者在面对**多字节存储**和**单个数值**存储所造成的不同的影响。

如何阅读汇编代码
--------

​ 以下是截取了`call.asm`当中的一部分代码，这类代码是反汇编得来的结果。接下来将开始解析这段程序。

    ##这是c语言函数f的反汇编代码（通过截取编译器输出得到，不是手写的汇编代码，手写的汇编只有助记符，没有地址码和机器码）。
    int f(int x) {
      ##对于这一行，e是十六进制的内存地址/偏移，1141是十六进制机器码。
      ##再往后的addi  sp,sp,-16是将栈指针sp减16。（一般只有压栈的情况下才会修改栈指针）
       e:	1141                	addi	sp,sp,-16
      ##对于这一行，10是十六进制的内存地址/偏移，e422是十六进制机器码。
      ##再往后的sd	s0,8(sp)是将寄存器s0的内容保存到栈的8偏移处（sp+8）。
      10:	e422                	sd	s0,8(sp)
      ##对于这一行，12是十六进制的内存地址/偏移，0800是十六进制机器码。
      ##再往后的addi  sp,sp,16是将栈指针sp加16。（一般只有出栈的情况下才会修改栈指针）
      12:	0800                	addi	s0,sp,16
      ##调用函数g
      return g(x);
    }
    

问题解答：
-----

一、Which registers contain arguments to functions? For example, which register holds 13 in main's call to `printf`?（哪些寄存器包含函数的参数？例如，在main调用printf时，哪个寄存器存放着13？）

**答：**从main函数开始，有如下寄存器：

1.  **sp**栈指针寄存器，用于存储当前栈顶地址。（入栈先减地址再入，出栈先出再增）。
2.  **ra**返回地址寄存器，专门用于保存函数调用返回地址的寄存器。
3.  **s0**保存寄存器，用于保存函数执行过程中需要持续使用的中间值、帧指针等。
4.  **a0~a7**是函数的参数寄存器，传递函数参数时会用到。

​ 在main调用printf时，寄存器**a2**存放着13。

二、Where is the call to function `f` in the assembly code for main? Where is the call to `g`? (Hint: the compiler may inline functions.)（在main函数的汇编代码中，对函数f的调用在哪里？对g的调用又在哪里？（提示：编译器可能会内联函数。））

**答**：在main函数当中，对**f**的调用被简化为了一条指令：`li a1,12`，因为编译器在编译代码时，对于非常简单的函数数会进行**内联优化**（算出其结果，然后直接写入对于寄存器中，无需生成**`jal`/`jalr`调用指令**）。对于**g**的调用会在**f**当中，但是由于函数**g**过于简单，所以对函数**f**进行了**指令融合**，即将函数**g**当中的指令逻辑融合到**f**当中。在本例子当中，**g**会做加3操作然后返回，然后我们可以在**f**当中直接进行加三操作，无需调用**g**。

三、At what address is the function printf located?（函数printf位于哪个地址？）

**答：**在`call.asm`当中，有以下一行代码：

    30:	6c4000ef          	jal	ra,6f4 <printf>
    

​ 其中`jal`是跳转指令，指令格式为：`jal ra 目标地址`,再结合后面的`<printf>`我们可以得知**`0x6f4`**是printf的地址，对应printf的入口。

四、What value is in the register `ra` just after the `jalr` to `printf` in `main`?（在main函数中执行jalr到printf之后，寄存器ra中的值是什么？）

**答：**因为**ra**是返回地址寄存器，也就是说它里面保存的是执行完函数调用后应该返回的地址，所以此时在执行到printf后，**ra**内的值应该是指令`jal ra,6f4 <printf>`的下一条指令的地址，也就是**`0x34`**。

五、Run the following code.（运行接下来的代码）

    	unsigned int i = 0x00646c72;
    	printf("H%x Wo%s", 57616, (char *) &i);
    

What is the output? [Here's an ASCII table](https://www.asciitable.com/) that maps bytes to characters.（输出是什么？这是一个将字节映射到字符的ASCII表。）

The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set `i` to in order to yield the same output? Would you need to change `57616` to a different value?（输出取决于 RISC-V 是小端字节序这一事实。如果 RISC-V 是大端字节序，那么为了得到相同的输出，你会将 i 设为多少？你需要将 57616 改成其他值吗？）

**答：**输出内容如下（xv6默认小端模式）：

    He110,World
    

*   小端模式：低地址存放低位，高地址存放高位。
*   大端模式：低地址存放高位，高地址存放低位。

​ 依照大端模式，我们需要将**i**进行修改，大小端模式只影响多字节的存储，而**57616**只是单个数值，不涉及多字节存储。为符合大端要求，我们需要将**i**修改为：**`0x726c6400`**即可。

六、In the following code, what is going to be printed after `'y='`? (note: the answer is not a specific value.) Why does this happen?（在下面的代码中，'y='后面将会打印出什么？（注意：答案不是一个具体的值。）为什么会出现这种情况？）

    	printf("x=%d y=%d", 3);
    

**答：**因为变量**y**没有对应的赋值，所以会输出一个**未初始化的随机的值**（类似：0,1385，-2294）。在汇编时，printf函数会用到两个寄存器，其中 a1负责存放3，a2没有指定要存放谁，所以里面的值是未知的。

Backtrace（中等）
-------------

​ 当一个函数调用另一个函数时，CPU 会将调用点的返回地址保存到栈上，这样被调用函数执行完后才能回到原来的位置继续执行。每次调用都会创建新的栈帧，并在栈帧中保存返回地址和上一层的栈帧指针。因此，如果我们知道当前函数的栈帧位置，就可以顺着栈帧链“回溯”，找到上一层函数的返回地址，再继续向上，直到遍历完整个调用链。我们把这个过程形象地称为“顺腾摸瓜”，意思是沿着栈帧链，一层层找到调用关系。

​ 本 Lab 要求实现一个 `backtrace()` 函数，它从当前栈帧出发，沿着栈帧链打印每一层函数的返回地址。输出顺序应与调用链一致（从当前函数向上直到最初调用的内核入口）。

​ **栈帧：**指**函数栈帧**，是函数在运行时在栈上分配的一段内存，用来保存函数调用需要的信息（例如：返回地址，上一层函数的栈帧指针，局部变量，保存的寄存器）。

### 官网提示和个人解析

​ 1、在`kernel/defs.h`在声明 `backtrace()` 函数原型，这样其他文件可以调用，并且在`kernel/printf.c`当中实现该函数。

​ 2、由于我们需要获取当前的栈帧地址，所以官网给我们提供了一个`r_fp`函数，用于返回当前的栈帧地址。我们需要将这个函数复制到`kernel/riscv.h`当中的**`#ifndef __ASSEMBLER__ ... #endif`** 定义当中。

​ 3、在实现该功能时，我们需要获取当前栈帧的地址，好在官网提供了`r_fp`函数，它返回一个**uint64**类型的数据（这是栈帧指针，指向的位置存放着真正的栈帧地址），对其解引用会得到当前的栈帧地址。

​ 4、接下来我们开始“向上”寻找调用链上的函数，根据官网的提示，在**“栈帧地址 - 8”**的位置上存放的是上一层函数的返回地址，也是我们要打印的地址。在**“栈帧地址 - 16”**的位置上存放的是上一层函数栈帧的地址，在打印完毕后我们切换到上一层函数的栈帧，然后继续打印返回地址，然后再次向上寻找栈帧，直至到达顶端。

​ 以下是xv6内核的相关约定（几乎每个函数调用的时候都会伴随以下汇编代码）：

    addi sp, sp, -X    # 分配栈帧
    sd ra, 8(sp)       # 保存返回地址
    sd s0, 0(sp)       # 保存旧的 frame pointer（栈帧指针，指向存放栈帧的内存）
    mv s0, sp          # 更新 frame pointer（栈帧指针）
    

​ 更直观点：

    s0 → 指向自己栈帧的 s0 存放位置 + 8
    s0-8 → ra
    s0-16 → 上一级 s0
    

​ 5、在向上寻找时也要注意越界的问题，在xv6当中，整个栈都在同一个页面当中，因此所有的栈帧都是在一个页面中（这也解释了为什么递归的层级多了会爆栈的原因，因为调用新的函数会创建新的栈帧，占用同一个栈的内存），所以我们需要保证我们在获取到新的栈帧的同时，要保证与刚才才处理过的栈帧处于同一页面，官网当中给出了`PGROUNDDOWN(fp)`宏来帮助我们判断当前fp的页面。同时也有一个忽略的点就是要保证地址是递减的，这样总会递减到当前页的边界，使得循环终止，如果忽略该条件，可能会导致地址加加减减跳不出本页，进而无限循环。

​ 6、通过当前栈帧获取上一层函数的返回地址，并且打印。

​ 7、通过当前栈帧获取上一层函数的栈帧，然后继续寻找。

### 相关代码

​ 在`kernel/printf.c`当中。

    void backtrace(){
      // 当前的栈帧
      uint64 s0 = r_fp();
      // 临时变量，最新的函数栈帧
      uint64 temp = s0;
      // 临时变量，用于接下来的比较
      uint64 log = s0;
      printf("backtrace:\n");
      // 确保找到的栈帧和最新的栈帧是同一页，并且栈帧只能单调递减，不能出现环路，防止死循环。
      while((PGROUNDDOWN(s0) == PGROUNDDOWN(temp)) && (s0 >= log )){
        // 栈帧-8是返回地址，取出返回地址当中的值，以地址形式打印
        uint64 ra = *(uint64 *)(s0 - 8);
        printf("%p\n", (void *)ra);
        // 临时变量保存当前栈帧，在保证栈帧单调递减的判断中使用
        log = s0;
        // 栈帧-16是上一层函数的栈帧
        s0 = *(uint64*)(s0 - 16);
      }
    }
    

​ **之后根据官网的提示进行实验结果的验证即可。**

Alarm（困难）
---------

​ 在这一lab当中，要求我们**实现用户态的定时“中断”功能**。用户进程可以向操作系统注册一个函数（handler），并且要求CPU在每隔n个tick后执行该函数一次，在handler在被执行时，用户程序需要“被暂停”，直到handler执行完毕后再返回用户程序，这个过程类似于硬硬件中断机制，只不过采用了软件的方法实现。

### 官网提示和个人解析：

​ 1、首先要求我们新添加两个系统调用，分别是：**`sigalarm(interval, handler)`和`sigreturn(void)`**，具体的添加方式详见：[Lab2-system calls && MIT6.1810操作系统工程【持续更新】 - 小白同学\_C - 博客园](https://www.cnblogs.com/xiaobai1523/p/19530432)。与此同时，`sigalarm(interval, handler)`函数的第一个参数interval代表每隔多少和tick执行handler，第二个参数handler就代表CPU每个n个tick要执行函数的地址了。这就需要我们在进程的`proc`当中添加新的成员用于记录当前tick和当前已经过去了多少tick以及注册的函数指针。

​ 2、如果应用程序调用 sigalarm (0, 0)，内核应停止生成周期性的警报调用。

​ 3、handler执行时，需要我们暂停用户程序，也就是先将用户程序的代码保护起来，替换为handler的代码。待handler执行完毕后再将用户程序的代码恢复，这就要求我们在进程的`proc`当中添加相应的trapframe帧用于保存用户程序状态（和中断的思想一样，打断当前执行的程序→保护断点和现场→获得中断向量→执行中断处理程序→恢复断点和现场→被打断的程序继续执行）。

​ 4、把`user/alarmtest.c` 添加到 Makefile 中。

​ 5、记得把`sigalarm(interval, handler)`和`sigreturn(void)`添加到`user/user.h`当中。，格式如下：

    	int sigalarm(int ticks, void (*handler)());
        int sigreturn(void);
    

​ 6、每过一个tick，硬件时钟就会触发一次中断，该中断在 `kernel/trap.c` 的 `usertrap ()` 中处理，所以我们需要在这里进行修改。官网说了，只要发生定时器中断时，我们才需要修改/对比进程的时钟tick数。在如下判断体内实现“判断handler是否执行的相关逻辑”，并且保存用户程序的断点和将用户程序代码替换为handler就在此执行。

    	if(which_dev == 2) ...
    

​ 7、 当handler执行完毕后，也是调用了`sigreturn`函数时，要求我们返回当前进程的**a0**寄存器。

### 相关代码

​ 有关添加系统调用的代码在这里就先跳过了，可以翻翻博主之前的文章[Lab2-system calls && MIT6.1810操作系统工程【持续更新】 - 小白同学\_C - 博客园](https://www.cnblogs.com/xiaobai1523/p/19530432)。

​ 一、kernel/proc.h

    // 在进程的proc当中新添加如下内容：
      int alarmticks;              // 警报之间的滴答声
      int alarmtickscount;         // 上次警报后的滴答声次数
      uint64 alarmhandler;      // 闹钟滴答声过去时调用的处理程序
      int inhandler;               // 是否正在处理alarm
      struct trapframe alarm_tf; // 用于保存被 alarm 打断时的 trapframe
    

​ 二、kernel/sysproc.c

    uint64
    sys_sigalarm(void)
    {
      int ticks;
      uint64 handler;
    
      // 读取用户传入参数
      argint(0, &ticks);
      argaddr(1, &handler);
    
      struct proc *p = myproc();
    
      // 设置 alarmticks 和 alarmhandler
      p->alarmticks = ticks;
      p->alarmtickscount = 0;
      // 如果 ticks 和 handler 都为 0，表示取消 alarm，所以将 alarmhandler 设置为 -1，表示不调用 handler
      if(ticks == 0 && handler == 0) {
        p->alarmhandler = -1;
      }else{
        p->alarmhandler = handler;
      }
    
      return 0;
    }
    
    uint64 
    sys_sigreturn(void)
    {
      struct proc *p = myproc();
      // 恢复被 alarm 打断时的 trapframe，以便在 handler 处理完后继续被打断的程序
      memmove(p->trapframe, &p->alarm_tf, sizeof(struct trapframe));
      // 处理完 alarm 后，重置 inhandler 和 alarmtickscount
      p->inhandler = 0;
      p->alarmtickscount = 0;
      return p->trapframe->a0; // 返回用户程序中 a0 的值
    }
    

​ 三、kernel/trap.c

    // 在usertrap函数的 if(which_dev == 2)... 当中添加如下内容：
    // 在时钟中断时，检查是否需要处理 alarm
      if(which_dev == 2){
        // 获取当前进程的指针
        struct proc *p = myproc();
        // 如果当前进程设置了 alarmhandler，并且不在处理 alarm 的过程中，就检查是否需要调用 alarmhandler
        // 注意，alarmhandler 的值为 -1 表示没有设置 handler（不调用），值为 0 表示正在处理 alarm，
        // 所以只有当 alarmhandler 大于 0 时才表示设置了 handler 并且不在处理 alarm 的过程中
        if(p->alarmhandler == 0 || p->alarmhandler != -1){
          // 增加滴答声计数，并检查是否达到了 alarmticks，如果达到了，并且 alarmticks 大于 0，就调用 handler
          p->alarmtickscount++;
          // 如果达到了设定的滴答数，且设置了 alarmticks（大于 0），就调用 handler
          if(p->alarmtickscount >= p->alarmticks && p->alarmticks > 0 ){
            p->alarmtickscount = 0;
            // 调用用户设置的 alarm 处理程序
            if(!p->inhandler){
              // 设置当前正在处理 alarm，防止在处理 alarm 的过程中被再次打断调用 handler
              p->inhandler = 1;
              // 保存被打断时的 trapframe 到 alarm_tf 中，以便在 handler 处理完后恢复
              memmove(&p->alarm_tf, p->trapframe, sizeof(struct trapframe));
              // 设置 trapframe 的 epc 为 handler 的地址，这样在 usertrapret() 时就会跳转到 handler 处执行
              p->trapframe->epc = (uint64)p->alarmhandler;  
    
            }
            
          }
        }
        yield();
      }
    

### 验收成果

    xiaobai@***:~/xv6-labs-2025$ ./grade-lab-traps alarm
    make: 'kernel/kernel' is up to date.
    == Test running alarmtest == (4.1s)
    == Test   alarmtest: test0 ==
      alarmtest: test0: OK
    == Test   alarmtest: test1 ==
      alarmtest: test1: OK
    == Test   alarmtest: test2 ==
      alarmtest: test2: OK
    == Test   alarmtest: test3 ==
      alarmtest: test3: OK
    xiaobai@***:~/xv6-labs-2025$
    

写在最后
----

​ 这一lab可以说很直观地让我们感受到中断的过程是怎样的，特别是涉及“保护断点/现场”，“获取中断服务程序入口地址”，“恢复断点/现场”等内容。

​ 快过年了，争取大年三十前尽快赶出下一个lab。