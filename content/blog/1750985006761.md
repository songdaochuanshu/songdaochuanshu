---
layout: post
title: '一个程序在计算机中是如何运行的？'
date: "2025-06-27T00:43:26Z"
---
一个程序在计算机中是如何运行的？
================

这是一个困扰了我很久的问题，但是之前都没有想过好好了解，最近在看《深入理解计算机系统》，想将整个流程归纳总结一下，文章结构包括：**可执行目标文件的结构——>操作系统如何加载可执行文件——>CPU如何执行可执行文件**。

可执行目标文件结构（第七章节）
===============

编译器通过预处理、编译、汇编、链接生成了最后的可执行目标文件，文件结构如下：

![](https://img2024.cnblogs.com/blog/3180563/202506/3180563-20250624182049747-1995547205.png)

ELF头描述了代码段`.text`、`.init`、`.rodata`，数据段`.data`和`.bss`的位置，在最初加载可执行文件时，会被率先读取到内核态的临时缓冲区，用于构建虚拟映射VMA，说明整个程序的虚拟内存里，哪里是代码段，哪里是数据段。

`.init`是在`main()`函数执行之前需要运行的代码，想知道请自行了解。在经过链接之后，代码段里的符号引用已经被重定位成了在代码段和数据段的地址，翻译成汇编语言，就是我们所看到的：

    .section .rodata
    .LC0:
        .string "Hello, World!"
    
    .text
    .globl main
    main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
    
        lea     rdi, [rip + .LC0]     # rdi = "Hello, World!"
        call    std::operator<<<std::char_traits<char> >(std::ostream&, char const*)
        mov     rax, 0 
        leave
        ret
    

CPU会不断地重复，取指令，解析指令，运行指令的过程，在第三部分详细介绍，接下来让我们了解，一个可执行目标文件是如何被加载到内存，构建成一个进程的。

操作系统加载可执行文件（第八、九章节）
===================

VMA
---

《深入理解计算机系统》的P581做了详细介绍，VMA是Linux内核中用来表示某一段虚拟地址范围的结构体，在`struct vm_area_struct`中定义。它不直接包含数据，不是“装数据的容器”，而是一个描述，告诉操作系统：

    // 通过 vm_flags 和 vm_file 推断某一段虚拟地址空间是干什么的（代码、堆、栈、文件映射等）
    struct vm_area_struct {
        unsigned long vm_start;     // 起始虚拟地址
        unsigned long vm_end;       // 结束虚拟地址
        struct file *vm_file;       // 映射的文件
        unsigned long vm_flags;     // 权限标志（如可读、可写、可执行）
        struct mm_struct *vm_mm;    // 指向该进程的虚拟内存空间
        struct vm_operations_struct *vm_ops; // 缺页处理函数，说明页面缺页时该怎么办
        ...
    };
    

使用`malloc()`和`mmap()`的本质就是通过内核机制在当前进程中创建新的VMA，从而在虚拟地址空间中分配出一段内存。

### ⭐当CPU访问虚拟地址时，发生了什么？

**CPU的动作**：取`PC = 0x400123`，解码`mov`指令，指令操作数中包含`0x601050`，CPU 使用页表（+TLB）查找这个地址的物理地址，如果找不到页表项 ➜ 触发**Page Fault**。

**Page Fault 发生后**：内核根据`fault`地址去进程的VMA红黑树中查找这个地址`0x601050`落在哪个VMA里？找到了VMA，调用该VMA绑定的`vm_ops->fault()`处理函数，创建页表项和映射物理页，恢复用户态程序继续执行。

### ⭐某一段的VMA一定存在吗？（原来这就是 Segmentation Fault）

并不是所有虚拟地址空间区域一开始就有对应的VMA，如果程序访问了没有对应VMA的虚拟地址，操作系统会报**段错误（Segmentation Fault）**，终止程序。**所以程序的`.text`、`.data`和`.bss`在程序加载时就一定会被操作系统构建对应的 VMA，否则程序根本无法正常执行。**

### VMA怎么管理？

内核为每一个进程维护自己的任务结构，其中一个条目指向`mm_struct`，`mm_struct`有两个字段`pgd`和`mmap`，其中`pgd`指向第一级页表的基址，`mmap`指向一个维护VMA的链表。

shell启动新的用户进程
-------------

    ./hello_world.out argv1 argv2
    

shell进程会调用`parseline`函数，以空格分隔解析参数保存在`cmdline`，第一个参数可能是一个内置的shell命令或者可执行目标文件。解析完命令后，`builtin_command`函数会检查第一个命令行参数是不是内置的shell命令，如果是，立即执行后返回1，否则返回0。在`builtin_command`返回0后，shell会创建一个子进程，并且在子进程中执行`execve(argv[0], argv, environ)`。shell进程使用`fork`的时候，会创建新进程的PCB，分配新的PID，创建当前进程的`mm_struct`，但是子进程的`mm_struct`会深拷贝父进程的虚拟内存描述，其中`pgd`指向的页表会被设置为只读，采用**COW**写时复制策略。

execve系统调用陷入内核态
---------------

`execve`是一个系统调用，作用是用一个新的程序替换当前进程的地址空间。`execve`执行时会触发`syscall`，使程序从用户态陷入内核态，过程为：

1.  切换特权级，从用户态（Ring 3）到内核态（Ring 0）。
    
2.  将当前栈指针从用户态的用户栈切换到这个内核栈顶。
    
3.  CPU保存进程上下文：将PC、寄存器的值以中断帧的形式压栈，并将进程状态、上次执行位置等信息保存在当前进程的PCB中，等系统调用处理完之后再返回到**该地址的下一条地址**继续执行。
    
4.  跳转到`syscall`表中`execve`对应的内核函数处理。
    

内核态更改当前进程上下文
------------

在内核态里，`execve`执行的动作包括：

1.  清理当前进程的VMA链表，也就是`mm_struct`里的`mmap`链表中的所有项。
    
2.  映射私有区域：分析新的ELF头，构建代码段和数据段等的VMA，注意，这时候除了`.text`的程序入口等必要的程序加载代码之外，其余的段的VMA还没有构建页表项。
    
3.  映射共享区域：共享库的内存映射区域在堆和栈之间，建立这一块区域的VMA，这里的页表也是懒加载，缺页时使用缺页异常处理函数构建。
    
4.  设置新入口点：将PC设置为新程序的入口地址（来自 ELF Header），更新栈指针到新的用户栈。
    

CPU如何执行可执行目标文件（第四章节）
====================

PC指针被设置为了新程序的入口地址，取指单元使用MMU将虚拟地址翻译为物理地址，并从物理地址（DRAM或者SRAM）中取指令，指令传给译码器，译码器解析指令来控制PC和ALU等。同时PC是自增的，除了一些会引起PC指针赋值的指令之外，PC会自动增加4字节/8字节大小，到下一个指令的地址。MMU会根据虚拟地址获取页表项，再获取物理地址，若页表项不存在，则出发缺页异常。

缺页异常处理函数会判断访问是否合法，如果合法，就分配或加载物理页，并建立页表项；否则，终止进程（如抛出段错误 SIGSEGV）。若合法，会判断页面类型（匿名页、共享页、COW页、文件映射等），文件映射页是mmap映射的文件、加载的 ELF段，分配新的物理页（或从文件中加载页到页缓存），更新页表项，将虚拟地址映射到物理页并设置访问权限，必要时刷新TLB。所有的做完后，会返回到**报错的那条指令地址**，这次就不会报错了。

Out of memory
=============

32位的计算机，虚拟地址只有4GB，如果运行大模型等较大的程序，mmap就无法分配那么大的虚拟内存地址，所以就会触发**Out of memory**，但是64位的机器不太会发生无法分配的情况，因为能分配的虚拟内存完全可以容纳整个进程，但是由于虚拟内存远远大于物理内存，所以会不断的触发缺页异常，不断的从机械硬盘上换页，这就是程序卡顿的原因。

malloc（待补充）
===========

参考资料
====

*   [深入理解计算机系统](https://www.zhihu.com/tardis/zm/art/455061631?source_id=1005)