---
layout: post
title: '开发 MCP Proxy（代理）也可以用 Solon AI MCP 哟！'
date: "2025-04-27T00:43:17Z"
---
开发 MCP Proxy（代理）也可以用 Solon AI MCP 哟！
====================================

Java AI（智能体） 全场景应用开发框架（LLM，Function Call，RAG，Embedding，Reranking，Flow，MCP Server，Mcp Client，Mcp Proxy）。同时兼容 java8 ~ java24。也是央企信创的优选！

MCP 有三种通讯方式：

通道

说明

备注

stdio

本地进程内通讯

现有

sse http

远程 http 通讯

现有

streamable http

远程 http 通讯

（MCP 官方刚通过决定，mcp-java-sdk 还没实现）

也可以按两大类分：

*   本地进程间通讯
*   远程通讯（比如给前端用，或远程接口用）。

目前看，行业内已经积累了大最 stdio mcp-server。而且还有提供代理转换的开源项目，比如：mcpo，mcp-proxy 之类的。如果是 Java，则可以使用 solon-ai-mcp 开发类似的代理。

    <dependency>
        <groupId>org.noear</groupId>
        <artifactId>solon-ai-mcp</artifactId>
        <version>3.2.1-M3</version>
    </dependency>
    

可以借用两种配置方式（也可以手动柜构建）：

### 1、使用经典的 mcpServers 配置格式加载

这种配置格式，目前 mcp 代理很常用。stdio mcp-server 的各种项目也会提供这种配置。添加示例配置（或者找个 mcp-server 复制下），我们从 gitee 的一个项目上，复制了一份并命名为 `mcp/mcpServers.case1.json`：

    {
      "mcpServers": {
        "gitee": {
          "command": "mcp-gitee-ent",
          "env": {
            "GITEE_ENT_API_BASE": "https://api.gitee.com/enterprises",
            "GITEE_ENT_MCP_ACCESS_TOKEN": "<your mcp ent access token>",
          }
        }
      }
    }
    

solon-ai-mcp 直接提供了解析此配置格式的快捷方法。以下是创建代理服务端示例：

    @McpServerEndpoint(sseEndpoint = "/mcp/proxy/gitee")
    public class McpServerTool implements ToolProvider {
        McpClientToolProvider toolProvider = McpClientToolProvider
                    .fromMcpServers("classpath:mcp/mcpServers.case1.json")
                    .get("gitee")
    
        @Override
        public Collection<FunctionTool> getTools() {
            return toolProvider.getTools();
        }
    }
    

mcpServers 配置是支持多服务配置的，所以解析后会是个Map。在原理上，我们用 McpClientToolProvider 加载了 mcpServers，并作为工具提供给 McpServerEndpoint 输出，形成了代理效果。

### 2、使用 yaml 格式配置加载

这个规范需要参考对应 McpClientProperties 实体属性。在 app.yml 配置里添加 mcp-client 配置。

    solon.ai:
      mcp:
        client:
          gitee:  # McpClientProperties 实体属性
            channel: "stdio"
            serverParameters:
              command: "mcp-gitee-ent"
              env: 
                GITEE_ENT_API_BASE: "https://api.gitee.com/enterprises"
                GITEE_ENT_MCP_ACCESS_TOKEN: "<your mcp ent access token>"
          
    

创建代理服务端

    @McpServerEndpoint(sseEndpoint = "/mcp/proxy/gitee")
    public class McpServerTool implements ToolProvider {
        @Inject("${solon.ai.mcp.client.gitee}") //通过配置，可直接注入
        McpClientToolProvider toolProvider;  
    
        @Override
        public Collection<FunctionTool> getTools() {
            return toolProvider.getTools();
        }
    }
    

### 3、还可以反向代理

其实我们还可以把 sse mcp-server 代理成 stdio 的方式输出：

    @McpServerEndpoint(channel = McpChannel.STDIO)
    public class McpServerTool implements ToolProvider {
         McpClientToolProvider sseToolProvider = McpClientToolProvider.builder()
                .apiUrl("http://localhost:8081/mcp/sse")
                .build();
    
        @Override
        public Collection<FunctionTool> getTools() {
            return toolProvider.getTools();
        }
    }
    

打包后，就可以通过 mcpServers 配置，被其它工具使用了：

    {
      "mcpServers": {
        "demo1": {
          "command": "java",
          "args": ["-jar", "/demo-mcp-stdio/target/demo-mcp-stdio.jar"]
        }
      }
    }
    

如果是 java ，还可以使用 solon-ai-mcp 。示例：

     McpClientToolProvider mcpClient = McpClientToolProvider.builder()
                    .channel(McpChannel.STDIO) //表示使用 stdio
                    .serverParameters(McpServerParameters.builder("java")
                            .args("-jar", "/demo-mcp-stdio/target/demo-mcp-stdio.jar")
                            .build())
                    .build();
    

### 4、总结

开发 MCP Proxy（代理）也可以用 Solon AI MCP 哟！尤其是 Java 环境，我们同时支持 java8，java11，java17，java21，java24。