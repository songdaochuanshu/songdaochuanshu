---
layout: post
title: 'MySQL 20 幻读是什么，幻读有什么问题？'
date: "2025-07-23T00:45:33Z"
---
MySQL 20 幻读是什么，幻读有什么问题？
=======================

首先给出要用到的数据：

    CREATE TABLE `t` (
      `id` int(11) NOT NULL,
      `c` int(11) DEFAULT NULL,
      `d` int(11) DEFAULT NULL,
      PRIMARY KEY (`id`),
      KEY `c` (`c`)
    ) ENGINE=InnoDB;
    
    insert into t values(0,0,0),(5,5,5),
    (10,10,10),(15,15,15),(20,20,20),(25,25,25);
    

那么下面的语句，是怎么加锁的，加的锁又是什么时候释放的？

    begin;
    select * from t where d=5 for update;
    commit;
    

该语句会命中`d=5`的行，对应的主键`id=5`，因此在select语句执行完成后，`id=5`这一行会加一个写锁，且由于两阶段锁协议，该写锁会在执行commit语句时候释放。

由于字段d上没有索引，该语句会做全表扫描，那么其他被扫描到但不符合条件的记录是否会被加锁呢？

本文接下来没有特殊说明的，都是设定在可重复读隔离级别。

### 幻读是什么？

先看如果只在`id=5`的行加锁会怎么样。

假设有这样一个场景：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250721111338388-1096269899.png)

分析session A里的三次执行：

*   Q1只返回`id=5`的行；
    
*   在T2时刻，session B把`id=0`的d值改成了5，因此T3时刻Q2能返回两行；
    
*   在T4时刻，session C插入一行，因此Q3时刻查出来3行。
    

其中，Q3读到`id=1`这一行的现象，被称为**幻读**。幻读指的是一个事务前后两次查询**同一个范围**的时候，后一次查询看到了前一次查询没有看到的行。

这里对幻读做说明：

*   在可重复读隔离级别下，普通的查询是快照读，不会看到别的事务插入的数据，因此幻读只有在当前读的情况下才会出现；
    
*   session B的修改结果，被session A后的select语句用当前读看到，不能称为幻读，幻读专指新插入的行。
    

这三个查询都是加了for update，因此都是当前读，要读到所有已经提交的记录的最新值。

从事务可见性规则分析的话，这三条SQL语句的返回结果都没有问题。但是由于造成了幻读，是有其他问题的。

### 幻读有什么问题？

首先是语义上的问题。session A在T1时刻的语句实际上想要声明，要把所有`d=5`的行锁住，不允许别的事务进行读写操作。

如果现在看感觉不明显，看看如下情况：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250721111420393-601216731.png)

在session B中，先将`id=0`的行也设置了`d=5`，之后设置`c=5`。由于在T1时刻，session A只是给`id=5`的行加了行锁，并没有给`id=0`的行加锁，因此session B是可以执行这两条update语句的，这就破坏了session A在T1时刻的加锁声明。

session C也是一样，对`id=1`的行的修改也破坏了加锁声明。

其次是数据一致性的问题。锁的设计是为了保证数据的一致性，这不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。

比如如下的情况：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250721111443413-1933599849.png)

分析数据库里的变化：

*   经过T1时刻，`id=5`这一行变为(5,5,100)，这个结果在T6正式提交；
    
*   经过T2时刻，`id=0`这一行变为(0,5,5)；
    
*   经过T4时刻，表里多了一行(1,5,5)；
    
*   其他行与这个执行序列无关，保持不变。
    

而binlog里的变化：

*   T2时刻，session B事务提交，写入了两条语句；
    
*   T4时刻，session C事务提交，写入了两条语句；
    
*   T6时刻，session A事务提交，写入了`update t set d=100 where d=5`这条语句。
    

统一一下，就是：

    update t set d=5 where id=0; /*(0,0,5)*/
    update t set c=5 where id=0; /*(0,5,5)*/
    
    insert into t values(1,1,5); /*(1,1,5)*/
    update t set c=5 where id=1; /*(1,5,5)*/
    
    update t set d=100 where d=5;/*所有d=5的行，d改成100*/
    

可以看出，这个语句序列，不论是拿到备库执行，还是以后用binlog来克隆，这三行的结果都变成了(0,5,100)、(1,5,100)和(5,5,100)。

即`id=0,id=1`两行发生了数据不一致。这是假设`select * from t where d=5 for update`只给`id=5`的行加锁导致的。

所以我们认为上面的设定不合理，假设改为“扫描过程中碰到的行都加上写锁”：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250721111519108-630441720.png)

由于session A把所有的行都加了写锁，所以session B在执行第一个语句时就被锁住，需要等到T6时刻session A提交后，session B才能继续执行。这样binlog里执行序列为：

    insert into t values(1,1,5); /*(1,1,5)*/
    update t set c=5 where id=1; /*(1,5,5)*/
    
    update t set d=100 where d=5;/*所有d=5的行，d改成100*/
    
    update t set d=5 where id=0; /*(0,0,5)*/
    update t set c=5 where id=0; /*(0,5,5)*/
    

可以看到，`id=0`的行最终结果为(0,5,5)，解决了不一致，但`id=1`这一行还是不一致。这是因为在T3时刻，给所有行加锁的时候，`id=1`这一行还不存在，也就加不上锁。

也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录。

到这里，实际上已经说明了幻读的定义以及幻读有什么问题。接下来，看看InnoDB怎么解决幻读。

### 如何解决幻读？

从上面可以看出，产生幻读的原因是，行锁只能锁住行，但是新插入记录，要更新的是记录之间的“间隙”。因此为了解决幻读，InnoDB引入了间隙锁。

在本文的场景中，初始化插入了6个记录，会产生7个间隙：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250721111552669-2091404342.png)

当执行`select * from t where d=5 for update`，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁，这样就确保无法再插入新记录。

间隙锁不像行锁那样，行锁之间会有冲突，间隙锁之间不存在冲突关系，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”的操作。

比如：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250721111615842-1173325613.png)

由于表里没有`c=7`的记录，因此session A和session B都是想要加间隙锁(5,10)，都是想保护这个间隙，因此它们之间不冲突，session B不会被堵住。

间隙锁和行锁合称临键锁（next-key lock），临键锁是前开后闭的区间。在本文的例子，如果用`select * from t for update`把整个表所有记录锁起来，会形成7个临键锁，分别是\\((-\\infty,0\],(0,5\],(5,10\],(10,15\],(15,20\],(20,25\],(25,+\\text{supremun}\]\\)。

由于\\(+\\infty\\)是开区间，为了做到前开后闭，InnoDB给每个索引加了一个不存在的最大值supremum。

间隙锁和临键锁的引入，能帮助解决幻读的问题，但同时会带来另外的问题。比如下面的场景：

![](https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250721111641063-797467228.png)

分析该场景：

*   session A执行`select … for update`，由于`id=9`行不存在，会加上间隙锁(5,10)；
    
*   session B执行`select … for update`同样会加上间隙锁(5,10)；
    
*   session B想要插入(9,9,9)，被session A的间隙锁挡住，进入等待；
    
*   session A想要插入(9,9,9)，被session B的间隙锁挡住。
    

至此形成了死锁。因此间隙锁的引入，可能导致同样的语句锁住更大的范围，会影响并发度。

为了减少死锁，很多公司实际使用读已提交的隔离级别，同时将binlog格式设置成row，以解决可能出现的数据和日志不一致问题。