---
layout: post
title: 'AspNetCoreå¼€å‘ç¬”è®°ï¼šWebApié¡¹ç›®é›†æˆä¼ä¸šå¾®ä¿¡å’Œå…¬ä¼—å·'
date: "2026-01-22T00:46:24Z"
---
AspNetCoreå¼€å‘ç¬”è®°ï¼šWebApié¡¹ç›®é›†æˆä¼ä¸šå¾®ä¿¡å’Œå…¬ä¼—å·
=================================

å‰è¨€
--

å¾ˆä¹…æ²¡å†™æ–‡ç« äº†ï¼Œç°åœ¨æœ‰äº†AIï¼Œå…¶å®å·²ç»ä¸æ€ä¹ˆéœ€è¦å†™æ–‡ç« ï¼Œåæ­£ä¸æ‡‚å°±é—®AIå˜›ã€‚

ä¸è¿‡AIæ€»æ˜¯æœ‰ç›²åŒºçš„ï¼Œå°±æ¯”å¦‚å›½å†…çš„å¾®ä¿¡å¼€å‘ã€‚

å¾®ä¿¡çš„æ–‡æ¡£æ˜¯å…¬è®¤çš„çƒ‚ï¼Œè€Œä¸”ç»å¸¸æ‚„å’ªå’ªæ”¹æ¥å£åˆä¸æ›´æ–°æ–‡æ¡£ï¼Œæ‰€ä»¥AIå¯¹å¾®ä¿¡å¼€å‘çš„APIå…¶å®ä¸æ€ä¹ˆç†Ÿæ‚‰ï¼Œç»å¸¸ç»™å‡ºä¸€äº›é”™è¯¯çš„å›å¤ã€‚

æœ¬æ–‡è®°å½•ä¸€ä¸‹æœ€è¿‘æˆ‘ä½¿ç”¨ C# WebApi é¡¹ç›®æ¥å…¥ä¼ä¸šå¾®ä¿¡å’Œå…¬ä¼—å·çš„è¿‡ç¨‹ï¼Œä¸»è¦æ˜¯ç”¨åˆ°è‡ªåŠ¨å›å¤åŠŸèƒ½ã€‚

å‰ç½®å·¥ä½œ
----

### ä¾èµ–åº“

æˆ‘ç”¨åˆ°äº† **SKIT.FlurlHttpClient.Wechat** è¿™ä¸ªç³»åˆ—çš„åº“ï¼š[https://github.com/fudiwei/DotNetCore.SKIT.FlurlHttpClient.Wechat](https://github.com/fudiwei/DotNetCore.SKIT.FlurlHttpClient.Wechat)

åŸæœ¬æƒ³ç›´æ¥ç”¨ Flurl å¯¹æ¥çš„ï¼Œæ¯•ç«Ÿç°åœ¨æ‰‹é‡Œæœ‰äº†é”¤å­ï¼ˆAIï¼‰ï¼Œçœ‹å•¥éƒ½æ˜¯é’‰å­ï¼Œå•¥éƒ½æƒ³é€ è½®å­ã€‚

ä¸è¿‡æœäº†ä¸€ä¸‹æˆ‘çš„æ”¶è—å¤¹ï¼Œå‘ç°æœ‰è¿™ä¸ªé¡¹ç›®ï¼Œå°è£…äº†å¾®ä¿¡çš„å¤§éƒ¨åˆ†æ¥å£ï¼Œé‚£è¿˜è¦å•¥è‡ªè¡Œè½¦ï¼Œç›´æ¥ç”¨å°±å®Œäº‹å„¿äº†ã€‚

å…¶ä¸­ï¼š

*   ä¼ä¸šå¾®ä¿¡ï¼šSKIT.FlurlHttpClient.Wechat.Work
*   å…¬ä¼—å·ï¼šSKIT.FlurlHttpClient.Wechat.Api

### å¾®ä¿¡é…ç½®ä¿¡æ¯

éœ€è¦å‡†å¤‡è¿™äº›é…ç½®ä¿¡æ¯ï¼š

ä¼ä¸šå¾®ä¿¡ï¼š

    public class WechatWorkOptions {
        public string CorpId { get; set; } = string.Empty;
        // åº”ç”¨ID
        public int AgentId { get; set; }
        // åº”ç”¨å¯†é’¥
        public string Secret { get; set; } = string.Empty;
        // å›è°ƒ Token
        public string CallbackToken { get; set; } = string.Empty;
        // å›è°ƒ EncodingAESKey
        public string CallbackEncodingAESKey { get; set; } = string.Empty;
    }
    

å…¬ä¼—å·ï¼š

    public class WechatApiClientOptions {
        public string AppId { get; set; } = string.Empty;
        public string AppSecret { get; set; } = string.Empty;
        public string CallbackToken { get; set; } = string.Empty;
        public string CallbackEncodingAESKey { get; set; } = string.Empty;
    }
    

### æ³¨å†ŒæœåŠ¡

    // ä¼ä¸šå¾®ä¿¡
    builder.Services.AddSingleton<WechatWorkClient>(sp => {
        var options = sp.GetRequiredService<IOptions<WechatWorkOptions>>().Value;
        return WechatWorkClientBuilder.Create(options).Build();
    });
    
    // å…¬ä¼—å·
    builder.Services.AddSingleton<WechatApiClient>(sp => {
        var options = sp.GetRequiredService<IOptions<WechatMpOptions>>().Value;
        return WechatApiClientBuilder.Create(options).Build();
    });
    

å‡†å¤‡å·¥ä½œå°±æå®šäº†ã€‚

ç®¡ç†token
-------

å¾®ä¿¡çš„æ¥å£éƒ½éœ€è¦ç”¨ AccessToken æ‰èƒ½è°ƒç”¨ï¼Œä½†å¾®ä¿¡åˆä¸æƒ³å¼€å‘è€…æ¯æ¬¡éƒ½å»è¯·æ±‚è·å–tokenï¼Œæ‰€ä»¥åªèƒ½è·å–ä¸€æ¬¡ç„¶åè‡ªå·±ä¿å­˜äº†ã€‚

C# å¯ä»¥ç”¨ IMemoryCache ç»„ä»¶ï¼Œå¾ˆæ–¹ä¾¿çš„ç®¡ç†è¿™äº›ä¸´æ—¶å­˜å‚¨çš„æ•°æ®ï¼›Djangoæ¡†æ¶ä¹Ÿæœ‰å†…ç½®çš„cacheæœºåˆ¶ï¼Œå…¶ä»–è¯­è¨€æ¡†æ¶å¯ä»¥ç”¨Redisè¿™ç±»NoSQLæ•°æ®åº“æ¥å­˜å‚¨ã€‚æ‰¯è¿œäº†ï¼Œæœ¬æ–‡è¿˜æ˜¯ä»‹ç»C#çš„ã€‚

æˆ‘ç”¨ä¸€ä¸ª `WechatWorkTokenService` æœåŠ¡æ¥ç®¡ç†ä¼ä¸šå¾®ä¿¡çš„tokenï¼ˆå…¬ä¼—å·ã€å°ç¨‹åºè¿™ç§ä¹Ÿæ˜¯åŒç†ï¼‰

    public class WechatWorkTokenService(
        WechatWorkClient client,
        IMemoryCache cache,
        IOptions<WechatWorkOptions> options
    ) : IWechatWorkTokenService {
        private const string CacheKey = "WechatWorkAccessToken";
    
        // ç”¨äºå¹¶å‘æ§åˆ¶ï¼Œé˜²æ­¢ç¬é—´é«˜å¹¶å‘å¯¼è‡´å¤šæ¬¡è¯·æ±‚ Token æ¥å£
        private static readonly SemaphoreSlim Semaphore = new SemaphoreSlim(1, 1);
    
        /// <summary>
        /// è·å– AccessToken
        /// </summary>
        public async Task<string> GetAccessTokenAsync(CancellationToken cancellationToken = default) {
            // 1. å°è¯•ä»ç¼“å­˜è·å–
            if (cache.TryGetValue(CacheKey, out string? accessToken) && !string.IsNullOrEmpty(accessToken)) {
                return accessToken;
            }
    
            // 2. ç¼“å­˜æœªå‘½ä¸­ï¼ŒåŠ é”è¯·æ±‚
            await Semaphore.WaitAsync(cancellationToken);
            try {
                // åŒé‡æ£€æŸ¥ï¼Œé˜²æ­¢æ’é˜Ÿç­‰å¾…çš„çº¿ç¨‹å†æ¬¡è¯·æ±‚
                if (cache.TryGetValue(CacheKey, out accessToken) && !string.IsNullOrEmpty(accessToken)) {
                    return accessToken;
                }
    
                // 3. è°ƒç”¨æ¥å£è·å– Token
                var request = new CgibinGetTokenRequest();
                var response = await client.ExecuteCgibinGetTokenAsync(request, cancellationToken);
    
                if (!response.IsSuccessful()) {
                    throw new Exception($"è·å– AccessToken å¤±è´¥: {response.ErrorMessage} (Code: {response.ErrorCode})");
                }
    
                accessToken = response.AccessToken;
    
                // 4. è®¾ç½®ç¼“å­˜
                // æå‰ 5 åˆ†é’Ÿè¿‡æœŸï¼Œç¡®ä¿åœ¨è¿‡æœŸå‰åˆ·æ–°
                // å¦‚æœ ExpiresIn å°äº 300 ç§’ï¼Œåˆ™è®¾ä¸ºä¸€åŠæ—¶é—´
                var expirySeconds = response.ExpiresIn > 300 ? response.ExpiresIn - 300 : response.ExpiresIn / 2;
                var cacheEntryOptions = new MemoryCacheEntryOptions()
                    .SetAbsoluteExpiration(TimeSpan.FromSeconds(expirySeconds));
    
                cache.Set(CacheKey, accessToken, cacheEntryOptions);
    
                return accessToken;
            }
            finally {
                Semaphore.Release();
            }
        }
    }
    

ä¼ä¸šå¾®ä¿¡
----

ä¼ä¸šå¾®ä¿¡çš„é™åˆ¶æ¯”è¾ƒå°‘ï¼Œå¯ä»¥ä¸»åŠ¨ç»™ç”¨æˆ·å‘ä¿¡æ¯ï¼Œæ‰€ä»¥å¯ä»¥æŠŠæ¥æ”¶å’Œå‘é€ä¿¡æ¯åˆ†å¼€ï¼Œä¾‹å¦‚è°ƒç”¨LLMå¤„ç†å›å¤çš„æ—¶å€™ï¼Œä¼šæ¯”è¾ƒæ…¢ï¼Œå¯ä»¥æŠŠå›å¤æ”¾åˆ°å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—é‡Œå»å®ç°ã€‚

### éªŒè¯å›è°ƒ

ç›´æ¥ä¸Šæ¥å£ä»£ç ã€‚

åœ¨é…ç½®ä¼ä¸šå¾®ä¿¡åº”ç”¨URLçš„æ—¶å€™ï¼Œå¾®ä¿¡æœåŠ¡å™¨ä¼šå‘é€ä¸€ä¸ªGETè¯·æ±‚åˆ°é…ç½®çš„URLè¿›è¡ŒéªŒè¯ï¼Œåç«¯ç¨‹åºéœ€è¦éªŒè¯ç­¾åï¼Œè§£å¯†åæŠŠå†…å®¹å¤è¯»ç»™å¾®ä¿¡æœåŠ¡å™¨ã€‚

ä¸‹é¢è¿™ä¸ªæ¥å£å°±å®ç°äº†è¿™ä¸ªéªŒè¯æ–¹æ³•ã€‚

è¿™æ ·å®ç°ä¹‹åå¡«å†™ `https://example.com/api/wechat/work/callback` è¿™ä¸ªåœ°å€å°±å¥½äº†ã€‚

    [ApiController]
    [AllowAnonymous]
    [Route("api/wechat/work/callback")]
    public class WechatWorkController(
        WechatWorkClient client,
        IBackgroundTaskQueue queue,
        ILogger<WechatWorkController> logger
    ) : ControllerBase {
        /// <summary>
        /// å›è°ƒéªŒè¯ (GET)
        /// </summary>
        [HttpGet]
        public IActionResult Echo(
            [FromQuery(Name = "msg_signature")] string msgSignature,
            [FromQuery(Name = "timestamp")] string timestamp,
            [FromQuery(Name = "nonce")] string nonce,
            [FromQuery(Name = "echostr")] string echoStr
        ) {
            // éªŒè¯ç­¾å
            var verifyResult = client.VerifyEventSignatureForEcho(
                timestamp, nonce, echoStr, msgSignature, out string? replyEcho
            );
    
            if (verifyResult.Result) {
                logger.LogInformation("Echo verification successful. ReplyEcho: {ReplyEcho}", replyEcho);
                return Content(replyEcho ?? string.Empty);
            }
    
            logger.LogWarning("Echo verification failed. Error: {Error}", verifyResult.Error?.Message);
            return BadRequest($"Verify signature failed: {verifyResult.Error?.Message}");
        }
    }
    

### æ¥æ”¶ä¿¡æ¯

æ¥æ”¶ä¿¡æ¯å’Œä¸Šé¢çš„éªŒè¯éƒ½æ˜¯ä¸€ä¸ªURLï¼ŒåŒºåˆ«æ˜¯æ¥æ”¶ä¿¡æ¯æ—¶ï¼Œå¾®ä¿¡æœåŠ¡å™¨ä¼šå‘URLå‘POSTè¯·æ±‚ã€‚

ä»£ç é‡Œæœ‰è¯¦ç»†æ³¨é‡Šäº†ï¼Œåº”è¯¥ä¸ç”¨è§£é‡Šå¤ªå¤šã€‚

    /// <summary>
    /// æ¥æ”¶æ¶ˆæ¯ (POST)
    /// </summary>
    [HttpPost]
    public async Task<IActionResult> Callback(
        [FromQuery(Name = "msg_signature")] string msgSignature,
        [FromQuery(Name = "timestamp")] string timestamp,
        [FromQuery(Name = "nonce")] string nonce
    ) {
        // å¿…é¡»è¯»å–åŸå§‹ Request Body æµï¼Œè€Œä¸èƒ½ä½¿ç”¨ [FromBody] ç»‘å®š
        // åŸå› ï¼š
        // 1. å¾®ä¿¡ç­¾åéªŒè¯ä¾èµ–äºåŸå§‹è¯·æ±‚ä½“ï¼Œä»»ä½•ç©ºæ ¼ã€æ¢è¡Œç¬¦çš„å·®å¼‚éƒ½ä¼šå¯¼è‡´ç­¾åæ ¡éªŒå¤±è´¥
        // 2. æ¨é€å†…å®¹é€šå¸¸æ˜¯åŠ å¯†çš„ XMLï¼Œéœ€è¦å…ˆè·å–åŸå§‹å­—ç¬¦ä¸²ä¼ ç»™ SDK è¿›è¡Œè§£å¯†
        using var reader = new StreamReader(Request.Body);
        var xml = await reader.ReadToEndAsync();
    
        logger.LogDebug("Callback Body (Length: {Length}): {Xml}", xml.Length, xml);
    
        // 1. éªŒè¯ç­¾å
        // è™½ç„¶ DeserializeEventFromXml å†…éƒ¨å¯èƒ½ä¼šåŒ…å«è§£å¯†è¿‡ç¨‹ï¼Œä½†æ˜¾å¼éªŒè¯ç­¾åæ˜¯æ›´å®‰å…¨çš„åšæ³•
        var verifyResult = client.VerifyEventSignatureFromXml(timestamp, nonce, xml, msgSignature);
        if (!verifyResult.Result) {
            logger.LogWarning("Callback signature verification failed. Error: {Error}", verifyResult.Error?.Message);
            return BadRequest($"Verify signature failed: {verifyResult.Error?.Message}");
        }
    
        // 2. ä½¿ç”¨ SKIT åº“æä¾›çš„æ‰©å±•æ–¹æ³•è‡ªåŠ¨è§£å¯†å¹¶ååºåˆ—åŒ–
        // æ³¨æ„ï¼šéœ€è¦åœ¨ WechatWorkClientOptions ä¸­é…ç½® PushToken å’Œ PushEncodingAESKey
        WechatWorkEvent wechatEvent;
        try {
            wechatEvent = client.DeserializeEventFromXml(xml);
            logger.LogInformation("Callback deserialized successfully. MessageType: {MessageType}, FromUser: {FromUser}, ToUser: {ToUser}", wechatEvent.MessageType, wechatEvent.FromUserName, wechatEvent.ToUserName);
        } catch (Exception ex) {
            // ååºåˆ—åŒ–å¤±è´¥ï¼ˆé€šå¸¸æ˜¯å› ä¸ºç­¾åéªŒè¯å¤±è´¥æˆ–è§£å¯†å¤±è´¥ï¼‰
            logger.LogError(ex, "Callback deserialization failed.");
            return BadRequest($"Deserialization failed: {ex.Message}");
        }
    
        // å¤„ç†é€»è¾‘
        if (string.Equals(wechatEvent.MessageType, "TEXT", StringComparison.OrdinalIgnoreCase)) {
            // å†æ¬¡ååºåˆ—åŒ–ä¸ºå…·ä½“çš„æ–‡æœ¬æ¶ˆæ¯äº‹ä»¶ä»¥è·å– Content
            var textEvent = client.DeserializeEventFromXml<TextMessageEvent>(xml);
            if (textEvent != null && !string.IsNullOrEmpty(textEvent.Content) &&
                !string.IsNullOrEmpty(textEvent.FromUserName)) {
                logger.LogInformation("Processing TEXT message from {FromUser}: {Content}", textEvent.FromUserName, textEvent.Content);
                await ProcessTextMessageAsync(textEvent.FromUserName, textEvent.Content);
            }
        }
        else if (string.Equals(wechatEvent.MessageType, "IMAGE", StringComparison.OrdinalIgnoreCase)) {
            var imageEvent = client.DeserializeEventFromXml<ImageMessageEvent>(xml);
            if (imageEvent != null && !string.IsNullOrEmpty(imageEvent.MediaId) &&
                !string.IsNullOrEmpty(imageEvent.FromUserName)) {
                logger.LogInformation("Processing IMAGE message from {FromUser}: {MediaId}", imageEvent.FromUserName, imageEvent.MediaId);
                await ProcessImageMessageAsync(imageEvent.FromUserName, imageEvent.MediaId);
            }
        }
        else {
            logger.LogInformation("Ignored message type: {MessageType}", wechatEvent.MessageType);
        }
    
        return Ok("success");
    }
    
    

### å¼‚æ­¥å¤„ç†ä¿¡æ¯

å› ä¸ºä¼ä¸šå¾®ä¿¡å¯ä»¥ä¸»åŠ¨ç»™ç”¨æˆ·å‘ä¿¡æ¯ï¼Œæ‰€ä»¥å¯ä»¥æŠŠæ¥æ”¶å’Œå‘é€ä¿¡æ¯åˆ†å¼€ï¼Œä¾‹å¦‚è°ƒç”¨LLMå¤„ç†å›å¤çš„æ—¶å€™ï¼Œä¼šæ¯”è¾ƒæ…¢ï¼Œå¯ä»¥æŠŠå›å¤æ”¾åˆ°å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—é‡Œå»å®ç°ã€‚

#### æ–‡æœ¬ä¿¡æ¯

çº¯æ–‡æœ¬å¤„ç†èµ·æ¥è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ã€‚

    /// <summary>
    /// å¼‚æ­¥å¤„ç†æ–‡æœ¬æ¶ˆæ¯
    /// </summary>
    private async Task ProcessTextMessageAsync(string toUser, string content) {
        await queue.QueueBackgroundWorkItemAsync(async (serviceProvider, token) => {
            // åœ¨åå°ä»»åŠ¡ä¸­è§£æ Scoped æœåŠ¡
            var chatBot = serviceProvider.GetRequiredService<IChatBotService>();
            var logger = serviceProvider.GetRequiredService<ILogger<WechatWorkController>>();
    
            try {
                logger.LogInformation("Processing background task for user {ToUser}", toUser);
    
                // 1. è°ƒç”¨ ChatBot è·å–å›å¤
                string reply = await chatBot.ProcessMessageAsync(content);
    
                // 2. å‘é€å›å¤
                var accessToken = await _tokenService.GetAccessTokenAsync();
                var request = new CgibinMessageSendRequest {
                    AccessToken = accessToken,
                    AgentId = _agentId,
                    ToUserIdList = [toUser],
                    MessageType = "text",
                    MessageContentAsText = new CgibinMessageSendRequest.Types.TextMessage {
                        Content = content
                    }
                };
                var response = await _client.ExecuteCgibinMessageSendAsync(request);
                if (!response.IsSuccessful()){
                    throw new Exception($"å‘é€ä¼ä¸šå¾®ä¿¡æ¶ˆæ¯å¤±è´¥: {response.ErrorMessage} (Code: {response.ErrorCode})");
                }
    
                logger.LogInformation("Reply sent to {ToUser}: {ReplyContent}", toUser, reply);
            } catch (Exception ex) {
                logger.LogError(ex, "Failed to process message for {ToUser}", toUser);
            }
        });
    }
    

#### å›¾ç‰‡ä¿¡æ¯

å›¾ç‰‡éº»çƒ¦ä¸€ç‚¹ï¼Œå¾®ä¿¡ä¸ä¼šç›´æ¥æŠŠå›¾ç‰‡æ•°æ®å‘æ¥ï¼Œè€Œæ˜¯æäº†ä¸ª mediaIdï¼Œè¦æˆ‘ä»¬æ‰‹åŠ¨å»ä¸‹è½½ã€‚

C# è¿™é‡Œè¿˜æ˜¯æ–¹ä¾¿çš„ï¼Œç›´æ¥æŠŠå›¾ç‰‡ä¸‹è½½æ”¾åˆ°å†…å­˜é‡Œäº¤ç»™ç¬¬ä¸‰æ–¹æœåŠ¡å¤„ç†ï¼ˆå¦‚OCRï¼‰ï¼Œç„¶åå†æŠŠç»“æœå‘å‡ºæ¥ã€‚

    /// <summary>
    /// å¼‚æ­¥å¤„ç†å›¾ç‰‡æ¶ˆæ¯
    /// </summary>
    private async Task ProcessImageMessageAsync(string toUser, string mediaId) {
        await queue.QueueBackgroundWorkItemAsync(async (serviceProvider, token) => {
            var chatBot = serviceProvider.GetRequiredService<IChatBotService>();
            var wechatService = serviceProvider.GetRequiredService<IWechatWorkService>();
            var tokenService = serviceProvider.GetRequiredService<IWechatWorkTokenService>();
            var logger = serviceProvider.GetRequiredService<ILogger<WechatWorkController>>();
            var wechatClient = serviceProvider.GetRequiredService<WechatWorkClient>();
    
            try {
                logger.LogInformation("Processing background image task for user {ToUser}", toUser);
    
                // 1. Download Image
                var accessToken = await tokenService.GetAccessTokenAsync(token);
                var request = new CgibinMediaGetRequest {
                    AccessToken = accessToken,
                    MediaId = mediaId
                };
                var resp = await wechatClient.ExecuteCgibinMediaGetAsync(request, cancellationToken: token);
    
                if (!resp.IsSuccessful()) {
                    logger.LogError("Failed to download image: {Error}", resp.ErrorMessage);
                    await wechatService.SendTextMessageAsync(toUser, "æŠ±æ­‰ï¼Œæ— æ³•è·å–å›¾ç‰‡å†…å®¹ã€‚");
                    return;
                }
    
                var bytes = resp.GetRawBytes();
                var mimeType = "image/jpeg";
                if (bytes.Length > 0 && bytes[0] == 0x89 && bytes[1] == 0x50 && bytes[2] == 0x4E && bytes[3] == 0x47) {
                    mimeType = "image/png";
                }
    
                var items = new ChatMessageContentItemCollection {
                    new ImageContent(bytes, mimeType)
                };
    
                // 2. Call ChatBot
                var chatMessage = new ChatMessageContent(AuthorRole.User, items);
                var reply = await chatBot.ProcessMessageAsync(chatMessage);
    
                // 3. Send Reply
                await wechatService.SendTextMessageAsync(toUser, reply);
    
                logger.LogInformation("Reply sent to {ToUser}", toUser);
            } catch (Exception ex) {
                logger.LogError(ex, "Failed to process image message for {ToUser}", toUser);
            }
        });
    }
    

å…¬ä¼—å·
---

å¥½ï¼Œä¼ä¸šå¾®ä¿¡æå®šäº†ã€‚æ¥ä¸‹æ¥çœ‹çœ‹å…¬ä¼—å·ã€‚

å…¬ä¼—å·å’Œä¼ä¸šå¾®ä¿¡ä¸ä¸€æ ·ï¼Œæ— æ³•ä¸»åŠ¨å‘ä¿¡æ¯ï¼Œæ‰€ä»¥åœ¨æ”¶åˆ°ç”¨æˆ·ä¿¡æ¯æ—¶ï¼Œè¦è¿”å›XMLæ ¼å¼çš„ç›¸åº”ï¼Œä½œä¸ºå›å¤å†…å®¹ï¼Œ5ç§’å†…å¿…é¡»å›å¤ã€‚

éªŒè¯å›è°ƒè¿™é‡Œå°±ä¸é‡å¤äº†ï¼Œå’Œä¼ä¸šå¾®ä¿¡æ˜¯ä¸€æ ·çš„ã€‚

    /// <summary>
    /// æ¥æ”¶æ¶ˆæ¯ (POST)
    /// </summary>
    [HttpPost]
    public async Task<IActionResult> Callback(
        [FromQuery(Name = "msg_signature")] string? msgSignature,
        [FromQuery(Name = "signature")] string? signature,
        [FromQuery(Name = "timestamp")] string timestamp,
        [FromQuery(Name = "nonce")] string nonce,
        [FromQuery(Name = "encrypt_type")] string? encryptType
    ) {
        using var reader = new StreamReader(Request.Body);
        var xml = await reader.ReadToEndAsync();
    
        _logger.LogDebug("Callback Body (Length: {Length}): {Xml}", xml.Length, xml);
    
        // 1. éªŒè¯ç­¾å
        // å¦‚æœæ˜¯å®‰å…¨æ¨¡å¼ (encryptType == "aes")ï¼Œä½¿ç”¨ VerifyEventSignatureFromXml (éœ€è¦ msg_signature)
        // å¦‚æœæ˜¯æ˜æ–‡æ¨¡å¼ï¼ŒSDK å†…éƒ¨ DeserializeEventFromXml ä¹Ÿä¼šåšä¸€äº›æ ¡éªŒï¼Œä½†é€šå¸¸æ˜æ–‡æ¨¡å¼ç­¾åæ ¡éªŒä½¿ç”¨ signature (VerifyEventSignatureForEcho logic)
        // è¿™é‡Œä¸»è¦å¤„ç†å®‰å…¨æ¨¡å¼ï¼Œå› ä¸ºæ˜æ–‡æ¨¡å¼ä¸‹é€šå¸¸ä¸éœ€è¦å¤æ‚çš„è§£å¯†éªŒè¯
        if (string.Equals(encryptType, "aes", StringComparison.OrdinalIgnoreCase)) {
            if (string.IsNullOrEmpty(msgSignature)) {
                return BadRequest("msg_signature is required for aes encryption");
            }
    
            var verifyResult = _client.VerifyEventSignatureFromXml(timestamp, nonce, xml, msgSignature);
            if (!verifyResult.Result) {
                _logger.LogWarning("Callback signature verification failed. Error: {Error}", verifyResult.Error?.Message);
                return BadRequest($"Verify signature failed: {verifyResult.Error?.Message}");
            }
        }
        else {
            // æ˜æ–‡æ¨¡å¼ï¼Œå¯ä»¥ä½¿ç”¨ signature éªŒè¯ (å¯é€‰)
            // var verifyResult = _client.VerifyEventSignatureForEcho(timestamp, nonce, signature);
        }
    
        // 2. ä½¿ç”¨ SKIT åº“è‡ªåŠ¨è§£å¯†å¹¶ååºåˆ—åŒ–
        WechatApiEvent wechatEvent;
        try {
            wechatEvent = _client.DeserializeEventFromXml(xml);
            _logger.LogInformation("Callback deserialized successfully. MessageType: {MessageType}, FromUser: {FromUser}, ToUser: {ToUser}",
                                   wechatEvent.MessageType, wechatEvent.FromUserName, wechatEvent.ToUserName);
        } catch (Exception ex) {
            _logger.LogError(ex, "Callback deserialization failed.");
            return BadRequest($"Deserialization failed: {ex.Message}");
        }
    
        switch (wechatEvent.MessageType?.ToLower()) {
            case "text":
                var textEvent = _client.DeserializeEventFromXml<TextMessageEvent>(xml);
                if (!string.IsNullOrEmpty(textEvent.Content) &&
                    !string.IsNullOrEmpty(textEvent.FromUserName)) {
                    _logger.LogInformation("Processing TEXT message from {FromUser}: {Content}", textEvent.FromUserName, textEvent.Content);
    
                    var isSafetyMode = string.Equals(encryptType, "aes", StringComparison.OrdinalIgnoreCase);
    
                    var textReply = new TextMessageReply {
                        ToUserName = textEvent.FromUserName,
                        FromUserName = textEvent.ToUserName,
                        MessageType = "text",
                        Content = "è¿™é‡Œæ˜¯å›å¤ç»™ç”¨æˆ·çš„å†…å®¹",
                        CreateTimestamp = DateTimeOffset.Now.ToUnixTimeSeconds()
                    };
    
                    var replyXml = _client.SerializeEventToXml(textReply, isSafetyMode);
                    return Content(replyXml, "application/xml");
                }
                break;
    
            default:
                _logger.LogInformation("Ignored message type: {MessageType}", wechatEvent.MessageType);
                break;
        }
    
        return Ok("success");
    }
    

å¯ä»¥çœ‹åˆ°ä»£ç é‡Œåˆ¤æ–­æ˜¯ text ç±»å‹åï¼Œæ„é€ äº† TextMessageReply ç±»å‹çš„æ•°æ®ï¼Œç„¶åè°ƒç”¨ SKIT.FlurlHttpClient.Wechat åº“æä¾›çš„ XML åºåˆ—åŒ–æ–¹æ³•ã€‚

è¿™ä¸ªåº“å°è£…äº†ç›´æ¥åºåˆ—åŒ–è¢«åŠ¨å›å¤äº‹ä»¶çš„æ‰©å±•æ–¹æ³•ï¼Œé»˜è®¤ä¼šåºåˆ—åŒ–ä¸ºå®‰å…¨æ¨¡å¼ã€‚

æ¥å…¥ç™»å½•
----

å¾®ä¿¡ç™»å½•å’Œå¤§éƒ¨åˆ†ç¬¬ä¸‰æ–¹å•ç‚¹è®¤è¯æµç¨‹å·®ä¸å¤šï¼Œå·²ç»å†™è¿‡å¥½å¤šæ¬¡äº†ã€‚

ä¸å†èµ˜è¿°è¿™ä¸ªæµç¨‹ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥çœ‹è¿™ç¯‡æ–‡ç« : [Django+Taroé¡¹ç›®å®ç°ä¼ä¸šå¾®ä¿¡ç™»å½•](https://blog.deali.cn/p/django-taro-wechat-work-login)

æœ¬æ¬¡æˆ‘æ²¡æœ‰æ¥å…¥ç™»å½•ï¼Œè€Œæ˜¯ç”¨äº†å¦ä¸€ç§æ–¹å¼å®ç°å¾®ä¿¡å’Œå¹³å°ç”¨æˆ·çš„å…³è”ï¼Œå°±æ˜¯å¹³å°ä¸Šç”Ÿæˆä¸€ä¸ªkeyï¼Œè®©ç”¨æˆ·åœ¨å¾®ä¿¡å‘é€ï¼Œæ„Ÿè§‰è¿˜æŒºæœ‰æ„æ€çš„ï¼Œå¦è¾Ÿè¹Šå¾„ã€‚

æ‰€ä»¥è¿™é‡Œæ¬è¿ä¸€ä¸‹æˆ‘ä¹‹å‰åšçš„å•ç‚¹è®¤è¯é¡¹ç›®é‡Œçš„ä»£ç å§ï¼Œè¯¦æƒ…å¯ä»¥çœ‹è¿™ç¯‡æ–‡ç« : [IdentityServerLiteé¡¹ç›®å’Œè¿‘æœŸçš„å¼€æºè®¡åˆ’](https://blog.deali.cn/p/almost-abandoned-project-open-source)

    /// <summary>
    /// ä¼ä¸šå¾®ä¿¡ç™»å½• - ä½¿ç”¨å›è°ƒçš„ code ç™»å½•
    /// </summary>
    /// <param name="code"></param>
    /// <param name="state">ä¸€äº›è®©å¾®ä¿¡è½¬å‘ä¼ ç»™åç«¯çš„å‚æ•°ï¼Œè¿™é‡Œæ˜¯å•ç‚¹è®¤è¯é¡¹ç›®çš„session_id</param>
    [HttpGet("wecom/login")]
    public async Task<IActionResult> WecomLogin(string code, string? state = null) {
        logger.LogInformation("ä¼ä¸šå¾®ä¿¡ç™»å½•ï¼Œcode: {code}, state: {state}, crop: {cropTag}", code, state, cropTag);
    
        if (string.IsNullOrWhiteSpace(state)) {
            return BadRequest(new ApiResponse { Message = "ä¼ä¸šå¾®ä¿¡ç™»å½•çš„ state ä¸ºç©ºï¼Œæ— æ³•è·å– session" });
        }
    
        var session = await authService.GetSession(state);
        if (session == null) {
            return NotFound(new ApiResponse { Message = $"session {state} ä¸å­˜åœ¨ï¼" });
        }
    
        var userInfo = await wecomService.GetUserInfo(code);
        if (userInfo == null) {
            return BadRequest(new ApiResponse { Message = "è·å– userinfo é”™è¯¯ï¼" });
        }
    
        if (userInfo.Errcode != 0) {
            return BadRequest(new ApiResponse { Message = $"è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥ï¼Œä¼å¾®é”™è¯¯ä¿¡æ¯: {userInfo.Errmsg}" });
        }
    
        var wechatUser = await wecomService.GetUser(userInfo.Userid);
        if (wechatUser == null) {
            return BadRequest(new ApiResponse { Message = "è·å– user é”™è¯¯ï¼" });
        }
    
        var user = await userRepo.Where(a => a.PhoneNumber == wechatUser.Userid).FirstAsync();
        // ç”¨æˆ·ä¸å­˜åœ¨çš„è¯ï¼Œè‡ªåŠ¨åˆ›å»ºç”¨æˆ·
        if (user == null) {
            user = await accountService.CreateUser(
                await accountService.GenerateUsername(wechatUser.Name),
                wechatUser.Userid,
                wechatUser.Name
            );
    
            logger.LogInformation("ç”¨æˆ· {Phone} ä¸å­˜åœ¨ï¼Œå·²åˆ›å»ºæ–°ç”¨æˆ· {UserId}", 
                                  wechatUser.Userid, user.Id);
            // return NotFound(new ApiResponse { Message = $"ç”¨æˆ· {wechatUser.Userid} ä¸å­˜åœ¨ï¼" });
        }
    
        try {
            var url = await authService.LoginSessionAndGetUri(session, user, true);
            logger.LogInformation("ä¼ä¸šå¾®ä¿¡ç™»å½•æˆåŠŸï¼Œè·³è½¬åˆ°é“¾æ¥: {url}", url);
            return Redirect(url);
        }
        catch (Exception ex) {
            ex.ToExceptionless().Submit();
            return Problem($"ä¼ä¸šå¾®ä¿¡ç™»å½•å¤±è´¥: LoginSessionAndGetUri å¤±è´¥ - {ex.Message}");
        }
    }
    

å°ç»“
--

å¤§æ¦‚å°±æ˜¯è¿™äº›äº†ï¼Œå¾ˆç¹çï¼Œä¸è¿‡è¿˜æŒºå¥½ç”¨çš„ï¼Œè¿™äº›ä»£ç å†™å®Œåå‡ ä¹æ˜¯ä¸€æ¬¡å°±å¯¹æ¥é€šè¿‡ï¼Œæƒ³èµ·æ¥ä»¥å‰åå¤è°ƒè¯•çš„ç»å†ï¼Œæ„Ÿå¹ï¼šæ—¥å­ä¹Ÿæ˜¯å¥½èµ·æ¥äº†å‘€ï¼ğŸ˜„

å¦ä¸€ç‚¹æ„Ÿå¹ï¼šSemantic KernelçœŸå¥½ç”¨ï¼Œæˆ‘ç”¨äº†å¤ªä¹…langchainï¼Œåº”è¯¥æ—©ç‚¹ä¸Šsemantic kernelçš„ã€‚

å¾®ä¿¡å…¬ä¼—å·ï¼šã€Œç¨‹åºè®¾è®¡å®éªŒå®¤ã€ ä¸“æ³¨äºäº’è”ç½‘çƒ­é—¨æ–°æŠ€æœ¯æ¢ç´¢ä¸å›¢é˜Ÿæ•æ·å¼€å‘å®è·µï¼ŒåŒ…æ‹¬æ¶æ„è®¾è®¡ã€æœºå™¨å­¦ä¹ ä¸æ•°æ®åˆ†æç®—æ³•ã€ç§»åŠ¨ç«¯å¼€å‘ã€Linuxã€Webå‰åç«¯å¼€å‘ç­‰ï¼Œæ¬¢è¿ä¸€èµ·æ¢è®¨æŠ€æœ¯ï¼Œåˆ†äº«å­¦ä¹ å®è·µç»éªŒã€‚