---
layout: post
title: '【Spring三级缓存解密】如何优雅解决循环依赖难题'
date: "2025-07-20T00:51:01Z"
---
【Spring三级缓存解密】如何优雅解决循环依赖难题
==========================

引言
--

在Spring框架的日常开发中，循环依赖问题如同一个幽灵，时不时困扰着开发者。当Bean A依赖Bean B，而Bean B又依赖Bean A时，传统的创建流程会陷入死锁。本文将深入剖析Spring如何通过三级缓存机制破解这一难题，揭示其背后的设计智慧。

一、循环依赖的本质问题
-----------

循环依赖的根源在于对象创建的**顺序性矛盾**：

    @Component
    public class ServiceA {
        @Autowired
        private ServiceB serviceB; // 需要ServiceB实例
    }
    
    @Component
    public class ServiceB {
        @Autowired
        private ServiceA serviceA; // 需要ServiceA实例
    }
    

这种"鸡生蛋还是蛋生鸡"的问题，传统创建流程无法解决。

二、三级缓存机制全景解析
------------

Spring通过三级缓存架构破解循环依赖：

classDiagram class DefaultSingletonBeanRegistry { -singletonObjects: Map~String, Object~ // 一级缓存：成品Bean -earlySingletonObjects: Map~String, Object~ // 二级缓存：半成品（早期引用） -singletonFactories: Map~String, ObjectFactory~ // 三级缓存：对象工厂 }

### 各级缓存的核心职责

缓存级别

存储内容

生命周期

作用

一级缓存

完全初始化的Bean

应用生命周期

提供最终产品

二级缓存

早期引用（半成品）

被依赖→初始化完成

临时周转

三级缓存

ObjectFactory对象

实例化→被依赖/初始化完成

延迟生成早期引用

三、破解循环依赖的全流程
------------

以经典的A→B→A依赖链为例：

sequenceDiagram participant C as 容器 participant L3 as 三级缓存 participant L2 as 二级缓存 participant A as BeanA participant B as BeanB Note over C: 创建BeanA C->>A: 1. 实例化(分配内存) C->>L3: 2. 添加ObjectFactory\_A C->>A: 3. 属性注入(发现需要B) Note over C: 转向创建B C->>B: 4. 实例化 C->>L3: 5. 添加ObjectFactory\_B C->>B: 6. 属性注入(发现需要A) B->>L3: 7. 请求获取A L3->>L3: 8. 调用ObjectFactory\_A.getObject() L3->>L3: 9. 执行getEarlyBeanReference() alt 需要代理 L3->>L3: 10. 创建代理对象Proxy\_A else 无需代理 L3->>L3: 10. 保留原始对象 end L3->>L2: 11. 存入早期引用 L3->>L3: 12. 移除ObjectFactory\_A L3->>B: 13. 返回A的早期引用 C->>B: 14. 完成B的初始化 C->>L1: 15. B成品放入一级缓存 C->>L3: 16. 移除ObjectFactory\_B C->>A: 17. 注入B(已就绪) C->>A: 18. 完成A初始化 C->>L1: 19. A成品放入一级缓存 C->>L2: 20. 移除A的早期引用

### 关键步骤解析

1.  **三级缓存注册**（步骤2/5）：
    
        // 实例化后立即注册
        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, bean));
        
    
2.  **早期引用生成**（步骤9-11）：
    
        protected Object getEarlyBeanReference(String beanName, Object bean) {
            for (BeanPostProcessor bp : getBeanPostProcessors()) {
                if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                    // 动态决策是否创建代理
                    bean = ((SmartInstantiationAwareBeanPostProcessor) bp)
                               .getEarlyBeanReference(bean, beanName);
                }
            }
            return bean;
        }
        
    
3.  **缓存状态转移**（步骤12/16/20）：
    
    *   被依赖后从三级缓存删除
    *   初始化完成后从二级缓存删除
    *   最终成品存于一级缓存

四、三级缓存的设计精妙之处
-------------

### 1\. 双重延迟决策机制

    public Object getEarlyBeanReference() {
        // 延迟点1：只在被依赖时触发
        // 延迟点2：动态决定是否创建代理
        return (needsProxy ? createProxy(bean) : bean); 
    }
    

**优势**：避免为不需要代理或未发生循环依赖的Bean创建额外对象

### 2\. 状态完整性保障

graph TD A\[属性注入完成\] --> B\[创建早期引用\] B --> C\[代理可安全使用属性值\]

当创建代理时，Bean已通过`populateBean()`完成属性注入，避免NPE风险

### 3\. 对象版本统一性

    // 最终代理一致性保证
    public void initializeBean() {
        if (earlyProxyReference != null) {
            return earlyProxyReference; // 复用已创建的代理
        }
        return createProxy(bean); // 无循环依赖时创建
    }
    

### 4\. 资源高效利用

场景

传统方案

三级缓存方案

性能提升

无循环依赖

创建所有代理

不创建代理

节省90%内存

有循环依赖无代理

创建半成品副本

直接使用原始对象

减少对象创建

有循环依赖需代理

可能创建多个代理

单例代理

避免代理冲突

五、疑难场景解决方案
----------

### 1\. 代理对象循环依赖

    @Service
    public class UserService {
        @Autowired 
        private OrderService orderService;
        
        @Transactional // 需要代理
        public void createUser() {...}
    }
    

**解决方案**：

*   在`getEarlyBeanReference()`中创建代理
*   保证代理对象基于完成属性注入的状态

### 2\. 多级循环依赖

A→B→C→A依赖链：

graph LR A-->B B-->C C-->A

**处理流程**：

1.  C获取A时触发三级缓存
2.  返回A的早期引用
3.  C完成初始化
4.  B获得C的引用
5.  A最终获得B的引用

### 3\. 无法解决的场景

场景

原因

构造器循环依赖

对象未实例化完成，无法暴露引用

原型(Prototype)作用域

Spring不缓存原型Bean

@Async方法

代理生成时机与标准AOP不同

六、性能优化建议
--------

1.  **避免循环依赖**：重构设计，引入事件机制
    
        // 使用事件解耦
        applicationContext.publishEvent(new UserCreatedEvent(user));
        
    
2.  **懒加载优化**：
    
        @Lazy
        @Autowired
        private HeavyService heavyService; // 延迟初始化
        
    
3.  **作用域控制**：
    
        @Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
        public class RequestScopedBean {...}
        
    

结论
--

Spring的三级缓存机制通过以下创新设计解决循环依赖：

1.  **空间换时间**：通过三级缓存状态管理打破创建顺序限制
2.  **延迟决策**：在被依赖时才决定是否创建代理
3.  **状态保障**：确保代理对象基于完整初始化状态
4.  **资源优化**：避免不必要的对象创建

理解三级缓存不仅帮助解决循环依赖异常，更是深入掌握Spring框架设计思想的钥匙。正如Spring框架创始人Rod Johnson所说："好的框架设计是在约束与灵活性之间找到完美平衡"，三级缓存正是这种平衡的艺术体现。