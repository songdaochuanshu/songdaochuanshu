---
layout: post
title: 'CMake构建学习笔记20-iconv库的构建'
date: "2025-08-27T00:40:24Z"
---
CMake构建学习笔记20-iconv库的构建
=======================

介绍了如何通过vcpkg在Windows下为MSVC环境构建跨平台的iconv库，并结合CMake项目实现UTF-8与GBK编码字符串的转换。

1\. 构建
======

iconv是一个用于在不同字符编码（如 UTF-8、GBK、ISO-8859-1 等）之间进行转换的开源库。笔者在[《c++中utf8字符串和gbk字符串的转换》](https://charlee44.com/post.html?id=df7a7e2f556b4c7a9724ddbe1195069c)这篇文章中介绍过如何在Windows下实现utf8字符串和gbk字符串的转换，不过该实现是基于Win32 API的，在其他平台中是无法使用的。如果需要跨平台，那么就需要使用iconv这样的库来统一实现。

不过麻烦的是iconv是GNU/Linux项目提供的库，不提供CMake的构建方式，以及原生的MSCV的构建方式。在Windows下的构建官方推荐使用MSYS2来进行构建。不过MSYS2构建出来的成果不一定能与MSVC构建的成果二进制兼容，而在Windows下还是使用MSVC的情况比较多。所以这就有点僵住了，只能寻求第三方的帮助。

这里笔者的解决方案是直接使用vcpkg。vcpkg是微软开发的C/C++跨平台开源库管理工具，试用了一下，感觉确实比以前进步很多，如果不是像笔者一样有自己的需求，完全可以都使用vcpkg来安装依赖库。

通过以下指令下载并安装iconv：

    git clone https://github.com/microsoft/vcpkg
    cd vcpkg
    .\bootstrap-vcpkg.bat
    .\vcpkg install libiconv:x64-windows
    

iconv就会安装在vcpkg的目录下，如下图所示：  

iconv是个底层库，不需要其他依赖库，因此可以直接复制到笔者的仓库中使用，算是满足了笔者的需求。另外，不知道vcpkg的机制是什么，vcpkg确实也使用了cmake来构建，因为生成了cmake的配置文件，可以直接被CMake项目集成使用。最后，默认情况下vcpkg会检测环境内的VS，使用最高版本的VS来编译链接，构建的时候要保证与目标版本一致。

2\. 示例
======

最后就直接给一个CMake项目调用刚才安装好的iconv库的示例吧。因为vcpkg在安装iconv的时候，也安装了相应的cmake的配置文件，所以可以直接在CMakeLists.txt集成，关键配置代码是：

    # 项目代码设置为utf-8编码
    if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
        message(">> using Clang")
    elseif ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
        message(">> using GCC")
    elseif ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel")
        message(">> using Intel C++")
    elseif ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "MSVC")
        message(">> using Visual Studio C++")
        add_compile_options("/utf-8")
    else()
        message(">> unknow compiler.")
    endif()
    
    find_package(Iconv REQUIRED)
    
    # ...
    
    target_link_libraries(${PROJECT_NAME} PRIVATE Iconv::Iconv)
    

注意，`find_package`要生效，需要保证CMake能够搜索到相应的库。如果是直接使用的vcpkg，那么需要将vcpkg集成到CMake搜索路径中：

    vcpkg integrate install
    

如果是像笔者一样，是将iconv复制到自己仓库中使用，那么需要在CMake的内置变量CMAKE\_PREFIX\_PATH中增加自己的仓库路径（比如修改CMakePresets.json文件中CMAKE\_PREFIX\_PATH的配置）。

将utf8编码字符串转换成gbk字符串的代码示例如下：

    #include <iconv.h>
    
    using namespace std;
    
    int main() {
      // 原始 UTF-8 字符串
      const char *utf8_str = "你好，世界！";
    
      printf("%s\n", utf8_str);
    
      size_t in_bytes_left = strlen(utf8_str);
      char in_buf[1024];
      strcpy(in_buf, utf8_str);
      char *in_ptr = in_buf;
    
      // 输出缓冲区（GBK）
      char out_buf[1024];
      char *out_ptr = out_buf;
      size_t out_bytes_left = sizeof(out_buf);
    
      // 打开 iconv 转换器：从 UTF-8 转换到 GBK
      iconv_t cd = iconv_open("GBK", "UTF-8");
      if (cd == (iconv_t)-1) {
        perror("iconv_open failed");
        return 1;
      }
    
      // 执行转换
      if (iconv(cd, &in_ptr, &in_bytes_left, &out_ptr, &out_bytes_left) ==
          (size_t)(-1)) {
        perror("iconv failed");
        iconv_close(cd);
        return 1;
      }
    
      // 关闭转换器
      iconv_close(cd);
    
      // 获取实际转换后的长度
      size_t converted_len = sizeof(out_buf) - out_bytes_left;
    
      // 直接写入二进制字节到 stdout（不经过 printf，防止转码）
      fwrite(out_buf, 1, converted_len, stdout);
    
      return 0;
    }
    

运行结果如下所示：

    浣犲ソ锛屼笘鐣岋紒
    你好，世界！