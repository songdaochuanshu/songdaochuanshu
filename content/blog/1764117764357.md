---
layout: post
title: 'ä½¿ç”¨.NETå¼€å‘å¹¶ä¸Šçº¿ä¸€ä¸ªå°æ™ºAIå¯¹è¯æœºå™¨äººçš„MCPæœåŠ¡è½¬æ¥å¹³å°'
date: "2025-11-26T00:42:44Z"
---
ä½¿ç”¨.NETå¼€å‘å¹¶ä¸Šçº¿ä¸€ä¸ªå°æ™ºAIå¯¹è¯æœºå™¨äººçš„MCPæœåŠ¡è½¬æ¥å¹³å°
================================

å‰è¨€
--

æœ€è¿‘å°æ™ºAIå¯¹è¯æœºå™¨äººåœ¨ESP32ç¤¾åŒºå®åœ¨æ˜¯å¤ªç«äº†,çœ‹è¿‡ä¹‹å‰æ–‡ç« çš„å°ä¼™ä¼´åº”è¯¥éƒ½çŸ¥é“ä¹‹å‰æœ‰ç»™æ¡Œé¢æœºå™¨äººå¼€å‘è¿‡ä¸€ä¸ª.NETå®¢æˆ·ç«¯,æ‰€ä»¥å¯¹å°æ™ºä¹Ÿç®—æ˜¯æ¯”è¾ƒç†Ÿæ‚‰ã€‚å°æ™ºè™½ç„¶æ”¯æŒMCP(Model Context Protocol)åè®®æ¥æ‰©å±•åŠŸèƒ½,ä½†æ˜¯å°æ™ºçš„MCPç«¯ç‚¹æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„WebSocketæœåŠ¡,å¦‚æœæƒ³è¦ä¸ºå°æ™ºå¼€å‘MCPåŠŸèƒ½,å°±éœ€è¦é’ˆå¯¹è¿™ä¸ªç‰¹æ®Šçš„ç«¯ç‚¹è¿›è¡Œå¼€å‘ã€‚

äºæ˜¯å°±æƒ³ç€èƒ½ä¸èƒ½åšä¸€ä¸ªè½¬æ¥å¹³å°,è®©å¼€å‘è€…å¯ä»¥ä¸“æ³¨äºæ ‡å‡†MCPæœåŠ¡çš„å¼€å‘,è€Œä¸ç”¨å…³å¿ƒå°æ™ºç‰¹æ®Šçš„WebSocketåè®®ç»†èŠ‚ã€‚è¿™ä¸ªå¹³å°å¯ä»¥å°†æ ‡å‡†çš„MCPæœåŠ¡èšåˆåé€šè¿‡WebSocketæä¾›ç»™å°æ™º,åŒæ—¶æ”¯æŒå¤šç§Ÿæˆ·,æ¯ä¸ªç”¨æˆ·éƒ½å¯ä»¥é…ç½®è‡ªå·±ä¸“å±çš„MCPæœåŠ¡ã€‚

é¡¹ç›®å·²ç»ä¸Šçº¿å¹¶å¼€æºäº†,å¤§å®¶å¯ä»¥ç›´æ¥è®¿é—® [https://xiaozhi.verdure-hiro.cn](https://xiaozhi.verdure-hiro.cn/) ä½“éªŒ,ä¹Ÿå¯ä»¥åœ¨GitHubä¸Šæ‰¾åˆ°å®Œæ•´æºç :[verdure-mcp-for-xiaozhi](https://github.com/maker-community/verdure-mcp-for-xiaozhi)

![img](https://img2024.cnblogs.com/blog/1690009/202511/1690009-20251125233400753-303203725.jpg)

### ğŸ“º è§†é¢‘æ¼”ç¤º

æƒ³å¿«é€Ÿäº†è§£é¡¹ç›®åŠŸèƒ½å’Œä½¿ç”¨æ–¹æ³•ï¼Ÿè§‚çœ‹æˆ‘çš„Bç«™è§†é¢‘æ•™ç¨‹ï¼š

Bç«™è§†é¢‘å†…å®¹

å†…å®¹ç®€ä»‹

é€‚åˆäººç¾¤

[å°æ™º MCP è½¬æ¥æœåŠ¡ä¸Šçº¿ä¸å¼€æº](https://www.bilibili.com/video/BV1LYkyBoEh1/)

å¹³å°ä»‹ç»ã€åŠŸèƒ½æ¼”ç¤ºã€åœ¨çº¿ä½¿ç”¨æ•™ç¨‹

å°æ™ºå•†å®¶å’Œå°æ™ºçˆ±å¥½è€…

[ç§æœ‰åŒ–éƒ¨ç½²ä¸ç±³å®¶æ™ºèƒ½å®¶å±…æ§åˆ¶](https://www.bilibili.com/video/BV1eJUTBYEsi/)

Dockeréƒ¨ç½²æ•™ç¨‹ã€ç±³å®¶MCPæœåŠ¡æ¥å…¥å®æˆ˜

éœ€è¦ç§æœ‰éƒ¨ç½²å’Œæ™ºèƒ½å®¶å±…æ§åˆ¶çš„ç”¨æˆ·

ä¸ºä»€ä¹ˆè¦åšè¿™ä¸ªé¡¹ç›®
---------

### æŠ€æœ¯èƒŒæ™¯

å°æ™ºAIçš„MCPç«¯ç‚¹é‡‡ç”¨çš„æ˜¯WebSocketåè®®,è¿™æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å®ç°æ–¹å¼,ä¸æ ‡å‡†çš„MCPåè®®(åŸºäºHTTP/SSE)æœ‰æ‰€ä¸åŒã€‚å¦‚æœæƒ³è¦ä¸ºå°æ™ºå¼€å‘MCPåŠŸèƒ½,å¼€å‘è€…éœ€è¦:

1.  **äº†è§£WebSocketåè®®ç»†èŠ‚**:éœ€è¦å¤„ç†è¿æ¥ç®¡ç†ã€å¿ƒè·³æ£€æµ‹ã€é‡è¿æœºåˆ¶ç­‰
2.  **å®ç°MCPåè®®è½¬æ¢**:å°†æ ‡å‡†MCPçš„HTTP/SSEè¯·æ±‚è½¬æ¢ä¸ºWebSocketæ¶ˆæ¯
3.  **å¤„ç†å·¥å…·èšåˆ**:å¦‚æœè¦ä½¿ç”¨å¤šä¸ªMCPæœåŠ¡,éœ€è¦è‡ªå·±å®ç°å·¥å…·åˆ—è¡¨çš„èšåˆå’Œè·¯ç”±

### è§£å†³æ–¹æ¡ˆè®¾è®¡

åŸºäºè¿™äº›æŠ€æœ¯éœ€æ±‚,è®¾è®¡äº†ä¸€ä¸ªMCPæœåŠ¡è½¬æ¥å¹³å°æ¥ç®€åŒ–å¼€å‘:

*   **åè®®è½¬æ¢**:è‡ªåŠ¨å°†æ ‡å‡†MCPæœåŠ¡(HTTP/SSE)è½¬æ¢ä¸ºå°æ™ºçš„WebSocketåè®®
*   **å¤šç§Ÿæˆ·æ¶æ„**:æ¯ä¸ªç”¨æˆ·éƒ½æœ‰ç‹¬ç«‹çš„é…ç½®ç©ºé—´,äº’ä¸å¹²æ‰°
*   **å¯è§†åŒ–ç®¡ç†**:é€šè¿‡Webç•Œé¢ç®¡ç†MCPæœåŠ¡é…ç½®,æ— éœ€æ‰‹åŠ¨ç¼–è¾‘é…ç½®æ–‡ä»¶
*   **æœåŠ¡èšåˆ**:å¹³å°ä½œä¸ºä¸­é—´å±‚,å°†å¤šä¸ªMCPæœåŠ¡çš„å·¥å…·èšåˆåæä¾›ç»™å°æ™º
*   **åˆ†å¸ƒå¼æ”¯æŒ**:æ”¯æŒå¤šå®ä¾‹éƒ¨ç½²,é€šè¿‡Rediså®ç°åˆ†å¸ƒå¼åè°ƒ

ä»è¿™ä¸ªé¡¹ç›®èƒ½å­¦åˆ°ä»€ä¹ˆ
----------

### æ ¸å¿ƒæŠ€æœ¯æ ˆ

*   **.NET 9** - æ–°çš„.NETæ¡†æ¶,æ€§èƒ½å’Œå¼€å‘ä½“éªŒéƒ½å¾ˆæ£’ï¼ˆå‡†å¤‡è¿‡æ®µæ—¶é—´å‡çº§.NET 10ï¼‰
*   **Blazor WebAssembly** - çº¯C#å¼€å‘å‰ç«¯,æ— éœ€å­¦ä¹ JavaScript
*   **é¢†åŸŸé©±åŠ¨è®¾è®¡(DDD)** - è§„èŒƒçš„åˆ†å±‚æ¶æ„å’Œé¢†åŸŸæ¨¡å‹
*   **ä»“å‚¨æ¨¡å¼** - æ•°æ®è®¿é—®å±‚çš„æœ€ä½³å®è·µ
*   **Keycloakè®¤è¯** - OpenID Connectæ ‡å‡†çš„èº«ä»½è®¤è¯
*   **WebSocketç¼–ç¨‹** - å®æ—¶åŒå‘é€šä¿¡çš„å®ç°
*   **åˆ†å¸ƒå¼åè°ƒ** - åŸºäºRedisçš„åˆ†å¸ƒå¼é”å’ŒçŠ¶æ€ç®¡ç†

### æ¶æ„äº®ç‚¹

è¿™ä¸ªé¡¹ç›®å±•ç¤ºäº†ä¼ä¸šçº§.NETåº”ç”¨çš„å®Œæ•´æ¶æ„:

    verdure-mcp-for-xiaozhi/
    â”œâ”€â”€ Domain/           # é¢†åŸŸå±‚:èšåˆæ ¹ã€å®ä½“ã€ä»“å‚¨æ¥å£
    â”œâ”€â”€ Application/      # åº”ç”¨æœåŠ¡å±‚:ä¸šåŠ¡é€»è¾‘ç¼–æ’
    â”œâ”€â”€ Infrastructure/   # åŸºç¡€è®¾æ–½å±‚:æ•°æ®è®¿é—®ã€å¤–éƒ¨æœåŠ¡
    â”œâ”€â”€ Api/             # APIå±‚:RESTfulæ¥å£ã€WebSocketæœåŠ¡
    â””â”€â”€ Web/             # Blazorå‰ç«¯:ç»„ä»¶åŒ–UIå¼€å‘
    

![å¹³å°ç•Œé¢å±•ç¤º](https://img2024.cnblogs.com/blog/1690009/202511/1690009-20251125224148514-1786920132.jpg)

æ ¸å¿ƒè®¾è®¡ç†å¿µ
------

### é¢†åŸŸæ¨¡å‹è®¾è®¡

é¡¹ç›®é‡‡ç”¨DDDè®¾è®¡,æ ¸å¿ƒæœ‰ä¸¤ä¸ªèšåˆæ ¹:

#### 1\. XiaozhiMcpEndpoint(å°æ™ºè¿æ¥ç«¯ç‚¹)

ä»£è¡¨ç”¨æˆ·é…ç½®çš„å°æ™ºWebSocketè¿æ¥åœ°å€,æ˜¯æ•´ä¸ªç³»ç»Ÿçš„æ ¸å¿ƒå®ä½“ã€‚

    public class XiaozhiMcpEndpoint : Entity, IAggregateRoot
    {
        public string Name { get; private set; }
        public string Address { get; private set; }  // WebSocketåœ°å€
        public string UserId { get; private set; }
        public string? Description { get; private set; }
        public bool IsEnabled { get; private set; }  // æ˜¯å¦å¯ç”¨è¿æ¥
        public bool IsConnected { get; private set; } // å®æ—¶è¿æ¥çŠ¶æ€
        
        // æ—¶é—´æˆ³è¿½è¸ª
        public DateTime CreatedAt { get; private set; }
        public DateTime? UpdatedAt { get; private set; }
        public DateTime? LastConnectedAt { get; private set; }
        public DateTime? LastDisconnectedAt { get; private set; }
        
        // æœåŠ¡ç»‘å®šé›†åˆ - ç§æœ‰å­—æ®µ,åªè¯»æš´éœ²
        private readonly List<McpServiceBinding> _serviceBindings = new();
        public IReadOnlyCollection<McpServiceBinding> ServiceBindings => _serviceBindings.AsReadOnly();
        
        public XiaozhiMcpEndpoint(string name, string address, string userId, string? description = null)
        {
            GenerateId(); // ä½¿ç”¨Guid Version 7ç”ŸæˆID
            Name = name;
            Address = address;
            UserId = userId;
            Description = description;
            IsEnabled = false; // é»˜è®¤ç¦ç”¨,éœ€ç”¨æˆ·ä¸»åŠ¨å¯ç”¨
            IsConnected = false;
            CreatedAt = DateTime.UtcNow;
        }
        
        // æ ¸å¿ƒä¸šåŠ¡æ–¹æ³•:å¯ç”¨ç«¯ç‚¹
        public void Enable()
        {
            IsEnabled = true;
            UpdatedAt = DateTime.UtcNow;
        }
        
        // æ ¸å¿ƒä¸šåŠ¡æ–¹æ³•:ç¦ç”¨ç«¯ç‚¹å¹¶æ–­å¼€è¿æ¥
        public void Disable()
        {
            IsEnabled = false;
            IsConnected = false;
            UpdatedAt = DateTime.UtcNow;
        }
        
        // ...å…¶ä»–æ–¹æ³•: SetConnected(), SetDisconnected(), UpdateInfo()ç­‰å·²çœç•¥
    }
    

**è®¾è®¡è¦ç‚¹**:

*   ä½¿ç”¨ç§æœ‰setterä¿æŠ¤æ•°æ®å®Œæ•´æ€§
*   é€šè¿‡æ–¹æ³•(Enable/Disable)è€Œéç›´æ¥ä¿®æ”¹å±æ€§æ¥æ”¹å˜çŠ¶æ€
*   IsEnabledå’ŒIsConnectedåˆ†ç¦»:IsEnabledæ˜¯ç”¨æˆ·æ„å›¾,IsConnectedæ˜¯å®é™…çŠ¶æ€
*   ServiceBindingsé›†åˆå°è£…:ç§æœ‰Listé…åˆåªè¯»æ¥å£æš´éœ²,é˜²æ­¢å¤–éƒ¨ç›´æ¥ä¿®æ”¹

#### 2\. McpServiceConfig(MCPæœåŠ¡é…ç½®)

ä»£è¡¨ä¸€ä¸ªå¯ç”¨çš„MCPæœåŠ¡èŠ‚ç‚¹åŠå…¶è®¤è¯é…ç½®ã€‚

    public class McpServiceConfig : Entity, IAggregateRoot
    {
        public string Name { get; private set; }
        public string Endpoint { get; private set; }
        public string UserId { get; private set; }
        public string? Description { get; private set; }
        public bool IsPublic { get; private set; }
        
        // è®¤è¯é…ç½®æ”¯æŒ4ç§ç±»å‹: bearer, basic, apikey, oauth2
        public string? AuthenticationType { get; private set; }
        public string? AuthenticationConfig { get; private set; } // JSONæ ¼å¼é…ç½®
        
        public string? Protocol { get; private set; } // stdio/http/sse
        
        // æ—¶é—´æˆ³
        public DateTime CreatedAt { get; private set; }
        public DateTime? UpdatedAt { get; private set; }
        public DateTime? LastSyncedAt { get; private set; }
        
        // å·¥å…·é›†åˆ - ç§æœ‰å­—æ®µ,åªè¯»æš´éœ²
        private readonly List<McpTool> _tools = new();
        public IReadOnlyCollection<McpTool> Tools => _tools.AsReadOnly();
        
        public McpServiceConfig(
            string name, 
            string endpoint, 
            string userId, 
            string? description = null,
            string? authenticationType = null,
            string? authenticationConfig = null,
            string? protocol = null)
        {
            GenerateId();
            Name = name;
            Endpoint = endpoint;
            UserId = userId;
            Description = description;
            IsPublic = false; // é»˜è®¤ç§æœ‰
            AuthenticationType = authenticationType;
            AuthenticationConfig = authenticationConfig;
            Protocol = protocol ?? "stdio"; // é»˜è®¤stdioåè®®
            CreatedAt = DateTime.UtcNow;
        }
        
        // æ›´æ–°æœåŠ¡é…ç½®ä¿¡æ¯
        public void UpdateInfo(
            string name, 
            string endpoint, 
            string? description = null,
            string? authenticationType = null,
            string? authenticationConfig = null,
            string? protocol = null)
        {
            Name = name;
            Endpoint = endpoint;
            Description = description;
            AuthenticationType = authenticationType;
            AuthenticationConfig = authenticationConfig;
            Protocol = protocol;
            UpdatedAt = DateTime.UtcNow;
        }
        
        public void SetPublic()
        {
            IsPublic = true;
            UpdatedAt = DateTime.UtcNow;
        }
        
        public void SetPrivate()
        {
            IsPublic = false;
            UpdatedAt = DateTime.UtcNow;
        }
        
        // ...å…¶ä»–æ–¹æ³•: UpdateAuthenticationConfig()ç­‰å·²çœç•¥
    }
    

**è®¾è®¡è¦ç‚¹**:

*   æ”¯æŒ4ç§è®¤è¯æ–¹å¼(Bearer/Basic/API Key/OAuth2),è®¤è¯é…ç½®ä»¥JSONå­˜å‚¨ä¿æŒçµæ´»æ€§
*   é€šè¿‡SetPublic/SetPrivateæ–¹æ³•æ§åˆ¶æœåŠ¡å¯è§æ€§,æ”¯æŒå…¬å…±æœåŠ¡å¸‚åœº
*   Toolsé›†åˆå°è£…:ç§æœ‰Listé…åˆåªè¯»æ¥å£æš´éœ²,é˜²æ­¢å¤–éƒ¨ç›´æ¥ä¿®æ”¹
*   ä½¿ç”¨Guid Version 7ä½œä¸ºID,æä¾›æ›´å¥½çš„æ•°æ®åº“ç´¢å¼•æ€§èƒ½å’Œæ—¶åºç‰¹æ€§

### WebSocketä¼šè¯ç®¡ç†

è¿™æ˜¯æ•´ä¸ªå¹³å°æœ€æ ¸å¿ƒçš„éƒ¨åˆ†,éœ€è¦å¤„ç†å‡ ä¸ªå…³é”®é—®é¢˜:

#### é—®é¢˜1:å¦‚ä½•èšåˆå¤šä¸ªMCPæœåŠ¡çš„å·¥å…·?

**è§£å†³æ–¹æ¡ˆ**:McpSessionServiceç»´æŠ¤å¤šä¸ªMcpClientå®ä¾‹

    public class McpSessionService : IAsyncDisposable
    {
        private readonly ILogger<McpSessionService> _logger;
        private readonly IMcpClientService _mcpClientService;
        private readonly McpSessionConfiguration _config;
        private readonly ReconnectionSettings _reconnectionSettings;
        
        // Session state
        private ClientWebSocket? _webSocket;
        private readonly List<McpClient> _mcpClients = new();
        // ğŸ”§ è¿½è¸ªæ¯ä¸ªå®¢æˆ·ç«¯çš„æœåŠ¡é…ç½®,ç”¨äºä¼šè¯æ¢å¤
        private readonly Dictionary<int, McpServiceEndpoint> _clientIndexToServiceConfig = new();
        // ğŸ”§ è¿½è¸ªå¤±è´¥çš„æœåŠ¡,ç”¨äºå®šæœŸé‡è¯•
        private readonly Dictionary<string, (McpServiceEndpoint Config, DateTime LastAttempt)> _failedServices = new();
        
        // Ping timeout monitoring
        private DateTime _lastPingReceivedTime = DateTime.UtcNow;
        private readonly TimeSpan _pingTimeout = TimeSpan.FromSeconds(120);
        
        // Connection status events
        public event Func<Task>? OnConnected;
        public event Func<string, Task>? OnConnectionFailed;
        public event Func<Task>? OnDisconnected;
        
        private async Task ConnectAsync(CancellationToken cancellationToken)
        {
            // âš ï¸ å…³é”®:å…ˆè¿æ¥MCPæœåŠ¡,å†è¿æ¥WebSocket
            // è¿™ç¡®ä¿æ‰€æœ‰åç«¯æœåŠ¡å°±ç»ªåæ‰å‘ŠçŸ¥å°æ™ºæˆ‘ä»¬åœ¨çº¿
            
            _logger.LogInformation("Server {ServerId}: Connecting to {Count} MCP service(s)...",
                ServerId, _config.McpServices.Count);
            
            var failedServiceNames = new List<string>();
            
            // 1. å…ˆè¿æ¥æ‰€æœ‰MCPæœåŠ¡(æ”¯æŒå¤šç§è®¤è¯æ–¹å¼)
            foreach (var service in _config.McpServices)
            {
                try
                {
                    // åˆ›å»ºMCPå®¢æˆ·ç«¯,ä¼ é€’è®¤è¯é…ç½®
                    var mcpClient = await _mcpClientService.CreateMcpClientAsync(
                        $"McpService_{service.ServiceName}",
                        service.NodeAddress,
                        service.Protocol ?? "stdio",
                        service.AuthenticationType,  // bearer/basic/apikey/oauth2
                        service.AuthenticationConfig, // JSONæ ¼å¼è®¤è¯é…ç½®
                        cancellationToken);
                    
                    var clientIndex = _mcpClients.Count;
                    _mcpClients.Add(mcpClient);
                    _clientIndexToServiceConfig[clientIndex] = service; // è¿½è¸ªé…ç½®ç”¨äºä¼šè¯æ¢å¤
                    
                    _logger.LogInformation("Server {ServerId}: Connected to MCP service {ServiceName}",
                        ServerId, service.ServiceName);
                }
                catch (Exception ex)
                {
                    // è®°å½•å¤±è´¥çš„æœåŠ¡,ä¾›åç»­é‡è¯•
                    failedServiceNames.Add(service.ServiceName);
                    _failedServices[service.ServiceName] = (service, DateTime.UtcNow);
                    _logger.LogWarning("Server {ServerId}: Skipping MCP service {ServiceName} - {Error}",
                        ServerId, service.ServiceName, ex.Message);
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªMCPå®¢æˆ·ç«¯è¿æ¥æˆåŠŸ
            if (_mcpClients.Count == 0)
            {
                throw new InvalidOperationException(
                    $"No MCP clients connected successfully (0/{_config.McpServices.Count})");
            }
            
            _logger.LogInformation("Server {ServerId}: {SuccessCount}/{TotalCount} MCP services connected",
                ServerId, _mcpClients.Count, _config.McpServices.Count);
            
            // 2. æ‰€æœ‰MCPæœåŠ¡å°±ç»ªå,è¿æ¥å°æ™ºWebSocket
            _webSocket = new ClientWebSocket();
            await _webSocket.ConnectAsync(new Uri(_config.WebSocketEndpoint), cancellationToken);
            
            _lastPingReceivedTime = DateTime.UtcNow; // åˆå§‹åŒ–pingç›‘æ§
            
            await (OnConnected?.Invoke() ?? Task.CompletedTask); // è§¦å‘è¿æ¥æˆåŠŸå›è°ƒ
            
            // 3. å¯åŠ¨åŒå‘é€šä¿¡ + pingè¶…æ—¶ç›‘æ§
            // ...æ¶ˆæ¯ç®¡é“å’Œç›‘æ§é€»è¾‘å·²çœç•¥
        }
    }
    

**è®¾è®¡è¦ç‚¹**:

*   **Listè€ŒéDictionary**:`_mcpClients`ä½¿ç”¨Listå­˜å‚¨,é€šè¿‡ç´¢å¼•æ˜ å°„åˆ°é…ç½®
*   **å¤±è´¥æœåŠ¡è·Ÿè¸ª**:`_failedServices`è®°å½•å¤±è´¥çš„æœåŠ¡ä¾›åç»­é‡è¯•
*   **Pingè¶…æ—¶ç›‘æ§**:120ç§’æœªæ”¶åˆ°pingåˆ™è®¤ä¸ºè¿æ¥æ–­å¼€
*   **è¿æ¥é¡ºåºå…³é”®**:å…ˆMCPæœåŠ¡,å†WebSocket,ç¡®ä¿åç«¯å°±ç»ª
*   **äº‹ä»¶é©±åŠ¨**:é€šè¿‡OnConnected/OnConnectionFailed/OnDisconnectedé€šçŸ¥ä¸Šå±‚

#### é—®é¢˜2:å°æ™ºè¯·æ±‚å·¥å…·åˆ—è¡¨æ€ä¹ˆå“åº”?

**è§£å†³æ–¹æ¡ˆ**:ä»é…ç½®æ•°æ®ç›´æ¥è·å–å·¥å…·ä¿¡æ¯,ä¸ä¾èµ–MCPå®¢æˆ·ç«¯è¿æ¥çŠ¶æ€

    private async Task HandleToolsListAsync(int? id, CancellationToken cancellationToken)
    {
        // âš¡ æ€§èƒ½ä¼˜åŒ–: ç›´æ¥ä»é…ç½®è¯»å–å·¥å…·åˆ—è¡¨,ä¸ä¾èµ–MCPå®¢æˆ·ç«¯è¿æ¥çŠ¶æ€
        // å³ä½¿éƒ¨åˆ†MCPæœåŠ¡è¿æ¥å¤±è´¥,ä¹Ÿèƒ½è¿”å›å·²é…ç½®çš„å®Œæ•´å·¥å…·åˆ—è¡¨
        
        if (_config.McpServices.Count == 0)
        {
            await SendErrorResponseAsync(id, -32603, "No MCP services configured",
                "No MCP service bindings configured for this endpoint", cancellationToken);
            return;
        }
    
        var allTools = new List<object>();
        
        // éå†æ‰€æœ‰é…ç½®çš„æœåŠ¡,èšåˆSelectedTools
        foreach (var serviceConfig in _config.McpServices)
        {
            foreach (var tool in serviceConfig.SelectedTools)
            {
                // è§£æå­˜å‚¨çš„InputSchema JSON(å®Œæ•´çš„å·¥å…·Schemaå·²åœ¨å·¥å…·åŒæ­¥æ—¶ä¿å­˜)
                var properties = new Dictionary<string, object>();
                var required = Array.Empty<string>();
    
                if (!string.IsNullOrEmpty(tool.InputSchema))
                {
                    var schemaDoc = JsonDocument.Parse(tool.InputSchema);
                    if (schemaDoc.RootElement.TryGetProperty("properties", out var propsElement))
                    {
                        properties = JsonElementToObject(propsElement) as Dictionary<string, object> ?? new();
                    }
                    if (schemaDoc.RootElement.TryGetProperty("required", out var reqElement))
                    {
                        required = reqElement.EnumerateArray()
                            .Select(x => x.GetString() ?? "")
                            .ToArray();
                    }
                }
    
                // æ„å»ºç¬¦åˆMCPåè®®çš„å·¥å…·å®šä¹‰
                allTools.Add(new
                {
                    name = tool.Name,
                    description = tool.Description,
                    inputSchema = new
                    {
                        type = "object",
                        properties = properties,
                        required = required,
                        title = $"{tool.Name}Arguments"
                    }
                });
            }
        }
        
        // è¿”å›JSON-RPCæ ¼å¼å“åº”
        var response = new
        {
            jsonrpc = "2.0",
            id = id,
            result = new { tools = allTools.ToArray() }
        };
        
        await SendWebSocketResponseAsync(response, cancellationToken);
    }
    

**å…³é”®ä¼˜åŒ–**:

*   ç›´æ¥ä»é…ç½®è¯»å–å·¥å…·æ•°æ®,å³ä½¿MCPå®¢æˆ·ç«¯è¿æ¥å¤±è´¥ä¹Ÿèƒ½è¿”å›å·¥å…·åˆ—è¡¨
*   å®Œæ•´è§£æInputSchemaçš„propertieså’Œrequiredå­—æ®µ
*   ç¬¦åˆMCPåè®®çš„å·¥å…·schemaæ ¼å¼è¦æ±‚

#### é—®é¢˜3:å°æ™ºè°ƒç”¨å·¥å…·æ€ä¹ˆè·¯ç”±åˆ°å¯¹åº”çš„MCPæœåŠ¡?

**è§£å†³æ–¹æ¡ˆ**:æ ¹æ®å·¥å…·åç§°æŸ¥æ‰¾å¯¹åº”çš„McpClient

    private async Task HandleToolsCallAsync(int? id, JsonDocument request, CancellationToken cancellationToken)
    {
        var toolName = request.RootElement.GetProperty("params")
            .GetProperty("name").GetString();
        var arguments = request.RootElement.GetProperty("params")
            .GetProperty("arguments");
        
        // ğŸ” éå†æ‰€æœ‰MCPå®¢æˆ·ç«¯,æŸ¥æ‰¾åŒ…å«è¯¥å·¥å…·çš„æœåŠ¡
        for (int i = 0; i < _mcpClients.Count; i++)
        {
            var mcpClient = _mcpClients[i];
            var serviceConfig = _clientIndexToServiceConfig[i];
            
            // å¦‚æœé…ç½®äº†SelectedTools,åˆ™åªåœ¨é€‰ä¸­çš„å·¥å…·ä¸­æŸ¥æ‰¾
            var selectedTools = serviceConfig.SelectedTools;
            if (selectedTools.Any())
            {
                var isToolSelected = selectedTools.Any(t => t.Name == toolName);
                if (!isToolSelected) continue; // å·¥å…·æœªè¢«é€‰ä¸­,è·³è¿‡æ­¤æœåŠ¡
            }
            
            // æ£€æŸ¥æ­¤MCPå®¢æˆ·ç«¯æ˜¯å¦æä¾›è¯¥å·¥å…·
            var hasTool = mcpClient.Tools?.Any(t => t.Name == toolName) ?? false;
            if (!hasTool) continue;
            
            // æ‰¾åˆ°ç›®æ ‡æœåŠ¡,è°ƒç”¨å·¥å…·
            try
            {
                var result = await mcpClient.CallToolAsync(
                    toolName,
                    JsonSerializer.Deserialize<Dictionary<string, object>>(arguments.GetRawText())!,
                    cancellationToken: cancellationToken);
                
                // è¿”å›å·¥å…·è°ƒç”¨ç»“æœ
                await SendWebSocketResponseAsync(new
                {
                    jsonrpc = "2.0",
                    id = id,
                    result = result
                }, cancellationToken);
                
                return; // æˆåŠŸè°ƒç”¨,ç»“æŸ
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Tool call failed for {ToolName} on service {ServiceName}",
                    toolName, serviceConfig.ServiceName);
                // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªæœåŠ¡
            }
        }
        
        // æœªæ‰¾åˆ°æä¾›è¯¥å·¥å…·çš„æœåŠ¡
        await SendErrorResponseAsync(id, -32601, "Tool not found",
            $"No MCP service provides tool '{toolName}'", cancellationToken);
    }
    

### MCPæœåŠ¡è®¤è¯æ”¯æŒ

ä¸ºäº†æ”¯æŒå„ç§éœ€è¦è®¤è¯çš„MCPæœåŠ¡,æˆ‘æŠ½è±¡å‡ºäº†ç»Ÿä¸€çš„è®¤è¯åŠ©æ‰‹ç±»:

    /// <summary>
    /// MCPè®¤è¯é…ç½®åŠ©æ‰‹ç±»
    /// è¢«McpClientService(å·¥å…·åŒæ­¥)å’ŒMcpSessionService(WebSocketè¿æ¥)å…±äº«ä½¿ç”¨
    /// </summary>
    public static class McpAuthenticationHelper
    {
        /// <summary>
        /// ä¸ºBearerã€Basicå’ŒAPI Keyè®¤è¯æ„å»ºHTTPè¯·æ±‚å¤´
        /// </summary>
        public static Dictionary<string, string> BuildAuthenticationHeaders(
            string authenticationType,
            string authenticationConfig,
            ILogger? logger = null)
        {
            if (string.IsNullOrEmpty(authenticationType) || string.IsNullOrEmpty(authenticationConfig))
            {
                throw new ArgumentException("Authentication type and config cannot be null or empty");
            }
    
            try
            {
                var authType = authenticationType.ToLowerInvariant();
    
                return authType switch
                {
                    "bearer" => BuildBearerTokenHeaders(authenticationConfig, logger),
                    "basic" => BuildBasicAuthHeaders(authenticationConfig, logger),
                    "apikey" => BuildApiKeyHeaders(authenticationConfig, logger),
                    _ => throw new InvalidOperationException(
                        $"Unsupported authentication type: {authenticationType}. Use BuildOAuth2Options for OAuth 2.0.")
                };
            }
            catch (Exception ex)
            {
                logger?.LogError(ex, "Failed to build authentication headers for type {AuthType}", authenticationType);
                throw new InvalidOperationException($"Failed to configure authentication: {ex.Message}", ex);
            }
        }
        
        /// <summary>
        /// ä¸ºOAuth 2.0æ„å»ºSDKçš„ClientOAuthOptionsé…ç½®
        /// </summary>
        public static ClientOAuthOptions BuildOAuth2Options(
            string authenticationConfig,
            ILogger? logger = null)
        {
            var authConfig = JsonSerializer.Deserialize<OAuth2AuthConfig>(authenticationConfig);
            
            if (string.IsNullOrEmpty(authConfig?.ClientId) || string.IsNullOrEmpty(authConfig.RedirectUri))
            {
                throw new InvalidOperationException("OAuth 2.0 Client ID and Redirect URI are required");
            }
    
            logger?.LogDebug("Configuring OAuth 2.0 with Client ID: {ClientId}", authConfig.ClientId);
    
            var oauthOptions = new ClientOAuthOptions
            {
                RedirectUri = new Uri(authConfig.RedirectUri),
                ClientId = authConfig.ClientId,
                ClientSecret = authConfig.ClientSecret
            };
    
            if (!string.IsNullOrEmpty(authConfig.Scope))
            {
                oauthOptions.Scopes = authConfig.Scope.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            }
    
            return oauthOptions;
        }
    
        // ç§æœ‰è¾…åŠ©æ–¹æ³•: BuildBearerTokenHeaders, BuildBasicAuthHeaders, BuildApiKeyHeaders
        // ...å®ç°ç»†èŠ‚å·²çœç•¥(è§£æJSONé…ç½®,æ„å»ºå¯¹åº”çš„HTTPè¯·æ±‚å¤´)
    }
    

**è®¾è®¡è¦ç‚¹**:

*   **DRYåŸåˆ™**:å·¥å…·åŒæ­¥å’ŒWebSocketè¿æ¥éƒ½å¤ç”¨è¿™ä¸ªåŠ©æ‰‹ç±»,æ¶ˆé™¤äº†150+è¡Œé‡å¤ä»£ç 
*   **åŒæ–¹æ³•è®¾è®¡**:
    *   `BuildAuthenticationHeaders`:å¤„ç†Bearer/Basic/API Key(é€šè¿‡HTTP Headerä¼ é€’)
    *   `BuildOAuth2Options`:å¤„ç†OAuth 2.0(ä½¿ç”¨SDKçš„ClientOAuthOptions)
*   **å¥å£®çš„é”™è¯¯å¤„ç†**:å‚æ•°éªŒè¯ã€å¼‚å¸¸æ•è·ã€è¯¦ç»†é”™è¯¯ä¿¡æ¯
*   **å¯é€‰æ—¥å¿—**:é€šè¿‡ILoggerå‚æ•°æ”¯æŒè°ƒè¯•,ä¸å¼ºåˆ¶ä¾èµ–
*   **ç§æœ‰è¾…åŠ©æ–¹æ³•**:æ¯ç§è®¤è¯ç±»å‹çš„å…·ä½“å®ç°å°è£…åœ¨ç§æœ‰æ–¹æ³•ä¸­,ä¿æŒä»£ç æ¸…æ™°

### åˆ†å¸ƒå¼WebSocketç®¡ç†

ä¸ºäº†æ”¯æŒå¤šå®ä¾‹éƒ¨ç½²,æˆ‘ä½¿ç”¨Rediså®ç°äº†åˆ†å¸ƒå¼åè°ƒ:

    public class McpSessionManager : IAsyncDisposable
    {
        private readonly IDistributedLockService _lockService; // RedLockå®ç°
        private readonly IConnectionStateService _connectionStateService; // RedisçŠ¶æ€ç®¡ç†
        private readonly Dictionary<string, McpSessionService> _sessions = new();
        
        public async Task<bool> StartSessionAsync(string serverId, CancellationToken cancellationToken = default)
        {
            // 1. æœ¬åœ°æ£€æŸ¥: é¿å…ä¸å¿…è¦çš„é”ç«äº‰
            if (_sessions.ContainsKey(serverId))
            {
                _logger.LogInformation("Server {ServerId} session already exists locally", serverId);
                return false;
            }
            
            // 2. Redisæ£€æŸ¥: å¯èƒ½å…¶ä»–å®ä¾‹å·²è¿æ¥
            var connectionState = await _connectionStateService.GetConnectionStateAsync(serverId);
            if (connectionState?.Status == ConnectionStatus.Connected)
            {
                _logger.LogInformation("Server {ServerId} is already connected on instance {InstanceId}",
                    serverId, connectionState.InstanceId);
                return false;
            }
            
            // 3. è·å–åˆ†å¸ƒå¼é” (RedLockç®—æ³•)
            var lockKey = $"mcp:session:lock:{serverId}";
            var acquired = await _lockService.AcquireLockAsync(
                lockKey,
                expiryTime: TimeSpan.FromMinutes(5),
                waitTime: TimeSpan.FromSeconds(10),
                retryTime: TimeSpan.FromSeconds(1));
            
            if (!acquired)
            {
                _logger.LogWarning("Failed to acquire lock for server {ServerId}", serverId);
                return false;
            }
            
            try
            {
                // 4. Double-check: å†æ¬¡æ£€æŸ¥RedisçŠ¶æ€(æŒæœ‰é”å)
                connectionState = await _connectionStateService.GetConnectionStateAsync(serverId);
                if (connectionState?.Status == ConnectionStatus.Connected)
                {
                    _logger.LogInformation("Server {ServerId} connected by another instance during lock wait",
                        serverId);
                    return false;
                }
                
                // 5. æ„å»ºä¼šè¯é…ç½®(ä»æ•°æ®åº“åŠ è½½æœåŠ¡ç»‘å®šã€å·¥å…·ç­‰)
                var config = await BuildSessionConfigurationAsync(serverId, cancellationToken);
                
                // 6. åˆ›å»ºä¼šè¯å¹¶è®¢é˜…äº‹ä»¶
                var session = new McpSessionService(config, _mcpClientService, _loggerFactory);
                
                session.OnConnected += async () =>
                {
                    await _connectionStateService.RegisterConnectionAsync(serverId, InstanceId);
                    await UpdateEndpointStatusAsync(serverId, isConnected: true);
                };
                
                session.OnConnectionFailed += async (error) =>
                {
                    await _connectionStateService.UpdateStatusAsync(serverId, ConnectionStatus.Failed);
                    await UpdateEndpointStatusAsync(serverId, isConnected: false);
                };
                
                session.OnDisconnected += async () =>
                {
                    await _connectionStateService.UnregisterConnectionAsync(serverId);
                    await UpdateEndpointStatusAsync(serverId, isConnected: false);
                    _sessions.Remove(serverId); // æ¸…ç†æœ¬åœ°ä¼šè¯
                };
                
                _sessions[serverId] = session;
                
                // 7. åœ¨åå°å¯åŠ¨ä¼šè¯(ä¸é˜»å¡)
                _ = Task.Run(async () =>
                {
                    try
                    {
                        await session.ConnectAsync(cancellationToken);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Session connection failed for {ServerId}", serverId);
                    }
                }, cancellationToken);
                
                return true;
            }
            finally
            {
                await _lockService.ReleaseLockAsync(lockKey); // é‡Šæ”¾åˆ†å¸ƒå¼é”
            }
        }
        
        // ...å…¶ä»–æ–¹æ³•: StopSessionAsync, BuildSessionConfigurationAsyncç­‰å·²çœç•¥
    }
    

**åˆ†å¸ƒå¼è®¾è®¡è¦ç‚¹**:

*   **ä¸‰å±‚æ£€æŸ¥æœºåˆ¶**: æœ¬åœ°å­—å…¸ â†’ RedisçŠ¶æ€ â†’ åˆ†å¸ƒå¼é”,æœ€å°åŒ–é”ç«äº‰å¼€é”€
*   **RedLockç®—æ³•**: ä½¿ç”¨RedLock.netåº“å®ç°åˆ†å¸ƒå¼é”,æ”¯æŒå¤šRediså®ä¾‹å®¹é”™
*   **Double-Checkæ¨¡å¼**: è·å–é”åå†æ¬¡æ£€æŸ¥RedisçŠ¶æ€,é˜²æ­¢ç«æ€æ¡ä»¶ä¸‹çš„é‡å¤è¿æ¥
*   **äº‹ä»¶é©±åŠ¨çŠ¶æ€åŒæ­¥**: é€šè¿‡OnConnected/OnDisconnectedäº‹ä»¶è‡ªåŠ¨æ›´æ–°Rediså’Œæ•°æ®åº“
*   **éé˜»å¡å¯åŠ¨**: ä¼šè¯è¿æ¥åœ¨åå°Taskä¸­æ‰§è¡Œ,StartSessionAsyncç«‹å³è¿”å›
*   **æ•…éšœè½¬ç§»æ”¯æŒ**: å®ä¾‹ä¸‹çº¿æ—¶,ç›‘æ§æœåŠ¡å¯æ£€æµ‹åˆ°RedisçŠ¶æ€å˜åŒ–å¹¶åœ¨å…¶ä»–å®ä¾‹é‡å¯ä¼šè¯

Blazorå‰ç«¯å¼€å‘ä½“éªŒ
------------

Blazor WebAssemblyå®ç°äº†çº¯C#å…¨æ ˆå¼€å‘,å‰åç«¯ç»Ÿä¸€æŠ€æœ¯æ ˆ:

    @page "/connections"
    @inject IXiaozhiMcpEndpointClientService ServerService
    @inject ISnackbar Snackbar
    
    <MudDataGrid Items="@_servers" Filterable="true">
        <Columns>
            <PropertyColumn Property="x => x.Name" Title="åç§°" />
            <PropertyColumn Property="x => x.IsConnected" Title="çŠ¶æ€">
                <CellTemplate>
                    @if (context.Item.IsConnected)
                    {
                        <MudChip Color="Color.Success" Icon="@Icons.Material.Filled.CheckCircle">å·²è¿æ¥</MudChip>
                    }
                    else if (context.Item.IsEnabled)
                    {
                        <MudChip Color="Color.Warning">æœªè¿æ¥</MudChip>
                    }
                    else
                    {
                        <MudChip>å·²ç¦ç”¨</MudChip>
                    }
                </CellTemplate>
            </PropertyColumn>
            <TemplateColumn Title="æ“ä½œ">
                <CellTemplate>
                    @if (context.Item.IsEnabled)
                    {
                        <MudIconButton Icon="@Icons.Material.Filled.PowerOff" 
                                       Color="Color.Error" 
                                       OnClick="@(() => DisableServerAsync(context.Item.Id!))" />
                    }
                    else
                    {
                        <MudIconButton Icon="@Icons.Material.Filled.PlayArrow" 
                                       Color="Color.Success" 
                                       OnClick="@(() => EnableServerAsync(context.Item.Id!))" />
                    }
                </CellTemplate>
            </TemplateColumn>
        </Columns>
    </MudDataGrid>
    
    @code {
        private IEnumerable<XiaozhiMcpEndpointDto> _servers = Array.Empty<XiaozhiMcpEndpointDto>();
        
        protected override async Task OnInitializedAsync()
        {
            await LoadServersAsync();
        }
        
        private async Task EnableServerAsync(string serverId)
        {
            await ServerService.EnableServerAsync(serverId);
            Snackbar.Add("WebSocketè¿æ¥å·²å¯åŠ¨", Severity.Success);
            await LoadServersAsync();
        }
    }
    

ä½¿ç”¨MudBlazorç»„ä»¶åº“,ç•Œé¢å¼€å‘æ•ˆç‡å¾ˆé«˜,è€Œä¸”ç»„ä»¶éƒ½æ˜¯Material Designé£æ ¼,å¾ˆç¾è§‚ã€‚

éƒ¨ç½²å’Œä¸Šçº¿
-----

### Dockerå•é•œåƒéƒ¨ç½²

é¡¹ç›®é…ç½®äº†å®Œæ•´çš„Dockeræ”¯æŒ,å‰åç«¯æ‰“åŒ…åˆ°ä¸€ä¸ªé•œåƒä¸­:

    # åŸºç¡€è¿è¡Œæ—¶é•œåƒ - Alpine Linuxæœ€å°åŒ–ä½“ç§¯
    FROM mcr.microsoft.com/dotnet/aspnet:9.0-alpine AS base
    WORKDIR /app
    EXPOSE 8080 8081
    RUN apk add --no-cache curl icu-libs tzdata
    
    # æ„å»ºé•œåƒ
    FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
    ARG BUILD_CONFIGURATION=Release
    WORKDIR /src
    
    # å¤åˆ¶é¡¹ç›®æ–‡ä»¶å¹¶è¿˜åŸä¾èµ–
    COPY ["Verdure.McpPlatform.sln", "."]
    COPY ["src/Verdure.McpPlatform.Api/Verdure.McpPlatform.Api.csproj", "src/Verdure.McpPlatform.Api/"]
    COPY ["src/Verdure.McpPlatform.Web/Verdure.McpPlatform.Web.csproj", "src/Verdure.McpPlatform.Web/"]
    # ...å…¶ä»–é¡¹ç›®æ–‡ä»¶å·²çœç•¥
    
    RUN dotnet restore "src/Verdure.McpPlatform.Api/Verdure.McpPlatform.Api.csproj"
    
    # å¤åˆ¶æºä»£ç å¹¶æ„å»º
    COPY . .
    WORKDIR "/src/src/Verdure.McpPlatform.Api"
    RUN dotnet publish "Verdure.McpPlatform.Api.csproj" \
        -c $BUILD_CONFIGURATION \
        -o /app/publish \
        /p:UseAppHost=false
    
    # æœ€ç»ˆè¿è¡Œæ—¶é•œåƒ
    FROM base AS final
    WORKDIR /app
    COPY --from=build /app/publish .
    
    ENV ASPNETCORE_URLS=http://+:8080
    ENV ASPNETCORE_ENVIRONMENT=Production
    ENV DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=false
    
    HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
        CMD curl -f http://localhost:8080/api/health || exit 1
    
    ENTRYPOINT ["dotnet", "Verdure.McpPlatform.Api.dll"]
    

### é…ç½®è¯´æ˜

ä¸»è¦éœ€è¦é…ç½®ä»¥ä¸‹ç¯å¢ƒå˜é‡:

    {
      "ConnectionStrings": {
        "mcpdb": "Host=localhost;Database=verdure_mcp;Username=postgres;Password=***",
        "identitydb": "Host=localhost;Database=verdure_identity;Username=postgres;Password=***",
        "Redis": "localhost:6379"
      },
      "Database": {
        "Provider": "PostgreSQL",  // æˆ– "SQLite"
        "TablePrefix": "verdure_"  // æ•°æ®åº“è¡¨åå‰ç¼€
      },
      "Identity": {
        "Url": "https://auth.verdure-hiro.cn/realms/maker-community",
        "Realm": "maker-community",
        "ClientId": "verdure-mcp",
        "Audience": "verdure-mcp-api",
        "RequireHttpsMetadata": true,
        "ClockSkewMinutes": 5
      },
      "ConnectionMonitor": {
        "CheckIntervalSeconds": 30,        // ç›‘æ§æ£€æŸ¥é—´éš”
        "HeartbeatTimeoutSeconds": 90,     // å¿ƒè·³è¶…æ—¶æ—¶é—´
        "ReconnectCooldownSeconds": 60     // é‡è¿å†·å´æ—¶é—´
      },
      "Logging": {
        "LogLevel": {
          "Default": "Information",
          "Verdure.McpPlatform": "Debug"
        }
      }
    }
    

**å…³é”®é…ç½®è¯´æ˜**:

1.  **æ•°æ®åº“é…ç½®**:
    
    *   `mcpdb`: ä¸šåŠ¡æ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²(MCPæœåŠ¡é…ç½®ã€è¿æ¥ç«¯ç‚¹ç­‰)
    *   `identitydb`: èº«ä»½è®¤è¯æ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²(ç”¨æˆ·ã€è§’è‰²ç­‰)
    *   `Provider`: æ”¯æŒPostgreSQLå’ŒSQLiteä¸¤ç§æ•°æ®åº“
    *   `TablePrefix`: ç»Ÿä¸€çš„è¡¨åå‰ç¼€,ç”¨äºå¤šç§Ÿæˆ·éƒ¨ç½²
2.  **Redisé…ç½®**:
    
    *   ç”¨äºåˆ†å¸ƒå¼é”å’Œè¿æ¥çŠ¶æ€ç®¡ç†
    *   ç”Ÿäº§ç¯å¢ƒå»ºè®®é…ç½®å¯†ç å’ŒSSL: `"redis:6379,password=***,ssl=true,abortConnect=false"`
3.  **èº«ä»½è®¤è¯é…ç½®**:
    
    *   `Url`: KeycloakæœåŠ¡åœ°å€,åŒ…å«realmè·¯å¾„
    *   `Realm`: Keycloak realmåç§°
    *   `ClientId`: å®¢æˆ·ç«¯ID
    *   `Audience`: APIå—ä¼—æ ‡è¯†,ç”¨äºJWTéªŒè¯
    *   `ClockSkewMinutes`: æ—¶é’Ÿåç§»å®¹å¿åº¦,å¤„ç†æœåŠ¡å™¨æ—¶é—´å·®å¼‚
4.  **è¿æ¥ç›‘æ§é…ç½®**:
    
    *   `CheckIntervalSeconds`: WebSocketè¿æ¥å¥åº·æ£€æŸ¥é—´éš”
    *   `HeartbeatTimeoutSeconds`: å¿ƒè·³è¶…æ—¶åˆ¤å®šæ—¶é—´
    *   `ReconnectCooldownSeconds`: æ–­å¼€åé‡è¿å†·å´æ—¶é—´
    *   å¼€å‘ç¯å¢ƒå¯ä»¥è®¾ç½®æ›´çŸ­çš„é—´éš”(15ç§’)ä»¥å¿«é€Ÿæ£€æµ‹é—®é¢˜

**ç¯å¢ƒå˜é‡æ–¹å¼é…ç½®**:

    # ä½¿ç”¨ç¯å¢ƒå˜é‡è¦†ç›–é…ç½®
    ConnectionStrings__mcpdb="Host=prod-db;Database=verdure_mcp;..."
    ConnectionStrings__Redis="redis:6379,password=***"
    Identity__Url="https://auth.example.com/realms/prod"
    ConnectionMonitor__CheckIntervalSeconds=60
    

æ€»ç»“ä¸å±•æœ›
-----

é€šè¿‡è¿™ä¸ªé¡¹ç›®çš„å¼€å‘å®è·µ,å¯ä»¥çœ‹åˆ°.NETç”Ÿæ€åœ¨å…¨æ ˆå¼€å‘ä¸Šçš„ä¼˜åŠ¿:

*   **ç»Ÿä¸€çš„æŠ€æœ¯æ ˆ**:ä»åç«¯APIåˆ°å‰ç«¯UIéƒ½æ˜¯C#,é™ä½äº†å­¦ä¹ æˆæœ¬
*   **æˆç†Ÿçš„æ¡†æ¶æ”¯æŒ**:EF Coreã€ASP.NET Coreã€Blazorç­‰éƒ½å¾ˆå®Œå–„
*   **ä¼ä¸šçº§ç‰¹æ€§**:DDDã€ä»“å‚¨æ¨¡å¼ã€åˆ†å¸ƒå¼åè°ƒç­‰éƒ½æœ‰ç°æˆçš„æœ€ä½³å®è·µå¯ä»¥å‚è€ƒ

ç›®å‰å¹³å°å·²ç»ä¸Šçº¿å¹¶å¼€æº,å¤§å®¶å¯ä»¥è®¿é—®[åœ¨çº¿æœåŠ¡](https://xiaozhi.verdure-hiro.cn/)ä½“éªŒ,ä¹Ÿæ¬¢è¿åœ¨GitHubä¸Šè´¡çŒ®ä»£ç ã€‚åç»­è®¡åˆ’:

*   æ·»åŠ æ›´å¤šMCPæœåŠ¡çš„é¢„ç½®æ¨¡æ¿
*   å®ç°å·¥å…·è°ƒç”¨çš„ç›‘æ§å’Œç»Ÿè®¡åŠŸèƒ½
*   å¼€å‘MCPæœåŠ¡çš„å¸‚åœºå’Œåˆ†äº«æœºåˆ¶

è¿™ä¸ªé¡¹ç›®å±•ç¤ºäº†.NETåœ¨ç°ä»£å…¨æ ˆå¼€å‘ä¸­çš„åº”ç”¨,å¸Œæœ›èƒ½ç»™æƒ³å­¦ä¹ .NETæŠ€æœ¯çš„å°ä¼™ä¼´æä¾›ä¸€ä¸ªå®æˆ˜å‚è€ƒ,åŒæ—¶ä¹Ÿä¸ºå°æ™ºç¤¾åŒºçš„ç”Ÿæ€å»ºè®¾è´¡çŒ®ä¸€ä»½åŠ›é‡ã€‚

### ğŸ“º æ¨èè§‚çœ‹è§†é¢‘æ•™ç¨‹

å¦‚æœä½ æƒ³æ›´ç›´è§‚åœ°äº†è§£é¡¹ç›®çš„ä½¿ç”¨æ–¹æ³•å’Œéƒ¨ç½²æµç¨‹,å¼ºçƒˆæ¨èè§‚çœ‹æˆ‘çš„Bç«™è§†é¢‘å†…å®¹:

*   [å°æ™º MCP è½¬æ¥æœåŠ¡ä¸Šçº¿ä¸å¼€æº](https://www.bilibili.com/video/BV1LYkyBoEh1/) - å¿«é€Ÿä¸Šæ‰‹æŒ‡å—
*   [ç§æœ‰åŒ–éƒ¨ç½²ä¸ç±³å®¶æ™ºèƒ½å®¶å±…æ§åˆ¶](https://www.bilibili.com/video/BV1eJUTBYEsi/) - æ·±åº¦å®æˆ˜æ•™ç¨‹
*   [Bç«™ä¸»é¡µ @ç»¿è«é˜¿å¹¿](https://space.bilibili.com/25228512) - è·å–æ›´å¤šAIå’Œåˆ›å®¢æ•™ç¨‹

å‚è€ƒæ¨è
----

*   [åˆ›å®¢ç¤¾åŒºåœ°å€](https://github.com/maker-community)
*   [é¡¹ç›®å¼€æºä»“åº“](https://github.com/maker-community/verdure-mcp-for-xiaozhi)
*   [åœ¨çº¿ä½“éªŒåœ°å€](https://xiaozhi.verdure-hiro.cn/)
*   [å°æ™ºAIå®˜ç½‘](https://xiaozhi.me/)
*   [MCPåè®®è§„èŒƒ](https://modelcontextprotocol.io/)
*   [å°æ™ºMCPä¾‹å­](https://github.com/78/mcp-calculator)
*   [.NETå®˜æ–¹æ–‡æ¡£](https://dotnet.microsoft.com/zh-cn/)
*   [Blazorå®˜æ–¹æ–‡æ¡£](https://dotnet.microsoft.com/zh-cn/apps/aspnet/web-apps/blazor)
*   [MudBlazorç»„ä»¶åº“](https://mudblazor.com/)