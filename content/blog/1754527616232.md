---
layout: post
title: 'Java文件写入与编码、字节数组、字符集、字符编解码 一文打通！'
date: "2025-08-07T00:46:56Z"
---
Java文件写入与编码、字节数组、字符集、字符编解码 一文打通！
================================

1\. 编码操作和解码操作
=============

编码操作是把字符串映射为一组byte序列。以何种方式映射？比如把“你”映射为00000000还是11111111？这是由编码集决定的。

常见的字符编码集如UTF-8、GBK等。

解码操作是把一组byte映射为字符串。同理根据编码集就可以进行解码操作。这是一个互逆的过程。

类似于谍战片中的情报，写在纸上的是加密内容（byte序列），当接头人拿到情报后通过密码本(编码集)，解出真正的内容。

2\. 案例
======

现在提出一个需求，你来编写一个Java接口。  
`实现接收一个网络请求，请求包含一个字符串参数，你把这个字符串保存到C盘为a.txt文档。`

这个过程设计到哪些编码和解码,是如何进行的？。

因为上层网络传输以byte为单位传输。

首先浏览器发送http请求时会把字符串参数“你好”根据编码方式(如UTF-8)编码为byte数组\[0xE4, 0xBD, 0xA0, 0xE5, 0xA5, 0xBD\]，从网络中传输。

当后端接收到请求后由Spring MVC框架会自动读取参数byte数组，默认按照UTF-8编码进行解码（版本不同解码时默认编码方式可能不同），创建一个String对象。

现在我们把字符串写到本地文件a.txt.

要知道文件存储同样是二进制，因此需要把字符串转为byte数组。

把byte数组写到本地磁盘，这个过程就完成了。

可能有的同学会有疑问？写入的a.txt文件你说是byte数组，但是我看到的是字符串呀！

你看到的是字符串，这是因为你打开文本使用的软件会读取byte序列，按照系统编码方式(可能是UTF-8、可能是GBK可以设置)进行编码后呈现给你的。

相信你通过电脑记事本打开有些文件，一定见过乱码吧。出现乱码的原因是通过某种编码方式写入磁盘的byte数组，它与记事本软件打开文本时使用的编码方式不一致。

这就是我们常说的编码不一致的问题。

Java中String默认编码是UTF-16是怎么回事？
============================

这里说的String默认编码是指String字符串在内存中的编码方式。`String`对象在内存中始终使用UTF-16编码。也就是说，无论原始字节是何种编码（UTF-8、GBK等），一旦被转换成`String`，它就会以UTF-16编码的形式存储在内存中。

字符集和字符编码
========

Unicode是字符集。Unicode 为全球几乎所有字符（文字、符号、表情等）分配了唯一的数字编号（称为 “码点”，格式为 U+XXXX），例如 U+0061 代表小写字母 “a”，U+4E2D 代表汉字 “中”。它只定义了字符与码点的对应关系，不涉及存储或传输的具体方式。char类型字符强制转换为int类型的值，对应的是该字符的unicode码点。

UTF-8 是 “Unicode 转换格式”（Unicode Transformation Format）的一种，它规定了如何将 Unicode 码点转换为计算机可存储的二进制字节序列。

* * *

追加 InputStreamReader 和 OutStreamReader  
实际底层Writer还是写入的字节序列，Reader读取的还是字节序列，只是内部做了包装，把字节转为字符，这样方便用户调用函数操作字符。

Java I/O使用了装饰器模式，每一层都有特定职责。

    // 字符流处理
    BufferedReader reader = new BufferedReader(     // 提供缓冲功能
                            new InputStreamReader( // 字节转字符
                              inputStream));       // 原始字节流
    
    // 字节流处理  
    BufferedInputStream bis = new BufferedInputStream( // 提供缓冲功能
                               inputStream);          // 原始字节流
    

`个人水平有限，如有错误还请各位大佬指正`

生活虽然苦闷，但跑起来总是带风！