---
layout: post
title: 'TensorRtSharpï¼šåœ¨ C# ä¸–ç•Œä¸­é‡Šæ”¾ GPU æ¨ç†çš„æè‡´æ€§èƒ½'
date: "2026-01-12T00:48:51Z"
---
TensorRtSharpï¼šåœ¨ C# ä¸–ç•Œä¸­é‡Šæ”¾ GPU æ¨ç†çš„æè‡´æ€§èƒ½
====================================

![TensorRtSharpï¼šåœ¨ C# ä¸–ç•Œä¸­é‡Šæ”¾ GPU æ¨ç†çš„æè‡´æ€§èƒ½](https://img2024.cnblogs.com/blog/2933426/202601/2933426-20260111184433092-325501944.png) TensorRtSharp 3.0 æ˜¯ä¸€ä¸ªä¸º C# å¼€å‘è€…æ‰“é€ çš„ TensorRT å°è£…åº“ï¼Œé€šè¿‡ NuGet ä¸€é”®å®‰è£…ï¼Œæä¾›å®Œæ•´çš„ GPU æ¨ç†åŠ é€ŸåŠŸèƒ½ã€‚è¯¥åº“åŸºäº TensorRT 10.x å¼€å‘ï¼Œæ”¯æŒ CUDA 11/12ï¼Œå…·å¤‡ç±»å‹å®‰å…¨ã€è‡ªåŠ¨èµ„æºç®¡ç†ç­‰ç‰¹æ€§ï¼Œæ˜¾è‘—æå‡ .NET ç¯å¢ƒä¸‹çš„æ·±åº¦å­¦ä¹ æ¨ç†æ€§èƒ½ï¼ˆé€Ÿåº¦æå‡ 2-10 å€ï¼Œæ˜¾å­˜é™ä½ 50%+ï¼‰ã€‚å®‰è£…ç®€å•ï¼Œåªéœ€æ·»åŠ ä¸¤ä¸ª NuGet åŒ…ï¼Œå¹¶é€šè¿‡ç¯å¢ƒå˜é‡é…ç½®åŸç”Ÿåº“è·¯å¾„å³å¯ä½¿ç”¨ã€‚æ¨èé…ç½®ä¸º CUDA 11.6 + TensorRT 10.13.0.35ï¼Œæ”¯æŒ

TensorRtSharpï¼šåœ¨ C# ä¸–ç•Œä¸­é‡Šæ”¾ GPU æ¨ç†çš„æè‡´æ€§èƒ½
====================================

ç›®å½•
--

*   [ä¸€ã€å‰è¨€](#%E4%B8%80%E5%89%8D%E8%A8%80)
*   [äºŒã€ä»€ä¹ˆæ˜¯ TensorRtSharp](#%E4%BA%8C%E4%BB%80%E4%B9%88%E6%98%AF-tensortrtsharp)
*   [ä¸‰ã€å®‰è£…ä¸é…ç½®](#%E4%B8%89%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE)
*   [å››ã€æ ¸å¿ƒæ¶æ„è®¾è®¡](#%E5%9B%9B%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1)
*   [äº”ã€æ ¸å¿ƒç±»ä¸ API](#%E4%BA%94%E6%A0%B8%E5%BF%83%E7%B1%BB%E4%B8%8E-api)
*   [å…­ã€å®Œæ•´ä½¿ç”¨ç¤ºä¾‹](#%E5%85%AD%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B)
*   [ä¸ƒã€å¼‚å¸¸å¤„ç†](#%E4%B8%83%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86)
*   [å…«ã€æ—¥å¿—ç³»ç»Ÿ](#%E5%85%AB%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F)
*   [ä¹ã€ä¸å…¶ä»–åº“çš„å¯¹æ¯”](#%E4%B9%9D%E4%B8%8E%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94)
*   [åã€å¸¸è§é—®é¢˜](#%E5%8D%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)
*   [åä¸€ã€æ€»ç»“](#%E5%8D%81%E4%B8%80%E6%80%BB%E7%BB%93)

* * *

ä¸€ã€å‰è¨€
----

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦ TensorRtSharpï¼Ÿ

åœ¨æ·±åº¦å­¦ä¹ æ¨¡å‹éƒ¨ç½²é¢†åŸŸï¼ŒNVIDIA TensorRT å‡­å€Ÿå…¶å“è¶Šçš„æ¨ç†æ€§èƒ½å·²æˆä¸º GPU åŠ é€Ÿçš„äº‹å®æ ‡å‡†ã€‚æ ¹æ® NVIDIA å®˜æ–¹æ•°æ®ï¼Œä½¿ç”¨ TensorRT è¿›è¡Œæ¨¡å‹ä¼˜åŒ–å’Œæ¨ç†åŠ é€Ÿï¼Œé€šå¸¸å¯ä»¥è·å¾—ï¼š

*   ğŸ“ˆ **æ¨ç†é€Ÿåº¦æå‡ 2-10 å€**ï¼ˆç›¸æ¯”åŸç”Ÿæ¡†æ¶ï¼‰
*   ğŸ’¾ **æ˜¾å­˜å ç”¨é™ä½ 50% ä»¥ä¸Š**ï¼ˆé€šè¿‡ç²¾åº¦ä¼˜åŒ–å’Œå±‚èåˆï¼‰
*   âš¡ **å»¶è¿Ÿé™ä½è‡³æ¯«ç§’çº§**ï¼ˆæ»¡è¶³å®æ—¶åº”ç”¨éœ€æ±‚ï¼‰

ç„¶è€Œï¼ŒTensorRT å®˜æ–¹ä»…æä¾› C++ å’Œ Python APIï¼Œè¿™è®©å¹¿å¤§ .NET å¼€å‘è€…é¢ä¸´ä¸€ä¸ªä¸¤éš¾çš„é€‰æ‹©ï¼š

*   **æ”¾å¼ƒç†Ÿæ‚‰çš„ C# ç”Ÿæ€**ï¼Œè½¬å‘ C++ æˆ– Python
*   **é€šè¿‡å¤æ‚çš„äº’æ“ä½œå±‚**è¿›è¡Œè°ƒç”¨ï¼Œå¼€å‘æ•ˆç‡ä½ä¸‹

**TensorRtSharp** åº”è¿è€Œç”Ÿ â€”â€” è¿™æ˜¯ä¸€ä¸ªçº¯ C# ç¼–å†™çš„ TensorRT å®Œæ•´å°è£…åº“ï¼Œä¸º .NET å¼€å‘è€…æä¾›äº†ï¼š

*   âœ… **ç±»å‹å®‰å…¨çš„ API æ¥å£** - å¼ºç±»å‹ç³»ç»Ÿï¼Œç¼–è¯‘æ—¶é”™è¯¯æ£€æŸ¥
*   âœ… **æ˜“äºä½¿ç”¨ä¸”æ€§èƒ½å“è¶Š** - ç›´è§‚çš„ API è®¾è®¡ï¼Œé›¶æ€§èƒ½æŸå¤±
*   âœ… **å®Œæ•´çš„ TensorRT åŠŸèƒ½è¦†ç›–** - æ”¯æŒæ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½
*   âœ… **è‡ªåŠ¨èµ„æºç®¡ç†** - åŸºäº RAII å’Œ Dispose æ¨¡å¼ï¼Œæ— éœ€æ‹…å¿ƒå†…å­˜æ³„æ¼
*   âœ… **å¼€ç®±å³ç”¨** - NuGet ä¸€é”®å®‰è£…ï¼Œæ— éœ€å¤æ‚é…ç½®
*   âœ… **å®Œå–„çš„æ–‡æ¡£å’Œç¤ºä¾‹** - ä¸°å¯Œçš„ä»£ç ç¤ºä¾‹å’Œè¯¦ç»†çš„ä½¿ç”¨è¯´æ˜

### 1.2 TensorRtSharp çš„æ ¸å¿ƒä¼˜åŠ¿

**1\. åŸç”Ÿ C# ä½“éªŒ**

    // ç®€æ´ç›´è§‚çš„ API è®¾è®¡
    using Runtime runtime = new Runtime();
    using CudaEngine engine = runtime.deserializeCudaEngineByBlob(data, size);
    using ExecutionContext context = engine.createExecutionContext();
    context.executeV3(stream);
    

**2\. å®Œæ•´åŠŸèƒ½è¦†ç›–**

*   âœ… æ¨¡å‹æ„å»ºï¼ˆONNX â†’ Engineï¼‰
*   âœ… æ¨ç†æ‰§è¡Œï¼ˆåŒæ­¥/å¼‚æ­¥ï¼‰
*   âœ… åŠ¨æ€å½¢çŠ¶æ”¯æŒ
*   âœ… å¤šç²¾åº¦æ¨ç†ï¼ˆFP32/FP16/INT8ï¼‰
*   âœ… å¤š GPU å¹¶è¡Œæ¨ç†

### 1.3 TensorRtSharp 3.0 çš„é‡å¤§æ”¹è¿›

åœ¨å‰æœŸå¼€å‘çš„ TensorRtSharp 1.0 å’Œ 2.0 ä¸­ï¼Œä½¿ç”¨è€…éœ€è¦ä¸‹è½½æºç ç¼–è¯‘æ‰èƒ½ä½¿ç”¨ï¼Œè¿‡ç¨‹ç¹çä¸”å®¹æ˜“å‡ºé”™ã€‚

**åœ¨æœ€æ–°çš„ 3.0 ç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬è¿›è¡Œäº†é‡å¤§æ”¹è¿›**ï¼š

âœ… **ä¸€é”®å®‰è£…** - ç›´æ¥å°†ç¼–è¯‘å¥½çš„åŸç”Ÿåº“ä¸æ‰˜ç®¡ä»£ç æ‰“åŒ…è‡³ NuGet åŒ…ä¸­  
âœ… **å¼€ç®±å³ç”¨** - æ— éœ€é…ç½®å¤æ‚çš„æ„å»ºç¯å¢ƒ  
âœ… **ç‰ˆæœ¬ä¸€è‡´** - é™ä½å› ç¯å¢ƒå·®å¼‚å¯¼è‡´çš„æ½œåœ¨é”™è¯¯

å¼€å‘è€…ä»…éœ€é€šè¿‡ Visual Studio çš„ NuGet åŒ…ç®¡ç†å™¨å®‰è£…å³å¯ç›´æ¥ä½¿ç”¨ï¼Œæ˜¾è‘—æå‡äº†å¼€å‘æ•ˆç‡ä¸éƒ¨ç½²ä¾¿æ·æ€§ï¼

æœ¬æ–‡å°†å…¨é¢ä»‹ç» TensorRtSharp çš„è®¾è®¡ç†å¿µã€æ ¸å¿ƒåŠŸèƒ½å’Œä½¿ç”¨æ–¹æ³•ï¼ŒåŠ©åŠ›å¤§å®¶å¿«é€Ÿä¸Šæ‰‹ä½¿ç”¨ã€‚

* * *

äºŒã€ä»€ä¹ˆæ˜¯ TensorRtSharp
-------------------

### 2.1 é¡¹ç›®ç®€ä»‹

**TensorRtSharp 3.0** æ˜¯ä½œè€…å¯¹ NVIDIA TensorRT å®˜æ–¹åº“çš„å®Œæ•´ C# æ¥å£å°è£…ã€‚é€šè¿‡ P/Invoke æŠ€æœ¯ï¼Œå®ƒå°† TensorRT çš„åŸç”Ÿ C++ API æ˜ å°„ä¸ºç¬¦åˆ .NET è®¾è®¡è§„èŒƒçš„æ‰˜ç®¡ä»£ç ï¼Œè®© C# å¼€å‘è€…èƒ½å¤Ÿæ— ç¼ä½¿ç”¨ TensorRT çš„å…¨éƒ¨åŠŸèƒ½ã€‚

### 2.2 æ ¸å¿ƒç‰¹æ€§

ç‰¹æ€§

è¯´æ˜

**å®Œæ•´çš„ API è¦†ç›–**

æ”¯æŒ TensorRT æ ¸å¿ƒåŠŸèƒ½ï¼ŒåŒ…æ‹¬æ¨¡å‹æ„å»ºã€æ¨ç†æ‰§è¡Œã€åŠ¨æ€å½¢çŠ¶ç­‰

**ç±»å‹å®‰å…¨**

å¼ºç±»å‹ç³»ç»Ÿï¼Œç¼–è¯‘æ—¶é”™è¯¯æ£€æŸ¥ï¼Œé¿å…è¿è¡Œæ—¶ç±»å‹é”™è¯¯

**è‡ªåŠ¨èµ„æºç®¡ç†**

åŸºäº RAII å’Œ Dispose æ¨¡å¼çš„èµ„æºç®¡ç†ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼

**è·¨å¹³å°æ”¯æŒ**

æ”¯æŒ Windowsã€Linuxï¼Œå…¼å®¹ .NET 5.0-10.0ã€.NET Core 3.1ã€.NET Framework 4.7.1-4.8.1

**é«˜æ€§èƒ½å¼‚æ­¥æ‰§è¡Œ**

æ”¯æŒ CUDA Streamã€å¤šæ‰§è¡Œä¸Šä¸‹æ–‡å¹¶è¡Œæ¨ç†

**å¼€ç®±å³ç”¨**

NuGet åŒ…å«æ‰€æœ‰ä¾èµ–ï¼Œæ— éœ€å¤æ‚é…ç½®

### 2.3 é¡¹ç›®ä¿¡æ¯

é¡¹ç›®

ä¿¡æ¯

**ç‰ˆæœ¬**

ç›®å‰æœ€æ–° NuGet ç‰ˆæœ¬ä¸º 0.0.5ï¼ˆæŒç»­æ›´æ–°ä¸­ï¼Œå»ºè®®ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬ï¼‰

**GitHub**

`https://github.com/guojin-yan/TensorRT-CSharp-API`

**æ¥å£ NuGet**

`JYPPX.TensorRT.CSharp.API`

**Runtime NuGet**

`JYPPX.TensorRT.CSharp.API.runtime.win-x64.cuda12` æˆ– `JYPPX.TensorRT.CSharp.API.runtime.win-x64.cuda11`

**ç¼–ç¨‹è¯­è¨€**

C# 10

* * *

ä¸‰ã€å®‰è£…ä¸é…ç½®
-------

### 3.1 é€šè¿‡ NuGet å®‰è£…

å®‰è£… TensorRtSharp éå¸¸ç®€å•ï¼Œåªéœ€å®‰è£…ä¸¤ä¸ª NuGet åŒ…ï¼š

    # å®‰è£…æ¥å£åŒ…
    dotnet add package JYPPX.TensorRT.CSharp.API
    
    # å®‰è£…è¿è¡Œæ—¶åŒ…ï¼ˆæ ¹æ®æ‚¨çš„ CUDA ç‰ˆæœ¬é€‰æ‹©ï¼‰
    # CUDA 12.x ç‰ˆæœ¬
    dotnet add package JYPPX.TensorRT.CSharp.API.runtime.win-x64.cuda12
    
    # æˆ– CUDA 11.x ç‰ˆæœ¬
    dotnet add package JYPPX.TensorRT.CSharp.API.runtime.win-x64.cuda11
    

> **ğŸ’¡ å°è´´å£«**ï¼šRuntime åŒ…ä¸ CUDA ç‰ˆæœ¬ç›¸å…³ï¼Œè¯·æ ¹æ®æ‚¨è®¾å¤‡ä¸Šå®‰è£…çš„ CUDA ç‰ˆæœ¬é€‰æ‹©å¯¹åº”çš„åŒ…ã€‚

### 3.2 ç³»ç»Ÿè¦æ±‚

è¦æ±‚

è¯´æ˜

**æ“ä½œç³»ç»Ÿ**

Windows 10+ã€Linuxï¼ˆUbuntu 18.04+ï¼‰ã€macOS 10.15+

**.NET ç‰ˆæœ¬**

.NET 5.0-10.0ã€.NET Core 3.1ã€.NET Framework 4.7.1+

**GPU**

NVIDIA GPUï¼ˆæ”¯æŒ CUDA 11.x æˆ– 12.xï¼‰

**ä¾èµ–**

NVIDIA TensorRT 10.xã€CUDA Runtime

### 3.3 é‡è¦ç‰ˆæœ¬è¯´æ˜

> **âš ï¸ é‡è¦æé†’ï¼šNVIDIA TensorRT å¿…é¡»æ˜¯ 10.x ç³»åˆ—ï¼ï¼**

TensorRtSharp 3.0 åŸºäº TensorRT 10.x å¼€å‘ï¼Œä¸æ”¯æŒ TensorRT 8.x æˆ– 9.x ç‰ˆæœ¬ã€‚

ä¸ºäº†é˜²æ­¢å‡ºç°å…¼å®¹æ€§é—®é¢˜ï¼Œå»ºè®®ä½¿ç”¨ä¸åšä¸»ç›¸åŒçš„é…ç½®ï¼š

**é…ç½® 1ï¼ˆæ¨èï¼‰ï¼š**

*   CUDA 11.6
*   cuDNN 9.2.0
*   TensorRT 10.13.0.35

**é…ç½® 2ï¼š**

*   CUDA 12.3
*   cuDNN 9.2.0
*   TensorRT 10.11.0.33

### 3.4 é…ç½®åŸç”Ÿåº“

TensorRtSharp ä¾èµ– TensorRT çš„åŸç”Ÿåº“ï¼ˆ`nvinfer.dll`ï¼‰å’Œ CUDA çš„åŸç”Ÿåº“ï¼ˆ`cudart64_*.dll` ç­‰ï¼‰ã€‚æœ‰ä¸¤ç§é…ç½®æ–¹å¼ï¼š

#### æ–¹å¼ä¸€ï¼šæ‹·è´ DLL åˆ°åº”ç”¨ç¨‹åºç›®å½•ï¼ˆä¸æ¨èï¼‰

å°† TensorRT å’Œ CUDA çš„æ‰€æœ‰ DLL æ–‡ä»¶æ‹·è´åˆ°ç¨‹åºå¯æ‰§è¡Œç›®å½•ä¸‹ã€‚

**ç¼ºç‚¹**ï¼š

*   ä¼šå¯¼è‡´ç¨‹åºç›®å½•æ–‡ä»¶åºå¤§
*   ä¸æ–¹ä¾¿ç®¡ç†ä¸éƒ¨ç½²
*   **ä¸æ¨èä½¿ç”¨æ­¤æ–¹å¼**

#### æ–¹å¼äºŒï¼šè®¾ç½®ç³»ç»Ÿ PATHï¼ˆæ¨èï¼‰

å°† TensorRT çš„ lib ç›®å½•å’Œ CUDA çš„ bin ç›®å½•è·¯å¾„æ·»åŠ åˆ°ç³»ç»Ÿ PATH ç¯å¢ƒå˜é‡ä¸­ã€‚

**ä¼˜ç‚¹**ï¼š

*   æ— éœ€å¤åˆ¶å¤§é‡æ–‡ä»¶
*   ä¿æŒåº”ç”¨ç›®å½•æ•´æ´
*   ä¾¿äºç‰ˆæœ¬ç®¡ç†å’Œéƒ¨ç½²ç»´æŠ¤

**é…ç½®æ­¥éª¤**ï¼š

1.  **è®¾ç½® CUDA\_PATH ç¯å¢ƒå˜é‡**

2.  **è®¾ç½® PATH ç¯å¢ƒå˜é‡**

å°†ä»¥ä¸‹è·¯å¾„æ·»åŠ åˆ° PATHï¼š

*   CUDA çš„ bin ç›®å½•ï¼ˆå¦‚ `C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.6\bin`ï¼‰
*   TensorRT çš„ lib ç›®å½•ï¼ˆå¦‚ `C:\TensorRT-10.13.0.35\lib`ï¼‰

> **ğŸ’¡ å»ºè®®**ï¼šä¼˜å…ˆä½¿ç”¨ç¯å¢ƒå˜é‡æ–¹å¼é…ç½®ï¼Œé¿å…å› æ–‡ä»¶å†—ä½™å¯¼è‡´éƒ¨ç½²å¤æ‚ã€‚åŒæ—¶æ³¨æ„ä¸åŒ CUDA ç‰ˆæœ¬é—´çš„å…¼å®¹æ€§é—®é¢˜ã€‚

* * *

å››ã€æ ¸å¿ƒæ¶æ„è®¾è®¡
--------

### 4.1 ä¸‰å±‚æ¶æ„

TensorRtSharp é‡‡ç”¨æ¸…æ™°çš„ä¸‰å±‚æ¶æ„è®¾è®¡ï¼š

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           ä¸šåŠ¡ API å±‚ (High-Level API)                   â”‚
    â”‚  Runtime, Builder, CudaEngine, ExecutionContext         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â–²
                               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         èµ„æºç®¡ç†å±‚ (Resource Management)                 â”‚
    â”‚  DisposableTrtObject, DisposableObject, IOvPtrHolder    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â–²
                               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         P/Invoke å±‚ (Native Interop)                    â”‚
    â”‚  NativeMethodsTensorRt*, NativeMethodsCuda*             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    

### 4.2 è‡ªåŠ¨èµ„æºç®¡ç†

TensorRtSharp å®ç°äº†å®Œå–„çš„èµ„æºç®¡ç†æœºåˆ¶ï¼Œæ‰€æœ‰ TensorRT å¯¹è±¡éƒ½ç»§æ‰¿è‡ª `DisposableTrtObject`ï¼š

    // æ‰€æœ‰ TensorRT å¯¹è±¡ç»§æ‰¿è‡ª DisposableTrtObject
    public abstract class DisposableTrtObject : DisposableObject
    {
        protected IntPtr ptr;                      // åŸç”Ÿå¯¹è±¡æŒ‡é’ˆ
        public bool IsDisposed { get; protected set; }
    
        // å®‰å…¨è®¿é—®åŸç”ŸæŒ‡é’ˆï¼ˆè‡ªåŠ¨æ£€æŸ¥é‡Šæ”¾çŠ¶æ€ï¼‰
        public IntPtr TrtPtr
        {
            get
            {
                ThrowIfDisposed();
                return ptr;
            }
        }
    
        // é‡Šæ”¾éæ‰˜ç®¡èµ„æº
        protected override void DisposeUnmanaged()
        {
            if (ptr != IntPtr.Zero)
            {
                // è°ƒç”¨åŸç”Ÿé‡Šæ”¾å‡½æ•°
                NativeDestroy(ptr);
                ptr = IntPtr.Zero;
            }
        }
    }
    
    // ä½¿ç”¨ using è¯­å¥è‡ªåŠ¨é‡Šæ”¾èµ„æº
    using Runtime runtime = new Runtime();
    using CudaEngine engine = runtime.deserializeCudaEngineByBlob(data, size);
    // ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾
    

**è®¾è®¡äº®ç‚¹**ï¼š

*   âœ… é‡‡ç”¨æ ‡å‡† Dispose æ¨¡å¼ï¼Œç¡®ä¿èµ„æºæ­£ç¡®é‡Šæ”¾
*   âœ… çº¿ç¨‹å®‰å…¨çš„èµ„æºé‡Šæ”¾æœºåˆ¶ï¼ˆä½¿ç”¨ `Interlocked.Exchange`ï¼‰
*   âœ… è‡ªåŠ¨å†…å­˜å‹åŠ›é€šçŸ¥ï¼ˆ`GC.AddMemoryPressure`ï¼‰
*   âœ… æŒ‡é’ˆå®‰å…¨è®¿é—®ï¼ˆ`ThrowIfDisposed` æ£€æŸ¥ï¼‰

* * *

äº”ã€æ ¸å¿ƒç±»ä¸ API
----------

### 5.1 å‘½åç©ºé—´

åœ¨ä½¿ç”¨ TensorRtSharp ä¹‹å‰ï¼Œé¦–å…ˆå¼•å…¥å¿…è¦çš„å‘½åç©ºé—´ï¼š

    using JYPPX.TensorRtSharp.Cuda;      // CUDA æ¥å£çš„ç¨‹åºé›†å‘½åç©ºé—´
    using JYPPX.TensorRtSharp.Nvinfer;   // TensorRT æ¥å£çš„ç¨‹åºé›†å‘½åç©ºé—´
    

### 5.2 Runtimeï¼ˆæ¨ç†è¿è¡Œæ—¶ï¼‰

Runtime æ˜¯ TensorRT æ¨ç†çš„å…¥å£ç‚¹ï¼Œè´Ÿè´£ä»åºåˆ—åŒ–çš„å¼•æ“æ–‡ä»¶åˆ›å»ºæ¨ç†å¼•æ“ã€‚

    // åˆ›å»º Runtime å®ä¾‹
    Runtime runtime = new Runtime();
    string filePath = "yolov8s-obb.engine";
    
    // ä»å­—èŠ‚æ•°ç»„ååºåˆ—åŒ–å¼•æ“
    byte[] data = File.ReadAllBytes(filePath);
    using CudaEngine cudaEngine = runtime.deserializeCudaEngineByBlob(data, (ulong)data.Length);
    
    // ä»æ–‡ä»¶æµååºåˆ—åŒ–
    using var reader = new FileStreamReader();
    reader.open(filePath);
    using CudaEngine cudaEngine = runtime.deserializeCudaEngineByFileStreamReader(reader);
    
    // é…ç½® DLAï¼ˆæ·±åº¦å­¦ä¹ åŠ é€Ÿå™¨ï¼‰
    runtime.setDLACore(0);  // ä½¿ç”¨ DLA æ ¸å¿ƒ 0
    int dlaCores = runtime.getNbDLACores();
    
    // è®¾ç½®æœ€å¤§çº¿ç¨‹æ•°
    runtime.setMaxThreads(4);
    

**ä¸»è¦ç”¨é€”**ï¼š

*   ååºåˆ—åŒ– TensorRT å¼•æ“æ–‡ä»¶
*   é…ç½® DLA åŠ é€Ÿå™¨
*   åŠ è½½æ’ä»¶åº“

### 5.3 Builderï¼ˆæ¨¡å‹æ„å»ºå™¨ï¼‰

Builder ç”¨äºä» ONNX æ¨¡å‹æ„å»º TensorRT å¼•æ“ã€‚

    using Builder builder = new Builder();
    
    // æŸ¥è¯¢å¹³å°èƒ½åŠ›
    bool hasFP16 = builder.platformHasFastFp16();  // æ˜¯å¦æ”¯æŒ FP16
    bool hasINT8 = builder.platformHasFastInt8();  // æ˜¯å¦æ”¯æŒ INT8
    int maxDLABatch = builder.maxDLABatchSize();   // DLA æœ€å¤§æ‰¹å¤§å°
    
    // åˆ›å»ºç½‘ç»œå®šä¹‰ï¼ˆæ˜¾å¼æ‰¹å¤„ç†æ¨¡å¼ï¼‰
    using NetworkDefinition network = builder.createNetworkV2(
        TrtNetworkDefinitionCreationFlag.kEXPLICIT_BATCH);
    
    // åˆ›å»ºæ„å»ºå™¨é…ç½®
    using BuilderConfig config = builder.createBuilderConfig();
    
    // åˆ›å»ºä¼˜åŒ–é…ç½®æ–‡ä»¶ï¼ˆç”¨äºåŠ¨æ€å½¢çŠ¶ï¼‰
    using OptimizationProfile profile = builder.createOptimizationProfile();
    
    // æ„å»ºåºåˆ—åŒ–ç½‘ç»œ
    using HostMemory serialized = builder.buildSerializedNetwork(network, config);
    
    // ä¿å­˜å¼•æ“æ–‡ä»¶
    using (FileStream fs = new FileStream("model.engine", FileMode.Create, FileAccess.Write))
    {
        fs.Write(serialized.getByteData(), 0, (int)serialized.Size);
    }
    

**ä¸»è¦ç”¨é€”**ï¼š

*   åˆ›å»ºç½‘ç»œå®šä¹‰å’Œæ„å»ºé…ç½®
*   æŸ¥è¯¢ç¡¬ä»¶èƒ½åŠ›ï¼ˆFP16ã€INT8ã€DLAï¼‰
*   æ„å»º TensorRT å¼•æ“
*   æ³¨å†Œè‡ªå®šä¹‰æ’ä»¶

### 5.4 CudaEngineï¼ˆæ¨ç†å¼•æ“ï¼‰

CudaEngine æ˜¯æ¨ç†çš„æ ¸å¿ƒå¯¹è±¡ï¼ŒåŒ…å«ä¼˜åŒ–åçš„æ¨¡å‹è®¡ç®—å›¾ã€‚

    // è·å–å¼ é‡ä¿¡æ¯
    int numTensors = engine.getNbIOTensors();
    string inputName = engine.getIOTensorName(0);    // è¾“å…¥å¼ é‡åç§°
    string outputName = engine.getIOTensorName(1);   // è¾“å‡ºå¼ é‡åç§°
    
    Dims inputShape = engine.getTensorShape(inputName);
    TrtDataType inputType = engine.getTensorDataType(inputName);
    
    // åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
    using ExecutionContext context = engine.createExecutionContext();
    using ExecutionContext contextStatic = engine.createExecutionContext(
        TrtExecutionContextAllocationStrategy.kSTATIC);
    
    // åºåˆ—åŒ–å¼•æ“
    using HostMemory memory = engine.serialize();
    
    // æŸ¥è¯¢å¼•æ“å±æ€§
    int numLayers = engine.getNbLayers();
    string name = engine.getName();
    long deviceMemory = engine.getDeviceMemorySize();
    

**ä¸»è¦ç”¨é€”**ï¼š

*   æŸ¥è¯¢æ¨¡å‹è¾“å…¥è¾“å‡ºä¿¡æ¯
*   åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
*   åºåˆ—åŒ–å¼•æ“
*   æ€§èƒ½åˆ†æ

### 5.5 ExecutionContextï¼ˆæ‰§è¡Œä¸Šä¸‹æ–‡ï¼‰

ExecutionContext ç®¡ç†å•æ¬¡æ¨ç†çš„æ‰§è¡Œç¯å¢ƒï¼Œæ”¯æŒå¼‚æ­¥æ¨ç†å’ŒåŠ¨æ€å½¢çŠ¶ã€‚

    // ç»‘å®šå¼ é‡åœ°å€
    Cuda1DMemory<float> input = new Cuda1DMemory<float>(3 * 1024 * 1024);
    Cuda1DMemory<float> output = new Cuda1DMemory<float>(1 * 20 * 21504);
    context.setInputTensorAddress("images", input.get());
    context.setOutputTensorAddress("output0", output.get());
    
    // è®¾ç½®åŠ¨æ€å½¢çŠ¶
    context.setinputShape("images", new Dims(1, 3, 1024, 1024));
    Dims shape = context.getTensorShape("images");
    
    // æ‰§è¡Œæ¨ç†ï¼ˆå¼‚æ­¥ï¼Œä½¿ç”¨ CUDA Streamï¼‰
    using CudaStream stream = new CudaStream();
    context.executeV3(stream);
    stream.Synchronize();  // ç­‰å¾…å®Œæˆ
    
    // è®¾ç½®ä¼˜åŒ–é…ç½®æ–‡ä»¶ï¼ˆåŠ¨æ€å½¢çŠ¶ï¼‰
    context.setOptimizationProfileAsync(0, stream);
    
    // è°ƒè¯•åŠŸèƒ½
    context.setDebugSync(true);
    

**ä¸»è¦ç”¨é€”**ï¼š

*   ç»‘å®šè¾“å…¥è¾“å‡ºå¼ é‡
*   è®¾ç½®åŠ¨æ€å½¢çŠ¶
*   æ‰§è¡Œæ¨ç†ï¼ˆå¼‚æ­¥ï¼‰
*   æ€§èƒ½åˆ†æå’Œè°ƒè¯•

### 5.6 OnnxParserï¼ˆONNX è§£æå™¨ï¼‰

OnnxParser å°† ONNX æ¨¡å‹è½¬æ¢ä¸º TensorRT ç½‘ç»œå®šä¹‰ã€‚

    // è§£æ ONNX æ–‡ä»¶
    using NetworkDefinition network = build.createNetworkV2(TrtNetworkDefinitionCreationFlag.kEXPLICIT_BATCH);
    using OnnxParser parser = new OnnxParser(network);
    bool success = parser.parseFromFile("yolov8s-obb.onnx", verbosity: 2);
    
    // æ£€æŸ¥ç®—å­æ”¯æŒ
    bool supportsConv = parser.supportsOperator("Conv");
    
    // å­å›¾æ”¯æŒ
    long numSubgraphs = parser.getNbSubgraphs();
    bool supported = parser.isSubgraphSupported(0);
    long[] nodes = parser.getSubgraphNodes(0);
    
    // è®¾ç½®è§£æå™¨æ ‡å¿—
    parser.setFlag(TrtOnnxParserFlag.kNATIVE_INSTANCENORM);
    

**ä¸»è¦ç”¨é€”**ï¼š

*   è§£æ ONNX æ¨¡å‹
*   æ£€æŸ¥ç®—å­æ”¯æŒ
*   å¤„ç†å­å›¾

### 5.7 CUDA å†…å­˜ç®¡ç†

#### ï¼ˆ1ï¼‰è®¾å¤‡å†…å­˜ï¼ˆCuda1DMemoryï¼‰

    // åˆ›å»ºè®¾å¤‡å†…å­˜
    using Cuda1DMemory<float> input = new Cuda1DMemory<float>(1000);
    ulong numElements = input.SizeElements;
    ulong numBytes = input.SizeBytes;
    IntPtr ptr = input.DevicePointer;
    
    // åŒæ­¥æ•°æ®ä¼ è¾“
    float[] hostData = new float[1000];
    input.copyFromHost(hostData);   // ä¸»æœº â†’ è®¾å¤‡
    input.copyToHost(hostData);      // è®¾å¤‡ â†’ ä¸»æœº
    
    // å¼‚æ­¥æ•°æ®ä¼ è¾“
    using CudaStream stream = new CudaStream();
    input.copyFromHostAsync(hostData, stream);
    input.copyToHostAsync(hostData, stream);
    
    // å†…å­˜æ“ä½œ
    input.memset(0);                 // å¡«å……ä¸º 0
    input.memsetAsync(0, stream);    // å¼‚æ­¥å¡«å……
    

#### ï¼ˆ2ï¼‰CUDA æµï¼ˆCudaStreamï¼‰

    // åˆ›å»ºæµï¼ˆå¸¦ä¼˜å…ˆçº§ï¼‰
    using CudaStream stream = new CudaStream();
    using CudaStream streamHigh = new CudaStream(0, -1);  // é«˜ä¼˜å…ˆçº§
    
    // åŒæ­¥æ“ä½œ
    stream.Synchronize();  // ç­‰å¾…æµå®Œæˆ
    bool isComplete = stream.Query();  // æŸ¥è¯¢æ˜¯å¦å®Œæˆ
    
    // äº‹ä»¶ä¾èµ–
    using CudaEvent cudaEvent = new CudaEvent();
    stream.WaitEvent(cudaEvent);  // ç­‰å¾…äº‹ä»¶
    
    // æ·»åŠ å›è°ƒ
    stream.AddCallback((streamPtr, statue, userData) =>
    {
        Console.WriteLine("Stream callback executed");
    }, IntPtr.Zero, 0);
    
    // CUDA Graph æ•è·
    stream.BeginCapture(CudaStreamCaptureMode.Global);
    // ... æ‰§è¡Œæ“ä½œ ...
    CudaGraph_t graph = stream.EndCapture();
    

#### ï¼ˆ3ï¼‰CUDA è®¾å¤‡ï¼ˆCudaDeviceï¼‰

    // è·å–ç³»ç»Ÿä¸­å¯ç”¨çš„ CUDA å…¼å®¹è®¾å¤‡çš„æ•°é‡
    int nbDevices = CudaDevice.GetDeviceCount();
    
    // è·å–æŒ‡å®šè®¾å¤‡çš„å±æ€§
    CudaDeviceProp properties = CudaDevice.GetDeviceProperties(deviceIdx);
    
    // è®¾ç½®æ‰§è¡Œè®¾å¤‡
    CudaDevice.SetDevice(device);
    
    // è·å–æœ‰å…³è®¾å¤‡çš„è¯·æ±‚ä¿¡æ¯
    int clockRate = CudaDevice.GetAttribute(CudaDeviceAttr.ClockRate, device);
    

* * *

å…­ã€å®Œæ•´ä½¿ç”¨ç¤ºä¾‹
--------

### ç¤ºä¾‹ 1ï¼šè·å–å’Œè®¾ç½®è®¾å¤‡ä¿¡æ¯

ä¸‹é¢çš„ä»£ç å¯ä»¥è·å–å½“å‰è®¾å¤‡çš„ç›¸å…³ä¿¡æ¯ï¼ŒåŒæ—¶å¯ä»¥è®¾ç½®æ¨ç†è®¾å¤‡ã€‚

    using JYPPX.TensorRtSharp.Cuda;
    using JYPPX.TensorRtSharp.Nvinfer;
    
    namespace TestDemo
    {
        internal class Program
        {
            static void Main(string[] args)
            {
                // æŒ‡å®šé»˜è®¤ä½¿ç”¨çš„ GPU è®¾å¤‡ç´¢å¼•
                // åœ¨å¤š GPU ç¯å¢ƒä¸‹ï¼Œå¯ä»¥é€šè¿‡ä¿®æ”¹æ­¤å˜é‡æ¥é€‰æ‹©ç‰¹å®šçš„æ˜¾å¡
                int device = 0;
    
                // è®°å½•æ—¥å¿—ï¼Œæ ‡è®°è®¾å¤‡ä¿¡æ¯æŸ¥è¯¢çš„å¼€å§‹
                Logger.Instance.INFO("=== Device Information ===");
    
                // è·å–å½“å‰ç³»ç»Ÿä¸­å¯è§çš„ NVIDIA GPU æ•°é‡
                int nbDevices = CudaDevice.GetDeviceCount();
    
                // æ£€æŸ¥ç³»ç»Ÿä¸­æ˜¯å¦å­˜åœ¨å¯ç”¨çš„ GPU è®¾å¤‡
                if (nbDevices <= 0)
                {
                    Logger.Instance.ERROR("Cannot find any available devices (GPUs)!");
                    Environment.Exit(0);
                }
    
                // æ‰“å°æ‰€æœ‰å¯ç”¨è®¾å¤‡çš„åˆ—è¡¨
                Logger.Instance.INFO("Available Devices: ");
    
                // éå†ç³»ç»Ÿä¸­çš„æ¯ä¸€ä¸ª GPU
                for (int deviceIdx = 0; deviceIdx < nbDevices; ++deviceIdx)
                {
                    // è·å–ç´¢å¼•ä¸º deviceIdx çš„ GPU çš„è¯¦ç»†å±æ€§
                    CudaDeviceProp tempProperties = CudaDevice.GetDeviceProperties(deviceIdx);
    
                    // æ‰“å°è®¾å¤‡ IDã€è®¾å¤‡åç§°ä»¥åŠ UUID (å”¯ä¸€æ ‡è¯†ç¬¦)
                    Logger.Instance.INFO($"  Device {deviceIdx}: \"{tempProperties.Name}\" UUID: {GetUuidString(tempProperties.Uuid)}");
    
                    // å¦‚æœå½“å‰éå†åˆ°çš„è®¾å¤‡ ID æ˜¯æˆ‘ä»¬æƒ³è¦ä½¿ç”¨çš„ç›®æ ‡è®¾å¤‡
                    // åˆ™å°†è¯¥è®¾å¤‡çš„å±æ€§ä¿å­˜ä¸‹æ¥ï¼Œä¾›åç»­ä½¿ç”¨
                    if (deviceIdx == device)
                    {
                        properties = tempProperties;
                    }
                }
    
                // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿è¯·æ±‚çš„ç›®æ ‡è®¾å¤‡ ID åœ¨æœ‰æ•ˆèŒƒå›´å†…
                if (device < 0 || device >= nbDevices)
                {
                    Logger.Instance.ERROR($"Cannot find device ID {device}!");
                    Environment.Exit(0);
                }
    
                // å°† CUDA ä¸Šä¸‹æ–‡è®¾ç½®åˆ°æŒ‡å®šçš„ GPU è®¾å¤‡ä¸Š
                CudaDevice.SetDevice(device);
    
                // æ‰“å°é€‰å®šè®¾å¤‡çš„è¯¦ç»†ä¿¡æ¯
                Logger.Instance.INFO($"Selected Device: {properties.Name}");
                Logger.Instance.INFO($"Selected Device ID: {device}");
                Logger.Instance.INFO($"Selected Device UUID: {GetUuidString(properties.Uuid)}");
                Logger.Instance.INFO($"Compute Capability: {properties.Major}.{properties.Minor}");
                Logger.Instance.INFO($"SMs: {properties.MultiProcessorCount}");
                Logger.Instance.INFO($"Device Global Memory: {(properties.TotalGlobalMem + 20)} MiB");
                Logger.Instance.INFO($"Shared Memory per SM: {(properties.SharedMemPerMultiprocessor >> 10)} KiB");
                Logger.Instance.INFO($"Memory Bus Width: {properties.MemoryBusWidth} bits (ECC {(properties.ECCEnabled != 0 ? "enabled" : "disabled")})");
    
                // è·å–å¹¶æ‰“å° GPU æ ¸å¿ƒæ—¶é’Ÿé¢‘ç‡å’Œæ˜¾å­˜æ—¶é’Ÿé¢‘ç‡
                int clockRate = CudaDevice.GetAttribute(CudaDeviceAttr.ClockRate, device);
                int memoryClockRate = CudaDevice.GetAttribute(CudaDeviceAttr.MemoryClockRate, device);
    
                Logger.Instance.INFO($"Application Compute Clock Rate: {clockRate / 1000000.0F} GHz");
                Logger.Instance.INFO($"Application Memory Clock Rate: {memoryClockRate / 1000000.0F} GHz");
            }
    
            /// <summary>
            /// è¾…åŠ©æ–¹æ³•ï¼šå°† CudaUUID ç»“æ„ä½“è½¬æ¢ä¸ºæ ¼å¼åŒ–çš„ GPU UUID å­—ç¬¦ä¸²
            /// æ ¼å¼é€šå¸¸ä¸ºï¼šGPU-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
            /// </summary>
            public static string GetUuidString(CudaUUID uuid)
            {
                int kUUID_SIZE = uuid.Bytes.Length;
                var ss = new System.Text.StringBuilder();
    
                // å®šä¹‰ UUID çš„åˆ†æ®µç‚¹ï¼Œç”¨äºæ’å…¥è¿å­—ç¬¦ "-"
                int[] splits = { 0, 4, 6, 8, 10, kUUID_SIZE };
    
                // æ·»åŠ å›ºå®šçš„ "GPU" å‰ç¼€
                ss.Append("GPU");
    
                // éå†åˆ†æ®µå®šä¹‰ï¼Œæ ¼å¼åŒ–æ¯ä¸€éƒ¨åˆ†çš„å­—èŠ‚
                for (int splitIdx = 0; splitIdx < splits.Length - 1; ++splitIdx)
                {
                    ss.Append("-");
                    for (int byteIdx = splits[splitIdx]; byteIdx < splits[splitIdx + 1]; ++byteIdx)
                    {
                        ss.AppendFormat("{0:x2}", uuid.Bytes[byteIdx]);
                    }
                }
    
                return ss.ToString();
            }
        }
    }
    

**ç¨‹åºè¿è¡Œç»“æœï¼š**

> **ğŸ’¡ æ³¨æ„**ï¼šä¸åŒçš„è®¾å¤‡è¾“å‡ºä¼šæœ‰ä¸åŒï¼Œä»¥å…·ä½“è®¾å¤‡è¾“å‡ºä¸ºå‡†ã€‚
> 
> ğŸ”—**ç¨‹åºè·¯å¾„é“¾æ¥**ï¼šå®Œæ•´ç¨‹åºå·²ç»ä¸Šä¼ åˆ°GitHubï¼Œè¯·è‡ªè¡Œä¸‹è½½ï¼Œé“¾æ¥ä¸ºï¼š
> 
>     https://github.com/guojin-yan/TensorRT-CSharp-API/tree/TensorRtSharp3.0/samples/SetCudaDeviceInfo
>     

* * *

### ç¤ºä¾‹ 2ï¼šONNX è½¬ Engine æ¨¡å‹

ä¸‹é¢æ˜¯æŒ‰ç…§å®˜æ–¹æ¨¡å‹è½¬æ¢ä»£ç ç¼–å†™çš„ä¸€ä¸ªç®€å•çš„è½¬æ¢ä»£ç ï¼š

    using JYPPX.TensorRtSharp.Cuda;
    using JYPPX.TensorRtSharp.Nvinfer;
    
    namespace OnnxToEngine
    {
        internal class Program
        {
            static void Main(string[] args)
            {
                // === é…ç½® TensorRT æ—¥å¿—å›è°ƒ ===
                // å®šä¹‰ä¸€ä¸ªå§”æ‰˜ï¼Œç”¨äºå¤„ç† TensorRT å†…éƒ¨äº§ç”Ÿçš„æ—¥å¿—æ¶ˆæ¯
                LogCallbackFunction _callbackDelegate = (message) =>
                {
                    Console.WriteLine(message);
                };
    
                // å°†è‡ªå®šä¹‰çš„å›è°ƒå‡½æ•°æ³¨å†Œç»™ TensorRT çš„å…¨å±€ Logger å®ä¾‹
                Logger.Instance.SetCallback(_callbackDelegate);
    
                // è®¾ç½®æ—¥å¿—çš„ä¸¥é‡æ€§çº§åˆ«é˜ˆå€¼
                // LoggerSeverity.kINFO: æ‰“å°ä¿¡æ¯ã€è­¦å‘Šå’Œé”™è¯¯
                Logger.Instance.SetThreshold(LoggerSeverity.kINFO);
    
                // 1. åˆ›å»º TensorRT Builder (æ„å»ºå™¨)
                Builder build = new Builder();
    
                // 2. åˆ›å»ºç½‘ç»œå®šä¹‰ (Network Definition)
                // æ˜¾å¼æ‰¹å¤„ç† æ ‡å¿—è¡¨ç¤ºç½‘ç»œå®šä¹‰ä¸­æ˜¾å¼åŒ…å«æ‰¹å¤„ç†ç»´åº¦
                NetworkDefinition networkDefinition = build.createNetworkV2(TrtNetworkDefinitionCreationFlag.kEXPLICIT_BATCH);
    
                // 3. åˆ›å»ºæ„å»ºå™¨é…ç½®
                BuilderConfig builderConfig = build.createBuilderConfig();
    
                // 4. åˆ›å»º ONNX è§£æå™¨
                OnnxParser onnxParser = new OnnxParser(networkDefinition);
    
                // æŒ‡å®šå¾…è½¬æ¢çš„ ONNX æ¨¡å‹æ–‡ä»¶è·¯å¾„
                string modelpath = "yolo11s-obb.onnx";
    
                // 5. è§£æ ONNX æ¨¡å‹æ–‡ä»¶
                // å‚æ•° 2: æ—¥å¿—çº§åˆ« (1=ERROR, 2=WARNING, 3=INFO, 4=VERBOSE)
                if (onnxParser.parseFromFile(modelpath, 2) == false)
                {
                    Console.WriteLine($"parse onnx model failed");
                    return;
                }
    
                // 6. è®¾ç½®æ„å»ºç²¾åº¦æ ‡å¿—
                // kFP16: å¯ç”¨åŠç²¾åº¦ (FP16) æ¨ç†æ¨¡å¼
                builderConfig.setFlag(TrtBuilderFlag.kFP16);
    
                // 7. åˆ›å»º CUDA æµ
                CudaStream cudaStream = new CudaStream();
    
                // 8. è®¾ç½®ä¼˜åŒ–é…ç½®æ–‡ä»¶çš„æµ
                builderConfig.setProfileStream(cudaStream);
    
                // 9. æ„å»ºå¹¶åºåˆ—åŒ–ç½‘ç»œ
                // è¿™æ˜¯ä¸€ä¸ªè€—æ—¶è¾ƒé•¿çš„è¿‡ç¨‹ï¼Œå› ä¸º TensorRT ä¼šè¿›è¡Œå†…æ ¸è‡ªåŠ¨è°ƒä¼˜ã€å±‚èåˆç­‰ä¼˜åŒ–
                HostMemory hostMemory = build.buildSerializedNetwork(networkDefinition, builderConfig);
    
                // 10. ä¿å­˜ Engine åˆ°ç£ç›˜
                string filePath = "yolo11s-obb.engine";
                using (FileStream fs = new FileStream(filePath, FileMode.Create, FileAccess.Write))
                {
                    fs.Write(hostMemory.getByteData(), 0, (int)hostMemory.Size);
                }
    
                Console.WriteLine("Engine saved successfully!");
            }
        }
    }
    

**ç¨‹åºè¿è¡Œç»“æœï¼š**

> ğŸ”—**ç¨‹åºè·¯å¾„é“¾æ¥**ï¼šå®Œæ•´ç¨‹åºå·²ç»ä¸Šä¼ åˆ°GitHubï¼Œè¯·è‡ªè¡Œä¸‹è½½ï¼Œé“¾æ¥ä¸ºï¼š
> 
>     https://github.com/guojin-yan/TensorRT-CSharp-API/tree/TensorRtSharp3.0/samples/OnnxToEngine
>     

* * *

### ğŸ’¡ ä½¿ç”¨ trtexec å·¥å…·è½¬æ¢æ¨¡å‹ï¼ˆæ¨èï¼‰

å½“å‰ ONNX è½¬ Engine ä»£ç ç”±äºæ²¡æœ‰è¿›è¡Œä¼˜åŒ–ï¼Œè½¬æ¢é€Ÿåº¦ä¼šè¾ƒæ…¢ã€‚**å»ºè®®ä½¿ç”¨ TensorRT SDK è‡ªå¸¦çš„ `trtexec.exe` å·¥å…·è½¬æ¢æ¨¡å‹**ã€‚

#### trtexec ä½¿ç”¨æ–¹å¼

**ï¼ˆ1ï¼‰ä½¿ç”¨ CMD åˆ‡æ¢åˆ°å·¥å…·ç›®å½•**

è¯¥å·¥å…·å­˜æ”¾åœ¨ä¸‹è½½çš„ TensorRT åº“ä¸­ï¼š

æ‰“å¼€ CMD å¹¶åˆ‡æ¢åˆ°è¯¥è·¯å¾„ï¼š

**ï¼ˆ2ï¼‰å›ºå®šå½¢çŠ¶æ¨¡å‹è½¬æ¢æŒ‡ä»¤**

å¯¹äºå½¢çŠ¶å›ºå®šçš„æ¨¡å‹ï¼Œç›´æ¥è¾“å…¥å¸¸è§„æŒ‡ä»¤è½¬æ¢å³å¯ï¼š

    trtexec.exe --onnx=yolov8s-obb.onnx --saveEngine=yolov8s-obb.engine --fp16 --workspace=1024
    

**å‚æ•°è¯´æ˜ï¼š**

*   `--onnx=yolov8s-obb.onnx`ï¼šæŒ‡å®šè¾“å…¥çš„ ONNX æ¨¡å‹æ–‡ä»¶è·¯å¾„
*   `--saveEngine=yolov8s-obb.engine`ï¼šæŒ‡å®šè¾“å‡ºçš„ Engine æ–‡ä»¶ä¿å­˜è·¯å¾„
*   `--fp16`ï¼šå¯ç”¨ FP16 ç²¾åº¦ï¼ˆå¯é€‰ï¼‰
*   `--workspace=1024`ï¼šæŒ‡å®šæœ€å¤§å·¥ä½œç©ºé—´ï¼Œå•ä½ MBï¼ˆå¯é€‰ï¼‰

**ï¼ˆ3ï¼‰åŠ¨æ€å½¢çŠ¶æ¨¡å‹è½¬æ¢æŒ‡ä»¤**

å¯¹äºè¾“å…¥å½¢çŠ¶æ˜¯åŠ¨æ€çš„æƒ…å†µï¼Œè½¬æ¢æ—¶è¦è®¾ç½®å½¢çŠ¶å‚æ•°ï¼š

    trtexec.exe --onnx=yolov8s-obb_b.onnx --saveEngine=yolov8s-obb_b.engine --fp16 --minShapes=images:1x3x1024x1024 --optShapes=images:8x3x1024x1024 --maxShapes=images:24x3x1024x1024
    

**å‚æ•°è¯´æ˜ï¼š**

*   `--minShapes=images:1x3x1024x1024`ï¼šæœ€å°è¾“å…¥å½¢çŠ¶
*   `--optShapes=images:8x3x1024x1024`ï¼šæœ€ä¼˜è¾“å…¥å½¢çŠ¶ï¼ˆEngine ä¼šä¸ºæ­¤å½¢çŠ¶ä¼˜åŒ–ï¼‰
*   `--maxShapes=images:24x3x1024x1024`ï¼šæœ€å¤§è¾“å…¥å½¢çŠ¶

**å¤šè¾“å…¥æ¨¡å‹è½¬æ¢æŒ‡ä»¤ï¼š**

    trtexec --onnx=model.onnx --minShapes=input1:1x3x224x224,input2:1x256 --optShapes=input1:4x3x224x224,input2:4x256 --maxShapes=input1:8x3x224x224,input2:8x256
    

* * *

### ç¤ºä¾‹ 3ï¼šYOLO ç›®æ ‡æ£€æµ‹

ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„ YOLO ç›®æ ‡æ£€æµ‹ç¤ºä¾‹ï¼Œå±•ç¤ºä»æ¨¡å‹æ„å»ºåˆ°æ¨ç†çš„å…¨æµç¨‹ã€‚

> **âš ï¸ ç”±äºä»£ç è¾ƒé•¿ï¼Œæ­¤å¤„ä»…å±•ç¤ºæ ¸å¿ƒæ€è·¯ã€‚å®Œæ•´ä»£ç è¯·å‚è€ƒé¡¹ç›®ç¤ºä¾‹ã€‚**

    using JYPPX.TensorRtSharp.Cuda;
    using JYPPX.TensorRtSharp.Nvinfer;
    using OpenCvSharp;
    using OpenCvSharp.Dnn;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    
    namespace YoloDetInfer
    {
        internal class Program
        {
            // ================= é…ç½®å‚æ•° =================
            // æ¨¡å‹è¾“å…¥å°ºå¯¸ (å®½=é«˜)
            private const int InputSize = 640;
    
    
            // å»ºè®®æ ¹æ®å®é™…æ¨¡å‹åŠ¨æ€è·å–æˆ–ä½¿ç”¨ Netron æŸ¥çœ‹
            private const int OutputSize = 8400;
    
            // æ¨¡å‹ç±»åˆ«æ•° (æ ¹æ®æ‚¨çš„å…·ä½“æ•°æ®é›†ä¿®æ”¹ï¼Œæ­¤å¤„å‡è®¾ä¸º15ç±»)
            private const int CategoryNum = 80;
    
            // ç½®ä¿¡åº¦é˜ˆå€¼
            private const float ConfThreshold = 0.25f;
    
            // NMS IOU é˜ˆå€¼
            private const float NmsThreshold = 0.3f;
    
            static void Main(string[] args)
            {
                //  ============= é…ç½® TensorRT æ—¥å¿—å›è°ƒ =============
                // å®šä¹‰ä¸€ä¸ªå§”æ‰˜ï¼Œç”¨äºå¤„ç† TensorRT å†…éƒ¨äº§ç”Ÿçš„æ—¥å¿—æ¶ˆæ¯ã€‚
                // è¿™å…è®¸æˆ‘ä»¬å°† C++ å±‚é¢çš„æ—¥å¿—è¾“å‡ºåˆ° C# çš„æ§åˆ¶å°ã€‚
                LogCallbackFunction _callbackDelegate = (message) =>
                {
                    Console.WriteLine(message);
                };
    
                // å°†è‡ªå®šä¹‰çš„å›è°ƒå‡½æ•°æ³¨å†Œç»™ TensorRT çš„å…¨å±€ Logger å®ä¾‹ã€‚
                Logger.Instance.SetCallback(_callbackDelegate);
    
                // è®¾ç½®æ—¥å¿—çš„ä¸¥é‡æ€§çº§åˆ«é˜ˆå€¼ã€‚
                // LoggerSeverity.kINFO: æ‰“å°ä¿¡æ¯ã€è­¦å‘Šå’Œé”™è¯¯ã€‚
                // å¼€å‘è°ƒè¯•é˜¶æ®µé€šå¸¸è®¾ä¸º kINFO æˆ– kVERBOSEï¼›ç”Ÿäº§ç¯å¢ƒå¯è®¾ä¸º kWARNING æˆ– kERROR ä»¥å‡å°‘è¾“å‡ºã€‚
                Logger.Instance.SetThreshold(LoggerSeverity.kINFO);
    
                string enginePath = "yolov8s.engine";
                string imagePath = "bus.jpg";
    
    
                // ================= 1. åŠ è½½ TensorRT Engine =================
                // ä½¿ç”¨ using è¯­å¥ç¡®ä¿æ–‡ä»¶æµæ­£ç¡®å…³é—­
                byte[] engineData;
                using (FileStream fs = new FileStream(enginePath, FileMode.Open, FileAccess.Read))
                using (BinaryReader br = new BinaryReader(fs))
                {
                    engineData = br.ReadBytes((int)fs.Length);
                }
    
                // ååºåˆ—åŒ– Engine
                // Runtime å¿…é¡»åœ¨ Engine ç”Ÿå‘½å‘¨æœŸå†…ä¿æŒå­˜æ´»ï¼Œé€šå¸¸å»ºè®®è®¾ä¸ºå…¨å±€æˆ–é™æ€ï¼Œæˆ–è€…ç¡®ä¿å®ƒæœ€åé‡Šæ”¾
                Runtime runtime = new Runtime();
    
                // åˆ›å»º CudaEngine (æ­¤å¤„ä½¿ç”¨ using ç¡®ä¿æ¨ç†å®Œæˆåå¼•æ“è¢«é”€æ¯)
                using (CudaEngine cudaEngine = runtime.deserializeCudaEngineByBlob(engineData, (ulong)engineData.Length))
                {
                    // ================= 2. åˆå§‹åŒ–æ¨ç†ä¸Šä¸‹æ–‡ä¸æ˜¾å­˜ =================
                    // åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
                    using (JYPPX.TensorRtSharp.Nvinfer.ExecutionContext executionContext = cudaEngine.createExecutionContext(TrtExecutionContextAllocationStrategy.kSTATIC))
                    using (CudaStream cudaStream = new CudaStream()) // åˆ›å»º CUDA æµç”¨äºå¼‚æ­¥æ‰§è¡Œ
                    {
                        // è·å–è¾“å…¥ç»´åº¦ä¿¡æ¯ (ç”¨äºæ ¡éªŒ)
                        Dims inputDims = executionContext.getTensorShape("images");
                        Logger.Instance.INFO($"Input Shape: {inputDims.d[0]}x{inputDims.d[1]}x{inputDims.d[2]}x{inputDims.d[3]}");
    
                        // è®¡ç®—æ‰€éœ€æ˜¾å­˜å¤§å°
                        // è¾“å…¥: Batch=1, Channel=3, Height=640, Width=640
                        ulong inputSizeInBytes = 1 * 3 * InputSize * InputSize;
                        // è¾“å‡º: Batch=1, Channels=CategoryNum+4(box)+1(angle), Num=8400
                        int outputChannels = CategoryNum + 4; // 4åæ ‡ + Nç±»åˆ«
                        ulong outputSizeInBytes = (ulong)(1 * outputChannels * OutputSize);
    
                        Stopwatch sw = new Stopwatch();
                        // åˆ†é… GPU æ˜¾å­˜
                        using (Cuda1DMemory<float> inputGpuMemory = new Cuda1DMemory<float>(inputSizeInBytes))
                        using (Cuda1DMemory<float> outputGpuMemory = new Cuda1DMemory<float>(outputSizeInBytes))
                        {
                            // ç»‘å®šæ˜¾å­˜åœ°å€åˆ° TensorRT ä¸Šä¸‹æ–‡
                            executionContext.setInputTensorAddress("images", inputGpuMemory.get());
                            executionContext.setOutputTensorAddress("output0", outputGpuMemory.get());
                            // é¢„çƒ­æ¨ç† (å¯é€‰ï¼Œä½†æ¨èï¼Œå°¤å…¶æ˜¯é¦–æ¬¡æ¨ç†æ—¶)
                            executionContext.executeV3(cudaStream);
                            cudaStream.Synchronize();
                            // ================= 3. å›¾åƒé¢„å¤„ç† =================
                            Mat img = Cv2.ImRead(imagePath);
                            if (img.Empty())
                            {
                                Logger.Instance.INFO("Image not found!");
                                return;
                            }
    
                            sw.Start();
                            float[] inputData = PreProcess(img, out float scale, out int xOffset, out int yOffset);
                            sw.Stop();
                            Logger.Instance.INFO($"Pre-processing time: {sw.ElapsedMilliseconds} ms");
                            // ================= 4. æ¨ç† =================
                            // å‡†å¤‡ä¸»æœºå†…å­˜æ¥æ”¶ç»“æœ
                            float[] outputData = new float[outputChannels * OutputSize];
    
    
                            sw.Restart();
                            // å°†æ•°æ®ä»ä¸»æœº æ‹·è´åˆ°è®¾å¤‡
                            inputGpuMemory.copyFromHostAsync(inputData, cudaStream);
    
                            // æ‰§è¡Œæ¨ç† (enqueueV3 æ˜¯å¼‚æ­¥çš„)
                            executionContext.executeV3(cudaStream);
                            // ç­‰å¾…æ¨ç†å®Œæˆ
                            cudaStream.Synchronize();
    
               
    
                            // å°†ç»“æœä»è®¾å¤‡ æ‹·è´å›ä¸»æœº
                            // è¿™é‡Œçš„æ‹·è´æ˜¯åŒæ­¥çš„ï¼Œä¼šç­‰å¾… GPU è®¡ç®—å®Œæˆ
                            outputGpuMemory.copyToHostAsync(outputData, cudaStream);
                            sw.Stop();
                            Logger.Instance.INFO($"Inference time: {sw.ElapsedMilliseconds} ms");
                            // ================= 5. åå¤„ç† =================
    
                            sw.Restart();
                            List<DetData> results = PostProcess(outputData, scale, xOffset, yOffset);
                            sw.Stop();
                            Logger.Instance.INFO($"Post-processing time: {sw.ElapsedMilliseconds} ms");
    
                            // ================= 6. ç»“æœå¯è§†åŒ– =================
                            Mat resultImg = DrawDetResult(results, img);
                            Cv2.ImShow("YOLO11-DET Result", resultImg);
                            Cv2.WaitKey(0);
                        }
                    }
                }
            }
    
            /// <summary>
            /// å›¾åƒé¢„å¤„ç†ï¼šLetterbox ç¼©æ”¾ã€å½’ä¸€åŒ–ã€HWC è½¬ CHW
            /// </summary>
            private static float[] PreProcess(Mat img, out float scale, out int xOffset, out int yOffset)
            {
                // è½¬æ¢é¢œè‰²ç©ºé—´ BGR -> RGB
                Mat rgbImg = new Mat();
                Cv2.CvtColor(img, rgbImg, ColorConversionCodes.BGR2RGB);
    
                // è®¡ç®— Letterbox ç¼©æ”¾æ¯”ä¾‹
                int maxDim = Math.Max(rgbImg.Width, rgbImg.Height);
                scale = (float)maxDim / InputSize;
    
                // è®¡ç®—ç¼©æ”¾åçš„å°ºå¯¸
                int newWidth = (int)(rgbImg.Width / scale);
                int newHeight = (int)(rgbImg.Height / scale);
    
                // Resize å›¾åƒ
                Mat resizedImg = new Mat();
                Cv2.Resize(rgbImg, resizedImg, new Size(newWidth, newHeight));
    
                // åˆ›å»ºé»‘è‰²èƒŒæ™¯ Canvas (InputSize x InputSize)
                Mat paddedImg = Mat.Zeros(InputSize, InputSize, MatType.CV_8UC3);
    
                // è®¡ç®—ç²˜è´´ä½ç½® (å±…ä¸­)
                xOffset = (InputSize - newWidth) / 2;
                yOffset = (InputSize - newHeight) / 2;
    
                // å°†å›¾åƒæ‹·è´åˆ° Canvas ä¸­å¤®
                Rect roi = new Rect(xOffset, yOffset, newWidth, newHeight);
                resizedImg.CopyTo(new Mat(paddedImg, roi));
    
                // å½’ä¸€åŒ– (0-255 -> 0-1) å¹¶è½¬ä¸º float ç±»å‹
                Mat floatImg = new Mat();
                paddedImg.ConvertTo(floatImg, MatType.CV_32FC3, 1.0 / 255.0);
    
                // HWC è½¬ CHW å¹¶å±•å¹³ä¸ºä¸€ç»´æ•°ç»„
                Mat[] channels = Cv2.Split(floatImg);
                float[] chwData = new float[3 * InputSize * InputSize];
    
                // æ‹·è´æ•°æ®ï¼šRé€šé“ -> Cé€šé“ -> Bé€šé“ (OpenCV Split å‡ºæ¥é¡ºåºæ˜¯ B, G, Rï¼Œå¯¹åº”ç´¢å¼• 0, 1, 2)
                int channelSize = InputSize * InputSize;
                // å°† R, G, B ä¾æ¬¡æ‹·å…¥æ•°ç»„
                Marshal.Copy(channels[0].Data, chwData, 0, channelSize); // R
                Marshal.Copy(channels[1].Data, chwData, channelSize, channelSize); // G
                Marshal.Copy(channels[2].Data, chwData, channelSize * 2, channelSize); // B
    
                // é‡Šæ”¾ä¸´æ—¶ Mat
                rgbImg.Dispose();
                resizedImg.Dispose();
                paddedImg.Dispose();
                floatImg.Dispose();
                foreach (var c in channels) c.Dispose();
    
                return chwData;
            }
    
            /// <summary>
            /// åå¤„ç†ï¼šè§£æ TensorRT è¾“å‡ºã€NMS è¿‡æ»¤
            /// </summary>
            private static List<DetData> PostProcess(float[] result, float scale, int xOffset, int yOffset)
            {
                List<Rect> boxes = new List<Rect>();
                List<float> confidences = new List<float>();
                List<int> classIds = new List<int>();
    
                // éå†æ‰€æœ‰é¢„æµ‹æ¡† (OutputSize)
                // æ•°æ®å¸ƒå±€: [4(box) + 80(classes)] * OutputSize
                // å±•å¹³æ•°ç»„ä¸­ï¼ŒåŒä¸€å±æ€§çš„æ•°æ®æ˜¯è¿ç»­å­˜å‚¨çš„ï¼Œä¾‹å¦‚æ‰€æœ‰ cx åœ¨ä¸€èµ·ï¼Œæ‰€æœ‰ cy åœ¨åœ¨ä¸€èµ·...
                int stride = OutputSize; // æ­¥é•¿ï¼Œä¸åŒå±æ€§åœ¨æ•°ç»„ä¸­çš„åç§»é‡
    
                for (int i = 0; i < OutputSize; i++)
                {
                    // æŸ¥æ‰¾æœ€å¤§ç±»åˆ«æ¦‚ç‡åŠå…¶ç´¢å¼•
                    float maxConf = 0;
                    int maxClassId = -1;
    
                    // éå†ç±»åˆ«
                    for (int c = 0; c < CategoryNum; c++)
                    {
                        // æ•°ç»„ç´¢å¼•ï¼š(åæ ‡/è§’åº¦åç§»é‡ + ç±»åˆ«åç§») * æ¡†ç´¢å¼•
                        // æ³¨æ„ï¼šåŸå§‹ä»£ç ä¸­ result[outputSize * j + i] è¿™ç§è®¿é—®æ–¹å¼åŸºäº Transposed æ•°æ®å¸ƒå±€
                        float conf = result[(4 + c) * stride + i];
                        if (conf > maxConf)
                        {
                            maxConf = conf;
                            maxClassId = c;
                        }
                    }
    
                    // ç½®ä¿¡åº¦è¿‡æ»¤
                    if (maxConf > ConfThreshold)
                    {
                        // æå–åæ ‡ (cx, cy, w, h)
                        float cx = result[0 * stride + i];
                        float cy = result[1 * stride + i];
                        float w = result[2 * stride + i];
                        float h = result[3 * stride + i];
                        // è¿˜åŸåæ ‡åˆ°åŸå›¾å°ºå¯¸
                        int rx = (int)((cx - xOffset - 0.5 * w) * scale);
                        int ry = (int)((cy - yOffset - 0.5 * h) * scale);
                        int rw = (int)(w * scale);
                        int rh = (int)(h * scale);
    
                        boxes.Add(new Rect(rx, ry, rw, rh));
                        confidences.Add(maxConf);
                        classIds.Add(maxClassId);
                    }
                }
    
                // æ‰§è¡Œ NMS (æ—‹è½¬æ¡† NMS)
                // OpenCV çš„ NMSBoxes æ”¯æŒ RotatedRect
                int[] indices;
                CvDnn.NMSBoxes(boxes, confidences, ConfThreshold, NmsThreshold, out indices);
    
                List<DetData> finalResults = new List<DetData>();
                foreach (int idx in indices)
                {
                    finalResults.Add(new DetData
                    {
                        index = classIds[idx],
                        score = confidences[idx],
                        box = boxes[idx]
                    });
                }
    
                return finalResults;
            }
    
            /// <summary>
            /// ç»˜åˆ¶æ£€æµ‹ç»“æœï¼ˆæ°´å¹³çŸ©å½¢æ¡†ï¼‰
            /// </summary>
            /// <param name="results">æ£€æµ‹ç»“æœåˆ—è¡¨</param>
            /// <param name="image">åŸå§‹å›¾åƒ</param>
            /// <returns>ç»˜åˆ¶åçš„å›¾åƒ</returns>
            public static Mat DrawDetResult(List<DetData> results, Mat image)
            {
                // å…‹éš†å›¾åƒä»¥å…ä¿®æ”¹åŸå›¾
                Mat mat = image.Clone();
    
                foreach (var item in results)
                {
                    // 1. ç»˜åˆ¶çŸ©å½¢æ¡†
                    // Rect ç»“æ„åŒ…å« X, Y, Width, Height
                    Cv2.Rectangle(mat, item.box, new Scalar(0, 255, 0), thickness: 2);
                    // 2. å‡†å¤‡æ ‡ç­¾æ–‡æœ¬ (ç±»åˆ«ID - ç½®ä¿¡åº¦)
                    string label = $"{item.index} - {item.score:F2}";
                    // 3. è®¡ç®—æ–‡æœ¬çš„å°ºå¯¸ï¼Œç”¨äºç»˜åˆ¶èƒŒæ™¯
                    int baseLine = 1;
                    Size textSize = Cv2.GetTextSize(label, HersheyFonts.HersheySimplex, 0.6, 1, out baseLine);
                    // 4. ç»˜åˆ¶æ ‡ç­¾èƒŒæ™¯ï¼ˆåŠé€æ˜é»‘è‰²çŸ©å½¢ï¼‰ï¼Œé˜²æ­¢æ–‡å­—ä¸èƒŒæ™¯æ··æ·†
                    // ä½ç½®ï¼šçŸ©å½¢å·¦ä¸Šè§’ç•¥å¾®ä¸Šç§»ï¼Œæˆ–è€…ç›´æ¥è´´ç€å·¦ä¸Šè§’
                    Point labelPosition = new Point(item.box.X, item.box.Y - (int)textSize.Height - 5);
    
                    // ç¡®ä¿æ ‡ç­¾ä¸ç”»å‡ºå›¾åƒè¾¹ç•Œ
                    if (labelPosition.Y < 0) labelPosition.Y = item.box.Y + (int)textSize.Height + 5;
                    Rect labelBgRect = new Rect(labelPosition.X,
                                                labelPosition.Y - (int)textSize.Height, // OpenCV GetTextSize è¿”å›çš„é«˜åº¦æ˜¯åŸºçº¿åˆ°åº•éƒ¨çš„è·ç¦»ï¼Œéœ€è°ƒæ•´
                                                (int)textSize.Width,
                                                (int)textSize.Height + (int)baseLine);
                    // å¦‚æœèƒŒæ™¯æ¡†ä¹Ÿåœ¨å›¾åƒèŒƒå›´å†…ï¼Œåˆ™ç»˜åˆ¶
                    // æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œç›´æ¥ç”»åœ¨æ¡†ä¸Šæ–¹
                    Cv2.Rectangle(mat,
                                   new Point(item.box.X, item.box.Y - textSize.Height - 5),
                                   new Point(item.box.X + textSize.Width, item.box.Y),
                                   new Scalar(0, 255, 0),
                                   thickness: -1); // -1 è¡¨ç¤ºå¡«å……
                    // 5. ç»˜åˆ¶æ–‡æœ¬ï¼ˆç™½è‰²æ–‡å­—ï¼‰
                    Cv2.PutText(mat,
                                label,
                                new Point(item.box.X, item.box.Y - 5),
                                HersheyFonts.HersheySimplex,
                                0.6,
                                new Scalar(0, 0, 0),
                                1);
                }
                return mat;
            }
    
            public class DetData
            {
                public int index;
                public float score;
                public Rect box;
            }
        }
    }
    
    
    

**ç¨‹åºè¿è¡Œç»“æœï¼š**

**æ€§èƒ½æµ‹è¯•ç»“æœï¼š**

Batch Size

1

2

4

6

8

10

12

14

16

18

20

22

24

å‰å¤„ç† (ms)

9

13

27

38

56

59

63

83

96

105

118

130

144

æ¨¡å‹æ¨ç† (ms)

7

15

24

36

48

60

96

84

93

153

120

133

203

åå¤„ç† (ms)

25

26

26

26

28

27

27

28

28

28

27

31

29

> ğŸ”—**ç¨‹åºè·¯å¾„é“¾æ¥**ï¼šå®Œæ•´ç¨‹åºå·²ç»ä¸Šä¼ åˆ°GitHubï¼Œè¯·è‡ªè¡Œä¸‹è½½ï¼Œé“¾æ¥ä¸ºï¼š
> 
>     https://github.com/guojin-yan/TensorRT-CSharp-API/tree/TensorRtSharp3.0/samples/YoloDetInfer
>     
> 
> åŒæ—¶ä¹Ÿæä¾›äº†**YoloOBB**æ¨¡å‹çš„æ¨ç†ç¨‹åºï¼Œè¯·è‡ªè¡Œä¸‹è½½ï¼Œé“¾æ¥ä¸ºï¼š
> 
>     https://github.com/guojin-yan/TensorRT-CSharp-API/tree/TensorRtSharp3.0/samples/YoloObbInfer
>     

* * *

### ç¤ºä¾‹ 4ï¼šåŠ¨æ€å½¢çŠ¶æ¨ç†

å¯¹äºè¾“å…¥å°ºå¯¸å¯å˜çš„æ¨¡å‹ï¼Œéœ€è¦æ ¹æ®è¾“å…¥çš„æ•°æ®é…ç½®åŠ¨æ€å½¢çŠ¶ã€‚

**æ ¸å¿ƒä»£ç ï¼š**

    using JYPPX.TensorRtSharp.Cuda;
    using JYPPX.TensorRtSharp.Nvinfer;
    using OpenCvSharp;
    using OpenCvSharp.Dnn;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    
    namespace YoloObbBatchInfer
    {
        internal class Program
        {
            // ================= é…ç½®å‚æ•° =================
            // æ¨¡å‹è¾“å…¥å°ºå¯¸ (å®½=é«˜)
            private const int InputSize = 1024;
            // å»ºè®®æ ¹æ®å®é™…æ¨¡å‹åŠ¨æ€è·å–æˆ–ä½¿ç”¨ Netron æŸ¥çœ‹
            private const int OutputSize = 21504;
            // æ¨¡å‹ç±»åˆ«æ•° (æ ¹æ®æ‚¨çš„å…·ä½“æ•°æ®é›†ä¿®æ”¹ï¼Œæ­¤å¤„å‡è®¾ä¸º15ç±»)
            private const int CategoryNum = 15;
            // ç½®ä¿¡åº¦é˜ˆå€¼
            private const float ConfThreshold = 0.25f;
    
            // NMS IOU é˜ˆå€¼
            private const float NmsThreshold = 0.3f;
            private const int MaxBatchSize = 24;
            static void Main(string[] args)
            {
                //  ============= é…ç½® TensorRT æ—¥å¿—å›è°ƒ =============
                // å®šä¹‰ä¸€ä¸ªå§”æ‰˜ï¼Œç”¨äºå¤„ç† TensorRT å†…éƒ¨äº§ç”Ÿçš„æ—¥å¿—æ¶ˆæ¯ã€‚
                // è¿™å…è®¸æˆ‘ä»¬å°† C++ å±‚é¢çš„æ—¥å¿—è¾“å‡ºåˆ° C# çš„æ§åˆ¶å°ã€‚
                LogCallbackFunction _callbackDelegate = (message) =>
                {
                    Console.WriteLine(message);
                };
                // å°†è‡ªå®šä¹‰çš„å›è°ƒå‡½æ•°æ³¨å†Œç»™ TensorRT çš„å…¨å±€ Logger å®ä¾‹ã€‚
                Logger.Instance.SetCallback(_callbackDelegate);
    
                // è®¾ç½®æ—¥å¿—çš„ä¸¥é‡æ€§çº§åˆ«é˜ˆå€¼ã€‚
                // LoggerSeverity.kINFO: æ‰“å°ä¿¡æ¯ã€è­¦å‘Šå’Œé”™è¯¯ã€‚
                // å¼€å‘è°ƒè¯•é˜¶æ®µé€šå¸¸è®¾ä¸º kINFO æˆ– kVERBOSEï¼›ç”Ÿäº§ç¯å¢ƒå¯è®¾ä¸º kWARNING æˆ– kERROR ä»¥å‡å°‘è¾“å‡ºã€‚
                Logger.Instance.SetThreshold(LoggerSeverity.kINFO);
    
                string enginePath = "yolov8s-obb_b.engine";
                string[] imagePaths = { 
                    "P0006.png" , "P0016.png", "P0456.png", "P0813.png"};
                // ================= 1. åŠ è½½ TensorRT Engine =================
                // ä½¿ç”¨ using è¯­å¥ç¡®ä¿æ–‡ä»¶æµæ­£ç¡®å…³é—­
                byte[] engineData;
                using (FileStream fs = new FileStream(enginePath, FileMode.Open, FileAccess.Read))
                using (BinaryReader br = new BinaryReader(fs))
                {
                    engineData = br.ReadBytes((int)fs.Length);
                }
    
                // ååºåˆ—åŒ– Engine
                // Runtime å¿…é¡»åœ¨ Engine ç”Ÿå‘½å‘¨æœŸå†…ä¿æŒå­˜æ´»ï¼Œé€šå¸¸å»ºè®®è®¾ä¸ºå…¨å±€æˆ–é™æ€ï¼Œæˆ–è€…ç¡®ä¿å®ƒæœ€åé‡Šæ”¾
                Runtime runtime = new Runtime();
                runtime.setMaxThreads(10);
                // åˆ›å»º CudaEngine (æ­¤å¤„ä½¿ç”¨ using ç¡®ä¿æ¨ç†å®Œæˆåå¼•æ“è¢«é”€æ¯)
                using (CudaEngine cudaEngine = runtime.deserializeCudaEngineByBlob(engineData, (ulong)engineData.Length))
                {
                    // ================= 2. åˆå§‹åŒ–æ¨ç†ä¸Šä¸‹æ–‡ä¸æ˜¾å­˜ =================
                    // åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
                    using (JYPPX.TensorRtSharp.Nvinfer.ExecutionContext executionContext = cudaEngine.createExecutionContext(TrtExecutionContextAllocationStrategy.kSTATIC))
                    using (CudaStream cudaStream = new CudaStream()) // åˆ›å»º CUDA æµç”¨äºå¼‚æ­¥æ‰§è¡Œ
                    {
                        // è·å–è¾“å…¥ç»´åº¦ä¿¡æ¯ (ç”¨äºæ ¡éªŒ)
                        Dims inputDims = executionContext.getTensorShape("images");
                        Logger.Instance.INFO($"Input Shape: {inputDims.d[0]}x{inputDims.d[1]}x{inputDims.d[2]}x{inputDims.d[3]}");
    
                        // è®¡ç®—æ‰€éœ€æ˜¾å­˜å¤§å°
                        // è¾“å…¥: Batch=1, Channel=3, Height=1024, Width=1024
                        ulong inputSizeInBytes = MaxBatchSize * 3 * InputSize * InputSize;
                        // è¾“å‡º: Batch=1, Channels=CategoryNum+4(box)+1(angle), Num=8400
                        int outputChannels = CategoryNum + 5; // 4åæ ‡ + 1è§’åº¦ + Nç±»åˆ«
                        ulong outputSizeInBytes = (ulong)(MaxBatchSize * outputChannels * OutputSize);
    
                        Stopwatch sw = new Stopwatch();
                        // åˆ†é… GPU æ˜¾å­˜
                        using (Cuda1DMemory<float> inputGpuMemory = new Cuda1DMemory<float>(inputSizeInBytes))
                        using (Cuda1DMemory<float> outputGpuMemory = new Cuda1DMemory<float>(outputSizeInBytes))
                        {
                            // ç»‘å®šæ˜¾å­˜åœ°å€åˆ° TensorRT ä¸Šä¸‹æ–‡
                            executionContext.setInputTensorAddress("images", inputGpuMemory.get());
                            executionContext.setOutputTensorAddress("output0", outputGpuMemory.get());
    
                            // å…³é”®ä¸€æ­¥ï¼Œä¿®æ”¹æœ¬æ¬¡æ¨ç†çš„å½¢çŠ¶
                            executionContext.setinputShape("images", new Dims(imagePaths.Count(), 3, 1024, 1024));
                            // é¢„çƒ­æ¨ç† (å¯é€‰ï¼Œä½†æ¨èï¼Œå°¤å…¶æ˜¯é¦–æ¬¡æ¨ç†æ—¶)
                            executionContext.executeV3(cudaStream);
                            cudaStream.Synchronize();
    
                            // ================= 3. å›¾åƒé¢„å¤„ç† =================
                            List<Mat> images = new List<Mat>();
                            foreach (var path in imagePaths) 
                            {
                                Mat img = Cv2.ImRead(path);
                                if (img.Empty())
                                {
                                    Logger.Instance.INFO("Image not found!");
                                    return;
                                }
                                images.Add(img);
                            }
    
                            (float[] inputData1, float[] scales1, int[] xOffsets1, int[] yOffsets1) = PreProcessBatch(images);
                            sw.Start();
                            (float[] inputData, float[] scales, int[] xOffsets, int[] yOffsets) = PreProcessBatch(images);
                            sw.Stop();
                            Logger.Instance.INFO($"Pre-processing time: {sw.ElapsedMilliseconds} ms");
                            // ================= 4. æ¨ç† =================
    
                            // å‡†å¤‡ä¸»æœºå†…å­˜æ¥æ”¶ç»“æœ
                            float[] outputData1 = new float[imagePaths.Count() * outputChannels * OutputSize];
                            // å°†æ•°æ®ä»ä¸»æœº æ‹·è´åˆ°è®¾å¤‡
                            inputGpuMemory.copyFromHostAsync(inputData, cudaStream);
    
                            // æ‰§è¡Œæ¨ç† (enqueueV3 æ˜¯å¼‚æ­¥çš„)
                            executionContext.executeV3(cudaStream);
                            // ç­‰å¾…æ¨ç†å®Œæˆ
                            cudaStream.Synchronize();
                            // å°†ç»“æœä»è®¾å¤‡ æ‹·è´å›ä¸»æœº
                            // è¿™é‡Œçš„æ‹·è´æ˜¯åŒæ­¥çš„ï¼Œä¼šç­‰å¾… GPU è®¡ç®—å®Œæˆ
                            outputGpuMemory.copyToHostAsync(outputData1, cudaStream);
    
                            sw.Restart();
                            // å‡†å¤‡ä¸»æœºå†…å­˜æ¥æ”¶ç»“æœ
                            float[] outputData = new float[imagePaths.Count() * outputChannels * OutputSize];
                            // å°†æ•°æ®ä»ä¸»æœº æ‹·è´åˆ°è®¾å¤‡
                            inputGpuMemory.copyFromHostAsync(inputData, cudaStream);
    
                            // æ‰§è¡Œæ¨ç† (enqueueV3 æ˜¯å¼‚æ­¥çš„)
                            executionContext.executeV3(cudaStream);
                            // ç­‰å¾…æ¨ç†å®Œæˆ
                            cudaStream.Synchronize();
                            // å°†ç»“æœä»è®¾å¤‡ æ‹·è´å›ä¸»æœº
                            // è¿™é‡Œçš„æ‹·è´æ˜¯åŒæ­¥çš„ï¼Œä¼šç­‰å¾… GPU è®¡ç®—å®Œæˆ
                            outputGpuMemory.copyToHostAsync(outputData, cudaStream);
    
                            sw.Stop();
                            Logger.Instance.INFO($"Inference time: {sw.ElapsedMilliseconds} ms");
                            // ================= 5. åå¤„ç† =================
                            List<List<ObbData>> results1 = PostProcessBatch(outputData, scales, xOffsets, yOffsets);
                            sw.Restart();
                            List<List<ObbData>> results = PostProcessBatch(outputData, scales, xOffsets, yOffsets);
                            sw.Stop();
                            Logger.Instance.INFO($"Post-processing time: {sw.ElapsedMilliseconds} ms");
    
                            // ================= 6. ç»“æœå¯è§†åŒ– =================
                            List<Mat> resultMats = new List<Mat>();
                            for(int i = 0; i < results.Count; ++i)
                            {
                                resultMats.Add(DrawObbResult(results[i], images[i]));
                            }
                            Mat putResultImgs = StitchHorizontalWithPadding(resultMats);
                            Cv2.ImWrite("YOLO11-OBB Result.png", putResultImgs);
                            Cv2.ImShow("YOLO11-OBB Result", putResultImgs);
                            Cv2.WaitKey(0);
                        }
                    }
                }
            }
    
            /// <summary>
            /// å›¾åƒé¢„å¤„ç†ï¼šLetterbox ç¼©æ”¾ã€å½’ä¸€åŒ–ã€HWC è½¬ CHW
            /// </summary>
            private static (float[], float[] ,  int[] , int[] ) PreProcessBatch(List<Mat> imgs)
            {
                int dataLen = 3 * InputSize * InputSize;
                float[] chwData = new float[imgs.Count * dataLen];
                float[] scales = new float[imgs.Count];
                int[] xOffsets = new int[imgs.Count];
                int[]  yOffsets = new int[imgs.Count];
                Parallel.For(0, imgs.Count, i =>
                {
                    Mat img = imgs[i];
                    // è½¬æ¢é¢œè‰²ç©ºé—´ BGR -> RGB
                    Mat rgbImg = new Mat();
                    Cv2.CvtColor(img, rgbImg, ColorConversionCodes.BGR2RGB);
    
                    // è®¡ç®— Letterbox ç¼©æ”¾æ¯”ä¾‹
                    int maxDim = Math.Max(rgbImg.Width, rgbImg.Height);
                    scales[i] = (float)maxDim / InputSize;
    
                    // è®¡ç®—ç¼©æ”¾åçš„å°ºå¯¸
                    int newWidth = (int)(rgbImg.Width / scales[i]);
                    int newHeight = (int)(rgbImg.Height / scales[i]);
    
                    // Resize å›¾åƒ
                    Mat resizedImg = new Mat();
                    Cv2.Resize(rgbImg, resizedImg, new Size(newWidth, newHeight));
    
                    // åˆ›å»ºé»‘è‰²èƒŒæ™¯ Canvas (InputSize x InputSize)
                    Mat paddedImg = Mat.Zeros(InputSize, InputSize, MatType.CV_8UC3);
    
                    // è®¡ç®—ç²˜è´´ä½ç½® (å±…ä¸­)
                    xOffsets[i] = (InputSize - newWidth) / 2;
                    yOffsets[i] = (InputSize - newHeight) / 2;
    
                    // å°†å›¾åƒæ‹·è´åˆ° Canvas ä¸­å¤®
                    Rect roi = new Rect(xOffsets[i], yOffsets[i], newWidth, newHeight);
                    resizedImg.CopyTo(new Mat(paddedImg, roi));
    
                    // å½’ä¸€åŒ– (0-255 -> 0-1) å¹¶è½¬ä¸º float ç±»å‹
                    Mat floatImg = new Mat();
                    paddedImg.ConvertTo(floatImg, MatType.CV_32FC3, 1.0 / 255.0);
    
                    // HWC è½¬ CHW å¹¶å±•å¹³ä¸ºä¸€ç»´æ•°ç»„
                    Mat[] channels = Cv2.Split(floatImg);
    
    
                    // æ‹·è´æ•°æ®ï¼šRé€šé“ -> Cé€šé“ -> Bé€šé“ (OpenCV Split å‡ºæ¥é¡ºåºæ˜¯ B, G, Rï¼Œå¯¹åº”ç´¢å¼• 0, 1, 2)
                    int channelSize = InputSize * InputSize;
                    // å°† R, G, B ä¾æ¬¡æ‹·å…¥æ•°ç»„
                    Marshal.Copy(channels[0].Data, chwData, dataLen * i, channelSize); // R
                    Marshal.Copy(channels[1].Data, chwData, dataLen * i + channelSize, channelSize); // G
                    Marshal.Copy(channels[2].Data, chwData, dataLen * i + channelSize * 2, channelSize); // B
    
                    // é‡Šæ”¾ä¸´æ—¶ Mat
                    rgbImg.Dispose();
                    resizedImg.Dispose();
                    paddedImg.Dispose();
                    floatImg.Dispose();
                    foreach (var c in channels) c.Dispose();
                });
    
    
    
                return (chwData, scales, xOffsets, yOffsets);
            }
    
            /// <summary>
            /// åå¤„ç†ï¼šè§£æ TensorRT è¾“å‡ºã€NMS è¿‡æ»¤
            /// </summary>
            private static List<List<ObbData>> PostProcessBatch(float[] result, float[] scales, int[] xOffsets, int[] yOffsets)
            {
                List<ObbData>[] obbDatas = new List<ObbData>[scales.Length];
    
                Parallel.For(0, scales.Length, b =>
                {
                    List<RotatedRect> boxes = new List<RotatedRect>();
                    List<float> confidences = new List<float>();
                    List<int> classIds = new List<int>();
    
                    // éå†æ‰€æœ‰é¢„æµ‹æ¡† (OutputSize)
                    // æ•°æ®å¸ƒå±€: [4(box) + 15(classes) + 1(angle)] * OutputSize
                    // å±•å¹³æ•°ç»„ä¸­ï¼ŒåŒä¸€å±æ€§çš„æ•°æ®æ˜¯è¿ç»­å­˜å‚¨çš„ï¼Œä¾‹å¦‚æ‰€æœ‰ cx åœ¨ä¸€èµ·ï¼Œæ‰€æœ‰ cy åœ¨åœ¨ä¸€èµ·...
                    int stride = OutputSize; // æ­¥é•¿ï¼Œä¸åŒå±æ€§åœ¨æ•°ç»„ä¸­çš„åç§»é‡
    
                    int resultDataOffset = OutputSize * (CategoryNum + 5) * b;
    
                    for (int i = 0; i < OutputSize; i++)
                    {
                        // æŸ¥æ‰¾æœ€å¤§ç±»åˆ«æ¦‚ç‡åŠå…¶ç´¢å¼•
                        float maxConf = 0;
                        int maxClassId = -1;
    
                        // éå†ç±»åˆ« 
                        for (int c = 0; c < CategoryNum; c++)
                        {
                            // æ•°ç»„ç´¢å¼•ï¼š(åæ ‡/è§’åº¦åç§»é‡ + ç±»åˆ«åç§») * æ¡†ç´¢å¼•
                            // æ³¨æ„ï¼šåŸå§‹ä»£ç ä¸­ result[outputSize * j + i] è¿™ç§è®¿é—®æ–¹å¼åŸºäº Transposed æ•°æ®å¸ƒå±€
                            float conf = result[(4 + c) * stride + i + resultDataOffset];
                            if (conf > maxConf)
                            {
                                maxConf = conf;
                                maxClassId = c;
                            }
                        }
    
                        // ç½®ä¿¡åº¦è¿‡æ»¤
                        if (maxConf > ConfThreshold)
                        {
                            // æå–åæ ‡ (cx, cy, w, h)
                            float cx = result[0 * stride + i + resultDataOffset];
                            float cy = result[1 * stride + i + resultDataOffset];
                            float w = result[2 * stride + i + resultDataOffset];
                            float h = result[3 * stride + i + resultDataOffset];
    
                            // æå–è§’åº¦ (é€šå¸¸åœ¨ç¬¬ 5 ä¸ªä½ç½®ï¼Œå³ç±»åˆ«ä¹‹å‰)
                            float angleRad = result[(CategoryNum + 4) * stride + i + resultDataOffset];
    
                            // è¿˜åŸåæ ‡åˆ°åŸå›¾å°ºå¯¸
                            float rx = (cx - xOffsets[b]) * scales[b];
                            float ry = (cy - yOffsets[b]) * scales[b];
                            float rw = w * scales[b];
                            float rh = h * scales[b];
    
                            // å°†å¼§åº¦è½¬æ¢ä¸ºè§’åº¦
                            // Normalize angle to [-Ï€/2, Ï€/2] range
                            // å°†è§’åº¦å½’ä¸€åŒ–åˆ°[-Ï€/2, Ï€/2]èŒƒå›´
                            if (angleRad >= Math.PI && angleRad <= 0.75 * Math.PI)
                            {
                                angleRad -= (float)Math.PI;
                            }
                            float angleDeg = angleRad * (float)(180f / Math.PI);  // Convert to degrees/è½¬æ¢ä¸ºè§’åº¦åˆ¶
    
                            boxes.Add(new RotatedRect(new Point2f(rx, ry), new Size2f(rw, rh), angleDeg));
                            confidences.Add(maxConf);
                            classIds.Add(maxClassId);
                        }
                    }
    
                    // æ‰§è¡Œ NMS (æ—‹è½¬æ¡† NMS)
                    // OpenCV çš„ NMSBoxes æ”¯æŒ RotatedRect
                    int[] indices;
                    CvDnn.NMSBoxes(boxes, confidences, ConfThreshold, NmsThreshold, out indices);
    
                    List<ObbData> finalResults = new List<ObbData>();
                    foreach (int idx in indices)
                    {
                        finalResults.Add(new ObbData
                        {
                            index = classIds[idx],
                            score = confidences[idx],
                            box = boxes[idx]
                        });
                    }
                    obbDatas[b] = finalResults;
                });
    
               
    
                return obbDatas.Select(x => x?.ToList() ?? new List<ObbData>()).ToList();
            }
    
            /// <summary>
            /// ç»˜åˆ¶æ—‹è½¬æ£€æµ‹ç»“æœ
            /// </summary>
            public static Mat DrawObbResult(List<ObbData> results, Mat image)
            {
                // å…‹éš†å›¾åƒä»¥å…ä¿®æ”¹åŸå›¾
                Mat mat = image.Clone();
    
                foreach (var item in results)
                {
                    // è·å–æ—‹è½¬çŸ©å½¢çš„å››ä¸ªé¡¶ç‚¹
                    Point2f[] points = item.box.Points();
    
                    // ç»˜åˆ¶å¤šè¾¹å½¢æ¡†
                    for (int j = 0; j < 4; j++)
                    {
                        Cv2.Line(mat, (Point)points[j], (Point)points[(j + 1) % 4],
                                new Scalar(0, 255, 0), 2);
                    }
    
                    // ç»˜åˆ¶æ ‡ç­¾ (ç±»åˆ« - ç½®ä¿¡åº¦)
                    string label = $"{item.index} - {item.score:F2}";
                    Point2f textPos = points[0]; // å·¦ä¸Šè§’
    
                    Cv2.PutText(mat, label, (Point)textPos, HersheyFonts.HersheySimplex, 0.8,
                                new Scalar(255, 0, 0), 2);
                }
    
                return mat;
            }
    
            public class ObbData
            {
                public int index;
                public float score;
                public RotatedRect box;
            }
    
    
            /// <summary>
            /// æ™ºèƒ½æ°´å¹³æ‹¼æ¥ï¼šè‡ªåŠ¨å¤„ç†é«˜åº¦ä¸ä¸€è‡´çš„å›¾ç‰‡
            /// </summary>
            /// <param name="images">å›¾ç‰‡åˆ—è¡¨</param>
            /// <param name="backgroundColor">å¡«å……èƒŒæ™¯é¢œè‰²ï¼Œé»˜è®¤ä¸ºé»‘è‰²</param>
            /// <returns>æ‹¼æ¥åçš„ Mat</returns>
            public static Mat StitchHorizontalWithPadding(List<Mat> images, Scalar? backgroundColor = null)
            {
                if (images == null || images.Count == 0)
                    return new Mat();
                // 1. æ‰¾åˆ°æ‰€æœ‰å›¾ç‰‡ä¸­çš„æœ€å¤§é«˜åº¦
                int maxHeight = images.Max(img => img.Rows);
                // è®¡ç®—æ€»å®½åº¦
                int totalWidth = images.Sum(img => img.Cols);
                // 2. å‡†å¤‡ç»“æœç”»å¸ƒ
                Mat result = new Mat(maxHeight, totalWidth, images[0].Type(), backgroundColor ?? Scalar.Black);
                // 3. å°†æ¯ä¸€å¼ å›¾ç‰‡å¤åˆ¶åˆ°ç”»å¸ƒçš„å¯¹åº”ä½ç½®
                int currentX = 0; // å½“å‰ X è½´åç§»é‡
                foreach (var img in images)
                {
                    if (img.Empty()) continue;
                    // è®¡ç®—å½“å‰å›¾ç‰‡éœ€è¦å‚ç›´åç§»å¤šå°‘ï¼ˆåº•éƒ¨å¯¹é½é€»è¾‘ï¼‰
                    // å¦‚æœæƒ³é¡¶éƒ¨å¯¹é½ï¼ŒyOffset = 0
                    // å¦‚æœæƒ³å±…ä¸­ï¼ŒyOffset = (maxHeight - img.Rows) / 2
                    int yOffset = maxHeight - img.Rows;
                    // å®šä¹‰ ROI (æ„Ÿå…´è¶£åŒºåŸŸ)
                    Rect roi = new Rect(currentX, yOffset, img.Cols, img.Rows);
    
                    // å°†åŸå›¾ç‰‡æ‹·è´åˆ°ç»“æœå›¾çš„ ROI åŒºåŸŸ
                    img.CopyTo(new Mat(result, roi));
                    // ç§»åŠ¨ X è½´æŒ‡é’ˆ
                    currentX += img.Cols;
                }
                return result;
            }
        }
    }
    
    
    

ä¸‹å›¾ä¸ºä¸Šè¿°ç¨‹åºè¿è¡Œåçš„è¾“å‡ºï¼Œæ¨¡å‹è¾“å…¥å½¢çŠ¶ä¸º -1x3x1024x1024ï¼Œå…¶ä¸­Batch Sizeä¸ºåŠ¨æ€è¾“å…¥ï¼›é¡¹ç›®ç¤ºä¾‹ä½¿ç”¨äº†å››å¼ å›¾ç‰‡è¿›è¡ŒåŒæ—¶æ¨ç†ï¼Œå¼€å¯å¹¶è¡Œå¤„ç†åï¼Œå››å¼ å›¾åƒé¢„å¤„ç†æ—¶é—´ä»…ç”¨21msï¼Œæ¨ç†æ—¶é—´ä¸º25msï¼Œåå¤„ç†æ—¶é—´ä¸º26msï¼Œç´¯è®¡æ—¶é—´ä¸º72ms.

ä¸‹å›¾ä¸ºæ¨ç†ç»“æœå±•ç¤ºï¼š

**æ€§èƒ½æµ‹è¯•ï¼ˆä¸åŒ Batch Sizeï¼‰ï¼š**

ä¸ºäº†æ¢ç©¶ä¸åŒBatch Sizeæ¨ç†æ—¶é—´å·®å¼‚ï¼Œæ­¤å¤„å¯¹ä¸åŒBatch Sizeè¿›è¡Œäº†æµ‹è¯•ï¼Œæµ‹è¯•ç»“æœå¦‚ä¸‹ï¼š

Batch Size

1

2

4

6

8

10

12

14

16

18

20

22

24

å‰å¤„ç† (ms )

9

13

27

38

56

59

63

83

96

105

118

130

144

æ¨¡å‹æ¨ç† (ms)

7

15

24

36

48

60

96

84

93

153

120

133

203

åå¤„ç† (ms)

25

26

26

26

28

27

27

28

28

28

27

31

29

> ğŸ”—**ç¨‹åºè·¯å¾„é“¾æ¥**ï¼šå®Œæ•´ç¨‹åºå·²ç»ä¸Šä¼ åˆ°GitHubï¼Œè¯·è‡ªè¡Œä¸‹è½½ï¼Œé“¾æ¥ä¸ºï¼š
> 
>     https://github.com/guojin-yan/TensorRT-CSharp-API/tree/TensorRtSharp3.0/samples/YoloObbBatchInfer
>     

* * *

### ç¤ºä¾‹ 5ï¼šå¹¶è¡Œæ¨ç†

ä½¿ç”¨ä¸€ä¸ª Runtime åˆ›å»ºå¤šæ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œå®ç°å¤šå¹¶è¡Œæ¨ç†ã€‚

**æ ¸å¿ƒä»£ç ï¼š**

    using JYPPX.TensorRtSharp.Cuda;
    using JYPPX.TensorRtSharp.Nvinfer;
    using OpenCvSharp;
    using OpenCvSharp.Dnn;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using static OpenCvSharp.FileStorage;
    
    namespace YoloDetParallelInfer
    {
        internal class Program
        {
            // ================= é…ç½®å‚æ•° =================
            // æ¨¡å‹è¾“å…¥å°ºå¯¸ (å®½=é«˜)
            private const int InputSize = 640;
    
    
            // å»ºè®®æ ¹æ®å®é™…æ¨¡å‹åŠ¨æ€è·å–æˆ–ä½¿ç”¨ Netron æŸ¥çœ‹
            private const int OutputSize = 8400;
    
            // æ¨¡å‹ç±»åˆ«æ•° (æ ¹æ®æ‚¨çš„å…·ä½“æ•°æ®é›†ä¿®æ”¹ï¼Œæ­¤å¤„å‡è®¾ä¸º15ç±»)
            private const int CategoryNum = 80;
    
            // ç½®ä¿¡åº¦é˜ˆå€¼
            private const float ConfThreshold = 0.25f;
    
            // NMS IOU é˜ˆå€¼
            private const float NmsThreshold = 0.3f;
    
            static void Main(string[] args)
            {
                //  ============= é…ç½® TensorRT æ—¥å¿—å›è°ƒ =============
                // å®šä¹‰ä¸€ä¸ªå§”æ‰˜ï¼Œç”¨äºå¤„ç† TensorRT å†…éƒ¨äº§ç”Ÿçš„æ—¥å¿—æ¶ˆæ¯ã€‚
                // è¿™å…è®¸æˆ‘ä»¬å°† C++ å±‚é¢çš„æ—¥å¿—è¾“å‡ºåˆ° C# çš„æ§åˆ¶å°ã€‚
                LogCallbackFunction _callbackDelegate = (message) =>
                {
                    Console.WriteLine(message);
                };
    
                // å°†è‡ªå®šä¹‰çš„å›è°ƒå‡½æ•°æ³¨å†Œç»™ TensorRT çš„å…¨å±€ Logger å®ä¾‹ã€‚
                Logger.Instance.SetCallback(_callbackDelegate);
    
                // è®¾ç½®æ—¥å¿—çš„ä¸¥é‡æ€§çº§åˆ«é˜ˆå€¼ã€‚
                // LoggerSeverity.kINFO: æ‰“å°ä¿¡æ¯ã€è­¦å‘Šå’Œé”™è¯¯ã€‚
                // å¼€å‘è°ƒè¯•é˜¶æ®µé€šå¸¸è®¾ä¸º kINFO æˆ– kVERBOSEï¼›ç”Ÿäº§ç¯å¢ƒå¯è®¾ä¸º kWARNING æˆ– kERROR ä»¥å‡å°‘è¾“å‡ºã€‚
                Logger.Instance.SetThreshold(LoggerSeverity.kINFO);
    
                string enginePath = "yolov8s.engine";
                string imagePath = "bus.jpg";
    
                               Mat img = Cv2.ImRead(imagePath);
                                if (img.Empty())
                                {
                                    Logger.Instance.INFO("Image not found!");
                                    return;
                                }
                // ================= 1. åŠ è½½ TensorRT Engine =================
                // ä½¿ç”¨ using è¯­å¥ç¡®ä¿æ–‡ä»¶æµæ­£ç¡®å…³é—­
                byte[] engineData;
                using (FileStream fs = new FileStream(enginePath, FileMode.Open, FileAccess.Read))
                using (BinaryReader br = new BinaryReader(fs))
                {
                    engineData = br.ReadBytes((int)fs.Length);
                }
    
                // ååºåˆ—åŒ– Engine
                // Runtime å¿…é¡»åœ¨ Engine ç”Ÿå‘½å‘¨æœŸå†…ä¿æŒå­˜æ´»ï¼Œé€šå¸¸å»ºè®®è®¾ä¸ºå…¨å±€æˆ–é™æ€ï¼Œæˆ–è€…ç¡®ä¿å®ƒæœ€åé‡Šæ”¾
                Runtime runtime = new Runtime();
                runtime.setMaxThreads(6);
                // åˆ›å»º CudaEngine (æ­¤å¤„ä½¿ç”¨ using ç¡®ä¿æ¨ç†å®Œæˆåå¼•æ“è¢«é”€æ¯)
                using (CudaEngine cudaEngine = runtime.deserializeCudaEngineByBlob(engineData, (ulong)engineData.Length))
                {
                    // ================= 2. åˆå§‹åŒ–æ¨ç†ä¸Šä¸‹æ–‡ä¸æ˜¾å­˜ =================
                    Stopwatch totalSw = new Stopwatch();
                    totalSw.Start();
                    Parallel.For(0, 24, b =>
                    {           
                        
                        // åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
                        using (JYPPX.TensorRtSharp.Nvinfer.ExecutionContext executionContext = cudaEngine.createExecutionContext(TrtExecutionContextAllocationStrategy.kSTATIC))
                        using (CudaStream cudaStream = new CudaStream()) // åˆ›å»º CUDA æµç”¨äºå¼‚æ­¥æ‰§è¡Œ
                        {
                            // è·å–è¾“å…¥ç»´åº¦ä¿¡æ¯ (ç”¨äºæ ¡éªŒ)
                            Dims inputDims = executionContext.getTensorShape("images");
                            Logger.Instance.INFO($"Input Shape: {inputDims.d[0]}x{inputDims.d[1]}x{inputDims.d[2]}x{inputDims.d[3]}");
    
                            // è®¡ç®—æ‰€éœ€æ˜¾å­˜å¤§å°
                            // è¾“å…¥: Batch=1, Channel=3, Height=640, Width=640
                            ulong inputSizeInBytes = 1 * 3 * InputSize * InputSize;
                            // è¾“å‡º: Batch=1, Channels=CategoryNum+4(box)+1(angle), Num=8400
                            int outputChannels = CategoryNum + 4; // 4åæ ‡ + Nç±»åˆ«
                            ulong outputSizeInBytes = (ulong)(1 * outputChannels * OutputSize);
    
                            Stopwatch sw = new Stopwatch();
                            // åˆ†é… GPU æ˜¾å­˜
                            using (Cuda1DMemory<float> inputGpuMemory = new Cuda1DMemory<float>(inputSizeInBytes))
                            using (Cuda1DMemory<float> outputGpuMemory = new Cuda1DMemory<float>(outputSizeInBytes))
                            {
                                // ç»‘å®šæ˜¾å­˜åœ°å€åˆ° TensorRT ä¸Šä¸‹æ–‡
                                executionContext.setInputTensorAddress("images", inputGpuMemory.get());
                                executionContext.setOutputTensorAddress("output0", outputGpuMemory.get());
                                // é¢„çƒ­æ¨ç† (å¯é€‰ï¼Œä½†æ¨èï¼Œå°¤å…¶æ˜¯é¦–æ¬¡æ¨ç†æ—¶)
                                executionContext.executeV3(cudaStream);
                                cudaStream.Synchronize();
                                // ================= 3. å›¾åƒé¢„å¤„ç† =================
                 
    
                                sw.Start();
                                float[] inputData = PreProcess(img, out float scale, out int xOffset, out int yOffset);
                                sw.Stop();
                                Logger.Instance.INFO($"Channel {b}: Pre-processing time: {sw.ElapsedMilliseconds} ms");
                                // ================= 4. æ¨ç† =================
                                // å‡†å¤‡ä¸»æœºå†…å­˜æ¥æ”¶ç»“æœ
                                float[] outputData = new float[outputChannels * OutputSize];
    
    
                                sw.Restart();
                                // å°†æ•°æ®ä»ä¸»æœº æ‹·è´åˆ°è®¾å¤‡
                                inputGpuMemory.copyFromHostAsync(inputData, cudaStream);
    
                                // æ‰§è¡Œæ¨ç† (enqueueV3 æ˜¯å¼‚æ­¥çš„)
                                executionContext.executeV3(cudaStream);
                                // ç­‰å¾…æ¨ç†å®Œæˆ
                                cudaStream.Synchronize();
    
    
    
                                // å°†ç»“æœä»è®¾å¤‡ æ‹·è´å›ä¸»æœº
                                // è¿™é‡Œçš„æ‹·è´æ˜¯åŒæ­¥çš„ï¼Œä¼šç­‰å¾… GPU è®¡ç®—å®Œæˆ
                                outputGpuMemory.copyToHostAsync(outputData, cudaStream);
                                sw.Stop();
                                Logger.Instance.INFO($"Channel {b}: Inference time: {sw.ElapsedMilliseconds} ms");
                                // ================= 5. åå¤„ç† =================
    
                                sw.Restart();
                                List<DetData> results = PostProcess(outputData, scale, xOffset, yOffset);
                                sw.Stop();
                                Logger.Instance.INFO($"Channel {b}: Post-processing time: {sw.ElapsedMilliseconds} ms");
    
                                // ================= 6. ç»“æœå¯è§†åŒ– =================
                                //Mat resultImg = DrawDetResult(results, img);
                                //Cv2.ImShow("YOLO11-DET Result", resultImg);
                                //Cv2.WaitKey(0);
                            }
                        }
                    });
    
                    totalSw.Stop();
                    Logger.Instance.INFO($"Total time for 8 inferences: {totalSw.ElapsedMilliseconds} ms");
    
    
                }
            }
    
            /// <summary>
            /// å›¾åƒé¢„å¤„ç†ï¼šLetterbox ç¼©æ”¾ã€å½’ä¸€åŒ–ã€HWC è½¬ CHW
            /// </summary>
            private static float[] PreProcess(Mat img, out float scale, out int xOffset, out int yOffset)
            {
                // è½¬æ¢é¢œè‰²ç©ºé—´ BGR -> RGB
                Mat rgbImg = new Mat();
                Cv2.CvtColor(img, rgbImg, ColorConversionCodes.BGR2RGB);
    
                // è®¡ç®— Letterbox ç¼©æ”¾æ¯”ä¾‹
                int maxDim = Math.Max(rgbImg.Width, rgbImg.Height);
                scale = (float)maxDim / InputSize;
    
                // è®¡ç®—ç¼©æ”¾åçš„å°ºå¯¸
                int newWidth = (int)(rgbImg.Width / scale);
                int newHeight = (int)(rgbImg.Height / scale);
    
                // Resize å›¾åƒ
                Mat resizedImg = new Mat();
                Cv2.Resize(rgbImg, resizedImg, new Size(newWidth, newHeight));
    
                // åˆ›å»ºé»‘è‰²èƒŒæ™¯ Canvas (InputSize x InputSize)
                Mat paddedImg = Mat.Zeros(InputSize, InputSize, MatType.CV_8UC3);
    
                // è®¡ç®—ç²˜è´´ä½ç½® (å±…ä¸­)
                xOffset = (InputSize - newWidth) / 2;
                yOffset = (InputSize - newHeight) / 2;
    
                // å°†å›¾åƒæ‹·è´åˆ° Canvas ä¸­å¤®
                Rect roi = new Rect(xOffset, yOffset, newWidth, newHeight);
                resizedImg.CopyTo(new Mat(paddedImg, roi));
    
                // å½’ä¸€åŒ– (0-255 -> 0-1) å¹¶è½¬ä¸º float ç±»å‹
                Mat floatImg = new Mat();
                paddedImg.ConvertTo(floatImg, MatType.CV_32FC3, 1.0 / 255.0);
    
                // HWC è½¬ CHW å¹¶å±•å¹³ä¸ºä¸€ç»´æ•°ç»„
                Mat[] channels = Cv2.Split(floatImg);
                float[] chwData = new float[3 * InputSize * InputSize];
    
                // æ‹·è´æ•°æ®ï¼šRé€šé“ -> Cé€šé“ -> Bé€šé“ (OpenCV Split å‡ºæ¥é¡ºåºæ˜¯ B, G, Rï¼Œå¯¹åº”ç´¢å¼• 0, 1, 2)
                int channelSize = InputSize * InputSize;
                // å°† R, G, B ä¾æ¬¡æ‹·å…¥æ•°ç»„
                Marshal.Copy(channels[0].Data, chwData, 0, channelSize); // R
                Marshal.Copy(channels[1].Data, chwData, channelSize, channelSize); // G
                Marshal.Copy(channels[2].Data, chwData, channelSize * 2, channelSize); // B
    
                // é‡Šæ”¾ä¸´æ—¶ Mat
                rgbImg.Dispose();
                resizedImg.Dispose();
                paddedImg.Dispose();
                floatImg.Dispose();
                foreach (var c in channels) c.Dispose();
    
                return chwData;
            }
    
            /// <summary>
            /// åå¤„ç†ï¼šè§£æ TensorRT è¾“å‡ºã€NMS è¿‡æ»¤
            /// </summary>
            private static List<DetData> PostProcess(float[] result, float scale, int xOffset, int yOffset)
            {
                List<Rect> boxes = new List<Rect>();
                List<float> confidences = new List<float>();
                List<int> classIds = new List<int>();
    
                // éå†æ‰€æœ‰é¢„æµ‹æ¡† (OutputSize)
                // æ•°æ®å¸ƒå±€: [4(box) + 80(classes)] * OutputSize
                // å±•å¹³æ•°ç»„ä¸­ï¼ŒåŒä¸€å±æ€§çš„æ•°æ®æ˜¯è¿ç»­å­˜å‚¨çš„ï¼Œä¾‹å¦‚æ‰€æœ‰ cx åœ¨ä¸€èµ·ï¼Œæ‰€æœ‰ cy åœ¨åœ¨ä¸€èµ·...
                int stride = OutputSize; // æ­¥é•¿ï¼Œä¸åŒå±æ€§åœ¨æ•°ç»„ä¸­çš„åç§»é‡
    
                for (int i = 0; i < OutputSize; i++)
                {
                    // æŸ¥æ‰¾æœ€å¤§ç±»åˆ«æ¦‚ç‡åŠå…¶ç´¢å¼•
                    float maxConf = 0;
                    int maxClassId = -1;
    
                    // éå†ç±»åˆ«
                    for (int c = 0; c < CategoryNum; c++)
                    {
                        // æ•°ç»„ç´¢å¼•ï¼š(åæ ‡/è§’åº¦åç§»é‡ + ç±»åˆ«åç§») * æ¡†ç´¢å¼•
                        // æ³¨æ„ï¼šåŸå§‹ä»£ç ä¸­ result[outputSize * j + i] è¿™ç§è®¿é—®æ–¹å¼åŸºäº Transposed æ•°æ®å¸ƒå±€
                        float conf = result[(4 + c) * stride + i];
                        if (conf > maxConf)
                        {
                            maxConf = conf;
                            maxClassId = c;
                        }
                    }
    
                    // ç½®ä¿¡åº¦è¿‡æ»¤
                    if (maxConf > ConfThreshold)
                    {
                        // æå–åæ ‡ (cx, cy, w, h)
                        float cx = result[0 * stride + i];
                        float cy = result[1 * stride + i];
                        float w = result[2 * stride + i];
                        float h = result[3 * stride + i];
                        // è¿˜åŸåæ ‡åˆ°åŸå›¾å°ºå¯¸
                        int rx = (int)((cx - xOffset - 0.5 * w) * scale);
                        int ry = (int)((cy - yOffset - 0.5 * h) * scale);
                        int rw = (int)(w * scale);
                        int rh = (int)(h * scale);
    
                        boxes.Add(new Rect(rx, ry, rw, rh));
                        confidences.Add(maxConf);
                        classIds.Add(maxClassId);
                    }
                }
    
                // æ‰§è¡Œ NMS (æ—‹è½¬æ¡† NMS)
                // OpenCV çš„ NMSBoxes æ”¯æŒ RotatedRect
                int[] indices;
                CvDnn.NMSBoxes(boxes, confidences, ConfThreshold, NmsThreshold, out indices);
    
                List<DetData> finalResults = new List<DetData>();
                foreach (int idx in indices)
                {
                    finalResults.Add(new DetData
                    {
                        index = classIds[idx],
                        score = confidences[idx],
                        box = boxes[idx]
                    });
                }
    
                return finalResults;
            }
    
            /// <summary>
            /// ç»˜åˆ¶æ£€æµ‹ç»“æœï¼ˆæ°´å¹³çŸ©å½¢æ¡†ï¼‰
            /// </summary>
            /// <param name="results">æ£€æµ‹ç»“æœåˆ—è¡¨</param>
            /// <param name="image">åŸå§‹å›¾åƒ</param>
            /// <returns>ç»˜åˆ¶åçš„å›¾åƒ</returns>
            public static Mat DrawDetResult(List<DetData> results, Mat image)
            {
                // å…‹éš†å›¾åƒä»¥å…ä¿®æ”¹åŸå›¾
                Mat mat = image.Clone();
    
                foreach (var item in results)
                {
                    // 1. ç»˜åˆ¶çŸ©å½¢æ¡†
                    // Rect ç»“æ„åŒ…å« X, Y, Width, Height
                    Cv2.Rectangle(mat, item.box, new Scalar(0, 255, 0), thickness: 2);
                    // 2. å‡†å¤‡æ ‡ç­¾æ–‡æœ¬ (ç±»åˆ«ID - ç½®ä¿¡åº¦)
                    string label = $"{item.index} - {item.score:F2}";
                    // 3. è®¡ç®—æ–‡æœ¬çš„å°ºå¯¸ï¼Œç”¨äºç»˜åˆ¶èƒŒæ™¯
                    int baseLine = 1;
                    Size textSize = Cv2.GetTextSize(label, HersheyFonts.HersheySimplex, 0.6, 1, out baseLine);
                    // 4. ç»˜åˆ¶æ ‡ç­¾èƒŒæ™¯ï¼ˆåŠé€æ˜é»‘è‰²çŸ©å½¢ï¼‰ï¼Œé˜²æ­¢æ–‡å­—ä¸èƒŒæ™¯æ··æ·†
                    // ä½ç½®ï¼šçŸ©å½¢å·¦ä¸Šè§’ç•¥å¾®ä¸Šç§»ï¼Œæˆ–è€…ç›´æ¥è´´ç€å·¦ä¸Šè§’
                    Point labelPosition = new Point(item.box.X, item.box.Y - (int)textSize.Height - 5);
    
                    // ç¡®ä¿æ ‡ç­¾ä¸ç”»å‡ºå›¾åƒè¾¹ç•Œ
                    if (labelPosition.Y < 0) labelPosition.Y = item.box.Y + (int)textSize.Height + 5;
                    Rect labelBgRect = new Rect(labelPosition.X,
                                                labelPosition.Y - (int)textSize.Height, // OpenCV GetTextSize è¿”å›çš„é«˜åº¦æ˜¯åŸºçº¿åˆ°åº•éƒ¨çš„è·ç¦»ï¼Œéœ€è°ƒæ•´
                                                (int)textSize.Width,
                                                (int)textSize.Height + (int)baseLine);
                    // å¦‚æœèƒŒæ™¯æ¡†ä¹Ÿåœ¨å›¾åƒèŒƒå›´å†…ï¼Œåˆ™ç»˜åˆ¶
                    // æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œç›´æ¥ç”»åœ¨æ¡†ä¸Šæ–¹
                    Cv2.Rectangle(mat,
                                   new Point(item.box.X, item.box.Y - textSize.Height - 5),
                                   new Point(item.box.X + textSize.Width, item.box.Y),
                                   new Scalar(0, 255, 0),
                                   thickness: -1); // -1 è¡¨ç¤ºå¡«å……
                    // 5. ç»˜åˆ¶æ–‡æœ¬ï¼ˆç™½è‰²æ–‡å­—ï¼‰
                    Cv2.PutText(mat,
                                label,
                                new Point(item.box.X, item.box.Y - 5),
                                HersheyFonts.HersheySimplex,
                                0.6,
                                new Scalar(0, 0, 0),
                                1);
                }
                return mat;
            }
    
            public class DetData
            {
                public int index;
                public float score;
                public Rect box;
            }
        }
    }
    
    
    

ä¸ºäº†æ–¹ä¾¿ç¼–å†™ä»£ç ï¼Œä¸Šè¿°å¹¶è¡Œå¤„ç†å³ä½¿æ—¶é—´åŒ…æ‹¬äº†æ¨ç†ä¸Šä¸‹æ–‡çš„åˆ›å»ºã€æ¨ç†é¢„çƒ­ç­‰æ­¥éª¤ï¼Œæ‰€ä»¥å®é™…æ—¶é—´ä¼šåé•¿ï¼Œä¸Šè¿°ç¨‹åºè¿è¡Œåè¾“å‡ºå¦‚ä¸‹æ‰€ç¤ºï¼š

**å¹¶è¡Œæµ‹è¯•ç»“æœï¼š**

åŒæ—¶ä¸ºäº†æ¯”è¾ƒä¸åŒå¹¶è¡Œæ•°ï¼Œæµ‹è¯•äº†ä»1åˆ°24ä¸åŒå¹¶è¡Œæ•°çš„æƒ…å†µï¼Œæ¨ç†æ€»æ—¶é—´å¦‚ä¸‹ï¼š

å¹¶è¡Œæ•°

1

2

4

6

8

10

12

14

16

18

20

22

24

æ¨ç†æ€»æ—¶é—´ (ms)

80

85

95

115

130

155

180

210

230

255

270

285

310

> ğŸ”—**ç¨‹åºè·¯å¾„é“¾æ¥**ï¼šå®Œæ•´ç¨‹åºå·²ç»ä¸Šä¼ åˆ°GitHubï¼Œè¯·è‡ªè¡Œä¸‹è½½ï¼Œé“¾æ¥ä¸ºï¼š
> 
>     https://github.com/guojin-yan/TensorRT-CSharp-API/tree/TensorRtSharp3.0/samples/YoloObbBatchInfer
>     

* * *

ä¸ƒã€å¼‚å¸¸å¤„ç†
------

TensorRtSharp æä¾›äº†å®Œå–„çš„å¼‚å¸¸å¤„ç†æœºåˆ¶ã€‚

    try
    {
        Runtime runtime = new Runtime();
        byte[] data = File.ReadAllBytes("model.engine");
        using CudaEngine engine = runtime.deserializeCudaEngineByBlob(data, (ulong)data.Length);
    }
    catch (TrtException ex)
    {
        // TensorRT ç‰¹å®šé”™è¯¯
        Console.WriteLine($"TensorRT Error: {ex.ErrMsg}");
        Console.WriteLine($"Status: {ex.Status}");
    }
    catch (CudaException ex)
    {
        // CUDA è¿è¡Œæ—¶é”™è¯¯
        Console.WriteLine($"CUDA Error: {ex.Message}");
        Console.WriteLine($"Status: {ex.Status}");
    }
    catch (InitException ex)
    {
        // åˆå§‹åŒ–é”™è¯¯
        Console.WriteLine($"Initialization Failed: {ex.Message}");
        Console.WriteLine($"Status: {ex.Status}");
    }
    

**å¼‚å¸¸ç±»å‹è¯´æ˜ï¼š**

å¼‚å¸¸ç±»å‹

è¯´æ˜

`TrtException`

TensorRT API é”™è¯¯ï¼ˆ20+ é”™è¯¯ç ï¼‰

`CudaException`

CUDA è¿è¡Œæ—¶é”™è¯¯ï¼ˆ40+ é”™è¯¯ç ï¼‰

`InitException`

åº“åˆå§‹åŒ–é”™è¯¯

* * *

å…«ã€æ—¥å¿—ç³»ç»Ÿ
------

TensorRtSharp æä¾›äº†å•ä¾‹æ—¥å¿—ç³»ç»Ÿã€‚

    // è·å–æ—¥å¿—å®ä¾‹
    Logger logger = Logger.Instance;
    
    // è®¾ç½®æ—¥å¿—çº§åˆ«
    logger.SetThreshold(LoggerSeverity.kINFO);  // INFOã€WARNINGã€ERROR
    
    // è®¾ç½®è‡ªå®šä¹‰å›è°ƒ
    logger.SetCallback((message) =>
    {
        Console.WriteLine($"[TensorRT] {message}");
    });
    
    // è®°å½•æ—¥å¿—
    logger.INFO("Engine building started...");
    logger.WARNING("FP16 not supported, falling back to FP32");
    logger.ERROR("Failed to parse ONNX model");
    
    // é™é»˜æ¨¡å¼
    logger.SetThreshold(LoggerSeverity.kINTERNAL_ERROR);  // ä»…ä¸¥é‡é”™è¯¯
    

* * *

ä¹ã€ä¸å…¶ä»–åº“çš„å¯¹æ¯”
---------

ç‰¹æ€§

TensorRtSharp

ML.NET

ONNX Runtime

**ç¼–ç¨‹è¯­è¨€**

C#

C#

C++/Python

**API ç±»å‹**

æ‰˜ç®¡å°è£…

æ‰˜ç®¡åº“

åŸç”Ÿç»‘å®š

**æ€§èƒ½**

åŸç”Ÿé€Ÿåº¦

ä¸­ç­‰

åŸç”Ÿé€Ÿåº¦

**æ˜“ç”¨æ€§**

é«˜

é«˜

ä¸­ç­‰

**TensorRT æ”¯æŒ**

å®Œæ•´

æ— 

æœ‰é™

**è‡ªå®šä¹‰ç®—å­**

æ”¯æŒ

å›°éš¾

æ”¯æŒ

**åŠ¨æ€å½¢çŠ¶**

æ”¯æŒ

æœ‰é™

æ”¯æŒ

**å¤š GPU**

æ”¯æŒ

æœ‰é™

æ”¯æŒ

* * *

åã€å¸¸è§é—®é¢˜
------

### é—®é¢˜ä¸€ï¼šæ‰¾ä¸åˆ° DLL æ¨¡å—

**é”™è¯¯ä¿¡æ¯ï¼š**

    Unable to load DLL 'TensorRT-C-API' or one of its dependencies: æ‰¾ä¸åˆ°æŒ‡å®šçš„æ¨¡å—ã€‚
    

**è§£å†³æ–¹æ¡ˆï¼š**

1.  æ£€æŸ¥æ˜¯å¦å®‰è£…äº†å¯¹åº”ç‰ˆæœ¬çš„ Runtime NuGet åŒ…
2.  ç¡®è®¤ç³»ç»Ÿ PATH ç¯å¢ƒå˜é‡ä¸­åŒ…å« TensorRT çš„ lib ç›®å½•å’Œ CUDA çš„ bin ç›®å½•
3.  ç¡®è®¤ TensorRT ç‰ˆæœ¬ä¸º 10.x ç³»åˆ—

**é”™è¯¯æˆªå›¾ï¼š**

  

* * *

### é—®é¢˜äºŒï¼šSEHException å¼‚å¸¸

**é”™è¯¯ä¿¡æ¯ï¼š**

    System.Runtime.InteropServices.SEHException: "External component has thrown an exception."
    

**å¯èƒ½åŸå› ï¼š**

*   TensorRT ç‰ˆæœ¬ä¸åŒ¹é…ï¼ˆå¿…é¡»ä½¿ç”¨ 10.xï¼‰
*   CUDA ç‰ˆæœ¬ä¸å…¼å®¹
*   æ¨¡å‹æ–‡ä»¶æŸå

**è§£å†³æ–¹æ¡ˆï¼š**

1.  ç¡®è®¤ TensorRT ç‰ˆæœ¬ä¸º 10.x
2.  æ£€æŸ¥ CUDA ç‰ˆæœ¬æ˜¯å¦åŒ¹é…
3.  é‡æ–°ç”Ÿæˆ Engine æ–‡ä»¶

**é”™è¯¯æˆªå›¾ï¼š**

### é—®é¢˜ä¸‰ï¼šSystem.ExecutionEngineException å¼‚å¸¸

**é”™è¯¯ä¿¡æ¯ï¼š**

    System.ExecutionEngineException 
    

**å¯èƒ½åŸå› ï¼š**

*   æ¨¡å‹æ–‡ä»¶ä¸è®¾å¤‡ä¸åŒ¹é…

**è§£å†³æ–¹æ¡ˆï¼š**

1.  åœ¨å½“å‰è®¾å¤‡ä¸Šé‡æ–°ç”Ÿæˆæ¨¡å‹æ–‡ä»¶

**é”™è¯¯æˆªå›¾ï¼š**

* * *

åä¸€ã€æ€»ç»“
-----

TensorRtSharp æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€è®¾è®¡ç²¾è‰¯çš„ TensorRT C# å°è£…åº“ï¼Œå®ƒå¡«è¡¥äº† .NET ç”Ÿæ€åœ¨é«˜æ€§èƒ½æ·±åº¦å­¦ä¹ æ¨ç†æ–¹é¢çš„ç©ºç™½ã€‚é€šè¿‡æä¾›ç±»å‹å®‰å…¨çš„ APIã€è‡ªåŠ¨èµ„æºç®¡ç†å’Œå®Œå–„çš„å¼‚å¸¸å¤„ç†ï¼ŒTensorRtSharp è®© C# å¼€å‘è€…èƒ½å¤Ÿå……åˆ†å‘æŒ¥ GPU çš„è®¡ç®—èƒ½åŠ›ï¼Œè€Œæ— éœ€é¢å¯¹å¤æ‚çš„åŸç”Ÿä»£ç ã€‚

### æ ¸å¿ƒä¼˜åŠ¿

âœ… **å®Œæ•´çš„ API è¦†ç›–**ï¼šæ”¯æŒ TensorRT æ ¸å¿ƒåŠŸèƒ½  
âœ… **ç±»å‹å®‰å…¨**ï¼šå¼ºç±»å‹ç³»ç»Ÿï¼Œç¼–è¯‘æ—¶é”™è¯¯æ£€æŸ¥  
âœ… **è‡ªåŠ¨èµ„æºç®¡ç†**ï¼šRAII + Dispose æ¨¡å¼  
âœ… **é«˜æ€§èƒ½**ï¼šå¼‚æ­¥æ‰§è¡Œã€å¤šæµå¹¶è¡Œ  
âœ… **æ˜“ç”¨æ€§**ï¼šç›´è§‚çš„ APIã€è¯¦ç»†æ³¨é‡Š  
âœ… **è·¨å¹³å°**ï¼šæ”¯æŒ Windows/Linux  
âœ… **å¼€ç®±å³ç”¨**ï¼šNuGet åŒ…å«æ‰€æœ‰ä¾èµ–

### é€‚ç”¨åœºæ™¯

æ— è®ºæ‚¨æ˜¯æ„å»ºä»¥ä¸‹ç±»å‹çš„åº”ç”¨ï¼ŒTensorRtSharp éƒ½æ˜¯æ‚¨çš„ç†æƒ³é€‰æ‹©ï¼š

*   ğŸ¯ **å®æ—¶è§†è§‰åº”ç”¨**ï¼šç›®æ ‡æ£€æµ‹ã€å›¾åƒåˆ†å‰²ã€å§¿æ€ä¼°è®¡
*   ğŸ¤ **è¯­éŸ³å¤„ç†**ï¼šè¯­éŸ³è¯†åˆ«ã€è¯­éŸ³åˆæˆ
*   ğŸš€ **è¾¹ç¼˜è®¡ç®—**ï¼šåµŒå…¥å¼è®¾å¤‡æ¨ç†

### ç«‹å³å¼€å§‹

**å®‰è£…å‘½ä»¤ï¼š**

    dotnet add package JYPPX.TensorRT.CSharp.API
    dotnet add package JYPPX.TensorRT.CSharp.API.runtime.win-x64.cuda12
    

**GitHub ä»“åº“ï¼š**

    https://github.com/guojin-yan/TensorRT-CSharp-API
    

ç«‹å³å®‰è£…å¹¶ä½“éªŒ C# ä¸–ç•Œä¸­çš„ GPU æ¨ç†æè‡´æ€§èƒ½å§ï¼

* * *

æŠ€æœ¯æ”¯æŒ
----

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿é€šè¿‡ä»¥ä¸‹æ–¹å¼äº¤æµï¼š

*   ğŸ“§ **GitHub Issues**ï¼šåœ¨é¡¹ç›®ä»“åº“æ Issue æˆ– Pull Request
*   ğŸ’¬ **QQ äº¤æµç¾¤**ï¼šåŠ å…¥ **945057948**ï¼Œå›å¤æ›´æ–¹ä¾¿æ›´å¿«å“¦

* * *

_ä½œè€…ï¼šGuojin Yan_  
_ç‰ˆæœ¬ï¼š0.0.5_  
_æœ€åæ›´æ–°ï¼š2026å¹´1æœˆ_

* * *

**ã€æ–‡ç« å£°æ˜ã€‘**

æœ¬æ–‡ä¸»è¦å†…å®¹åŸºäºä½œè€…çš„ç ”ç©¶ä¸å®è·µï¼Œéƒ¨åˆ†è¡¨è¿°å€ŸåŠ©AIå·¥å…·è¿›è¡Œäº†è¾…åŠ©ä¼˜åŒ–ã€‚ç”±äºæŠ€æœ¯å±€é™æ€§ï¼Œæ–‡ä¸­å¯èƒ½å­˜åœ¨é”™è¯¯æˆ–ç–æ¼ä¹‹å¤„ï¼Œæ³è¯·å„ä½è¯»è€…æ‰¹è¯„æŒ‡æ­£ã€‚å¦‚æœå†…å®¹æ— æ„ä¸­ä¾µçŠ¯äº†æ‚¨çš„æƒç›Šï¼Œè¯·åŠæ—¶é€šè¿‡å…¬ä¼—å·åå°ä¸æˆ‘ä»¬è”ç³»ï¼Œæˆ‘ä»¬å°†ç¬¬ä¸€æ—¶é—´æ ¸å®å¹¶å¦¥å–„å¤„ç†ã€‚æ„Ÿè°¢æ‚¨çš„ç†è§£ä¸æ”¯æŒï¼