---
layout: post
title: '『Python底层原理』--Python整数为什么可以无限大'
date: "2025-02-25T00:37:13Z"
---
『Python底层原理』--Python整数为什么可以无限大
==============================

**整数类型**是编程中最常见的数据类型之一，但它的实现细节却鲜为人知。

与其他语言不同，`Python` 的整数是任意精度的，这意味着它们可以无限大，仅受限于内存。

这种特性使得 `Python` 在处理大整数时非常强大，但也增加了实现的复杂性。

今天，我们将探讨 `Python` 整数的内部实现，揭示其背后的奥秘。

1\. 整数的内部表示
===========

在大多数编程语言中，整数通常是固定精度的，例如 **32 位**或 **64 位**。

然而，`Python` 的整数是任意精度的，这意味着它们可以无限大，而不会出现溢出问题。

这种特性使得 `Python`在密码学、计算机代数等领域中非常实用。

    # Python 中的整数可以非常大，而不会溢出
    big_number = 1234567890123456789012345678901234567890
    print(big_number * big_number)  # 输出一个更大的整数
    

这种任意精度的特性是如何实现的呢？

答案在于 `Python` 的整数实现方式。

`Python` 的整数是通过 `CPython` 的 `PyLongObject` 结构体实现的，

这个结构体定义了整数的存储方式，包括符号和数字。

`PyLongObject`的定义参考：`Include/cpython/longintrepr.h` 文件。

    typedef struct _PyLongValue {
        uintptr_t lv_tag; /* Number of digits, sign and flags */
        digit ob_digit[1];
    } _PyLongValue;
    
    struct _longobject {
        PyObject_HEAD
        _PyLongValue long_value;
    };
    

这里的`_longobject`就是`PyLongObject`，`_PyLongValue`中存储了数字的符号和个数。

`Python` 使用一种**“大基数”**表示法，而不是常见的十进制表示，

在 **64 位**平台上，基数为\\(2^{30}\\) ，而在 **32 位**平台上，基数为\\(2^{15}\\) 。

以**64位平台**（基数为$ 2^{30} $）为例，一个大数据`1234567890123456789`存储为`[1038713109, 76039121, 1]`。

    def to_digits(n, base=2**30):
        digits = [n % base]
    
        n = n // base
        while n != 0:
            digits.append(n % base)
            n = n // base
    
        return digits
    
    x = 1234567890123456789
    print(f"整数 {x} 的底层数字表示: {to_digits(x)}")
    # 整数 1234567890123456789 的底层数字表示: [1038713109, 76039121, 1]
    

如果要计算在**32位**平台上的表示，只要将传入`to_digits`的`base`参数改为`2**15`即可。

所以，任意大的整数，在`Python`内部都用用一个列表来存放，列表中的每个数值都小于$ 2^{30} $ 或者$ 2^{15} $ 。

2\. 整数的内存优化
===========

`Python` 整数占用较多内存，即使是小整数也需要 28 字节（在 64 位平台上）。

为了优化内存使用，`CPython` 采取了一些巧妙的策略，尤其是在处理小整数时。

我本机上的Python3.12.4版本中，小于等于$ 2^{64} $的整数都是缓存的。

    i = 2**64
    j = 2**64
    print(f"addr i: {id(i)}, addr j: {id(j)}")
    print(f"i 和 j 是否相同: {i is j}")
    # addr i: 2595289736288, addr j: 2595289736288
    # i 和 j 是否相同: True
    
    i = 2**65
    j = 2**65
    print(f"addr i: {id(i)}, addr j: {id(j)}")
    print(f"i 和 j 是否相同: {i is j}")
    # addr i: 2595289736432, addr j: 2595289736480
    # i 和 j 是否相同: False
    

从上面的示例可以看出，当整数$ \\le 2^{64} $时，`i`和`j`的内存地址是一样的；反之则不一样。

不过，虽然`CPython`对整数的实现已经很高效了，但是但在处理大量整数时，内存占用仍然是一个需要考虑的问题。

以下是一些优化建议：

1.  使用`array`模块或`numpy`：如果你需要存储大量同类型的整数，使用`array`模块或`numpy`会以更紧凑的方式存储数据。
2.  避免不必要的整数创建：尽量复用已有的整数对象，尤其是在循环中。
3.  使用生成器：如果只需要逐个处理整数，可以使用生成器而不是创建整个列表。

3\. 整数的性能优化
===========

`CPython`的整数实现不仅考虑了内存使用，还通过多种优化手段提高了运算性能。

1.  **位操作优化**：对于大整数，`CPython`使用多精度算术，多精度整数在内存中以数组形式存储，每个元素代表一定位数的数值。

关联的源码可参考：`Include/cpython/longintrepr.h` 和 `Objects/longobject.c`

2.  **缓存机制优化**：对于一些频繁出现的运算或者中间结果，会将其缓存起来。当再次需要这些结果时，直接从缓存中获取，而不是重新计算。

关联的源码可参考：`Objects/longobject.c` 和 `Objects/object.c`

3.  **并行计算支持**：对于大整数加法，会将计算任务分解成多个子任务，并行地在多个核心上执行。

关联的源码可参考：`Python/thread_pthread.h`、`Python/thread_pthread.c` 和 `Objects/longobject.c`

4.  **代码生成优化**：在将整数加法的 `Python` 代码转换为机器码时，生成更高效的指令序列。

关联的源码可参考：`Python/compile.c`和`Python/ceval.c`

4\. 总结
======

`Python` 的整数实现是一个高效且灵活的任意精度整数系统。

通过`CPython`的源码，我们可以看到`Python`如何在内部处理大整数，以及如何通过优化策略提高性能和节省内存。

不过，虽然`Python`的整数实现已经非常强大，但在处理大量数据时，我们仍然可以通过一些技巧进一步优化内存使用和性能。