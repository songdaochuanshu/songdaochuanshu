---
layout: post
title: 'C++学习：CRTP 模式是什么'
date: "2025-02-06T00:35:56Z"
---
C++学习：CRTP 模式是什么
================

CRTP（Curiously Recurring Template Pattern，奇异递归模板模式）是 C++ 中的一种设计模式。

基本概念
----

CRTP 是指一个类（通常是基类）`以其派生类作为模板参数`的模式。其基本形式如下：

    template <typename Derived>
    class Base {
    // 基类的成员函数可以使用 Derived 类型
    };
    
    class Derived : public Base<Derived> {
    // 派生类的定义
    };
    

主要用途和优势
-------

*   静态多态性  
    CRTP 可以实现`静态多态`，即在编译时确定调用的函数，`避免`了`动态多态`（通过虚函数实现）带来的`运行时开销`。

    template <typename Derived>
    class Shape {
    public:
    void draw() {
    static_cast<Derived*>(this)->drawImpl();
    }
    };
    class Circle : public Shape<Circle> {
    public:
    void drawImpl() {
    std::cout << "Drawing a circle" << std::endl;
    }
    };
    
    class Square : public Shape<Square> {
    public:
    void drawImpl() {
    std::cout << "Drawing a square" << std::endl;
    }
    };
    
    int main() {
    Circle circle;
    Square square;
    circle.draw(); // 调用 Circle 的 drawImpl
    square.draw(); // 调用 Square 的 drawImpl
    return 0;
    }
    

在这个例子中，Shape 类的 draw 函数通过 static\_cast 将 this 指针转换为 Derived 类型，然后调用 drawImpl 函数。由于 drawImpl 函数是在编译时确定的，因此没有虚函数调用的开销。

*   避免虚函数开销  
    在某些情况下，虚函数的调用会带来一定的开销，特别是在性能敏感的代码中。CRTP 可以作为一种替代方案，避免虚函数的使用。
*   代码复用和扩展  
    CRTP 允许基类访问派生类的成员，从而实现代码的复用和扩展。基类可以在不知道具体派生类的情况下，调用派生类的特定功能。