---
layout: post
title: 'TypeScript ä¸­çš„å•ä¾‹æ¨¡å¼'
date: "2025-11-08T00:39:23Z"
---
TypeScript ä¸­çš„å•ä¾‹æ¨¡å¼
=================

ä»€ä¹ˆæ˜¯å•ä¾‹æ¨¡å¼ï¼Ÿ
--------

å•ä¾‹æ¨¡å¼æ˜¯ä¸€ç§åˆ›å»ºå‹è®¾è®¡æ¨¡å¼ï¼Œå®ƒç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›ä¸€ä¸ªå…¨å±€è®¿é—®ç‚¹æ¥è·å–è¿™ä¸ªå®ä¾‹ã€‚åœ¨ TypeScript ä¸­ï¼Œå•ä¾‹æ¨¡å¼ç‰¹åˆ«æœ‰ç”¨ï¼Œå› ä¸ºå®ƒç»“åˆäº† JavaScript çš„çµæ´»æ€§å’Œ TypeScript çš„ç±»å‹å®‰å…¨ã€‚

ä¸ºä»€ä¹ˆéœ€è¦å•ä¾‹æ¨¡å¼ï¼Ÿ
----------

æƒ³è±¡ä¸€ä¸‹è¿™äº›åœºæ™¯ï¼š

*   æ•°æ®åº“è¿æ¥æ± ç®¡ç†
*   åº”ç”¨ç¨‹åºé…ç½®ç®¡ç†å™¨
*   æ—¥å¿—è®°å½•å™¨
*   ç¼“å­˜ç®¡ç†å™¨

åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿æ•´ä¸ªåº”ç”¨ç¨‹åºä¸­åªæœ‰ä¸€ä¸ªå®ä¾‹æ¥å¤„ç†è¿™äº›å…¨å±€èµ„æºï¼Œé¿å…èµ„æºæµªè´¹å’Œä¸ä¸€è‡´çš„çŠ¶æ€ã€‚

åŸºç¡€å•ä¾‹å®ç°
------

è®©æˆ‘ä»¬ä»æœ€ç®€å•çš„å®ç°å¼€å§‹ï¼š

    class Singleton {
      private static instance: Singleton;
    
      private constructor() {
        // ç§æœ‰æ„é€ å‡½æ•°é˜²æ­¢å¤–éƒ¨å®ä¾‹åŒ–
      }
    
      public static getInstance(): Singleton {
        if (!Singleton.instance) {
          Singleton.instance = new Singleton();
        }
        return Singleton.instance;
      }
    
      public someBusinessLogic() {
        // ä¸šåŠ¡é€»è¾‘
      }
    }
    

çº¿ç¨‹å®‰å…¨çš„å•ä¾‹å®ç°
---------

åœ¨ JavaScript/TypeScript ä¸­ï¼Œç”±äºæ˜¯å•çº¿ç¨‹ç¯å¢ƒï¼Œæˆ‘ä»¬ä¸éœ€è¦æ‹…å¿ƒä¼ ç»Ÿçš„çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚ä½†è€ƒè™‘åˆ°å¼‚æ­¥æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´å®‰å…¨çš„å®ç°ï¼š

    class ThreadSafeSingleton {
      private static instance: ThreadSafeSingleton;
    
      private constructor() {
        // åˆå§‹åŒ–ä»£ç 
      }
    
      public static getInstance(): ThreadSafeSingleton {
        if (!ThreadSafeSingleton.instance) {
          ThreadSafeSingleton.instance = new ThreadSafeSingleton();
        }
        return ThreadSafeSingleton.instance;
      }
    
      // ä½¿ç”¨ Promise ç¡®ä¿å¼‚æ­¥å®‰å…¨
      public static async getInstanceAsync(): Promise<ThreadSafeSingleton> {
        if (!ThreadSafeSingleton.instance) {
          ThreadSafeSingleton.instance = new ThreadSafeSingleton();
          // æ¨¡æ‹Ÿå¼‚æ­¥åˆå§‹åŒ–
          await new Promise(resolve => setTimeout(resolve, 0));
        }
        return ThreadSafeSingleton.instance;
      }
    }
    

ä½¿ç”¨æ¨¡å—æ¨¡å¼çš„å•ä¾‹å®ç°
-----------

TypeScript çš„æ¨¡å—ç³»ç»Ÿå¤©ç„¶æ”¯æŒå•ä¾‹æ¨¡å¼ï¼š

    // Logger.ts
    class Logger {
      private logs: string[] = [];
    
      log(message: string) {
        this.logs.push(`${new Date().toISOString()}: ${message}`);
        console.log(message);
      }
    
      getLogs(): string[] {
        return [...this.logs];
      }
    }
    
    // ç›´æ¥å¯¼å‡ºå®ä¾‹
    export const logger = new Logger();
    

å¸¦å‚æ•°çš„å•ä¾‹æ¨¡å¼
--------

æœ‰æ—¶æˆ‘ä»¬éœ€è¦åœ¨å•ä¾‹åˆå§‹åŒ–æ—¶ä¼ é€’å‚æ•°ï¼š

    class ConfigManager {
      private static instance: ConfigManager;
      private config: Record<string, any>;
    
      private constructor(initialConfig?: Record<string, any>) {
        this.config = initialConfig || {};
      }
    
      public static initialize(initialConfig?: Record<string, any>): ConfigManager {
        if (!ConfigManager.instance) {
          ConfigManager.instance = new ConfigManager(initialConfig);
        }
        return ConfigManager.instance;
      }
    
      public static getInstance(): ConfigManager {
        if (!ConfigManager.instance) {
          throw new Error('ConfigManager not initialized. Call initialize() first.');
        }
        return ConfigManager.instance;
      }
    
      public set(key: string, value: any): void {
        this.config[key] = value;
      }
    
      public get(key: string): any {
        return this.config[key];
      }
    }
    

å•ä¾‹æ¨¡å¼çš„ä¼˜ç¼ºç‚¹
--------

### ä¼˜ç‚¹ï¼š

*   **ä¸¥æ ¼æ§åˆ¶å®ä¾‹æ•°é‡**ï¼šç¡®ä¿å…¨å±€å”¯ä¸€å®ä¾‹
*   **å…¨å±€è®¿é—®ç‚¹**ï¼šæ–¹ä¾¿åœ¨ä»»ä½•åœ°æ–¹è®¿é—®
*   **å»¶è¿Ÿåˆå§‹åŒ–**ï¼šåªæœ‰åœ¨éœ€è¦æ—¶æ‰åˆ›å»ºå®ä¾‹

### ç¼ºç‚¹ï¼š

*   **è¿åå•ä¸€èŒè´£åŸåˆ™**ï¼šç±»éœ€è¦ç®¡ç†è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
*   **éšè—çš„ä¾èµ–å…³ç³»**ï¼šå•ä¾‹çš„ä½¿ç”¨å¯èƒ½ä¸æ˜æ˜¾
*   **æµ‹è¯•å›°éš¾**ï¼šéš¾ä»¥æ¨¡æ‹Ÿå’Œæµ‹è¯•
*   **å…¨å±€çŠ¶æ€**ï¼šå¯èƒ½å¯¼è‡´ä»£ç è€¦åˆ

æµ‹è¯•å•ä¾‹æ¨¡å¼
------

æµ‹è¯•å•ä¾‹ç±»æ—¶éœ€è¦ç‰¹åˆ«æ³¨æ„ï¼š

    describe('Singleton', () => {
      beforeEach(() => {
        // é‡ç½®å•ä¾‹å®ä¾‹ç”¨äºæµ‹è¯•
        (Singleton as any).instance = undefined;
      });
    
      it('should return the same instance', () => {
        const instance1 = Singleton.getInstance();
        const instance2 = Singleton.getInstance();
        expect(instance1).toBe(instance2);
      });
    });
    

å®é™…åº”ç”¨ç¤ºä¾‹ï¼šæ•°æ®åº“è¿æ¥æ± 
-------------

è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªå®é™…çš„æ•°æ®åº“è¿æ¥æ± å•ä¾‹å®ç°ï¼š

    interface DatabaseConfig {
      host: string;
      port: number;
      username: string;
      password: string;
      database: string;
    }
    
    class DatabaseConnectionPool {
      private static instance: DatabaseConnectionPool;
      private connections: any[] = [];
      private config: DatabaseConfig;
    
      private constructor(config: DatabaseConfig) {
        this.config = config;
        this.initializePool();
      }
    
      public static getInstance(config?: DatabaseConfig): DatabaseConnectionPool {
        if (!DatabaseConnectionPool.instance) {
          if (!config) {
            throw new Error('Configuration required for first initialization');
          }
          DatabaseConnectionPool.instance = new DatabaseConnectionPool(config);
        }
        return DatabaseConnectionPool.instance;
      }
    
      private initializePool(): void {
        // åˆå§‹åŒ–è¿æ¥æ± 
        for (let i = 0; i < 10; i++) {
          this.connections.push(this.createConnection());
        }
      }
    
      private createConnection(): any {
        // åˆ›å»ºæ•°æ®åº“è¿æ¥çš„é€»è¾‘
        return {
          query: (sql: string) => console.log(`Executing: ${sql}`),
          close: () => console.log('Connection closed')
        };
      }
    
      public getConnection(): any {
        return this.connections.pop() || this.createConnection();
      }
    
      public releaseConnection(connection: any): void {
        this.connections.push(connection);
      }
    }
    

å®é™…åº”ç”¨ç¤ºä¾‹ï¼šStreams to River
-----------------------

[Streams to River](https://github.com/Trae-AI/stream-to-river) ç”±å­—èŠ‚è·³åŠ¨å¼€æºï¼Œ æ˜¯ä¸€æ¬¾è‹±è¯­å­¦ä¹ åº”ç”¨ã€‚è¯¥äº§å“çš„åˆè¡·æ˜¯é€šè¿‡å°†æ—¥å¸¸æ‰€è§çš„è‹±è¯­å•è¯ã€å¥å­å’Œç›¸å…³çš„ä¸Šä¸‹æ–‡è¿›è¡Œè®°å½•ã€æå–å’Œç®¡ç†, ç»“åˆ è‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ï¼Œè¿›è¡Œå‘¨æœŸæ€§çš„å­¦ä¹ å’Œè®°å¿†ã€‚

åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œæ·±åº¦é‡‡ç”¨äº† TRAE è¿›è¡Œä»£ç çš„å¼€å‘å’Œè°ƒè¯•ã€æ³¨é‡Šå’Œå•æµ‹çš„ç¼–å†™ï¼Œé€šè¿‡ coze workflow å¿«é€Ÿé›†æˆäº†å›¾åƒè½¬æ–‡å­—ã€å®æ—¶èŠå¤©ã€è¯­éŸ³è¯†åˆ«ã€å•è¯åˆ’çº¿ç­‰å¤§æ¨¡å‹èƒ½åŠ›ã€‚

åœ¨è¯¥é¡¹ç›®ä»£ç ä¸­å°±å­˜åœ¨å¤§é‡çš„å•ä¾‹æ¨¡å¼ä»£ç ã€‚

### 1\. AuthService çš„å®ç°

    class AuthService {
      private static instance: AuthService;
      private serverConfig: ServerConfig;
    
      private constructor() {
        this.serverConfig = ServerConfig.getInstance();
      }
    
      public static getInstance(): AuthService {
        if (!AuthService.instance) {
          AuthService.instance = new AuthService();
        }
        return AuthService.instance;
      }
    
      async login(loginData: LoginRequest): Promise<AuthResponse> {
        try {
          const response = await Taro.request({
            url: this.serverConfig.getFullUrl('/api/login'),
            method: 'POST',
            data: loginData,
            header: {
              'Content-Type': 'application/json'
            }
          });
    
          if (response.statusCode === 200) {
            const authData = response.data as AuthResponse;
            await this.setToken(authData.token);
            return authData;
          } else {
            throw new Error(response.data || 'ç™»å½•å¤±è´¥');
          }
        } catch (error) {
          console.error('Login error:', error);
          throw error;
        }
      }
    
      async register(registerData: RegisterRequest): Promise<AuthResponse> {
        try {
          const response = await Taro.request({
            url: this.serverConfig.getFullUrl('/api/register'),
            method: 'POST',
            data: registerData,
            header: {
              'Content-Type': 'application/json'
            }
          });
    
          if (response.statusCode === 200) {
            const authData = response.data as AuthResponse;
            await this.setToken(authData.token);
            return authData;
          } else {
            throw new Error(response.data || 'æ³¨å†Œå¤±è´¥');
          }
        } catch (error) {
          console.error('Register error:', error);
          throw error;
        }
      }
    
      async getUserInfo(): Promise<User> {
        try {
          const token = await this.getToken();
          if (!token) {
            throw new Error('æœªæ‰¾åˆ°token');
          }
    
          const response = await Taro.request({
            url: this.serverConfig.getFullUrl('/api/user'),
            method: 'GET',
            header: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          });
    
          if (response.statusCode === 200) {
            return response.data as User;
          } else {
            throw new Error('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥');
          }
        } catch (error) {
          console.error('Get user info error:', error);
          throw error;
        }
      }
    
      async setToken(token: string): Promise<void> {
        try {
          await Taro.setStorageSync('jwt_token', token);
        } catch (error) {
          console.error('Set token error:', error);
          throw error;
        }
      }
    
      async getToken(): Promise<string | null> {
        try {
          return Taro.getStorageSync('jwt_token') || null;
        } catch (error) {
          console.error('Get token error:', error);
          return null;
        }
      }
    
      async clearToken(): Promise<void> {
        try {
          await Taro.removeStorageSync('jwt_token');
        } catch (error) {
          console.error('Clear token error:', error);
        }
      }
    
      async isLoggedIn(): Promise<boolean> {
        const token = await this.getToken();
        return !!token;
      }
    
      async logout(): Promise<void> {
        await this.clearToken();
      }
    }
    

### 2\. AudioManager çš„å®ç°

    class AudioManager {
      private static instance: AudioManager;
      private currentAudio: HTMLAudioElement | null = null;
      private currentWordId: number | null = null;
      private playingCallbacks: Map<number, (isPlaying: boolean) => void> = new Map();
    
      static getInstance(): AudioManager {
        if (!AudioManager.instance) {
          AudioManager.instance = new AudioManager();
        }
        return AudioManager.instance;
      }
    
      // Register playback status callback
      registerCallback(wordId: number, callback: (isPlaying: boolean) => void) {
        this.playingCallbacks.set(wordId, callback);
      }
    
      // Unregister callback
      unregisterCallback(wordId: number) {
        this.playingCallbacks.delete(wordId);
      }
    
      // Play audio
      async playAudio(wordId: number, audioUrl: string): Promise<void> {
        try {
          // Stop currently playing audio
          this.stopCurrentAudio();
    
          // Create new audio instance
          const audio = new Audio(audioUrl);
          this.currentAudio = audio;
          this.currentWordId = wordId;
    
          // Set audio properties
          audio.preload = 'auto';
          audio.volume = 1.0;
    
          // Notify playback start
          this.notifyPlayingState(wordId, true);
    
          // Listen to audio events
          audio.addEventListener('ended', () => {
            this.handleAudioEnd();
          });
    
          audio.addEventListener('error', (e) => {
            console.error('Audio playback error:', e);
            this.handleAudioEnd();
          });
    
          // Play audio
          await audio.play();
        } catch (error) {
          console.error('Failed to play audio:', error);
          this.handleAudioEnd();
        }
      }
    
      // Stop current audio
      private stopCurrentAudio() {
        if (this.currentAudio) {
          this.currentAudio.pause();
          this.currentAudio.currentTime = 0;
          this.currentAudio = null;
        }
        if (this.currentWordId !== null) {
          this.notifyPlayingState(this.currentWordId, false);
          this.currentWordId = null;
        }
      }
    
      // Handle audio end
      private handleAudioEnd() {
        if (this.currentWordId !== null) {
          this.notifyPlayingState(this.currentWordId, false);
        }
        this.currentAudio = null;
        this.currentWordId = null;
      }
    
      // Notify playback state change
      private notifyPlayingState(wordId: number, isPlaying: boolean) {
        const callback = this.playingCallbacks.get(wordId);
        if (callback) {
          callback(isPlaying);
        }
      }
    
      // Check if currently playing
      isPlaying(wordId: number): boolean {
        return this.currentWordId === wordId && this.currentAudio !== null;
      }
    }
    

### 3\. ServerConfig çš„å®ç°

    class ServerConfig {
      private static instance: ServerConfig;
      private config: ServerConfigInterface;
    
      private constructor() {
        this.config = this.loadConfig();
      }
    
      public static getInstance(): ServerConfig {
        if (!ServerConfig.instance) {
          ServerConfig.instance = new ServerConfig();
        }
        return ServerConfig.instance;
      }
    
      private loadConfig(): ServerConfigInterface {
        const serverDomain = location.origin;
    
        const url = new URL(serverDomain);
    
        return {
          domain: url.hostname,
          port: url.port ? parseInt(url.port) : (url.protocol === 'https:' ? 443 : 80),
          protocol: url.protocol.replace(':', ''),
        };
      }
    
      public getDomain(): string {
        return this.config.domain;
      }
    
      public getPort(): number {
        return this.config.port || 80;
      }
    
      public getProtocol(): string {
        return this.config.protocol || 'http';
      }
    
      public getBaseUrl(): string {
        const port = this.getPort();
        const protocol = this.getProtocol();
        const domain = this.getDomain();
    
        if ((protocol === 'http' && port === 80) || (protocol === 'https' && port === 443)) {
          return `${protocol}://${domain}`;
        }
    
        return `${protocol}://${domain}:${port}`;
      }
    
      public getFullUrl(path: string = ''): string {
        const baseUrl = this.getBaseUrl();
        const cleanPath = path.startsWith('/') ? path : `/${path}`;
        return `${baseUrl}${cleanPath}`;
      }
    }
    

å®é™…åº”ç”¨ç¤ºä¾‹ï¼šCherry Studio
--------------------

ğŸ’ [Cherry Studio](https://github.com/CherryHQ/cherry-studio) æ˜¯ä¸€æ¬¾æ”¯æŒå¤šä¸ªå¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰æœåŠ¡å•†çš„æ¡Œé¢å®¢æˆ·ç«¯ï¼Œå…¼å®¹ Windowsã€Mac å’Œ Linux ç³»ç»Ÿã€‚ã€‚

è¯¥é¡¹ç›®å‰ç«¯æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œ é‡‡ç”¨è‰¯å¥½çš„è®¾è®¡ååˆ†å¿…è¦ã€‚å®ƒçš„ä»£ç ä¸­ä¹Ÿå­˜åœ¨å¤§é‡çš„å•ä¾‹æ¨¡å¼è®¾è®¡ã€‚

### 1\. StoreSyncService çš„å®ç°

    import { IpcChannel } from '@shared/IpcChannel'
    import type { StoreSyncAction } from '@types'
    import { BrowserWindow, ipcMain } from 'electron'
    
    /**
     * StoreSyncService class manages Redux store synchronization between multiple windows in the main process
     * It uses singleton pattern to ensure only one sync service instance exists in the application
     *
     * Main features:
     * 1. Manages window subscriptions for store sync
     * 2. Handles IPC communication for store sync between windows
     * 3. Broadcasts Redux actions from one window to all other windows
     * 4. Adds metadata to synced actions to prevent infinite sync loops
     */
    export class StoreSyncService {
      private static instance: StoreSyncService
      private windowIds: number[] = []
      private isIpcHandlerRegistered = false
    
      private constructor() {
        return
      }
    
      /**
       * Get the singleton instance of StoreSyncService
       */
      public static getInstance(): StoreSyncService {
        if (!StoreSyncService.instance) {
          StoreSyncService.instance = new StoreSyncService()
        }
        return StoreSyncService.instance
      }
    
      /**
       * Subscribe a window to store sync
       * @param windowId ID of the window to subscribe
       */
      public subscribe(windowId: number): void {
        if (!this.windowIds.includes(windowId)) {
          this.windowIds.push(windowId)
        }
      }
    
      /**
       * Unsubscribe a window from store sync
       * @param windowId ID of the window to unsubscribe
       */
      public unsubscribe(windowId: number): void {
        this.windowIds = this.windowIds.filter((id) => id !== windowId)
      }
    
      /**
       * Sync an action to all renderer windows
       * @param type Action type, like 'settings/setTray'
       * @param payload Action payload
       *
       * NOTICE: DO NOT use directly in ConfigManager, may cause infinite sync loop
       */
      public syncToRenderer(type: string, payload: any): void {
        const action: StoreSyncAction = {
          type,
          payload
        }
    
        //-1 means the action is from the main process, will be broadcast to all windows
        this.broadcastToOtherWindows(-1, action)
      }
    
      /**
       * Register IPC handlers for store sync communication
       * Handles window subscription, unsubscription and action broadcasting
       */
      public registerIpcHandler(): void {
        if (this.isIpcHandlerRegistered) return
    
        ipcMain.handle(IpcChannel.StoreSync_Subscribe, (event) => {
          const windowId = BrowserWindow.fromWebContents(event.sender)?.id
          if (windowId) {
            this.subscribe(windowId)
          }
        })
    
        ipcMain.handle(IpcChannel.StoreSync_Unsubscribe, (event) => {
          const windowId = BrowserWindow.fromWebContents(event.sender)?.id
          if (windowId) {
            this.unsubscribe(windowId)
          }
        })
    
        ipcMain.handle(IpcChannel.StoreSync_OnUpdate, (event, action: StoreSyncAction) => {
          const sourceWindowId = BrowserWindow.fromWebContents(event.sender)?.id
    
          if (!sourceWindowId) return
    
          // Broadcast the action to all other windows
          this.broadcastToOtherWindows(sourceWindowId, action)
        })
    
        this.isIpcHandlerRegistered = true
      }
    
      /**
       * Broadcast a Redux action to all other windows except the source
       * @param sourceWindowId ID of the window that originated the action
       * @param action Redux action to broadcast
       */
      private broadcastToOtherWindows(sourceWindowId: number, action: StoreSyncAction): void {
        // Add metadata to indicate this action came from sync
        const syncAction = {
          ...action,
          meta: {
            ...action.meta,
            fromSync: true,
            source: `windowId:${sourceWindowId}`
          }
        }
    
        // Send to all windows except the source
        this.windowIds.forEach((windowId) => {
          if (windowId !== sourceWindowId) {
            const targetWindow = BrowserWindow.fromId(windowId)
            if (targetWindow && !targetWindow.isDestroyed()) {
              targetWindow.webContents.send(IpcChannel.StoreSync_BroadcastSync, syncAction)
            } else {
              this.unsubscribe(windowId)
            }
          }
        })
      }
    }
    
    // Export singleton instance
    export default StoreSyncService.getInstance()
    

### 2\. NotificationQueue çš„å®ç°

    import type { Notification } from '@renderer/types/notification'
    import PQueue from 'p-queue'
    
    type NotificationListener = (notification: Notification) => Promise<void> | void
    
    export class NotificationQueue {
      private static instance: NotificationQueue
      private queue = new PQueue({ concurrency: 1 })
      private listeners: NotificationListener[] = []
    
      // oxlint-disable-next-line @typescript-eslint/no-empty-function
      private constructor() {}
    
      public static getInstance(): NotificationQueue {
        if (!NotificationQueue.instance) {
          NotificationQueue.instance = new NotificationQueue()
        }
        return NotificationQueue.instance
      }
    
      public subscribe(listener: NotificationListener) {
        this.listeners.push(listener)
      }
    
      public unsubscribe(listener: NotificationListener) {
        this.listeners = this.listeners.filter((l) => l !== listener)
      }
    
      public async add(notification: Notification): Promise<void> {
        await this.queue.add(() => Promise.all(this.listeners.map((listener) => listener(notification))))
      }
    
      /**
       * æ¸…ç©ºé€šçŸ¥é˜Ÿåˆ—
       */
      public clear(): void {
        this.queue.clear()
      }
    
      /**
       * è·å–é˜Ÿåˆ—ä¸­ç­‰å¾…çš„ä»»åŠ¡æ•°é‡
       */
      public get pending(): number {
        return this.queue.pending
      }
    
      /**
       * è·å–é˜Ÿåˆ—çš„å¤§å°ï¼ˆåŒ…æ‹¬æ­£åœ¨è¿›è¡Œå’Œç­‰å¾…çš„ä»»åŠ¡ï¼‰
       */
      public get size(): number {
        return this.queue.size
      }
    }
    

### 3\. AgentService çš„å®ç°

    import path from 'node:path'
    
    import { loggerService } from '@logger'
    import { pluginService } from '@main/services/agents/plugins/PluginService'
    import { getDataPath } from '@main/utils'
    import type {
      AgentEntity,
      CreateAgentRequest,
      CreateAgentResponse,
      GetAgentResponse,
      ListOptions,
      UpdateAgentRequest,
      UpdateAgentResponse
    } from '@types'
    import { AgentBaseSchema } from '@types'
    import { asc, count, desc, eq } from 'drizzle-orm'
    
    import { BaseService } from '../BaseService'
    import { type AgentRow, agentsTable, type InsertAgentRow } from '../database/schema'
    import type { AgentModelField } from '../errors'
    
    const logger = loggerService.withContext('AgentService')
    
    export class AgentService extends BaseService {
      private static instance: AgentService | null = null
      private readonly modelFields: AgentModelField[] = ['model', 'plan_model', 'small_model']
    
      static getInstance(): AgentService {
        if (!AgentService.instance) {
          AgentService.instance = new AgentService()
        }
        return AgentService.instance
      }
    
      async initialize(): Promise<void> {
        await BaseService.initialize()
      }
    
      // Agent Methods
      async createAgent(req: CreateAgentRequest): Promise<CreateAgentResponse> {
        this.ensureInitialized()
    
        const id = `agent_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`
        const now = new Date().toISOString()
    
        if (!req.accessible_paths || req.accessible_paths.length === 0) {
          const defaultPath = path.join(getDataPath(), 'agents', id)
          req.accessible_paths = [defaultPath]
        }
    
        if (req.accessible_paths !== undefined) {
          req.accessible_paths = this.ensurePathsExist(req.accessible_paths)
        }
    
        await this.validateAgentModels(req.type, {
          model: req.model,
          plan_model: req.plan_model,
          small_model: req.small_model
        })
    
        const serializedReq = this.serializeJsonFields(req)
    
        const insertData: InsertAgentRow = {
          id,
          type: req.type,
          name: req.name || 'New Agent',
          description: req.description,
          instructions: req.instructions || 'You are a helpful assistant.',
          model: req.model,
          plan_model: req.plan_model,
          small_model: req.small_model,
          configuration: serializedReq.configuration,
          accessible_paths: serializedReq.accessible_paths,
          created_at: now,
          updated_at: now
        }
    
        await this.database.insert(agentsTable).values(insertData)
        const result = await this.database.select().from(agentsTable).where(eq(agentsTable.id, id)).limit(1)
        if (!result[0]) {
          throw new Error('Failed to create agent')
        }
    
        const agent = this.deserializeJsonFields(result[0]) as AgentEntity
        return agent
      }
    
      async getAgent(id: string): Promise<GetAgentResponse | null> {
        this.ensureInitialized()
    
        const result = await this.database.select().from(agentsTable).where(eq(agentsTable.id, id)).limit(1)
    
        if (!result[0]) {
          return null
        }
    
        const agent = this.deserializeJsonFields(result[0]) as GetAgentResponse
        agent.tools = await this.listMcpTools(agent.type, agent.mcps)
    
        // Load installed_plugins from cache file instead of database
        const workdir = agent.accessible_paths?.[0]
        if (workdir) {
          try {
            agent.installed_plugins = await pluginService.listInstalledFromCache(workdir)
          } catch (error) {
            // Log error but don't fail the request
            logger.warn(`Failed to load installed plugins for agent ${id}`, {
              workdir,
              error: error instanceof Error ? error.message : String(error)
            })
            agent.installed_plugins = []
          }
        } else {
          agent.installed_plugins = []
        }
    
        return agent
      }
    
      async listAgents(options: ListOptions = {}): Promise<{ agents: AgentEntity[]; total: number }> {
        this.ensureInitialized() // Build query with pagination
    
        const totalResult = await this.database.select({ count: count() }).from(agentsTable)
    
        const sortBy = options.sortBy || 'created_at'
        const orderBy = options.orderBy || 'desc'
    
        const sortField = agentsTable[sortBy]
        const orderFn = orderBy === 'asc' ? asc : desc
    
        const baseQuery = this.database.select().from(agentsTable).orderBy(orderFn(sortField))
    
        const result =
          options.limit !== undefined
            ? options.offset !== undefined
              ? await baseQuery.limit(options.limit).offset(options.offset)
              : await baseQuery.limit(options.limit)
            : await baseQuery
    
        const agents = result.map((row) => this.deserializeJsonFields(row)) as GetAgentResponse[]
    
        for (const agent of agents) {
          agent.tools = await this.listMcpTools(agent.type, agent.mcps)
        }
    
        return { agents, total: totalResult[0].count }
      }
    
      async updateAgent(
        id: string,
        updates: UpdateAgentRequest,
        options: { replace?: boolean } = {}
      ): Promise<UpdateAgentResponse | null> {
        this.ensureInitialized()
    
        // Check if agent exists
        const existing = await this.getAgent(id)
        if (!existing) {
          return null
        }
    
        const now = new Date().toISOString()
    
        if (updates.accessible_paths !== undefined) {
          updates.accessible_paths = this.ensurePathsExist(updates.accessible_paths)
        }
    
        const modelUpdates: Partial<Record<AgentModelField, string | undefined>> = {}
        for (const field of this.modelFields) {
          if (Object.prototype.hasOwnProperty.call(updates, field)) {
            modelUpdates[field] = updates[field as keyof UpdateAgentRequest] as string | undefined
          }
        }
    
        if (Object.keys(modelUpdates).length > 0) {
          await this.validateAgentModels(existing.type, modelUpdates)
        }
    
        const serializedUpdates = this.serializeJsonFields(updates)
    
        const updateData: Partial<AgentRow> = {
          updated_at: now
        }
        const replaceableFields = Object.keys(AgentBaseSchema.shape) as (keyof AgentRow)[]
        const shouldReplace = options.replace ?? false
    
        for (const field of replaceableFields) {
          if (shouldReplace || Object.prototype.hasOwnProperty.call(serializedUpdates, field)) {
            if (Object.prototype.hasOwnProperty.call(serializedUpdates, field)) {
              const value = serializedUpdates[field as keyof typeof serializedUpdates]
              ;(updateData as Record<string, unknown>)[field] = value ?? null
            } else if (shouldReplace) {
              ;(updateData as Record<string, unknown>)[field] = null
            }
          }
        }
    
        await this.database.update(agentsTable).set(updateData).where(eq(agentsTable.id, id))
        return await this.getAgent(id)
      }
    
      async deleteAgent(id: string): Promise<boolean> {
        this.ensureInitialized()
    
        const result = await this.database.delete(agentsTable).where(eq(agentsTable.id, id))
    
        return result.rowsAffected > 0
      }
    
      async agentExists(id: string): Promise<boolean> {
        this.ensureInitialized()
    
        const result = await this.database
          .select({ id: agentsTable.id })
          .from(agentsTable)
          .where(eq(agentsTable.id, id))
          .limit(1)
    
        return result.length > 0
      }
    }
    
    export const agentService = AgentService.getInstance()
    

æ€»ç»“
--

å•ä¾‹æ¨¡å¼åœ¨ TypeScript ä¸­æ˜¯ä¸€ä¸ªå¼ºå¤§è€Œæœ‰ç”¨çš„æ¨¡å¼ï¼Œä½†éœ€è¦è°¨æ…ä½¿ç”¨ã€‚é€šè¿‡åˆç†çš„å®ç°å’Œé€‚å½“çš„ä½¿ç”¨åœºæ™¯ï¼Œå®ƒå¯ä»¥æœ‰æ•ˆåœ°ç®¡ç†å…¨å±€èµ„æºå’ŒçŠ¶æ€ã€‚è®°ä½ï¼Œå•ä¾‹æ¨¡å¼ä¸æ˜¯ä¸‡èƒ½çš„ï¼Œåœ¨å†³å®šä½¿ç”¨ä¹‹å‰ï¼Œè¯·ç¡®ä¿å®ƒç¡®å®æ˜¯è§£å†³ä½ é—®é¢˜çš„æœ€ä½³æ–¹æ¡ˆã€‚