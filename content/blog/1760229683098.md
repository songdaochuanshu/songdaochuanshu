---
layout: post
title: '我把Excel变成了像素画板！用Python实现图片到单元格的映射'
date: "2025-10-12T00:41:23Z"
---
我把Excel变成了像素画板！用Python实现图片到单元格的映射
=================================

![我把Excel变成了像素画板！用Python实现图片到单元格的映射](https://img2024.cnblogs.com/blog/3687401/202510/3687401-20251011151041803-2112452857.png) 这篇文章介绍了一个用Python将图片转换为Excel像素画的工具。通过OpenCV读取图片像素值，使用openpyxl在Excel单元格填充对应颜色，实现图片到Excel的映射。工具包含GUI界面，支持图片预览和进度显示，默认将图片缩放至320像素宽以优化性能。核心代码仅100余行，涉及图像处理、Excel操作和界面交互。作者分享了完整实现思路、环境配置和使用步骤，并提供了可执行文件。该工具展示了编程将创意想法落地的过程，适合对图像处理和自动化感兴趣的开发者学习参考。

​

 视频演示
-----

[我把Excel变成了像素画板！用Python实现图片到单元格的映射](https://www.bilibili.com/video/BV1UP4nzsEop/)

* * *

大家好，这里是Coding茶水间！

最近做了一个有趣的小工具：用 Python 把任意图片“复刻”成 Excel 表格艺术。

通过解析图片像素值，然后在 Excel 单元格中填充对应颜色，就能生成一张由无数小方格组成的“像素画”。

这个工具不复杂，适合对图像处理和自动化感兴趣的小伙伴研究。

在这篇图文教程中，我会一步步带你了解工具的原理、代码实现和使用方法。

代码基于 PyQt5（GUI 界面）、OpenCV（图像处理）和 openpyxl（Excel 操作），简单易上手。感兴趣的同学可以直接 fork 代码试试！

工具效果预览
------

先来看看成品效果吧！左边是原图，右边是生成的 Excel 艺术（每个单元格就是一个像素）。

另一个例子，我换了张猫咪图片，生成后效果如下：

_（截图说明：工具自动缩放图片到 320 宽，生成低分辨率 Excel 以节省资源，但细节依然清晰）_

手工操作这种效果？想想看，一张 320x240 的图片就需要 76,800 个单元格手动填色……太恐怖了！用程序，几秒钟搞定。

实现原理
----

核心思路很简单：

1.  **读取图片**：用 OpenCV 加载图像，获取每个像素的 RGB 值。
2.  **缩放处理**：为了避免高分辨率图片占用过多资源，默认将宽度固定为 320，高度按比例缩放。
3.  **生成 Excel**：用 openpyxl 创建工作表，每个像素对应一个单元格，填充对应颜色的 PatternFill。
4.  **GUI 界面**：PyQt5 提供简单界面，选择图片和保存路径，一键绘制，还带进度条显示。

环境准备
----

*   Python 3.8+
*   依赖库：pip install PyQt5 opencv-python openpyxl numpy
*   UI 文件：用 Qt Designer 设计 excel\_ui.py（我用的是一个简单的窗口，包含图片预览、路径输入和按钮）。

如果懒得配置环境，我还打包了 EXE 可执行文件（脱离 Python 环境）

完整代码
----

下面是核心代码，分为主窗口类和入口。代码不长，注释详尽。

    import sys
    from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog, QMessageBox, QProgressDialog
    from PyQt5.QtGui import QImage, QPixmap
    from excel_ui import Ui_MainWindow  # Qt Designer 生成的 UI 文件
    from PyQt5.QtCore import Qt, QTimer
    import cv2
    import numpy as np
    import openpyxl
    from openpyxl.styles import PatternFill
    from openpyxl.utils import get_column_letter
    
    class MainWindow(QMainWindow, Ui_MainWindow):
        def __init__(self, parent=None):
            super().__init__(parent)
            self.setupUi(self)
            self.img_ori = None  # 存储原始图像
    
        def select_pic(self):
            """选择图片并预览"""
            file_path, _ = QFileDialog.getOpenFileName(self, "选择图片", "", "Image Files(*.png *.jpg *.jpeg *.bmp)")
            if file_path:
                self.img_ori = cv2.imread(file_path)
                img = cv2.cvtColor(self.img_ori, cv2.COLOR_BGR2RGB)
                h, w, ch = img.shape
                bytes_per_line = ch * w
                q_image = QImage(img.data, w, h, bytes_per_line, QImage.Format.Format_RGB888)
                q_pixmap = QPixmap.fromImage(q_image)
                self.imageLabel.setPixmap(q_pixmap.scaled(
                    self.imageLabel.width(), self.imageLabel.height(),
                    Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation
                ))
    
        def select_excel(self):
            """选择 Excel 保存路径"""
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "设置 Excel 路径",
                "",
                "Excel Files (*.xlsx *.xls)"
            )
            if file_path:
                self.excelPathLineEdit.setText(file_path)
                return file_path
            else:
                return None
    
        def huizhi(self):
            """绘制图片到 Excel"""
            if not hasattr(self, 'img_ori') or self.img_ori is None:
                QMessageBox.warning(self, "警告", "请先选择图片！")
                return
            excel_path = self.excelPathLineEdit.text()
            if not excel_path:
                QMessageBox.warning(self, "警告", "请先选择 Excel 文件保存路径！")
                return
            try:
                # 强制缩放宽度为 320，高度按比例计算
                min_width = 320
                image = self.img_ori
                height, width = image.shape[:2]
                scale_factor = min_width / width
                new_width = min_width
                new_height = int(height * scale_factor)
                image = cv2.resize(image, (new_width, new_height))
    
                # 创建 Excel 工作簿
                workbook = openpyxl.Workbook()
                sheet = workbook.active
    
                # 设置单元格为正方形（宽度 3，高度 17）
                for col in range(1, new_width + 1):
                    sheet.column_dimensions[get_column_letter(col)].width = 3
                for row in range(1, new_height + 1):
                    sheet.row_dimensions[row].height = 17
    
                # 创建进度条
                progress = QProgressDialog("正在绘制图片到 Excel...", "取消", 0, new_height, self)
                progress.setWindowTitle("进度")
                progress.setWindowModality(Qt.WindowModal)
                progress.setValue(0)
    
                # 遍历图片像素并填充 Excel 单元格
                for y in range(new_height):
                    if progress.wasCanceled():
                        break
                    for x in range(new_width):
                        b, g, r = image[y, x]  # OpenCV 默认 BGR 格式
                        color = "{:02x}{:02x}{:02x}".format(r, g, b)  # 转换为 RGB 格式的十六进制
                        if color == "000000":
                            color = "010101"  # 纯黑色替换为深灰色
                        fill = PatternFill(start_color=color, end_color=color, fill_type="solid")
                        sheet.cell(row=y + 1, column=x + 1).fill = fill
                    progress.setValue(y + 1)
                    QApplication.processEvents()  # 确保 UI 更新
    
                # 保存 Excel 文件
                if not progress.wasCanceled():
                    workbook.save(excel_path)
                    QMessageBox.information(self, "成功", "图片已成功绘制到 Excel 文件！")
                progress.close()
            except Exception as e:
                QMessageBox.critical(self, "错误", f"绘制失败: {str(e)}")
    
    if __name__ == '__main__':
        app = QApplication(sys.argv)
        window = MainWindow()
        window.show()
        sys.exit(app.exec())

### 代码亮点解析

*   **图像预览**：select\_pic() 用 QImage 实时显示选中的图片，保持宽高比。
*   **缩放优化**：cv2.resize() 固定宽度 320，避免高分辨率卡顿。实际 Excel 文件大小控制在合理范围内。
*   **像素填充**：双层循环遍历 (y, x)，转 RGB 十六进制，应用 PatternFill。进度条用 QProgressDialog 实时反馈。
*   **异常处理**：捕获保存错误，友好提示。

使用步骤
----

1.  运行程序（python main.py 或双击 EXE）。
2.  点击“选择图片”，挑选一张 PNG/JPG 等格式的图像，界面会预览。
3.  点击“选择 Excel 路径”，设置保存文件名（.xlsx）。
4.  点击“开始绘制”，等待进度条完成。
5.  打开生成的 Excel，Ctrl + 滚轮缩放查看效果！（建议全屏查看）

结语
--

这个小工具就是下午“无聊”时写的，编程的乐趣就在于把不可能变可能。

如果你有图像处理项目灵感，评论区聊聊～别忘了三连（点赞、收藏、关注）支持下，更多干货见！

如果代码有 bug 或优化建议，随时 issue 我。玩得开心！

​