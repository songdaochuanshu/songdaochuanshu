---
layout: post
title: '2025 年的 PHP 虽低调内敛没大改 但是更好用了'
date: "2025-12-31T00:45:51Z"
---
2025 年的 PHP 虽低调内敛没大改 但是更好用了
===========================

2025 年 PHP 的“反常识”变化
-------------------

2025 年的 PHP 并没有上演“脱胎换骨”。相反，它做的是更工程化、更实在的改进：把那些最容易割伤人的细节一点点打磨平整。

你只要真的在生产环境里跑 PHP ，就会在这些地方感受到变化：

*   写领域规则更顺手：不必靠一堆 getter/setter 才能把约束讲清楚。
*   工具链更“较真”：对正确性更有立场，对“反正能跑”更不耐烦。
*   框架生态继续抬高基线： PHP 8.2+ 已经不是尝鲜，而是默认门槛。比如 Laravel 12 的最低版本仍是 PHP 8.2。 (Laravel)
*   PHP 8.5 于 2025 年 11 月发布，定位并不炫酷，却很像生产力放大器——前提是你愿意采用它更鼓励的写法。 (PHP)

这不是功能清单，而是“工程体感总结”：哪些变化真的改变了日常写代码的方式，哪些做法减少了事故，以及哪些教训值得更早接受。

[原文 2025 年的 PHP：没大改，却更好用了](https://catchadmin.com/post/2025-12/php-in-2025-what-changed-what-stuck-next-time)

趋势 #1： PHP 8.4 让“规矩、朴素”的代码更容易写
------------------------------

PHP 8.4 虽然在 2024 年末发布，但 2025 年才在大多数团队里“落地”。原因很简单：生产升级从来不是一键完成。最关键的变化是 property hooks 与 asymmetric visibility。 (PHP)

### Property hooks：把规则贴在数据旁边

以前你要表达不变式，常常会写成：私有属性 + getter/setter。它并不错误，但很容易让一个简单概念变得臃肿、仪式感过强。

Property hooks 的价值在于：你可以在“读/写属性的那一刻”把规则讲明白，不再依赖大量样板。

    <?php
    final class Money
    {
        public function __construct(
            public string $currency,
            public int $amountCents
        ) {
            if ($this->amountCents < 0) {
                throw new InvalidArgumentException("Amount cannot be negative.");
            }
            if (!preg_match('/^[A-Z]{3}$/', $this->currency)) {
                throw new InvalidArgumentException("Currency must be ISO-4217 format.");
            }
        }
    }
    final class Invoice
    {
        public function __construct(
            public Money $total
        ) {}
        public Money $paid
        {
            set (Money $value) {
                if ($value->currency !== $this->total->currency) {
                    throw new InvalidArgumentException("Currency mismatch.");
                }
                if ($value->amountCents > $this->total->amountCents) {
                    throw new InvalidArgumentException("Overpayment is not allowed.");
                }
                $this->paid = $value;
            }
        }
    }
    

工程上的直观收益是：校验不再散落在各个 service 里，而能更自然地贴近它要保护的状态。

现场教训：用 property hooks 做校验很合适；但如果你拿它做数据库 lazy-loading 之类的隐式 IO ，你会得到更难追踪的行为与更痛苦的调试体验。

### Asymmetric visibility：读给外部看，写留给内部做

很多领域对象都想要“对外可读、对内可写”。过去你不是开 setter ，就是绕路。现在 PHP 8.4 把这种需求变得更直白。 (PHP)

    <?php
    final class Shipment
    {
        public function __construct(
            public private(set) string $status = 'CREATED',
        ) {}
        public function markInTransit(): void
        {
            $this->status = 'IN_TRANSIT';
        }
    }
    

它减少了那种“为了 hydration/为了测试”而暴露 setter 的冲动——而这类冲动往往会无意间扩大系统的可变性与接口面。

趋势 #2： PHP 8.5 更像一次“写起来更舒服”的升级
------------------------------

PHP 8.5 在 2025 年 11 月 20 日发布。 (PHP)  
相比轰动性的语法革新，它更像在开发体验上做加法： pipe operator ，以及更顺手的 clone-and-modify（社区常说 “clone with”）。 (stitcher.io)

### Pipe operator：把数据处理写成清晰的流水线

业务代码里，数据变换非常常见。过去你要么写成嵌套调用，要么堆中间变量。 Pipe 的好处是：按步骤阅读更自然。

    <?php
    function trimAll(array $xs): array {
        return array_map('trim', $xs);
    }
    function dropEmpty(array $xs): array {
        return array_values(array_filter($xs, fn($x) => $x !== ''));
    }
    function unique(array $xs): array {
        return array_values(array_unique($xs));
    }
    $tags = ['  php ', '', 'backend', 'PHP', 'backend '];
    $normalized = $tags
        |> trimAll(...)
        |> dropEmpty(...)
        |> array_map(strtolower(...), ...)
        |> unique(...);
    print_r($normalized);
    

现场教训：每一步要“小且命名明确”。如果你一路 pipe 进匿名函数的大段逻辑，可读性会反过来下降。

### URI 扩展：少写正则，多用标准解析

发布公告提到专门的 URI 扩展。 (PHP)  
只要你做过重定向、回调、 OAuth 、支付、 webhook ，你就知道 URL 解析的坑有多“顽固”。方向上的价值很明确：用标准组件替换零散 regex。

### clone-and-modify：更安全的“复制后微调”

DTO 、 command 、 event 这些“近似不可变对象”越来越常见。过去你要么 clone 后再手动改（容易漏），要么到处写 withX()。

PHP 8.5 明确支持在 cloning 同时修改属性。 (PHP)  
这会鼓励团队更多使用“复制后小改动”的安全模式。

    <?php
    final class CustomerProfile
    {
        public function __construct(
            public string $id,
            public string $email,
            public bool $marketingOptIn,
        ) {}
    }
    $old = new CustomerProfile('c-123', 'old@mail.com', false);
    // Pseudocode-ish shape for the pattern:
    $new = clone $old;
    $new->email = 'new@mail.com';
    

趋势 #3：框架把门槛抬高了，你的依赖也会被一起拖着走
---------------------------

### Laravel：靠“稳定与无聊”赢

Laravel 12 延续维护导向，同时保持 PHP 8.2+ 基线。 (Laravel)  
现实影响很直接：停在 PHP 8.0/8.1 的服务，会越来越难享受生态更新与安全支持。

### Symfony：快节奏是压力，也是优势

Symfony 的时间线显示： Symfony 8.0 在 2025 年 11 月作为稳定线，并要求 PHP 8.4+。 (Symfony)  
同时官方也给出了面向 2025 年 11 月下旬发布的准备建议。 (Symfony)

现场教训： LTS 还是 latest ，本质是运维策略与预算问题。多服务体系里，最好明确一个默认选项，并公开例外。

趋势 #4：静态分析从“加分项”变成“底线”
----------------------

PHPStan 2.x 让越来越多团队把它放进合并门禁，因为它命中的 bug 往往就是事故前身。 (phpstan.org)

稳妥的引入方式是渐进式，而不是一夜拉满：

*   从低等级开始，先让 CI 跑起来但不阻断。
*   修掉显而易见的问题：类型缺失、死分支、无意义 null 判断。
*   baseline 只能当过渡，必须计划消化。
*   逐模块提升门槛。

示例配置与 CI：

    parameters:
      level: 6
      paths:
        - src
      tmpDir: var/phpstan
      checkMissingIterableValueType: false
      reportUnmatchedIgnoredErrors: true
    

    composer require --dev phpstan/phpstan
    vendor/bin/phpstan analyse --memory-limit=1G
    

趋势 #5：测试写得更轻松，但执行标准更现代
----------------------

*   PHPUnit 11 要求 PHP 8.2+， PHPUnit 12 要求 PHP 8.3+。 (phpunit.de)
*   Pest 4 要求 PHP 8.3+（ 2025 年 8 月发布）， Pest 3 对齐 PHP 8.2+。 (pestphp.com)

Pest 的优势是降低写测试的阻力，尤其适合应用层测试。例子如下：

    <?php
    final class Discount
    {
        public function apply(int $priceCents, int $percent): int
        {
            if ($percent < 0 || $percent > 100) {
                throw new InvalidArgumentException("Percent must be 0..100");
            }
            $cut = (int) round($priceCents * ($percent / 100));
            return max(0, $priceCents - $cut);
        }
    }
    

    <?php
    use PHPUnit\Framework\Attributes\Test;
    it('applies percentage discount safely', function () {
        $d = new Discount();
        expect($d->apply(10000, 10))->toBe(9000);
        expect($d->apply(10000, 0))->toBe(10000);
        expect($d->apply(10000, 100))->toBe(0);
    });
    it('rejects invalid percentages', function () {
        $d = new Discount();
        expect(fn() => $d->apply(10000, -1))->toThrow(InvalidArgumentException::class);
        expect(fn() => $d->apply(10000, 101))->toThrow(InvalidArgumentException::class);
    });
    

现场教训：优先测边界——这些地方最容易出事故：四舍五入、时间窗、幂等、空值、格式化。

趋势 #6： Composer 更安全导向，依赖成了供应链问题
-------------------------------

Composer 的演进持续强化一个观念：依赖管理是生产基础设施。 (getcomposer.org)  
2025 年末的 GitHub release notes 也体现了对安全与审计行为的加强。 (GitHub)

实用卫生习惯包括：提交 lock 、使用 composer audit 、保持 platform 约束一致、定期依赖更新。

    {
      "require": {
        "php": "^8.3"
      },
      "config": {
        "platform": {
          "php": "8.3.0"
        }
      }
    }
    

趋势 #7：工具更 AI ，但 adoption 的关键仍是 IDE
----------------------------------

PhpStorm 2025.3 提到对 PHP 8.5 的支持与 agent 集成。 (The JetBrains Blog)  
现实是： IDE 如果不支持新语法，新特性很难进入团队日常写法。

生产上最值得坚持的清单
-----------

*   把升级当作可管理的产品工作：定目标、做双版本 CI 、按顺序升级。
*   做清晰边界：输入 DTO → 领域对象 → 输出映射。
*   追求可调试性：减少隐式 null 、数组契约、无幂等重试。
*   把可观测性放在关键决策点：结构化日志、 correlation ID。
*   用语言特性降低偶然复杂度，而不是制造花活。

结论
--

2025 年的 PHP 更偏向奖励“稳定与克制”。 PHP 8.4 帮你更清楚地表达意图， PHP 8.5 让常见变换与不可变风格更顺手。 (PHP)  
真正跑得更快的团队，往往不是追新，而是用这些变化把系统变得更可预测。