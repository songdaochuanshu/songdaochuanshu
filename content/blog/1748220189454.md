---
layout: post
title: 'XXL-MQ v1.4.0 | 轻量级分布式消息队列'
date: "2025-05-26T00:43:09Z"
---
XXL-MQ v1.4.0 | 轻量级分布式消息队列
==========================

### Release Notes

*   1、【重构】XXL-MQ 核心代码重构，基于“存算分离”与“分区机制”设计思想。在轻量级、分布式的基础上，强化高吞吐、海量消息及水平扩展能力。；
*   2、【新增】存算分离：消息中心（Broker）与消息存储层（Store）解耦。消息中心 提供消息OpenApi以及消息控制台管理能力；消息存储层 提供消息存储能力。得益于存算分离系统设计，消息中心支持水平扩展，支持线性提升消息吞吐及存储能力。
*   3、【新增】分区机制：针对消息数据进行分区路由计算及隔离，结合在线消费者进行 “分区动态平衡分配”（每个消费者分配负责分区区间），实现消费者与消息数据的灵活路由绑定。基于分区机制，灵活实现并行、串行、分片、Hash、广播...等多消息类型，保障系统高吞吐特性。
*   4、【增强】扩展支持多消息类型:
    *   并行消息：多个消费者并行消费数据，支持轮询或随机策略。适用于消息吞吐量较大的业务场景，如邮件发送、日志记录等。
    *   串行消息：同一时刻只有一个消费者消费数据，消息按照生产顺序FIFO串行消费。适用于有串行消费诉求的业务场景，如秒杀、抢单等场景；
    *   分片消息：支持根据业务参数进行Hash分片，相同分片的消息数据路由至同一个消费者FIFO串行消费，不同分片的消息数据路由至不同消费者并行执行。适用于有根据业务参数分片消费的业务场景，如短信发送，可实现同一个手机号（业务参数）的消息路由至单个消费者串行消息，同时全局消息分片并行消费。
    *   广播消息：消息发送后，广播发送给相关主题全部在线消费者。适用于广播消息场景，如广播通知、广播更新缓存等；
    *   延时消息：支持设置消息的延迟生效时间，到达设置的生效时间时该消息才会被消费。适用于延时消费场景，如订单超时取消、定时发送邮件等；
    *   失败重试消息：支持设置消息的失败重试次数，自定义重试间隔侧路，消息失败时会主动进行重试消费，直至重试次数耗尽或者消费成功。
*   5、【增强】海量消息：消息存储基于DB实现，支持Mysql、Blade多存储介质；消息存储进行冷热设计，并滚动式清理归档，支持海量消息堆积（Mysql存储支持千万级；Blade存储支持10亿级/理论无上限）。
*   6、【新增】超时控制: 支持自定义消息超时时间，消息消费超时将会主动中断；
*   7、【新增】跨语言/OpenAPI：提供语言无关的消息中心 OpenAPI（RESTFUL 格式），提供消息生产、拉取及消费等能力，实现多语言支持；
*   8、【增强】易用性提升: 一行代码即可发布一条消息，一行注解即可订阅一个消息主题，接入灵活方便；
*   9、【增强】消息可视化: 提供消息中心Web控制台，可在线管理消息主题、消息数据，查看消费数据及消费轨迹等；
*   10、【新增】容器化：提供官方Docker镜像，并实时更新推送DockerHub，进一步实现产品开箱即用；

### XXL-MQ 代码接入示例：

**步骤一**：开发 “消费者（Consumer）” 代码

    @XxlMq("topic_sample")
    public void consume() {    
        // 获取消息内容；
        String messageData = XxlMqHelper.getMessageData();
    
        // 设置消息消费结果，可选；不设置时，默认为消费成功；
        XxlMqHelper.consumeSuccess();
    }
    

**步骤二**：发送（生产）消息数据

    // 简单发送消息
    XxlMqHelper.produce("topic_sample", "消息数据" );
    
    // 指定延时生效时间
    XxlMqHelper.produce("topic_sample", "消息数据", effectTime, );
    

**步骤三**：消息Topic管理 （可选）  
登陆 “XXL-MQ消息中心” ，支持针对消息Topic进行管理维护，包括： “消息路由策略、归档清理策略、失败重试策略、超时时间控制” 等信息管理维护。  
（说明：该步骤为可选操作。消费者服务启动后将会自动注册生成 Topic信息，如果没有Topic信息定制修改诉求，可忽略该步骤。）

XXL-MQ 消息中心：消息主题（Topic）管理；  
![image](https://img2024.cnblogs.com/blog/554415/202505/554415-20250524231629609-1906886828.png)

XXL-MQ 消息中心：消息主题（Topic）编辑；  
![image](https://img2024.cnblogs.com/blog/554415/202505/554415-20250524231633130-623590877.png)

**步骤四**：消息数据管理（可选）  
登陆 “XXL-MQ消息中心” ，支持线上化管理维护消息数据，包括：“查询消费轨迹”、“消息数据清理”、“消息数据归档” 等管理操作。  
![image](https://img2024.cnblogs.com/blog/554415/202505/554415-20250524231638345-74770139.png)

### 项目简介：

XXL-MQ是一个轻量级分布式消息队列，具备“轻量级、分布式、高吞吐（单机TPS 10W+）、海量消息（亿级）” 等特性，支持 “并行消息、串行消息、分片消息、广播消息、延迟消息、失败重试消息”多消息类型，现已开放源代码，开箱即用。

*   **中文文档**：[https://www.xuxueli.com/xxl-mq/](https://www.xuxueli.com/xxl-mq/)
*   **Github**：[https://github.com/xuxueli/xxl-mq](https://github.com/xuxueli/xxl-mq)

![image](https://img2024.cnblogs.com/blog/554415/202505/554415-20250524231647224-1428268678.png)

### 项目特性：

*   1、简单易用: 一行代码即可发布一条消息，一行注解即可订阅一个消息主题，接入灵活方便；
*   2、轻量级: 除存储层（可选，支持MySQL/Blade），无第三方依赖；部署及运维低成本、轻量级。
*   3、水平扩展：得益于存算分离系统设计，消息中心为无状态服务；消息中心（Broker）及消费者（Client）均支持集群扩展部署，线形提升消息生产及吞吐能力；
*   4、高可用/HA：消息中心内置注册发现能力，支持Broker服务以及Topic消费者动态注册；消息中心与消费者单节点故障时，可自动摘除故障节点，实现消息吞吐及消费故障转移；
*   5、高吞吐：消息生产及消费链路进行批量、并行及异步系统设计，消息存储进行冷数据及时清理归档设计，实现消息高吞吐（Mysql存储单机吞吐1W；Blade存储单机吞吐10W）。
*   6、海量消息：消息存储基于DB实现，支持Mysql、Blade多存储介质；消息存储进行冷热设计，并滚动式清理归档，支持海量消息堆积（Mysql存储支持千万级；Blade存储支持10亿级/理论无上限）。
*   7、存算分离：消息中心（Broker）设计为无状态服务，提供主题及消息控制台管理能力以及消息RPC服务能力，与消息存储层解耦；
*   8、跨语言/OpenAPI：提供语言无关的消息中心 OpenAPI（RESTFUL 格式），提供消息生产、拉取及消费等能力，实现多语言支持；
*   9、实时性：消息中心与消费者基于JsonRpc进行吞吐消费，支持毫秒级生产投递、秒级消费感知，延迟消息基于时间轮机制支持零延迟消费感知；
*   10、消息持久化：消息数据默认持久化存储，并支持Topic维度自定义清理归档策略，灵活控制消息数据滚动归档清理；
*   11、分区路由策略：针对消息数据进行分区并路由消费者，提供丰富路由策略，包括：Hash、轮询、随机、第一个、最后一个、广播；
*   12、归档策略：针对已消费完成数据滚动归档及清理，提供丰富归档策略，包括：归档保留7天、归档保留30天、归档保留90天、归档永久保留、不归档直接清理；
*   13、重试策略：针对消费失败消息，支持设置丰富重试策略，包括：固定间隔、线性间隔、随机间隔；
*   14、失败重试：针对消费失败消息，支持自定义重试次数、以及重试间隔基数，结合重试策略支持灵活消费失败重试，支持重试次数耗尽或者消费成功；
*   15、超时控制: 支持自定义消息超时时间，消息消费超时将会主动中断；
*   16、多消息类型:
    *   并行消息：多个消费者并行消费数据，支持轮询或随机策略。适用于消息吞吐量较大的业务场景，如邮件发送、日志记录等。
    *   串行消息：同一时刻只有一个消费者消费数据，消息按照生产顺序FIFO串行消费。适用于有串行消费诉求的业务场景，如秒杀、抢单等场景；
    *   分片消息：支持根据业务参数进行Hash分片，相同分片的消息数据路由至同一个消费者FIFO串行消费，不同分片的消息数据路由至不同消费者并行执行。适用于有根据业务参数分片消费的业务场景，如短信发送，可实现同一个手机号（业务参数）的消息路由至单个消费者串行消息，同时全局消息分片并行消费。
    *   广播消息：消息发送后，广播发送给相关主题全部在线消费者。适用于广播消息场景，如广播通知、广播更新缓存等；
    *   延时消息：支持设置消息的延迟生效时间，到达设置的生效时间时该消息才会被消费。适用于延时消费场景，如订单超时取消、定时发送邮件等；
    *   失败重试消息：支持设置消息的失败重试次数，自定义重试间隔侧路，消息失败时会主动进行重试消费，直至重试次数耗尽或者消费成功。
*   17、消息可视化: 提供消息中心Web控制台，可在线管理消息主题、消息数据，查看消费数据及消费轨迹等；
*   18、消息轨迹: 消费生产及消费轨迹日志会进行记录，并支持在线查看，辅助排查业务问题；
*   19、优先级：支持设置消息主题优先级，优先级越高，消费吞吐资源配置及保障越高；
*   20、消息失败告警：支持以Topic粒度监控消息，存在失败消息时主动推送告警邮件；默认提供邮件方式失败告警，同时预留扩展接口，可方面的扩展短信、钉钉等告警方式；
*   21、容器化：提供官方Docker镜像，并实时更新推送DockerHub，进一步实现产品开箱即用；
*   22、访问令牌（AccessToken）：为提升系统安全性，消息中心和消费者客户端进行安全性校验，校验AccessToken合法性；