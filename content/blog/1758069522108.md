---
layout: post
title: 'Flutteræ•°æ®å¯è§†åŒ–ï¼šfl_chartå›¾è¡¨åº“çš„é«˜çº§åº”ç”¨'
date: "2025-09-17T00:38:42Z"
---
Flutteræ•°æ®å¯è§†åŒ–ï¼šfl\_chartå›¾è¡¨åº“çš„é«˜çº§åº”ç”¨
==============================

Flutteræ•°æ®å¯è§†åŒ–ï¼šfl\_chartå›¾è¡¨åº“çš„é«˜çº§åº”ç”¨
==============================

> æœ¬æ–‡åŸºäº[BeeCount(èœœèœ‚è®°è´¦)](https://github.com/TNT-Likely/BeeCount)é¡¹ç›®çš„å®é™…å¼€å‘ç»éªŒï¼Œæ·±å…¥æ¢è®¨å¦‚ä½•ä½¿ç”¨fl\_chartæ„å»ºç¾è§‚ã€äº¤äº’å¼çš„è´¢åŠ¡æ•°æ®å¯è§†åŒ–å›¾è¡¨ã€‚

é¡¹ç›®èƒŒæ™¯
----

[BeeCount(èœœèœ‚è®°è´¦)](https://github.com/TNT-Likely/BeeCount)æ˜¯ä¸€æ¬¾å¼€æºã€ç®€æ´ã€æ— å¹¿å‘Šçš„ä¸ªäººè®°è´¦åº”ç”¨ã€‚æ‰€æœ‰è´¢åŠ¡æ•°æ®å®Œå…¨ç”±ç”¨æˆ·æŒæ§ï¼Œæ”¯æŒæœ¬åœ°å­˜å‚¨å’Œå¯é€‰çš„äº‘ç«¯åŒæ­¥ï¼Œç¡®ä¿æ•°æ®ç»å¯¹å®‰å…¨ã€‚

å¼•è¨€
--

æ•°æ®å¯è§†åŒ–æ˜¯ç°ä»£åº”ç”¨çš„é‡è¦ç‰¹æ€§ï¼Œç‰¹åˆ«æ˜¯å¯¹äºè´¢åŠ¡ç®¡ç†ç±»åº”ç”¨ã€‚ç”¨æˆ·éœ€è¦ç›´è§‚åœ°äº†è§£è‡ªå·±çš„æ”¶æ”¯çŠ¶å†µã€æ¶ˆè´¹è¶‹åŠ¿å’Œèµ„äº§åˆ†å¸ƒã€‚ä¼˜ç§€çš„æ•°æ®å¯è§†åŒ–ä¸ä»…èƒ½å¸®åŠ©ç”¨æˆ·æ›´å¥½åœ°ç†è§£æ•°æ®ï¼Œè¿˜èƒ½æå‡åº”ç”¨çš„ä¸“ä¸šæ€§å’Œç”¨æˆ·ç²˜æ€§ã€‚

fl\_chartæ˜¯Flutterç”Ÿæ€ä¸­æœ€å—æ¬¢è¿çš„å›¾è¡¨åº“ä¹‹ä¸€ï¼Œå®ƒæä¾›äº†ä¸°å¯Œçš„å›¾è¡¨ç±»å‹ã€æµç•…çš„åŠ¨ç”»æ•ˆæœå’Œçµæ´»çš„è‡ªå®šä¹‰é€‰é¡¹ã€‚åœ¨BeeCounté¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨fl\_chartæ„å»ºäº†å®Œæ•´çš„è´¢åŠ¡æ•°æ®åˆ†æåŠŸèƒ½ï¼ŒåŒ…æ‹¬è¶‹åŠ¿å›¾ã€é¥¼å›¾ã€æŸ±çŠ¶å›¾ç­‰å¤šç§å›¾è¡¨ç±»å‹ã€‚

fl\_chartæ ¸å¿ƒç‰¹æ€§
-------------

### ä¸°å¯Œçš„å›¾è¡¨ç±»å‹

*   **çº¿æ€§å›¾ï¼ˆLineChartï¼‰**: å±•ç¤ºæ•°æ®è¶‹åŠ¿å˜åŒ–
*   **æŸ±çŠ¶å›¾ï¼ˆBarChartï¼‰**: å¯¹æ¯”ä¸åŒç±»åˆ«æ•°æ®
*   **é¥¼å›¾ï¼ˆPieChartï¼‰**: æ˜¾ç¤ºæ•°æ®å æ¯”åˆ†å¸ƒ
*   **æ•£ç‚¹å›¾ï¼ˆScatterChartï¼‰**: å±•ç¤ºæ•°æ®ç›¸å…³æ€§
*   **é›·è¾¾å›¾ï¼ˆRadarChartï¼‰**: å¤šç»´åº¦æ•°æ®å¯¹æ¯”

### å¼ºå¤§çš„äº¤äº’èƒ½åŠ›

*   **è§¦æ‘¸äº¤äº’**: ç‚¹å‡»ã€é•¿æŒ‰ã€æ»‘åŠ¨ç­‰æ‰‹åŠ¿æ”¯æŒ
*   **åŠ¨æ€æ›´æ–°**: æ•°æ®å˜åŒ–æ—¶çš„æµç•…åŠ¨ç”»
*   **è‡ªå®šä¹‰æ ·å¼**: å®Œå…¨å¯å®šåˆ¶çš„è§†è§‰æ•ˆæœ
*   **å“åº”å¼è®¾è®¡**: é€‚é…ä¸åŒå±å¹•å°ºå¯¸

è´¢åŠ¡æ•°æ®åˆ†ææ¶æ„
--------

### æ•°æ®æ¨¡å‹è®¾è®¡

    // ç»Ÿè®¡æ•°æ®åŸºç±»
    abstract class ChartData {
      final DateTime date;
      final double value;
      final String label;
    
      const ChartData({
        required this.date,
        required this.value,
        required this.label,
      });
    }
    
    // æ—¥æ”¶æ”¯ç»Ÿè®¡
    class DailyStats extends ChartData {
      final double income;
      final double expense;
      final double net;
    
      const DailyStats({
        required DateTime date,
        required this.income,
        required this.expense,
        required this.net,
      }) : super(
              date: date,
              value: net,
              label: '',
            );
    
      factory DailyStats.fromTransaction(List<Transaction> transactions, DateTime date) {
        double income = 0;
        double expense = 0;
    
        for (final tx in transactions) {
          if (isSameDay(tx.happenedAt, date)) {
            switch (tx.type) {
              case 'income':
                income += tx.amount;
                break;
              case 'expense':
                expense += tx.amount;
                break;
            }
          }
        }
    
        return DailyStats(
          date: date,
          income: income,
          expense: expense,
          net: income - expense,
        );
      }
    }
    
    // åˆ†ç±»ç»Ÿè®¡
    class CategoryStats extends ChartData {
      final String categoryName;
      final int transactionCount;
      final Color color;
    
      const CategoryStats({
        required DateTime date,
        required double value,
        required this.categoryName,
        required this.transactionCount,
        required this.color,
      }) : super(
              date: date,
              value: value,
              label: categoryName,
            );
    }
    
    // æœˆåº¦è¶‹åŠ¿
    class MonthlyTrend extends ChartData {
      final int year;
      final int month;
      final double income;
      final double expense;
    
      const MonthlyTrend({
        required this.year,
        required this.month,
        required this.income,
        required this.expense,
      }) : super(
              date: DateTime(year, month),
              value: income - expense,
              label: '$yearå¹´$monthæœˆ',
            );
    }
    

### æ•°æ®å¤„ç†æœåŠ¡

    class AnalyticsService {
      final BeeRepository repository;
    
      AnalyticsService(this.repository);
    
      // è·å–æŒ‡å®šæ—¶é—´èŒƒå›´çš„æ—¥ç»Ÿè®¡æ•°æ®
      Future<List<DailyStats>> getDailyStats({
        required int ledgerId,
        required DateTimeRange range,
      }) async {
        final transactions = await repository.getTransactionsInRange(
          ledgerId: ledgerId,
          range: range,
        );
    
        final Map<DateTime, List<Transaction>> groupedByDate = {};
        for (final tx in transactions) {
          final date = DateTime(tx.happenedAt.year, tx.happenedAt.month, tx.happenedAt.day);
          groupedByDate.putIfAbsent(date, () => []).add(tx);
        }
    
        final List<DailyStats> result = [];
        DateTime current = DateTime(range.start.year, range.start.month, range.start.day);
        final end = DateTime(range.end.year, range.end.month, range.end.day);
    
        while (!current.isAfter(end)) {
          final dayTransactions = groupedByDate[current] ?? [];
          result.add(DailyStats.fromTransaction(dayTransactions, current));
          current = current.add(const Duration(days: 1));
        }
    
        return result;
      }
    
      // è·å–åˆ†ç±»ç»Ÿè®¡æ•°æ®
      Future<List<CategoryStats>> getCategoryStats({
        required int ledgerId,
        required DateTimeRange range,
        required String type, // 'income' or 'expense'
      }) async {
        final transactions = await repository.getCategoryStatsInRange(
          ledgerId: ledgerId,
          range: range,
          type: type,
        );
    
        final Map<String, CategoryStatsData> categoryMap = {};
        
        for (final tx in transactions) {
          final categoryName = tx.categoryName ?? 'æœªåˆ†ç±»';
          final existing = categoryMap[categoryName];
          
          if (existing == null) {
            categoryMap[categoryName] = CategoryStatsData(
              categoryName: categoryName,
              totalAmount: tx.amount,
              transactionCount: 1,
              color: _getCategoryColor(categoryName),
            );
          } else {
            existing.totalAmount += tx.amount;
            existing.transactionCount += 1;
          }
        }
    
        return categoryMap.values
            .map((data) => CategoryStats(
                  date: range.start,
                  value: data.totalAmount,
                  categoryName: data.categoryName,
                  transactionCount: data.transactionCount,
                  color: data.color,
                ))
            .toList()
          ..sort((a, b) => b.value.compareTo(a.value));
      }
    
      // è·å–æœˆåº¦è¶‹åŠ¿æ•°æ®
      Future<List<MonthlyTrend>> getMonthlyTrends({
        required int ledgerId,
        required int year,
      }) async {
        final List<MonthlyTrend> trends = [];
    
        for (int month = 1; month <= 12; month++) {
          final range = DateTimeRange(
            start: DateTime(year, month, 1),
            end: DateTime(year, month + 1, 1).subtract(const Duration(days: 1)),
          );
    
          final monthStats = await repository.getMonthStats(
            ledgerId: ledgerId,
            range: range,
          );
    
          trends.add(MonthlyTrend(
            year: year,
            month: month,
            income: monthStats.income,
            expense: monthStats.expense,
          ));
        }
    
        return trends;
      }
    
      Color _getCategoryColor(String categoryName) {
        // ä¸ºä¸åŒåˆ†ç±»åˆ†é…å›ºå®šé¢œè‰²
        final colors = [
          Colors.red.shade300,
          Colors.blue.shade300,
          Colors.green.shade300,
          Colors.orange.shade300,
          Colors.purple.shade300,
          Colors.teal.shade300,
          Colors.amber.shade300,
          Colors.indigo.shade300,
        ];
        
        final index = categoryName.hashCode % colors.length;
        return colors[index.abs()];
      }
    }
    

æ”¶æ”¯è¶‹åŠ¿å›¾å®ç°
-------

### åŸºç¡€çº¿æ€§å›¾ç»„ä»¶

    class IncomeExpenseTrendChart extends ConsumerWidget {
      final DateTimeRange dateRange;
      final int ledgerId;
    
      const IncomeExpenseTrendChart({
        Key? key,
        required this.dateRange,
        required this.ledgerId,
      }) : super(key: key);
    
      @override
      Widget build(BuildContext context, WidgetRef ref) {
        final dailyStatsAsync = ref.watch(dailyStatsProvider(DailyStatsParams(
          ledgerId: ledgerId,
          range: dateRange,
        )));
    
        return Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'æ”¶æ”¯è¶‹åŠ¿',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    PopupMenuButton<String>(
                      onSelected: (value) {
                        // å¤„ç†æ—¶é—´èŒƒå›´é€‰æ‹©
                      },
                      itemBuilder: (context) => [
                        const PopupMenuItem(value: '7d', child: Text('æœ€è¿‘7å¤©')),
                        const PopupMenuItem(value: '30d', child: Text('æœ€è¿‘30å¤©')),
                        const PopupMenuItem(value: '90d', child: Text('æœ€è¿‘90å¤©')),
                      ],
                      child: const Icon(Icons.more_vert),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                
                SizedBox(
                  height: 280,
                  child: dailyStatsAsync.when(
                    data: (stats) => _buildChart(context, stats),
                    loading: () => const Center(child: CircularProgressIndicator()),
                    error: (error, _) => Center(
                      child: Text('åŠ è½½å¤±è´¥: $error'),
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      }
    
      Widget _buildChart(BuildContext context, List<DailyStats> stats) {
        if (stats.isEmpty) {
          return const Center(
            child: Text('æš‚æ— æ•°æ®'),
          );
        }
    
        final theme = Theme.of(context);
        final colors = BeeTheme.colorsOf(context);
    
        return LineChart(
          LineChartData(
            gridData: FlGridData(
              show: true,
              drawHorizontalLine: true,
              drawVerticalLine: false,
              horizontalInterval: _calculateInterval(stats),
              getDrawingHorizontalLine: (value) => FlLine(
                color: theme.colorScheme.outline.withOpacity(0.2),
                strokeWidth: 1,
              ),
            ),
            
            titlesData: FlTitlesData(
              show: true,
              rightTitles: AxisTitles(sideTitles: SideTitles(showTitles: false)),
              topTitles: AxisTitles(sideTitles: SideTitles(showTitles: false)),
              
              bottomTitles: AxisTitles(
                sideTitles: SideTitles(
                  showTitles: true,
                  reservedSize: 30,
                  interval: _getBottomInterval(stats),
                  getTitlesWidget: (value, meta) => _buildBottomTitle(
                    context,
                    stats,
                    value.toInt(),
                  ),
                ),
              ),
              
              leftTitles: AxisTitles(
                sideTitles: SideTitles(
                  showTitles: true,
                  interval: _calculateInterval(stats),
                  reservedSize: 60,
                  getTitlesWidget: (value, meta) => _buildLeftTitle(
                    context,
                    value,
                  ),
                ),
              ),
            ),
            
            borderData: FlBorderData(show: false),
            
            minX: 0,
            maxX: stats.length.toDouble() - 1,
            minY: _getMinY(stats),
            maxY: _getMaxY(stats),
            
            lineBarsData: [
              // æ”¶å…¥çº¿
              LineChartBarData(
                spots: _createSpots(stats, (stat) => stat.income),
                isCurved: true,
                color: colors.income,
                barWidth: 3,
                isStrokeCapRound: true,
                dotData: FlDotData(
                  show: true,
                  getDotPainter: (spot, percent, barData, index) =>
                      FlDotCirclePainter(
                    radius: 4,
                    color: colors.income,
                    strokeWidth: 2,
                    strokeColor: Colors.white,
                  ),
                ),
                belowBarData: BarAreaData(
                  show: true,
                  color: colors.income.withOpacity(0.1),
                ),
              ),
              
              // æ”¯å‡ºçº¿
              LineChartBarData(
                spots: _createSpots(stats, (stat) => stat.expense),
                isCurved: true,
                color: colors.expense,
                barWidth: 3,
                isStrokeCapRound: true,
                dotData: FlDotData(
                  show: true,
                  getDotPainter: (spot, percent, barData, index) =>
                      FlDotCirclePainter(
                    radius: 4,
                    color: colors.expense,
                    strokeWidth: 2,
                    strokeColor: Colors.white,
                  ),
                ),
              ),
            ],
            
            lineTouchData: LineTouchData(
              enabled: true,
              touchTooltipData: LineTouchTooltipData(
                tooltipBgColor: theme.colorScheme.surface,
                tooltipBorder: BorderSide(
                  color: theme.colorScheme.outline,
                ),
                tooltipRoundedRadius: 8,
                getTooltipItems: (touchedSpots) => _buildTooltipItems(
                  context,
                  touchedSpots,
                  stats,
                  colors,
                ),
              ),
              touchCallback: (FlTouchEvent event, LineTouchResponse? touchResponse) {
                // å¤„ç†è§¦æ‘¸äº‹ä»¶
                if (event is FlTapUpEvent && touchResponse?.lineBarSpots != null) {
                  final spot = touchResponse!.lineBarSpots!.first;
                  final dayStats = stats[spot.spotIndex];
                  _showDayDetails(context, dayStats);
                }
              },
            ),
          ),
        );
      }
    
      List<FlSpot> _createSpots(List<DailyStats> stats, double Function(DailyStats) getValue) {
        return stats.asMap().entries.map((entry) {
          return FlSpot(entry.key.toDouble(), getValue(entry.value));
        }).toList();
      }
    
      double _calculateInterval(List<DailyStats> stats) {
        if (stats.isEmpty) return 100;
        
        final maxValue = stats
            .map((s) => math.max(s.income, s.expense))
            .reduce(math.max);
        
        if (maxValue <= 100) return 50;
        if (maxValue <= 1000) return 200;
        if (maxValue <= 10000) return 2000;
        return 5000;
      }
    
      double _getBottomInterval(List<DailyStats> stats) {
        if (stats.length <= 7) return 1;
        if (stats.length <= 14) return 2;
        if (stats.length <= 30) return 5;
        return 10;
      }
    
      Widget _buildBottomTitle(BuildContext context, List<DailyStats> stats, int index) {
        if (index < 0 || index >= stats.length) return const SizedBox.shrink();
        
        final date = stats[index].date;
        final text = DateFormat('MM/dd').format(date);
        
        return SideTitleWidget(
          axisSide: meta.axisSide,
          child: Text(
            text,
            style: TextStyle(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
              fontSize: 12,
            ),
          ),
        );
      }
    
      Widget _buildLeftTitle(BuildContext context, double value) {
        return Text(
          _formatAmount(value),
          style: TextStyle(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
            fontSize: 12,
          ),
        );
      }
    
      String _formatAmount(double amount) {
        if (amount.abs() >= 10000) {
          return '${(amount / 10000).toStringAsFixed(1)}ä¸‡';
        }
        return amount.toStringAsFixed(0);
      }
    
      List<LineTooltipItem?> _buildTooltipItems(
        BuildContext context,
        List<LineBarSpot> touchedSpots,
        List<DailyStats> stats,
        BeeColors colors,
      ) {
        return touchedSpots.map((LineBarSpot touchedSpot) {
          const textStyle = TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.bold,
            fontSize: 14,
          );
          
          final dayStats = stats[touchedSpot.spotIndex];
          final date = DateFormat('MMæœˆddæ—¥').format(dayStats.date);
          
          if (touchedSpot.barIndex == 0) {
            // æ”¶å…¥çº¿
            return LineTooltipItem(
              '$date\næ”¶å…¥: ${dayStats.income.toStringAsFixed(2)}',
              textStyle.copyWith(color: colors.income),
            );
          } else {
            // æ”¯å‡ºçº¿
            return LineTooltipItem(
              '$date\næ”¯å‡º: ${dayStats.expense.toStringAsFixed(2)}',
              textStyle.copyWith(color: colors.expense),
            );
          }
        }).toList();
      }
    
      void _showDayDetails(BuildContext context, DailyStats dayStats) {
        showModalBottomSheet(
          context: context,
          builder: (context) => DayDetailsSheet(dayStats: dayStats),
        );
      }
    
      double _getMinY(List<DailyStats> stats) {
        if (stats.isEmpty) return 0;
        return math.min(0, stats.map((s) => math.min(s.income, s.expense)).reduce(math.min)) * 1.1;
      }
    
      double _getMaxY(List<DailyStats> stats) {
        if (stats.isEmpty) return 100;
        return stats.map((s) => math.max(s.income, s.expense)).reduce(math.max) * 1.1;
      }
    }
    

åˆ†ç±»æ”¯å‡ºé¥¼å›¾å®ç°
--------

### äº¤äº’å¼é¥¼å›¾ç»„ä»¶

    class CategoryExpensePieChart extends ConsumerStatefulWidget {
      final DateTimeRange dateRange;
      final int ledgerId;
    
      const CategoryExpensePieChart({
        Key? key,
        required this.dateRange,
        required this.ledgerId,
      }) : super(key: key);
    
      @override
      ConsumerState<CategoryExpensePieChart> createState() => _CategoryExpensePieChartState();
    }
    
    class _CategoryExpensePieChartState extends ConsumerState<CategoryExpensePieChart>
        with SingleTickerProviderStateMixin {
      int touchedIndex = -1;
      late AnimationController _animationController;
      late Animation<double> _animation;
    
      @override
      void initState() {
        super.initState();
        _animationController = AnimationController(
          duration: const Duration(milliseconds: 600),
          vsync: this,
        );
        _animation = CurvedAnimation(
          parent: _animationController,
          curve: Curves.easeInOut,
        );
        _animationController.forward();
      }
    
      @override
      void dispose() {
        _animationController.dispose();
        super.dispose();
      }
    
      @override
      Widget build(BuildContext context) {
        final categoryStatsAsync = ref.watch(categoryStatsProvider(CategoryStatsParams(
          ledgerId: widget.ledgerId,
          range: widget.dateRange,
          type: 'expense',
        )));
    
        return Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'æ”¯å‡ºåˆ†ç±»',
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 16),
                
                SizedBox(
                  height: 300,
                  child: categoryStatsAsync.when(
                    data: (stats) => _buildChart(context, stats),
                    loading: () => const Center(child: CircularProgressIndicator()),
                    error: (error, _) => Center(
                      child: Text('åŠ è½½å¤±è´¥: $error'),
                    ),
                  ),
                ),
                
                const SizedBox(height: 16),
                categoryStatsAsync.maybeWhen(
                  data: (stats) => _buildLegend(context, stats),
                  orElse: () => const SizedBox.shrink(),
                ),
              ],
            ),
          ),
        );
      }
    
      Widget _buildChart(BuildContext context, List<CategoryStats> stats) {
        if (stats.isEmpty) {
          return const Center(
            child: Text('æš‚æ— æ”¯å‡ºæ•°æ®'),
          );
        }
    
        // åªæ˜¾ç¤ºå‰8ä¸ªåˆ†ç±»ï¼Œå…¶ä½™å½’ä¸º"å…¶ä»–"
        final displayStats = _prepareDisplayStats(stats);
        final total = displayStats.fold(0.0, (sum, stat) => sum + stat.value);
    
        return AnimatedBuilder(
          animation: _animation,
          builder: (context, child) {
            return PieChart(
              PieChartData(
                pieTouchData: PieTouchData(
                  touchCallback: (FlTouchEvent event, pieTouchResponse) {
                    setState(() {
                      if (!event.isInterestedForInteractions ||
                          pieTouchResponse == null ||
                          pieTouchResponse.touchedSection == null) {
                        touchedIndex = -1;
                        return;
                      }
                      touchedIndex = pieTouchResponse.touchedSection!.touchedSectionIndex;
                    });
                  },
                ),
                
                borderData: FlBorderData(show: false),
                sectionsSpace: 2,
                centerSpaceRadius: 60,
                
                sections: displayStats.asMap().entries.map((entry) {
                  final index = entry.key;
                  final stat = entry.value;
                  final isTouched = index == touchedIndex;
                  final percentage = (stat.value / total * 100);
                  
                  return PieChartSectionData(
                    color: stat.color,
                    value: stat.value,
                    title: '${percentage.toStringAsFixed(1)}%',
                    radius: (isTouched ? 110.0 : 100.0) * _animation.value,
                    titleStyle: TextStyle(
                      fontSize: isTouched ? 16.0 : 14.0,
                      fontWeight: FontWeight.bold,
                      color: Colors.white,
                      shadows: [
                        Shadow(
                          color: Colors.black.withOpacity(0.5),
                          blurRadius: 2,
                        ),
                      ],
                    ),
                    badgeWidget: isTouched ? _buildBadge(stat) : null,
                    badgePositionPercentageOffset: 1.2,
                  );
                }).toList(),
              ),
            );
          },
        );
      }
    
      Widget _buildBadge(CategoryStats stat) {
        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: stat.color,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.white, width: 2),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.2),
                blurRadius: 4,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Text(
            'Â¥${stat.value.toStringAsFixed(0)}',
            style: const TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.bold,
              fontSize: 12,
            ),
          ),
        );
      }
    
      Widget _buildLegend(BuildContext context, List<CategoryStats> stats) {
        final displayStats = _prepareDisplayStats(stats);
        
        return Column(
          children: displayStats.asMap().entries.map((entry) {
            final index = entry.key;
            final stat = entry.value;
            final isHighlighted = index == touchedIndex;
            
            return AnimatedContainer(
              duration: const Duration(milliseconds: 200),
              margin: const EdgeInsets.symmetric(vertical: 2),
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              decoration: BoxDecoration(
                color: isHighlighted
                    ? stat.color.withOpacity(0.1)
                    : Colors.transparent,
                borderRadius: BorderRadius.circular(8),
                border: isHighlighted
                    ? Border.all(color: stat.color.withOpacity(0.3))
                    : null,
              ),
              child: Row(
                children: [
                  Container(
                    width: 16,
                    height: 16,
                    decoration: BoxDecoration(
                      color: stat.color,
                      shape: BoxShape.circle,
                    ),
                  ),
                  const SizedBox(width: 12),
                  
                  Expanded(
                    child: Text(
                      stat.categoryName,
                      style: TextStyle(
                        fontWeight: isHighlighted
                            ? FontWeight.w600
                            : FontWeight.normal,
                      ),
                    ),
                  ),
                  
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      Text(
                        'Â¥${stat.value.toStringAsFixed(2)}',
                        style: TextStyle(
                          fontWeight: FontWeight.w600,
                          color: isHighlighted
                              ? stat.color
                              : Theme.of(context).colorScheme.onSurface,
                        ),
                      ),
                      Text(
                        '${stat.transactionCount}ç¬”',
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            );
          }).toList(),
        );
      }
    
      List<CategoryStats> _prepareDisplayStats(List<CategoryStats> stats) {
        if (stats.length <= 8) return stats;
    
        final topStats = stats.take(7).toList();
        final othersValue = stats.skip(7).fold(0.0, (sum, stat) => sum + stat.value);
        final othersCount = stats.skip(7).fold(0, (sum, stat) => sum + stat.transactionCount);
    
        if (othersValue > 0) {
          topStats.add(CategoryStats(
            date: DateTime.now(),
            value: othersValue,
            categoryName: 'å…¶ä»–',
            transactionCount: othersCount,
            color: Colors.grey.shade400,
          ));
        }
    
        return topStats;
      }
    }
    

æœˆåº¦å¯¹æ¯”æŸ±çŠ¶å›¾
-------

### å“åº”å¼æŸ±çŠ¶å›¾ç»„ä»¶

    class MonthlyComparisonBarChart extends ConsumerWidget {
      final int year;
      final int ledgerId;
    
      const MonthlyComparisonBarChart({
        Key? key,
        required this.year,
        required this.ledgerId,
      }) : super(key: key);
    
      @override
      Widget build(BuildContext context, WidgetRef ref) {
        final monthlyTrendsAsync = ref.watch(monthlyTrendsProvider(MonthlyTrendsParams(
          ledgerId: ledgerId,
          year: year,
        )));
    
        return Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      '$yearå¹´æœˆåº¦å¯¹æ¯”',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    Row(
                      children: [
                        _buildLegendItem(context, 'æ”¶å…¥', BeeTheme.colorsOf(context).income),
                        const SizedBox(width: 16),
                        _buildLegendItem(context, 'æ”¯å‡º', BeeTheme.colorsOf(context).expense),
                      ],
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                
                SizedBox(
                  height: 300,
                  child: monthlyTrendsAsync.when(
                    data: (trends) => _buildChart(context, trends),
                    loading: () => const Center(child: CircularProgressIndicator()),
                    error: (error, _) => Center(
                      child: Text('åŠ è½½å¤±è´¥: $error'),
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      }
    
      Widget _buildLegendItem(BuildContext context, String label, Color color) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 12,
              height: 12,
              decoration: BoxDecoration(
                color: color,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            const SizedBox(width: 6),
            Text(
              label,
              style: Theme.of(context).textTheme.bodySmall,
            ),
          ],
        );
      }
    
      Widget _buildChart(BuildContext context, List<MonthlyTrend> trends) {
        if (trends.isEmpty) {
          return const Center(
            child: Text('æš‚æ— æ•°æ®'),
          );
        }
    
        final theme = Theme.of(context);
        final colors = BeeTheme.colorsOf(context);
        final maxValue = trends
            .map((t) => math.max(t.income, t.expense))
            .reduce(math.max);
    
        return BarChart(
          BarChartData(
            alignment: BarChartAlignment.spaceAround,
            maxY: maxValue * 1.2,
            
            gridData: FlGridData(
              show: true,
              drawHorizontalLine: true,
              drawVerticalLine: false,
              horizontalInterval: _calculateInterval(maxValue),
              getDrawingHorizontalLine: (value) => FlLine(
                color: theme.colorScheme.outline.withOpacity(0.2),
                strokeWidth: 1,
              ),
            ),
            
            titlesData: FlTitlesData(
              show: true,
              rightTitles: AxisTitles(sideTitles: SideTitles(showTitles: false)),
              topTitles: AxisTitles(sideTitles: SideTitles(showTitles: false)),
              
              bottomTitles: AxisTitles(
                sideTitles: SideTitles(
                  showTitles: true,
                  getTitlesWidget: (value, meta) {
                    final month = value.toInt() + 1;
                    return SideTitleWidget(
                      axisSide: meta.axisSide,
                      child: Text(
                        '${month}æœˆ',
                        style: TextStyle(
                          color: theme.colorScheme.onSurfaceVariant,
                          fontSize: 12,
                        ),
                      ),
                    );
                  },
                ),
              ),
              
              leftTitles: AxisTitles(
                sideTitles: SideTitles(
                  showTitles: true,
                  reservedSize: 60,
                  interval: _calculateInterval(maxValue),
                  getTitlesWidget: (value, meta) {
                    return Text(
                      _formatAmount(value),
                      style: TextStyle(
                        color: theme.colorScheme.onSurfaceVariant,
                        fontSize: 12,
                      ),
                    );
                  },
                ),
              ),
            ),
            
            borderData: FlBorderData(show: false),
            
            barGroups: trends.asMap().entries.map((entry) {
              final index = entry.key;
              final trend = entry.value;
              
              return BarChartGroupData(
                x: index,
                barRods: [
                  BarChartRodData(
                    toY: trend.income,
                    color: colors.income,
                    width: 12,
                    borderRadius: const BorderRadius.vertical(
                      top: Radius.circular(4),
                    ),
                    backDrawRodData: BackgroundBarChartRodData(
                      show: true,
                      toY: maxValue * 1.2,
                      color: theme.colorScheme.surfaceVariant.withOpacity(0.3),
                    ),
                  ),
                  BarChartRodData(
                    toY: trend.expense,
                    color: colors.expense,
                    width: 12,
                    borderRadius: const BorderRadius.vertical(
                      top: Radius.circular(4),
                    ),
                  ),
                ],
                barsSpace: 4,
              );
            }).toList(),
            
            barTouchData: BarTouchData(
              enabled: true,
              touchTooltipData: BarTouchTooltipData(
                tooltipBgColor: theme.colorScheme.surface,
                tooltipBorder: BorderSide(
                  color: theme.colorScheme.outline,
                ),
                tooltipRoundedRadius: 8,
                getTooltipItem: (group, groupIndex, rod, rodIndex) {
                  final trend = trends[groupIndex];
                  final isIncome = rodIndex == 0;
                  final amount = isIncome ? trend.income : trend.expense;
                  final label = isIncome ? 'æ”¶å…¥' : 'æ”¯å‡º';
                  
                  return BarTooltipItem(
                    '${trend.month}æœˆ\n$label: Â¥${amount.toStringAsFixed(2)}',
                    TextStyle(
                      color: isIncome ? colors.income : colors.expense,
                      fontWeight: FontWeight.bold,
                    ),
                  );
                },
              ),
            ),
          ),
        );
      }
    
      double _calculateInterval(double maxValue) {
        if (maxValue <= 1000) return 200;
        if (maxValue <= 10000) return 2000;
        if (maxValue <= 100000) return 20000;
        return 50000;
      }
    
      String _formatAmount(double amount) {
        if (amount >= 10000) {
          return '${(amount / 10000).toStringAsFixed(1)}ä¸‡';
        }
        return '${amount.toStringAsFixed(0)}';
      }
    }
    

å›¾è¡¨æ€§èƒ½ä¼˜åŒ–
------

### æ•°æ®ç¼“å­˜ç­–ç•¥

    class ChartDataCache {
      static final Map<String, CachedData> _cache = {};
      static const Duration cacheExpiration = Duration(minutes: 5);
    
      static Future<T> getOrCompute<T>(
        String key,
        Future<T> Function() computation,
      ) async {
        final cached = _cache[key];
        
        if (cached != null &&
            DateTime.now().difference(cached.timestamp) < cacheExpiration) {
          return cached.data as T;
        }
    
        final result = await computation();
        _cache[key] = CachedData(
          data: result,
          timestamp: DateTime.now(),
        );
    
        return result;
      }
    
      static void clearCache() {
        _cache.clear();
      }
    
      static void clearExpired() {
        final now = DateTime.now();
        _cache.removeWhere((key, value) =>
            now.difference(value.timestamp) >= cacheExpiration);
      }
    }
    
    class CachedData {
      final dynamic data;
      final DateTime timestamp;
    
      CachedData({
        required this.data,
        required this.timestamp,
      });
    }
    

### å“åº”å¼æ•°æ®æ›´æ–°

    // ä½¿ç”¨ Riverpod çš„è‡ªåŠ¨ç¼“å­˜å’Œå¤±æ•ˆæœºåˆ¶
    final dailyStatsProvider = FutureProvider.family.autoDispose<List<DailyStats>, DailyStatsParams>(
      (ref, params) async {
        final analytics = ref.watch(analyticsServiceProvider);
        
        // ç›‘å¬ç›¸å…³æ•°æ®å˜åŒ–ï¼Œè‡ªåŠ¨å¤±æ•ˆç¼“å­˜
        ref.listen(currentLedgerIdProvider, (prev, next) {
          if (prev != next) {
            ref.invalidateSelf();
          }
        });
    
        return analytics.getDailyStats(
          ledgerId: params.ledgerId,
          range: params.range,
        );
      },
    );
    
    class DailyStatsParams {
      final int ledgerId;
      final DateTimeRange range;
    
      const DailyStatsParams({
        required this.ledgerId,
        required this.range,
      });
    
      @override
      bool operator ==(Object other) =>
          identical(this, other) ||
          other is DailyStatsParams &&
              runtimeType == other.runtimeType &&
              ledgerId == other.ledgerId &&
              range == other.range;
    
      @override
      int get hashCode => ledgerId.hashCode ^ range.hashCode;
    }
    

å›¾è¡¨äº¤äº’å¢å¼º
------

### æ‰‹åŠ¿æ“ä½œæ”¯æŒ

    class InteractiveChart extends StatefulWidget {
      final Widget chart;
      final VoidCallback? onRefresh;
    
      const InteractiveChart({
        Key? key,
        required this.chart,
        this.onRefresh,
      }) : super(key: key);
    
      @override
      State<InteractiveChart> createState() => _InteractiveChartState();
    }
    
    class _InteractiveChartState extends State<InteractiveChart> {
      bool _isRefreshing = false;
    
      @override
      Widget build(BuildContext context) {
        return RefreshIndicator(
          onRefresh: () async {
            if (widget.onRefresh != null) {
              setState(() {
                _isRefreshing = true;
              });
              
              widget.onRefresh!();
              
              // æ¨¡æ‹Ÿåˆ·æ–°å»¶è¿Ÿ
              await Future.delayed(const Duration(milliseconds: 500));
              
              setState(() {
                _isRefreshing = false;
              });
            }
          },
          child: SingleChildScrollView(
            physics: const AlwaysScrollableScrollPhysics(),
            child: AnimatedOpacity(
              opacity: _isRefreshing ? 0.5 : 1.0,
              duration: const Duration(milliseconds: 200),
              child: widget.chart,
            ),
          ),
        );
      }
    }
    

### ç©ºçŠ¶æ€å¤„ç†

    class EmptyChartWidget extends StatelessWidget {
      final String message;
      final IconData icon;
      final VoidCallback? onAction;
      final String? actionLabel;
    
      const EmptyChartWidget({
        Key? key,
        required this.message,
        this.icon = Icons.bar_chart,
        this.onAction,
        this.actionLabel,
      }) : super(key: key);
    
      @override
      Widget build(BuildContext context) {
        return Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                icon,
                size: 64,
                color: Theme.of(context).colorScheme.onSurfaceVariant.withOpacity(0.5),
              ),
              const SizedBox(height: 16),
              
              Text(
                message,
                style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
              
              if (onAction != null && actionLabel != null) ...[
                const SizedBox(height: 24),
                FilledButton(
                  onPressed: onAction,
                  child: Text(actionLabel!),
                ),
              ],
            ],
          ),
        );
      }
    }
    

æœ€ä½³å®è·µæ€»ç»“
------

### 1\. æ•°æ®å¤„ç†åŸåˆ™

*   **æ•°æ®åˆ†å±‚**ï¼šåŸå§‹æ•°æ® -> å¤„ç†æ•°æ® -> æ˜¾ç¤ºæ•°æ®
*   **ç¼“å­˜ç­–ç•¥**ï¼šåˆç†ä½¿ç”¨ç¼“å­˜é¿å…é‡å¤è®¡ç®—
*   **å¼‚æ­¥åŠ è½½**ï¼šå¤§æ•°æ®é›†ä½¿ç”¨å¼‚æ­¥å¤„ç†

### 2\. æ€§èƒ½ä¼˜åŒ–

*   **å»¶è¿Ÿæ¸²æŸ“**ï¼šå¤æ‚å›¾è¡¨ä½¿ç”¨å»¶è¿Ÿåˆå§‹åŒ–
*   **å†…å­˜ç®¡ç†**ï¼šåŠæ—¶æ¸…ç†ä¸éœ€è¦çš„æ•°æ®
*   **åŠ¨ç”»ä¼˜åŒ–**ï¼šåˆç†ä½¿ç”¨åŠ¨ç”»ï¼Œé¿å…è¿‡åº¦æ¸²æŸ“

### 3\. ç”¨æˆ·ä½“éªŒ

*   **åŠ è½½çŠ¶æ€**ï¼šæä¾›æ˜ç¡®çš„åŠ è½½åé¦ˆ
*   **é”™è¯¯å¤„ç†**ï¼šä¼˜é›…å¤„ç†æ•°æ®å¼‚å¸¸
*   **äº¤äº’åé¦ˆ**ï¼šæä¾›è§¦è§‰å’Œè§†è§‰åé¦ˆ

### 4\. è§†è§‰è®¾è®¡

*   **é¢œè‰²ä¸€è‡´æ€§**ï¼šéµå¾ªåº”ç”¨ä¸»é¢˜è‰²å½©
*   **å¯è¯»æ€§**ï¼šç¡®ä¿æ–‡å­—å’Œå›¾å½¢æ¸…æ™°å¯è§
*   **å“åº”å¼**ï¼šé€‚é…ä¸åŒå±å¹•å°ºå¯¸

å®é™…åº”ç”¨æ•ˆæœ
------

åœ¨BeeCounté¡¹ç›®ä¸­ï¼Œfl\_chartæ•°æ®å¯è§†åŒ–ç³»ç»Ÿå¸¦æ¥äº†æ˜¾è‘—ä»·å€¼ï¼š

1.  **ç”¨æˆ·æ´å¯Ÿæå‡**ï¼šç›´è§‚çš„å›¾è¡¨å¸®åŠ©ç”¨æˆ·ç†è§£æ¶ˆè´¹æ¨¡å¼
2.  **ä½¿ç”¨æ—¶é•¿å¢åŠ **ï¼šä¸°å¯Œçš„æ•°æ®åˆ†ææå‡ç”¨æˆ·ç²˜æ€§
3.  **ä¸“ä¸šå°è±¡**ï¼šç¾è§‚çš„å›¾è¡¨æå‡åº”ç”¨ä¸“ä¸šå½¢è±¡
4.  **å†³ç­–æ”¯æŒ**ï¼šæ•°æ®å¯è§†åŒ–è¾…åŠ©ç”¨æˆ·è´¢åŠ¡å†³ç­–

ç»“è¯­
--

æ•°æ®å¯è§†åŒ–æ˜¯ç°ä»£åº”ç”¨ä¸å¯æˆ–ç¼ºçš„åŠŸèƒ½ï¼Œfl\_chartä¸ºFlutterå¼€å‘è€…æä¾›äº†å¼ºå¤§è€Œçµæ´»çš„å›¾è¡¨è§£å†³æ–¹æ¡ˆã€‚é€šè¿‡åˆç†çš„æ¶æ„è®¾è®¡ã€æ€§èƒ½ä¼˜åŒ–å’Œç”¨æˆ·ä½“éªŒè€ƒè™‘ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºå‡ºæ—¢ç¾è§‚åˆå®ç”¨çš„æ•°æ®å¯è§†åŒ–ç³»ç»Ÿã€‚

BeeCountçš„å®è·µè¯æ˜ï¼Œä¼˜ç§€çš„æ•°æ®å¯è§†åŒ–ä¸ä»…èƒ½æå‡ç”¨æˆ·ä½“éªŒï¼Œæ›´èƒ½ä¸ºç”¨æˆ·åˆ›é€ å®é™…ä»·å€¼ï¼Œå¸®åŠ©ä»–ä»¬æ›´å¥½åœ°ç†è§£å’Œç®¡ç†è‡ªå·±çš„è´¢åŠ¡çŠ¶å†µã€‚

å…³äºBeeCounté¡¹ç›®
------------

### é¡¹ç›®ç‰¹è‰²

*   ğŸ¯ **ç°ä»£æ¶æ„**: åŸºäºRiverpod + Drift + Supabaseçš„ç°ä»£æŠ€æœ¯æ ˆ
*   ğŸ“± **è·¨å¹³å°æ”¯æŒ**: iOSã€AndroidåŒå¹³å°åŸç”Ÿä½“éªŒ
*   ğŸ”„ **äº‘ç«¯åŒæ­¥**: æ”¯æŒå¤šè®¾å¤‡æ•°æ®å®æ—¶åŒæ­¥
*   ğŸ¨ **ä¸ªæ€§åŒ–å®šåˆ¶**: Material Design 3ä¸»é¢˜ç³»ç»Ÿ
*   ğŸ“Š **æ•°æ®åˆ†æ**: å®Œæ•´çš„è´¢åŠ¡æ•°æ®å¯è§†åŒ–
*   ğŸŒ **å›½é™…åŒ–**: å¤šè¯­è¨€æœ¬åœ°åŒ–æ”¯æŒ

### æŠ€æœ¯æ ˆä¸€è§ˆ

*   **æ¡†æ¶**: Flutter 3.6.1+ / Dart 3.6.1+
*   **çŠ¶æ€ç®¡ç†**: Flutter Riverpod 2.5.1
*   **æ•°æ®åº“**: Drift (SQLite) 2.20.2
*   **äº‘æœåŠ¡**: Supabase 2.5.6
*   **å›¾è¡¨**: FL Chart 0.68.0
*   **CI/CD**: GitHub Actions

### å¼€æºä¿¡æ¯

BeeCountæ˜¯ä¸€ä¸ªå®Œå…¨å¼€æºçš„é¡¹ç›®ï¼Œæ¬¢è¿å¼€å‘è€…å‚ä¸è´¡çŒ®ï¼š

*   **é¡¹ç›®ä¸»é¡µ**: [https://github.com/TNT-Likely/BeeCount](https://github.com/TNT-Likely/BeeCount)
*   **å¼€å‘è€…ä¸»é¡µ**: [https://github.com/TNT-Likely](https://github.com/TNT-Likely)
*   **å‘å¸ƒä¸‹è½½**: [GitHub Releases](https://github.com/TNT-Likely/BeeCount/releases)

å‚è€ƒèµ„æº
----

### å®˜æ–¹æ–‡æ¡£

*   [fl\_chartå®˜æ–¹æ–‡æ¡£](https://pub.dev/packages/fl_chart) - fl\_chartå®Œæ•´ä½¿ç”¨æŒ‡å—
*   [Flutterå›¾è¡¨é€‰æ‹©æŒ‡å—](https://flutter.dev/development/ui/widgets/material#data-visualization) - Flutterå®˜æ–¹å›¾è¡¨ç»„ä»¶å¯¹æ¯”

### å­¦ä¹ èµ„æº

*   [fl\_chartç¤ºä¾‹é›†åˆ](https://github.com/imaNNeoFighT/fl_chart/tree/master/example) - å®˜æ–¹ç¤ºä¾‹ä»£ç 
*   [æ•°æ®å¯è§†åŒ–æœ€ä½³å®è·µ](https://material.io/design/communication/data-visualization.html) - Material Designæ•°æ®å¯è§†åŒ–æŒ‡å—

* * *

_æœ¬æ–‡æ˜¯BeeCountæŠ€æœ¯æ–‡ç« ç³»åˆ—çš„ç¬¬5ç¯‡ï¼Œåç»­å°†æ·±å…¥æ¢è®¨CSVå¯¼å…¥å¯¼å‡ºã€å›½é™…åŒ–ç­‰è¯é¢˜ã€‚å¦‚æœä½ è§‰å¾—è¿™ç¯‡æ–‡ç« æœ‰å¸®åŠ©ï¼Œæ¬¢è¿å…³æ³¨é¡¹ç›®å¹¶ç»™ä¸ªStarï¼_