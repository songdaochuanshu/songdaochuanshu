---
layout: post
title: '[快速阅读十一] 伊拉克团队的TAGC（低光增强效果）算法实现。'
date: "2025-08-07T00:46:56Z"
---
\[快速阅读十一\] 伊拉克团队的TAGC（低光增强效果）算法实现。
==================================

这篇来自伊拉克团队的论文提出了一个简单却有效的低光图像增强算法TAGC，无需训练数据就能实现媲美深度学习的效果，效果惊艳不错。

　　原论文信息如下：

　　 论文标题: Tuning adaptive gamma correction (TAGC) for enhancing images in low light

　　发表日期: 2025年07月

　　作者: Ghufran Alhamzawi, Alfoudi Ali Saeed, Suha Mohammed Hadi等

　　发表单位: University of Al-Qadisiyah, University of Information Technology and Communications等

　　原文链接:

　　　　[http://arxiv.org/pdf/2507.19574v1](http://arxiv.org/pdf/2507.19574v1)\=

　　AGC的核心思想非常巧妙：它通过分析图像的亮度分布，自动计算出最适合的伽马校正参数。整个过程完全自动化，不需要任何人工干预。具体来说，它分为四个步骤：

　　　　**1. 计算亮度因子(L)**根据人眼对不同颜色的敏感度，给RGB三个通道赋予不同权重。

　　　　　　　　　　　　![image](https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160448778-2126148724.png)

　　　　**2. 计算平均颜色因子(μ)**取RGB三个通道的平均值，作为整体颜色基准。

　　　　　　　　　　　　　　![image](https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160510127-403364297.png)

　　　　**3. 计算自适应伽马系数(γ)**结合亮度因子和平均颜色因子，动态调整伽马值。

　　　　　　　　　　　![image](https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160527887-234765531.png)

　　　　**4. 应用自适应伽马校正**使用计算出的伽马值对图像进行增强处理。

 　　　　　　　　　　![image](https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160546843-1026003141.png)

　　以上都是针对单个像素处理的。

　　这个算法弄成代码也不是很复杂的，分享如下：

void IM\_TAGC\_Enhancement(unsigned char \*Src, unsigned char \*Dest, int Width, int Height, int Stride)
{
    int Channel = Stride / Width;
    float Inv255 = 1.0f / 255;
    if (Channel == 3)
    {
        for (int Y = 0; Y < Height; Y++)
        {
            unsigned char \*LinePS = Src + Y \* Stride;
            unsigned char \*LinePD = Dest + Y \* Stride;
            for (int X = 0; X < Width; X++)
            {
                float Blue = LinePS\[0\] \* Inv255;
                float Green = LinePS\[1\] \* Inv255;
                float Red = LinePS\[2\] \* Inv255;
                float L = 0.2126f \* Red + 0.7152 \* Green + 0.0722 \* Blue;
                float A = (Blue + Green + Red) / 3;
                float Gamma = 5.0f + (0.5f - L) \* (1 - A) - 2 \* L;
                LinePD\[0\] = ClampToByte((int)(powf(Blue, 2 / Gamma) \* 255 + 0.4999999f));
                LinePD\[1\] = ClampToByte((int)(powf(Green, 2 / Gamma) \* 255 + 0.4999999f));
                LinePD\[2\] = ClampToByte((int)(powf(Red, 2 / Gamma) \* 255 + 0.4999999f));
                LinePS += 3;
                LinePD += 3;
            }
        }
    }
}

　　效果吗，确实能做到作者论文里的效果的，说明作者是没有作假的。

　![微信图片_20250806160826](https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160854531-1033299728.jpg)       ![微信图片_20250806160832](https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160902056-49755058.jpg)

  ![微信图片_20250806160835](https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160911300-816814483.png)        ![微信图片_20250806160834](https://img2024.cnblogs.com/blog/349293/202508/349293-20250806161033058-1103527801.png)

　　不过对有些图像的处理效果就还是有点灰蒙蒙的，整体对比度不高。 

　　至于算法的速度并不像有些文章里说的可以满足4K视频实时增强的，虽然上面提供的代码只是示意代码，可以进行大量的优化，但是最后的pow函数是个非常耗时的过程，而且似乎没有设么好的办法去避免这个计算，不算前面文章那个pow(x,1.5)可以转换为x \* sqrt(x)。

　　不过这个点和我一样还在研究传统算法的，又是伊拉克的团队，这份精神还是值得表扬的。

 　　Demo下载地址：[https://files.cnblogs.com/files/Imageshop/TAGC.rar?t=1754469391&download=true](https://files.cnblogs.com/files/Imageshop/TAGC.rar?t=1754469391&download=true)