---
layout: post
title: '源码调试-带你了解下车牌识别的深度学习模型-LPRNet'
date: "2025-09-14T00:41:51Z"
---
源码调试-带你了解下车牌识别的深度学习模型-LPRNet
============================

![源码调试-带你了解下车牌识别的深度学习模型-LPRNet](https://img2024.cnblogs.com/blog/3687401/202509/3687401-20250912170528871-443921043.png) 本期视频介绍了基于PyTorch的车牌识别模型LPRNet的调试运行过程。主要内容包括：1）项目结构分析和环境配置；2）单张图片识别代码实现，涵盖图像预处理、模型预测和结果可视化；3）注意事项说明。该模型支持蓝牌和新能源车牌识别，具有轻量级特性，适合实际应用开发。视频详细演示了从源码获取到运行测试的全流程，并提供了处理单张车牌图像的关键代码解析。

​

视频演示
----

[源码调试-带你了解下车牌识别的深度学习模型-LPRNet](https://www.bilibili.com/video/BV1N3HkzaEHe)

大家好，这里是Coding茶水间。本期我们来调试运行一个经典的深度学习网络——LPRNet，它专门用于车牌识别任务。

LPRNet是由Intel团队开发的端到端深度学习模型，专为车牌识别优化，具有轻量级的特性。

下面我们一步步来探索它的源码、环境搭建和实际运行。

1\. LPRNet简介
------------

LPRNet支持识别蓝牌和绿牌（新能源车牌）。它基于PyTorch框架，结合OpenCV进行图像处理，适用于Python 3.0以上版本。

在GitHub上，作者提供了模型的识别效果展示，包括模糊、污损或倾斜的车牌图片。

2\. 获取源码
--------

打开LPRNet的GitHub页面（网址可在视频简介中获取）。点击“Code”按钮下载ZIP压缩包，或使用Git命令克隆仓库：

    git clone https://github.com/sirius-ai/LPRNet_Pytorch.git

下载后解压，使用VS Code或其他IDE打开项目。

3\. 源码结构分析
----------

项目结构如下：

*   **data**：数据集文件夹，包含测试用的车牌图片。这些图片包括模糊、污损或倾斜的样本。
*   **load\_data.py**：用于加载数据集的脚本。
*   **model**：核心文件夹，包含LPRNet网络结构代码。
*   **weights**：预训练权重文件（Final\_LPRNet\_model.pth）。
*   **train\_LPRNet.py** 和 **test\_LPRNet.py**：训练和测试脚本。

4\. 环境要求
--------

*   Python 3.0+
*   PyTorch
*   OpenCV
*   NumPy 等基础库

确保安装这些依赖后，即可运行。

5\. 测试模型性能
----------

使用作者提供的test\_LPRNet.py对测试图片进行批量验证，检查模型性能。

6\. 单张图片识别
----------

在实际应用中，我们常需要对单张车牌图像进行识别。下面是针对单张图片的自定义代码（基于LPRNet）。代码使用OpenCV读取图片，进行预处理，并输出识别结果。

### 代码实现

    # -*- coding: utf-8 -*-
    # /usr/bin/env/python3
    
    '''
    单图片验证LPRNet模型
    '''
    
    from data.load_data import CHARS, CHARS_DICT
    from PIL import Image, ImageDraw, ImageFont
    from model.LPRNet import build_lprnet
    from torch.autograd import Variable
    import torch.nn.functional as F
    import torch.nn as nn
    import numpy as np
    import argparse
    import torch
    import time
    import cv2
    import os
    
    def cv2ImgAddText(img, text, pos, textColor=(255, 0, 0), textSize=12):
        if (isinstance(img, np.ndarray)):
            img = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        draw = ImageDraw.Draw(img)
        fontText = ImageFont.truetype("data/NotoSansCJK-Regular.ttc", textSize, encoding="utf-8")
        draw.text(pos, text, textColor, font=fontText)
        return cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)
    
    def predict_single_image(image_path):
        # 硬编码参数
        img_size = [94, 24]          # 图像尺寸
        lpr_max_len = 8              # 车牌最大长度
        dropout_rate = 0             # dropout率
        use_cuda = False             # 是否使用CUDA
        pretrained_model = './weights/Final_LPRNet_model.pth'  # 预训练模型路径
        
        # 检查模型文件是否存在
        if not os.path.exists(pretrained_model):
            print(f"[Error] 预训练模型未找到: {pretrained_model}")
            return
        
        # 构建模型
        lprnet = build_lprnet(lpr_max_len=lpr_max_len, phase=False, 
                             class_num=len(CHARS), dropout_rate=dropout_rate)
        device = torch.device("cuda:0" if use_cuda else "cpu")
        lprnet.to(device)
        
        # 加载预训练模型
        lprnet.load_state_dict(torch.load(pretrained_model, map_location=device))
        lprnet.eval()
        
        # 读取并预处理图像
        if not os.path.exists(image_path):
            print(f"[Error] 图像未找到: {image_path}")
            return
        
        # 使用OpenCV读取图像
        img_orig = cv2.imread(image_path)
        if img_orig is None:
            print(f"[Error] 无法读取图像: {image_path}")
            return
        
        # 调整图像大小并归一化
        img = cv2.resize(img_orig, (img_size[0], img_size[1]))
        img = img.astype('float32')
        img -= 127.5
        img *= 0.0078125
        img = np.transpose(img, (2, 0, 1))  # HWC -> CHW
        
        # 转换为torch tensor并添加batch维度
        img = torch.from_numpy(img).unsqueeze(0)
        if use_cuda:
            img = img.cuda()
        
        # 预测
        with torch.no_grad():
            prebs = lprnet(img)
        
        # 解码预测结果
        prebs = prebs.cpu().numpy()[0]  # 去掉batch维度
        preb_label = []
        for j in range(prebs.shape[1]):
            preb_label.append(np.argmax(prebs[:, j], axis=0))
        
        # 去除重复和空白标签
        no_repeat_blank_label = []
        pre_c = preb_label[0]
        if pre_c != len(CHARS) - 1:  # 忽略空白标签
            no_repeat_blank_label.append(pre_c)
        for c in preb_label:
            if (pre_c == c) or (c == len(CHARS) - 1):
                if c == len(CHARS) - 1:
                    pre_c = c
                continue
            no_repeat_blank_label.append(c)
            pre_c = c
        
        # 将数字标签转换为字符
        plate_number = ''.join([CHARS[i] for i in no_repeat_blank_label])
        
        # 显示结果
        result_img = cv2ImgAddText(img_orig, plate_number, (10, 30), textColor=(0, 255, 0), textSize=30)
        cv2.imshow('License Plate Recognition', result_img)
        print(f"识别结果: {plate_number}")
        cv2.waitKey(0)
        cv2.destroyAllWindows()
    
    if __name__ == "__main__":
        # 直接在这里指定要测试的图像路径
        test_image_path = "3.png"  # 替换为您的测试图像路径
        predict_single_image(test_image_path)

7\. 运行效果演示
----------

选取一张车牌图片（例如从网上下载的分割好的图像），甚至可以对最后一位字符进行裁切测试。运行代码后，结果会直接叠加在图片上显示。

例如：

*   测试一张蓝牌：识别准确。
*   测试一张绿牌（新能源）：也支持识别。

8\. 代码分析
--------

### 预训练模型加载

设置预训练模型路径（如./weights/Final\_LPRNet\_model.pth），检查文件存在性。然后使用build\_lprnet构建模型，选择设备（CPU或CUDA）。

### 图像读取与预处理

使用OpenCV读取图片：

*   Resize到94x24分辨率。
*   转换为float32类型。
*   减去127.5，使像素值范围变为-127.5到127.5（以0为中心，便于模型收敛）。
*   乘以0.0078125，使范围接近-1到1（像素归一化）。
*   转置维度：从HWC (Height, Width, Channels) 转为CHW。
*   添加batch维度，成为4维张量（batch\_size, channels, height, width）。

### 预测与解码

如果使用CUDA，将图像移到GPU。关闭梯度计算（with torch.no\_grad()）以加速预测。得到输出后，解码为字符序列，去除重复和空白标签，最终转换为车牌号字符串。

### 显示结果

使用PIL在原图上添加文本，显示识别结果。

9\. 注意事项
--------

*   Mac用户默认使用CPU；NVIDIA显卡用户可启用CUDA加速。
*   如果想获取单张图片处理代码，欢迎三连+关注，并留言邮箱。
*   模型适用于已分割的车牌图像；实际应用中可结合检测模型（如YOLO）进行完整识别。

如果想深入了解车牌识别更多内容，欢迎关注Coding茶水间，我会持续输出相关教程！

​