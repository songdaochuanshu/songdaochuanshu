---
layout: post
title: '我为什么认为未来的自动化应该是：人提需求，AI生成工作流，AI工具执行'
date: "2025-10-11T00:37:26Z"
---
我为什么认为未来的自动化应该是：人提需求，AI生成工作流，AI工具执行
===================================

![我为什么认为未来的自动化应该是：人提需求，AI生成工作流，AI工具执行](https://img2024.cnblogs.com/blog/3583746/202510/3583746-20251010161754654-1522511401.png) 大家好，今天想和大家分享一个我最近一直在思考和实践的小实验：如何让AI Agent更有条理地完成复杂任务，并且让我们 humans（人类）能够更好地控制和复现这些任务。

大家好，今天想和大家分享一个我最近一直在思考和实践的小实验：如何让AI Agent更有条理地完成复杂任务，并且让我们 humans（人类）能够更好地控制和复现这些任务。

起因：AI的"自由散漫"让我头疼
----------------

自从开始玩各种大模型和AI Agent，我发现一个有趣的问题：这些AI们厉害是厉害，但有时候就像个天赋异禀却太随性的天才艺术家——你想让他画一幅画，他可能会给你一首诗；你想他分析数据，他可能会给你讲个哲学故事。

特别是在处理一些需要多步骤、有明确逻辑的任务时，AI的表现总是不太稳定。这次可能完美搞定，下次换了个条件，结果就大相径庭。这种"随心所欲"的特性，虽然很有"创意"，但在实际工作中却让我很头疼。

灵光一闪：为什么不试试工作流？
---------------

某天在写代码的时候，我突然想到了工作流这个概念。我们都知道，人类处理复杂任务时，往往会把大任务分解成小步骤，按一定顺序执行，遇到问题也有相应的应对方案。为什么不能给AI也这样的一套"工作流程图"呢？

于是我开始了我的小实验：设计一个极简的工作流定义语言（DSL），让AI按照预设的路径完成任务。这样既能发挥AI的能力，又能保证结果的可控和可重复。

我的工作流定义长啥样？
-----------

在多次尝试后，我设计出了这样一个极简的YAML结构：

    workflow:
      name: string                # 工作流叫啥
      description: string         # 工作流要干啥
    
      # 步骤定义（最核心的部分）
      steps:
        - id: string              # 步骤ID
          description: string     # 步骤说明
          depends_on: [string]    # 依赖哪些步骤
    
      # 输出定义
      outputs:
        <output_name>:
          from: <step_id>
    
    # --- 碰到问题怎么办 ---
      error_handling:
        fallback_to:              # 出问题时的备选方案
    

超级简单对吧？我是故意这么设计的，因为我希望这份定义既能让AI看懂，也方便我们人类理解和修改。

真实案例：让AI帮我生成GitHub仓库采集工作流
-------------------------

这次小实验最酷的部分来了：不是我手动编写工作流，而是让AI根据我的需求自动生成！

我的需求很简单："帮我获取GitHub上前8个热门的前端仓库，提取重要信息并整理成表格"。

### 其他产品怎么做？

通常情况下，我会打开各种工作流工具，手动拖拽节点，配置参数，连接线...整个过程可能需要十几分钟，还得考虑各种细节。更糟的是，如果需求稍有变化，又得重新折腾一遍。

### 我的玩法：让AI自己写工作流

我给了AI这样一段完整的提示：

    我需要你帮我创建一个工作流定义，用于获取GitHub上前8个热门的前端仓库。请使用以下的工作流DSL格式：
    
    ```yaml
    workflow:
      name: string                # 工作流名称
      description: string         # 工作流描述
    
      steps:
        - id: string              # 步骤唯一标识符
          description: string     # 步骤说明，描述该步骤需要做什么
          depends_on: [string]    # 前置依赖步骤ID列表
    
      outputs:
        <output_name>:            # 输出变量名称
          from: <step_id>         # 指定从哪个步骤获取输出结果
    
      error_handling:
        fallback_to:
          <strategy>: <step_id>   # 定义错误处理策略
    ```
    
    基于这个DSL结构和我的需求，请生成一个完整的工作流YAML定义。工作流应该包括数据获取、信息提取、格式化和保存等步骤，并且考虑可能的错误处理场景。
    
    

看到了吗？我的提示词包含了三个关键部分：

1.  **明确的需求描述**：获取GitHub上前8个热门的前端仓库
2.  **完整的工作流DSL定义**：展示了我设计的YAML结构和每个字段的作用
3.  **生成指导**：明确告诉AI要基于这个DSL生成完整的工作流

然后，神奇的事情发生了！AI分析我的需求，理解了我的DSL结构，然后自动生成了这样的工作流：

    workflow:
      name: 获取GitHub热门前端仓库
      description: 从GitHub获取最热门的前8个前端相关仓库信息
    
      steps:
        - id: fetch_repos
          description: 通过GitHub API搜索并获取热门JavaScript前端仓库，按星标数降序排列，限制数量为8个
        
        - id: extract_details
          description: 从获取的仓库列表中提取仓库名、星标数、描述和URL等关键信息
          depends_on: [fetch_repos]
        
        - id: format_results
          description: 将提取的仓库信息格式化为易读的输出格式
          depends_on: [extract_details]
        
        - id: save_results
          description: 保存格式化后的结果，准备作为工作流输出
          depends_on: [format_results]
    
      outputs:
        popular_repos:
          from: save_results
    
      error_handling:
        fallback_to:
          api_failure: fetch_repos    # API请求失败时重试获取步骤
          format_issue: extract_details # 解析问题时继续提取尝试
          critical_failure: halt       # 严重故障时停止整个流程
    

### 没有提供DSL会怎样？

我很好奇，如果不提供DSL，直接让AI生成工作流，会有什么结果。于是我尝试了：

    请帮我创建一个工作流，用于获取GitHub上前8个热门的前端仓库，并提取重要信息整理成表格。
    

AI给出的结果是一个松散的步骤描述，没有清晰的结构，更不能直接用于自动执行。这对比太明显了——**提供DSL不仅给了AI生成规则，还确保了输出结果的一致性和可用性**。

### 更酷的是：版本控制与迭代

最让我兴奋的是，我可以把这个AI生成的工作流定义存到Git里，随时可以：

*   追踪变更历史
*   和团队成员协作
*   根据需要进行调整
*   回退到之前的版本

比如，过几天我想增加分析仓库趋势的功能，我可以告诉AI：

    请在我现有的GitHub仓库采集工作流基础上（附上当前的工作流YAML），增加一个步骤来分析这些项目的技术趋势，并生成简要报告。保持现有的DSL结构不变。
    

AI就能理解我的需求，在工作流中智能地添加新步骤，保持整体结构的一致性。

在AI开发工具的加持下，这种方法变得更强大了
----------------------

如果说之前的工作流定义还只是个"纸上谈兵"的概念，那么现在有了Claude CLI、Claude Dev这样的AI开发工具，这个想法就能真正发光发热了！

### 不再需要写代码去实现自动化

以前，我需要写代码来实现工作流的执行引擎，比如：

*   解析YAML工作流定义
*   按依赖顺序执行步骤
*   处理错误和重试
*   管理步骤间的数据传递

但现在？这些都可以交给AI开发工具来处理！

通过工作流生成的YAML，我可以这样自动化操作：

    # 让 Claude CLI 执行工作流
    claude github-workflow.yaml
    
    # 让 Claude Dev 监控执行过程
    claude dev --watch workflow.yml
    

AI工具会：

*   **自动理解工作流结构**：理解步骤间的依赖关系
*   **智能执行每个步骤**：调用合适的工具和API
*   **处理各种边界情况**：网络超时、API限制、数据格式问题
*   **提供执行反馈**：实时告诉我进展到了哪一步

### 真正的"无代码自动化"

举个例子，假如我要实现一个"每日技术资讯汇总"功能：

**传统方式（需要写代码）：**

1.  设计数据库schema
2.  写爬虫代码抓取多个技术网站
3.  写数据处理脚本清洗和分类
4.  写邮件发送模块
5.  部署定时任务
6.  各种异常处理和日志记录

**现在的方式（只需要定义工作流）：**

1.  让AI生成工作流定义
2.  AI开发工具自动执行

整个过程从"开发项目"变成了"描述需求"。我甚至不需要打开IDE，直接在命令行就能搞定：

    # 1. 生成工作流定义
    claude "帮我创建一个每日技术资讯汇总工作流，从HackerNews、RSSHub获取热门文章，分类整理后发送邮件" > workflow.yml
    
    # 2. 设置定时执行
    echo "0 8 * * * claude workflow.yml" | crontab -
    
    # 完成！
    

### 我们终于可以做更有意义的事情了

这种转变让我重新思考了"开发"的意义。过去，我们花了大量时间在重复的、模式化的编码工作上：

*   写同样的API调用代码
*   处理相似的数据格式
*   配置各种工具和环境
*   调试各种基础设施问题

现在，这些都可以交给AI和AI工具。我们终于有精力和时间去关注真正重要的事情：

#### 1\. **更深入的思考**

不用再纠结于代码实现细节，我可以花更多时间思考：

*   这个任务的本质是什么？
*   有没有更好的解决方案？
*   这个结果能为用户带来什么价值？

#### 2\. **更有创意的探索**

freed up 的脑力可以用来尝试更创新的想法：

*   能不能结合多个领域的知识？
*   如何让流程更智能化？
*   有没有全新的应用场景？

#### 3\. **更好地与AI协作**

有了更多时间，我可以专注于提升与AI的协作质量：

*   如何提出更好的需求？
*   如何设计更合适的引导？
*   如何从AI的结果中获得启发？

### 实际案例：自动化我的技术调研

最近我需要调研几个新兴技术框架。以前我会：

1.  写脚本爬取GitHub数据
2.  写代码分析趋势
3.  生成报告模板
4.  手动整理结果

现在，我只需要：

    # 定义需求
    claude "帮我调研 Svelte、Qwik、Solid.js 这三个前端框架，对比它们的性能、生态、学习曲线和适用场景" > tech-research.yml
    
    # 执行
    claude tech-research.yml
    

AI工具会：

*   自动访问GitHub获取各框架的数据
*   通过浏览器查找技术博客和评测
*   对比分析框架特性
*   生成结构化的对比报告

我只需要在结果出来后，花时间思考这些信息对我的项目有什么意义，而不是浪费时间在数据收集和整理上。

我的小工作流解决了什么？
------------

这种"AI生成工作流+AI工具执行"的方式，效果简直超乎想象：

1.  **零代码实现自动化**：从需求到执行，全程无需写一行代码
2.  **快速原型验证**：想法几分钟就能变成可用的自动化流程
3.  **专注核心问题**：把重复劳动交给AI，我们专注于价值创造
4.  **持续改进循环**：工作流定义可以不断迭代优化
5.  **团队协作更简单**：通过Git共享工作流定义，无需共享代码

"会写代码的AI"到"会设计流程的AI"再到"会执行流程的AI"
--------------------------------

说实话，AI的发展让我有点惊讶：

*   第一阶段：AI会写代码 → 解放我们的编程工作
*   第二阶段：AI会设计流程 → 解放我们的架构设计工作
*   第三阶段：AI会执行流程 → 解放我们的实现和运维工作

现在，我们只需要当好"需求者"和"思考者"，AI包办了从设计到执行的全过程。这种协作方式让我觉得自己更像一个"指挥家"而非"工人"。

这种方法让我重新思考了与AI协作的位置关系：

*   以前：我是设计者，AI是执行者
*   现在：我是需求提出者和价值判断者，AI既是流程设计者也是执行者

这种转变让我从繁琐的流程设计和代码编写中解放出来，专注于真正需要创造力和判断力的部分。

工作流背后的思考
--------

这个小实验让我重新思考了与AI协作的方式：

### 1\. 开发正在从"编写代码"转向"描述需求"

随着AI工具的成熟，我们的工作重心正在从"如何实现"转向"要实现什么"。这是一种根本性的转变——从技术思维转向产品思维，从实现思维转向价值思维。

### 2\. 简单抽象比复杂实现更重要

过去我们追求的是代码的优雅和架构的完美。现在我发现，一个好的抽象（比如我这个简单的工作流DSL）往往比复杂的实现更有价值。因为它能让AI更好地理解和执行。

### 3\. 与AI协作是一种"引导"而非"控制"

与其精确控制每一个细节，不如设计好框架和目标，然后引导AI在这个框架内发挥。现在的AI工具已经足够智能，能够理解我们的意图并自主完成复杂的任务。

我的下一步计划
-------

这个小实验只是开始，AI工具的发展让一切皆有可能：

1.  **更智能的协作模式**：探索如何与AI工具更自然地协作，比如语音交互、实时调整等
2.  **工作流的市场和生态**：设想一个工作流定义的共享市场，大家可以互相分享和改进工作流模板
3.  **与更多工具的集成**：让工作流能够调用各种SaaS服务、API、本地工具等
4.  **人机协同的边界探索**：人在哪些环节最有价值？AI在哪里能发挥最大作用？

当然，最重要的还是继续在实践中探索这种"描述需求→得到结果"的新模式。

写在最后
----

这篇分享更多是记录我的思考过程而非技术教程。我相信，在与AI协作的道路上，我们正在经历一个重大的转变。

传统的"人写代码，机器执行"的模式正在被"人描述需求，AI设计和执行"所取代。这不仅仅是效率的提升，更是工作本质的重新定义。

通过工作流定义和AI开发工具的结合，我感觉自己就像有了一个超级能干的团队伙伴。我可以专注于提出有价值的想法和判断结果的质量，而把所有繁琐的实现工作都交给AI。

**我们正在从"代码的书写者"变成"思想的引导者"。** 这或许就是这个时代给我们的最大礼物——让我们有机会重新专注于那些真正需要人类智慧的事情。

正是基于这些实践和思考，我愈发确信，未来的自动化应该是这样的模式：人负责提出有意义的需求和判断结果价值，AI负责将需求转化为高效的工作流程，而AI工具则负责可靠地执行这些流程。在这种模式中，每个人都能发挥自己独特的价值。

* * *

\*关注 **【松哥ai自动化】** 公众号，获取深度技术解析，从源码角度彻底理解各种工具的实现原理。更重要的是，遇到技术难题时，直接联系我！我会根据你的具体情况，提供最适合的解决方案和技术指导。

上期回顾：（[跨平台自动化框架的OCR点击操作实现详解与思考](https://mp.weixin.qq.com/s/8eGgS0yokAeCQY7-lrZGTQ)）\*