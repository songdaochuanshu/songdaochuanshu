---
layout: post
title: '线程池以及HashTable, HashMap, ConcurrentHashMap之间的区别'
date: "2026-01-15T00:43:37Z"
---
线程池以及HashTable, HashMap, ConcurrentHashMap之间的区别
===============================================

### 什么是线程池

##### 线程池（Thread Pool）是一种线程使用模式，提前创建一定数量的线程并进行复用，统一管理线程的创建、销毁和调度，从而：

*   降低线程创建和销毁的开销
*   提高程序响应速度
*   防止线程数量失控导致系统资源耗尽

### 线程池的核心参数

*   Java中线程池的核心实现类是 ThreadPoolExecutor。

    public ThreadPoolExecutor(
        int corePoolSize,
        int maximumPoolSize,
        long keepAliveTime,
        TimeUnit unit,
        BlockingQueue<Runnable> workQueue,
        ThreadFactory threadFactory,
        RejectedExecutionHandler handler
    )
    

1.  corePoolSize（核心线程数）

*   线程池中长期存活的线程数量
*   即使空闲，也不会被销毁（除非设置允许回收）
*   作用：保证线程池的基本处理能力

2.  maximumPoolSize（最大线程数）

*   线程池中允许存在的最大线程数量
*   当任务很多、队列已满时，才会创建新线程
*   作用：限制线程数量，防止资源耗尽

3.  keepAliveTime（空闲存活时间）

*   非核心线程空闲时，最多存活时间
*   超过该时间将被回收

4.  unit（时间单位）

*   keepAliveTime 的时间单位
*   如：TimeUnit.SECONDS

5.  workQueue（任务队列）

*   用于存放等待执行的任务
*   常见实现：

队列

特点

LinkedBlockingQueue

无界队列（可能 OOM）

ArrayBlockingQueue

有界队列

SynchronousQueue

不存任务，直接交给线程

DelayQueue

延时任务

6.  threadFactory（线程工厂）

*   用于创建线程
*   可自定义线程名、优先级、是否守护线程
*   方便排查问题、日志定位

7.  handler（拒绝策略）

*   当线程池线程数已满 + 队列已满时触发。

策略

行为

AbortPolicy

抛异常（默认）

CallerRunsPolicy

调用者自己执行

DiscardPolicy

直接丢弃任务

DiscardOldestPolicy

丢弃最早任务

### 线程池的工作流程

*   线程池处理任务的完整逻辑可总结为5个步骤:

flowchart TD A\[提交任务\] --> B{核心线程池是否满？} B -- 否 --> C\[创建核心线程执行任务\] B -- 是 --> D{任务队列是否满？} D -- 否 --> E\[任务加入队列等待\] D -- 是 --> F{线程池是否达到最大线程数？} F -- 否 --> G\[创建非核心线程执行任务\] F -- 是 --> H\[执行拒绝策略\]

### Executors创建常见线程池

*   Java提供了Executors工具类，快速创建线程池（但生产环境不推荐直接使用）。

1.  FixedThreadPool（固定大小线程池）

    ExecutorService pool = Executors.newFixedThreadPool(5);
    

*   特点
    *   线程数量固定
    *   使用 无界队列 LinkedBlockingQueue
*   风险
    *   任务过多可能 OOM(内存溢出)
*   适用场景
    *   任务量稳定
    *   并发数可控

2.  SingleThreadExecutor（单线程池）

    ExecutorService pool = Executors.newSingleThreadExecutor();
    

*   特点
    *   只有一个线程
    *   保证任务顺序执行
*   风险
    *   任务堆积可能 OOM(内存溢出)

3.  CachedThreadPool（缓存线程池）

    ExecutorService pool = Executors.newCachedThreadPool();
    

*   特点
    *   线程数不固定
    *   空闲线程 60s 回收
    *   使用 SynchronousQueue
*   风险
    *   线程数无限增长，容易耗尽CPU

4.  ScheduledThreadPool（定时线程池）

    ScheduledExecutorService pool = Executors.newScheduledThreadPool(3);
    

*   特点:支持定时、周期任务

* * *

### HashTable, HashMap, ConcurrentHashMap 之间的区别

#### 主要区别：

对比点

Hashtable

HashMap

ConcurrentHashMap

线程安全

安全

不安全

安全

实现方式

数组+链表

数组+链表+红黑树 (JDK 1.8)

数组+链表+红黑树 + CAS + synchronized

锁的粒度

synchronized 整表加锁

无锁

分段锁/桶级锁 (锁定头节点)

性能

最差

最好

高并发下最好

允许 key 为 null

不允许

允许 1 个

不允许

允许 value 为 null

不允许

允许

不允许

是否推荐使用

不推荐

推荐（单线程）

推荐（并发）

扩容机制

整体扩容，扩容时阻塞所有操作

整体扩容，扩容时阻塞所有操作

分段 / 分桶扩容，不阻塞全部操作