---
layout: post
title: 'å°†SignalRç§»æ¤åˆ°Esp32â€”è®©å°æ™ºè®¾å¤‡æ— ç¼è¿æ¥.NETåŠŸèƒ½æ‹“å±•MCPæœåŠ¡'
date: "2026-02-02T00:58:30Z"
---
å°†SignalRç§»æ¤åˆ°Esp32â€”è®©å°æ™ºè®¾å¤‡æ— ç¼è¿æ¥.NETåŠŸèƒ½æ‹“å±•MCPæœåŠ¡
=======================================

å‰è¨€
--

è¿™æ®µæ—¶é—´è¿·ä¸Šäº†æ‰‹æ“Esp32çš„å°æ™ºèŠå¤©æœºå™¨äººï¼Œä¹Ÿç”¨.NETä¸ºå°æ™ºAIå¼€å‘äº†ä¸€äº›MCPè½¬æ¥å¹³å°å’ŒMCPæœåŠ¡ã€‚å°æ™ºESP32æœ¬èº«å°±å…·å¤‡MCPèƒ½åŠ›ï¼Œå¯ä»¥è°ƒç”¨æœ¬åœ°MCPå·¥å…·å’ŒæœåŠ¡ç«¯MCPå·¥å…·ï¼Œå¹¶å°†ç»“æœè¿”å›ç»™è®¾å¤‡ï¼Œè¿™ä¸ªåŠŸèƒ½ä¸€ç›´éƒ½æœ‰ã€‚

å¦‚æœä½ æœ‰æ‰‹æ“Esp32çš„ç¡¬ä»¶ç©å…·æ‰“ç®—ï¼Œå¯ä»¥å…³æ³¨æˆ‘çš„Bç«™è´¦å·ï¼ˆç»¿è«é˜¿å¹¿ï¼‰[https://space.bilibili.com/25228512](https://space.bilibili.com/25228512)  
å¸¦ä½ æ‰‹æ“ç©å…·ã€‚

å°æ™ºåŸæœ¬è¿™å¥—æ¶æ„æœ‰ä¸ªå±€é™æ€§ï¼š**MCPå·¥å…·æ‰§è¡Œå®Œä¹‹åï¼Œåªèƒ½åŒæ­¥è¿”å›ç»“æœæˆ–è€…é€šè¿‡å¼‚æ­¥é‚®ä»¶é€šçŸ¥ï¼Œè®¾å¤‡æ— æ³•è¢«åŠ¨æ¥æ”¶æœåŠ¡ç«¯çš„æ¶ˆæ¯**ã€‚æ¯”å¦‚æˆ‘æƒ³è®©æœåŠ¡ç«¯ä¸»åŠ¨ç»™è®¾å¤‡æ¨é€ä¸€å¼ å›¾ç‰‡ã€æ’­æ”¾ä¸€æ®µè¯­éŸ³ã€æˆ–è€…å‘é€ä¸€ä¸ªæ–‡æœ¬é€šçŸ¥ï¼Œåœ¨ä¹‹å‰çš„æ¶æ„ä¸‹æ˜¯åšä¸åˆ°çš„ã€‚

æ‰€ä»¥æˆ‘å°±å†³å®šæ”¹é€ å°æ™ºå®¢æˆ·ç«¯ï¼Œé›†æˆSignalRå®æ—¶é€šä¿¡æ¡†æ¶ã€‚è¿™æ¬¡æ”¹é€ çš„æ ¸å¿ƒä»·å€¼æ˜¯ï¼š**é€šè¿‡SignalRæ¶ˆæ¯é€šé“ï¼Œè®©è®¾å¤‡å¯ä»¥æ¥æ”¶å„ç§ç±»å‹çš„æ¶ˆæ¯ï¼ˆå£°éŸ³ã€å›¾ç‰‡ã€æ–‡æœ¬é€šçŸ¥ï¼‰ï¼ŒæœåŠ¡ç«¯çš„MCPå·¥å…·æ‰§è¡ŒæˆåŠŸåï¼Œå¯ä»¥æ ¹æ®ç”¨æˆ·IDæ¨é€æ•°æ®åˆ°å¯¹åº”çš„ç”¨æˆ·é€šé“**ã€‚

æ•´ä¸ªæ”¹é€ æ¶‰åŠSignalR C++å®¢æˆ·ç«¯çš„é›†æˆã€JWT Tokenè®¤è¯ã€æ‰«ç ç™»å½•ï¼ˆåŸºäºESP32æœ¬åœ°MCPå·¥å…·å®ç°ï¼‰ã€ä»¥åŠæœåŠ¡ç«¯æ¶ˆæ¯æ¨é€é€»è¾‘ã€‚å®¢æˆ·ç«¯ä»£ç éƒ½æ˜¯C++å®ç°çš„ï¼Œä¸è¿‡ç°åœ¨AIè¾…åŠ©ç¼–ç¨‹å¾ˆå¼ºå¤§ï¼Œå¸®æˆ‘èŠ‚çœäº†å¤§é‡æ—¶é—´ã€‚

![img](https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201121657114-327485878.png)

é—®é¢˜è§£ç­”
----

**Q: ä¸ºä»€ä¹ˆé€‰æ‹©SignalRè€Œä¸æ˜¯ç›´æ¥ç”¨WebSocketï¼Ÿ**

A: èµ·åˆæˆ‘ç¡®å®è€ƒè™‘è¿‡ç›´æ¥ç”¨WebSocketï¼Œä½†SignalRæä¾›äº†å¾ˆå¤šå¼€ç®±å³ç”¨çš„åŠŸèƒ½ï¼š

*   **HubæŠ½è±¡**ï¼šæœåŠ¡ç«¯å¯ä»¥è½»æ¾å®ç°ç¾¤ç»„ç®¡ç†ï¼ŒæŒ‰ç”¨æˆ·IDæ¨é€æ¶ˆæ¯ï¼Œæ¯”å¦‚`Clients.Group($"Users:{userId}").SendAsync("Notification", message)`
*   **æ¶ˆæ¯è·¯ç”±**ï¼šä¸éœ€è¦è‡ªå·±å†™æ¶ˆæ¯åˆ†å‘é€»è¾‘ï¼ŒSignalRçš„Hubæ–¹æ³•è°ƒç”¨å’Œäº‹ä»¶æ¨é€å·²ç»å¾ˆå®Œå–„äº†
*   **ç±»å‹åŒ–è°ƒç”¨**ï¼šç›¸æ¯”åŸå§‹WebSocketçš„å­—ç¬¦ä¸²æ¶ˆæ¯ï¼ŒSignalRæä¾›äº†ç±»ä¼¼RPCçš„è°ƒç”¨ä½“éªŒï¼Œä»£ç æ›´æ¸…æ™°

è™½ç„¶ESP32æ²¡æœ‰ç°æˆçš„SignalRåº“ï¼Œä½†æˆ‘æ‰¾åˆ°äº†å¾®è½¯å®˜æ–¹çš„C++ SignalRå®¢æˆ·ç«¯ï¼ˆåŠæˆå“ï¼‰ï¼Œå°†å®ƒä¸ESP32çš„WebSocketç»„ä»¶æ•´åˆåï¼Œå°±èƒ½ç”¨ä¸ŠSignalRçš„è¿™äº›ç‰¹æ€§äº†ã€‚è‡³äºSignalRè‡ªå¸¦çš„é‡è¿æœºåˆ¶ï¼Œæˆ‘æ²¡ç”¨ï¼Œå°æ™ºæœ‰è‡ªå·±çš„å¾ªç¯é‡è¿é€»è¾‘ï¼Œæ›´å¯æ§ä¸€äº›ã€‚

**Q: æ”¹é€ çš„æ ¸å¿ƒä»·å€¼æ˜¯ä»€ä¹ˆï¼Ÿè§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿ**

A: æ”¹é€ å‰ï¼ŒESP32çš„MCPå·¥å…·è°ƒç”¨å®Œæˆåï¼Œåªèƒ½é€šè¿‡ä¸¤ç§æ–¹å¼é€šçŸ¥ï¼š

1.  **åŒæ­¥è¿”å›**ï¼šå·¥å…·æ‰§è¡Œç»“æœç›´æ¥è¿”å›ç»™è°ƒç”¨æ–¹
2.  **å¼‚æ­¥é‚®ä»¶**ï¼šé€šè¿‡é‚®ä»¶å‘é€æ‰§è¡Œç»“æœ

è¿™ä¸¤ç§æ–¹å¼éƒ½æ— æ³•æ»¡è¶³å®æ—¶æ¨é€çš„éœ€æ±‚ã€‚æ¯”å¦‚æˆ‘æƒ³è®©æœåŠ¡ç«¯åœ¨ç”Ÿå›¾å®Œæˆåç«‹å³æ¨é€å›¾ç‰‡ç»™è®¾å¤‡æ˜¾ç¤ºï¼Œæˆ–è€…æ’­æ”¾ä¸€æ®µè¯­éŸ³æç¤ºï¼Œä¹‹å‰çš„æ¶æ„åšä¸åˆ°ã€‚

æ”¹é€ åï¼Œé€šè¿‡SignalRå»ºç«‹äº†ä¸€æ¡**æœåŠ¡ç«¯åˆ°è®¾å¤‡çš„å®æ—¶æ¶ˆæ¯é€šé“**ï¼š

*   æœåŠ¡ç«¯çš„MCPå·¥å…·æ‰§è¡ŒæˆåŠŸåï¼Œå¯ä»¥è°ƒç”¨`_hubContext.Clients.Group($"Users:{userId}").SendAsync("ShowImage", imageData)`å°†å›¾ç‰‡æ¨é€ç»™è®¾å¤‡
*   è®¾å¤‡é€šè¿‡SignalRçš„äº‹ä»¶ç›‘å¬æ¥æ”¶æ¶ˆæ¯ï¼š`connection->on("ShowImage", [](const std::vector<signalr::value>& args) { ... })`
*   æ”¯æŒæ¨é€ä»»æ„ç±»å‹çš„æ•°æ®ï¼šæ–‡æœ¬ã€å›¾ç‰‡ï¼ˆBase64ï¼‰ã€è¯­éŸ³URLã€JSONé€šçŸ¥ç­‰

è¿™æ‰æ˜¯è¿™æ¬¡æ”¹é€ çš„æ ¸å¿ƒä»·å€¼ï¼š**è®©è®¾å¤‡å…·å¤‡è¢«åŠ¨æ¥æ”¶æœåŠ¡ç«¯æ¶ˆæ¯çš„èƒ½åŠ›**ï¼Œè€Œä¸ä»…ä»…æ˜¯ä¸»åŠ¨è°ƒç”¨å’ŒåŒæ­¥è¿”å›ã€‚

**Q: æ‰«ç ç™»å½•æ˜¯æ€ä¹ˆå®ç°çš„ï¼Ÿ**

A: æ‰«ç ç™»å½•åŠŸèƒ½æ˜¯åŸºäºESP32æœ¬åœ°MCPå·¥å…·å®ç°çš„ï¼Œè¿™æ˜¯å°æ™ºçš„å›ºæœ‰åŠŸèƒ½ï¼Œæˆ‘åªæ˜¯è¿›è¡Œäº†æ‹“å±•ï¼š

1.  è®¾å¤‡å¯åŠ¨æ—¶æ£€æŸ¥æ˜¯å¦æœ‰JWT Token
2.  å¦‚æœæ²¡æœ‰Tokenï¼Œè°ƒç”¨æœ¬åœ°MCPå·¥å…·`display_qrcode`åœ¨å±å¹•ä¸Šæ˜¾ç¤ºäºŒç»´ç 
3.  äºŒç»´ç å†…å®¹åŒ…å«è®¾å¤‡IDå’ŒæœåŠ¡ç«¯åœ°å€ï¼š`https://mcp-server.com/device-login?deviceId=xxx`
4.  ç”¨æˆ·ç”¨æ‰‹æœºæ‰«ç ï¼Œå®Œæˆæˆæƒã€‚
5.  è®¾å¤‡è·å–Tokenåä¿å­˜åˆ°NVSï¼ˆNon-Volatile Storageï¼‰ï¼Œä¸‹æ¬¡å¯åŠ¨ç›´æ¥ä½¿ç”¨

è¿™æ ·å°±å®ç°äº†è®¾å¤‡çš„å¿«é€Ÿè®¤è¯ï¼Œç”¨æˆ·ä½“éªŒå¾ˆå¥½ã€‚æ‰«ç è®¤è¯çš„æœåŠ¡ç«¯æ˜¯ä½¿ç”¨å¼€æºçš„keycloakåšçš„ï¼Œå¯¹æ¥äº†è®¾å¤‡è®¤è¯ç±»å‹ã€‚

![img](https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201121907430-924035727.png)

åè¯è§£é‡Š
----

### æ ¸å¿ƒæ¦‚å¿µ

*   **SignalR**ï¼šå¾®è½¯æä¾›çš„å®æ—¶é€šä¿¡æ¡†æ¶ï¼Œå°è£…äº†WebSocketã€Serverâ€‘Sent Eventså’Œé•¿è½®è¯¢ç­‰ä¼ è¾“æ–¹å¼ï¼Œæ”¯æŒHubæ¨¡å‹ã€è‡ªåŠ¨é‡è¿ä¸æ¶ˆæ¯åºåˆ—åŒ–ã€‚é€‚åˆå®ç°åŒå‘ã€ä½å»¶è¿Ÿçš„å®æ—¶æ¶ˆæ¯ç³»ç»Ÿã€‚å°†å®ƒç§»æ¤åˆ°åµŒå…¥å¼è®¾å¤‡æ—¶éœ€è€ƒè™‘å®¢æˆ·ç«¯å®ç°çš„ä½“ç§¯ã€å†…å­˜æ¶ˆè€—ä¸çº¿ç¨‹æ¨¡å‹ã€‚
    
*   **Hubï¼ˆé›†çº¿å™¨ï¼‰**ï¼šSignalRçš„æ ¸å¿ƒæŠ½è±¡ï¼Œç±»ä¼¼äºMVCä¸­çš„Controllerã€‚æœåŠ¡ç«¯é€šè¿‡Hubå®šä¹‰æ–¹æ³•ä¾›å®¢æˆ·ç«¯è°ƒç”¨ï¼Œå®¢æˆ·ç«¯ä¹Ÿå¯ä»¥æ³¨å†Œäº‹ä»¶ç›‘å¬æœåŠ¡ç«¯æ¨é€ã€‚ä¾‹å¦‚`ChatHub.SendMessage(user, message)`å°±æ˜¯ä¸€ä¸ªå…¸å‹çš„Hubæ–¹æ³•ã€‚
    
*   **MCPï¼ˆModel Context Protocolï¼‰**ï¼šä¸€ç§åŸºäºJSON-RPC 2.0çš„åè®®ï¼Œç”¨äºå®šä¹‰å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä¹‹é—´çš„å·¥å…·è°ƒç”¨è§„èŒƒã€‚åœ¨IoTåœºæ™¯ä¸­ï¼Œè®¾å¤‡å¯ä»¥ä½œä¸ºMCP Serveræš´éœ²èƒ½åŠ›ï¼ˆå¦‚é‡å¯ã€æ˜¾ç¤ºå›¾ç‰‡ï¼‰ï¼Œè€Œäº‘ç«¯æœåŠ¡ä½œä¸ºMCP Clientè°ƒç”¨è¿™äº›èƒ½åŠ›ã€‚
    
*   **JSON-RPC 2.0**ï¼šä¸€ç§è½»é‡çº§çš„è¿œç¨‹è¿‡ç¨‹è°ƒç”¨åè®®ï¼Œä½¿ç”¨JSONç¼–ç ã€‚MCPåè®®åŸºäºæ­¤æ ‡å‡†ï¼Œå®šä¹‰äº†`initialize`ã€`tools/list`ã€`tools/call`ç­‰æ–¹æ³•ã€‚æ¯ä¸ªè¯·æ±‚å¿…é¡»åŒ…å«`jsonrpc: "2.0"`ã€`method`ã€`id`å­—æ®µã€‚
    

### ESP32ç›¸å…³

*   **FreeRTOS**ï¼šä¸€ä¸ªå¼€æºã€è½»é‡çº§çš„å®æ—¶æ“ä½œç³»ç»Ÿå†…æ ¸ï¼Œå¸¸ç”¨äºå¾®æ§åˆ¶å™¨å¹³å°ï¼ˆå¦‚ESP32ï¼‰ã€‚æä¾›ä»»åŠ¡è°ƒåº¦ã€ä¼˜å…ˆçº§ã€äº’æ–¥é”ã€ä¿¡å·é‡ã€é˜Ÿåˆ—ã€è½¯ä»¶å®šæ—¶å™¨ç­‰å®æ—¶ç‰¹æ€§ï¼Œä¾¿äºåœ¨èµ„æºå—é™è®¾å¤‡ä¸Šå®ç°å¹¶å‘ä¸ç¡®å®šæ€§è¡Œä¸ºã€‚ä½¿ç”¨æ—¶éœ€æ³¨æ„å †æ ˆå¤§å°ã€ä¸­æ–­å®‰å…¨å’Œä»»åŠ¡ä¼˜å…ˆçº§è®¾è®¡ã€‚
    
*   **ESP32 PSRAM**ï¼šESP32å¯é€‰çš„å¤–éƒ¨ä¼ªé™æ€RAMï¼ˆPseudo-SRAMï¼‰ï¼Œç”¨äºæ‰©å±•è®¾å¤‡å¯ç”¨å†…å­˜ï¼ˆå¸¸è§4MB/8MB/16MBï¼‰ã€‚é€‚åˆå­˜æ”¾å¤§å¯¹è±¡ã€å›¾åƒç¼“å­˜ã€ç½‘ç»œç¼“å†²å’ŒåŠ¨æ€åˆ†é…æ•°æ®ã€‚åœ¨ESP-IDFä¸­éœ€å¯ç”¨å¹¶æ­£ç¡®é…ç½®ï¼Œåˆ†é…æ—¶ä¹Ÿå¯ä½¿ç”¨ä¸åŒçš„å †åŒºåŸŸï¼ˆå¦‚`heap_caps_malloc(size, MALLOC_CAP_SPIRAM)`ï¼‰æ¥æ§åˆ¶æ”¾ç½®ä¸æ€§èƒ½ï¼DMAé™åˆ¶ã€‚
    
*   **WebSocket**ï¼šä¸€ç§åŸºäºTCPçš„å…¨åŒå·¥é€šä¿¡åè®®ï¼Œé€šè¿‡HTTPæ¡æ‰‹å‡çº§å»ºç«‹è¿æ¥ã€‚SignalRé»˜è®¤ä¼˜å…ˆä½¿ç”¨WebSocketä½œä¸ºä¼ è¾“å±‚ï¼Œåœ¨ESP32ä¸Šé€šè¿‡`esp_websocket_client`ç»„ä»¶å®ç°ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ESP32çš„WebSocketå®¢æˆ·ç«¯ä¸æ”¯æŒè‡ªåŠ¨é‡è¿ï¼Œéœ€è¦åœ¨åº”ç”¨å±‚å®ç°ã€‚
    

### è®¤è¯ç›¸å…³

*   **Bearer Token**ï¼šä¸€ç§HTTPè®¤è¯æ–¹æ¡ˆï¼Œå°†Tokenæ”¾åœ¨Authorizationå¤´ä¸­ï¼š`Authorization: Bearer <token>`ã€‚åœ¨SignalRä¸­ï¼Œé€šå¸¸å°†Tokenä½œä¸ºæŸ¥è¯¢å‚æ•°ä¼ é€’ï¼š`/hub?access_token=YOUR_TOKEN`
    
*   **JWTï¼ˆJSON Web Tokenï¼‰**ï¼šä¸€ç§å¼€æ”¾æ ‡å‡†ï¼ˆRFC 7512ï¼‰ï¼Œç”¨äºåœ¨å„æ–¹ä¹‹é—´å®‰å…¨åœ°ä¼ è¾“ä¿¡æ¯ã€‚åœ¨Verdure MCPä¸­ï¼Œä½¿ç”¨Keycloakç­¾å‘çš„JWTè¿›è¡Œç”¨æˆ·è®¤è¯ï¼ŒTokenä¸­åŒ…å«ç”¨æˆ·IDã€è§’è‰²ã€è¿‡æœŸæ—¶é—´ç­‰Claimä¿¡æ¯ã€‚
    
*   **API Token**ï¼šä¸€ç§ç®€å•çš„è®¤è¯æ–¹å¼ï¼Œåç»­è¿æ¥æ—¶æºå¸¦æ­¤TokenéªŒè¯èº«ä»½ã€‚Verdure MCPåŒæ—¶æ”¯æŒAPI Tokenå’ŒJWTä¸¤ç§æ–¹å¼ã€‚
    

![img](https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201152548041-1540521880.png)

æ ¸å¿ƒæŠ€æœ¯æ¶æ„
------

æ•´ä¸ªæ”¹é€ çš„æ¶æ„å¯ä»¥ç”¨ä¸€å¼ å›¾è¯´æ˜ï¼š

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   .NET MCP Service   â”‚                          â”‚   ESP32 Device       â”‚
    â”‚   (Verdure MCP)      â”‚â—„â”€â”€â”€â”€â”€SignalR Hubâ”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   (å°æ™ºå®¢æˆ·ç«¯)       â”‚
    â”‚                      â”‚                          â”‚                      â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â‘  JWT Tokenè®¤è¯         â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚  DeviceHub.cs  â”‚  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  â”‚  æ‰«ç ç™»å½•      â”‚  â”‚
    â”‚  â”‚                â”‚  â”‚                          â”‚  â”‚  (æœ¬åœ°MCPå·¥å…·) â”‚  â”‚
    â”‚  â”‚ OnConnected    â”‚  â”‚                          â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â”‚  â”‚ (éªŒè¯Token)    â”‚  â”‚                          â”‚          â†“           â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â‘¡ å»ºç«‹è¿æ¥               â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚          â†“           â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  â”‚ SignalR Client â”‚  â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                          â”‚  â”‚ - connection   â”‚  â”‚
    â”‚  â”‚  ç¾¤ç»„ç®¡ç†      â”‚  â”‚                          â”‚  â”‚ - on() events  â”‚  â”‚
    â”‚  â”‚ Users:{userId} â”‚  â”‚                          â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                          â”‚                      â”‚
    â”‚          â†“           â”‚                          â”‚                      â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â‘¢ MCPå·¥å…·æ‰§è¡Œåæ¨é€     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚  æ¶ˆæ¯æ¨é€      â”‚  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  â”‚ æ¶ˆæ¯æ¥æ”¶å¤„ç†   â”‚  â”‚
    â”‚  â”‚ SendAsync()    â”‚  â”‚  ShowImage(imageData)    â”‚  â”‚ - æ˜¾ç¤ºå›¾ç‰‡     â”‚  â”‚
    â”‚  â”‚                â”‚  â”‚  PlayAudio(audioUrl)     â”‚  â”‚ - æ’­æ”¾è¯­éŸ³     â”‚  â”‚
    â”‚  â”‚                â”‚  â”‚  Notification(text)      â”‚  â”‚ - æ˜¾ç¤ºé€šçŸ¥     â”‚  â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                          â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    

å…³é”®æµç¨‹ï¼š

1.  **æ‰«ç ç™»å½•**ï¼šè®¾å¤‡å¯åŠ¨åï¼Œå¦‚æœæ²¡æœ‰Tokenï¼Œè°ƒç”¨æœ¬åœ°MCPå·¥å…·æ˜¾ç¤ºäºŒç»´ç ï¼Œç”¨æˆ·æ‰«ç åè·å–JWT Token
2.  **å»ºç«‹è¿æ¥**ï¼šæºå¸¦JWT Tokenè¿æ¥SignalR Hubï¼ŒæœåŠ¡ç«¯éªŒè¯ååŠ å…¥ç”¨æˆ·ç¾¤ç»„`Users:{userId}`
3.  **æ¶ˆæ¯æ¨é€**ï¼šæœåŠ¡ç«¯MCPå·¥å…·æ‰§è¡Œå®Œæˆåï¼Œé€šè¿‡SignalRå°†ç»“æœæ¨é€ç»™è®¾å¤‡
    *   `_hubContext.Clients.Group($"Users:{userId}").SendAsync("ShowImage", imageData)`
    *   è®¾å¤‡ç›‘å¬äº‹ä»¶å¹¶å¤„ç†ï¼š`connection->on("ShowImage", handler)`

è¿™å¥—æ¶æ„çš„æ ¸å¿ƒä»·å€¼å°±æ˜¯**è®©æœåŠ¡ç«¯å¯ä»¥ä¸»åŠ¨æ¨é€æ¶ˆæ¯ç»™è®¾å¤‡**ï¼Œè€Œä¸ä»…ä»…æ˜¯ç­‰å¾…è®¾å¤‡è½®è¯¢æˆ–åŒæ­¥è¿”å›ã€‚

å¼€å‘ç¯å¢ƒå‡†å¤‡
------

### ESP32å¼€å‘ç¯å¢ƒï¼ˆVS Codeæ–¹å¼ï¼‰

æœ€ç®€å•çš„æ–¹å¼æ˜¯ä½¿ç”¨VS Codeçš„ESP-IDFæ’ä»¶ï¼š

1.  **å®‰è£…VS Codeå’Œæ’ä»¶**
    
    *   ä¸‹è½½å®‰è£… [Visual Studio Code](https://code.visualstudio.com/)
    *   å®‰è£…æ‰©å±•ï¼š`Espressif IDF` (æœç´¢ `esp-idf`)
2.  **é…ç½®ESP-IDF**
    
    *   æŒ‰`F1`æ‰“å¼€å‘½ä»¤é¢æ¿ï¼Œè¾“å…¥ `ESP-IDF: Configure ESP-IDF Extension`
    *   é€‰æ‹© `Express` å¿«é€Ÿé…ç½®
    *   é€‰æ‹©ESP-IDFç‰ˆæœ¬ï¼ˆæ¨èv5.1æˆ–æ›´é«˜ï¼‰
    *   ç­‰å¾…å®‰è£…å®Œæˆï¼ˆä¼šè‡ªåŠ¨ä¸‹è½½å·¥å…·é“¾ã€Pythonç¯å¢ƒç­‰ï¼‰
3.  **åˆ›å»º/æ‰“å¼€é¡¹ç›®**
    
    *   `F1` â†’ `ESP-IDF: Show Examples Projects`
    *   æˆ–ç›´æ¥æ‰“å¼€ esp-signalr-example é¡¹ç›®æ–‡ä»¶å¤¹
4.  **ç¼–è¯‘å’Œçƒ§å½•**
    
    *   ç‚¹å‡»åº•éƒ¨çŠ¶æ€æ çš„ `Build`ã€`Flash`ã€`Monitor` æŒ‰é’®
    *   æˆ–æŒ‰å¿«æ·é”®ï¼š`Ctrl+E B`ï¼ˆç¼–è¯‘ï¼‰ã€`Ctrl+E F`ï¼ˆçƒ§å½•ï¼‰

è¿™ç§æ–¹å¼æ¯”å‘½ä»¤è¡Œç®€å•å¾ˆå¤šï¼Œé€‚åˆ.NETå¼€å‘è€…å¿«é€Ÿä¸Šæ‰‹ESP32å¼€å‘ã€‚

![img](https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201122055040-2075015821.png)

### .NETå¼€å‘ç¯å¢ƒ

æœåŠ¡ç«¯ä½¿ç”¨.NET 10å¼€å‘ï¼š

    # Windows: ä¸‹è½½å®‰è£…å™¨ https://dotnet.microsoft.com/download/dotnet/10.0
    
    # éªŒè¯å®‰è£…
    dotnet --version  # åº”è¯¥è¾“å‡º 10.0.x
    
    

æ ¸å¿ƒä»£ç å®ç°
------

æœ¬ç« èŠ‚å°†ä»£ç åˆ†ä¸º**ç¤ºä¾‹ä»£ç **å’Œ**å®é™…æ•´åˆä»£ç **ä¸¤ä¸ªéƒ¨åˆ†è¿›è¡Œè®²è§£ï¼š

*   **ç¤ºä¾‹ä»£ç **ï¼šç”¨äºç†è§£æ ¸å¿ƒæ¦‚å¿µçš„ç®€åŒ–ç‰ˆæœ¬ï¼Œä¾¿äºå­¦ä¹ å’Œå¿«é€Ÿä¸Šæ‰‹
*   **å®é™…æ•´åˆä»£ç **ï¼šç”Ÿäº§ç¯å¢ƒä¸­çš„å®Œæ•´å®ç°ï¼ŒåŒ…å«å®Œå–„çš„é”™è¯¯å¤„ç†ã€çŠ¶æ€ç®¡ç†ç­‰

### å…³äºç¤ºä¾‹ä»“åº“

ä¸ºäº†å¸®åŠ©å¼€å‘è€…å¿«é€Ÿä¸Šæ‰‹ESP32çš„SignalRé›†æˆï¼Œæˆ‘åˆ›å»ºäº†ä¸€ä¸ªå®Œæ•´çš„ç¤ºä¾‹ä»“åº“ï¼š

**ğŸ”— ä»“åº“åœ°å€**ï¼š[https://github.com/maker-community/esp-signalr-example](https://github.com/maker-community/esp-signalr-example)

**ğŸ“¦ ä»“åº“ç»“æ„**ï¼š

    esp-signalr-example/
    â”œâ”€â”€ main/                    # ESP32 C++å®¢æˆ·ç«¯ä»£ç 
    â”‚   â”œâ”€â”€ main.cpp            # ä¸»ç¨‹åºï¼ˆWiFiè¿æ¥ã€SignalRåˆå§‹åŒ–ï¼‰
    â”‚   â””â”€â”€ CMakeLists.txt      # ESP-IDFæ„å»ºé…ç½®
    â”œâ”€â”€ signalr-server/         # .NET C# æœåŠ¡ç«¯ä»£ç 
    â”‚   â”œâ”€â”€ Program.cs          # ASP.NET CoreæœåŠ¡å™¨é…ç½®
    â”‚   â”œâ”€â”€ ChatHub.cs          # SignalR Hubå®ç°
    â”‚   â””â”€â”€ signalr-server.csproj
    â”œâ”€â”€ docs/                   # æ–‡æ¡£
    â”‚   â”œâ”€â”€ QUICKSTART.md       # 5åˆ†é’Ÿå¿«é€Ÿå¼€å§‹æŒ‡å—
    â”‚   â”œâ”€â”€ TEST_SERVER_SETUP.md # æµ‹è¯•æœåŠ¡å™¨è¯¦ç»†è®¾ç½®
    â”‚   â””â”€â”€ TROUBLESHOOTING.md  # å¸¸è§é—®é¢˜æ’æŸ¥
    â””â”€â”€ README.md               # é¡¹ç›®è¯´æ˜
    

**âœ¨ ä¸»è¦ç‰¹æ€§**ï¼š

1.  **å¼€ç®±å³ç”¨çš„æœåŠ¡å™¨**ï¼š
    
    *   åŸºäºASP.NET Coreå’ŒSignalRæ„å»º
    *   æ”¯æŒæ¶ˆæ¯å¹¿æ’­
    *   å®Œæ•´çš„è¿æ¥ç®¡ç†å’Œæ—¥å¿—è¾“å‡º
    *   æä¾›RESTful APIç”¨äºè®¾å¤‡æ§åˆ¶
2.  **ç®€åŒ–çš„ESP32å®¢æˆ·ç«¯**ï¼š
    
    *   ä½¿ç”¨Microsoftå®˜æ–¹çš„C++ SignalRå®¢æˆ·ç«¯åº“ç§»æ¤ç‰ˆ
    *   é€šè¿‡menuconfigé…ç½®WiFiå’ŒæœåŠ¡å™¨åœ°å€
    *   æ¼”ç¤ºæ¶ˆæ¯å‘é€/æ¥æ”¶ã€ä¼ æ„Ÿå™¨æ•°æ®ä¸ŠæŠ¥
    *   æ¸…æ™°çš„æ—¥å¿—è¾“å‡ºå’Œé”™è¯¯å¤„ç†

**ğŸš€ å¿«é€Ÿå¼€å§‹ç¤ºä¾‹**ï¼ˆ5åˆ†é’Ÿè¿è¡Œï¼‰ï¼š

    # 1. å…‹éš†ä»“åº“
    git clone https://github.com/maker-community/esp-signalr-example.git
    cd esp-signalr-example
    
    # 2. å¯åŠ¨æœåŠ¡å™¨ï¼ˆéœ€è¦.NET 9.0+ï¼‰
    cd signalr-server
    dotnet run --urls "http://+:5000" è¿™ä¸ªè¿è¡Œå¯ä»¥ç”¨ipè®¿é—®
    # æœåŠ¡å™¨è¿è¡Œåœ¨: http://0.0.0.0:5000/chatHub
    
    # 3. é…ç½®å¹¶çƒ§å½•ESP32
    cd ../
    idf.py menuconfig
    # é…ç½®WiFi SSIDã€å¯†ç å’ŒæœåŠ¡å™¨åœ°å€
    idf.py build flash monitor
    

esp32çš„é…ç½®å¦‚ä¸‹ï¼š

![img](https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201134357961-636085039.png)

**ğŸ“Š è¿è¡Œæ•ˆæœ**ï¼š

æœåŠ¡å™¨è¾“å‡ºï¼š  
![img](https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201135020573-402562452.png)

    âœ“ Client connected: abc123
      IP Address: 192.168.1.100
      Total Connections: 1
    
    [10:30:25] Received from ESP32-Device: Test message #1 from ESP32
    [10:30:35] Sensor Update - Temperature: 25.50
    

ESP32ä¸²å£è¾“å‡ºï¼š  
![img](https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201134940520-565577362.png)

    I (3520) SIGNALR_EXAMPLE: âœ“âœ“âœ“ Connected to SignalR Hub! âœ“âœ“âœ“
    I (3525) SIGNALR_EXAMPLE: ğŸ”” Notification: Welcome!
    I (14640) S
    

**ğŸ¯ ç¤ºä¾‹ä»“åº“çš„ä»·å€¼**ï¼š

*   **å­¦ä¹ è·¯å¾„æ¸…æ™°**ï¼šä»ç®€å•çš„è¿æ¥åˆ°å¤æ‚çš„æ•°æ®ä¼ è¾“ï¼Œå¾ªåºæ¸è¿›
*   **å¯ç›´æ¥è¿è¡Œ**ï¼šä¸éœ€è¦ä¾èµ–å¤–éƒ¨æœåŠ¡ï¼Œæœ¬åœ°å³å¯æµ‹è¯•å®Œæ•´æµç¨‹
*   **ä»£ç æ³¨é‡Šè¯¦ç»†**ï¼šå…³é”®éƒ¨åˆ†éƒ½æœ‰ä¸­è‹±æ–‡æ³¨é‡Šè¯´æ˜
*   **æ˜“äºæ‰©å±•**ï¼šåŸºäºè¿™ä¸ªç¤ºä¾‹å¯ä»¥å¿«é€Ÿå¼€å‘è‡ªå·±çš„åº”ç”¨

æ¥ä¸‹æ¥çš„ 5.1 èŠ‚å°†åŸºäºè¿™ä¸ªç¤ºä¾‹ä»“åº“çš„ä»£ç è¿›è¡Œè®²è§£ã€‚

### 5.1 ç¤ºä¾‹ä»£ç ï¼ˆæ•™å­¦ç®€åŒ–ç‰ˆï¼‰

> **è¯´æ˜**ï¼šä»¥ä¸‹ä»£ç æ¥è‡ªå¼€æºç¤ºä¾‹ä»“åº“ [esp-signalr-example](https://github.com/maker-community/esp-signalr-example)ï¼Œç»è¿‡ç²¾ç®€çªå‡ºæ ¸å¿ƒæ¦‚å¿µï¼Œæ–¹ä¾¿ç†è§£SignalRä¸ESP32é›†æˆçš„åŸºæœ¬åŸç†ã€‚å®Œæ•´ä»£ç è¯·å‚è€ƒä»“åº“æºç ã€‚

#### 5.1.1 æœåŠ¡ç«¯ï¼šSignalR HubåŸºç¡€å®ç°

è¿™æ˜¯æœåŠ¡ç«¯çš„æ ¸å¿ƒä»£ç ï¼Œå®ç°äº†è¿æ¥ç®¡ç†ã€æ¶ˆæ¯å¹¿æ’­å’Œè®¾å¤‡çŠ¶æ€è·Ÿè¸ªï¼š

**ChatHub.cs - Hubæ ¸å¿ƒå®ç°**ï¼š

    using Microsoft.AspNetCore.SignalR;
    
    public class ChatHub : Hub
    {
        private readonly ILogger<ChatHub> _logger;
        private static int _connectionCount = 0;
        
        // å­˜å‚¨è¿æ¥çš„è®¾å¤‡ä¿¡æ¯
        private static readonly Dictionary<string, DeviceInfo> _connectedDevices = new();
        private static readonly object _devicesLock = new();
    
        public ChatHub(ILogger<ChatHub> logger)
        {
            _logger = logger;
        }
    
        /// <summary>
        /// å¤„ç†æ¥è‡ªESP32çš„æ¶ˆæ¯
        /// </summary>
        public async Task SendMessage(string user, string message)
        {
            _logger.LogInformation("[{Time}] Received from {User}: {Message}", 
                DateTime.Now.ToString("HH:mm:ss"), user, message);
            
            // å¹¿æ’­åˆ°æ‰€æœ‰è¿æ¥çš„å®¢æˆ·ç«¯
            await Clients.All.SendAsync("ReceiveMessage", user, message);
        }
    
        /// <summary>
        /// å¤„ç†ä¼ æ„Ÿå™¨æ•°æ®æ›´æ–°
        /// </summary>
        public async Task UpdateSensor(string sensorId, double value)
        {
            _logger.LogInformation("[{Time}] Sensor Update - {SensorId}: {Value:F2}", 
                DateTime.Now.ToString("HH:mm:ss"), sensorId, value);
            
            // å¹¿æ’­ä¼ æ„Ÿå™¨æ•°æ®åˆ°æ‰€æœ‰å®¢æˆ·ç«¯
            await Clients.All.SendAsync("UpdateSensorData", sensorId, value);
        }
    
        /// <summary>
        /// å¤„ç†ESP32çŠ¶æ€æ›´æ–°
        /// </summary>
        public async Task UpdateDeviceStatus(string deviceId, string status, int freeHeap)
        {
            _logger.LogInformation("[{Time}] Device Status - {DeviceId}: {Status}, Free Heap: {FreeHeap} bytes", 
                DateTime.Now.ToString("HH:mm:ss"), deviceId, status, freeHeap);
            
            await Clients.All.SendAsync("DeviceStatusUpdate", deviceId, status, freeHeap);
        }
    
        /// <summary>
        /// å®¢æˆ·ç«¯è¿æ¥æ—¶è§¦å‘
        /// </summary>
        public override async Task OnConnectedAsync()
        {
            Interlocked.Increment(ref _connectionCount);
            
            var connectionId = Context.ConnectionId;
            var httpContext = Context.GetHttpContext();
            var ipAddress = httpContext?.Connection.RemoteIpAddress?.ToString();
            var userAgent = httpContext?.Request.Headers["User-Agent"].ToString();
            
            // ä¿å­˜è®¾å¤‡ä¿¡æ¯
            lock (_devicesLock)
            {
                _connectedDevices[connectionId] = new DeviceInfo
                {
                    ConnectionId = connectionId,
                    IpAddress = ipAddress,
                    UserAgent = userAgent,
                    ConnectedAt = DateTime.UtcNow
                };
            }
            
            _logger.LogInformation("âœ“ Client connected: {ConnectionId}", connectionId);
            _logger.LogInformation("  IP Address: {IpAddress}", ipAddress);
            _logger.LogInformation("  Total Connections: {Count}", _connectionCount);
            
            await base.OnConnectedAsync();
            
            // å‘é€æ¬¢è¿æ¶ˆæ¯ï¼ˆESP32é€šè¿‡æ­¤æ¶ˆæ¯ç¡®è®¤è¿æ¥æˆåŠŸï¼‰
            await Clients.Caller.SendAsync("Notification", 
                "Welcome to SignalR Test Server!");
        }
    
        /// <summary>
        /// å®¢æˆ·ç«¯æ–­å¼€æ—¶è§¦å‘
        /// </summary>
        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            Interlocked.Decrement(ref _connectionCount);
            
            var connectionId = Context.ConnectionId;
            
            // ç§»é™¤è®¾å¤‡ä¿¡æ¯
            lock (_devicesLock)
            {
                _connectedDevices.Remove(connectionId);
            }
            
            _logger.LogInformation("âœ— Client disconnected: {ConnectionId}", connectionId);
            if (exception != null)
            {
                _logger.LogWarning("  Disconnection reason: {Message}", exception.Message);
            }
            _logger.LogInformation("  Remaining Connections: {Count}", _connectionCount);
            
            await base.OnDisconnectedAsync(exception);
        }
    }
    
    /// <summary>
    /// è®¾å¤‡è¿æ¥ä¿¡æ¯
    /// </summary>
    public class DeviceInfo
    {
        public string ConnectionId { get; set; } = "";
        public string? IpAddress { get; set; }
        public string? UserAgent { get; set; }
        public DateTime ConnectedAt { get; set; }
    }
    

**Program.cs - SignalRæœåŠ¡é…ç½®**ï¼š

    var builder = WebApplication.CreateBuilder(args);
    
    // æ·»åŠ SignalRæœåŠ¡
    builder.Services.AddSignalR(options =>
    {
        options.EnableDetailedErrors = true;  // å¼€å‘ç¯å¢ƒå¯ç”¨
        options.ClientTimeoutInterval = TimeSpan.FromSeconds(30);  // å®¢æˆ·ç«¯è¶…æ—¶
        options.KeepAliveInterval = TimeSpan.FromSeconds(15);  // å¿ƒè·³é—´éš”
    });
    
    // æ·»åŠ CORSæ”¯æŒï¼ˆå…è®¸ESP32è·¨åŸŸè¿æ¥ï¼‰
    builder.Services.AddCors(options =>
    {
        options.AddDefaultPolicy(policy =>
        {
            policy.AllowAnyOrigin()
                  .AllowAnyHeader()
                  .AllowAnyMethod();
        });
    });
    
    var app = builder.Build();
    
    app.UseCors();
    app.MapHub<ChatHub>("/chatHub");
    
    // ç›‘å¬æ‰€æœ‰ç½‘ç»œæ¥å£ï¼ˆé‡è¦ï¼šå±€åŸŸç½‘å†…ESP32èƒ½è®¿é—®ï¼‰
    app.Urls.Add("http://0.0.0.0:5000");
    
    Console.WriteLine("SignalR Server: http://0.0.0.0:5000/chatHub");
    app.Run();
    

**å…³é”®ç‚¹è¯´æ˜**ï¼š

1.  **è¿æ¥ç¡®è®¤æœºåˆ¶**ï¼šæœåŠ¡å™¨åœ¨ `OnConnectedAsync` ä¸­å‘é€ `Notification` æ¶ˆæ¯ï¼ŒESP32æ”¶åˆ°æ­¤æ¶ˆæ¯æ‰è®¤ä¸ºè¿æ¥æˆåŠŸ
2.  **æ¶ˆæ¯å¹¿æ’­**ï¼šä½¿ç”¨ `Clients.All.SendAsync()` å‘æ‰€æœ‰è¿æ¥çš„å®¢æˆ·ç«¯å¹¿æ’­æ¶ˆæ¯
3.  **è¿æ¥è·Ÿè¸ª**ï¼šä½¿ç”¨é™æ€å­—å…¸ `_connectedDevices` è·Ÿè¸ªæ‰€æœ‰è¿æ¥çš„è®¾å¤‡ä¿¡æ¯

#### 5.1.2 æœåŠ¡ç«¯ï¼šè®¾å¤‡æ§åˆ¶APIï¼ˆé€šè¿‡SignalRæ¨é€æ¶ˆæ¯ï¼‰

ç¤ºä¾‹ä»“åº“æä¾›äº†å®Œæ•´çš„è®¾å¤‡æ§åˆ¶APIï¼Œæ¼”ç¤ºå¦‚ä½•é€šè¿‡SignalRå‘ESP32æ¨é€å„ç§ç±»å‹çš„æ¶ˆæ¯ï¼š

**Program.cs - è®¾å¤‡æ§åˆ¶APIç«¯ç‚¹**ï¼š

    // ============================================================================
    // è®¾å¤‡æ§åˆ¶ API - ç”¨äºå‘è®¾å¤‡å‘é€ CustomMessage
    // ============================================================================
    
    // è·å–æ‰€æœ‰è¿æ¥çš„è®¾å¤‡
    app.MapGet("/api/device/connections", () =>
    {
        return Results.Ok(ChatHub.ConnectedDevices);
    })
    .WithName("GetConnections")
    .WithDescription("è·å–æ‰€æœ‰è¿æ¥çš„è®¾å¤‡åˆ—è¡¨");
    
    // å‘é€é€šçŸ¥
    app.MapPost("/api/device/notification", async (
        NotificationRequest request, 
        IHubContext<ChatHub> hubContext, 
        ILogger<Program> logger) =>
    {
        var message = new
        {
            action = "notification",
            title = request.Title ?? "é€šçŸ¥",
            content = request.Content ?? "",
            emotion = request.Emotion ?? "bell",
            sound = request.Sound ?? "popup"
        };
    
        await SendCustomMessage(hubContext, logger, request.ConnectionId, message);
        return Results.Ok(new { success = true, message = "Notification sent" });
    })
    .WithDescription("å‘é€é€šçŸ¥åˆ°è®¾å¤‡ (sound: popup/success/vibration/exclamation/low_battery/none)");
    
    // å‘é€å›¾ç‰‡
    app.MapPost("/api/device/image", async (
        ImageRequest request, 
        IHubContext<ChatHub> hubContext, 
        ILogger<Program> logger) =>
    {
        var message = new
        {
            action = "image",
            url = request.Url
        };
    
        await SendCustomMessage(hubContext, logger, request.ConnectionId, message);
        return Results.Ok(new { success = true, message = "Image sent" });
    })
    .WithDescription("å‘é€å›¾ç‰‡URLåˆ°è®¾å¤‡æ˜¾ç¤º (æ”¯æŒJPG/PNG, æœ€å¤§1MB)");
    
    // å‘é€éŸ³é¢‘
    app.MapPost("/api/device/audio", async (
        AudioRequest request, 
        IHubContext<ChatHub> hubContext, 
        ILogger<Program> logger) =>
    {
        var message = new
        {
            action = "audio",
            url = request.Url
        };
    
        await SendCustomMessage(hubContext, logger, request.ConnectionId, message);
        return Results.Ok(new { success = true, message = "Audio sent" });
    })
    .WithDescription("å‘é€éŸ³é¢‘URLåˆ°è®¾å¤‡æ’­æ”¾ (OGGæ ¼å¼, æœ€å¤§512KB)");
    
    // å‘é€å‘½ä»¤
    app.MapPost("/api/device/command", async (
        CommandRequest request, 
        IHubContext<ChatHub> hubContext, 
        ILogger<Program> logger) =>
    {
        var message = new
        {
            action = "command",
            command = request.Command
        };
    
        await SendCustomMessage(hubContext, logger, request.ConnectionId, message);
        return Results.Ok(new { success = true, message = "Command sent" });
    })
    .WithDescription("å‘é€å‘½ä»¤åˆ°è®¾å¤‡ (command: reboot/wake/listen/stop)");
    
    // æ˜¾ç¤ºäºŒç»´ç 
    app.MapPost("/api/device/qrcode", async (
        QRCodeRequest request, 
        IHubContext<ChatHub> hubContext, 
        ILogger<Program> logger) =>
    {
        var message = new
        {
            action = "qrcode",
            content = request.Content,
            title = request.Title ?? "æ‰«ç "
        };
    
        await SendCustomMessage(hubContext, logger, request.ConnectionId, message);
        return Results.Ok(new { success = true, message = "QRCode sent" });
    })
    .WithDescription("æ˜¾ç¤ºäºŒç»´ç åˆ°è®¾å¤‡å±å¹•");
    
    // è¾…åŠ©æ–¹æ³•ï¼šå‘é€ CustomMessage
    async Task SendCustomMessage(
        IHubContext<ChatHub> hubContext, 
        ILogger<Program> logger, 
        string? connectionId, 
        object message)
    {
        var json = JsonSerializer.Serialize(message);
        logger.LogInformation("ğŸ“¤ Sending CustomMessage to {Target}: {Message}", 
            string.IsNullOrEmpty(connectionId) ? "ALL" : connectionId, json);
    
        if (string.IsNullOrEmpty(connectionId))
        {
            // å‘é€ç»™æ‰€æœ‰è¿æ¥çš„è®¾å¤‡
            await hubContext.Clients.All.SendAsync("CustomMessage", json);
        }
        else
        {
            // å‘é€ç»™æŒ‡å®šè¿æ¥
            await hubContext.Clients.Client(connectionId).SendAsync("CustomMessage", json);
        }
    }
    
    // ============================================================================
    // è¯·æ±‚æ¨¡å‹
    // ============================================================================
    
    record NotificationRequest
    {
        public string? ConnectionId { get; init; }
        public string? Title { get; init; }
        public string Content { get; init; } = "";
        public string? Emotion { get; init; }
        public string? Sound { get; init; }
    }
    
    record ImageRequest
    {
        public string? ConnectionId { get; init; }
        public string Url { get; init; } = "";
    }
    
    record AudioRequest
    {
        public string? ConnectionId { get; init; }
        public string Url { get; init; } = "";
    }
    
    record CommandRequest
    {
        public string? ConnectionId { get; init; }
        public string Command { get; init; } = "";
    }
    
    record QRCodeRequest
    {
        public string? ConnectionId { get; init; }
        public string Content { get; init; } = "";
        public string? Title { get; init; }
    }
    

**å…³é”®ç‚¹è¯´æ˜**ï¼š

1.  **IHubContextæ³¨å…¥**ï¼šä½¿ç”¨ `IHubContext<ChatHub>` åœ¨éHubç±»ä¸­å‘é€SignalRæ¶ˆæ¯
2.  **æ¶ˆæ¯æ ¼å¼**ï¼šä½¿ç”¨JSONæ ¼å¼çš„ `CustomMessage` äº‹ä»¶ï¼ŒåŒ…å« `action` å­—æ®µæ ‡è¯†æ¶ˆæ¯ç±»å‹
3.  **å®šå‘æ¨é€**ï¼š
    *   `Clients.All.SendAsync()` - å¹¿æ’­ç»™æ‰€æœ‰è¿æ¥çš„è®¾å¤‡
    *   `Clients.Client(connectionId).SendAsync()` - å‘é€ç»™æŒ‡å®šè®¾å¤‡
    *   `Clients.Group(groupName).SendAsync()` - å‘é€ç»™ç¾¤ç»„ï¼ˆå¦‚ `Users:{userId}`ï¼‰
4.  **RESTful APIè®¾è®¡**ï¼šæä¾›HTTPç«¯ç‚¹æ§åˆ¶è®¾å¤‡ï¼Œä¾¿äºå…¶ä»–æœåŠ¡è°ƒç”¨

æœåŠ¡ç«¯çš„æ¥å£å›¾ç‰‡å¦‚ä¸‹å¯ä»¥ç›´æ¥æ“ä½œæµ‹è¯•ï¼š

![img](https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201134534230-1496642342.png)

#### 5.1.3 å®¢æˆ·ç«¯ï¼ˆESP32ï¼‰ï¼šè¿æ¥SignalRå¹¶æ¥æ”¶æ¶ˆæ¯

è¿™æ˜¯ESP32ç«¯çš„æ ¸å¿ƒä»£ç ï¼Œæ¼”ç¤ºå¦‚ä½•è¿æ¥SignalR Hubå¹¶æ¥æ”¶å„ç§ç±»å‹çš„æ¶ˆæ¯ï¼š

**main.cpp - SignalRè¿æ¥ä¸æ¶ˆæ¯å¤„ç†**ï¼š

    #include <stdio.h>
    #include <memory>
    #include "freertos/FreeRTOS.h"
    #include "freertos/task.h"
    #include "esp_system.h"
    #include "esp_log.h"
    #include "nvs_flash.h"
    
    #include "hub_connection_builder.h"
    #include "esp32_websocket_client.h"
    #include "esp32_http_client.h"
    
    // =============================================================================
    // é…ç½®é¡¹ï¼ˆé€šè¿‡menuconfigè®¾ç½®ï¼‰
    // =============================================================================
    
    #define WIFI_SSID      CONFIG_EXAMPLE_WIFI_SSID
    #define WIFI_PASSWORD  CONFIG_EXAMPLE_WIFI_PASSWORD
    #define SIGNALR_HUB_URL CONFIG_EXAMPLE_SIGNALR_HUB_URL
    
    static const char* TAG = "SIGNALR_EXAMPLE";
    
    // SignalRè¿æ¥å¯¹è±¡
    static std::unique_ptr<signalr::hub_connection> g_connection;
    static bool g_is_connected = false;
    
    // =============================================================================
    // æ¶ˆæ¯å¤„ç†å™¨
    // =============================================================================
    
    /**
     * å¤„ç†æœåŠ¡å™¨å‘é€çš„æ¶ˆæ¯
     */
    static void on_receive_message(const std::vector<signalr::value>& args)
    {
        ESP_LOGI(TAG, "==============================================");
        ESP_LOGI(TAG, "ğŸ“© Message received from server:");
        
        if (args.size() >= 2) {
            std::string user = args[0].as_string();
            std::string message = args[1].as_string();
            
            ESP_LOGI(TAG, "   From: %s", user.c_str());
            ESP_LOGI(TAG, "   Text: %s", message.c_str());
        } else if (args.size() == 1) {
            ESP_LOGI(TAG, "   Message: %s", args[0].as_string().c_str());
        }
        
        ESP_LOGI(TAG, "==============================================");
    }
    
    /**
     * å¤„ç†é€šçŸ¥æ¶ˆæ¯ï¼ˆè¿æ¥ç¡®è®¤ï¼‰
     */
    static void on_notification(const std::vector<signalr::value>& args)
    {
        if (args.empty()) return;
        
        std::string notification = args[0].as_string();
        ESP_LOGI(TAG, "ğŸ”” Notification: %s", notification.c_str());
        
        // é€šè¿‡Notificationæ¶ˆæ¯ç¡®è®¤è¿æ¥æˆåŠŸ
        if (!g_is_connected) {
            g_is_connected = true;
            ESP_LOGI(TAG, "==============================================");
            ESP_LOGI(TAG, "âœ“âœ“âœ“ Connected to SignalR Hub! âœ“âœ“âœ“");
            ESP_LOGI(TAG, "==============================================");
        }
    }
    
    /**
     * å¤„ç†ä¼ æ„Ÿå™¨æ•°æ®æ›´æ–°
     */
    static void on_sensor_update(const std::vector<signalr::value>& args)
    {
        if (args.size() < 2) return;
        
        std::string sensor_id = args[0].as_string();
        double value = args[1].as_double();
        
        ESP_LOGI(TAG, "ğŸ“Š Sensor Update: %s = %.2f", sensor_id.c_str(), value);
    }
    
    /**
     * å¤„ç†è®¾å¤‡çŠ¶æ€æ›´æ–°
     */
    static void on_device_status(const std::vector<signalr::value>& args)
    {
        if (args.size() < 3) return;
        
        std::string device_id = args[0].as_string();
        std::string status = args[1].as_string();
        int free_heap = static_cast<int>(args[2].as_double());
        
        ESP_LOGI(TAG, "ğŸ“± Device Status: %s - %s (Free Heap: %d bytes)", 
                 device_id.c_str(), status.c_str(), free_heap);
    }
    
    // =============================================================================
    // SignalRè¿æ¥ç®¡ç†
    // =============================================================================
    
    /**
     * åˆå§‹åŒ–SignalRè¿æ¥
     */
    static void init_signalr(void)
    {
        ESP_LOGI(TAG, "Initializing SignalR connection to: %s", SIGNALR_HUB_URL);
    
        try {
            // åˆ›å»ºhub_connectionï¼ˆä½¿ç”¨make_uniqueï¼‰
            g_connection = std::make_unique<signalr::hub_connection>(
                signalr::hub_connection_builder::create(SIGNALR_HUB_URL)
                    .with_websocket_factory([](const signalr::signalr_client_config& config) {
                        return std::make_shared<signalr::esp32_websocket_client>(config);
                    })
                    .with_http_client_factory([](const signalr::signalr_client_config& config) {
                        return std::make_shared<signalr::esp32_http_client>(config);
                    })
                    .with_automatic_reconnect()  // å¯ç”¨è‡ªåŠ¨é‡è¿
                    .skip_negotiation(true)      // è·³è¿‡åå•†ï¼Œç›´æ¥WebSocket
                    .build());
    
            ESP_LOGI(TAG, "âœ“ SignalR connection object created");
            
        } catch (const std::exception& e) {
            ESP_LOGE(TAG, "Failed to create SignalR connection: %s", e.what());
        }
    }
    
    /**
     * æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
     */
    static void setup_message_handlers(void)
    {
        if (!g_connection) {
            ESP_LOGE(TAG, "Connection not initialized");
            return;
        }
    
        // æ³¨å†Œ "ReceiveMessage" äº‹ä»¶
        g_connection->on("ReceiveMessage", on_receive_message);
        ESP_LOGI(TAG, "âœ“ Registered handler: ReceiveMessage");
    
        // æ³¨å†Œ "Notification" äº‹ä»¶ï¼ˆç”¨äºè¿æ¥ç¡®è®¤ï¼‰
        g_connection->on("Notification", on_notification);
        ESP_LOGI(TAG, "âœ“ Registered handler: Notification");
    
        // æ³¨å†Œ "UpdateSensorData" äº‹ä»¶
        g_connection->on("UpdateSensorData", on_sensor_update);
        ESP_LOGI(TAG, "âœ“ Registered handler: UpdateSensorData");
    
        // æ³¨å†Œ "DeviceStatusUpdate" äº‹ä»¶
        g_connection->on("DeviceStatusUpdate", on_device_status);
        ESP_LOGI(TAG, "âœ“ Registered handler: DeviceStatusUpdate");
    }
    
    /**
     * å¯åŠ¨SignalRè¿æ¥
     */
    static void start_signalr_connection(void)
    {
        if (!g_connection) {
            ESP_LOGE(TAG, "Connection not initialized");
            return;
        }
        
        ESP_LOGI(TAG, "Starting SignalR connection...");
    
        try {
            // å¯åŠ¨è¿æ¥ï¼ˆå¼‚æ­¥ï¼‰
            g_connection->start([](std::exception_ptr exception) {
                if (exception) {
                    ESP_LOGE(TAG, "Connection failed in callback");
                } else {
                    ESP_LOGI(TAG, "Connection started successfully");
                }
            });
            
            ESP_LOGI(TAG, "Waiting for Notification message to confirm connection...");
    
        } catch (const std::exception& e) {
            ESP_LOGE(TAG, "Exception starting connection: %s", e.what());
        }
    }
    
    // =============================================================================
    // æµ‹è¯•ä»»åŠ¡ï¼šå®šæœŸå‘é€æ¶ˆæ¯
    // =============================================================================
    
    static void signalr_test_task(void* param)
    {
        int message_count = 1;
        
        while (true) {
            // ç­‰å¾…10ç§’
            vTaskDelay(pdMS_TO_TICKS(10000));
            
            // æ£€æŸ¥è¿æ¥çŠ¶æ€
            if (!g_connection || !g_is_connected) {
                ESP_LOGW(TAG, "Not connected, skipping message send");
                continue;
            }
            
            // å‘é€æ¶ˆæ¯åˆ°æœåŠ¡å™¨
            std::string message = "Test message #" + std::to_string(message_count++) + " from ESP32";
            
            ESP_LOGI(TAG, "ğŸ“¤ Sending message...");
            ESP_LOGI(TAG, "   User: ESP32-Device");
            ESP_LOGI(TAG, "   Message: %s", message.c_str());
            
            try {
                std::vector<signalr::value> args;
                args.push_back(signalr::value("ESP32-Device"));
                args.push_back(signalr::value(message));
                
                // è°ƒç”¨æœåŠ¡å™¨çš„ SendMessage æ–¹æ³•
                g_connection->invoke("SendMessage", args, 
                    [](const signalr::value& result, std::exception_ptr exception) {
                        if (exception) {
                            ESP_LOGE(TAG, "âœ— Failed to send message");
                        } else {
                            ESP_LOGI(TAG, "âœ“ Message sent successfully!");
                        }
                    });
                    
            } catch (const std::exception& e) {
                ESP_LOGE(TAG, "Exception sending message: %s", e.what());
            }
        }
    }
    
    // =============================================================================
    // ä¸»ç¨‹åº
    // =============================================================================
    
    extern "C" void app_main(void)
    {
        ESP_LOGI(TAG, "========================================");
        ESP_LOGI(TAG, " ESP32 SignalR Client Test Example");
        ESP_LOGI(TAG, "========================================");
        
        // 1. åˆå§‹åŒ–WiFiï¼ˆçœç•¥WiFiè¿æ¥ä»£ç ï¼Œå‚è€ƒå®Œæ•´ç¤ºä¾‹ï¼‰
        // wifi_init_sta();
        
        // 2. åˆå§‹åŒ–SignalRè¿æ¥å¯¹è±¡
        ESP_LOGI(TAG, "Step 1: Initializing SignalR...");
        init_signalr();
        
        // 3. æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
        ESP_LOGI(TAG, "Step 2: Setting up message handlers...");
        setup_message_handlers();
        
        // 4. å¯åŠ¨è¿æ¥
        ESP_LOGI(TAG, "Step 3: Starting connection...");
        start_signalr_connection();
        
        // 5. åˆ›å»ºæµ‹è¯•ä»»åŠ¡ï¼ˆå®šæœŸå‘é€æ¶ˆæ¯ï¼‰
        ESP_LOGI(TAG, "Step 4: Creating test task...");
        xTaskCreate(signalr_test_task, "signalr_test", 8192, NULL, 5, NULL);
        
        ESP_LOGI(TAG, "Setup complete. Check logs for connection status.");
    }
    

**å…³é”®ç‚¹è¯´æ˜**ï¼š

1.  **è¿æ¥åˆ›å»º**ï¼šä½¿ç”¨ `hub_connection_builder` æ„å»ºè¿æ¥ï¼Œé…ç½®WebSocketå®¢æˆ·ç«¯å·¥å‚
2.  **è·³è¿‡åå•†**ï¼š`skip_negotiation(true)` ç›´æ¥ä½¿ç”¨WebSocketï¼Œæé«˜è¿æ¥é€Ÿåº¦
3.  **æ¶ˆæ¯å¤„ç†å™¨æ³¨å†Œ**ï¼šä½¿ç”¨ `connection->on("EventName", handler)` æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨
4.  **è¿æ¥ç¡®è®¤**ï¼šé€šè¿‡æ¥æ”¶ `Notification` æ¶ˆæ¯åˆ¤æ–­è¿æ¥æˆåŠŸï¼ˆæœåŠ¡å™¨åœ¨ `OnConnectedAsync` ä¸­å‘é€ï¼‰
5.  **è°ƒç”¨æœåŠ¡å™¨æ–¹æ³•**ï¼šä½¿ç”¨ `invoke()` è°ƒç”¨Hubæ–¹æ³•ï¼Œå¦‚ `SendMessage`

**å®Œæ•´è¿è¡Œæµç¨‹**ï¼š

    1. WiFiè¿æ¥æˆåŠŸ
       â†“
    2. åˆ›å»ºSignalRè¿æ¥å¯¹è±¡
       â†“
    3. æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨ï¼ˆReceiveMessageã€Notificationç­‰ï¼‰
       â†“
    4. è°ƒç”¨ connection->start() å¯åŠ¨è¿æ¥
       â†“
    5. ç­‰å¾…æœåŠ¡å™¨å‘é€ Notification æ¶ˆæ¯
       â†“
    6. æ”¶åˆ° Notificationï¼Œæ ‡è®°è¿æ¥æˆåŠŸ
       â†“
    7. å®šæœŸè°ƒç”¨ invoke("SendMessage") å‘é€æ¶ˆæ¯
       â†“
    8. æ¥æ”¶æœåŠ¡å™¨å¹¿æ’­çš„æ¶ˆæ¯ï¼Œè§¦å‘å¯¹åº”å¤„ç†å™¨
    

**ç¤ºä¾‹è¾“å‡º**ï¼š

    I (3480) SIGNALR_EXAMPLE: âœ“ Registered handler: ReceiveMessage
    I (3485) SIGNALR_EXAMPLE: âœ“ Registered handler: Notification
    I (3490) SIGNALR_EXAMPLE: Starting SignalR connection...
    I (4520) SIGNALR_EXAMPLE: ==============================================
    I (4520) SIGNALR_EXAMPLE: âœ“âœ“âœ“ Connected to SignalR Hub! âœ“âœ“âœ“
    I (4525) SIGNALR_EXAMPLE: ==============================================
    I (4530) SIGNALR_EXAMPLE: ğŸ”” Notification: Welcome to SignalR!
    I (14530) SIGNALR_EXAMPLE: ğŸ“¤ Sending message...
    I (14640) SIGNALR_EXAMPLE: âœ“ Message sent successfully!
    I (14650) SIGNALR_EXAMPLE: ğŸ“© Message received from server:
    I (14655) SIGNALR_EXAMPLE:    From: ESP32-Device
    I (14660) SIGNALR_EXAMPLE:    Text: Test message #1 from ESP32
    

### 5.2 å®é™…æ•´åˆä»£ç ï¼ˆç”Ÿäº§ç¯å¢ƒå®Œæ•´å®ç°ï¼‰

> **è¯´æ˜**ï¼šä»¥ä¸‹ä»£ç æ¥è‡ªå°æ™ºAIé¡¹ç›®çš„å®é™…ç”Ÿäº§ä»£ç ï¼ŒåŒ…å«äº†å®Œæ•´çš„é”™è¯¯å¤„ç†ã€çŠ¶æ€ç®¡ç†ã€JWTè®¤è¯å’Œè‡ªåŠ¨é‡è¿æœºåˆ¶ã€‚

å®é™…é¡¹ç›®ä»£ç åˆ†ä¸ºä¸‰ä¸ªä¸»è¦ä»“åº“ï¼š

#### 5.2.1 å°æ™ºESP32è®¾å¤‡ä»£ç 

**ä»“åº“åœ°å€**ï¼š

*   ä¸»ä»“åº“ï¼š[https://github.com/maker-community/xiaozhi-esp32](https://github.com/maker-community/xiaozhi-esp32)
*   SignalRé›†æˆåˆ†æ”¯ï¼š`signalr` å’Œ `signalr-update-audio`
*   å®Œæ•´ç¤ºä¾‹å·¥ç¨‹ï¼š[esp-signalr-example](https://github.com/maker-community/esp-signalr-example)

> **æ³¨æ„**ï¼šSignalRåŠŸèƒ½ä¸»è¦åœ¨ `signalr` å’Œ `signalr-update-audio` ä¸¤ä¸ªåˆ†æ”¯ä¸­å®ç°ï¼Œè¿™ä¸¤ä¸ªåˆ†æ”¯éƒ½æ˜¯SignalRé›†æˆç›¸å…³çš„å¼€å‘åˆ†æ”¯ã€‚

**æ ¸å¿ƒæ–‡ä»¶**ï¼š

*   `main/signalr_client.cc` / `main/signalr_client.h` - **SignalRå®¢æˆ·ç«¯æ ¸å¿ƒå®ç°**
*   `main/application.cc` / `main/application.h` - ä¸»åº”ç”¨ç¨‹åºé€»è¾‘å’ŒçŠ¶æ€ç®¡ç†
*   `main/protocols/websocket_protocol.cc` - WebSocketåè®®å®ç°
*   `main/protocols/mqtt_protocol.cc` - MQTTåè®®å®ç°
*   `main/mcp_server.cc` - MCPæœåŠ¡å™¨å®ç°

**å®é™…å®ç°ç‰¹ç‚¹**ï¼š

ä¸ç¤ºä¾‹ä»£ç ç›¸æ¯”,ç”Ÿäº§ç¯å¢ƒå®ç°å¢åŠ äº†ï¼š

1.  **å®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†**
    
    *   è¿æ¥å»ºç«‹ã€æ–­å¼€é‡è¿ã€èµ„æºæ¸…ç†
    *   è®¾å¤‡çŠ¶æ€æœºç®¡ç†ï¼ˆç©ºé—²ã€è¿æ¥ä¸­ã€ç›‘å¬ã€è¯´è¯ç­‰ï¼‰
2.  **åè®®ç‰ˆæœ¬æ”¯æŒ**
    
    *   æ”¯æŒWebSocketå’ŒMQTTä¸¤ç§ä¼ è¾“åè®®
    *   åè®®å±‚æŠ½è±¡,æ˜“äºæ‰©å±•æ–°åè®®
3.  **éŸ³é¢‘æµå¤„ç†**
    
    *   å®æ—¶éŸ³é¢‘æ•°æ®çš„ç¼–ç ã€ä¼ è¾“å’Œæ¥æ”¶
    *   **éŸ³é¢‘åˆ†å—ä¼ è¾“**ï¼ˆé‡è¦ï¼ï¼‰- è§£å†³å¤§æ•°æ®ä¼ è¾“å¯¼è‡´è¿æ¥æ–­å¼€çš„é—®é¢˜
    *   æ”¯æŒOpusç¼–è§£ç 
4.  **MCPå·¥å…·é›†æˆ**
    
    *   å®Œæ•´çš„MCP Serverå®ç°
    *   å·¥å…·æ³¨å†Œã€è°ƒç”¨å’Œå“åº”æœºåˆ¶
    *   æ”¯æŒå¼‚æ­¥å·¥å…·æ‰§è¡Œ
5.  **SignalRå®¢æˆ·ç«¯å°è£…**
    
    *   å®Œæ•´çš„è¿æ¥ç”Ÿå‘½å‘¨æœŸç®¡ç†
    *   JWT Tokenè®¤è¯
    *   è‡ªåŠ¨é‡è¿æœºåˆ¶ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
    *   è®¾å¤‡æ³¨å†Œå’Œå¿ƒè·³ä¿æŒ
    *   è‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†

##### SignalRå®¢æˆ·ç«¯æ ¸å¿ƒå®ç° (signalr\_client.cc)

è¿™æ˜¯æ•´ä¸ªSignalRé›†æˆçš„æ ¸å¿ƒä»£ç ï¼Œå°è£…äº†æ‰€æœ‰ä¸SignalRé€šä¿¡ç›¸å…³çš„é€»è¾‘ã€‚

**å®Œæ•´ä»£ç **ï¼š[signalr\_client.cc](https://github.com/maker-community/xiaozhi-esp32/blob/signalr-update-audio/main/signalr_client.cc) ï¼ˆ850è¡Œï¼‰

**å…³é”®å®ç°è¦ç‚¹**ï¼š

**1\. å•ä¾‹æ¨¡å¼ç®¡ç†** - å…¨å±€å”¯ä¸€å®ä¾‹

    SignalRClient& SignalRClient::GetInstance() {
        static SignalRClient instance;
        return instance;
    }
    

**2\. JWT Tokenè®¤è¯** - é€šè¿‡Query Stringä¼ é€’

    bool SignalRClient::Initialize(const std::string& hub_url, const std::string& token) {
        // ğŸ” Build URL with token as query parameter (ASP.NET Core SignalR standard method)
        std::string final_hub_url = hub_url;
        if (!token.empty()) {
            ESP_LOGI(TAG, "========== SignalR Token Authentication ==========");
            
            // Remove "Bearer " prefix if present
            std::string token_value = token;
            if (token_value.find("Bearer ") == 0) {
                token_value = token_value.substr(7);
            }
            
            // Append token to URL
            final_hub_url += "?access_token=" + token_value;
        }
        
        // Create hub connection builder
        auto builder = signalr::hub_connection_builder::create(final_hub_url);
        
        // Set WebSocket factory (ä½¿ç”¨ESP32çš„WebSocketå®ç°)
        builder.with_websocket_factory([](const signalr::signalr_client_config& config) {
            auto client = std::make_shared<signalr::esp32_websocket_client>(config);
            return client;
        });
        
        // Skip negotiation (direct WebSocket connection)
        builder.skip_negotiation(true);
        
        // Build connection
        connection_ = std::make_unique<signalr::hub_connection>(builder.build());
    }
    

**3\. è¶…æ—¶å’Œå¿ƒè·³é…ç½®**

    signalr::signalr_client_config cfg;
    cfg.set_server_timeout(std::chrono::seconds(60));     // server expects 60s idle
    cfg.set_keepalive_interval(std::chrono::seconds(15)); // send ping every 15s
    cfg.set_handshake_timeout(std::chrono::seconds(5));   // short handshake timeout
    
    // IMPORTANT: Disable library's auto-reconnect! It has race condition bugs
    cfg.enable_auto_reconnect(false);
    connection_->set_client_config(cfg);
    

**4\. è¿æ¥ç¡®è®¤å’Œè‡ªåŠ¨æ³¨å†Œ**

    // Register Notification handler to confirm connection
    connection_->on("Notification", [this](const std::vector<signalr::value>& args) {
        if (args.empty()) return;
        
        std::string message = args[0].as_string();
        ESP_LOGI(TAG, "ğŸ”” Notification from server: %s", message.c_str());
        
        if (!connection_confirmed_) {
            connection_confirmed_ = true;
            ESP_LOGI(TAG, "âœ“âœ“âœ“ SIGNALR CONNECTION CONFIRMED BY SERVER! âœ“âœ“âœ“");
            
            // ğŸ”„ Auto-register device info after connection confirmed
            std::string mac_address = DeviceInfo::GetMacAddress();
            std::string metadata = DeviceInfo::BuildMetadataJson();
            
            RegisterDevice(mac_address, "", metadata, [](bool success, const std::string& result) {
                if (success) {
                    ESP_LOGI(TAG, "âœ… Device auto-registration successful");
                }
            });
        }
    });
    

**5\. è‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†**

    connection_->on("CustomMessage", [this](const std::vector<signalr::value>& args) {
        if (args.empty()) return;
        
        try {
            std::string json_str = args[0].as_string();
            ESP_LOGI(TAG, "ğŸ“¨ Received CustomMessage: %s", json_str.c_str());
            
            auto root = cJSON_Parse(json_str.c_str());
            if (root) {
                if (on_custom_message_) {
                    on_custom_message_(root);  // è°ƒç”¨ç”¨æˆ·è®¾ç½®çš„å›è°ƒ
                }
                cJSON_Delete(root);
            }
        } catch (const std::exception& e) {
            ESP_LOGE(TAG, "Exception handling CustomMessage: %s", e.what());
        }
    });
    

**6\. è‡ªåŠ¨é‡è¿æœºåˆ¶** - ä½¿ç”¨PSRAMæ ˆçš„åå°ä»»åŠ¡

    void SignalRClient::StartReconnectTask() {
        ESP_LOGI(TAG, "Starting SignalR reconnect background task (PSRAM stack)...");
        reconnect_task_running_.store(true, std::memory_order_release);
        
        // Allocate task stack from PSRAM (reusable)
        reconnect_task_stack_ = (StackType_t*)heap_caps_malloc(
            RECONNECT_TASK_STACK_SIZE, MALLOC_CAP_SPIRAM);
        
        // Create task with static allocation (stack in PSRAM)
        reconnect_task_handle_ = xTaskCreateStatic(
            ReconnectTaskEntry, "signalr_reconn",
            RECONNECT_TASK_STACK_SIZE / sizeof(StackType_t),
            this, 2, reconnect_task_stack_, reconnect_task_buffer_
        );
    }
    
    void SignalRClient::ReconnectTaskLoop() {
        while (reconnect_task_running_.load(std::memory_order_acquire)) {
            vTaskDelay(pdMS_TO_TICKS(1000));
            
            if (!reconnect_requested_.load() || IsConnected()) {
                continue;
            }
            
            // Apply exponential backoff
            ESP_LOGI(TAG, "Attempting connection (backoff=%dms)...", reconnect_backoff_ms_);
            
            if (Connect() && IsConnected()) {
                reconnect_backoff_ms_ = 1000;  // Reset backoff on success
            } else {
                vTaskDelay(pdMS_TO_TICKS(reconnect_backoff_ms_));
                reconnect_backoff_ms_ = std::min(reconnect_backoff_ms_ * 2, 
                    MAX_RECONNECT_BACKOFF_MS);  // Exponential backoff
            }
        }
    }
    

**7\. è®¾å¤‡æ³¨å†Œå’Œå¿ƒè·³**

    void SignalRClient::RegisterDevice(
        const std::string& mac_address,
        const std::string& device_token,
        const std::string& metadata,
        std::function<void(bool, const std::string&)> callback) {
        
        if (!IsConnected()) {
            if (callback) callback(false, "Not connected");
            return;
        }
        
        std::vector<signalr::value> args;
        args.push_back(signalr::value(mac_address));
        args.push_back(signalr::value(device_token));
        args.push_back(signalr::value(metadata));
        
        connection_->invoke("RegisterDevice", args,
            [callback](const signalr::value& result, std::exception_ptr ex) {
                if (ex) {
                    if (callback) callback(false, "Registration failed");
                } else {
                    if (callback) callback(true, "Registration sent");
                }
            });
    }
    
    void SignalRClient::SendHeartbeat(
        std::function<void(bool, const std::string&)> callback) {
        
        if (!IsConnected()) {
            if (callback) callback(false, "Not connected");
            return;
        }
        
        std::vector<signalr::value> args;
        connection_->invoke("Heartbeat", args,
            [callback](const signalr::value& result, std::exception_ptr ex) {
                if (!ex) {
                    ESP_LOGD(TAG, "ğŸ’“ Heartbeat sent");
                    if (callback) callback(true, "Success");
                }
            });
    }
    

**SignalRå®¢æˆ·ç«¯ç±»å®šä¹‰** (signalr\_client.h):

    class SignalRClient {
    public:
        static SignalRClient& GetInstance();
        
        // è¿æ¥ç®¡ç†
        bool Initialize(const std::string& hub_url, const std::string& token);
        bool Connect();
        void Disconnect();
        void Reset();
        void RequestReconnect();
        
        // çŠ¶æ€æŸ¥è¯¢
        bool IsInitialized() const;
        bool IsConnecting() const;
        bool IsConnected() const;
        std::string GetConnectionState() const;
        
        // å›è°ƒè®¾ç½®
        void OnCustomMessage(std::function<void(const cJSON*)> callback);
        void OnDeviceRegistered(std::function<void(const cJSON*)> callback);
        
        // Hubæ–¹æ³•è°ƒç”¨
        void RegisterDevice(const std::string& mac_address,
                           const std::string& device_token,
                           const std::string& metadata,
                           std::function<void(bool, const std::string&)> callback);
        void SendHeartbeat(std::function<void(bool, const std::string&)> callback);
        void InvokeHubMethod(const std::string& method_name,
                            const std::string& args_json,
                            std::function<void(bool, const std::string&)> callback);
    
    private:
        SignalRClient();
        ~SignalRClient();
        
        std::unique_ptr<signalr::hub_connection> connection_;
        std::string hub_url_;
        std::string token_;
        bool initialized_ = false;
        bool connection_confirmed_ = false;
        std::atomic<bool> reconnect_requested_{false};
        
        // å›è°ƒå‡½æ•°
        std::function<void(const cJSON*)> on_custom_message_;
        std::function<void(const cJSON*)> on_device_registered_;
        
        // é‡è¿ä»»åŠ¡
        TaskHandle_t reconnect_task_handle_ = nullptr;
        int reconnect_backoff_ms_ = 1000;
    };
    

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

    // åœ¨ä¸»åº”ç”¨ä¸­ä½¿ç”¨SignalRå®¢æˆ·ç«¯
    void Application::InitializeSignalR() {
        auto& client = SignalRClient::GetInstance();
        
        // è®¾ç½®æ¶ˆæ¯å›è°ƒ
        client.OnCustomMessage([this](const cJSON* json) {
            ESP_LOGI(TAG, "Received message from server");
            HandleServerMessage(json);
        });
        
        // åˆå§‹åŒ–å¹¶è¿æ¥
        std::string hub_url = "wss://your-server.com/devicehub";
        std::string token = GetJwtToken();  // ä»NVSè¯»å–æˆ–æ‰«ç è·å–
        
        if (client.Initialize(hub_url, token)) {
            if (client.Connect()) {
                client.RequestReconnect();  // å¯åŠ¨è‡ªåŠ¨é‡è¿ä»»åŠ¡
            }
        }
    }
    

##### Applicationå±‚é›†æˆä»£ç 

**æ ¸å¿ƒä»£ç ç‰‡æ®µ** (application.cc):

    
    void Application::HandleSignalRMessage(const std::string& message) {
        ESP_LOGI(TAG, "Handling SignalR message: %s", message.c_str());
        
        auto root = cJSON_Parse(message.c_str());
        if (!root) {
            ESP_LOGE(TAG, "Failed to parse SignalR message JSON");
            return;
        }
        
        auto display = Board::GetInstance().GetDisplay();
        
        // Check message action/type
        auto action = cJSON_GetObjectItem(root, "action");
        if (cJSON_IsString(action)) {
            if (strcmp(action->valuestring, "notification") == 0) {
                // Handle notification
                // JSON: {"action":"notification", "title":"æ ‡é¢˜", "content":"å†…å®¹", "emotion":"bell", "sound":"popup"}
                auto title = cJSON_GetObjectItem(root, "title");
                auto content = cJSON_GetObjectItem(root, "content");
                auto emotion = cJSON_GetObjectItem(root, "emotion");
                auto sound = cJSON_GetObjectItem(root, "sound");
                
                const char* title_str = cJSON_IsString(title) ? title->valuestring : Lang::Strings::INFO;
                const char* content_str = cJSON_IsString(content) ? content->valuestring : "";
                const char* emotion_str = cJSON_IsString(emotion) ? emotion->valuestring : "bell";
                
                // Select sound based on "sound" field
                std::string_view sound_view = Lang::Sounds::OGG_POPUP;
                if (cJSON_IsString(sound)) {
                    if (strcmp(sound->valuestring, "success") == 0) {
                        sound_view = Lang::Sounds::OGG_SUCCESS;
                    } else if (strcmp(sound->valuestring, "vibration") == 0) {
                        sound_view = Lang::Sounds::OGG_VIBRATION;
                    } else if (strcmp(sound->valuestring, "exclamation") == 0) {
                        sound_view = Lang::Sounds::OGG_EXCLAMATION;
                    } else if (strcmp(sound->valuestring, "low_battery") == 0) {
                        sound_view = Lang::Sounds::OGG_LOW_BATTERY;
                    } else if (strcmp(sound->valuestring, "none") == 0) {
                        sound_view = "";
                    }
                    // default: popup
                }
                
                Alert(title_str, content_str, emotion_str, sound_view);
                
            } else if (strcmp(action->valuestring, "command") == 0) {
                // Handle command
                // JSON: {"action":"command", "command":"reboot|wake|listen|stop"}
                auto cmd = cJSON_GetObjectItem(root, "command");
                if (cJSON_IsString(cmd)) {
                    if (strcmp(cmd->valuestring, "reboot") == 0) {
                        Reboot();
                    } else if (strcmp(cmd->valuestring, "wake") == 0) {
                        // Trigger wake word detection
                        xEventGroupSetBits(event_group_, MAIN_EVENT_WAKE_WORD_DETECTED);
                    } else if (strcmp(cmd->valuestring, "listen") == 0) {
                        StartListening();
                    } else if (strcmp(cmd->valuestring, "stop") == 0) {
                        StopListening();
                    } else {
                        ESP_LOGW(TAG, "Unknown SignalR command: %s", cmd->valuestring);
                    }
                }
                
            } else if (strcmp(action->valuestring, "display") == 0) {
                // Display custom content
                // JSON: {"action":"display", "content":"æ–‡æœ¬å†…å®¹", "role":"system"}
                auto content = cJSON_GetObjectItem(root, "content");
                auto role = cJSON_GetObjectItem(root, "role");
                const char* role_str = cJSON_IsString(role) ? role->valuestring : "system";
                if (cJSON_IsString(content)) {
                    display->SetChatMessage(role_str, content->valuestring);
                }
                
            } else if (strcmp(action->valuestring, "emotion") == 0) {
                // Change emotion/expression
                // JSON: {"action":"emotion", "emotion":"happy"}
                auto emotion = cJSON_GetObjectItem(root, "emotion");
                if (cJSON_IsString(emotion)) {
                    display->SetEmotion(emotion->valuestring);
                }
                
            } else if (strcmp(action->valuestring, "image") == 0) {
                // Display image from URL
                // JSON: {"action":"image", "url":"https://example.com/image.jpg"}
                auto url = cJSON_GetObjectItem(root, "url");
                if (cJSON_IsString(url)) {
                    HandleSignalRImageMessage(url->valuestring);
                } else {
                    ESP_LOGW(TAG, "Image action requires 'url' field");
                }
                
            } else if (strcmp(action->valuestring, "audio") == 0) {
                // Play audio from URL (OGG format)
                // JSON: {"action":"audio", "url":"https://example.com/sound.ogg"}
                auto url = cJSON_GetObjectItem(root, "url");
                if (cJSON_IsString(url)) {
                    HandleSignalRAudioMessage(url->valuestring);
                } else {
                    ESP_LOGW(TAG, "Audio action requires 'url' field");
                }
                
            } else if (strcmp(action->valuestring, "qrcode") == 0) {
                // Show QR code
                // JSON: {"action":"qrcode", "data":"https://...", "title":"æ ‡é¢˜", "subtitle":"å‰¯æ ‡é¢˜"}
                auto data = cJSON_GetObjectItem(root, "data");
                auto title = cJSON_GetObjectItem(root, "title");
                auto subtitle = cJSON_GetObjectItem(root, "subtitle");
                if (cJSON_IsString(data)) {
                    const char* title_str = cJSON_IsString(title) ? title->valuestring : nullptr;
                    const char* subtitle_str = cJSON_IsString(subtitle) ? subtitle->valuestring : nullptr;
                    display->ShowQRCode(data->valuestring, title_str, subtitle_str);
                } else {
                    ESP_LOGW(TAG, "QRCode action requires 'data' field");
                }
                
            } else if (strcmp(action->valuestring, "hide_qrcode") == 0) {
                // Hide QR code
                // JSON: {"action":"hide_qrcode"}
                display->HideQRCode();
                
            } else {
                // Default: display as system message
                char* display_str = cJSON_Print(root);
                if (display_str) {
                    display->SetChatMessage("system", display_str);
                    cJSON_free(display_str);
                }
            }
        } else {
            // No action specified, display raw message
            char* display_str = cJSON_Print(root);
            if (display_str) {
                display->SetChatMessage("system", display_str);
                cJSON_free(display_str);
            }
        }
        
        cJSON_Delete(root);
    }
    
    

**å®Œæ•´çš„Applicationç±»åŠŸèƒ½**ï¼š

*   âœ… è®¾å¤‡çŠ¶æ€ç®¡ç† (çŠ¶æ€æœº)
*   âœ… ç½‘ç»œäº‹ä»¶å¤„ç† (è¿æ¥/æ–­å¼€)
*   âœ… éŸ³é¢‘æœåŠ¡é›†æˆ (ç¼–è§£ç ã€æµå¤„ç†)
*   âœ… å”¤é†’è¯æ£€æµ‹
*   âœ… åè®®å±‚æŠ½è±¡ (WebSocket/MQTT)
*   âœ… MCPæ¶ˆæ¯è·¯ç”±
*   âœ… é”™è¯¯å¤„ç†å’Œæ¢å¤
*   âœ… èµ„æºç®¡ç†å’Œæ¸…ç†
*   âœ… çº¿ç¨‹å®‰å…¨çš„æ¶ˆæ¯è°ƒåº¦

#### 5.2.2 MCPæœåŠ¡å™¨ä»£ç  (verdure-mcp)

**ä»“åº“åœ°å€**ï¼š[verdure-mcp](https://github.com/maker-community/verdure-mcp)

**ç›®å½•ç»“æ„**ï¼š

    src/Verdure.Mcp.Server/
    â”œâ”€â”€ Hubs/
    â”‚   â””â”€â”€ DeviceHub.cs          # SignalR Hubå®ç°
    â”œâ”€â”€ Tools/
    â”‚   â”œâ”€â”€ MusicTool.cs          # éŸ³ä¹æ’­æ”¾æ§åˆ¶
    â”‚   â”œâ”€â”€ EmailTool.cs          # é‚®ä»¶å‘é€
    â”‚   â”œâ”€â”€ WeatherTool.cs        # å¤©æ°”æŸ¥è¯¢
    â”‚   â””â”€â”€ SmartHomeTool.cs      # æ™ºèƒ½å®¶å±…æ§åˆ¶
    â”œâ”€â”€ Services/
    â”‚   â”œâ”€â”€ DeviceService.cs      # è®¾å¤‡ç®¡ç†æœåŠ¡
    â”‚   â”œâ”€â”€ McpExecutor.cs        # MCPå·¥å…·æ‰§è¡Œå™¨
    â”‚   â””â”€â”€ TokenService.cs       # JWTä»¤ç‰ŒæœåŠ¡
    â””â”€â”€ Models/
        â”œâ”€â”€ DeviceConnection.cs   # è®¾å¤‡è¿æ¥è®°å½•
        â”œâ”€â”€ DeviceInfo.cs         # è®¾å¤‡ä¿¡æ¯
        â””â”€â”€ McpToolLog.cs         # å·¥å…·è°ƒç”¨æ—¥å¿—
    

**DeviceHubå®Œæ•´å®ç°** (Hubs/DeviceHub.cs):

ç”Ÿäº§ç¯å¢ƒçš„DeviceHubå®é™…å®ç°ç‰¹ç‚¹ï¼š

*   âœ… æ•°æ®åº“æŒä¹…åŒ– (Entity Framework Core + PostgreSQL)
*   âœ… è®¾å¤‡æ³¨å†Œå’ŒçŠ¶æ€è·Ÿè¸ª
*   âœ… ç”¨æˆ·å’Œè®¾å¤‡åˆ†ç»„ç®¡ç†
*   âœ… å¿ƒè·³æ£€æµ‹
*   âœ… åŒé‡è®¤è¯ (JWT + API Token)
*   âœ… å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—

    using Microsoft.AspNetCore.SignalR;
    using Verdure.Mcp.Infrastructure.Database;
    using Verdure.Mcp.Infrastructure.Services;
    
    namespace Verdure.Mcp.Server.Hubs;
    
    /// <summary>
    /// è®¾å¤‡è¿æ¥Hub - å¤„ç†ESP32ç­‰IoTè®¾å¤‡çš„SignalRè¿æ¥
    /// </summary>
    public class DeviceHub : Hub
    {
        private readonly McpDbContext _dbContext;
        private readonly ITokenValidationService _tokenValidationService;
        private readonly ILogger<DeviceHub> _logger;
    
        public DeviceHub(
            McpDbContext dbContext,
            ITokenValidationService tokenValidationService,
            ILogger<DeviceHub> logger)
        {
            _dbContext = dbContext;
            _tokenValidationService = tokenValidationService;
            _logger = logger;
        }
    
        /// <summary>
        /// è®¾å¤‡è¿æ¥ - æ”¯æŒJWTå’ŒAPI TokenåŒé‡è®¤è¯
        /// </summary>
        public override async Task OnConnectedAsync()
        {
            try
            {
                var httpContext = Context.GetHttpContext();
                if (httpContext == null)
                {
                    _logger.LogWarning("HttpContext is null");
                    Context.Abort();
                    return;
                }
    
                // ä»æŸ¥è¯¢å‚æ•°è·å–token
                var token = httpContext.Request.Query["access_token"].ToString();
                if (string.IsNullOrEmpty(token))
                {
                    _logger.LogWarning("Connection attempt without token");
                    Context.Abort();
                    return;
                }
    
                // éªŒè¯token - æ”¯æŒJWTå’ŒAPI Token
                var validationResult = await _tokenValidationService.ValidateTokenAsync(token);
                if (!validationResult.IsValid)
                {
                    _logger.LogWarning("Invalid token: {Reason}", validationResult.FailureReason);
                    Context.Abort();
                    return;
                }
    
                var userId = validationResult.UserId;
                if (string.IsNullOrEmpty(userId))
                {
                    _logger.LogWarning("Token valid but userId is missing");
                    Context.Abort();
                    return;
                }
    
                // å°†è¿æ¥åŠ å…¥ç”¨æˆ·ç»„ (æ ¼å¼: Users:{userId})
                await Groups.AddToGroupAsync(Context.ConnectionId, $"Users:{userId}");
    
                _logger.LogInformation(
                    "Device connected: ConnectionId={ConnectionId}, UserId={UserId}",
                    Context.ConnectionId, userId);
    
                // å‘é€æ¬¢è¿é€šçŸ¥
                await Clients.Caller.SendAsync("Notification", 
                    $"Welcome! Connected to Verdure MCP Server at {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss}");
    
                await base.OnConnectedAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in OnConnectedAsync");
                Context.Abort();
            }
        }
    
        /// <summary>
        /// è®¾å¤‡æ–­å¼€è¿æ¥
        /// </summary>
        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            if (exception != null)
            {
                _logger.LogWarning(exception, 
                    "Device disconnected with error: ConnectionId={ConnectionId}",
                    Context.ConnectionId);
            }
            else
            {
                _logger.LogInformation(
                    "Device disconnected normally: ConnectionId={ConnectionId}",
                    Context.ConnectionId);
            }
    
            await base.OnDisconnectedAsync(exception);
        }
    
        /// <summary>
        /// è®¾å¤‡æ³¨å†Œ - ä¿å­˜è®¾å¤‡MACåœ°å€å’Œå…ƒæ•°æ®
        /// </summary>
        public async Task RegisterDevice(string macAddress, string deviceToken, string metadata)
        {
            try
            {
                var userId = Context.Items["UserId"]?.ToString();
                if (string.IsNullOrEmpty(userId))
                {
                    _logger.LogWarning("RegisterDevice called without userId");
                    return;
                }
    
                _logger.LogInformation(
                    "Device registration: UserId={UserId}, MAC={MacAddress}, Metadata={Metadata}",
                    userId, macAddress, metadata);
    
                // å°†è®¾å¤‡åŠ å…¥è®¾å¤‡ç»„ (æ ¼å¼: Device:{macAddress})
                await Groups.AddToGroupAsync(Context.ConnectionId, $"Device:{macAddress}");
    
                // ä¿å­˜è®¾å¤‡ä¿¡æ¯åˆ°æ•°æ®åº“
                var existingDevice = await _dbContext.Devices
                    .FirstOrDefaultAsync(d => d.MacAddress == macAddress);
    
                if (existingDevice != null)
                {
                    existingDevice.LastSeenAt = DateTime.UtcNow;
                    existingDevice.Metadata = metadata;
                    existingDevice.IsOnline = true;
                }
                else
                {
                    _dbContext.Devices.Add(new Device
                    {
                        MacAddress = macAddress,
                        UserId = userId,
                        Metadata = metadata,
                        IsOnline = true,
                        CreatedAt = DateTime.UtcNow,
                        LastSeenAt = DateTime.UtcNow
                    });
                }
    
                await _dbContext.SaveChangesAsync();
    
                // ç¡®è®¤æ³¨å†ŒæˆåŠŸ
                await Clients.Caller.SendAsync("Notification", 
                    $"Device registered successfully: {macAddress}");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in RegisterDevice");
            }
        }
    
        /// <summary>
        /// å¿ƒè·³ä¿æŒ
        /// </summary>
        public async Task Heartbeat()
        {
            _logger.LogDebug("Heartbeat from ConnectionId={ConnectionId}", Context.ConnectionId);
            
            // æ›´æ–°æœ€åæ´»è·ƒæ—¶é—´
            // æ³¨æ„ï¼šå®é™…ä»£ç ä¸­å¯ä»¥æ ¹æ®ConnectionIdæŸ¥æ‰¾è®¾å¤‡å¹¶æ›´æ–°LastSeenAt
            await Task.CompletedTask;
        }
    }
    

**å®é™…çš„MCPå·¥å…·å®ç°** (ä¸ä½¿ç”¨åŸºç±»):

åœ¨verdure-mcpä¸­ï¼ŒMCPå·¥å…·**ä¸ç»§æ‰¿ä»»ä½•åŸºç±»**ï¼Œè€Œæ˜¯ï¼š

1.  ä½¿ç”¨ `[McpServerToolType]` ç‰¹æ€§æ ‡è®°
2.  é€šè¿‡ä¾èµ–æ³¨å…¥è·å– `IDevicePushService` æœåŠ¡
3.  ä½¿ç”¨ `IDevicePushService` çš„æ–¹æ³•æ¨é€æ¶ˆæ¯ç»™è®¾å¤‡

**DevicePushServiceæ¥å£** (Infrastructure/Services/DevicePushService.cs):

    namespace Verdure.Mcp.Infrastructure.Services;
    
    /// <summary>
    /// è®¾å¤‡æ¨é€æœåŠ¡æ¥å£
    /// </summary>
    public interface IDevicePushService
    {
        /// <summary>
        /// å‘ç”¨æˆ·çš„æ‰€æœ‰è®¾å¤‡å‘é€æ¶ˆæ¯
        /// </summary>
        Task SendToUserAsync(string userId, string method, object message, 
            CancellationToken cancellationToken = default);
    
        /// <summary>
        /// å‘æŒ‡å®šè®¾å¤‡å‘é€æ¶ˆæ¯
        /// </summary>
        Task SendToDeviceAsync(string deviceId, string method, object message, 
            CancellationToken cancellationToken = default);
    
        /// <summary>
        /// å‘é€è‡ªå®šä¹‰æ¶ˆæ¯ (xiaozhiåè®®æ ¼å¼)
        /// </summary>
        Task SendCustomMessageAsync(string userId, object message, 
            CancellationToken cancellationToken = default);
    
        /// <summary>
        /// å‘é€é€šçŸ¥æ¶ˆæ¯
        /// </summary>
        Task SendNotificationAsync(string userId, string notificationMessage, 
            CancellationToken cancellationToken = default);
    }
    

**DevicePushServiceå®ç°** (Server/Services/DevicePushServiceImpl.cs):

    using Microsoft.AspNetCore.SignalR;
    using Verdure.Mcp.Server.Hubs;
    using Verdure.Mcp.Infrastructure.Services;
    using System.Text.Json;
    
    namespace Verdure.Mcp.Server.Services;
    
    public class DevicePushServiceImpl : IDevicePushService
    {
        private readonly IHubContext<DeviceHub> _hubContext;
        private readonly ILogger<DevicePushServiceImpl> _logger;
    
        public DevicePushServiceImpl(
            IHubContext<DeviceHub> hubContext,
            ILogger<DevicePushServiceImpl> logger)
        {
            _hubContext = hubContext;
            _logger = logger;
        }
    
        public async Task SendToUserAsync(string userId, string method, object message, 
            CancellationToken cancellationToken = default)
        {
            var groupName = $"Users:{userId}";
            await _hubContext.Clients.Group(groupName)
                .SendAsync(method, message, cancellationToken);
            
            _logger.LogInformation("Sent {Method} to user {UserId}", method, userId);
        }
    
        public async Task SendToDeviceAsync(string deviceId, string method, object message, 
            CancellationToken cancellationToken = default)
        {
            var groupName = $"Device:{deviceId}";
            await _hubContext.Clients.Group(groupName)
                .SendAsync(method, message, cancellationToken);
            
            _logger.LogInformation("Sent {Method} to device {DeviceId}", method, deviceId);
        }
    
        public async Task SendCustomMessageAsync(string userId, object message, 
            CancellationToken cancellationToken = default)
        {
            var groupName = $"Users:{userId}";
            
            // é‡è¦ï¼ESP32å®¢æˆ·ç«¯æœŸæœ›æ¥æ”¶JSONå­—ç¬¦ä¸²ï¼Œè€Œä¸æ˜¯å¯¹è±¡
            var jsonString = JsonSerializer.Serialize(message);
            
            await _hubContext.Clients.Group(groupName)
                .SendAsync("CustomMessage", jsonString, cancellationToken);
            
            _logger.LogInformation("Sent CustomMessage to user {UserId}: {Message}", 
                userId, jsonString);
        }
    
        public async Task SendNotificationAsync(string userId, string notificationMessage, 
            CancellationToken cancellationToken = default)
        {
            var groupName = $"Users:{userId}";
            await _hubContext.Clients.Group(groupName)
                .SendAsync("Notification", notificationMessage, cancellationToken);
            
            _logger.LogInformation("Sent notification to user {UserId}: {Message}", 
                userId, notificationMessage);
        }
    }
    

**éŸ³ä¹æ’­æ”¾å·¥å…·å®é™…å®ç°** (Tools/MusicTool.cs):

    using System;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Hosting;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Microsoft.Extensions.Options;
    using Verdure.Mcp.Server.Settings;
    using ModelContextProtocol.Server;
    using Verdure.Mcp.Infrastructure.Services;
    using Verdure.Mcp.Server.Services;
    using Hangfire;
    
    namespace Verdure.Mcp.Server.Tools;
    
    /// <summary>
    /// MCP Tool to pick a random audio file from wwwroot and push its URL to device(s).
    /// </summary>
    [McpServerToolType]
    public class MusicTool
    {
        private readonly IHttpContextAccessor _httpContextAccessor;
        private readonly IWebHostEnvironment _env;
        private readonly IDevicePushService _devicePushService;
        private readonly ILogger<MusicTool> _logger;
        private readonly IBackgroundJobClient _backgroundJobClient;
        private readonly ImageStorageSettings _imageStorageSettings;
    
        public MusicTool(
            IHttpContextAccessor httpContextAccessor,
            IWebHostEnvironment env,
            IDevicePushService devicePushService,
            ILogger<MusicTool> logger,
            IBackgroundJobClient backgroundJobClient,
            IOptions<ImageStorageSettings>? imageSettings = null)
        {
            _httpContextAccessor = httpContextAccessor;
            _env = env;
            _devicePushService = devicePushService;
            _logger = logger;
            _backgroundJobClient = backgroundJobClient;
            _imageStorageSettings = imageSettings?.Value ?? new ImageStorageSettings();
        }
    
        /// <summary>
        /// Select a random audio file from the `wwwroot/audio` folder and push it to the user
        /// identified by the `X-User-Id` request header.
        /// The pushed message follows the same shape as used in `test-send-message.ps1` (action = "audio", url = "...").
        /// </summary>
        [McpServerTool(Name = "play_random_music")]
        [Description("Plays a random audio file from wwwroot/audio by pushing an audio message to the user's devices")]
        public async Task<MusicResponse> PlayRandomMusic(CancellationToken cancellationToken = default)
        {
            try
            {
                var httpContext = _httpContextAccessor.HttpContext;
                var effectiveUserId = httpContext?.Request.Headers["X-User-Id"].FirstOrDefault();
                if (string.IsNullOrEmpty(effectiveUserId))
                {
                    _logger.LogWarning("No userId provided and X-User-Id header is missing");
                    return new MusicResponse { Success = false, Message = "Missing userId or X-User-Id header" };
                }
    
                var webRoot = _env.WebRootPath ?? _env.ContentRootPath;
                var folder = "audios";
                var audioFolder = Path.Combine(webRoot, folder);
    
                if (!Directory.Exists(audioFolder))
                {
                    _logger.LogWarning("Audio folder does not exist: {AudioFolder}", audioFolder);
                    return new MusicResponse { Success = false, Message = $"Audio folder not found: {folder}" };
                }
    
                // Find audio files (ogg, mp3) and pick a random one
                var files = Directory.GetFiles(audioFolder)
                    .Where(f => f.EndsWith('.' + "ogg") || f.EndsWith('.' + "mp3") || f.EndsWith('.' + "wav"))
                    .ToArray();
    
                if (files.Length == 0)
                {
                    _logger.LogWarning("No audio files found in {AudioFolder}", audioFolder);
                    return new MusicResponse { Success = false, Message = "No audio files found" };
                }
    
                var rnd = new Random();
                var chosen = files[rnd.Next(files.Length)];
                var fileName = Path.GetFileName(chosen);
    
                string url;
                // Prefer configured ImageStorage BaseUrl (keeps image and audio base URL consistent)
                if (!string.IsNullOrWhiteSpace(_imageStorageSettings.BaseUrl))
                {
                    var cfgBase = _imageStorageSettings.BaseUrl.TrimEnd('/');
                    url = $"{cfgBase}/{folder}/{Uri.EscapeDataString(fileName)}";
                }
                else
                {
                    var req = httpContext?.Request;
                    var hostBase = req != null ? $"{req.Scheme}://{req.Host.Value}" : string.Empty;
                    url = string.IsNullOrEmpty(hostBase)
                        ? $"/{folder}/{Uri.EscapeDataString(fileName)}"
                        : $"{hostBase}/{folder}/{Uri.EscapeDataString(fileName)}";
                }
    
                var title = Path.GetFileNameWithoutExtension(fileName);
    
                var message = new
                {
                    action = "audio",
                    url,
                    title
                };
    
                // Schedule push as a delayed background job so device can play result first.
                try
                {
    
                    var jobDelay = TimeSpan.FromSeconds(5);
    
                    _logger.LogInformation("Scheduling audio push to user {UserId} after {Delay}s: {Url}",
                        effectiveUserId, jobDelay.TotalSeconds, url);
    
                    _backgroundJobClient.Schedule<MusicPushBackgroundJob>(
                        job => job.ExecuteAsync(effectiveUserId, url, title, CancellationToken.None),
                        jobDelay);
    
                    return new MusicResponse { Success = true, Message = "Audio scheduled", Url = url, FileName = fileName };
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to schedule audio push for user {UserId}", effectiveUserId);
                    return new MusicResponse { Success = false, Message = ex.Message };
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to play random music");
                return new MusicResponse { Success = false, Message = ex.Message };
            }
        }
    }
    
    public class MusicResponse
    {
        public bool Success { get; set; }
        public required string Message { get; set; }
        public string? Url { get; set; }
        public string? FileName { get; set; }
    }
    
    

**å»¶è¿Ÿæ¨é€åå°ä»»åŠ¡** (Tools/MusicPushBackgroundJob.cs):

    using Verdure.Mcp.Infrastructure.Services;
    using Verdure.Mcp.Server.Services;
    
    namespace Verdure.Mcp.Server.Tools;
    
    /// <summary>
    /// Background job to push music/audio messages to user devices after a delay.
    /// </summary>
    public class MusicPushBackgroundJob
    {
        private readonly IDevicePushService _devicePushService;
        private readonly ILogger<MusicPushBackgroundJob> _logger;
    
        public MusicPushBackgroundJob(IDevicePushService devicePushService, ILogger<MusicPushBackgroundJob> logger)
        {
            _devicePushService = devicePushService;
            _logger = logger;
        }
    
        public async Task ExecuteAsync(string userId, string url, string title, CancellationToken cancellationToken)
        {
            _logger.LogInformation("Executing MusicPushBackgroundJob: user={UserId}, url={Url}", userId, url);
    
            var message = new
            {
                action = "audio",
                url,
                title
            };
    
            try
            {
                await _devicePushService.SendCustomMessageAsync(userId, message, cancellationToken);
                _logger.LogInformation("Music pushed to user {UserId}", userId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to push music to user {UserId}", userId);
            }
        }
    }
    
    

#### 5.2.3 å›¾ç‰‡ç”Ÿæˆå·¥å…·å®ç°ç¤ºä¾‹

**ä»“åº“åœ°å€**ï¼š[verdure-mcp - GenerateImageTool](https://github.com/maker-community/verdure-mcp/blob/main/src/Verdure.Mcp.Server/Tools/GenerateImageTool.cs)

è¿™ä¸ªå·¥å…·å±•ç¤ºäº†å¦‚ä½•ç”Ÿæˆå›¾ç‰‡å¹¶æ¨é€åˆ°è®¾å¤‡ï¼š

    using System.ComponentModel;
    using System.Net;
    using Hangfire;
    using Microsoft.EntityFrameworkCore;
    using ModelContextProtocol.Server;
    using Verdure.Mcp.Domain.Entities;
    using Verdure.Mcp.Domain.Enums;
    using Verdure.Mcp.Infrastructure.Data;
    using Verdure.Mcp.Infrastructure.Services;
    using Verdure.Mcp.Server.Services;
    
    namespace Verdure.Mcp.Server.Tools;
    
    /// <summary>
    /// ä½¿ç”¨ Azure OpenAI DALL-E ç”Ÿæˆå›¾ç‰‡çš„ MCP å·¥å…·
    /// </summary>
    [McpServerToolType]
    public class GenerateImageTool
    {
        private readonly IImageGenerationService _imageGenerationService;
        private readonly IEmailService _emailService;
        private readonly McpDbContext _dbContext;
        private readonly IBackgroundJobClient _backgroundJobClient;
        private readonly IHttpContextAccessor _httpContextAccessor;
        private readonly IImageStorageService _imageStorageService;
        private readonly IDevicePushService _devicePushService;
        private readonly ILogger<GenerateImageTool> _logger;
    
        public GenerateImageTool(
            IImageGenerationService imageGenerationService,
            IEmailService emailService,
            McpDbContext dbContext,
            IBackgroundJobClient backgroundJobClient,
            IHttpContextAccessor httpContextAccessor,
            IImageStorageService imageStorageService,
            IDevicePushService devicePushService,
            ILogger<GenerateImageTool> logger)
        {
            _imageGenerationService = imageGenerationService;
            _emailService = emailService;
            _dbContext = dbContext;
            _backgroundJobClient = backgroundJobClient;
            _httpContextAccessor = httpContextAccessor;
            _imageStorageService = imageStorageService;
            _devicePushService = devicePushService;
            _logger = logger;
        }
    
        /// <summary>
        /// ä½¿ç”¨ Azure OpenAI DALL-E æ ¹æ®æç¤ºè¯ç”Ÿæˆå›¾ç‰‡ã€‚
        /// å¦‚æœæä¾›é‚®ç®±åœ°å€ï¼Œä¼šå°†ç”Ÿæˆçš„å›¾ç‰‡å‘é€åˆ°æŒ‡å®šé‚®ç®±ã€‚
        /// å¦‚æœè¯·æ±‚å¤´ä¸­åŒ…å«ç”¨æˆ·ä¿¡æ¯ï¼ˆX-User-Email å’Œ X-User-Idï¼‰ï¼Œä»»åŠ¡å°†å¼‚æ­¥è¿è¡Œã€‚
        /// </summary>
        /// <param name="prompt">æè¿°è¦ç”Ÿæˆå›¾ç‰‡çš„æ–‡æœ¬æç¤ºè¯</param>
        /// <param name="size">å›¾ç‰‡å°ºå¯¸ï¼š"1024x1024"ã€"1792x1024" æˆ– "1024x1792"ï¼Œé»˜è®¤ä¸º "1024x1024"</param>
        /// <param name="quality">å›¾ç‰‡è´¨é‡ï¼š"standard" æˆ– "hd"ï¼Œé»˜è®¤ä¸º "standard"</param>
        /// <param name="style">å›¾ç‰‡é£æ ¼ï¼š"vivid" æˆ– "natural"ï¼Œé»˜è®¤ä¸º "vivid"</param>
        /// <param name="cancellationToken"></param>
        /// <returns>åŒ…å«ä»»åŠ¡ä¿¡æ¯å’Œå›¾ç‰‡æ•°æ®çš„ JSON å¯¹è±¡ï¼ˆåŒæ­¥æ¨¡å¼ä¸‹ï¼‰</returns>
        [McpServerTool(Name = "generate_image")]
        [Description("ä½¿ç”¨ DALL-E æ¨¡å‹ï¼Œæ ¹æ®æ–‡æœ¬æç¤ºè¯ç”Ÿæˆå›¾ç‰‡ã€‚æ”¯æŒé‚®ä»¶é€šçŸ¥å’Œå¼‚æ­¥å¤„ç†ã€‚")]
        public async Task<ImageGenerationResponse> GenerateImage(
            [Description("æè¿°è¦ç”Ÿæˆå›¾ç‰‡çš„æ–‡æœ¬æç¤ºè¯")] string prompt,
            [Description("å›¾ç‰‡å°ºå¯¸ï¼š'1024x1024'ã€'1792x1024' æˆ– '1024x1792'ï¼Œé»˜è®¤ä¸º '1024x1024'")] string? size = null,
            [Description("å›¾ç‰‡è´¨é‡ï¼š'standard' æˆ– 'hd'ï¼Œé»˜è®¤ä¸º 'standard'")] string? quality = null,
            [Description("å›¾ç‰‡é£æ ¼ï¼š'vivid' æˆ– 'natural'ï¼Œé»˜è®¤ä¸º 'vivid'")] string? style = null,
            CancellationToken cancellationToken = default)
        {
            var httpContext = _httpContextAccessor.HttpContext;
            
            // ä»è¯·æ±‚å¤´æå–é‚®ç®±åœ°å€ (X-User-Email)
            var email = httpContext?.Request.Headers["X-User-Email"].FirstOrDefault();
            
            // ä»è¯·æ±‚å¤´æå–ç”¨æˆ· ID (X-User-Id)
            var userId = httpContext?.Request.Headers["X-User-Id"].FirstOrDefault();
    
            _logger.LogInformation("æ”¶åˆ°å›¾ç‰‡ç”Ÿæˆè¯·æ±‚ã€‚æç¤ºè¯: {Prompt}, é‚®ç®±: {Email}, ç”¨æˆ·ID: {UserId}", 
                prompt, email ?? "æ— ", userId ?? "æ— ");
    
            // åˆ›å»ºä»»åŠ¡è®°å½•
            var task = new ImageGenerationTask
            {
                Id = Guid.NewGuid(),
                Prompt = prompt,
                Size = size ?? "1024x1024",
                Quality = quality ?? "standard",
                Style = style ?? "vivid",
                Status = ImageTaskStatus.Pending,
                Email = email,
                UserId = userId,
                CreatedAt = DateTime.UtcNow
            };
    
            _dbContext.ImageGenerationTasks.Add(task);
            await _dbContext.SaveChangesAsync(cancellationToken);
    
            // å¦‚æœå­˜åœ¨ç”¨æˆ·ä¿¡æ¯ï¼ˆX-User-Email å’Œ X-User-Idï¼‰ï¼Œä½¿ç”¨ Hangfire å¼‚æ­¥å¤„ç†
            if (!string.IsNullOrEmpty(email) && !string.IsNullOrEmpty(userId))
            {
                _logger.LogInformation("æ£€æµ‹åˆ°ç”¨æˆ·ä¿¡æ¯ï¼Œä½¿ç”¨å¼‚æ­¥å¤„ç†ä»»åŠ¡ {TaskId}", task.Id);
                
                var jobId = _backgroundJobClient.Enqueue<ImageGenerationBackgroundJob>(
                    job => job.ExecuteAsync(task.Id, CancellationToken.None));
                
                task.HangfireJobId = jobId;
                task.Status = ImageTaskStatus.Processing;
                await _dbContext.SaveChangesAsync(cancellationToken);
    
                return new ImageGenerationResponse
                {
                    TaskId = task.Id,
                    Status = "å¤„ç†ä¸­",
                    Message = "å›¾ç‰‡ç”Ÿæˆä»»åŠ¡å·²åŠ å…¥é˜Ÿåˆ—ã€‚å¦‚æœæ‚¨æä¾›äº†é‚®ç®±åœ°å€ï¼Œç¨åä¼šæ”¶åˆ°ç”Ÿæˆç»“æœã€‚",
                    IsAsync = true
                };
            }
            else
            {
                // åŒæ­¥å¤„ç†
                _logger.LogInformation("æœªæ£€æµ‹åˆ°å®Œæ•´ç”¨æˆ·ä¿¡æ¯ï¼Œä½¿ç”¨åŒæ­¥å¤„ç†ä»»åŠ¡ {TaskId}", task.Id);
                
                task.Status = ImageTaskStatus.Processing;
                await _dbContext.SaveChangesAsync(cancellationToken);
    
                try
                {
                    var result = await _imageGenerationService.GenerateImageAsync(
                        prompt, size, quality, style, cancellationToken);
    
                    if (result.Success)
                    {
                        task.Status = ImageTaskStatus.Completed;
                        task.ImageData = result.ImageBase64;
                        task.CompletedAt = DateTime.UtcNow;
                        task.UpdatedAt = DateTime.UtcNow;
    
                        // ä¿å­˜å›¾ç‰‡åˆ°æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿï¼ˆPNG + JPEGï¼‰
                        ImageStorageResult? storageResult = null;
                        if (!string.IsNullOrEmpty(result.ImageBase64))
                        {
                            try
                            {
                                storageResult = await _imageStorageService.SaveImageAsync(
                                    result.ImageBase64, 
                                    task.Id, 
                                    cancellationToken);
                                task.ImageUrl = storageResult.PngUrl; // æ•°æ®åº“ä¿å­˜ PNG URL
                                _logger.LogInformation(
                                    "å›¾ç‰‡å·²ä¿å­˜ - PNG: {PngUrl}, JPEG: {JpegUrl}, å‹ç¼©ç‡: {CompressionRatio:F1}%",
                                    storageResult.PngUrl, storageResult.JpegUrl, storageResult.CompressionRatio);
                            }
                            catch (Exception ex)
                            {
                                _logger.LogError(ex, "ä¿å­˜å›¾ç‰‡åˆ°æœ¬åœ°å¤±è´¥ï¼Œä»»åŠ¡ {TaskId}", task.Id);
                                // å³ä½¿ä¿å­˜å¤±è´¥ï¼Œä»ç„¶ç»§ç»­æµç¨‹
                            }
                        }
    
                        await _dbContext.SaveChangesAsync(cancellationToken);
    
                        // å¦‚æœæä¾›äº†é‚®ç®±ï¼Œå‘é€é‚®ä»¶
                        if (!string.IsNullOrEmpty(email) && !string.IsNullOrEmpty(result.ImageBase64))
                        {
                            try
                            {
                                var imageBytes = Convert.FromBase64String(result.ImageBase64);
                                var encodedPrompt = WebUtility.HtmlEncode(prompt);
                                var encodedRevisedPrompt = WebUtility.HtmlEncode(result.RevisedPrompt ?? "æ— ");
                                await _emailService.SendImageEmailAsync(
                                    email,
                                    "æ‚¨çš„å›¾ç‰‡å·²ç”Ÿæˆ",
                                    $"<h1>æ‚¨çš„å›¾ç‰‡å·²æˆåŠŸç”Ÿæˆï¼</h1><p>æç¤ºè¯ï¼š{encodedPrompt}</p><p>ä¿®è®¢åçš„æç¤ºè¯ï¼š{encodedRevisedPrompt}</p>",
                                    imageBytes,
                                    $"image_{task.Id}.png",
                                    cancellationToken);
                                
                                task.EmailSent = true;
                                await _dbContext.SaveChangesAsync(cancellationToken);
                            }
                            catch (Exception ex)
                            {
                                _logger.LogError(ex, "å‘é€é‚®ä»¶å¤±è´¥ï¼Œä»»åŠ¡ {TaskId}", task.Id);
                            }
                        }
    
                        // å¦‚æœæœ‰ç”¨æˆ· IDï¼Œæ¨é€åˆ°ç”¨æˆ·è®¾å¤‡ï¼ˆä½¿ç”¨ JPEG ç‰ˆæœ¬ï¼Œç¬¦åˆ xiaozhi åè®®ï¼‰
                        if (!string.IsNullOrEmpty(userId) && storageResult != null)
                        {
                            try
                            {
                                // 1. å…ˆå‘é€é€šçŸ¥æ¶ˆæ¯
                                var notificationMessage = new
                                {
                                    action = "notification",
                                    title = "å›¾ç‰‡ç”Ÿæˆå®Œæˆ",
                                    content = $"æ‚¨çš„å›¾ç‰‡å·²ç”Ÿæˆï¼š{prompt.Substring(0, Math.Min(30, prompt.Length))}...",
                                    emotion = "happy",
                                    sound = "success"
                                };
                                await _devicePushService.SendCustomMessageAsync(userId, notificationMessage, cancellationToken);
                                
                                // 2. å†å‘é€å›¾ç‰‡æ¶ˆæ¯ï¼ˆESP32 æœŸæœ›çš„æ ¼å¼ - xiaozhi åè®®ï¼‰
                                var imageMessage = new
                                {
                                    action = "image",
                                    url = storageResult.JpegUrl,  // ä½¿ç”¨ JPEG URLï¼ˆä½“ç§¯å°ï¼‰
                                    // æ‰©å±•ä¿¡æ¯ï¼ˆå¯é€‰ï¼ŒESP32 å¯ä»¥å¿½ç•¥ï¼‰
                                    taskId = task.Id.ToString(),
                                    pngUrl = storageResult.PngUrl,
                                    prompt = prompt,
                                    jpegSize = storageResult.JpegSize,
                                    timestamp = DateTime.UtcNow
                                };
    
                                await _devicePushService.SendCustomMessageAsync(userId, imageMessage, cancellationToken);
                                _logger.LogInformation(
                                    "å·²æ¨é€å›¾ç‰‡åˆ°ç”¨æˆ· {UserId} çš„è®¾å¤‡ï¼Œä»»åŠ¡ {TaskId}ï¼ŒJPEG URL: {JpegUrl} ({JpegSize} bytes)", 
                                    userId, task.Id, storageResult.JpegUrl, storageResult.JpegSize);
                            }
                            catch (Exception ex)
                            {
                                _logger.LogError(ex, "æ¨é€æ¶ˆæ¯åˆ°è®¾å¤‡å¤±è´¥ï¼Œç”¨æˆ· {UserId}ï¼Œä»»åŠ¡ {TaskId}", userId, task.Id);
                            }
                        }
    
                        // åŒæ­¥æ¨¡å¼ï¼šè¿”å› PNG URLï¼ˆå®Œæ•´è´¨é‡ï¼‰
                        return new ImageGenerationResponse
                        {
                            TaskId = task.Id,
                            Status = "å·²å®Œæˆ",
                            Message = "å›¾ç‰‡ç”ŸæˆæˆåŠŸ",
                            ImageUrl = storageResult?.PngUrl ?? result.ImageUrl,
                            RevisedPrompt = result.RevisedPrompt,
                            IsAsync = false
                        };
                    }
                    else
                    {
                        task.Status = ImageTaskStatus.Failed;
                        task.ErrorMessage = result.ErrorMessage;
                        task.UpdatedAt = DateTime.UtcNow;
                        await _dbContext.SaveChangesAsync(cancellationToken);
    
                        return new ImageGenerationResponse
                        {
                            TaskId = task.Id,
                            Status = "å¤±è´¥",
                            Message = result.ErrorMessage ?? "å›¾ç‰‡ç”Ÿæˆå¤±è´¥",
                            IsAsync = false
                        };
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "åŒæ­¥ç”Ÿæˆå›¾ç‰‡æ—¶å‡ºé”™ï¼Œä»»åŠ¡ {TaskId}", task.Id);
                    
                    task.Status = ImageTaskStatus.Failed;
                    task.ErrorMessage = ex.Message;
                    task.UpdatedAt = DateTime.UtcNow;
                    await _dbContext.SaveChangesAsync(cancellationToken);
    
                    return new ImageGenerationResponse
                    {
                        TaskId = task.Id,
                        Status = "å¤±è´¥",
                        Message = ex.Message,
                        IsAsync = false
                    };
                }
            }
        }
    
        /// <summary>
        /// è·å–å›¾ç‰‡ç”Ÿæˆä»»åŠ¡çš„çŠ¶æ€
        /// </summary>
        /// <param name="taskId">è¦æŸ¥è¯¢çš„ä»»åŠ¡ ID</param>
        /// <returns>ä»»åŠ¡çŠ¶æ€å’Œç»“æœï¼ˆå¦‚æœå·²å®Œæˆï¼‰</returns>
        [McpServerTool(Name = "get_image_task_status")]
        [Description("è·å–å›¾ç‰‡ç”Ÿæˆä»»åŠ¡çš„çŠ¶æ€")]
        public async Task<ImageGenerationResponse> GetImageTaskStatus(
            [Description("è¦æŸ¥è¯¢çš„ä»»åŠ¡ ID")] string taskId,
            CancellationToken cancellationToken = default)
        {
            if (!Guid.TryParse(taskId, out var id))
            {
                return new ImageGenerationResponse
                {
                    Status = "é”™è¯¯",
                    Message = "ä»»åŠ¡ ID æ ¼å¼æ— æ•ˆ"
                };
            }
    
            var task = await _dbContext.ImageGenerationTasks.FindAsync(new object[] { id }, cancellationToken);
            
            if (task == null)
            {
                return new ImageGenerationResponse
                {
                    Status = "é”™è¯¯",
                    Message = "æœªæ‰¾åˆ°ä»»åŠ¡"
                };
            }
    
            return new ImageGenerationResponse
            {
                TaskId = task.Id,
                Status = task.Status.ToString().ToLowerInvariant(),
                Message = task.ErrorMessage ?? GetStatusMessage(task.Status),
                ImageBase64 = task.ImageData,
                ImageUrl = task.ImageUrl,
                IsAsync = !string.IsNullOrEmpty(task.HangfireJobId)
            };
        }
    
        private static string GetStatusMessage(ImageTaskStatus status)
        {
            return status switch
            {
                ImageTaskStatus.Pending => "ä»»åŠ¡ç­‰å¾…ä¸­",
                ImageTaskStatus.Processing => "ä»»åŠ¡å¤„ç†ä¸­",
                ImageTaskStatus.Completed => "å›¾ç‰‡ç”ŸæˆæˆåŠŸ",
                ImageTaskStatus.Failed => "å›¾ç‰‡ç”Ÿæˆå¤±è´¥",
                ImageTaskStatus.Cancelled => "ä»»åŠ¡å·²å–æ¶ˆ",
                _ => "æœªçŸ¥çŠ¶æ€"
            };
        }
    }
    
    /// <summary>
    /// å›¾ç‰‡ç”Ÿæˆå“åº”æ¨¡å‹
    /// </summary>
    public class ImageGenerationResponse
    {
        public Guid? TaskId { get; set; }
        public required string Status { get; set; }
        public string? Message { get; set; }
        public string? ImageBase64 { get; set; }
        public string? ImageUrl { get; set; }
        public string? RevisedPrompt { get; set; }
        public bool IsAsync { get; set; }
    }
    
    

**å®é™…é¡¹ç›®ç‰¹ç‚¹**ï¼š

1.  **åŒæ¨¡å¼æ”¯æŒ**ï¼š
    
    *   åŒæ­¥æ¨¡å¼ï¼šç«‹å³ç”Ÿæˆå¹¶è¿”å›ç»“æœ
    *   å¼‚æ­¥æ¨¡å¼ï¼šä½¿ç”¨Hangfireåå°ä»»åŠ¡ï¼Œå®Œæˆåé€šè¿‡é‚®ä»¶é€šçŸ¥
2.  **å¤šæ¸ é“æ¨é€**ï¼š
    
    *   é€šè¿‡SignalRæ¨é€åˆ°è®¾å¤‡ï¼ˆCustomMessageï¼‰
    *   é€šè¿‡é‚®ä»¶å‘é€é“¾æ¥
3.  **å›¾ç‰‡å­˜å‚¨**ï¼š
    
    *   åŒæ—¶ä¿å­˜PNGå’ŒJPEGä¸¤ç§æ ¼å¼
    *   å­˜å‚¨åˆ°Azure Blob Storageæˆ–æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿ
4.  **å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•**
    

**è·å–å®Œæ•´ä»£ç **ï¼š

*   ğŸ”§ ESP32è®¾å¤‡ç«¯ (å°æ™ºå®Œæ•´å®ç°):  
    [https://github.com/maker-community/xiaozhi-esp32](https://github.com/maker-community/xiaozhi-esp32)
    
    *   SignalRé›†æˆåˆ†æ”¯ï¼š`signalr` å’Œ `signalr-update-audio`
*   ğŸ”§ ESP32ç¤ºä¾‹å·¥ç¨‹ (åŒ…å«å®Œæ•´çš„SignalRé›†æˆç¤ºä¾‹):  
    [https://github.com/maker-community/esp-signalr-example](https://github.com/maker-community/esp-signalr-example)
    
*   ğŸ”§ SignalR C++å®¢æˆ·ç«¯åº“:  
    [https://github.com/maker-community/esp-signalr](https://github.com/maker-community/esp-signalr)  
    [https://github.com/maker-community/esp-signalr-example](https://github.com/maker-community/esp-signalr-example)
    
*   ğŸŒ MCPæœåŠ¡å™¨ç«¯:  
    [https://github.com/maker-community/verdure-mcp](https://github.com/maker-community/verdure-mcp)
    

å®é™…ä½¿ç”¨åœºæ™¯ç¤ºä¾‹
--------

### åœºæ™¯1ï¼šAIç”Ÿå›¾åæ¨é€åˆ°è®¾å¤‡

ç”¨æˆ·é€šè¿‡å°æ™ºå¯¹è¯ï¼š"å¸®æˆ‘ç”Ÿæˆä¸€å¼ çŒ«å’ªçš„å›¾ç‰‡"

1.  å¯¹è¯å‘é€åˆ°.NET MCPæœåŠ¡
2.  MCPæœåŠ¡è°ƒç”¨APIç”Ÿæˆå›¾ç‰‡
3.  ç”Ÿæˆå®Œæˆåï¼Œåå°ä»»åŠ¡è°ƒç”¨hubå‘é€æ¶ˆæ¯
4.  æœåŠ¡ç«¯é€šè¿‡SignalRæ¨é€å›¾ç‰‡ç»™è¯¥ç”¨æˆ·çš„æ‰€æœ‰è®¾å¤‡
5.  ESP32è®¾å¤‡æ¥æ”¶åˆ°`è‡ªå®šä¹‰æ¶ˆæ¯`äº‹ä»¶ï¼Œä¸‹è½½å¹¶æ˜¾ç¤ºåœ¨å±å¹•ä¸Š

### åœºæ™¯2ï¼šæ’­æ”¾éŸ³ä¹

ç”¨æˆ·é€šè¿‡è¯­éŸ³è¯´æƒ³è¦æ’­æ”¾éŸ³ä¹ï¼Œmcpè¢«è§¦å‘ï¼Œéšæœºé€‰æ‹©éŸ³ä¹urlæ¨é€åˆ°è®¾å¤‡

1.  å¯¹è¯å‘é€åˆ°.NET MCPæœåŠ¡
2.  æœåŠ¡ç«¯é€šè¿‡SignalRæ¨é€éŸ³ä¹ç»™è¯¥ç”¨æˆ·çš„æ‰€æœ‰è®¾å¤‡
3.  ESP32è®¾å¤‡æ¥æ”¶åˆ°`è‡ªå®šä¹‰æ¶ˆæ¯`äº‹ä»¶ï¼Œä¸‹è½½å¹¶æ’­æ”¾è¯­éŸ³

å†…å­˜ä¼˜åŒ–ç»éªŒåˆ†äº«
--------

> **è¯´æ˜**ï¼šæœ¬ç« èŠ‚å†…å®¹å¯¹äºåœ¨ESP32ä¸Šè¿è¡ŒSignalRå®¢æˆ·ç«¯éå¸¸é‡è¦ï¼Œè¿™äº›éƒ½æ˜¯å®è·µä¸­æ€»ç»“å‡ºçš„ç»éªŒã€‚

åœ¨ESP32ä¸Šé›†æˆSignalRç¡®å®é‡åˆ°äº†å†…å­˜é—®é¢˜ï¼Œåˆ†äº«ä¸€äº›ä¼˜åŒ–ç»éªŒï¼š

### 1\. ä½¿ç”¨PSRAMå­˜å‚¨å¤§å¯¹è±¡

    // ä¸ºå›¾ç‰‡æ•°æ®åˆ†é…PSRAMå†…å­˜
    void* imageBuffer = heap_caps_malloc(imageSize, MALLOC_CAP_SPIRAM);
    if (imageBuffer == NULL) {
        // é™çº§åˆ°å†…éƒ¨RAM
        imageBuffer = malloc(imageSize);
    }
    

åœ¨VS Codeçš„menuconfigä¸­å¯ç”¨PSRAMï¼š

*   `F1` â†’ `ESP-IDF: SDK Configuration editor`
*   `Component config` â†’ `ESP32-specific` â†’ `Support for external, SPI-connected RAM`

### 2\. å‡å°‘JSONåºåˆ—åŒ–æ¬¡æ•°

    // é”™è¯¯åšæ³•ï¼šé¢‘ç¹åˆ›å»º/é”€æ¯cJSONå¯¹è±¡
    for (int i = 0; i < 100; i++) {
        cJSON* root = cJSON_Parse(jsonString);
        // å¤„ç†...
        cJSON_Delete(root);  // äº§ç”Ÿå†…å­˜ç¢ç‰‡
    }
    
    // æ­£ç¡®åšæ³•ï¼šå¤ç”¨å¯¹è±¡
    cJSON* root = cJSON_Parse(jsonString);
    for (int i = 0; i < 100; i++) {
        // å¤„ç†...
    }
    cJSON_Delete(root);
    

### 3\. å¢åŠ ä»»åŠ¡æ ˆå¤§å°

SignalRçš„å›è°ƒåµŒå¥—è¾ƒæ·±ï¼Œéœ€è¦å¢åŠ æ ˆï¼š

åœ¨menuconfigä¸­ï¼š`Component config` â†’ `ESP32-specific` â†’ `Main task stack size` â†’ è®¾ç½®ä¸º`8192`

æˆ–åœ¨ä»£ç ä¸­ï¼š

    xTaskCreatePinnedToCore(
        signalr_task,
        "signalr",
        8192,  // æ ˆå¤§å°ï¼ˆå­—èŠ‚ï¼‰
        NULL,
        5,     // ä¼˜å…ˆçº§
        NULL,
        1      // CPUæ ¸å¿ƒ
    );
    

æ€»ç»“ä¸æ„Ÿæ‚Ÿ
-----

é€šè¿‡è¿™æ¬¡SignalRç§»æ¤å’Œé›†æˆçš„å®è·µï¼Œæˆ‘æ·±åˆ»ä½“ä¼šåˆ°ï¼š

1.  **é€‰å¯¹æ¡†æ¶å¾ˆé‡è¦**ï¼šSignalRçš„ç¾¤ç»„ç®¡ç†ã€æ¶ˆæ¯è·¯ç”±ç­‰ç‰¹æ€§ï¼Œçœå»äº†å¤§é‡åŸºç¡€è®¾æ–½ä»£ç ã€‚å¦‚æœä»å¤´æ‰‹å†™WebSocketï¼Œè¿™äº›åŠŸèƒ½å¾—èŠ±å‡ å‘¨æ—¶é—´ã€‚
    
2.  **å†…å­˜ç®¡ç†æ˜¯åµŒå…¥å¼æ°¸æ’çš„ä¸»é¢˜**ï¼šESP32çš„RAMé™åˆ¶è®©æˆ‘å¯¹æ¯ä¸€ä¸ªmallocéƒ½æ ¼å¤–å°å¿ƒã€‚åˆç†ä½¿ç”¨PSRAMã€é¿å…å†…å­˜ç¢ç‰‡ã€åŠæ—¶é‡Šæ”¾èµ„æºï¼Œè¿™äº›åœ¨PCä¸Šä¸ç”¨careçš„é—®é¢˜ï¼Œåœ¨åµŒå…¥å¼ä¸Šéƒ½æ˜¯å‘ã€‚
    
3.  **AIè¾…åŠ©ç¼–ç¨‹çœŸé¦™**ï¼šè¿™æ¬¡é¡¹ç›®ä¸­ï¼ŒSignalR C++å®¢æˆ·ç«¯çš„ç§»æ¤ã€æ¶ˆæ¯å¤„ç†ç­‰å¤§é‡ä»£ç éƒ½æ˜¯å€ŸåŠ©AIç”Ÿæˆçš„ã€‚è™½ç„¶ç”Ÿæˆçš„ä»£ç éœ€è¦è°ƒè¯•å’Œä¼˜åŒ–ï¼Œä½†ç¡®å®å¤§å¹…æé«˜äº†å¼€å‘æ•ˆç‡ã€‚
    
4.  **æ¶ˆæ¯æ¨é€è§£å†³å®é™…é—®é¢˜**ï¼šä¹‹å‰MCPå·¥å…·åªèƒ½åŒæ­¥è¿”å›ç»“æœï¼Œç°åœ¨é€šè¿‡SignalRï¼ŒæœåŠ¡ç«¯å¯ä»¥ä¸»åŠ¨æ¨é€å›¾ç‰‡ã€è¯­éŸ³ã€é€šçŸ¥ç»™è®¾å¤‡ï¼Œç”¨æˆ·ä½“éªŒæå‡æ˜æ˜¾ã€‚
    
5.  **.NETç”Ÿæ€çš„å¼ºå¤§**ï¼šSignalRã€EF Coreã€JWTè®¤è¯â€¦â€¦å¾®è½¯è¿™å¥—ç”Ÿæ€çœŸçš„å¾ˆå®Œå–„ã€‚ä½œä¸º.NETå¼€å‘è€…ï¼Œèƒ½ç”¨ç†Ÿæ‚‰çš„æŠ€æœ¯æ ˆå¿«é€Ÿæ­å»ºç”Ÿäº§çº§æœåŠ¡ã€‚
    

è¿™ä¸ªé¡¹ç›®è¿˜æœ‰å¾ˆå¤šä¼˜åŒ–ç©ºé—´ï¼Œæ¯”å¦‚ï¼š

*   WebSocket Binary Protocolæ›¿ä»£JSONå‡å°‘å¸¦å®½
*   å¼•å…¥Rediså­˜å‚¨ç¾¤ç»„ä¿¡æ¯ï¼Œæ”¯æŒæœåŠ¡ç«¯æ¨ªå‘æ‰©å±•
*   ç»§ç»­å®Œå–„ä»£ç è´¨é‡ï¼Œè®©åº“èƒ½å¤Ÿè¢«æ›´å¤šçš„äººå…³æ³¨å’Œå‚ä¸ï¼Œå¸Œæœ›æœ‰æ›´å¤šçš„äººæ¥å®é™…ä½¿ç”¨å’Œä¼˜åŒ–ã€‚

ä½†ä½œä¸ºä¸€ä¸ªåˆæ­¥èƒ½ç”¨çš„æ–¹æ¡ˆï¼Œå·²ç»è¶³å¤Ÿæ”¯æ’‘å°æ™ºæœºå™¨äººçš„åŠŸèƒ½æ‰©å±•äº†ã€‚åç»­æˆ‘ä¼šç»§ç»­å®Œå–„è¿™å¥—æ¶æ„ï¼Œæ¬¢è¿å¤§å®¶ä¸€èµ·æ¢è®¨å’Œè´¡çŒ®ä»£ç ï¼

å¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½ç»™å¤§å®¶åœ¨.NET IoTå¼€å‘ã€SignalRå®æ—¶é€šä¿¡æ–¹é¢å¸¦æ¥ä¸€äº›å¯å‘ã€‚å¦‚æœæœ‰é—®é¢˜æ¬¢è¿åœ¨è¯„è®ºåŒºè®¨è®ºï¼Œè®©æˆ‘ä»¬ä¸€èµ·æ¢ç´¢.NETåœ¨IoTé¢†åŸŸçš„æ›´å¤šå¯èƒ½æ€§ï¼

æ‰‹æ“ESP32å°æœºå™¨äºº
-----------

å¦‚æœä½ æœ‰æ‰‹æ“Esp32çš„ç¡¬ä»¶æ‰“ç®—ï¼Œå¯ä»¥å…³æ³¨æˆ‘çš„Bç«™è´¦å·ï¼ˆç»¿è«é˜¿å¹¿ï¼‰  
[https://space.bilibili.com/25228512](https://space.bilibili.com/25228512)

![img](https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201141614219-406532144.png)

é¡¹ç›®åœ°å€
----

### ESP32ç›¸å…³

*   **SignalR C++å®¢æˆ·ç«¯åº“**ï¼š  
    [https://github.com/maker-community/esp-signalr](https://github.com/maker-community/esp-signalr)
    
*   **å°æ™ºESP32å®Œæ•´å®ç°** (signalr-update-audioåˆ†æ”¯):  
    [https://github.com/maker-community/xiaozhi-esp32](https://github.com/maker-community/xiaozhi-esp32)
    
*   **ESP32 SignalRå®Œæ•´ç¤ºä¾‹å·¥ç¨‹** (åŒ…å«éŸ³é¢‘åˆ†å—ã€è®¾å¤‡æ§åˆ¶APIç­‰):  
    [https://github.com/maker-community/esp-signalr-example](https://github.com/maker-community/esp-signalr-example)
    
    *   [æœåŠ¡ç«¯ä»£ç ](https://github.com/maker-community/esp-signalr-example/tree/main/signalr-server)
    *   [å®¢æˆ·ç«¯ä»£ç ](https://github.com/maker-community/esp-signalr-example/tree/main/main)

### .NETæœåŠ¡ç«¯

*   **Verdure MCPæœåŠ¡** (åŒ…å«å®Œæ•´çš„Hubã€Toolsã€Serviceså®ç°):  
    [https://github.com/maker-community/verdure-mcp](https://github.com/maker-community/verdure-mcp)
*   **å°æ™ºmcpè½¬æ¥å¹³å°**ï¼š
*   [https://github.com/maker-community/verdure-mcp-for-xiaozhi](https://github.com/maker-community/verdure-mcp-for-xiaozhi)

### å‚è€ƒèµ„æ–™

*   **SignalR Client C++ (å¾®è½¯å®˜æ–¹)**:  
    [https://github.com/aspnet/SignalR-Client-Cpp](https://github.com/aspnet/SignalR-Client-Cpp)
*   **SignalR Client C# nanoframework**:  
    [https://github.com/nanoframework/nanoFramework.SignalR.Client](https://github.com/nanoframework/nanoFramework.SignalR.Client)

å‚è€ƒæ–‡æ¡£
----

1.  [ASP.NET Core SignalR å®˜æ–¹æ–‡æ¡£](https://docs.microsoft.com/zh-cn/aspnet/core/signalr/)
2.  [SignalR Hub åè®®è§„èŒƒ](https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md)
3.  [ESP-IDF ç¼–ç¨‹æŒ‡å—](https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/)
4.  [VS Code ESP-IDF æ’ä»¶](https://github.com/espressif/vscode-esp-idf-extension)
5.  [JWT è®¤è¯æœ€ä½³å®è·µ](https://jwt.io/introduction)
6.  [Keycloak è®¤è¯é›†æˆæŒ‡å—](https://www.keycloak.org/docs/latest/securing_apps/)

* * *

_æœ¬æ–‡é¦–å‘äºä¸ªäººæŠ€æœ¯åšå®¢ï¼Œè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚å¦‚æœå¯¹.NET IoTå¼€å‘ã€SignalRå®æ—¶é€šä¿¡æ„Ÿå…´è¶£ï¼Œæ¬¢è¿å…³æ³¨æˆ‘çš„åšå®¢è·å–æ›´å¤šæŠ€æœ¯åˆ†äº«ï¼_