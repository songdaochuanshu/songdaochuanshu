---
layout: post
title: 'LiteFlow 框架分析系列（一）：工作原理与快速入门'
date: "2025-12-25T17:25:29Z"
---
LiteFlow 框架分析系列（一）：工作原理与快速入门
============================

LiteFlow 框架分析系列（一）：工作原理与快速入门
============================

摘要
--

本篇作为 LiteFlow 框架分析系列的第一篇，主要带大家宏观了解 LiteFlow 是什么，它的核心设计理念是什么，以及它是如何通过一套简单的 DSL（领域特定语言）规则来驱动复杂的业务逻辑的。我们将通过一个简单的示例，结合 PlantUML 时序图，展示 LiteFlow 的运行机制。

1\. LiteFlow 是什么？
-----------------

简单来说，LiteFlow 就是一个**编排式的规则引擎**。

想象一下，你的代码里是不是充满了各种 `if-else`，或者一堆臃肿的 Service 调用？业务流程复杂的时候，改一个逻辑可能要动好几个文件，牵一发而动全身。

LiteFlow 的出现就是为了解决这个问题。它把你的业务逻辑拆分成一个个独立的“组件”（Component），然后通过一个规则文件（EL 表达式）把这些组件像搭积木一样串起来。

**核心思想就两点：**

1.  **组件化**：把业务逻辑切碎。
2.  **编排化**：用规则来决定执行顺序。

2\. 核心概念
--------

在深入源码之前，咱们得先对齐一下 LiteFlow 的几个核心概念，这就像学外语先背单词一样。

*   **Node (节点)**：流程中最小的执行单元。你可以把它理解为一个 Java 类，里面写了具体的业务代码。
*   **Component (组件)**：Node 的具体实现。在代码里，通常继承 `NodeComponent` 类。
*   **Chain (流程链)**：一串 Node 的组合。比如“先执行 A，再执行 B，如果 A 成功了再执行 C”，这就是一条 Chain。
*   **EL (表达式语言)**：用来定义 Chain 的语法。LiteFlow 独创了一套非常丝滑的语法，比如 `THEN(a, b, c)` 表示串行执行，`WHEN(a, b, c)` 表示并行执行。
*   **Slot (槽/上下文)**：流程执行的数据容器。你可以把它看作是一个流动的 Map，所有组件都可以从里面存取数据，实现数据共享。

3\. 工作原理
--------

LiteFlow 是怎么跑起来的呢？咱们用一张图来说明。

当你在 Spring Boot 启动的时候，LiteFlow 会做这么几件事：

1.  **加载配置**：读取 `liteflow.rule-source` 配置的规则文件。
2.  **解析规则**：把 XML/JSON/YAML 里的规则解析成内存里的 `Chain` 和 `Node` 对象。
3.  **注册组件**：把你的 Java Component 注册到 LiteFlow 的容器里。

当你调用 `flowExecutor.execute2Resp("chain1", param)` 时：  

### 关键步骤解析：

1.  **找链**：`FlowBus` 是 LiteFlow 的“交通枢纽”，它管理着所有的 Chain。执行器首先问它要到名为 `chain1` 的链。
2.  **执行链**：Chain 拿到后，根据定义好的 EL 规则（比如 `THEN(A, B)`），依次调度组件。
3.  **组件执行**：组件 A 和 B 依次运行。注意，它们之间不直接传递参数，而是通过 `Slot` 这个公共区域来交换数据。这大大降低了耦合度！

4\. 快速上手示例
----------

光说不练假把式，咱们看个最简单的 Spring Boot 集成例子。

### 第一步：定义组件

    @LiteflowComponent("a")
    public class ACmp extends NodeComponent {
        @Override
        public void process() {
            System.out.println("ACmp executed!");
            // 往上下文放点东西
            this.getContextBean(DefaultContext.class).setData("data", "hello");
        }
    }
    
    @LiteflowComponent("b")
    public class BCmp extends NodeComponent {
        @Override
        public void process() {
            System.out.println("BCmp executed!");
            // 从上下文拿东西
            String data = this.getContextBean(DefaultContext.class).getData("data");
            System.out.println("Data from A: " + data);
        }
    }
    

### 第二步：定义规则 (flow.el.xml)

    <?xml version="1.0" encoding="UTF-8"?>
    <flow>
        <chain name="chain1">
            THEN(a, b);
        </chain>
    </flow>
    

### 第三步：启动执行

    @Component
    public class TestRunner implements CommandLineRunner {
        
        @Resource
        private FlowExecutor flowExecutor;
    
        @Override
        public void run(String... args) throws Exception {
            LiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");
            if (response.isSuccess()){
                System.out.println("执行成功");
            }
        }
    }
    

5\. 总结
------

这一篇我们主要通过白话的方式介绍了 LiteFlow 的“世界观”。

*   **它的核心价值**：解耦。把“做什么”（Component）和“怎么做”（Rule）分开了。
*   **它的运行方式**：FlowExecutor 接收指令 -> FlowBus 查找流程 -> Chain 调度组件 -> Slot 传递数据。

LiteFlow 就像一个精密的生产线指挥系统，你只需要负责造零件（组件）和画图纸（规则），剩下的调度工作，它全包了。