---
layout: post
title: '经典面试题目“OOM异常会导致JVM退出吗？”'
date: "2025-04-30T00:40:30Z"
---
经典面试题目“OOM异常会导致JVM退出吗？”
=======================

经典面试题目“OOM异常会导致JVM退出吗？

我的回答是“这要分情况看，对于守护线程来说，OOM并不会导致JVM退出；对于非守护线程来说，如果某个线程捕获了OOM异常并处理异常后线程并未退出，那JVM并不会退出；如果线程没有捕获Error异常，那么将由全局的异常处理器处理，默认的全局的异常处理器也会让当前这个发生异常的线程退出，但是如果这个线程是最后一个非守护线程，那么JVM会退出，如果不是，JVM并不会退出。

对于守护线程来说，OOM并不会导致JVM退出，这里有一个非常好的线上故障：[https://blog.csdn.net/shuxiaohua/article/details/114658325](https://blog.csdn.net/shuxiaohua/article/details/114658325) ，缺少的接收客户端请求的线程Acceptor是一个守护线程，并且因为OOM退出时，并没有让Tomcat退出。

下面介绍一下非守护线程的情况，这些非守护线程通常就是处理业务的线程。每一个写过Java的人都应该知道Java异常继承体系，如下图所示。

![](https://img2024.cnblogs.com/blog/1236123/202504/1236123-20250429164835223-1085273427.png)

这里我们要注意一点，就是Exception和Error有共同的父类Throwable，这意味着异常和错误都可以在Java层捕获，例如：

    public static void main(String[] args) throws InterruptedException {
        try{
            // 每个整数数组的大小为4M
            int[] array１ = new int[1_000_000];
            int[] array２ = new int[1_000_000];
            int[] array３ = new int[1_000_000];
            int[] array４ = new int[1_000_000];
            int[] array５ = new int[1_000_000];
        }catch (Throwable t){
            t.printStackTrace();
        }
        System.out.println("程序走到了这里!");
    }
    

我们在指定参数-Xms20M -Xmx20m后，运行打印结果如下：

    java.lang.OutOfMemoryError: Java heap space
    	at cn.hotspotvm.TestError.main(TestError.java:12)
    程序走到了这里!
    

可以看到，即使发生了错误，这个线程依然在正常运行，如果我们不对Error进行捕获呢？如下：

    public static void main(String[] args) throws InterruptedException {
        int[] array１ = new int[1_000_000];
        int[] array２ = new int[1_000_000];
        int[] array３ = new int[1_000_000];
        int[] array４ = new int[1_000_000];
        int[] array５ = new int[1_000_000];
        System.out.println("程序走到了这里!");
    }
    

再次运行后就的打印结果如下：

    Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
    	at cn.hotspotvm.TestError.main(TestError.java:10)
    

可以看到，在发生错误时这个线程没有走到打印语句，而是直接退出了。

这里顺便说一下，我们可以设置一个全局的异常处理器来统一处理，或者优先针对某个线程设置异常处理器，这样当我们忽略了捕获错误时，可以在全局异常处理器中进行处理。举个例子如下：

    public static void main(String[] args) throws InterruptedException {
        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                System.out.println("这里是全局异常处理 "+e.getLocalizedMessage());
            }
        });
    
        int[] array１ = new int[1_000_000];
        int[] array２ = new int[1_000_000];
        int[] array３ = new int[1_000_000];
        int[] array４ = new int[1_000_000];
        int[] array５ = new int[1_000_000];
    
        System.out.println("程序走到了这里!");
    }
    

打印的信息如下：

    这里是全局异常处理 Java heap space
    

这个线程在全局异常处理中如果没有特殊处理，通常会让当前的线程退出。如果当前线程退出，那么JVM会退出吗？

其实Java虚拟机退出的条件是：虚拟机内已经没有了非守护线程。线程发生未处理的异常最终导致线程结束时，如果这个线程是最后一个非守护线程，则会退出，否则不退出。

更多文章可访问：[JDK源码剖析网](http://hotspotvm.cn)

![](https://img2024.cnblogs.com/blog/1236123/202504/1236123-20250424100503675-351126910.png)