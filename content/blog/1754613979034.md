---
layout: post
title: '.NET 10 新增功能系列文章5——C# 14 中的新增功能'
date: "2025-08-08T00:46:19Z"
---
.NET 10 新增功能系列文章5——C# 14 中的新增功能
===============================

### 1\. 扩展成员：更强大的扩展能力

C# 14对扩展方法进行了重大增强，引入了全新的**扩展成员**语法。这一新特性不仅支持扩展方法，还允许开发者声明**扩展属性**和**静态扩展成员**。

    public static class Enumerable
    {
        // 实例扩展成员块
        extension<TSource>(IEnumerable<TSource> source)
        {
            // 扩展属性
            public bool IsEmpty => !source.Any();
            
            // 扩展索引器
            public TSource this[int index] => source.Skip(index).First();
            
            // 扩展方法
            public IEnumerable<TSource> Where(Func<TSource, bool> predicate) { ... }
        }
    
        // 静态扩展成员块
        extension<TSource>(IEnumerable<TSource>)
        {
            // 静态扩展方法
            public static IEnumerable<TSource> Combine(IEnumerable<TSource> first, IEnumerable<TSource> second) { ... }
            
            // 静态扩展属性
            public static IEnumerable<TSource> Identity => Enumerable.Empty<TSource>();
        }
    }
    
    
    实例扩展成员可以像普通实例成员一样调用，如`sequence.IsEmpty`，而静态扩展成员则通过类型名调用，如`IEnumerable<int>.Identity`。这一特性极大地丰富了扩展方法的应用场景，使API设计更加灵活。
    
    

### 2\. field关键字：简化属性实现

C# 14引入了`field`上下文关键字，用于简化属性实现，无需显式声明后备字段。编译器会自动合成支持字段。

改进前的传统实现：

    private string _msg;
    public string Message
    {
        get => _msg;
        set => _msg = value ?? throw new ArgumentNullException(nameof(value));
    }
    

使用`field`关键字后的简化实现：

    public string Message
    {
        get;
        set => field = value ?? throw new ArgumentNullException(nameof(value));
    }
    
    

`field`关键字使属性实现更加简洁，特别是在需要对属性值进行验证或转换时。如果类型中已有名为`field`的符号，可以使用`@field`或`this.field`来消除歧义。

### 3\. 隐式Span转换：提升性能关键代码

C# 14增强了对`System.Span<T>`和`System.ReadOnlySpan<T>`的支持，引入了更多隐式转换，使这些高性能类型的使用更加自然。

新特性包括：

*   `T[]`到`Span<T>`的隐式转换
*   `Span<T>`到`ReadOnlySpan<T>`的隐式转换
*   `string`到`ReadOnlySpan<char>`的隐式转换

这些转换使得Span类型可以：

*   作为扩展方法的接收器
*   与其他转换组合使用
*   在泛型类型推断场景中提供帮助

Span类型的这些改进对于高性能场景（如文本处理、数值计算等）尤为重要，可以在不牺牲安全性的前提下获得接近原生代码的性能。

### 4\. nameof支持未绑定泛型类型

C# 14扩展了`nameof`操作符的功能，使其支持未绑定的泛型类型。这使得在反射、日志记录等场景下的代码更加简洁。

    // C# 14新特性
    string name = nameof(List<>); // 返回"List"
    
    // 之前只能这样做
    string name = nameof(List<int>); // 返回"List"
    

这一改进特别适用于需要处理泛型类型名称的通用框架代码，减少了硬编码字符串的使用，提高了代码的维护性。

### 5\. 带修饰符的简单Lambda参数

C# 14允许在不指定参数类型的情况下，为lambda表达式参数添加修饰符（如`ref`、`in`、`out`等），进一步简化了lambda表达式的书写。

改进前：

    TryParse<int> parse2 = (string text, out int result) => Int32.TryParse(text, out result);
    

改进后：

    TryParse<int> parse1 = (text, out result) => Int32.TryParse(text, out result);
    

注意`params`修饰符仍然需要显式类型声明。这一特性使lambda表达式更加简洁，特别是在处理包含`out`参数的方法时。

### 6\. 部分成员增强：构造函数和事件

C# 14扩展了部分成员的支持范围，现在可以将**实例构造函数**和**事件**声明为部分成员。

部分构造函数的要点：

*   必须包含定义声明和实现声明
*   只有实现声明可以包含构造函数初始值设定项(`this()`或`base()`)
*   只有一个分部类型声明可以包含主构造函数语法

部分事件的要点：

*   必须包含定义声明和实现声明
*   实现声明必须包含`add`和`remove`访问器
*   定义声明类似于字段事件

这些增强使得代码生成器和手动编写代码的协作更加灵活，特别适合大型项目或框架开发。

### 7\. 用户自定义复合赋值运算符

C# 14引入了用户自定义复合赋值运算符的能力，允许开发者为自己定义的类型重载复合赋值运算符（如`+=`、`-=`等）。这一特性通过更自然的语法简化了对自定义类型的操作。

虽然具体的实现细节需要参考功能规范，但这一特性为数值计算库、矩阵运算等场景提供了更优雅的语法支持。

### 8\. 空条件赋值：更简洁的null检查

C# 14扩展了空条件运算符`?.`的用法，现在可以将其放在赋值操作的左侧，实现空条件赋值。

传统null检查方式：

    if (customer is not null)
    {
        customer.Order = GetCurrentOrder();
    }
    

使用空条件赋值的简洁方式：

    customer?.Order = GetCurrentOrder();
    

在这个例子中，`GetCurrentOrder()`方法仅在`customer`不为null时才会被调用。这一特性同样适用于复合赋值运算符（如`+=`、`-=`等），但不支持递增(`++`)和递减(`--`)运算符。

系列文章
----

[.NET 10 中的新增功能系列文章1——运行时中的新增功能](https://www.cnblogs.com/powertoolsteam/p/19010089)

[.NET 10 中的新增功能系列文章2——ASP.NET Core 中的新增功能](https://www.cnblogs.com/powertoolsteam/p/19012227)

[.NET 10 中的新增功能系列文章3——.NET MAUI 中的新增功能](https://www.cnblogs.com/powertoolsteam/p/19014471)

[.NET 10 中的新增功能系列文章4——.NET SDK中的新增功能](https://www.cnblogs.com/powertoolsteam/p/19022593)

* * *

  

本文是由葡萄城技术开发团队发布，转载请注明出处：[葡萄城官网](https://www.grapecity.com.cn/)