---
layout: post
title: 'SpringBoot集成测试笔记：缩小测试范围、提高测试效率'
date: "2025-07-21T00:49:01Z"
---
SpringBoot集成测试笔记：缩小测试范围、提高测试效率
==============================

如果需要指定需要测试的 Bean 及其依赖，而不是加载完整的上下文环境，可以在 \`@SpringBootTest\` 注解的 \`classes\` 参数中配置需要测试及依赖的类或对象。如果遇到不是项目中自己写的或者可以自动生成的实现类，可以通过配置 \`@TestConfiguration\` 的方式，在测试配置中注册相关的 Bean。最终做到缩小测试范围，提高测试运行效率。

背景
--

在 SpringBoot 中，除了基于 Mock 的单元测试，往往还需要执行几个模块组合的集成测试。一种简单的方法就是在测试类上加入 `@SpringBootTest` 注解，但是，如果不对该注解做一些配置，默认情况下该测试类会加载完整的 SpringBoot 环境，包括该程序中所有的 Bean。如果要初始化的 Bean 非常多，启动集成测试的时间就会很长，因此我们需要对 `@SpringBootTest` 注解进行一些配置，以减少环境加载的数量，提高程序运行效率。

项目架构
----

下面是一个简单的 SpringBoot 项目，类图如下：

*   `ProjectController` 依赖接口 `ProjectListService` 和 `ProjectOperateService`；
*   `ProjectListService` 的实现类依赖接口 `ProjectConverter` 和 `ProjectMapper`；
*   `ProjectOperateService` 的实现类依赖接口 `ProjectBizCheckService`、`TechCheckService`、`ProjectConverver` 和 `ProjectMapper`;
*   接口 `ProjectConverter` 为 `MapStruct`映射接口；
*   接口 `ProjectMapper` 为 `Mybatis` 数据访问接口（DAO）。

不带参数的 `@SpringBootTest` 测试类
---------------------------

从类图中可以看到，`ProjectListService` 的实现类依赖两个接口，分别是用于对象转换的 `ProjectConverter` 和数据访问接口 `ProjectMapper`。我们首先使用默认的配置，即不带参数的 `@SpringBootTest` 注解进行测试。测试类代码如下：

    /**
     * 直接采用 {@link SpringBootTest} 注解的集成测试，
     * 不带任何参数或配置
     *
     */
    @SpringBootTest
    @DisplayName("集成测试：不带任何参数或配置")
    class ProjectListServiceWithoutConfigsTest {
        private final ApplicationContext applicationContext;
    
        @Autowired
        private ProjectListService projectListService;
    
        public ProjectListServiceWithoutConfigsTest(ApplicationContext applicationContext) {
            this.applicationContext = applicationContext;
        }
    
        @Test
        @DisplayName("获取所有Bean名称和数量")
        public void printAllBean() {
            // 获取所有Bean名称
            String[] beanNames = applicationContext.getBeanDefinitionNames();
            Arrays.sort(beanNames);
            System.out.println("========== Spring Beans Total (" + beanNames.length + ") =========");
            for (String beanName : beanNames) {
                System.out.println("name=" + beanName + ", class=" + applicationContext.getBean(beanName).getClass());
            }
        }
    
        @Test
        @DisplayName("测试查询全部项目列表-应包含2个项目，且和数据库一致")
        void testListAllProjects() {
            List<ProjectListResponse> projectListResponses = projectListService.listProjects();
    
            assertThat(projectListResponses).hasSize(2);
            assertThat(projectListResponses.getFirst().getProjectId()).isEqualTo(1);
            assertThat(projectListResponses.getFirst().getProjectName()).isEqualTo("测试项目1");
            assertThat(projectListResponses.getFirst().getProjectStatus()).isEqualTo(ProjectStatus.READY.getDesc());
    
            assertThat(projectListResponses.get(1).getProjectId()).isEqualTo(2);
            assertThat(projectListResponses.get(1).getProjectName()).isEqualTo("测试项目2");
            assertThat(projectListResponses.get(1).getProjectStatus()).isEqualTo(ProjectStatus.RUNNING.getDesc());
        }
    }
    

这里我们实现了一个方法 `printAllBean()`，通过获取应用上下文 `ApplicationContext` 对象中的所有被 Spring 加载的 Bean，检查本次测试加载的 Bean 数量。

运行测试，`printAllBean()` 方法的输出如下：

    ========== Spring Beans Total (289) =========
    name=/project, class=class cn.asuka.itd.project.controller.ProjectController
    name=accessorsProvider, class=class springfox.documentation.schema.property.bean.AccessorsProvider
    name=apiDescriptionLookup, class=class springfox.documentation.spring.web.scanners.ApiDescriptionLookup
    name=apiDescriptionReader, class=class springfox.documentation.spring.web.scanners.ApiDescriptionReader
    name=apiDocumentationScanner, class=class springfox.documentation.spring.web.scanners.ApiDocumentationScanner
    ......
    name=welcomePageNotAcceptableHandlerMapping, class=class org.springframework.boot.autoconfigure.web.servlet.WelcomePageNotAcceptableHandlerMapping
    name=xmlModelPlugin, class=class springfox.documentation.schema.plugins.XmlModelPlugin
    name=xmlPropertyPlugin, class=class springfox.documentation.schema.property.XmlPropertyPlugin
    

可以看到总共加载了 289 个 Bean，数量很多，但大多数是我们在测试中不直接依赖的。

那么，我们应该如何让该测试只依赖我们需要的 Bean，或者尽可能减少依赖的 Bean 数量呢？

带参数的 `@SpringBootTest` 测试
-------------------------

首先，我们要知道的是基于 `MapStruct` 的 `ProjectConverter` 接口，在编译期会生成对应的实现类 `ProjectConverterImpl`，和 `ProjectConverter` 在同一个包下，因此我们实际上可以直接把该实现类加载进 Spring 上下文中。

但是，基于 `Mybatis` 的 `ProjectMapper` 并不会直接生成实现类，而是在运行期通过 `MapperProxy` 代理类去执行。此外我们使用的数据库连接池是 `Druid`，因此 `ProjectMapper` 也隐含了对 `Druid` 连接池的依赖。

因此，我们通过设置 `@SpringBootTest` 注解的 `classes` 参数，来指定本次测试中 Spring 上下文需要加载的类。

为了让测试代码能够调用 `Druid` 连接池，还需要建立一个 `MybatisTestConfig` 的配置类，人为地设置一个在测试环境下的 `DataSource` 对象，让我们的测试类依赖该数据源，而不是生产代码中的数据源。

`MybatisTestConfig` 配置类定义如下：

    /**
     * @author jwmao
     */
    @TestConfiguration
    @AutoConfigureAfter({DataSourceAutoConfiguration.class, MybatisAutoConfiguration.class})
    @MapperScan(basePackages = {"cn.asuka.itd.project.dao"})
    public class MybatisTestConfig {
        @Value("${spring.datasource.druid.url}")
        private String url;
    
        @Value("${spring.datasource.druid.username}")
        private String username;
    
        @Value("${spring.datasource.druid.password}")
        private String password;
    
        @Value("${spring.datasource.druid.driver-class-name}")
        private String driverClassName;
    
        @Bean
        @ConfigurationProperties(prefix = "spring.datasource")
        public DataSource dataSource() {
            DruidDataSource dataSource = new DruidDataSource();
            dataSource.setUrl(url);
            dataSource.setUsername(username);
            dataSource.setPassword(password);
            dataSource.setDriverClassName(driverClassName);
            return dataSource;
        }
    
        @Bean
        public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
            SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
            sessionFactory.setDataSource(dataSource);
            sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver()
                    .getResources("classpath:mapper/*.xml"));
            return sessionFactory.getObject();
        }
    }
    

除了指定数据源 `DataSource` 对象，还需要指定 `SqlSessionFactory` 对象，因为 `MapperProxy` 类依赖它，如果不指定的话它不会自动注入。

下面来看一下 `ProjectListServiceWithConfigsTest` 的实现：

    /**
     * 指定测试依赖Bean的测试类
     */
    @SpringBootTest(classes = {
            ProjectListServiceImpl.class,
            MybatisTestConfig.class,
            ProjectConverterImpl.class
    })
    @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
    @PropertySource("classpath:application.properties")
    @DisplayName("集成测试：指定测试依赖Bean")
    class ProjectListServiceWithConfigsTest {
        private final ApplicationContext applicationContext;
    
        @Autowired
        private ProjectListServiceImpl projectListServiceUnderTest;
    
        public ProjectListServiceWithConfigsTest(ApplicationContext applicationContext) {
            this.applicationContext = applicationContext;
        }
    
        @Test
        @DisplayName("获取所有Bean名称和数量")
        public void printAllBean() {
            // 获取所有Bean名称
            String[] beanNames = applicationContext.getBeanDefinitionNames();
            Arrays.sort(beanNames);
            System.out.println("========== Spring Beans Total (" + beanNames.length + ") =========");
            for (String beanName : beanNames) {
                System.out.println("name=" + beanName + ", class=" + applicationContext.getBean(beanName).getClass());
            }
        }
    
        @Test
        @DisplayName("测试查询全部项目列表-应包含2个项目，且和数据库一致")
        void testListAllProjects() {
            List<ProjectListResponse> projectListResponses = projectListServiceUnderTest.listProjects();
    
            assertThat(projectListResponses).hasSize(2);
            assertThat(projectListResponses.getFirst().getProjectId()).isEqualTo(1);
            assertThat(projectListResponses.getFirst().getProjectName()).isEqualTo("测试项目1");
            assertThat(projectListResponses.getFirst().getProjectStatus()).isEqualTo(ProjectStatus.READY.getDesc());
    
            assertThat(projectListResponses.get(1).getProjectId()).isEqualTo(2);
            assertThat(projectListResponses.get(1).getProjectName()).isEqualTo("测试项目2");
            assertThat(projectListResponses.get(1).getProjectStatus()).isEqualTo(ProjectStatus.RUNNING.getDesc());
        }
    }
    

在上述测试类中，两个测试方法 `printAllBean()` 和 `testListAllProjects()` 实现完全一致。在类上方的注解中，我们首先通过

    @SpringBootTest(classes = {
            ProjectListServiceImpl.class,
            MybatisTestConfig.class,
            ProjectConverterImpl.class
    })
    

分别指定我们需要测试的类 `ProjectListServiceImpl`、`ProjectConverter` 接口的实现类 `ProjectConverterImpl` 以及 Mybatis 配置类 `MybatisTestConfig`。然后通过 `@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)` 让测试类不加载默认的数据源，而是加载我们在 `MybatisTestConfig` 中配置的数据源；并通过 `@PropertySource("classpath:application.properties")` 来指定我们使用的测试配置文件。

运行测试类，可以看到 `testListAllProjects()` 同样可以测试通过，且 `printAllBean()` 的结果如下：

    ========== Spring Beans Total (27) =========
    name=cn.asuka.itd.testconfig.MybatisConfig#MapperScannerRegistrar#0, class=class org.mybatis.spring.mapper.MapperScannerConfigurer
    name=dataSource, class=class com.alibaba.druid.pool.DruidDataSource
    name=hikariPoolDataSourceMetadataProvider, class=class org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration$HikariPoolDataSourceMetadataProviderConfiguration$$Lambda/0x00000205685d79a0
    name=mybatisConfig, class=class cn.asuka.itd.testconfig.MybatisConfig$$EnhancerBySpringCGLIB$$7108b66c
    name=org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory, class=class org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory
    name=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration, class=class org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
    name=org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration, class=class org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration
    name=org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration$HikariPoolDataSourceMetadataProviderConfiguration, class=class org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration$HikariPoolDataSourceMetadataProviderConfiguration
    name=org.springframework.boot.context.internalConfigurationPropertiesBinder, class=class org.springframework.boot.context.properties.ConfigurationPropertiesBinder
    name=org.springframework.boot.context.internalConfigurationPropertiesBinderFactory, class=class org.springframework.boot.context.properties.ConfigurationPropertiesBinder$Factory
    name=org.springframework.boot.context.properties.BoundConfigurationProperties, class=class org.springframework.boot.context.properties.BoundConfigurationProperties
    name=org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor, class=class org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor
    name=org.springframework.boot.context.properties.EnableConfigurationPropertiesRegistrar.methodValidationExcludeFilter, class=class org.springframework.boot.validation.beanvalidation.MethodValidationExcludeFilter$$Lambda/0x00000205685d7bb8
    name=org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration, class=class org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration
    name=org.springframework.boot.test.context.ImportsContextCustomizer$ImportsCleanupPostProcessor, class=class org.springframework.boot.test.context.ImportsContextCustomizer$ImportsCleanupPostProcessor
    name=org.springframework.boot.test.mock.mockito.MockitoPostProcessor, class=class org.springframework.boot.test.mock.mockito.MockitoPostProcessor
    name=org.springframework.boot.test.mock.mockito.MockitoPostProcessor$SpyPostProcessor, class=class org.springframework.boot.test.mock.mockito.MockitoPostProcessor$SpyPostProcessor
    name=org.springframework.context.annotation.internalAutowiredAnnotationProcessor, class=class org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
    name=org.springframework.context.annotation.internalCommonAnnotationProcessor, class=class org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
    name=org.springframework.context.annotation.internalConfigurationAnnotationProcessor, class=class org.springframework.context.annotation.ConfigurationClassPostProcessor
    name=org.springframework.context.event.internalEventListenerFactory, class=class org.springframework.context.event.DefaultEventListenerFactory
    name=org.springframework.context.event.internalEventListenerProcessor, class=class org.springframework.context.event.EventListenerMethodProcessor
    name=projectConverterImpl, class=class cn.asuka.itd.converter.ProjectConverterImpl
    name=projectListServiceImpl, class=class cn.asuka.itd.project.service.impl.ProjectListServiceImpl
    name=projectMapper, class=class jdk.proxy2.$Proxy84
    name=spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties, class=class org.springframework.boot.autoconfigure.jdbc.DataSourceProperties
    name=sqlSessionFactory, class=class org.apache.ibatis.session.defaults.DefaultSqlSessionFactory
    

可以看到只加载了 27 个 Bean，大大减少了 Bean 的加载数量，对测试运行速度提升也有帮助。

总结
--

如果需要指定需要测试的 Bean 及其依赖，而不是加载完整的上下文环境，可以在 `@SpringBootTest` 注解的 `classes` 参数中配置需要测试及依赖的类或对象。如果遇到不是项目中自己写的或者可以自动生成的实现类，可以通过配置 `@TestConfiguration` 的方式，在测试配置中注册相关的 Bean。最终做到缩小测试范围，提高测试运行效率。