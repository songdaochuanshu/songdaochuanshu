---
layout: post
title: 'Makefile极简指南'
date: "2025-11-08T00:39:23Z"
---
Makefile极简指南
============

Makefile 是嵌入式开发中不可或缺的构建工具，它能自动化编译、链接流程，支持\*\*增量构建\*\*（仅重新编译修改的文件），避免重复输入冗长命令，大幅提升开发效率。

Makefile 是嵌入式开发中不可或缺的构建工具，它能自动化编译、链接流程，支持**增量构建**（仅重新编译修改的文件），避免重复输入冗长命令，大幅提升开发效率。

一、Makefile 核心逻辑
---------------

每个 Makefile 的规则都遵循「目标 - 依赖 - 命令」的核心结构，这是 Makefile 的灵魂：

    目标: 依赖
    	命令  # 关键：命令前必须是【Tab键】，不能用空格！
    

*   **目标**：要生成的文件（如 `app.exe`、`main.o`、嵌入式固件 `firmware.elf`）或要执行的动作（如 `clean`）；
*   **依赖**：生成目标必需的文件（如 `main.c`、`add.o`）或其他目标；
*   **命令**：从依赖生成目标的具体步骤（如编译器命令 `gcc`）。

二、入门实操：从单个文件到多文件
----------------

### 1\. 第一步：单个文件编译（最简场景）

#### 项目结构

    project/
    ├── main.c  # 核心代码（含 main() 函数）
    └── Makefile  # 构建脚本（首字母大小写均可，无后缀）
    

#### 基础版本（直接编译）

    # 目标：生成 app.exe；依赖：main.c
    app.exe: main.c
    	 # 编译命令：将 main.c 生成 app.exe
    	gcc -o app.exe main.c 
    

#### 优化版本（使用变量，便于维护）

定义变量后，后续更换工具链（如嵌入式交叉编译器）时，仅需修改变量，无需改动命令：

    CC = gcc  # 编译器变量
    
    # 目标:依赖
    app.exe: main.c
     	# 变量引用语法：$(变量名)
    	$(CC) -o app.exe main.c 
    

在命令行输入`make`即可生成app.exe可执行文件。

### 2\. 第二步：多文件编译

当项目拆分多个源文件（如主程序、驱动、工具函数）时，用 `.o` 中间文件做依赖，支持**增量编译**（仅重新编译修改的文件）。

#### 项目结构

    project/
    ├── main.c    # 主程序（调用加法函数）
    ├── add.c     # 加法函数实现
    ├── add.h     # 加法函数声明（头文件）
    └── Makefile
    

#### 基础版本

    CC = gcc
    
    # 最终目标：链接所有 .o 文件生成可执行程序
    app.exe: main.o add.o
    	$(CC) -o app.exe main.o add.o  # 链接命令
    
    # 中间目标：.c 文件编译为 .o 文件（-c：只编译不链接）
    main.o: main.c add.h  # main.c 依赖 add.h（需包含函数声明）
    	$(CC) -c main.c
    
    add.o: add.c add.h
    	$(CC) -c add.c
    
    # 清理目标：删除编译产物
    .PHONY: clean  # 声明为伪目标，避免目录有clean文件时命令失效
    clean:
    	rm -f main.o add.o app.exe  # Linux/macOS
    	# del main.o add.o app.exe  # Windows 需替换为这行
    

在命令行输入`make`即可生成app.exe可执行文件，输入`make clean`即可清理编译过程中生成的中间文件

#### 增量编译优势

*   仅修改 `add.c` 时，`make` 自动检测依赖变化，仅重新编译 `add.o`，再链接生成 `app.exe`，无需编译 `main.o`，节省时间；
*   手动删除某个 `.o` 文件（如 `main.o`），`make` 会自动重新编译该文件。

### 3\. 第三步：模式规则 + 自动变量（简化代码）

上面的多文件 Makefile 中，每个 `.o` 文件的编译命令重复（`$(CC) -c XXX.c`），可用「模式规则」和「自动变量」简化，新增文件时无需修改规则。

#### 优化版本（嵌入式推荐）

    CC = gcc                  # 编译器
    OBJS = main.o add.o       # 所有中间 .o 文件（新增文件仅需添加此处）
    TARGET = app.exe          # 最终目标文件名（统一管理，便于修改）
    
    # 最终目标：链接所有依赖的 .o 文件
    $(TARGET): $(OBJS)
    	$(CC) -o $@ $^  # 自动变量：$@=目标名，$^=所有依赖
    
    # 模式规则：所有 .c 文件自动生成对应的 .o 文件（替代重复规则）
    %.o: %.c
    	$(CC) -c $< -o $@  # 自动变量：$<=第一个依赖（即 .c 文件），$@=目标（即 .o 文件）
    
    # 清理目标
    .PHONY: clean  # 声明为伪目标，避免目录有clean文件时命令失效
    clean:
    	rm -f $(OBJS) $(TARGET)  # Linux/macOS
    	# del $(OBJS) $(TARGET)  # Windows 替换
    

#### 核心自动变量（必记）

自动变量

含义

示例

`$@`

当前目标文件名

编译 `add.o` 时，`$@=add.o`；链接 `app.exe` 时，`$@=app.exe`

`$<`

第一个依赖文件名

编译 `add.o` 时，`$<=add.c`

`$^`

所有依赖文件名

链接 `app.exe` 时，`$^=main.o add.o`

#### 简化优势

*   新增源文件（如 `uart.c`）时，仅需在 `OBJS` 中添加 `uart.o`，无需新增编译规则；
*   代码无冗余，降低手写错误概率

总结
--

1.  核心规则：`目标:依赖 + Tab命令`（Tab 是关键）；
2.  变量用途：`CC`（编译器）、`CFLAGS`（编译选项）、`OBJS`（中间文件），便于维护；
3.  简化技巧：模式规则 `%.o: %.c` 减少重复代码，自动变量 `$@`/`$<`/`$^` 简化命令；
4.  嵌入式适配：替换 `CC` 为交叉编译器，添加 `MCU 架构` 和 `Thumb 指令集` 选项；
5.  增量编译：修改单个文件仅重新编译对应 `.o`，大幅节省时间。