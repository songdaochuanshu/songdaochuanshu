---
layout: post
title: 'nacos(四): 创建第一个消费者Conumer(单体)'
date: "2025-02-14T00:35:50Z"
---
nacos(四): 创建第一个消费者Conumer(单体)
-----------------------------

接上一篇[《nacos(三): 创建第一个生产者producer(单体)》](https://www.cnblogs.com/ddcoder/p/18711197)，我们这一篇实现单体的消费者功能，准备与上一次的生产者集成在一个单体项目中。

消费者的本质其实就是向nacos注册后，通过负载均衡组件LoadBalancer获取服务地址，并通过OpenFeign或者RestTemplate等方式调用生产者提供的服务。在本次实验中，使用LoadBalancer+RestTemplate进行服务调用。

创建消费者一般需要以下步骤：

**步骤一：**

添加spring-cloud-starter-alibaba-nacos-discovery依赖，向nacos注册自己。这一步和创建生产者的步骤一致，不再赘述。

**步骤二：**

在pom.xml中引入LoadBalancer（这个过程中，还是要注意版本的匹配）：

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns\="http://maven.apache.org/POM/4.0.0" xmlns:xsi\="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation\="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"\>
    <modelVersion\>4.0.0</modelVersion\>

    <groupId\>com.nacos</groupId\>
    <artifactId\>springboot</artifactId\>
    <version\>0.0.1-SNAPSHOT</version\>
    <name\>springboot</name\>
    <description\>Demo project for Spring Boot</description\>
    <packaging\>jar</packaging\>
    <properties\>
        <java.version\>1.8</java.version\>
        <project.build.sourceEncoding\>UTF-8</project.build.sourceEncoding\>
        <project.reporting.outputEncoding\>UTF-8</project.reporting.outputEncoding\>
        <spring-boot.version\>2.7.6</spring-boot.version\>
        <spring-cloud-alibaba.version\>2021.0.5.0</spring-cloud-alibaba.version\>
    </properties\>
    <dependencies\>
        <!--springboot\-->
        <dependency\>
            <groupId\>org.springframework.boot</groupId\>
            <artifactId\>spring-boot-starter</artifactId\>
        </dependency\>

        <dependency\>
            <groupId\>org.springframework.boot</groupId\>
            <artifactId\>spring-boot-starter-web</artifactId\>
        </dependency\>

        <!-- 服务发现(生产者)  \-->
        <dependency\>
            <groupId\>com.alibaba.cloud</groupId\>
            <artifactId\>spring-cloud-starter-alibaba-nacos-discovery</artifactId\>
        </dependency\>

        <!--消费者\-->
        **<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
            <version>3.1.5</version>
        </dependency>**

        <dependency\>
            <groupId\>org.springframework.boot</groupId\>
            <artifactId\>spring-boot-starter-test</artifactId\>
            <scope\>test</scope\>
        </dependency\>
    </dependencies\>
    <dependencyManagement\>
        <dependencies\>
            <dependency\>
                <groupId\>org.springframework.boot</groupId\>
                <artifactId\>spring-boot-dependencies</artifactId\>
                <version\>${spring-boot.version}</version\>
                <type\>pom</type\>
                <scope\>import</scope\>
            </dependency\>
            <dependency\>
                <groupId\>com.alibaba.cloud</groupId\>
                <artifactId\>spring-cloud-alibaba-dependencies</artifactId\>
                <version\>${spring-cloud-alibaba.version}</version\>
                <type\>pom</type\>
                <scope\>import</scope\>
            </dependency\>
        </dependencies\>
    </dependencyManagement\>

    <build\>
        <plugins\>
            <plugin\>
                <groupId\>org.apache.maven.plugins</groupId\>
                <artifactId\>maven-compiler-plugin</artifactId\>
                <version\>3.8.1</version\>
                <configuration\>
                    <source\>1.8</source\>
                    <target\>1.8</target\>
                    <encoding\>UTF-8</encoding\>
                </configuration\>
            </plugin\>
            <plugin\>
                <groupId\>org.springframework.boot</groupId\>
                <artifactId\>spring-boot-maven-plugin</artifactId\>
                <version\>${spring-boot.version}</version\>
                <configuration\>
                    <mainClass\>com.nacos.springboot.SpringbootApplication</mainClass\>
                    <skip\>false</skip\>
                </configuration\>
                <executions\>
                    <execution\>
                        <id\>repackage</id\>
                        <goals\>
                            <goal\>repackage</goal\>
                        </goals\>
                    </execution\>
                </executions\>
            </plugin\>
        </plugins\>
    </build\>

</project\>

**步骤三：**

在application.yml中，开启LoadBalancer：

server:
  port: 8085

spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
        username: nacos
        password: nacos
      config:
        server-addr: 127.0.0.1:8848
        file-extension: properties
        username: nacos
        password: nacos
    **loadbalancer:
      nacos:
        enabled: true**

  application:
    name: product1

如果没有在配置文件中开启，用服务名调用生产者的服务时，URL会解析不出来，报UnknownHostException。

**步骤四：**

添加RestTemplate的配置类

@Component
public class BeanManageConfig {

    @Bean
    **@LoadBalanced**
    public RestTemplate getRestTemplate(){
        return new RestTemplate();
    }
}

其中@LoadBalanced注解上创建出来的RestTemplate具备负载均衡的能力。

到了这一步，消费者的配置已经都准备好了。下一个步骤就是尝试调用生产者服务，确认是否可以调用成功。

**步骤五：**

在项目中创建一个Controller，尝试调用服务：

@RestController
public class Consumer {

    @Autowired
    private DiscoveryClient discoveryClient;

    @Autowired
    private RestTemplate restTemplate;

    @RequestMapping("/c/echo")
    public String echo(){
        String url \= "http://product1/hello/";
        System.out.println(url);
        ResponseEntity<String> forEntity = this.restTemplate.getForEntity(url, String.class);
        return forEntity.getBody();
    }

    @RequestMapping("/c/services")
    public String serviceslist(){
        List<ServiceInstance> instances = discoveryClient.getInstances("product1");
        if (instances != null && !instances.isEmpty()) {
            for(ServiceInstance s:instances){
                System.out.println(s.getHost()+":"+s.getPort());
            }
            return "Service found!";
        } else {
            return "Service not found!";
        }
    }
}

在这段代码中，echo()方法里调用了名为product1的生产者的服务；servicelist()方法测试product1服务是否可以获取到，并输出获取到的可用地址。

单体消费者的创建与配置到这里就结束了，关于RestTemplate的深入运用将在之后的文章中慢慢探讨。下一篇将会介绍如何操作nacos中的配置项，并定时同步远程最新配置项方法。

posted on 2025-02-13 16:30  [咚..咚](https://www.cnblogs.com/ddcoder)  阅读(58)  评论(0)  [编辑](https://i.cnblogs.com/EditPosts.aspx?postid=18713905)  [收藏](javascript:void\(0\))  [举报](javascript:void\(0\))