---
layout: post
title: '备忘录模式'
date: "2025-02-12T00:36:13Z"
---
备忘录模式
=====

备忘录模式的核心思想是将对象的状态保存在一个独立的对象中，这样既能保持对象的封装性，又能方便地恢复对象到之前的状态。

备忘录（Memento、Snapshot）模式属于行为型模式的一种。

备忘录模式主要用于捕获一个对象的内部状态，以便在将来的某个时候**恢复**此状态。

备忘录模式的核心思想是将对象的状态保存在一个独立的对象中，这样既能保持对象的封装性，又能方便地恢复对象到之前的状态。

我们使用的几乎所有软件都用到了备忘录模式。大多数软件提供的保存、打开，以及编辑过程中的Undo、Redo都是备忘录模式的应用。Java的序列化也可以看作是备忘录模式。

备忘录模式适合在有撤销操作、恢复状态、对象状态追踪等场景下使用。

备忘录模式通常有以下组成部分：

*   Memento（备忘录）：存储对象的内部状态。备忘录通常是一个不可变的对象，即在创建之后不允许更改它的内容。
*   Originator（发起人）：发起人是需要保存其状态的对象。它创建一个备忘录，保存当前的状态，并可以通过备忘录恢复到之前的状态。发起人负责生成和恢复备忘录，但它对备忘录的内部状态一无所知。
*   Caretaker（看护者）：看护者负责保存备忘录，但它不能修改备忘录的内容。看护者是一个管理者，通常用于保存多个备忘录的状态，供需要时进行恢复。

如果我们使用的编程语言支持**嵌套类**（如Java、C++、 C# 等），则可将备忘录嵌套在Originator类中； 如果不支持（如PHP等）， 那么我们可以从备忘录类中抽取一个空接口，然后让其他所有对象通过接口来引用备忘录。 我们还可以在该接口中添加一些元数据操作，但不能暴露Originator类的状态。

我们用备忘录模式实现一个简单的文本编辑器中的撤销功能。当用户输入文本时，编辑器会保存当前文本状态，这样当用户点击“撤销”按钮时，编辑器能够恢复到上一个状态。

1、Memento: 备忘录类

    // Memento: 备忘录类
    class Memento {
        private String state;
    
        public Memento(String state) {
            this.state = state;
        }
    
        public String getState() {
            return state;
        }
    }

![](https://img2024.cnblogs.com/blog/1171560/202502/1171560-20250211225040065-228103236.gif "点击并拖拽以移动")

2、Originator: 发起人类

    // Originator: 发起人类
    class TextEditor {
        private String text;
    
        public void setText(String text) {
            this.text = text;
        }
    
        public String getText() {
            return text;
        }
    
        // 创建备忘录
        public Memento saveToMemento() {
            return new Memento(text);
        }
    
        // 恢复状态
        public void restoreFromMemento(Memento memento) {
            this.text = memento.getState();
        }
    }

![](https://img2024.cnblogs.com/blog/1171560/202502/1171560-20250211225040065-228103236.gif "点击并拖拽以移动")

3、Caretaker: 看护者类

    // Caretaker: 看护者类
    class TextEditorHistory {
        private List<Memento> mementoList = new ArrayList<>();
    
        // 保存备忘录
        public void addMemento(Memento memento) {
            mementoList.add(memento);
        }
    
        // 获取特定索引的备忘录
        public Memento getMemento(int index) {
            return mementoList.get(index);
        }
    }

![](https://img2024.cnblogs.com/blog/1171560/202502/1171560-20250211225040065-228103236.gif "点击并拖拽以移动")

4、客户端

    // 客户端代码
    public class MementoPatternDemo {
        public static void main(String[] args) {
            TextEditor editor = new TextEditor();
            TextEditorHistory history = new TextEditorHistory();
    
            editor.setText("Hello");
            history.addMemento(editor.saveToMemento()); // 保存当前状态
    
            editor.setText("Hello, World!");
            history.addMemento(editor.saveToMemento()); // 保存当前状态
    
            editor.setText("Hello, World! How are you?");
            System.out.println("Current Text: " + editor.getText());
    
            // 恢复到上一个状态
            editor.restoreFromMemento(history.getMemento(1));
            System.out.println("After undo: " + editor.getText());
    
            // 恢复到最初状态
            editor.restoreFromMemento(history.getMemento(0));
            System.out.println("After undo again: " + editor.getText());
        }
    }

![](https://img2024.cnblogs.com/blog/1171560/202502/1171560-20250211225040065-228103236.gif "点击并拖拽以移动")

备忘录模式的**优缺点**。

优点：

*   保持封装性：备忘录模式允许将对象的状态保存在外部，但不暴露对象的内部实现。发起人对象可以将状态保存在备忘录中，而无需让其他对象直接访问内部状态。
*   简化恢复操作：通过备忘录，系统可以轻松地将对象恢复到之前的状态，而无需手动追踪每个状态的变更。
*   支持多次恢复：可以创建多个备忘录对象，用于在不同的时刻恢复到不同的状态。

缺点：

*   增加了系统的复杂性：备忘录模式涉及多个对象的协作，可能会导致系统设计更加复杂。
*   内存消耗大：每次状态变更都会创建一个新的备忘录，这可能导致内存消耗较大，尤其是状态变化频繁时。
*   备忘录管理问题：如果管理不当，备忘录可能会堆积成大量的无用对象，需要额外的清理策略。

我们可以同时使用**命令模式**和**备忘录模式**来实现 “撤销”功能。命令用于对目标对象执行各种不同的操作，备忘录用来保存一条命令执行前该对象的状态。

人生的确充满艰难险阻，但回荡不息的主旋律，是不期而遇的温暖和生生不息的希望。-- 烟沙九洲