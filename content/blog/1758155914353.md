---
layout: post
title: 'C++ 模板参数推导问题小记（模板类的模板构造函数）'
date: "2025-09-18T00:38:34Z"
---
C++ 模板参数推导问题小记（模板类的模板构造函数）
==========================

本篇主要是为了记录在编写一个模板类的模板构造函数中遇到的初始化问题，以及针对这个问题展开的相关知识整理，文章就以引发这个问题的代码为标题了。

问题代码
====

在编写一个代表空间点的模板类 `point` 时，我打算为它添加一个模板构造函数：

代码

    
    template<typename T, std::size_t N>
    struct point
    {
        using value_type = scalar<T>;
        value_type _v[N];
        point() : _v{ value_type{} } {}
        template<typename U>
        explicit point(const U (&arr)[N])
        {
            if constexpr(std::is_same_v<value_type, U>)
                memcpy(_v, arr, n * sizeof(value_type));
            else
            {
                for(std::size_t i = 0; i != N; ++i)
                    _v[i] = static_cast<value_type>(arr[i]);//抑制“”
            }
        }
    };
    point<int, 3> pi3({ 0, 1, 2 });

代码中的 `scalar` 是 [这篇](https://www.cnblogs.com/saltymilk/p/19013086) 笔记中提到用于类型限制的别名模板，用以排除非数值类型的模板实例化。

`template<typename U> point(const U (&arr)[N])` 这个构造函数的意图是 `point` 只接受长度为 `N` 的数组进行初始化。

一切看起来没什么问题，但是当我写下这样的初始化代码时，发现代码仍然能够正常通过编译：

代码

    
    point<int, 3> pi3({ 0, 1 });
    {{the-copyright}}*本*文*由*博*客*园* @saltymilk *原*创*{{/the-copyright}}

为什么料想之中的长度限制并没有起作用？

问题分析
====

分析 `point<int, 3> pi3({ 0, 1 });` 这句代码，编译器是如何处理它的：

1\. `point<int, 3> pi3` 指定了 `pi3` 这个实例的 `T` 为 `int`，`N` 为 `3`；

2\. `pi3({ 0, 1 })` 是一个单参数构造语句，尝试匹配接受单个参数的构造函数，匹配到接受数组引用的自定义构造函数 `template<typename U> point<int, 3>::point(const U (&arr)[3])`；

3\. 根据调用参数 `{ 0, 1 }`，即 `[int, int]` 推导 `U` 为 `int`，构造函数实例化为 `point<int, 3>::point<int>(const int (&arr)[3])`;

4\. 使用 `{ 0, 1 }` 对一个临时的 `int [3]` 进行列表初始化，初始化结果为 `{ 0, 1, 0 }`，随后传入构造函数。

`point` 类的模板参数 `N` 在类的实例化时被指定为 `3`，在成员模板构造函数实例化期间它是已知的，函数参数推导过程对它没有任何影响，这句代码能够通过编译的根本原因是长度为 `3` 的数组能够被只有 `2` 个元素的初始化列表初始化。

而我由于对初始化细节了解不全面，加之模板代码对问题分析有一定的干扰，让我一时没有抓住本质，写出了这段一厢情愿的代码。

问题解决
====

解决方法很简单，把数组的维度也作为模板参数参与推导，然后对它进行约束就能实现这个目的了：

代码

    
    template<typename U, std::size_t M, typename = std::enable_if_t<M == N>>
    explicit point(const U (&arr)[M])
    {
        //...
    };
    int iarr[] = { 0, 1, 2 };
    point<int, 3> pi30(iarr);//OK
    point<int, 3> pi31({ 0, 1, 2 });//OK
    point<int, 3> pi3({ 0, 1 });//无法通过编译
    {{the-copyright}}*本*文*由*博*客*园* @saltymilk *原*创*{{/the-copyright}}

现在数组的维度 `M` 需要从构造函数的参数推导出来，如果 `M` 与 `N` 不相等，构造函数实例化失败。

问题到此就可以结束了，但是不妨来分析一下 `({ ... })` 这种初始化写法。

C++ 的初始化
========

首先复习一下基础知识，不考虑拷贝构造的情况下，C++ 的初始化有两种：

1\. `(...)`，即直接初始化
------------------

这种调用适用于类类型，直接要求调用类的某个构造函数。所有用户自定义和编译器合成版本的构造函数都会被加入候选列表，随后根据重载函数匹配规则选出匹配度最高的一个进行调用，无匹配项或多个项都具有最佳匹配度时匹配失败。

这种初始化语法有个缺陷 —— 可能会被解析为函数声明，在这些情况下，解析的结果往往很反直觉，所以被称为 [最令人烦恼的解析](https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BB%A4%E4%BA%BA%E7%83%A6%E6%81%BC%E7%9A%84%E8%A7%A3%E6%9E%90
)。

2\. `= { ... }` & `{ ... }`，即 [列表初始化](https://en.cppreference.com/w/cpp/language/list_initialization.html)
----------------------------------------------------------------------------------------------------------

在 C++11 标准之前，列表初始化只能用来对 [聚合类型](https://cppreference.com/w/cpp/language/aggregate_initialization.html#Definitions) 进行初始化。上文中使用 `{ 0, 1 }` 将一个临时的 `int [3]` 初始化为 `{ 0, 1, 0 }` 就属于聚合类型的列表初始化。更加详细的规则不是本文的重点关注对象，感兴趣的话可以到 [这里](https://cppreference.com/w/cpp/language/aggregate_initialization) 阅读。

值得一提的是，MSVC（测试版本为 \_MSC\_VER=1943）支持使用 `(...)` 对聚合类型进行列表初始化，但这并不被 C++ 标准采纳，属于 MSVC 方言，不具备可移植性，使用时须当心。

C++11 引入了统一初始化语法，使得任何类型都能够使用列表初始化语法进行初始化，同时新增了 `std::initializer_list` 来支持统一的列表初始化语法。

列表初始化语法杜绝了将初始化语句解析为函数声明语句的可能，并且阻止了 [窄化转换](https://en.cppreference.com/w/cpp/language/list_initialization.html#Narrowing_conversions)，使初始化更加简洁安全。

在使用列表初始化器初始化对象时，接受 `std::initializer_list` 的构造函数具有无与伦比的重载匹配优先级，即使无法正确构造一个 `std::initializer_list` 且其他函数能够精确匹配参数时也可能直接屏蔽其他构造函数，直接报错而不尝试其他重载版本（Scott Meyers, Effective Modern C++, Item 7）。所以除非你非常确定自己的类需要一个接受 `std::initializer_list` 的构造函数，并且你能够正确处理它与其他构造函数的关系，不要轻易定义这个构造函数。

`({ ... })` 是如何解析的
==================

有了前面的铺垫，这个初始化语句就很好理解了。外层的 `()` 指定要调用某个函数，该函数能够匹配只有一个参数的调用形式，内层的 `{ ... }` 作为一个初始化列表对这个参数进行初始化。

[列表初始化](https://en.cppreference.com/w/cpp/language/list_initialization.html#Copy-list-initialization) 指定的情形是直接包含这种初始化形式的，并且解释得非常详细：

![copy-list-initialization](https://img2024.cnblogs.com/blog/3635299/202509/3635299-20250902182849797-1642037269.png)

其实我们平时也经常在函数调用时使用这种语法：

代码

    
    void foo(int i, const std::vector &vec);//函数签名
    foo(0, { 0, 1, 2 });//调用

当它被用于类的初始化时，编译器自动匹配构造函数调用，匹配规则与普通函数是一样的。

再探 `point` 的初始化
===============

前面对 `point` 构造的分析只是简化版，让我们再次详细分析这一句代码的解析过程：

`point pi3({ 0, 1 });` 这个调用中的 `({ 0, 1 })` 会匹配所有接受单个参数、名为 `point` 的函数。查看一下候选的函数，编译器发现有三个：用户定义的接受数组引用的构造函数，自动合成的拷贝构造函数，以及自动合成的移动构造函数。分别分析它们的匹配情况：

匹配接受数组引用的构造函数 `point<int, 3>::point<int>(const int (&arr)[3])`，此构造函数的形参是 `const int (&)[3]`。根据聚合类型的列表初始化规则，指定长度的数组可被元素数量小于或等于其长度的初始化列表初始化。此处创建一个临时数组 `int [3]` 并且被初始化为 `{ 0, 1, 0 }`，绑定到数组引用形参上，函数匹配成功。

匹配拷贝构造函数 `point<int, 3>::point(const point<int, 3> &)`，其形参是 `const point<int, 3> &`。这里需要创建一个临时的 `point<int, 3>`，相当于 `point<int, 3> temp{ 0, 1 };`。显然，`point<int, 3>` 既不是聚合类型，也没有接受 `(int, int)` 的构造函数，更没有接受 `std::initializer_list` 的构造函数。这样一个临时的变量无法被创建出来，所以拷贝构造函数匹配失败。

移动构造函数的情形与拷贝构造函数相同，无法匹配。

最终，自定义的那个接受数组引用的构造函数被选中用来初始化这个 `point<int, 3>` 实例。

语义检查与优化
=======

`point` 类的定义使得 `({ 0, 1 })` 无法匹配到拷贝构造或移动构造函数，但是如果我们定义下面这样一个能被两个 `int` 参数构造的类：

代码

    
    struct S
    {
        S(int, int) {}
        //S(const S &) = delete;//如果删除拷贝构造函数，按照语言规则，移动构造函数也不会自动合成
    };
    S s({ 0, 1 });//若拷贝构造函数被删除，无法通过编译
    S s1 = S{ 0, 1 };//若拷贝构造函数被删除，可以通过编译（C++17之后）
    {{the-copyright}}*本*文*由*博*客*园* @saltymilk *原*创*{{/the-copyright}}

按照前面讲述的，`s` 的构造会调用用户定义的构造函数和编译器合成的移动构造函数，即先构造一个临时的 `S` 对象，再用这个临时对象调用移动构造函数。这样的构造过程显然是冗余的，中间这个临时对象被创建出来后立即用于后续的构造，没有任何可能会被修改，所以它的构造完全可以直接发生在最终目标位置。

大多数编译器确实会优化掉这个中间过程，但是如果我们像代码注释中那样让 `S` 的移动构造函数和拷贝构造函数不可用，编译器会提示 `s` 的构造中引用了被删除的函数。那些确实会执行这项优化的编译器，为什么必须检查一定不会被引用的函数的可用性呢？

这是因为编译器执行代码优化的基础是代码必须按照语言标准进行编写，而确保代码符合语言标准的工作是由语义检查环节完成的。也就是说，代码优化必须在语义检查通过后才能执行（实际的编译中这两个环节之间还会有其他操作），那么为什么语义同样是调用移动构造函数的 `s1` 构造语句不会报错呢？

我们知道，从 C++17 开始，有一些 [拷贝省略](https://en.cppreference.com/w/cpp/language/copy_elision.html#Example) 是强制施行的，即原来这些被视作优化的拷贝省略形式被纳入标准行为。其中就包括上述代码中 `s1` 的构造情形：

![mandatory-copy-elision](https://img2024.cnblogs.com/blog/3635299/202509/3635299-20250903175448238-1649234777.png)

既然 `s1` 构造中省略拷贝步骤已是标准行为，编译器的语义检测就只需要检查对应的构造函数可用性就行了（前提是设置编译器的语言标准大于 C++17）。

而 `s` 的构造语句形式不在强制拷贝省略的情形之列，所以如果拷贝构造函数和移动构造函数都不可用，语义检查将不能通过。

总而言之，符合优化条件但未遵守语言标准的代码绝不会因为能够被优化而通过语义检查。

编写支持统一初始化语法的 `point` 类
======================

`point` 必须以两重括号的形式初始化总让人感觉不自然，我们可以尝试让它支持统一初始化语法，在前面的基础上需要保证三点：语法形式的支持、实参个数限制、窄化转换限制。

利用 `std::initializer_list`
--------------------------

我们来尝试一下利用 `std::initializer_list`：

代码

    
    template<typename T, std::size_t N>
    struct point
    {
        using value_type = scalar<T>;
        value_type _v[N];
        point() : _v{ value_type{} } { }
        template<typename U>
        explicit point(std::initializer_list<U> il)
        {
            //static_assert(il.size() == N, "argument number mismatch.");//可行吗？
            //...
        }
    };

很快我们的尝试就遇到一个问题，如何在编译时限制传入 `std::initializer_list` 的长度。上述代码中这个静态断言会出现编译错误，编译器会提示 `il.size()` 不是编译期常量，不能用于静态断言环境。

[`std::initializer_list::size()`](https://en.cppreference.com/w/cpp/utility/initializer_list/size) 从 C++14 开始被标记为 `constexpr`，为什么它无法用于静态断言？这涉及 `constexpr` 函数的特性，`constexpr` 标识符声明一个返回值有可能在编译期求值的函数，但是它必须满足 [编译期求值的条件](https://en.cppreference.com/w/cpp/language/constexpr.html#constexpr_function)。此处传入的这个 `il` 是一个运行期构造的变量，显然不符合编译期常量求值环境。

看来这条路走不通，得另寻他法。

可变参数模板构造函数
----------

我们可以为 `point` 编写一个接受参数包的模板构造函数：

代码

    
    template<typename T, std::size_t N>
    struct point
    {
        using value_type = scalar<T>;
        value_type _v[N];
        point() : _v{ value_type{} } { }
        template<typename... Args, typename = std::enable_if_t<sizeof...(Args) == N>>
        explicit point(scalar<Args>&&... args)
        {
            //...
        }
    };

参数包展开中使用 `scalar` 限制参数为算术类型，这是为了防止这个模板函数被实例化为拷贝构造函数或者移动构造函数。在本例中即使不限制这个类型，也只在恰好 `N == 1` 时可能出现（实际的代码中创建一个一维点没什么意义），而且 `explicit` 的拷贝函数也很难匹配上大多数的拷贝语境，但是我在其他地方确实被这样的匹配坑过，这样的代码行为可能会让人意外，所以此处特意一提。

这个版本的构造函数已经能够很好地支持统一初始化语法和参数数量限制了，但是它还有一点未实现：限制数值窄化转换。

尝试实现 为了实现这个目标，我首先看了一下标准库是否直接提供这样的 `traits`，可惜并未找到，于是去网上搜索是否有什么实现思路，确实找到了一篇 [博客](https://riccibruno.github.io/2018/04/27/c++_is_narrowing_conversion_type_trait) 详细说明了实现思路，并指出关键点是 C++ 的拷贝列表初始化语法不允许窄化转换：

![narrowing conversion](https://img2024.cnblogs.com/blog/3635299/202509/3635299-20250908182208962-754779539.png)

这段话让我大受启发，虽然这篇博客中实现的窄化检查是两个类型之间的，对它稍加改造就可以检测参数包了：

代码

    
    //仅用于类型推导的空类
    struct dummy { };
    //单参数窄化转换检查辅助函数
    template<typename T>
    dummy narrowing_conversion_check(T);
    //参数包窄化转换检查类，通过折叠表达式对参数包逐一进行窄化转换检查
    template<typename T, typename... Args>
    struct narrowing_conversion_guard : decltype(((narrowing_conversion_check<T>({ std::declval<Args>() })), ...)) { };
    template<typename... Args,
    typename = std::enable_if_t<sizeof...(Args) == N>,
    typename = narrowing_conversion_guard<T, Args...>>//在point的构造函数中使用它
    point(scalar<Args>&&... args) : _v{ std::forward<Args>(args)... } { }

发现已有机制 刚写完这个检测类我就恍然大悟，数组成员 `_v` 是直接支持列表初始化的，编译器自然而然会在列表初始化时进行窄化转换检查，所以在这种情况下没有必要手动检查，真是得来全不费功夫啊：

代码

    
    template<typename T, std::size_t N>
    struct point
    {
        using value_type = scalar<T>;
        value_type _v[N];
        point() : _v{ value_type{} } { }
        template<typename... Args, typename = std::enable_if_t<sizeof...(Args) == N>>
        explicit point(scalar<Args>&&... args) : _v{ std::forward<Args>(args)... } { }
    };
    point<int, 3> pi30{ 0, 1, 2 };//OK
    point<int, 3> pi31{ 0, 1 };//错误：需要3个参数，实际提供了2个参数
    point<int, 2> pi2{ 1, 2.0 };//错误：列表初始化中无法将double窄化转换为int

对于一个空间点类，要么默认构造为全 `0`，要么指定所有元素的初值是合理的，因为这两种构造都符合一般直觉，并且空间点的维度 `N` 几乎不会取到大于 `4`，不会在逐一指定初值时造成编码负担。如果我们设计一个构造函数，它接受的参数数量可以不等于点的元素数量，并且没有给出注释说明在两者不相等时的构造行为，就会给使用者带来一些困扰并且可能造成被误用。

总结
==

作为一篇知识点整理笔记，本文内容写的比较杂，此处作一个简单总结：

1\. 模板代码往往比普通代码需要更复杂的理解能力，所以在编写模板代码时，一些隐藏的语言规则问题更难被发觉；

2\. 语义检查和代码优化的关系可以解释这样一个问题：为什么有些理论上会被执行的代码最终却没有被执行，既然没被执行，我们不定义（或阻止编译器生成）它们为什么又无法成功编译；

3\. 正如 Scott Meyers, Effective C++, Item 18 所说，让接口容易被正确使用，不易被误用，花费时间琢磨如何设计更加符合普遍直觉且行为一致的接口是值得的。初始化作为基础中的基础，值得透彻研究，这有助于设计语义清晰，更易被正确使用的接口；

本文来自博客园，作者：[saltymilk](https://www.cnblogs.com/saltymilk/)，转载请注明原文链接：[https://www.cnblogs.com/saltymilk/p/19031419](https://www.cnblogs.com/saltymilk/p/19031419)