---
layout: post
title: '7. RabbitMQ 消息队列——延时队列(Spring Boot + 安装message_exchange"延迟插件" 的详细配置说明)的详细讲解'
date: "2025-04-07T00:40:35Z"
---
7\. RabbitMQ 消息队列——延时队列(Spring Boot + 安装message\_exchange"延迟插件" 的详细配置说明)的详细讲解
=============================================================================

7\. RabbitMQ 消息队列——延时队列(Spring Boot + 安装message\_exchange"延迟插件" 的详细配置说明)的详细讲解
=============================================================================

@

目录

*   [7\. RabbitMQ 消息队列——延时队列(Spring Boot + 安装message\_exchange"延迟插件" 的详细配置说明)的详细讲解](#7-rabbitmq-消息队列延时队列spring-boot--安装message_exchange延迟插件-的详细配置说明的详细讲解)
*   [1\. RabbitMQ 延时队列概述](#1-rabbitmq-延时队列概述)
*   [2\. RabbitMQ 中的 TTL](#2-rabbitmq-中的-ttl)
*   [3\. RabbitMQ 整合 Spring Boot](#3--rabbitmq-整合-spring-boot)
    *   [3.1 Spring Boot 当中搭建配置 RabbitMQ 的 队列 TTL(延时队列)](#31--spring-boot-当中搭建配置-rabbitmq-的-队列-ttl延时队列)
*   [null](#_)
    *   [3.2 延时队列优化](#32-延时队列优化)
    *   [3.3 Rabbitmq 插件实现延迟队列](#33-rabbitmq-插件实现延迟队列)
*   [4\. 补充：Docker 容器当中安装 message\_exchange"延迟插件" 的详细步骤](#4-补充docker-容器当中安装-message_exchange延迟插件-的详细步骤)
*   [5\. 最后：](#5-最后)

1\. RabbitMQ 延时队列概述
===================

延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。

**延时队列的应用场景：**

> 场景：有一个订单，15 分钟内如果不支付，就把该订单设置为交易关闭，那么就不能再进行支付了，这类实现延迟任务的场景就可以采用延时队列的方式来实现，当然除了延时队列，还可以采用其它的方式——> 定时任务的方式。

1.  订单在十分钟之内未支付则自动取消。
2.  新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。
3.  用户注册后，如果三天内没有登陆则进行短信提醒。
4.  用户发起退款，如果三天内没有得到处理则通知相关运营人员。
5.  预定会议后，需要在预定的时间点前 10 分钟，通知各个参会人员参加会议。

这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎 使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果 数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支 付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十 分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万 级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单 的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428576-774380403.png)

2\. RabbitMQ 中的 TTL
===================

TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者队列中的所有消息的最大存活时间。

单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为 **“死信 ”** 。如果同时配置了队列的 TTL 和消息的 TTL ，那么较小的那个值将会被使用，有两种方式设置了 TTL 。

**消息设置 TTL：**

另一种方式便是针对每条消息设置 TTL

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428579-301523000.png)

**队列设置 TTL：**

第一种是在创建队列的时候设置队列的 `“x-message-ttl ”` 属性。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428601-390382379.png)

**延时队列 和 死信队列：**

如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队 列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为**消息是否过期是在即将投递到消费者 之前判定的**，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需 要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以 直接投递该消息到消费者，否则该消息将会被丢弃。

上一篇我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已 经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延 时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为 里面的消息都是希望被立即处理的消息。

3\. RabbitMQ 整合 Spring Boot
===========================

**1\. 创建项目**  
![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428605-519347160.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428651-237240065.png)

**添加相关依赖，在 `pom.xml` 文件当中**

    
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>
    
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <scope>test</scope>
            </dependency>
    
            <!--RabbitMQ 依赖-->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-amqp</artifactId>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>
            </dependency>
    
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>1.2.47</version>
            </dependency>
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
            </dependency>
            <!--swagger-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>2.9.2</version>
            </dependency>
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger-ui</artifactId>
                <version>2.9.2</version>
            </dependency>
            <!--RabbitMQ 测试依赖-->
            <dependency>
                <groupId>org.springframework.amqp</groupId>
                <artifactId>spring-rabbit-test</artifactId>
                <scope>test</scope>
            </dependency>
        </dependencies>
    
    

    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.5.3</version>
            <relativePath/> <!-- lookup parent from repository -->
        </parent>
        <groupId>com.rainbowsea</groupId>
        <artifactId>springboot-rabbitmq</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <name>springboot-rabbitmq</name>
        <description>Demo project for Spring Boot</description>
    
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>
    
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <scope>test</scope>
            </dependency>
    
            <!--RabbitMQ 依赖-->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-amqp</artifactId>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>
            </dependency>
    
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>1.2.47</version>
            </dependency>
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
            </dependency>
            <!--swagger-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>2.9.2</version>
            </dependency>
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger-ui</artifactId>
                <version>2.9.2</version>
            </dependency>
            <!--RabbitMQ 测试依赖-->
            <dependency>
                <groupId>org.springframework.amqp</groupId>
                <artifactId>spring-rabbit-test</artifactId>
                <scope>test</scope>
            </dependency>
        </dependencies>
    
    
    </project>
    
    

**在 `resources/创建一个 application.properties` 文件当中(当然也可以使用 `yaml` 配置文件)，配置相关的配置文件**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428644-1852372030.png)

    spring.rabbitmq.host=192.168.76.156
    spring.rabbitmq.port=5672
    spring.rabbitmq.username=admin
    spring.rabbitmq.password=123
    

**添加 Swagger 配置类**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428640-1022756704.png)

    package com.rainbowsea.rabbitmq.springbootrabbitmq.config;
    
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import springfox.documentation.builders.ApiInfoBuilder;
    import springfox.documentation.service.ApiInfo;
    import springfox.documentation.service.Contact;
    import springfox.documentation.spi.DocumentationType;
    import springfox.documentation.spring.web.plugins.Docket;
    import springfox.documentation.swagger2.annotations.EnableSwagger2;
    
    @Configuration
    @EnableSwagger2
    public class SwaggerConfig {
        @Bean
        public Docket webApiConfig() {
            return new Docket(DocumentationType.SWAGGER_2)
                    .groupName("webApi")
                    .apiInfo(webApiInfo())
                    .select()
                    .build();
        }
    
        private ApiInfo webApiInfo() {
            return new ApiInfoBuilder()
                    .title("rabbitmq 接口文档")
                    .description("本文档描述了 rabbitmq 微服务接口定义")
                    .version("1.0")
                    .contact(new Contact("enjoy6288", "http://rainbowsea.com", "3339966@qq.com"))
                    .build();
        }
    }
    

3.1 Spring Boot 当中搭建配置 RabbitMQ 的 队列 TTL(延时队列)
----------------------------------------------

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428577-1684540341.png)

**代码架构图：**

创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428560-783473547.png)

**1\. 创建文件类代码（该代码就是用于配置 RabbitMQ 当中的交换机和队列的信息配置的），作为一个配置类存在的** 。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428640-1008210609.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428671-1207320563.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428602-1347363408.png)

    
    import org.springframework.amqp.core.Binding;
    import org.springframework.amqp.core.BindingBuilder;
    import org.springframework.amqp.core.DirectExchange;
    import org.springframework.amqp.core.Queue;
    import org.springframework.amqp.core.QueueBuilder;
    import org.springframework.beans.factory.annotation.Qualifier;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    import java.util.HashMap;
    import java.util.Map;
    
    @Configuration  // 标注是一个配置类，加载到 IOC 容器当中
    public class TtlQueueConfig {
    
        // 普通交换机的名称
        public static final String X_EXCHANGE = "X";
    
        // 声明 XExchange 别名；会注入到 IOC 容器当中 普通交换机的
        @Bean(value = "xExchange")
        public DirectExchange xExchange() {
            return new DirectExchange(X_EXCHANGE);
        }
    
    }
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428603-1639140093.png)

    package com.rainbowsea.rabbitmq.springbootrabbitmq.config;
    
    
    import org.springframework.amqp.core.Binding;
    import org.springframework.amqp.core.BindingBuilder;
    import org.springframework.amqp.core.DirectExchange;
    import org.springframework.amqp.core.Queue;
    import org.springframework.amqp.core.QueueBuilder;
    import org.springframework.beans.factory.annotation.Qualifier;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    import java.util.HashMap;
    import java.util.Map;
    
    @Configuration  // 标注是一个配置类，加载到 IOC 容器当中
    public class TtlQueueConfig {
    
        // 普通交换机的名称
        public static final String X_EXCHANGE = "X";
        // 死信队列的名称
        public static final String DEAD_LETTER_QUEUE = "QD";
    
        // 死信交换机的名称
        public static final String Y_DEAD_LETTER_EXCHANGE = "Y";
        // 普通队列的名称
        public static final String QUEUE_A = "QA";
        public static final String QUEUE_B = "QB";
    
        // 声明普通队列 TTL 为 10s
        @Bean("queueA")
        public Queue queueA() {
            // 创建一个 Map 用于存放，设置队列信息
            Map<String, Object> arguments = new HashMap<>(3);
            // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
            arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
            // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
            arguments.put("x-dead-letter-routing-key", "YD");
            // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
            arguments.put("x-message-ttl", 10000);
    
            return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();
        }
    
    
        // 声明普通队列 TTL 为 40s
        @Bean("queueB")
        public Queue queueB() {
            // 创建一个 Map 用于存放，设置队列信息
            Map<String, Object> arguments = new HashMap<>(3);
            // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
            arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
            // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
            arguments.put("x-dead-letter-routing-key", "YD");
            // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
            arguments.put("x-message-ttl", 40000);
    
            return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
        }
    
    
    }
    
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428559-914770760.png)

     // 声明死信队列
        @Bean("queueD")
        public Queue queueD() {
            //  不带参数，就不需要 .withArguments(arguments)
            //return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
            return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();
        }
    
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428615-973761147.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428559-1586287764.png)

    // 绑定
    
        /**
         * 注意：这里的  public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
         *                                   @Qualifier("xExchange") DirectExchange xExchange)
         *
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier 参数内的值是，我们上边：  @Bean(value = "xExchange")，@Bean("queueA") 注入到 IOC 容器当中的值
         * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
         *  @Bean(value = "xExchange")
         *     public DirectExchange xExchange() {
         * @Bean("queueA") public Queue queueA() {
         */
        @Bean
        public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
                                      @Qualifier("xExchange") DirectExchange xExchange) {
            // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
            // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XA"
            // 表示将 队列 queueA 与 xExchange 交换机，通过 routingKey 为 "XA" 进行一个绑定
            return BindingBuilder.bind(queueA).to(xExchange).with("XA");
        }
    

**完整配置代码如下：**

    package com.rainbowsea.rabbitmq.springbootrabbitmq.config;
    
    
    import org.springframework.amqp.core.Binding;
    import org.springframework.amqp.core.BindingBuilder;
    import org.springframework.amqp.core.DirectExchange;
    import org.springframework.amqp.core.Queue;
    import org.springframework.amqp.core.QueueBuilder;
    import org.springframework.beans.factory.annotation.Qualifier;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    import java.util.HashMap;
    import java.util.Map;
    
    @Configuration  // 标注是一个配置类，加载到 IOC 容器当中
    public class TtlQueueConfig {
    
        // 普通交换机的名称
        public static final String X_EXCHANGE = "X";
        // 死信队列的名称
        public static final String DEAD_LETTER_QUEUE = "QD";
    
        // 死信交换机的名称
        public static final String Y_DEAD_LETTER_EXCHANGE = "Y";
        // 普通队列的名称
        public static final String QUEUE_A = "QA";
        public static final String QUEUE_B = "QB";
    
        // 声明 XExchange 别名；会注入到 IOC 容器当中 普通交换机的
        @Bean(value = "xExchange")
        public DirectExchange xExchange() {
            return new DirectExchange(X_EXCHANGE);
        }
    
    
        // 声明 yExchange 别名；会注入到 IOC 容器当中 普通交换机的
        @Bean(value = "yExchange")
        public DirectExchange yExchange() {
            return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);
        }
    
        // 声明普通队列 TTL 为 10s
        @Bean("queueA")
        public Queue queueA() {
            // 创建一个 Map 用于存放，设置队列信息
            Map<String, Object> arguments = new HashMap<>(3);
            // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
            arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
            // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
            arguments.put("x-dead-letter-routing-key", "YD");
            // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
            arguments.put("x-message-ttl", 10000);
    
            return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();
        }
    
    
        // 声明普通队列 TTL 为 40s
        @Bean("queueB")
        public Queue queueB() {
            // 创建一个 Map 用于存放，设置队列信息
            Map<String, Object> arguments = new HashMap<>(3);
            // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
            arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
            // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
            arguments.put("x-dead-letter-routing-key", "YD");
            // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
            arguments.put("x-message-ttl", 40000);
    
            return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
        }
    
    
        // 声明死信队列
        @Bean("queueD")
        public Queue queueD() {
            //  不带参数，就不需要 .withArguments(arguments)
            //return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
            return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();
        }
    
    
        // 绑定
    
        /**
         * 注意：这里的  public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
         *                                   @Qualifier("xExchange") DirectExchange xExchange)
         *
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier 参数内的值是，我们上边：  @Bean(value = "xExchange")，@Bean("queueA") 注入到 IOC 容器当中的值
         * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
         *  @Bean(value = "xExchange")
         *     public DirectExchange xExchange() {
         * @Bean("queueA") public Queue queueA() {
         */
        @Bean  // 绑定也是要注入到 IOC 容器当中的
        public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
                                      @Qualifier("xExchange") DirectExchange xExchange) {
            // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
            // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XA"
            // 表示将 队列 queueA 与 xExchange 交换机，通过 routingKey 为 "XA" 进行一个绑定
            return BindingBuilder.bind(queueA).to(xExchange).with("XA");
        }
    
    
        // 绑定
    
        /**
         * 注意：这里的  public Binding queueBBindingX(@Qualifier("queueB") Queue queueB,
         *                                   @Qualifier("xExchange") DirectExchange xExchange)
         *
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier 参数内的值是，我们上边：  @Bean(value = "xExchange")，@Bean("queueB") 注入到 IOC 容器当中的值
         * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
         *  @Bean(value = "xExchange")
         *     public DirectExchange xExchange() {
         * @Bean("queueB") public Queue queueB() {
         */
        @Bean  // 绑定也是要注入到 IOC 容器当中的
        public Binding queueBBindingX(@Qualifier("queueB") Queue queueB,
                                      @Qualifier("xExchange") DirectExchange xExchange) {
            // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
            // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XB"
            // 表示将 队列 queueB 与 xExchange 交换机，通过 routingKey 为 "XB" 进行一个绑定
            return BindingBuilder.bind(queueB).to(xExchange).with("XB");
        }
    
    
        // 绑定
    
        /**
         * 注意：这里的  public Binding queueDBindingX(@Qualifier("queueD") Queue queueD,
         *                                   @Qualifier("yExchange") DirectExchange yExchange)
         *
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier 参数内的值是，我们上边：  @Bean(value = "yExchange")，@Bean("queueD") 注入到 IOC 容器当中的值
         * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
         * @Bean(value = "yExchange")
         * public DirectExchange yExchange() {
         * @Bean("queueD")
         *     public Queue queueD() {
         */
        @Bean // 绑定也是要注入到 IOC 容器当中的
        public Binding queueDBindingX(@Qualifier("queueD") Queue queueD,
                                      @Qualifier("yExchange") DirectExchange yExchange) {
            // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
            // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"YD"
            // 表示将 队列 queueD 与 yExchange 交换机，通过 routingKey 为 "YD" 进行一个绑定
            return BindingBuilder.bind(queueD).to(yExchange).with("YD");
        }
    
    
    }
    
    

**生产者——》发送消息的代码：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428601-668428967.png)

    package com.rainbowsea.rabbitmq.springbootrabbitmq.controller;
    
    
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.amqp.rabbit.core.RabbitTemplate;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;
    
    import javax.annotation.Resource;
    import java.util.Date;
    
    /**
     * 生产者：发送延时消息
     * http://localhost:8080/ttl/sendMsg/嘻嘻嘻
     */
    
    
    @RestController
    @RequestMapping("/ttl")
    @Slf4j
    public class SendMsgController {
    
        @Resource  // 注入到 IOC 容器当中
        private RabbitTemplate rabbitTemplate;
    
    
        @GetMapping("/sendMsg/{message}")
        public void sendMsg(@PathVariable String message) {
            log.info("当前时间:{},发送一条消息给两个 TTL 队列:{}", new Date().toString(), message);
            rabbitTemplate.convertAndSend("X","XA","消息来自ttl为 10s的队列" + message);
            rabbitTemplate.convertAndSend("X","XB","消息来自ttl为 40s的队列" + message);
    
        }
    
    }
    
    

**消费者——》消费/读取消息的代码：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428580-852096707.png)

    package com.rainbowsea.rabbitmq.springbootrabbitmq.consumer;
    
    
    import com.rabbitmq.client.Channel;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.amqp.core.Message;
    
    import org.springframework.amqp.rabbit.annotation.RabbitListener;
    import org.springframework.stereotype.Component;
    
    import java.io.IOException;
    import java.util.Date;
    
    /**
     * 消费者(消费/读取消息)
     */
    
    @Slf4j
    @Component  // 当 IOC 容器读取到
    public class DeadLetterQueueConsumer {
    
    
        @RabbitListener(queues = "QD")
        public void receiveD(Message message, Channel channel) {
            String msg = new String(message.getBody());
            log.info("当前时间:{},收到死信队列的消息:{}", new Date().toString(), msg);
        }
    
    
    }
    
    
    
    

**运行效果：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428485-244160289.png)

**该延时队列存在的问题：**

第一条消息在 10 S 后变成了死信消息，然后被消费者消费/读取掉了，第二条消息在 40S 之后变成了死信消息，然后被消费掉，这样一个延时队列就被打造完成了。

不过，该延时队列存在一个问题：

> 如果这样使用的话，岂不是**每增加一个新的时间需求，就要新增一个队列。** 这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 `TTL` 为一个小时的队列，如果是预定会议室，然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求。

3.2 延时队列优化
----------

> **优化思路：** **就是把延时时间，交给发送消息的生产者上决定，而不是写死在队列当中，通过一个无延时队列来处理，生产者上设置的一个延时发送的时间。**

在这里新增了一个队列 QC,绑定关系如下，该队列不设置 TTL 时间

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428652-1933494840.png)

> **特别注意：** **这里需要将上面创建了的 交换机，队列删除了，因为 RabbitMQ 消息队列不能将一个已经存在的交换机/队列，的基础上，进行修改，而是只能重新生成** 。

在 **TtlQueueConfig** 配置类上添加上一个，RoutingKey 为 XC ，队列为 QC，对应 死信队列还是 QD 。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428640-189613932.png)

    
    import org.springframework.amqp.core.Binding;
    import org.springframework.amqp.core.BindingBuilder;
    import org.springframework.amqp.core.DirectExchange;
    import org.springframework.amqp.core.Queue;
    import org.springframework.amqp.core.QueueBuilder;
    import org.springframework.beans.factory.annotation.Qualifier;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    import java.util.HashMap;
    import java.util.Map;
    
    @Configuration  // 标注是一个配置类，加载到 IOC 容器当中
    public class TtlQueueConfig {
    
        // 普通交换机的名称
        public static final String X_EXCHANGE = "X";
        // 死信队列的名称
        public static final String DEAD_LETTER_QUEUE = "QD";
    
        // 死信交换机的名称
        public static final String Y_DEAD_LETTER_EXCHANGE = "Y";
        // 普通队列的名称
        public static final String QUEUE_A = "QA";
        public static final String QUEUE_B = "QB";
    
    
    
        //普通队列的名称
        public static final String QUEUE_C = "QC";
        // 声明队列 QC 同时绑定上 (以 RoutingKey 为 XC  )QD 死信交换机
        @Bean("queueC")
        public Queue queueC(){
            // 创建一个 Map 用于存放，设置队列信息
            Map<String, Object> arguments = new HashMap<>(3);
            // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
            arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
            // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
            arguments.put("x-dead-letter-routing-key", "YD");
            // 不设置 TTL 时间，也是通过生产者来设置
            return QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();
        }
    
        // 将声明的队列 QC  绑定到 X 交换机当中
        @Bean  // 绑定也是要注入到 IOC 容器当中的
        public Binding queueBindingX(@Qualifier("queueC") Queue queueC,
                                      @Qualifier("xExchange") DirectExchange xExchange) {
            // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
            // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XC"
            // 表示将 队列 queueC 与 xExchange 交换机，通过 routingKey 为 "XC" 进行一个绑定
            return BindingBuilder.bind(queueC).to(xExchange).with("XC");
        }
    
    }
    

完整代码内容：

    package com.rainbowsea.rabbitmq.springbootrabbitmq.config;
    
    
    import org.springframework.amqp.core.Binding;
    import org.springframework.amqp.core.BindingBuilder;
    import org.springframework.amqp.core.DirectExchange;
    import org.springframework.amqp.core.Queue;
    import org.springframework.amqp.core.QueueBuilder;
    import org.springframework.beans.factory.annotation.Qualifier;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    import java.util.HashMap;
    import java.util.Map;
    
    @Configuration  // 标注是一个配置类，加载到 IOC 容器当中
    public class TtlQueueConfig {
    
        // 普通交换机的名称
        public static final String X_EXCHANGE = "X";
        // 死信队列的名称
        public static final String DEAD_LETTER_QUEUE = "QD";
    
        // 死信交换机的名称
        public static final String Y_DEAD_LETTER_EXCHANGE = "Y";
        // 普通队列的名称
        public static final String QUEUE_A = "QA";
        public static final String QUEUE_B = "QB";
    
    
    
        //普通队列的名称
        public static final String QUEUE_C = "QC";
        // 声明队列 QC 同时绑定上 (以 RoutingKey 为 XC  )QD 死信交换机
        @Bean("queueC")
        public Queue queueC(){
            // 创建一个 Map 用于存放，设置队列信息
            Map<String, Object> arguments = new HashMap<>(3);
            // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
            arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
            // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
            arguments.put("x-dead-letter-routing-key", "YD");
            // 不设置 TTL 时间，也是通过生产者来设置
            return QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();
        }
    
        // 将声明的队列 QC  绑定到 X 交换机当中
        @Bean  // 绑定也是要注入到 IOC 容器当中的
        public Binding queueBindingX(@Qualifier("queueC") Queue queueC,
                                      @Qualifier("xExchange") DirectExchange xExchange) {
            // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
            // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XC"
            // 表示将 队列 queueC 与 xExchange 交换机，通过 routingKey 为 "XC" 进行一个绑定
            return BindingBuilder.bind(queueC).to(xExchange).with("XC");
        }
    
    
        // 声明 XExchange 别名；会注入到 IOC 容器当中 普通交换机的
        @Bean(value = "xExchange")
        public DirectExchange xExchange() {
            return new DirectExchange(X_EXCHANGE);
        }
    
    
        // 声明 yExchange 别名；会注入到 IOC 容器当中 普通交换机的
        @Bean(value = "yExchange")
        public DirectExchange yExchange() {
            return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);
        }
    
        // 声明普通队列 TTL 为 10s
        @Bean("queueA")
        public Queue queueA() {
            // 创建一个 Map 用于存放，设置队列信息
            Map<String, Object> arguments = new HashMap<>(3);
            // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
            arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
            // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
            arguments.put("x-dead-letter-routing-key", "YD");
            // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
            arguments.put("x-message-ttl", 10000);
    
            return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();
        }
    
    
        // 声明普通队列 TTL 为 40s
        @Bean("queueB")
        public Queue queueB() {
            // 创建一个 Map 用于存放，设置队列信息
            Map<String, Object> arguments = new HashMap<>(3);
            // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
            arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
            // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
            arguments.put("x-dead-letter-routing-key", "YD");
            // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
            arguments.put("x-message-ttl", 40000);
    
            return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
        }
    
    
        // 声明死信队列
        @Bean("queueD")
        public Queue queueD() {
            //  不带参数，就不需要 .withArguments(arguments)
            //return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
            return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();
        }
    
    
        // 绑定
    
        /**
         * 注意：这里的  public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
         *                                   @Qualifier("xExchange") DirectExchange xExchange)
         *
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier 参数内的值是，我们上边：  @Bean(value = "xExchange")，@Bean("queueA") 注入到 IOC 容器当中的值
         * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
         *  @Bean(value = "xExchange")
         *     public DirectExchange xExchange() {
         * @Bean("queueA") public Queue queueA() {
         */
        @Bean  // 绑定也是要注入到 IOC 容器当中的
        public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
                                      @Qualifier("xExchange") DirectExchange xExchange) {
            // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
            // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XA"
            // 表示将 队列 queueA 与 xExchange 交换机，通过 routingKey 为 "XA" 进行一个绑定
            return BindingBuilder.bind(queueA).to(xExchange).with("XA");
        }
    
    
        // 绑定
    
        /**
         * 注意：这里的  public Binding queueBBindingX(@Qualifier("queueB") Queue queueB,
         *                                   @Qualifier("xExchange") DirectExchange xExchange)
         *
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier 参数内的值是，我们上边：  @Bean(value = "xExchange")，@Bean("queueB") 注入到 IOC 容器当中的值
         * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
         *  @Bean(value = "xExchange")
         *     public DirectExchange xExchange() {
         * @Bean("queueB") public Queue queueB() {
         */
        @Bean  // 绑定也是要注入到 IOC 容器当中的
        public Binding queueBBindingX(@Qualifier("queueB") Queue queueB,
                                      @Qualifier("xExchange") DirectExchange xExchange) {
            // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
            // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XB"
            // 表示将 队列 queueB 与 xExchange 交换机，通过 routingKey 为 "XB" 进行一个绑定
            return BindingBuilder.bind(queueB).to(xExchange).with("XB");
        }
    
    
        // 绑定
    
        /**
         * 注意：这里的  public Binding queueDBindingX(@Qualifier("queueD") Queue queueD,
         *                                   @Qualifier("yExchange") DirectExchange yExchange)
         *
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier("xExchange") DirectExchange xExchange)
         * @Qualifier 参数内的值是，我们上边：  @Bean(value = "yExchange")，@Bean("queueD") 注入到 IOC 容器当中的值
         * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
         * @Bean(value = "yExchange")
         * public DirectExchange yExchange() {
         * @Bean("queueD")
         *     public Queue queueD() {
         */
        @Bean // 绑定也是要注入到 IOC 容器当中的
        public Binding queueDBindingX(@Qualifier("queueD") Queue queueD,
                                      @Qualifier("yExchange") DirectExchange yExchange) {
            // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
            // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"YD"
            // 表示将 队列 queueD 与 yExchange 交换机，通过 routingKey 为 "YD" 进行一个绑定
            return BindingBuilder.bind(queueD).to(yExchange).with("YD");
        }
    
    
    }
    
    

**生产者——> 发送消息，代码**

> 这里，生产者，指定一个延时时间(TTL)，交给 X 交换机——>以 routingKey = XC 发送给 QC 队列——> 发送给死信交换机——> 以 routingKey = YD 分配给 QD 死信队列——>最后给消费者读取/消费消息。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428544-1183079308.png)

    
    
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.amqp.rabbit.core.RabbitTemplate;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;
    
    import javax.annotation.Resource;
    import java.util.Date;
    
    /**
     * 生产者：发送延时消息
     * http://localhost:8080/ttl/sendMsg/嘻嘻嘻
     */
    
    
    @RestController
    @RequestMapping("ttl")
    @Slf4j
    public class SendMsgController {
    
        @Resource  // 注入到 IOC 容器当中
        private RabbitTemplate rabbitTemplate;
    
    
        @GetMapping("/sendExpirationMsg/{message}/{ttlTime}")
        public void sendMsg(@PathVariable String message,
                            @PathVariable String ttlTime) {
            log.info("当前时间:{},发送一条时长{}毫秒 TTL 消息给队列QC:{}", new Date().toString(), ttlTime, message);
            rabbitTemplate.convertAndSend("X", "XC", message, msg -> {
                // 发送消息的时候，延时时长
                msg.getMessageProperties().setExpiration(ttlTime);
                return msg;
            });
            log.info("当前时间：{},发送一条时长{}毫秒 TTL 信息给队列 C:{}", new Date(), ttlTime, message);
    
        }
    }
    

**测试效果：**

浏览器发送请求：

*   [http://localhost:8080/ttl/sendExpirationMsg/你好1/20000](http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD1/20000)
*   [http://localhost:8080/ttl/sendExpirationMsg/你好2/2000](http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD2/2000)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428483-138748402.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428559-146200515.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428642-1302957467.png)

> **分析测试结果：**
> 
> ![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428660-782814992.png)

> 看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用消息属性上设置 **TTL** 的方式，消息可能并不会按时 “死亡” ，因为**RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列，如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行** 。

3.3 Rabbitmq 插件实现延迟队列
---------------------

上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间 及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。

我们可以通过安装一个：`rabbitmq-delayed-message-exchange 插件` 来解决这个问题。这个插件是如何解决的呢：**既然延时队列，将消息放入到队列当中存在，一个消息过期时间优先级的问题，那么我们就不将延时的消息，放入到队列当中，而是通过交换机进行处理。**

`rabbitmq-delayed-message-exchange 插件` 就是让我们延时的消息，可以不走队列，而是通过交换机本身进行一个处理，让消费者直接从交换机当中消费，读取消息。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428484-1182540066.png)

消息发送后不会直接投递到队列，

而是存储到 Mnesia（嵌入式数据库），检查 x-delay 时间（消息头部）；

延迟插件在 RabbitMQ 3.5.7 及以上的版本才支持，依赖 Erlang/OPT 18.0 及以上运行环境；

Mnesia 是一个小型数据库，不适合于大量延迟消息的实现

解决了消息过期时间不一致(优先级)出现的问题。

**安装：安装延时队列插件 详细步骤：**

1.  在官网上下载：[https://www.rabbitmq.com/community-plugins](https://www.rabbitmq.com/community-plugins)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428643-1230798542.png)

下载 `rabbitmq_delayed_message_exchange` 插件

2.  然后解压放置到 RabbitMQ 的插件目录，进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效。

    [root@RainbowSea plugins]# cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins # 进入到 RabbitMQ 插件目录
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428654-1753476306.png)

3.  将下载好的 `rabbitmq_delayed_message_exchange` 插件，上传到 RabbitMQ 的安装目录下的 plgins 目录 当中。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428604-1263857573.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428603-204377583.png)

4.  执行 `rabbitmq-plugins enable rabbitmq_delayed_message_exchange` 命令，启用该插件

    [root@RainbowSea plugins]# rabbitmq-plugins enable rabbitmq_delayed_message_exchange
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428642-1284427229.png)

5.  `rabbitmq-plugins list` 查看所有插件

    [root@RainbowSea plugins]# rabbitmq-plugins list
    

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428643-221340504.png)

添加成功的效果：

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428611-450078936.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428608-1951034612.png)

**具体代码实现：**

1.  在这里新增了一个队列 `delayed.queue`,一个自定义交换机 `delayed.exchange`，绑定关系如下:

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428653-111552693.png)

**编写配置类代码：**

在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并 不会立即投递到目标队列中，而是存储在 mnesia (一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。  
![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428630-1807443887.png)

    package com.rainbowsea.rabbitmq.springbootrabbitmq.config;
    
    
    import org.springframework.amqp.core.Binding;
    import org.springframework.amqp.core.BindingBuilder;
    import org.springframework.amqp.core.CustomExchange;
    import org.springframework.amqp.core.Queue;
    import org.springframework.beans.factory.annotation.Qualifier;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    import java.util.HashMap;
    import java.util.Map;
    
    @Configuration
    public class DelayedQueueConfig {
    
        public static final String DELAYED_QUEUE_NAME = "delayed.queue";
        public static final String DELAYED_EXCHANGE_NAME = "delayed.exchange";
        public static final String DELAYED_ROUTING_KEY = "delayed.routingkey";
    
    
        @Bean("delayedQueue")  // 声明队列，基于 rabbitmq_delayed_message_exchange 插件的
        public Queue delayedQueue() {
            return new Queue(DELAYED_QUEUE_NAME);
        }
    
        // 声明交换机(可以算是一种自定义交换机)，基于 rabbitmq_delayed_message_exchange 插件的
        @Bean("delayedExchange")
        public CustomExchange delayedExchange() {
            // 创建一个 Map 用于存放，设置队列信息
            Map<String, Object> arguments = new HashMap<>(3);
            // 自定义交换机的类型, 这里定义为 direct 直接类型
            arguments.put("x-delayed-type", "direct");
            /**
             * CustomExchange 方法参数
             * 1.交换机的名称
             * 2.交换机的类型
             * 3.是否需要持久化
             * 4.是否需要自动删除
             * 5.其它的参数
             */
    
            return new CustomExchange(DELAYED_EXCHANGE_NAME, "x-delayed-message", true, false, arguments);
        }
    
    
        // 基于 rabbitmq_delayed_message_exchange 插件的 将队列绑定到交换机当中
        @Bean
        public Binding delayedQueueBindingdelayedExchange(
                @Qualifier("delayedQueue") Queue delayedQueue,
                @Qualifier("delayedExchange") CustomExchange delayedExchange) {
            return BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();
        }
    }
    
    

**生产者-发送消息的：** 这里我们使用的是，通过生产者，设置延时时间，而不是通过队列写死延时时间的方式。

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428650-647259746.png)

    
    import com.rainbowsea.rabbitmq.springbootrabbitmq.config.DelayedQueueConfig;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.amqp.rabbit.core.RabbitTemplate;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;
    
    
    import javax.annotation.Resource;
    import java.util.Date;
    
    /**
     * 生产者：发送延时消息
     * http://localhost:8080/ttl/sendMsg/嘻嘻嘻
     */
    
    
    @RestController
    @RequestMapping("ttl")
    @Slf4j
    public class SendMsgController {
    
        @Resource  // 注入到 IOC 容器当中
        private RabbitTemplate rabbitTemplate;
    
    
        @GetMapping("sendDelayMsg/{message}/{delayTime}")
        public void sendMsg(@PathVariable String message, @PathVariable Integer delayTime) {
            log.info(" 当前时间: {}, 发送一条延迟{} 毫秒的信息给队列 delayed.queue:{}", new Date(), delayTime, message);
            rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME, DelayedQueueConfig.DELAYED_ROUTING_KEY, message,
                    correlationData -> {
                        // 发送消息的时候，延迟时长，单位:ms
                        correlationData.getMessageProperties().setDelay(delayTime);
                        return correlationData;
                    });
        }
    
    }
    

**消费者/读取/消费——使用插件交换机当中延时的消息：**

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428593-670395555.png)

    package com.rainbowsea.rabbitmq.springbootrabbitmq.consumer;
    
    
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.amqp.core.Message;
    import org.springframework.amqp.rabbit.annotation.RabbitListener;
    import org.springframework.stereotype.Component;
    import com.rainbowsea.rabbitmq.springbootrabbitmq.config.DelayedQueueConfig;
    
    import java.util.Date;
    
    
    /**
     * 消费者，消费/读取消息，基于rabbitmq_delayed_message_exchange 插件
     */
    @Slf4j
    @Component
    public class DelayQueueConsumer {
    
        // 监听消息
        @RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)
        public void receiveDelayQueue(Message message) {
            String msg = new String(message.getBody());
            log.info("当前时间:{} ,收到延时队列的消息:{}", new Date().toString(), msg);
        }
    }
    
    

**运行结果：** 浏览器当中发出请求：

*   [http://localhost:8080/ttl/sendDelayMsg/come](http://localhost:8080/ttl/sendDelayMsg/come) on baby1/20000
*   [http://localhost:8080/ttl/sendDelayMsg/come](http://localhost:8080/ttl/sendDelayMsg/come) on baby2/2000

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428653-393492267.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428643-607159461.png)

**总结：**

延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：**消息可靠发送，消息可靠投递，死信队列** 来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单击故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。

当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点，看需要适用的场景。

4\. 补充：Docker 容器当中安装 message\_exchange"延迟插件" 的详细步骤
==================================================

1.  **确定 Docker 容器对应映射的卷的目录位置：**

    docker inspect rabbitmq
    

对应的运行结果：

            "Mounts": [
                {
                    "Type": "volume",
                    "Name": "rabbitmq-plugin",
                    "Source": "/var/lib/docker/volumes/rabbitmq-plugin/_data",
                    "Destination": "/plugins",
                    "Driver": "local",
                    "Mode": "z",
                    "RW": true,
                    "Propagation": ""
                },
                {
                    "Type": "volume",
                    "Name": "cca7bc3012f5b76bd6c47a49ca6911184f9076f5f6263b41f4b9434a7f269b11",
                    "Source": "/var/lib/docker/volumes/cca7bc3012f5b76bd6c47a49ca6911184f9076f5f6263b41f4b9434a7f269b11/_data",
                    "Destination": "/var/lib/rabbitmq",
                    "Driver": "local",
                    "Mode": "",
                    "RW": true,
                    "Propagation": ""
                }
            ]
    

和容器内 `/plugins` 目录对应的宿主机目录是：`/var/lib/docker/volumes/rabbitmq-plugin/_data`

> **注意：这里必须必须必须，将下载到的 `插件` 拷贝到 RabbitMQ 服务器 `plugins` 目录下，不然时无法安装成功的。**

2.  **下载对应的 messaging 延时插件**

**messaging 延时插件的官网文档地址：** [https://www.rabbitmq.com/community-plugins](https://www.rabbitmq.com/community-plugins)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428631-1860627507.png)

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428644-975179095.png)

**下载在 Docker 容器当中下载安装文件：**

    wget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/v3.13.0/rabbitmq_delayed_message_exchange-3.13.0.ez
    mv rabbitmq_delayed_message_exchange-3.13.0.ez /var/lib/docker/volumes/rabbitmq-plugin/_data
    

3.  **启用该延时插件：**

    # 登录进入容器内部
    docker exec -it rabbitmq /bin/bash
    
    # rabbitmq-plugins命令所在目录已经配置到$PATH环境变量中了，可以直接调用
    rabbitmq-plugins enable rabbitmq_delayed_message_exchange
    
    # 退出Docker容器
    exit
    
    # 重启Docker容器
    docker restart rabbitmq
    

4.  **插件安装成功的，确定，验证：**

*   确认点1：查看当前节点已启用插件的列表：

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428650-1702034190.png)

*   确认点2：如果创建新交换机时可以在type中看到x-delayed-message选项，那就说明插件安装好了

![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428641-1256909882.png)

5\. 最后：
=======

> “在这个最后的篇章中，我要表达我对每一位读者的感激之情。你们的关注和回复是我创作的动力源泉，我从你们身上吸取了无尽的灵感与勇气。我会将你们的鼓励留在心底，继续在其他的领域奋斗。感谢你们，我们总会在某个时刻再次相遇。”
> 
> ![在这里插入图片描述](https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428685-1975720165.gif)