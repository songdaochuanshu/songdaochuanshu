---
layout: post
title: 'linux设备驱动阻塞IO应用'
date: "2026-02-18T01:00:22Z"
---
linux设备驱动阻塞IO应用
===============

使用wait\_queue\_head\_t实现阻塞上层应用

1\. 驱动中阻塞相关函数的基础
----------------

### 1.1 wait\_queue\_head\_t

定义等待队列头

#include <linux/wait.h>
/\*
 \* lock：自旋锁，用于保护队列操作（如添加/删除等待项）的并发安全
 \* head：链表头，指向等待队列项的链表
 \*/
typedef struct wait\_queue\_head {
    spinlock\_t      lock;
    struct list\_head    head;
} wait\_queue\_head\_t;

### 1.2 init\_waitqueue\_head

初始化一个已经分配了内存的等待队列头，设置其自旋锁和链表为空

void init\_waitqueue\_head(wait\_queue\_head\_t \*q);

### 1.3 DECLARE\_WAITQUEUE

**静态声明并初始化一个等待队列项（wait queue entry）**。该宏创建一个 wait\_queue\_entry 类型的变量，并将指定的进程描述符 tsk （当前进程为 current ）与该队列项关联，同时设置默认的唤醒函数

DECLARE\_WAITQUEUE(name, tsk);

// 使用方式
DECLARE\_WAITQUEUE(wait, current);
// 展开后为
wait\_queue\_entry\_t wait = {
    .private    = current,                 // 指向等待的进程 task\_struct
    .func       = default\_wake\_function,   // 唤醒时调用的函数
    .task\_list  = { NULL, NULL }           // 链表节点，用于挂入等待队列头
};

### 1.4 add\_wait\_queue

将一个已经初始化好的等待队列项 wait 添加到等待队列头 queue 所管理的队列中。添加后，该队列项就成为了等待队列的一部分

在进程准备睡眠之前，先将自己添加到等待队列，这样其他唤醒者才能找到它

void add\_wait\_queue(wait\_queue\_head\_t \*queue, wait\_queue\_t \*wait);

### 1.5 set\_current\_state

**设置当前进程的状态**，将 current->state 赋值为 new\_state `，`进程状态定义在 <linux/sched.h> 中，常见的有：

*   `TASK_RUNNING`：可运行状态（正在运行或就绪）。
    
*   `TASK_INTERRUPTIBLE`：可中断的睡眠状态，可以被信号唤醒。
    
*   `TASK_UNINTERRUPTIBLE`：不可中断的睡眠状态，只能由显式唤醒解除。
    

void set\_current\_state(int new\_state);        // 有内存屏障，保证顺序
void \_\_set\_current\_state(int new\_state);      // 没有内存屏障    

### 1.6 `remove_wait_queue`

将之前通过 add\_wait\_queue 添加的等待队列项从等待队列中移除；当进程被唤醒并重新获得 CPU 后，通常需要调用此函数将自己从等待队列中删除，表示不再等待该条件；如果忘记移除，队列项仍留在等待队列中，可能导致后续不必要的唤醒或资源泄漏

void remove\_wait\_queue(wait\_queue\_head\_t \*queue, wait\_queue\_t \*wait);

### 1.7 `wake_up`

唤醒队列中所有进程（包括 TASK\_UNINTERRUPTIBLE和 TASK\_INTERRUPTIBLE ）

void wake\_up(wait\_queue\_head\_t \*queue);

唤醒等待队列 queue 中所有状态为 TASK\_INTERRUPTIBLE 的进程。这些进程将被设置为 TASK\_RUNNING 并移入运行队列，等待调度器选择它们运行

void wake\_up\_interruptible(wait\_queue\_head\_t \*queue);

2\. 阻塞驱动使用例子
------------

#include <linux/init.h>
#include <linux/errno.h>
#include <linux/mm.h>
#include <linux/sched.h>
#include <linux/module.h>
#include <linux/ioctl.h>
#include <linux/io.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/wait.h>

#define GLOBALFIFO\_SIZE    1024
#define GLOBALMEM\_MAGIC    'M'
#define MEM\_CLEAR        \_IO(GLOBALMEM\_MAGIC, 0)

struct globalfifo\_dev {
    struct cdev m\_cdev;            /\* 字符设备 \*/
    unsigned int current\_len;        /\* fifo有效数据长度 \*/
    unsigned char mem\[GLOBALFIFO\_SIZE\];    /\* 全局内存 \*/
    struct semaphore sem;            /\* 并发控制信号量 \*/
    wait\_queue\_head\_t r\_wait;        /\* 阻塞读等待队列头 \*/
    wait\_queue\_head\_t w\_wait;        /\* 阻塞写等待队列头 \*/
};

static int globalfifo\_major = 266;

// 存放字符设备私有数据
struct globalfifo\_dev\* globalfifo\_devp;

/\* user open fd \*/
static int globalfifo\_open(struct inode\* inode, struct file\* filp) {
    
    struct globalfifo\_dev\* dev;
    dev \= container\_of(inode->i\_cdev, struct globalfifo\_dev, m\_cdev);
    filp\->private\_data = dev;
    return 0;
}

/\* user release fd\*/
static int globalfifo\_release(struct inode\* inode, struct file\* filp) {
    return 0;
}

/\* user read fd \*/
static ssize\_t globalfifo\_read(struct file\* filp, char \_\_user\* buf, size\_t count, loff\_t\* ppos) {
    int ret;    
    struct globalfifo\_dev\* dev = filp->private\_data;    
    
    // 定义等待队列
    DECLARE\_WAITQUEUE(wait, current);    

    down(&dev->sem);

    // 1.将等待队列加入到等待队列头
    add\_wait\_queue(&dev->r\_wait, &wait);

    // 2.循环检查等待条件（防止假唤醒，如果唤醒后不满足条件会再次睡眠）
    while (dev->current\_len == 0) {
        // 3. 检查非阻塞模式直接返回
        if (filp->f\_flags & O\_NONBLOCK) {
            ret \= -EAGAIN;
            up(&dev->sem);
            remove\_wait\_queue(&dev->w\_wait, &wait);
            set\_current\_state(TASK\_RUNNING);
            return ret;
        }
        // 4.改变进程状态为可中断睡眠
        \_\_set\_current\_state(TASK\_INTERRUPTIBLE);

        up(&dev->sem);

        // 5.调度其他进程执行（真正睡眠）        
        schedule();

        // 6.检查如果有信号到达返回上层处理错误（自己的唤醒只将状态转换为TASK\_RUNNING，但信号到来也会做这个处理）
        if (signal\_pending(current)) {
            ret \= -ERESTARTSYS;
            remove\_wait\_queue(&dev->w\_wait, &wait);
            set\_current\_state(TASK\_RUNNING);
            return ret;
        }
        
        // 被唤醒后的处理
        down(&dev->sem);
    }

    if(count > dev->current\_len)
        count \= dev->current\_len;

    if(copy\_to\_user(buf, dev->mem, count)) {
        ret \= -EFAULT;
        up(&dev->sem);
        remove\_wait\_queue(&dev->w\_wait, &wait);
           set\_current\_state(TASK\_RUNNING);
        return ret;
    } else {
        memcpy(dev\->mem, dev->mem + count, dev->current\_len - count);
        dev\->current\_len -= count;
            
        wake\_up\_interruptible(&dev->w\_wait);    // 读出数据后唤醒写进程
        ret = count;
    }
    
    up(&dev->sem);
    remove\_wait\_queue(&dev->w\_wait, &wait);
    set\_current\_state(TASK\_RUNNING);

    return ret;
}

/\* user write fd \*/ 
static ssize\_t globalfifo\_write(struct file\* filp, const char \_\_user\* buf, size\_t count, loff\_t\* ppos) {
    int ret;    
    struct globalfifo\_dev\* dev = filp->private\_data;    

    // 定义等待队列
    DECLARE\_WAITQUEUE(wait, current);
    down(&dev->sem);
    // 1.将等待队列插入写等待队列头
    add\_wait\_queue(&dev->w\_wait, &wait);

    // 2.循环等待 若FIFO满则应该挂起
    while (dev->current\_len == GLOBALFIFO\_SIZE) {
        // 3. 若非阻塞则直接返回
        if (filp->f\_flags & O\_NONBLOCK) {
            up(&dev->sem);
            ret \= -EAGAIN;
            remove\_wait\_queue(&dev->w\_wait, &wait);
            set\_current\_state(TASK\_RUNNING);
            return ret;
        }
        // 4.将进程状态改为可打断睡眠
        \_\_set\_current\_state(TASK\_INTERRUPTIBLE);
        up(&dev->sem);
        // 5.调度其他进程（真正睡眠）
        schedule();

        // 6.若因为信号唤醒，则返回让上层完成错误处理
        if (signal\_pending(current)) {
            ret \= -ERESTARTSYS;
            remove\_wait\_queue(&dev->w\_wait, &wait);
            set\_current\_state(TASK\_RUNNING);
            return ret;
        }
        down(&dev->sem);
    }

    if (count > GLOBALFIFO\_SIZE - dev->current\_len)
        count \= GLOBALFIFO\_SIZE - dev->current\_len;

    if (copy\_from\_user(dev->mem, buf, count)) {
        ret \= -EFAULT;
        up(&dev->sem);
        remove\_wait\_queue(&dev->w\_wait, &wait);
        set\_current\_state(TASK\_RUNNING);
        return ret;
    } else {
        dev\->current\_len += count;
        // 唤醒等待队列
        wake\_up\_interruptible(&dev->r\_wait);
        ret \= count;    
    }

    up(&dev->sem);
    remove\_wait\_queue(&dev->w\_wait, &wait);
    set\_current\_state(TASK\_RUNNING);

    return count;
}

/\* user lseek fd \*/
static loff\_t globalfifo\_llseek(struct file\* filp, loff\_t offset, int orig) {
    loff\_t ret;
    switch(orig) {
    // 从起始位置开始移动指针
    case 0:
        if(offset < 0) {
            ret \= -EINVAL;
            break;
        }
        if((unsigned int)offset > GLOBALFIFO\_SIZE) {
            ret \= -EINVAL;
            break;
        }
        filp\->f\_pos = (unsigned int)offset;
        ret \= filp->f\_pos;
        break;
    // 从当前位置开始移动指针
    case 1:
        if((filp->f\_pos + offset) > GLOBALFIFO\_SIZE) {
            ret \= -EINVAL;
            break;
        }
        if((filp->f\_pos + offset) < 0) {
            ret \= -EINVAL;
            break;
        }
        filp\->f\_pos += offset;
        ret \= filp->f\_pos;
        break;
    default:
        ret \= -EINVAL;
    }
    return ret;
}

/\* user ioctl fd \*/
static long globalfifo\_unlocked\_ioctl(struct file \*filp, unsigned int cmd, unsigned long arg){
    // 获取设备结构体指针    
    struct globalfifo\_dev\* dev = filp->private\_data;    
    
    switch(cmd) {
    case MEM\_CLEAR:
        down(&dev->sem);
        dev\->current\_len = 0;
        memset(dev\->mem, 0, GLOBALFIFO\_SIZE);
        up(&dev->sem);
        break;
    default:
        return -EINVAL;
    }
    return 0;
}

static const struct file\_operations globalfifo\_fops = {
    .owner \= THIS\_MODULE,
    .open \= globalfifo\_open,
    .release \= globalfifo\_release,
    .llseek \= globalfifo\_llseek,
    .read \= globalfifo\_read,
    .write \= globalfifo\_write,
    .unlocked\_ioctl \= globalfifo\_unlocked\_ioctl
};

/\* 设备驱动模块insmod加载函数 \*/
static int globalfifo\_init(void) {
    // 向 Linux 内核中注册字符设备编号范围
    register\_chrdev\_region(MKDEV(globalfifo\_major, 0), 1, "globalfifo");

    // 为设备以及共享内存分配内存
    globalfifo\_devp = kmalloc(sizeof(struct globalfifo\_dev), GFP\_KERNEL);
    memset(globalfifo\_devp, 0, sizeof(struct globalfifo\_dev));
    
    // 初始化字符设备0的基本字段
    cdev\_init(&globalfifo\_devp->m\_cdev, &globalfifo\_fops);
    globalfifo\_devp\->m\_cdev.owner = THIS\_MODULE;
    // 将主设备号globalfifo\_major次设备号0，与字符设备驱动的关联
    cdev\_add(&globalfifo\_devp->m\_cdev, MKDEV(globalfifo\_major, 0), 1);

    // 初始化信号量
    sema\_init(&globalfifo\_devp->sem, 1);

    // 初始化读写等待队列头
    init\_waitqueue\_head(&globalfifo\_devp->r\_wait);
    init\_waitqueue\_head(&globalfifo\_devp->w\_wait);
    return 0;
}

static void globalfifo\_exit(void) {
    dev\_t devno;
    // 注销cdev
    cdev\_del(&globalfifo\_devp->m\_cdev);
    // 释放设备结构体内存
    kfree(globalfifo\_devp);    
    // 释放设备号
    devno = MKDEV(globalfifo\_major, 0);
    unregister\_chrdev\_region(devno, 1);
}


MODULE\_AUTHOR("cear");
MODULE\_LICENSE("GPL");

module\_param(globalfifo\_major, int, S\_IRUGO);
module\_init(globalfifo\_init);
module\_exit(globalfifo\_exit);