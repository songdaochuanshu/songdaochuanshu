---
layout: post
title: '3Dç‚¹äº‘åˆ°2Dç‚¹äº‘æŠ•å½±å›¾åƒå…·ä½“æ–¹æ³•'
date: "2026-01-30T00:55:10Z"
---
3Dç‚¹äº‘åˆ°2Dç‚¹äº‘æŠ•å½±å›¾åƒå…·ä½“æ–¹æ³•
=================

ç”±äºå·¥ä½œéœ€æ±‚ï¼Œéœ€è¦å°†ä¸‰ç»´é›·è¾¾ç‚¹äº‘æ•°æ®æŠ•å½±åˆ°äºŒç»´å¹³é¢ä¸Šï¼Œä»¥ä¾¿è¿›è¡Œåç»­çš„å¯è§†åŒ–åˆ†ææˆ–ä¸å…¶ä»–2Dä¼ æ„Ÿå™¨ï¼ˆå¦‚æ‘„åƒå¤´ï¼‰çš„æ•°æ®èåˆã€‚ä¸ºæ­¤ï¼Œæˆ‘æ•´ç†å¹¶å®ç°äº†å®Œæ•´çš„3Dåˆ°2DæŠ•å½±ä»£ç ï¼Œå¹¶åœ¨æ­¤è®°å½•æ•´ä¸ªè¿‡ç¨‹ï¼Œä»¥å¤‡æ—¥åæŸ¥é˜…ä¸å¤ç”¨ã€‚

ä¸‹å›¾å±•ç¤ºäº†æŠ•å½±åçš„æ•ˆæœï¼šåŸå§‹çš„3Dç‚¹äº‘ç»è¿‡åæ ‡å˜æ¢ä¸è§†è§’æ˜ å°„åï¼ŒæˆåŠŸå‘ˆç°åœ¨2Då›¾åƒå¹³é¢ä¸Šï¼Œä¿ç•™äº†å…³é”®çš„ç©ºé—´ç»“æ„ä¿¡æ¯ï¼Œä¸ºåç»­çš„ç›®æ ‡æ£€æµ‹ã€åœºæ™¯ç†è§£ç­‰ä»»åŠ¡å¥ å®šäº†åŸºç¡€ã€‚

  

åŸå§‹ç‚¹äº‘

å«å¼ºåº¦ä¿¡å·è½¬ç°åº¦å›¾

çº¯ç»¿è‰²æŠ•å½±æŠ•å½±

å¢åŠ é¢œè‰²æŠ•å½±

Â è¯¥å®ç°å……åˆ†è€ƒè™‘äº†é›·è¾¾åæ ‡ç³»ä¸å›¾åƒåæ ‡ç³»ä¹‹é—´çš„è½¬æ¢å…³ç³»ï¼Œæ”¯æŒçµæ´»è°ƒæ•´æŠ•å½±å‚æ•°ï¼ˆå¦‚ä¿¯ä»°è§’ã€åèˆªè§’ã€è§†åœºè§’ç­‰ï¼‰ï¼Œå…·æœ‰è‰¯å¥½çš„é€šç”¨æ€§å’Œå¯æ‰©å±•æ€§ã€‚

1\. pclåº“çš„å®‰è£…

sudo apt install libpcl-dev

2\. opencvåº“çš„å®‰è£…

sudo apt-get install libopencv-dev

3\. å‡†å¤‡æ‘„åƒæœºçš„å†…å‚æ ‡å®š

æˆ‘ä½¿ç”¨çš„æ˜¯æ£‹ç›˜æ ‡å®šæ³•,ç”¨matlabåšçš„,å…·ä½“å‚è€ƒæˆ‘çš„å¦ä¸€ç¯‡åšå®¢: https://www.cnblogs.com/cqwo/p/19179297

ç›¸æœºå†…å‚æ ‡å®š

ç›¸æœºå†…å‚ç´ æ

Â 4. ç›¸æœºé›·è¾¾å‚æ•°æ ‡å®š

æ ‡å®šå‚æ•°å›¾åƒ

æ ‡å®šå‚æ•°å¯¹åº”ç‚¹äº‘

å…·ä½“æ­¥éª¤å‚æ•°ä¸‹é¢æ¸¯å¤§è®ºæ–‡å’Œå…¬å…±çš„

å‚è€ƒè®ºæ–‡ï¼šhttp://arxiv.org/abs/2103.01627  
å‚è€ƒä»£ç ï¼šhttps://github.com/hku-mars/livox\_camera\_calib

ä»£ç 1():

#include <iostream>
#include <opencv2/opencv.hpp>
#include <pcl/io/pcd\_io.h>
#include <pcl/point\_types.h>
#include <pcl/point\_cloud.h>
#include <algorithm> // for min\_element, max\_element

int main() {
    // 1. è¯»å–å¸¦ intensity çš„ PCD
    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);
    if (pcl::io::loadPCDFile<pcl::PointXYZI>("your\_pointcloud.pcd", \*cloud) == -1) {
        std::cerr << "âŒ æ— æ³•åŠ è½½ PCD æ–‡ä»¶ï¼" << std::endl;
        return -1;
    }

    // 2. æå–æœ‰æ•ˆç‚¹ï¼ˆå« intensityï¼‰
    std::vector<pcl::PointXYZI> valid\_points;
    for (const auto& pt : cloud->points) {
        if (std::isfinite(pt.x) && std::isfinite(pt.y) && std::isfinite(pt.z)) {
            valid\_points.push\_back(pt);
        }
    }

    if (valid\_points.empty()) {
        std::cerr << "âš ï¸ æ²¡æœ‰æœ‰æ•ˆç‚¹ï¼" << std::endl;
        return -1;
    }

    // 3. æ„å»º OpenCV æ‰€éœ€çš„ Point3f åˆ—è¡¨ï¼ˆä»…ç”¨äº projectPointsï¼‰
    std::vector<cv::Point3f> object\_points;
    object\_points.reserve(valid\_points.size());
    for (const auto& pt : valid\_points) {
        object\_points.emplace\_back(pt.x, pt.y, pt.z);
    }

    // 4. ç›¸æœºå†…å‚ï¼ˆä½ çš„çœŸå®å‚æ•°ï¼‰
    cv::Mat cameraMatrix = (cv::Mat\_<double>(3, 3) <<
        783.890724, 0.198476, 628.151868,
        0.0,        783.350933, 382.160525,
        0.0,        0.0,        1.0
    );

    // 5. ç•¸å˜ç³»æ•°ï¼ˆä½ çš„çœŸå®å‚æ•°ï¼‰
    cv::Mat distCoeffs = (cv::Mat\_<double>(5, 1) <<
        -0.413786, 0.249752, 0.00262, -0.00224, 0.0
    );

    // 6. å¤–å‚ T\_C^Lï¼ˆä½ çš„çœŸå®å‚æ•°ï¼‰
    Eigen::Matrix4f T\_CL;
    T\_CL << -0.013604, -0.999425, -0.031069, 0.075062,
            -0.024031,  0.031390, -0.999218, 0.037218,
             0.999619, -0.012847, -0.024444, -0.692299,
             0.0,       0.0,       0.0,       1.0;

    // æå– R å’Œ t
    cv::Mat R\_mat = (cv::Mat\_<double>(3, 3) <<
        T\_CL(0,0), T\_CL(0,1), T\_CL(0,2),
        T\_CL(1,0), T\_CL(1,1), T\_CL(1,2),
        T\_CL(2,0), T\_CL(2,1), T\_CL(2,2)
    );
    cv::Mat t\_vec = (cv::Mat\_<double>(3, 1) <<
        T\_CL(0,3), T\_CL(1,3), T\_CL(2,3)
    );

    // è½¬ä¸ºæ—‹è½¬å‘é‡
    cv::Mat rvec;
    cv::Rodrigues(R\_mat, rvec);

    // 7. æŠ•å½±
    std::vector<cv::Point2f> image\_points;
    cv::projectPoints(object\_points, rvec, t\_vec, cameraMatrix, distCoeffs, image\_points);

    // 8. åˆ›å»ºå›¾åƒï¼ˆæ ¹æ®ä½ çš„ç›¸æœºåˆ†è¾¨ç‡ï¼‰
    int img\_width = 1280;   // è¯·ç¡®è®¤ä½ çš„å›¾åƒå®½åº¦
    int img\_height = 720;   // è¯·ç¡®è®¤ä½ çš„å›¾åƒé«˜åº¦
    cv::Mat img = cv::Mat::zeros(img\_height, img\_width, CV\_8UC3);

    // 9. å½’ä¸€åŒ– intensity åˆ° \[0, 255\]
    float min\_i = std::numeric\_limits<float>::max();
    float max\_i = std::numeric\_limits<float>::lowest();
    for (const auto& pt : valid\_points) {
        if (pt.intensity < min\_i) min\_i = pt.intensity;
        if (pt.intensity > max\_i) max\_i = pt.intensity;
    }
    float range = max\_i - min\_i;
    if (range <= 0) range = 1.0f; // é˜²æ­¢é™¤é›¶

    // 10. ç»˜åˆ¶ç‚¹ï¼ˆç°åº¦å›¾ï¼‰
    for (size\_t i = 0; i < image\_points.size(); ++i) {
        const cv::Point2f& p = image\_points\[i\];
        if (p.x >= 0 && p.x < img\_width && p.y >= 0 && p.y < img\_height) {
            float norm\_i = (valid\_points\[i\].intensity - min\_i) / range;
            int gray = static\_cast<int>(norm\_i \* 255.0f);
            cv::circle(img, cv::Point(static\_cast<int>(p.x), static\_cast<int>(p.y)),
                       2, cv::Scalar(gray, gray, gray), -1);
        }
    }

    // 11. ä¿å­˜ç»“æœ
    std::string out\_file = "projection\_intensity.png";
    if (cv::imwrite(out\_file, img)) {
        std::cout << "âœ… æŠ•å½±å›¾åƒå·²ä¿å­˜ä¸º: " << out\_file << std::endl;
        std::cout << "ğŸ“Š Intensity èŒƒå›´: \[" << min\_i << ", " << max\_i << "\]" << std::endl;
    } else {
        std::cerr << "âŒ æ— æ³•ä¿å­˜å›¾åƒï¼" << std::endl;
        return -1;
    }

    return 0;
}

ã€€é™„ä»¶2: å¸¦ä¸Šè‰²çš„å›¾

#include <pcl/point\_types.h>
#include <pcl/io/pcd\_io.h>
#include <pcl/filters/voxel\_grid.h>
#include <pcl/registration/icp.h>
#include <pcl/visualization/pcl\_visualizer.h>
#include <pcl/point\_cloud.h>
#include <opencv2/opencv.hpp>
#include <lidar/LdsLidar.h>
#include <thread>
#include <cmath>
#include <algorithm>

#include <pcl/common/transforms.h>
#include <pcl/common/common.h>
#include <iostream>
#include <chrono>
#include <pcl/point\_cloud.h>


int main() {
    // 1. è¯»å–å¸¦ intensity çš„ PCD
    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);
    if (pcl::io::loadPCDFile<pcl::PointXYZI>("../Config/PCD/SLIDER.pcd", \*cloud) == -1) {
        std::cerr << "âŒ æ— æ³•åŠ è½½ PCD æ–‡ä»¶ï¼" << std::endl;
        return -1;
    }

    // 2. æå–æœ‰æ•ˆç‚¹ï¼ˆå« intensityï¼‰
    std::vector<pcl::PointXYZI> validPoints;
    for (const auto& pt : cloud->points) {
        if (std::isfinite(pt.x) && std::isfinite(pt.y) && std::isfinite(pt.z)) {
            validPoints.push\_back(pt);
        }
    }

    if (validPoints.empty()) {
        std::cerr << "âš ï¸ æ²¡æœ‰æœ‰æ•ˆç‚¹ï¼" << std::endl;
        return -1;
    }

    // 3. æ„å»º OpenCV æ‰€éœ€çš„ Point3f åˆ—è¡¨ï¼ˆä»…ç”¨äº projectPointsï¼‰
    std::vector<cv::Point3f> objectPoints;
    objectPoints.reserve(validPoints.size());
    for (const auto& pt : validPoints) {
        objectPoints.emplace\_back(pt.x, pt.y, pt.z);
    }

    // 4. ç›¸æœºå†…å‚ï¼ˆä½ çš„çœŸå®å‚æ•°ï¼‰
    cv::Mat cameraMatrix = (cv::Mat\_<double>(3, 3) <<
                                                   783.890724, 0.198476, 628.151868,
            0.0,        783.350933, 382.160525,
            0.0,        0.0,        1.0
    );

    // 5. ç•¸å˜ç³»æ•°ï¼ˆä½ çš„çœŸå®å‚æ•°ï¼‰
    cv::Mat distCoeffs = (cv::Mat\_<double>(5, 1) <<
                                                 -0.413786, 0.249752, 0.00262, -0.00224, 0.0
    );

    // 6. å¤–å‚ T\_C^Lï¼ˆä½ çš„çœŸå®å‚æ•°ï¼‰
    Eigen::Matrix4f T\_CL;
    T\_CL << -0.013604, -0.999425, -0.031069, 0.075062,
            -0.024031,  0.031390, -0.999218, 0.037218,
            0.999619, -0.012847, -0.024444, -0.692299,
            0.0,       0.0,       0.0,       1.0;

    // æå– R å’Œ t
    cv::Mat R\_mat = (cv::Mat\_<double>(3, 3) <<
                                            T\_CL(0,0), T\_CL(0,1), T\_CL(0,2),
            T\_CL(1,0), T\_CL(1,1), T\_CL(1,2),
            T\_CL(2,0), T\_CL(2,1), T\_CL(2,2)
    );
    cv::Mat t\_vec = (cv::Mat\_<double>(3, 1) <<
                                            T\_CL(0,3), T\_CL(1,3), T\_CL(2,3)
    );

    // è½¬ä¸ºæ—‹è½¬å‘é‡
    cv::Mat rvec;
    cv::Rodrigues(R\_mat, rvec);

    // 7. æŠ•å½±
    std::vector<cv::Point2f> imagePoints;
    cv::projectPoints(objectPoints, rvec, t\_vec, cameraMatrix, distCoeffs, imagePoints);

    // 8. åˆ›å»ºå›¾åƒï¼ˆæ ¹æ®ä½ çš„ç›¸æœºåˆ†è¾¨ç‡ï¼‰
    int imgWidth = 1280;   // è¯·ç¡®è®¤ä½ çš„å›¾åƒå®½åº¦
    int imgHeight = 720;   // è¯·ç¡®è®¤ä½ çš„å›¾åƒé«˜åº¦

    // 9. å½’ä¸€åŒ– intensity åˆ° \[0, 255\]
    float minI = std::numeric\_limits<float>::max();
    float maxI = std::numeric\_limits<float>::lowest();
    for (const auto& pt : validPoints) {
        if (pt.intensity < minI) minI = pt.intensity;
        if (pt.intensity > maxI) maxI = pt.intensity;
    }
    float range = maxI - minI;
    if (range <= 0) range = 1.0f; // é˜²æ­¢é™¤é›¶

    // === 9. åˆ›å»ºå•é€šé“ç°åº¦å›¾ ===
    cv::Mat grayImg = cv::Mat::zeros(imgHeight, imgWidth, CV\_8UC1);

    for (size\_t i = 0; i < imagePoints.size(); ++i) {
        const cv::Point2f& p = imagePoints\[i\];
        int x = static\_cast<int>(p.x + 0.5);
        int y = static\_cast<int>(p.y + 0.5);

        if (x >= 0 && x < imgWidth && y >= 0 && y < imgHeight) {
            float norm\_i = (validPoints\[i\].intensity - minI) / range;
            uint8\_t val = static\_cast<uint8\_t>(std::min(255.0f, std::max(0.0f, norm\_i \* 255.0f)));

            // å¯é€‰ï¼šä¿ç•™æœ€å¼ºåå°„ï¼ˆæœ€å¤§ intensityï¼‰
            auto& current = grayImg.at<uint8\_t>(y, x);
            if (val > current) {
                current = val;
            }
        }
    }
    // === 10. åº”ç”¨ JET ä¼ªå½©è‰² ===
    cv::Mat colorImg;
    cv::applyColorMap(grayImg, colorImg, cv::COLORMAP\_JET);

    // === 11. å°†æ— ç‚¹åŒºåŸŸè®¾ä¸ºé»‘è‰²ï¼ˆé»˜è®¤ JET ä¸­ 0=æ·±è“ï¼Œæˆ‘ä»¬æ”¹ä¸ºé»‘ï¼‰===
    cv::Mat mask = (grayImg == 0);
    colorImg.setTo(cv::Scalar(0, 0, 0), mask); // BGR é»‘è‰²

    // 12. ä¿å­˜ç»“æœ
    std::string outFile = "projection\_color.png";
    if (cv::imwrite(outFile, colorImg)) {
        std::cout << "âœ… æŠ•å½±å›¾åƒå·²ä¿å­˜ä¸º: " << outFile << std::endl;
        std::cout << "ğŸ“Š Intensity èŒƒå›´: \[" << minI << ", " << maxI << "\]" << std::endl;
    } else {
        std::cerr << "âŒ æ— æ³•ä¿å­˜å›¾åƒï¼" << std::endl;
        return -1;
    }

    return 0;
}