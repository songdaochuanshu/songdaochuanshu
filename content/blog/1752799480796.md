---
layout: post
title: '揭开SQL Server和PostgreSQL填充因子的神秘面纱'
date: "2025-07-18T00:44:40Z"
---
揭开SQL Server和PostgreSQL填充因子的神秘面纱
================================

揭开SQL Server和PostgreSQL填充因子的神秘面纱
================================

### 理解SQL Server和PostgreSQL中的填充因子

在调优数据库性能时，一些小设置往往能带来显著的差异。填充因子就是其中一个经常讨论的设置。SQL Server和PostgreSQL都支持这一概念，但它们的处理方式有所不同。 如果你在管理这两种系统中的数据库，了解填充因子的工作原理可以帮助你避免因索引页拆分、索引碎片以及不必要的磁盘I/O带来的头疼问题。

### 填充因子的概念

让我们先从一个比喻开始。假设你在整理书架。如果你把书架填得满满的，除非你拿出一些书或重新排列，否则就没有空间再放新书。这基本上就是数据库页面的工作方式。当数据库页面变满并且需要容纳更多数据时，它就必须拆分，这会消耗时间和资源。而填充因子就是一个设置，它允许你在每个页面上留出一些“空间”，就像在书架上留出空间以便以后放置新书一样。

![](https://img2024.cnblogs.com/blog/257159/202501/257159-20250128130335717-1613406076.png)

### SQL Server中的填充因子

在SQL Server中，填充因子是一个专门的索引设置。当你定义或重建索引时，可以设置填充因子来控制每个索引页面的填充程度。 例如，如果你将填充因子设置为90%，SQL Server会在每个索引页面上留出10%的空间，为将来的插入新数据或更新保留空间。 这可以减少页拆分发生的可能性，页拆分是一项成本较高的操作，可能会导致查询变慢。 默认情况下，SQL Server的填充因子设置为80%，意味着它会将每个索引页面填满。这对于读取密集型的工作负载效果很好，因为数据更改较少。但是，如果你的工作负载涉及频繁的更新或插入，较低的填充因子可以减少索引碎片。 假设有一个名为“Orders”的表，在“OrderDate”字段上有一个聚集索引。该表每天都会接收频繁的更新和插入新记录。 以下是如何设置自定义填充因子的示例：

    -- 使用自定义填充因子重建索引
    ALTER INDEX idx_OrderDate ON Orders  REBUILD WITH (FILLFACTOR = 90);

在这个示例中，SQL Server在重建索引时会将每个索引页面留出10%的空间。这个额外的空间确保未来的插入或更新不太可能触发页拆分，从而提高整体性能。我们还可以使用以下命令设置服务器范围的默认填充因子：

    -- 设置服务器范围的填充因子为90
    EXEC sp_configure 'fill factor', 90;
    RECONFIGURE;

### PostgreSQL中的填充因子

在PostgreSQL中，填充因子的作用范围更广，它既可以应用于表，也可以应用于索引。这是因为PostgreSQL的架构造成的，尤其是它使用的MVCC（多版本并发控制）架构。当PostgreSQL中的一行数据被更新时，系统会创建该行的一个新版本，而旧版本会保留在原页面，直到执行“清理”操作（vacuum）。如果同一页面上没有足够的空间存储新版本，PostgreSQL将不得不将其写到其他地方，这会导致表膨胀并增加“清理”过程中的额外开销。通过设置较低的填充因子，我们可以为更新留出更多空间，这样更新就能在同一页面上进行。 例如，填充因子为90意味着每个页面初始只使用90%的空间，留出10%的空间供未来更新使用。这减少了行数据移动的可能性，最小化了PostgreSQL在更新后进行“清理”时的开销。 假设有一个名为“customers”的表，频繁更新其中的“last\_login”字段。以下是如何为这个表设置自定义填充因子的示例：

    -- 创建具有自定义填充因子的表
    CREATE TABLE customers (
        customer_id SERIAL PRIMARY KEY,
        name TEXT,
        last_login TIMESTAMP
    ) WITH (fillfactor = 90);

此配置为每个页面保留了10%的空间，用于将来的更新，确保“last\_login”字段的更新不会导致不必要的行数据移动。我们还可以调整现有表或索引的填充因子：

    -- 修改现有表的填充因子，PostgreSQL才会有的选项
    ALTER TABLE customers SET (fillfactor = 90);
    
    -- 创建具有自定义填充因子的索引
    CREATE INDEX idx_last_login ON customers (last_login) WITH (fillfactor = 90);

### 默认值和关键差异

有趣的是，PostgreSQL的默认填充因子是100%，这对于写操作密集型的工作负载来说似乎有些违反直觉。 这个默认值是一个折衷，平衡了存储效率和性能，以适应一般的使用场景。这两个数据库之间的关键差异在于它们的作用范围和目的。SQL Server的填充因子专注于索引，旨在减少特定场景中的索引碎片和索引页拆分。 另一方面，PostgreSQL将填充因子作为一个更广泛的工具，不仅用于索引，还用于处理与MVCC相关的表级别的挑战。 这使得PostgreSQL的填充因子在写操作密集型环境中尤为有价值，因为在这些环境中，更新和行版本管理非常频繁。

### 实际考虑

如何在数据库中使用填充因子呢？答案取决于你的工作负载。 在SQL Server中，对于那些经常进行更新或插入操作的索引，较低的填充因子是必需的。 而在PostgreSQL中，你可能会考虑调整表和索引的填充因子，特别是对于那些经常需要大量写入的表，以减少膨胀并优化“清理”操作。

### 总结

归根结底，填充因子是一个值得通过实验和观察来调整的设置。 通过了解它在每个系统中的工作原理，并在你的特定环境中进行测试，你可以在性能和存储效率之间找到合适的平衡。 毕竟，数据库就像书架，一些额外的空间可以带来很大的帮助。

![](https://img2024.cnblogs.com/blog/257159/202409/257159-20240908204310924-1005667056.png)

**本文版权归作者所有，未经作者同意不得转载。**