---
layout: post
title: 'ConcurrentHashMapçš„Nullç¦ä»¤ï¼šä¸€åœºé’ˆå¯¹â€œæ¸£ç”·â€Nullçš„å®Œç¾é˜²å«æˆ˜'
date: "2025-09-04T00:38:13Z"
---
ConcurrentHashMapçš„Nullç¦ä»¤ï¼šä¸€åœºé’ˆå¯¹â€œæ¸£ç”·â€Nullçš„å®Œç¾é˜²å«æˆ˜
===========================================

å¼•è¨€ï¼šä¸€åœºå€¼å¾—æ·±æ€çš„è®¾è®¡æŠ‰æ‹©
--------------

åœ¨Javaé›†åˆæ¡†æ¶çš„æµ©ç€šå®‡å®™ä¸­ï¼Œ`ConcurrentHashMap`ï¼ˆä»¥ä¸‹ç®€ç§°CHMï¼‰æ— ç–‘æ˜¯æœ€è€€çœ¼çš„æ˜æ˜Ÿä¹‹ä¸€ã€‚ä½œä¸ºé«˜å¹¶å‘ç¯å¢ƒçš„ç‹è€…ï¼Œå®ƒä»¥å…¶å“è¶Šçš„æ€§èƒ½å’Œçº¿ç¨‹å®‰å…¨æ€§å¾æœäº†æ— æ•°å¼€å‘è€…ã€‚ä½†è¿™ä½ç‹è€…æœ‰ä¸€ä¸ªçœ‹ä¼¼"ä¸è¿‘äººæƒ…"çš„åŸåˆ™ï¼š**åšå†³æ‹’ç»nullä½œä¸ºkeyæˆ–value**ã€‚

è¿™ä¸ªè®¾è®¡å†³ç­–å¸¸å¸¸è®©åˆšä»HashMapè½¬æ¥çš„å¼€å‘è€…å›°æƒ‘ä¸å·²ã€‚ä¸ºä»€ä¹ˆHashMapå¯ä»¥å¦ç„¶æ¥å—nullï¼Œè€ŒCHMå´å¦‚æ­¤å†³ç»ï¼ŸèƒŒåç©¶ç«Ÿéšè—ç€æ€æ ·çš„æ·±æ„ï¼Ÿä»Šå¤©ï¼Œè®©æˆ‘ä»¬æ­å¼€è¿™ä¸ªè®¾è®¡èƒŒåçš„æ€è€ƒï¼Œçœ‹çœ‹CHMå¦‚ä½•åœ¨è¿™åœºä¸nullçš„è¾ƒé‡ä¸­æå«äº†å¹¶å‘ä¸–ç•Œçš„ç§©åºã€‚

ç¬¬ä¸€éƒ¨åˆ†ï¼šNullçš„"æ¸£ç”·"æœ¬è´¨â€”â€”ä»¤äººå›°æƒ‘çš„äºŒä¹‰æ€§
--------------------------

### 1.1 ä¸€ä¸ªç®€å•çš„æ€ç»´å®éªŒ

æƒ³è±¡ä¸€ä¸‹è¿™ä¸ªåœºæ™¯ï¼šä½ ä½œä¸ºçº¿ç¨‹Aï¼Œè°ƒç”¨äº† `concurrentMap.get("annualBonus")` æ¥æŸ¥è¯¢ä½ çš„å¹´ç»ˆå¥–ï¼Œç»“æœè¿”å›äº† `null`ã€‚

æ­¤åˆ»ï¼Œä½ çš„å†…å¿ƒä¼šäº§ç”Ÿä¸¤ç§æˆªç„¶ä¸åŒçš„è§£è¯»ï¼š

*   **ä¹è§‚è§£è¯»**ï¼š"å¤ªå¥½äº†ï¼è¿™ä¸ªkeyä¸å­˜åœ¨ï¼Œè¯´æ˜HRè¿˜æ²¡å½•å…¥æ•°æ®ï¼Œå¹´ç»ˆå¥–è¿˜æœ‰å¸Œæœ›ï¼"
*   **æ‚²è§‚è§£è¯»**ï¼š"å®Œäº†ï¼è¿™ä¸ªkeyå­˜åœ¨ï¼Œä½†valueæ˜ç¡®æ˜¯nullï¼Œè¯´æ˜å…¬å¸å†³å®šä»Šå¹´ä¸å‘å¹´ç»ˆå¥–äº†ï¼"

è¿™å°±æ˜¯nullå¸¦æ¥çš„**äºŒä¹‰æ€§é™·é˜±**â€”â€”å•ä»è¿”å›å€¼æœ¬èº«ï¼Œä½ æ ¹æœ¬æ— æ³•åŒºåˆ†è¿™ä¸¤ç§å¤©å·®åœ°å†µï¼

### 1.2 HashMapçš„è§£å†³æ–¹æ¡ˆåŠå…¶å±€é™

åœ¨å•çº¿ç¨‹çš„HashMapä¸–ç•Œä¸­ï¼Œè¿™ä¸ªé—®é¢˜ä¼¼ä¹æœ‰è§£ï¼š

    HashMap<String, Double> map = new HashMap<>();
    map.put("annualBonus", null); // æ˜ç¡®å­˜å‚¨nullå€¼
    
    Double bonus = map.get("annualBonus");
    if (bonus == null) {
        if (map.containsKey("annualBonus")) {
            System.out.println("å¹´ç»ˆå¥–æ˜ç¡®è®¾ç½®ä¸ºé›¶"); // æƒ…å†µäºŒ
        } else {
            System.out.println("æ²¡æœ‰å¹´ç»ˆå¥–è®°å½•"); // æƒ…å†µä¸€
        }
    }
    

HashMapé€šè¿‡æä¾›`containsKey()`æ–¹æ³•ä½œä¸ºè¾…åŠ©åˆ¤æ–­ï¼Œå‹‰å¼ºè§£å†³äº†è¿™ä¸ªäºŒä¹‰æ€§é—®é¢˜ã€‚ä½†è¿™ç§æ–¹æ³•åœ¨å¹¶å‘ç¯å¢ƒä¸‹å´å®Œå…¨å¤±æ•ˆäº†â€”â€”åœ¨ä¸¤ä¸ªæ–¹æ³•è°ƒç”¨ä¹‹é—´çš„å¾®å°é—´éš™ï¼Œå…¶ä»–çº¿ç¨‹å¯èƒ½å·²ç»ä¿®æ”¹äº†æ˜ å°„å…³ç³»ã€‚

### 1.3 å¹¶å‘ç¯å¢ƒçš„æ”¾å¤§æ•ˆåº”

åœ¨å¹¶å‘ä¸–ç•Œä¸­ï¼Œæ—¶é—´å·®å°±æ˜¯ä¸€åˆ‡ã€‚è€ƒè™‘ä»¥ä¸‹æ—¶åºï¼š

1.  çº¿ç¨‹Aè°ƒç”¨ `get("key")`ï¼Œå¾—åˆ°null
2.  çº¿ç¨‹Bçªç„¶æ’å…¥ `put("key", "value")`
3.  çº¿ç¨‹Aè°ƒç”¨ `containsKey("key")`ï¼Œå¾—åˆ°true

çº¿ç¨‹Aæ­¤åˆ»çš„ç»“è®ºä¼šæ˜¯ï¼š"å“¦ï¼Œkeyå­˜åœ¨ä½†å€¼ä¸ºnull"ï¼Œè¿™å®Œå…¨æ˜¯ä¸€ä¸ªé”™è¯¯çš„åˆ¤æ–­ï¼

è¿™ç§ç«æ€æ¡ä»¶ï¼ˆrace conditionï¼‰ä½¿å¾—åŸºäºä¸¤æ¬¡è°ƒç”¨çš„åˆ¤æ–­æ–¹å¼å˜å¾—å®Œå…¨ä¸å¯é ï¼Œè€Œnullçš„äºŒä¹‰æ€§æ­£æ˜¯æ”¾å¤§è¿™ä¸ªé—®é¢˜çš„ç½ªé­ç¥¸é¦–ã€‚

ç¬¬äºŒéƒ¨åˆ†ï¼šè®¾è®¡å“²å­¦ä¹‹äº‰â€”â€”ä¸ºä»€ä¹ˆHashMapä¸CHMåˆ†é“æ‰¬é•³
-------------------------------

### 2.1 HashMapçš„è®¾è®¡èƒŒæ™¯ä¸å“²å­¦

`HashMap`è¯ç”ŸäºJava 1.2ï¼Œé‚£æ—¶å¤šæ ¸å¤„ç†å™¨è¿˜æœªæ™®åŠï¼Œå¹¶å‘ç¼–ç¨‹å¹¶éè®¾è®¡é‡ç‚¹ã€‚HashMapçš„è®¾è®¡å“²å­¦ä½“ç°äº†"çµæ´»æ€§ä¼˜å…ˆ"çš„æ€æƒ³ï¼š

*   **å…è®¸null**ï¼šä¸ºå¼€å‘è€…æä¾›ä¾¿åˆ©ï¼Œå…è®¸ä½¿ç”¨nullè¡¨ç¤º"æœªè®¾ç½®"æˆ–"æ— æ„ä¹‰"
*   **æ–‡æ¡£è¯´æ˜**ï¼šé€šè¿‡æ–‡æ¡£æ˜ç¡®å‘ŠçŸ¥å¼€å‘è€…nullçš„äºŒä¹‰æ€§ï¼Œå¹¶å°†åŒºåˆ†è´£ä»»äº¤ç»™è°ƒç”¨è€…
*   **å•çº¿ç¨‹å‡è®¾**ï¼šåŸºäºå½“æ—¶çš„ä¸»æµä½¿ç”¨åœºæ™¯ï¼Œæ²¡æœ‰å……åˆ†è€ƒè™‘å¹¶å‘è®¿é—®

æ­£å¦‚HashMapçš„APIæ–‡æ¡£æ‰€è¨€ï¼š"è¿”å›nullä¸ä¸€å®šè¡¨ç¤ºæ˜ å°„ä¸åŒ…å«è¯¥é”®çš„æ˜ å°„ï¼›ä¹Ÿå¯èƒ½è¡¨ç¤ºæ˜ å°„æ˜¾å¼åœ°å°†é”®æ˜ å°„åˆ°nullã€‚"

### 2.2 ConcurrentHashMapçš„è®¾è®¡é©å‘½

å½“Doug Leaå¤§å¸ˆåœ¨Java 5ä¸­å¼•å…¥J.U.CåŒ…æ—¶ï¼Œå¹¶å‘ç¼–ç¨‹æ­£æˆä¸ºæ—¥ç›Šé‡è¦çš„è®®é¢˜ã€‚CHMçš„è®¾è®¡å“²å­¦ä½“ç°äº†"å®‰å…¨æ€§ä¸æ˜ç¡®æ€§ä¼˜å…ˆ"çš„åŸåˆ™ï¼š

#### 2.2.1 æŠ€æœ¯å®ç°çº¦æŸ

CHMçš„å¹¶å‘æ§åˆ¶åŸºäºç²¾ç»†çš„é”åˆ†æ®µæŠ€æœ¯ï¼ˆJava 7åŠä¹‹å‰ï¼‰æˆ–CASæ“ä½œï¼ˆJava 8+ï¼‰ï¼Œè¿™äº›æœºåˆ¶æœ¬èº«å°±ä¸é€‚åˆå¤„ç†nullå€¼ï¼š

*   **é”åˆ†æ®µ**ï¼šéœ€è¦åŸºäºå¯¹è±¡çš„monitorï¼Œè€Œnullæ²¡æœ‰monitor
*   **CASæ“ä½œ**ï¼šéœ€è¦æ¯”è¾ƒé¢„æœŸå€¼ï¼Œè€Œnullä½œä¸ºç‰¹æ®Šå€¼ä¼šå¢åŠ æ¯”è¾ƒå¤æ‚åº¦
*   **å“ˆå¸Œè®¡ç®—**ï¼šnullçš„å“ˆå¸Œå€¼å®šä¹‰ä¸æ˜ç¡®ï¼ˆå®é™…ä¸Šè§„å®šä¸º0ï¼‰

#### 2.2.2 å“²å­¦ç†å¿µå‡çº§

CHMçš„è®¾è®¡é€‰æ‹©åæ˜ äº†ä¸€ç§æ›´æ·±å±‚æ¬¡çš„å·¥ç¨‹å“²å­¦ï¼š

> **åœ¨å¹¶å‘ç³»ç»Ÿä¸­ï¼Œæ˜ç¡®æ€§æ¯”çµæ´»æ€§æ›´é‡è¦ï¼Œå¯é¢„æµ‹æ€§æ¯”ä¾¿åˆ©æ€§æ›´æœ‰ä»·å€¼ã€‚**

è¿™ç§å“²å­¦é€‰æ‹©ç±»ä¼¼äºå¼ºç±»å‹è¯­è¨€ä¸å¼±ç±»å‹è¯­è¨€çš„åŒºåˆ«ï¼šå‰è€…é€šè¿‡é™åˆ¶çµæ´»æ€§æ¥æ¢å–å®‰å…¨æ€§å’Œæ€§èƒ½ï¼Œåè€…åˆ™ç›¸åã€‚

### 2.3 å®é™…æ¡ˆä¾‹ï¼šå¦‚æœCHMå…è®¸nullä¼šæ€æ ·

å‡è®¾CHMå…è®¸nullå€¼ï¼Œè€ƒè™‘ä»¥ä¸‹ä»£ç ï¼š

    // å‡è®¾CHMå…è®¸nullï¼ˆå®é™…ä¸Šä¸å…è®¸ï¼‰
    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
    
    // çº¿ç¨‹A
    String value = map.get("key");
    if (value == null) {
        // æ— æ³•ç¡®å®šæ˜¯keyä¸å­˜åœ¨è¿˜æ˜¯valueä¸ºnull
        if (map.containsKey("key")) { // æ³¨æ„ï¼šè¿™ä¸æ˜¯åŸå­æ“ä½œï¼
            System.out.println("Key exists with null value");
        } else {
            System.out.println("Key does not exist");
        }
    }
    

åœ¨å¹¶å‘ç¯å¢ƒä¸‹ï¼Œå³ä½¿ä¸¤ä¸ªæ–¹æ³•è¿ç»­è°ƒç”¨ï¼Œä¸­é—´ä¹Ÿå¯èƒ½è¢«å…¶ä»–çº¿ç¨‹ä¿®æ”¹ï¼Œä½¿å¾—åˆ¤æ–­ç»“æœæ— æ•ˆç”šè‡³è¯¯å¯¼ç¨‹åºè¡Œä¸ºã€‚

ç¬¬ä¸‰éƒ¨åˆ†ï¼šè¶…è¶Šç¦ä»¤â€”â€”å¦‚ä½•åœ¨CHMä¸­ä¼˜é›…å¤„ç†ç©ºå€¼
------------------------

### 3.1 ç©ºå¯¹è±¡æ¨¡å¼ï¼ˆNull Object Patternï¼‰

æœ€ç»å…¸çš„è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨ä¸€ä¸ªä¸“é—¨çš„ç©ºå¯¹è±¡æ¥è¡¨ç¤º"ç©ºæ„ä¹‰"ï¼š

    public class NullSafeMapExample {
        // å®šä¹‰ä¸€ä¸ªæ˜ç¡®çš„ç©ºå€¼æ ‡è®°
        private static final Object NULL_PLACEHOLDER = new Object();
        
        private final ConcurrentHashMap<String, Object> map = new ConcurrentHashMap<>();
        
        public void putNullValue(String key) {
            map.put(key, NULL_PLACEHOLDER);
        }
        
        public boolean isKeyPresentWithNull(String key) {
            return map.get(key) == NULL_PLACEHOLDER;
        }
        
        public boolean isKeyAbsent(String key) {
            return !map.containsKey(key);
        }
    }
    

è¿™ç§æ–¹æ³•å®Œå…¨æ¶ˆé™¤äº†äºŒä¹‰æ€§ï¼šå¦‚æœä¸€ä¸ªkeyå­˜åœ¨ä¸”å€¼ä¸º`NULL_PLACEHOLDER`ï¼Œæˆ‘ä»¬å°±æ˜ç¡®çŸ¥é“è¿™æ˜¯"æœ‰æ„ä¹‰çš„ç©º"ã€‚

### 3.2 Optionalå®¹å™¨ï¼ˆJava 8+ï¼‰

Java 8å¼•å…¥çš„`Optional`ç±»ä¸ºè¿™ä¸ªé—®é¢˜æä¾›äº†æ›´ä¼˜é›…çš„è§£å†³æ–¹æ¡ˆï¼š

    ConcurrentHashMap<String, Optional<String>> map = new ConcurrentHashMap<>();
    
    // å­˜å‚¨ç©ºå€¼
    map.put("nullableKey", Optional.empty());
    
    // å­˜å‚¨å®é™…å€¼
    map.put("normalKey", Optional.of("actual value"));
    
    // æ£€ç´¢å€¼
    Optional<String> result = map.get("someKey");
    if (result != null) { // æ³¨æ„ï¼šè¿™é‡Œæ£€æŸ¥çš„æ˜¯Optionalå¯¹è±¡æ˜¯å¦ä¸ºnull
        if (result.isPresent()) {
            System.out.println("å€¼å­˜åœ¨: " + result.get());
        } else {
            System.out.println("é”®å­˜åœ¨ä½†å€¼ä¸ºç©º");
        }
    } else {
        System.out.println("é”®ä¸å­˜åœ¨");
    }
    

Optionalæä¾›äº†ç±»å‹å®‰å…¨çš„ç©ºå€¼è¡¨ç¤ºï¼Œå®Œå…¨æ¶ˆé™¤äº†äºŒä¹‰æ€§é—®é¢˜ã€‚

### 3.3 æ ‡è®°æ¥å£ä¸ç‰¹æ®Šå€¼

æ ¹æ®å…·ä½“ä¸šåŠ¡åœºæ™¯ï¼Œä¹Ÿå¯ä»¥å®šä¹‰ç‰¹æ®Šçš„æ ‡è®°å€¼ï¼š

    public interface PaymentService {
        ConcurrentHashMap<String, BigDecimal> PAYMENT_CACHE = new ConcurrentHashMap<>();
        
        // ç‰¹æ®Šå€¼è¡¨ç¤ºä¸åŒçŠ¶æ€
        BigDecimal PENDING = BigDecimal.valueOf(-1);
        BigDecimal FAILED = BigDecimal.valueOf(-2);
        BigDecimal NOT_APPLICABLE = BigDecimal.valueOf(-3);
        
        default void processPayment(String userId, BigDecimal amount) {
            if (amount == null) {
                PAYMENT_CACHE.put(userId, NOT_APPLICABLE);
            } else {
                PAYMENT_CACHE.put(userId, amount);
            }
        }
    }
    

ç¬¬å››éƒ¨åˆ†ï¼šæ·±å…¥æŠ€æœ¯å®ç°â€”â€”ä¸ºä»€ä¹ˆnullä¼šç ´åå¹¶å‘å®‰å…¨
---------------------------

### 4.1 å†…å­˜å¯è§æ€§ä¸é‡æ’åºé—®é¢˜

ç°ä»£JVMå’Œå¤„ç†å™¨ä¸ºäº†ä¼˜åŒ–æ€§èƒ½ï¼Œä¼šè¿›è¡ŒæŒ‡ä»¤é‡æ’åºã€‚åœ¨å¹¶å‘ç¯å¢ƒä¸­ï¼Œnullå€¼å¯èƒ½å¼•å…¥å¾®å¦™çš„å†…å­˜å¯è§æ€§é—®é¢˜ï¼š

    // å‡è®¾CHMå…è®¸nullï¼ˆä¼ªä»£ç ï¼‰
    if (map.get(key) == null) {
        // æ­¤æ—¶ï¼Œå…¶ä»–çº¿ç¨‹å¯èƒ½æ­£åœ¨æ’å…¥nullå€¼
        // ç”±äºå†…å­˜å¯è§æ€§é—®é¢˜ï¼Œå½“å‰çº¿ç¨‹å¯èƒ½çœ‹ä¸åˆ°æœ€æ–°å€¼
        map.putIfAbsent(key, null); // æœŸæœ›åŸå­æ“ä½œï¼Œä½†nullå€¼ä½¿è¯­ä¹‰å¤æ‚åŒ–
    }
    

nullä½œä¸ºä¸€ä¸ªç‰¹æ®Šå€¼ï¼Œä¼šå¹²æ‰°JVMå¯¹å†…å­˜å¯è§æ€§çš„ä¼˜åŒ–ï¼Œå› ä¸ºç¼–è¯‘å™¨éš¾ä»¥ä¼˜åŒ–å¯¹ç‰¹æ®Šå€¼çš„å¤„ç†ã€‚

### 4.2 å¹¶å‘ç®—æ³•çš„å¤æ‚æ€§

CHMå†…éƒ¨ä½¿ç”¨å¤æ‚çš„å¹¶å‘ç®—æ³•ï¼Œå¦‚Java 8ä¸­çš„CASï¼ˆCompare-And-Swapï¼‰æ“ä½œï¼š

    // CASæ“ä½œä¼ªä»£ç 
    boolean compareAndSet(expectedValue, newValue) {
        if (currentValue == expectedValue) {
            currentValue = newValue;
            return true;
        }
        return false;
    }
    

å¦‚æœå…è®¸nullï¼Œé‚£ä¹ˆexpectedValueä¹Ÿå¯èƒ½æ˜¯nullï¼Œè¿™å¢åŠ äº†æ¡ä»¶åˆ¤æ–­çš„å¤æ‚æ€§ï¼Œå¹¶å¯èƒ½å¼•å…¥è¾¹ç¼˜æƒ…å†µbugã€‚

### 4.3 åºåˆ—åŒ–ä¸ååºåˆ—åŒ–çš„æŒ‘æˆ˜

nullå€¼åœ¨åºåˆ—åŒ–å’Œååºåˆ—åŒ–è¿‡ç¨‹ä¸­ä¹Ÿä¼šå¸¦æ¥é¢å¤–å¤æ‚æ€§ï¼š

    // ååºåˆ—åŒ–æ—¶ï¼Œéœ€è¦åŒºåˆ†"å­—æ®µä¸å­˜åœ¨"å’Œ"å­—æ®µå€¼ä¸ºnull"
    public class ConcurrentHashMap implements Serializable {
        // ååºåˆ—åŒ–ä»£ç éœ€è¦é¢å¤–å¤„ç†nullå€¼
        private void readObject(ObjectInputStream in) 
            throws IOException, ClassNotFoundException {
            // å¦‚æœå…è®¸nullï¼Œè¿™é‡Œéœ€è¦æ›´å¤æ‚çš„é€»è¾‘
        }
    }
    

ç¬¬äº”éƒ¨åˆ†ï¼šå®è·µæŒ‡å—ä¸æœ€ä½³å®è·µ
--------------

### 5.1 æ£€æµ‹ä¸é¢„é˜²nullå€¼

åœ¨å®é™…å¼€å‘ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡å–ä¸»åŠ¨ç­–ç•¥é˜²æ­¢nullå€¼è¢«æ„å¤–æ’å…¥ï¼š

    public class NullSafeConcurrentHashMap<K, V> {
        private final ConcurrentHashMap<K, V> delegate = new ConcurrentHashMap<>();
        
        public V put(K key, V value) {
            if (key == null || value == null) {
                throw new NullPointerException("Null values not permitted");
            }
            return delegate.put(key, value);
        }
        
        public V putIfAbsent(K key, V value) {
            if (key == null || value == null) {
                throw new NullPointerException("Null values not permitted");
            }
            return delegate.putIfAbsent(key, value);
        }
        
        // å§”æ‰˜å…¶ä»–æ–¹æ³•...
    }
    

### 5.2 è¿ç§»ç­–ç•¥ï¼šä»HashMapåˆ°ConcurrentHashMap

å½“ä»HashMapè¿ç§»åˆ°ConcurrentHashMapæ—¶ï¼Œéœ€è¦å¤„ç†ç°æœ‰çš„nullå€¼ï¼š

    public class MapMigrationService {
        public static <K, V> ConcurrentHashMap<K, V> migrateFromHashMap(
            HashMap<K, V> source, V nullReplacement) {
            
            ConcurrentHashMap<K, V> target = new ConcurrentHashMap<>();
            
            for (Map.Entry<K, V> entry : source.entrySet()) {
                K key = entry.getKey();
                V value = entry.getValue();
                
                if (key == null) {
                    throw new IllegalArgumentException("Null keys not supported");
                }
                
                if (value == null) {
                    target.put(key, nullReplacement);
                } else {
                    target.put(key, value);
                }
            }
            
            return target;
        }
    }
    

### 5.3 æµ‹è¯•ç­–ç•¥ï¼šç¡®ä¿nullå®‰å…¨

ä¸ºå¹¶å‘é›†åˆç¼–å†™æµ‹è¯•æ—¶ï¼Œéœ€è¦ç‰¹åˆ«å…³æ³¨nullå¤„ç†ï¼š

    public class ConcurrentHashMapTest {
        @Test(expected = NullPointerException.class)
        public void testPutNullKey() {
            ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
            map.put(null, "value");
        }
        
        @Test(expected = NullPointerException.class)
        public void testPutNullValue() {
            ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
            map.put("key", null);
        }
        
        @Test
        public void testReplaceWithNull() {
            ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
            map.put("key", "value");
            
            // replaceæ–¹æ³•ä¹Ÿä¸å…è®¸nullå€¼
            try {
                map.replace("key", null);
                fail("Expected NullPointerException");
            } catch (NullPointerException expected) {
                // æµ‹è¯•é€šè¿‡
            }
        }
    }
    

ç»“è®ºï¼šåŸåˆ™èƒŒåçš„æ™ºæ…§
----------

`ConcurrentHashMap`å¯¹nullçš„ç¦ä»¤çœ‹ä¼¼ä¸¥è‹›ï¼Œå®åˆ™ä½“ç°äº†æ·±åˆ»çš„è®¾è®¡æ™ºæ…§ã€‚åœ¨å¹¶å‘ç¼–ç¨‹è¿™ä¸ªå……æ»¡ä¸ç¡®å®šæ€§çš„ä¸–ç•Œé‡Œï¼ŒCHMé€šè¿‡è¿™æ¡æ˜ç¡®çš„åŸåˆ™ï¼š

1.  **æ¶ˆé™¤äº†äºŒä¹‰æ€§**ï¼šä½¿ç¨‹åºè¡Œä¸ºæ›´åŠ å¯é¢„æµ‹å’Œå¯é 
2.  **ç®€åŒ–äº†å®ç°**ï¼šå‡å°‘äº†è¾¹ç¼˜æƒ…å†µï¼Œæé«˜äº†æ€§èƒ½å’Œç¨³å®šæ€§
3.  **å¼ºåŒ–äº†å¥‘çº¦**ï¼šé€šè¿‡å¿«é€Ÿå¤±è´¥æœºåˆ¶æå‰æš´éœ²é—®é¢˜ï¼Œè€Œä¸æ˜¯éšè—é—®é¢˜

æ­£å¦‚è®¡ç®—æœºç§‘å­¦ä¸­çš„è®¸å¤šæœ€ä½³å®è·µä¸€æ ·ï¼Œè¿™ç§é™åˆ¶å®é™…ä¸Šèµ‹äºˆäº†å¼€å‘è€…æ›´å¤§çš„åŠ›é‡â€”â€”åœ¨å¹¶å‘ä¸–ç•Œä¸­æ„å»ºæ›´åŠ å¥å£®å’Œå¯é ç³»ç»Ÿçš„åŠ›é‡ã€‚

ä¸‹æ¬¡å½“ä½ ä½¿ç”¨ConcurrentHashMapæ—¶ï¼Œä¸å¦¨æ„Ÿè°¢è¿™ä¸ªæ˜æ™ºçš„è®¾è®¡é€‰æ‹©ã€‚å®ƒä¸ä»…ä»…æ˜¯ä¸€ä¸ªAPIé™åˆ¶ï¼Œæ›´æ˜¯å¹¶å‘ç¼–ç¨‹å“²å­¦çš„ä¸€ç§ä½“ç°ï¼š**åœ¨æ­£ç¡®çš„çº¦æŸä¸‹ï¼Œæˆ‘ä»¬æ‰èƒ½è·å¾—çœŸæ­£çš„è‡ªç”±**ã€‚

ğŸ‘‰ ç‚¹èµ | å…³æ³¨ | è¯„è®º â€”â€” ä½ çš„æ¯ä¸€æ¬¡äº’åŠ¨ï¼Œéƒ½æ˜¯ç¬”è€…æŒç»­åˆ›ä½œçš„æœ€å¤§åŠ¨åŠ›ï¼  
ğŸ“© æƒ³äº†è§£æ›´å¤šæŠ€æœ¯æ·±åº¦è§£æï¼Ÿç‚¹å‡»å…³æ³¨æŒ‰é’®ï¼Œè®¢é˜…æ›´æ–°ä¸è¿·è·¯ï¼

* * *

**å‚è€ƒèµ„æ–™**ï¼š

1.  Oracleå®˜æ–¹Javaæ–‡æ¡£ï¼šConcurrentHashMapç±»
2.  Lea, D. (2005). "Java Concurrency in Practice"
3.  Goetz, B. (2006). "Javaå¹¶å‘ç¼–ç¨‹å®æˆ˜"
4.  JEP 155: Concurrency Updatesï¼ˆJavaå¹¶å‘æ›´æ–°ææ¡ˆï¼‰