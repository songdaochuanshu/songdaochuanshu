---
layout: post
title: 'ã€URPã€‘[å®æ—¶é˜´å½±]è®¡ç®—æµç¨‹è§£æ'
date: "2025-09-02T00:40:22Z"
---
ã€URPã€‘\[å®æ—¶é˜´å½±\]è®¡ç®—æµç¨‹è§£æ
===================

![ã€URPã€‘[å®æ—¶é˜´å½±]è®¡ç®—æµç¨‹è§£æ](https://img2024.cnblogs.com/blog/3685400/202509/3685400-20250901113444900-1824481364.png) é˜´å½±è´´å›¾ç”Ÿæˆæµç¨‹ é˜´å½±è´´å›¾æŠ€æœ¯é€šè¿‡ä¸¤æ¬¡æ¸²æŸ“æµç¨‹å®ç°é˜´å½±æ•ˆæœï¼š é˜´å½±è´´å›¾ç”Ÿæˆé˜¶æ®µï¼šä»¥å…‰æºä¸ºè§†è§’æ¸²æŸ“åœºæ™¯æ·±åº¦ä¿¡æ¯è‡³çº¹ç†ï¼ˆShadow Mapï¼‰ï¼Œä»…è®°å½•æœ€è¿‘æ·±åº¦å€¼ã€‚ åœºæ™¯æ¸²æŸ“é˜¶æ®µï¼šå°†åƒç´ å˜æ¢è‡³å…‰æºç©ºé—´ï¼Œé‡‡æ ·Shadow Mapå¹¶ä¸å®é™…æ·±åº¦æ¯”è¾ƒï¼Œåˆ¤å®šé®æŒ¡å…³ç³»ã€‚ å…³é”®Passä½œç”¨ ShadowCaster Passï¼šç”±Litæˆ–è‡ªå®šä¹‰æè´¨ç”Ÿæˆï¼Œå°†ç‰©ä½“æ·±åº¦å†™å…¥ShadowMapï¼Œå†³å®šé˜´å½±æŠ•å°„èŒƒå›´ã€‚ DepthOnly Passï¼šä»…æ¸²æŸ“å‡ ä½•æ·±åº¦ï¼Œé¿å…é¢œè‰²å¹²æ‰°ï¼Œæå‡ShadowMapç²¾åº¦ã€‚

åœ¨Unity URPä¸­ï¼Œå®æ—¶é˜´å½±çš„å·¥ä½œæµç¨‹åŸºäºâ€Œ**ShadowMapæŠ€æœ¯**â€Œå®ç°ï¼Œä¸»è¦æµç¨‹å¦‚ä¸‹ï¼š

> [ã€ä»UnityURPå¼€å§‹æ¢ç´¢æ¸¸æˆæ¸²æŸ“ã€‘](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**ä¸“æ -ç›´è¾¾**

**ä¸€ã€é˜´å½±ç”Ÿæˆæµç¨‹**
============

â€Œé˜´å½±è´´å›¾ï¼ˆShadowMapï¼‰ç”Ÿæˆ
------------------

åœ¨å…‰æºä½ç½®è®¾ç½®è™šæ‹Ÿç›¸æœºï¼Œæ¸²æŸ“åœºæ™¯æ·±åº¦åˆ°çº¹ç†ï¼š

*   ä¸»å…‰æºé˜´å½±ç”±`ShadowCaster Pass`å¤„ç†ï¼Œè¾“å‡ºæ·±åº¦å›¾åˆ°`_MainLightShadowmapTexture`â€Œ
*   ä½¿ç”¨çº§è”é˜´å½±ï¼ˆCascaded Shadow Mappingï¼‰æå‡ç²¾åº¦ï¼šå°†ShadowMapåˆ’åˆ†ä¸º2Ã—2å›¾é›†ï¼Œå¯¹åº”ä¸åŒç²¾åº¦ç­‰çº§â€Œ

    csharp
    // URPæ ¸å¿ƒæµç¨‹if (ä¸»å…‰æºå¼€å¯é˜´å½±) {
        MainLightShadowCasterPass.Render();// ç”Ÿæˆ_MainLightShadowmapTexture
    }
    

â€Œæ·±åº¦å€¼æ¯”è¾ƒ
------

æ­£å¸¸æ¸²æŸ“æ—¶æ‰§è¡Œï¼š

*   å°†åƒç´ åæ ‡è½¬æ¢åˆ°å…‰æºç©ºé—´è·å–æ·±åº¦å€¼
*   é‡‡æ ·ShadowMapæ¯”è¾ƒæ·±åº¦ï¼šè‹¥å½“å‰æ·±åº¦ > ShadowMapå€¼ï¼Œåˆ™åˆ¤å®šä¸ºé˜´å½±åŒºåŸŸâ€Œ

**äºŒã€å…³é”®Passçš„ä½œç”¨**
===============

â€Œ**ShadowCaster Pass**â€Œ
-----------------------

*   â€Œ**ä½œç”¨**â€Œï¼šä¸“ç”¨äºç”Ÿæˆé˜´å½±è´´å›¾
*   â€Œ**è¾“å‡ºç›®æ ‡**â€Œï¼š`_MainLightShadowmapTexture`ï¼ˆä¸»å…‰æºï¼‰æˆ–è‡ªå®šä¹‰ShadowMap
*   â€Œ**Shaderè¦æ±‚**â€Œï¼š

    hlsl
    Pass {
        Tags { "LightMode" = "ShadowCaster" }
        #pragma multi_compile_shadowcaster // ç”ŸæˆSHADOWS_DEPTH/SHADOW_CUBEå®â€Œ
        V2F_SHADOW_CASTER; // å£°æ˜æ•°æ®ç»“æ„
        TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) // é¡¶ç‚¹ç€è‰²å™¨å¤„ç†æ·±åº¦åç§»â€Œ
    }
    

### æ¥è‡ªäºLitçš„é˜´å½±æŠ•å°„pass

    // ShadowCaster è®¡ç®—ç¯å…‰çš„æ·±åº¦è´´å›¾ï¼Œç›¸å½“äºä»¥å…‰çš„ä½ç½®ä¸»åŠ¨æŠ•å°„åˆ°ç‰©ä½“ä¸Šï¼Œå½¢æˆçš„åç§»é˜´å½±ã€‚ç”¨æ¥æŠ•å°„é˜´å½±åˆ°å…¶ä»–ä½ç½®çš„è®¡ç®—ã€‚
    // è¿™é‡Œæ¶‰åŠåˆ°_ShadowBiasåœ¨Shadow.hlslä¸­xåˆ†é‡è¡¨ç¤ºDepthBiasæ·±åº¦æ–¹å‘åç§»ï¼Œyåˆ†é‡è¡¨ç¤ºNormalBiasæ³•çº¿æ–¹å‘åç§»ã€‚
    Pass
    {
        Name "ShadowCaster"
        Tags
        {
            "LightMode" = "ShadowCaster"
        }
    
        // -------------------------------------
        // Render State Commands
        ZWrite On
        ZTest LEqual
        ColorMask 0
        Cull[_Cull]
    
        HLSLPROGRAM
        #pragma target 2.0
    
        // -------------------------------------
        // Shader Stages
        #pragma vertex ShadowPassVertex
        #pragma fragment ShadowPassFragment
    
        // -------------------------------------
        // Material Keywords
        #pragma shader_feature_local _ALPHATEST_ON
        #pragma shader_feature_local_fragment _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A
    
        //--------------------------------------
        // GPU Instancing
        #pragma multi_compile_instancing
        #include_with_pragmas "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DOTS.hlsl"
    
        // -------------------------------------
        // Universal Pipeline keywords
    
        // -------------------------------------
        // Unity defined keywords
        #pragma multi_compile_fragment _ LOD_FADE_CROSSFADE
    
        // This is used during shadow map generation to differentiate between directional and punctual light shadows, as they use different formulas to apply Normal Bias
        #pragma multi_compile_vertex _ _CASTING_PUNCTUAL_LIGHT_SHADOW
    
        // -------------------------------------
        // Includes
        #include "Packages/com.unity.render-pipelines.universal/Shaders/LitInput.hlsl"
        #include "Packages/com.unity.render-pipelines.universal/Shaders/ShadowCasterPass.hlsl"
        ENDHLSL
    }
    

### `ShadowCasterPass.hlsl`

é˜´å½±æŠ•å°„ä¸»è¦è®¡ç®—åœ¨é¡¶ç‚¹è®¡ç®—ä½ç½®ï¼Œç‰‡å…ƒä¸éœ€è¦å¤„ç†çº¹ç†é¢œè‰²é˜´å½±è¿”å›0ç»™é»‘è‰²ã€‚

    #ifndef UNIVERSAL_SHADOW_CASTER_PASS_INCLUDED
    #define UNIVERSAL_SHADOW_CASTER_PASS_INCLUDED
    
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl"
    #if defined(LOD_FADE_CROSSFADE)
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/LODCrossFade.hlsl"
    #endif
    
    // Shadow Casting Light geometric parameters. These variables are used when applying the shadow Normal Bias and are set by UnityEngine.Rendering.Universal.ShadowUtils.SetupShadowCasterConstantBuffer in com.unity.render-pipelines.universal/Runtime/ShadowUtils.cs
    // For Directional lights, _LightDirection is used when applying shadow Normal Bias.
    // For Spot lights and Point lights, _LightPosition is used to compute the actual light direction because it is different at each shadow caster geometry vertex.
    float3 _LightDirection;
    float3 _LightPosition;
    
    struct Attributes
    {
        float4 positionOS   : POSITION;
        float3 normalOS     : NORMAL;
        float2 texcoord     : TEXCOORD0;
        UNITY_VERTEX_INPUT_INSTANCE_ID
    };
    
    struct Varyings
    {
        #if defined(_ALPHATEST_ON)
            float2 uv       : TEXCOORD0;
        #endif
        float4 positionCS   : SV_POSITION;
        UNITY_VERTEX_INPUT_INSTANCE_ID
    };
    
    float4 GetShadowPositionHClip(Attributes input)
    {
        float3 positionWS = TransformObjectToWorld(input.positionOS.xyz);
        float3 normalWS = TransformObjectToWorldNormal(input.normalOS);
    
    #if _CASTING_PUNCTUAL_LIGHT_SHADOW
        float3 lightDirectionWS = normalize(_LightPosition - positionWS);
    #else
        float3 lightDirectionWS = _LightDirection;
    #endif
    
        float4 positionCS = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, lightDirectionWS));
    
    #if UNITY_REVERSED_Z
        positionCS.z = min(positionCS.z, UNITY_NEAR_CLIP_VALUE);
    #else
        positionCS.z = max(positionCS.z, UNITY_NEAR_CLIP_VALUE);
    #endif
    
        return positionCS;
    }
    
    Varyings ShadowPassVertex(Attributes input)
    {
        Varyings output;
        UNITY_SETUP_INSTANCE_ID(input);
        UNITY_TRANSFER_INSTANCE_ID(input, output);
    
        #if defined(_ALPHATEST_ON)
            output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap);
        #endif
    
        output.positionCS = GetShadowPositionHClip(input);
        return output;
    }
    
    half4 ShadowPassFragment(Varyings input) : SV_TARGET
    {
        UNITY_SETUP_INSTANCE_ID(input);
    
        #if defined(_ALPHATEST_ON)
            Alpha(SampleAlbedoAlpha(input.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)).a, _BaseColor, _Cutoff);
        #endif
    
        #if defined(LOD_FADE_CROSSFADE)
            LODFadeCrossFade(input.positionCS);
        #endif
    
        return 0;
    }
    
    #endif
    
    

**DepthOnly Pass**â€Œ
-------------------

*   â€Œ**ä½œç”¨**â€Œï¼šç”Ÿæˆåœºæ™¯æ·±åº¦å›¾ï¼ˆéç›´æ¥ç”¨äºé˜´å½±ï¼‰
*   â€Œ**è¾“å‡ºç›®æ ‡**â€Œï¼š`_CameraDepthTexture`
*   â€Œ**é˜´å½±å…³è”**â€Œï¼šä¸ºå±å¹•ç©ºé—´é˜´å½±è®¡ç®—æä¾›åœºæ™¯æ·±åº¦æ•°æ®ï¼Œéé˜´å½±è´´å›¾ç›´æ¥æ¥æºâ€Œ

**ä¸‰ã€é˜´å½±ç”Ÿæˆä½ç½®**
============

*   â€Œ**æ ¸å¿ƒPass**â€Œï¼šé˜´å½±å®Œå…¨ç”±`LightMode="ShadowCaster"`çš„Passç”Ÿæˆâ€Œ
*   â€Œ**æ‰§è¡Œé˜¶æ®µ**â€Œï¼šåœ¨`MainLightShadowCasterPass`æ¸²æŸ“ç®¡çº¿é˜¶æ®µå®Œæˆâ€Œ
*   â€Œ**çº¹ç†å­˜å‚¨**â€Œï¼š
    *   ä¸»å…‰æºé˜´å½± â†’Â `_MainLightShadowmapTexture`â€Œ
    *   ç‚¹å…‰æºé˜´å½± â†’ CubeMapå½¢å¼å­˜å‚¨â€Œ

**å››ã€æ·±åº¦åç§»å¤„ç†**
============

é€šè¿‡`TRANSFER_SHADOW_CASTER_NORMALOFFSET`å®ï¼š

*   è‡ªåŠ¨è®¡ç®—æ³•çº¿åç§»
*   è§£å†³Shadow Acneï¼ˆé˜´å½±ç—¤ç–®ï¼‰å’ŒPeter Panningï¼ˆè¾¹ç¼˜å‰¥ç¦»ï¼‰é—®é¢˜â€Œ

**äº”ã€çº§è”é˜´å½±ä¼˜åŒ–**
============

URPé‡‡ç”¨2Ã—2çº§è”å›¾é›†ï¼š

*   æ¯çº§å¯¹åº”ä¸åŒè§†é”¥åŒºåŸŸ
*   åŠ¨æ€åˆ†é…ç²¾åº¦ï¼šè¿‘è·ç¦»é«˜ç²¾åº¦ï¼Œè¿œè·ç¦»ä½ç²¾åº¦â€Œ
*   é€šè¿‡`GetShadowCasterBounds()`è®¡ç®—å…‰æºå½±å“èŒƒå›´â€Œ

> âš ï¸ æ³¨æ„äº‹é¡¹
> 
> *   ç‰©ä½“éœ€åŒ…å«`ShadowCaster`Â Passæ‰èƒ½æŠ•å°„é˜´å½±â€Œ
> *   æ·±åº¦æµ‹è¯•å†²çªå¯èƒ½å¯¼è‡´é˜´å½±ç¼ºå¤±ï¼Œéœ€æ£€æŸ¥æè´¨é…ç½®

* * *

> [ã€ä»UnityURPå¼€å§‹æ¢ç´¢æ¸¸æˆæ¸²æŸ“ã€‘](https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=13021255&sharerefer=PC&sharesource=chenghai37&sharefrom=from_link)**ä¸“æ -ç›´è¾¾**

ï¼ˆæ¬¢è¿_ç‚¹èµç•™è¨€_æ¢è®¨ï¼Œæ›´å¤šäººåŠ å…¥è¿›æ¥èƒ½æ›´åŠ å®Œå–„è¿™ä¸ªæ¢ç´¢çš„è¿‡ç¨‹ï¼ŒğŸ™ï¼‰