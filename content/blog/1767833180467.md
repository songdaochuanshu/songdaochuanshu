---
layout: post
title: 'BLE 4.2 Controller：高精度调度器与冲突仲裁'
date: "2026-01-08T00:46:20Z"
---
BLE 4.2 Controller：高精度调度器与冲突仲裁
==============================

由于芯片通常只有一个 Radio（单射频），我们不能同时进行广播、扫描和保持连接。如果我在 37 信道广播时，连接的锚点（Anchor Point）也到了，该怎么办？如果我正在扫描，突然需要回复一个连接请求，怎么保证时间差精确在 150µs？

这就是我们需要一个**高精度调度器（High-Precision Scheduler）** 的原因。通用的 RTOS（如 FreeRTOS）基于 SysTick 的 1ms 调度精度在这里完全不够看，我们需要的是微秒级的控制。

1 设计哲学：时间轴上的俄罗斯方块
=================

BLE Controller 的调度本质上是**时分复用（TDM）**。我们可以把时间看作一条无限延伸的单行铁轨，而每一个任务（广播一次、连接交互一次）就是一列列火车。

我们的调度器只有两个核心目标：

1.  **不撞车：** 保证任意两个任务在时间轴上不重叠。
2.  **准点率：** 任务必须在预定的微秒时刻触发（误差 < 2µs）。  
    ![image](https://img2024.cnblogs.com/blog/2160691/202601/2160691-20260107134613379-1261820989.png)

为了实现这一点，我们需要抛弃“线程优先级”的概念，转而使用**基于绝对时间的有序链表**。

2 冲突仲裁
======

显然，这样插入非常容易出现时间上的重叠。但幸好，蓝牙中并不是所有事件都对时间要求非常严格，为了解决冲突，可以根据事件的**优先级**和**一定的策略**调整不同事件开始的时间。  
![image](https://img2024.cnblogs.com/blog/2160691/202601/2160691-20260107134626263-1664847779.png)

下面以 Cordio 源码为例，分析不同情况的处理方法。

### 2.1.1 新事件优先级更高

如果新事件优先级更高，新事件获胜，则移除旧的事件，插入新的事件，然后通过回调函数 `abortCback` 通知旧事件被取消了。回调函数针对不同的事件单独实现。

    static bool_t SchResolveConflict(BbOpDesc_t *pItem, BbOpDesc_t *pTgt)
    {
      schRemoveForConflict(pTgt);
      schInsertToEmptyList(pItem);
    
      if (pDeleted->abortCback) {
        pDeleted->abortCback(pDeleted);  
      }
      
      return TRUE;
    }
    

### 2.1.2 优先级相同

如果新事件优先级相同，就使用冲突回调函数 `conflictCback` 来决定怎么处理。回调函数针对不同的事件单独实现。

    static bool_t SchIsBodResolvable(
      BbOpDesc_t *pItem,           // 新BOD
      BbOpDesc_t *pTgt,            // 现有BOD
      BbConflictAct_t conflictCback
    )
    {
      // 策略1: 比较重调度策略（优先级）
      if (pItem->reschPolicy < pTgt->reschPolicy) {
        return TRUE;  // 新BOD优先级更高，可以抢占
      }
      
      // 策略2: 优先级相同，使用冲突回调
      else if ((pItem->reschPolicy == pTgt->reschPolicy) && 
               conflictCback) {
        if (conflictCback(pItem, pTgt) == pItem) {
          return TRUE;  // 回调选择了新BOD
        }
      }
      
      // 策略3: 新BOD优先级更低或相同但无回调
      else {
        LL_TRACE_WARN2("!!! Scheduling conflict: existing=%u vs incoming=%u", 
                       pTgt->reschPolicy, pItem->reschPolicy);
        return FALSE;  // 保留现有BOD
      }
      
      return FALSE;
    }
    

### 2.1.3 新事件优先级更低

如果新事件优先级更低，则保留旧事件，调整新事件的事件重新尝试插入。  
例如一个普通的广播事件在调度时碰到了更高优先级的连接事件，广播事件重新计算下一次的广播事件，然后重新尝试调度。对于广播，错过一次几乎不影响用户体验。

![image](https://img2024.cnblogs.com/blog/2160691/202601/2160691-20260107134641658-910925783.png)

    static bool_t SchResolveConflict(
      BbOpDesc_t *pItem,  // 要插入的BOD
      BbOpDesc_t *pTgt    // 冲突的BOD
    )
    {
      BbOpDesc_t *pCur = pTgt;
      int numDeletedBod = 0;
      BbOpDesc_t *pDeleted[SCH_MAX_DELETE_BOD];  // 最多删除8个
      
      // 1. 遍历并移除所有冲突的BOD
      while (TRUE) {
        
        // 防止删除过多
        if (numDeletedBod == SCH_MAX_DELETE_BOD) {
          result = FALSE;
          break;
        }
        
        pDeleted[numDeletedBod++] = pCur;
        
        // 如果只与pCur冲突
        if ((pCur->pNext == NULL) || 
            SCH_IS_DONE_BEFORE(pItem, pCur->pNext)) {
          result = schRemoveForConflict(pCur);
          break;
        }
        
        // 继续移除下一个冲突的BOD
        if (!schRemoveForConflict(pCur)) {
          result = FALSE;
          break;
        }
        
        pCur = pCur->pNext;
      }
      
      // 2. 如果成功移除，插入新BOD
      if (result == TRUE) {
        if (pCur->pNext) {
          schInsertBefore(pItem, pCur->pNext);
        }
        else if (pTgt->pPrev) {
          schInsertAfter(pItem, pTgt->pPrev);
        }
        else {
          schInsertToEmptyList(pItem);
        }
        
        // 3. 调用所有被移除BOD的中止回调
        for (int i = 0; i < numDeletedBod; i++) {
          if (pDeleted[i]->abortCback) {
            pDeleted[i]->abortCback(pDeleted[i]);
          }
        }
      }
      
      return result;
    }
    

本文版权归作者：[ixbwer](https://www.cnblogs.com/ixbwer/)所有，转载请注明原文链接：[https://www.cnblogs.com/ixbwer/p/19451924](https://www.cnblogs.com/ixbwer/p/19451924)，否则保留追究法律责任的权利。