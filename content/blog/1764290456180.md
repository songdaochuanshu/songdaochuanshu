---
layout: post
title: 'AI è§†é¢‘è¶…åˆ†ä¸äººè„¸ä¿®å¤åˆ©å™¨ï¼šRealESRGAN + GFPGAN é«˜æ•ˆå¤„ç†è„šæœ¬'
date: "2025-11-28T00:40:56Z"
---
AI è§†é¢‘è¶…åˆ†ä¸äººè„¸ä¿®å¤åˆ©å™¨ï¼šRealESRGAN + GFPGAN é«˜æ•ˆå¤„ç†è„šæœ¬
=========================================

ğŸš€ å‰è¨€
-----

è§†é¢‘è¶…åˆ†è¾¨ç‡ï¼ˆVideo Super-Resolution, VSRï¼‰æ˜¯æå‡æ—§è§†é¢‘æˆ–ä½åˆ†è¾¨ç‡è§†é¢‘è´¨é‡çš„æœ‰æ•ˆæ‰‹æ®µã€‚æœ¬è„šæœ¬ç»“åˆäº† **RealESRGAN** (ç”¨äºé€šç”¨èƒŒæ™¯å’Œç»†èŠ‚æ”¾å¤§) å’Œ **GFPGAN** (ç”¨äºé«˜æ¸…äººè„¸ä¿®å¤) ä¸¤ä¸ªå¼ºå¤§çš„ AI æ¨¡å‹ï¼Œå¹¶é’ˆå¯¹å¤§è§„æ¨¡è§†é¢‘å¤„ç†ä¸­çš„å¸¸è§é—®é¢˜ï¼ˆå¦‚ä¸­æ–­ã€èµ„æºå ç”¨ã€I/O ç“¶é¢ˆï¼‰è¿›è¡Œäº†æ·±åº¦ä¼˜åŒ–ã€‚

ç‰¹åˆ«æ˜¯ V16.0 ç‰ˆæœ¬ï¼Œå¼•å…¥äº†**çº¿ç¨‹å®‰å…¨çš„æ–­ç‚¹ç»­ä¼ æœºåˆ¶**å’Œ**ä¼˜åŒ–çš„ I/O çº¿ç¨‹æ± **ï¼Œå½»åº•è§£å†³äº†åœ¨å¤„ç†æ•°ä¸‡å¸§è§†é¢‘æ—¶å®¹æ˜“å‡ºç°çš„å‡æ­»æˆ–è¿›åº¦ä¸¢å¤±é—®é¢˜ã€‚

ğŸ› ï¸ ç¯å¢ƒæ­å»ºä¸é…ç½®è¦æ±‚
-------------

### 1\. è½¯ä»¶ç¯å¢ƒ

æ‚¨éœ€è¦å®‰è£…ä»¥ä¸‹åŸºç¡€è½¯ä»¶ï¼š

*   **Python 3.8+**
*   **CUDA (NVIDIA æ˜¾å¡ç”¨æˆ·)**ï¼šå¼ºçƒˆæ¨èä½¿ç”¨ GPU è¿›è¡Œæ¨ç†ï¼Œå¦åˆ™é€Ÿåº¦ä¼šéå¸¸æ…¢ã€‚
*   **FFmpeg**ï¼šç”¨äºè§†é¢‘çš„è¯»å–ã€éŸ³é¢‘æå–å’Œæœ€ç»ˆçš„åˆæˆã€‚è¯·ç¡®ä¿ `ffmpeg` å‘½ä»¤åœ¨æ‚¨çš„ç³»ç»Ÿ PATH ä¸­å¯ç”¨ã€‚

### 2\. Python ä¾èµ–

é€šè¿‡ pip å®‰è£…æ‰€æœ‰å¿…éœ€çš„åº“ï¼š

    pip install torch torchvision torchaudio
    # Real-ESRGAN/GFPGAN ä¾èµ–
    pip install basicsr
    pip install facexlib
    pip install gfpgan
    pip install opencv-python
    pip install tqdm
    # å¦‚æœæ‚¨éœ€è¦æ‰‹åŠ¨å®‰è£… Real-ESRGAN å’Œ GFPGANï¼Œè¯·å‚è€ƒå®˜æ–¹ä»“åº“ã€‚

### 3\. æ¨¡å‹æ–‡ä»¶å‡†å¤‡

è¯·ä¸‹è½½ä»¥ä¸‹ä¸¤ä¸ªé¢„è®­ç»ƒæ¨¡å‹ï¼Œå¹¶å°†å…¶æ”¾ç½®åˆ°æ‚¨æŒ‡å®šçš„è·¯å¾„ï¼ˆä¾‹å¦‚ `/root/autodl-tmp/models/`ï¼‰ï¼š

*   **RealESRGAN æ¨¡å‹ (èƒŒæ™¯/ç»†èŠ‚è¶…åˆ†)**:
    *   \*\*æ–‡ä»¶\*\*: `RealESRGAN_x4plus.pth`
    *   \*\*ä¸‹è½½åœ°å€\*\*: \[å®˜æ–¹ä»“åº“é€šå¸¸ä¼šæä¾›ä¸‹è½½é“¾æ¥\]
*   **GFPGAN æ¨¡å‹ (äººè„¸ä¿®å¤)**:
    *   \*\*æ–‡ä»¶\*\*: `GFPGANv1.4.pth`
    *   \*\*ä¸‹è½½åœ°å€\*\*: \[å®˜æ–¹ä»“åº“é€šå¸¸ä¼šæä¾›ä¸‹è½½é“¾æ¥\]

ğŸ“‹ ä»£ç é…ç½®ï¼ˆé‡è¦ï¼‰
-----------

åœ¨ä½¿ç”¨å‰ï¼Œè¯·åŠ¡å¿…ä¿®æ”¹ä»£ç å¼€å¤´çš„å››ä¸ªæ ¸å¿ƒé…ç½®é¡¹ï¼š

ç¼–å·

å˜é‡å

æè¿°

ç¤ºä¾‹å€¼

1

INPUT\_VIDEO\_PATH

å¾…å¤„ç†çš„åŸå§‹è§†é¢‘çš„\*\*ç»å¯¹è·¯å¾„\*\*ã€‚

`"/root/autodl-tmp/video.mp4"`

2

OUTPUT\_DIR

ä¸´æ—¶å¸§å’Œæœ€ç»ˆè§†é¢‘çš„\*\*è¾“å‡ºç›®å½•\*\*ã€‚

`"/root/autodl-tmp/upscale_output/"`

3

REALESRGAN\_MODEL\_PATH

æ­¥éª¤ 3 ä¸‹è½½çš„ RealESRGAN æ¨¡å‹è·¯å¾„ã€‚

`"/root/autodl-tmp/models/RealESRGAN_x4plus.pth"`

4

GFPGAN\_MODEL\_PATH

æ­¥éª¤ 3 ä¸‹è½½çš„ GFPGAN æ¨¡å‹è·¯å¾„ã€‚

`"/root/autodl-tmp/models/GFPGANv1.4.pth"`

### æ€§èƒ½è°ƒä¼˜å‚æ•°

å˜é‡å

æè¿°

å»ºè®®å€¼/è¯´æ˜

TILE\_SIZE

RealESRGAN çš„\*\*åˆ‡å—å¤§å°\*\*ã€‚æ˜¾å­˜è¶Šå¤§ï¼Œå¯ä»¥è®¾ç½®è¶Šå¤§ã€‚å‡å°‘æ˜¾å­˜å ç”¨æ—¶å¯è°ƒå° (å¦‚ 4000)ã€‚

`6000` (å¤§æ˜¾å­˜å‹å¥½)

BATCH\_SIZE

æ¯æ¬¡ä»è§†é¢‘ä¸­è¯»å–çš„å¸§æ•°ã€‚\*\*ä¸å½±å“ GPU æ¨ç†æ‰¹æ¬¡\*\*ï¼Œä¸»è¦å½±å“ I/O æ•ˆç‡ã€‚

`8`

IO\_THREADS

å¼‚æ­¥å†™å…¥å›¾ç‰‡çš„çº¿ç¨‹æ•°ã€‚\*\*å…³é”®ä¼˜åŒ–ç‚¹\*\*ã€‚è¿‡å¤šä¼šå¯¼è‡´ç£ç›˜ I/O é˜Ÿåˆ—é˜»å¡ï¼Œå»ºè®® `4-8`ã€‚

`6`

VIDEO\_CRF

FFmpeg è§†é¢‘ç¼–ç è´¨é‡ï¼Œå€¼è¶Šå°è´¨é‡è¶Šé«˜ï¼Œæ–‡ä»¶è¶Šå¤§ã€‚`18` æ˜¯ä¸€ä¸ªé«˜è´¨é‡çš„å¹³è¡¡ç‚¹ã€‚

`'18'`

ğŸ’¡ æ³¨æ„äº‹é¡¹
-------

*   **æ–­ç‚¹ç»­ä¼ ï¼ˆCheckpointingï¼‰**ï¼šè„šæœ¬ä¼šåœ¨ `OUTPUT_DIR` ä¸­ç”Ÿæˆä¸€ä¸ª `checkpoint.txt` æ–‡ä»¶ï¼Œè®°å½•å·²å®Œæˆçš„å¸§æ•°ã€‚å¦‚æœç¨‹åºæ„å¤–ä¸­æ–­ï¼ˆå¦‚æ–­ç”µæˆ–æ‰‹åŠ¨åœæ­¢ï¼‰ï¼Œä¸‹æ¬¡è¿è¡Œæ—¶å°†è‡ªåŠ¨ä»ä¸Šæ¬¡ä¸­æ–­çš„ä½ç½®ç»§ç»­å¤„ç†ï¼Œæ— éœ€ä¿®æ”¹ä»£ç ã€‚
*   **çº¿ç¨‹é” (`CHECKPOINT_LOCK`)**ï¼šè¿™æ˜¯ V16.0 ä¿®å¤çš„å…³é”®ã€‚å®ƒç¡®ä¿å¤šçº¿ç¨‹å¼‚æ­¥å†™å…¥å›¾ç‰‡æ—¶ï¼Œå¯¹è¿›åº¦æ–‡ä»¶ (`checkpoint.txt`) çš„æ“ä½œæ˜¯åŸå­æ€§çš„ï¼Œå½»åº•é¿å…äº†æ–‡ä»¶æŸåæˆ–å¤šçº¿ç¨‹äº‰æŠ¢å¯¼è‡´çš„ç¨‹åºå‡æ­»ã€‚
*   **å•æ–‡ä»¶åŸåˆ™**ï¼šè„šæœ¬å°†è§†é¢‘åˆ†è§£ä¸ºå›¾ç‰‡åºåˆ— (`frame_000001.jpg`, `frame_000002.jpg` ç­‰) è¿›è¡Œå¤„ç†ï¼Œæœ€åå†åˆæˆè§†é¢‘ã€‚è¯·ç¡®ä¿ `OUTPUT_DIR` æœ‰è¶³å¤Ÿçš„ç©ºé—´ï¼ˆé€šå¸¸æ˜¯åŸè§†é¢‘ä½“ç§¯çš„æ•°å€åˆ°æ•°åå€ï¼‰ã€‚

ğŸ’» å®Œæ•´ Python ä»£ç 
---------------

ä»¥ä¸‹æ˜¯ç»è¿‡æ³¨é‡Šä¼˜åŒ–å’Œ V16.0 ä¿®å¤çš„å®Œæ•´è„šæœ¬ï¼Œæ‚¨å¯ä»¥ç›´æ¥ä¿å­˜ä¸º `upscale_processor.py`ã€‚

    import cv2
    import os
    import subprocess
    import time
    from tqdm import tqdm
    from basicsr.archs.rrdbnet_arch import RRDBNet
    from realesrgan import RealESRGANer
    from gfpgan import GFPGANer
    import torch
    import numpy as np
    import concurrent.futures
    import threading
    
    # -------------------------------------------------------------
    # ğŸ¯ é…ç½®å‚æ•° (V16.0 ç»ˆæä¿®å¤ç‰ˆ: è§£å†³æœ€åé˜¶æ®µå‡æ­»é—®é¢˜)
    # -------------------------------------------------------------
    # *** 1. æ›¿æ¢ä¸ºæ‚¨çš„æµ‹è¯•è§†é¢‘è·¯å¾„ (MP4 æ ¼å¼) ***
    INPUT_VIDEO_PATH = "/root/autodl-tmp/video.mp4"
    
    # *** 2. è¾“å‡ºæ–‡ä»¶å¤¹è·¯å¾„ ***
    OUTPUT_DIR = "/root/autodl-tmp/upscale_output/"
    OUTPUT_VIDEO_NAME = "upscaled_video_1080p.mp4"
    
    # *** 3. æ¨¡å‹è·¯å¾„ ***
    REALESRGAN_MODEL_PATH = "/root/autodl-tmp/models/RealESRGAN_x4plus.pth"
    GFPGAN_MODEL_PATH = "/root/autodl-tmp/models/GFPGANv1.4.pth"
    
    # -------------------------------------------------------------
    # AI/å¤„ç†å‚æ•°
    # -------------------------------------------------------------
    CHECKPOINT_FILE = os.path.join(OUTPUT_DIR, "checkpoint.txt")  # è¿›åº¦è®°å½•æ–‡ä»¶è·¯å¾„
    UPSCALING_FACTOR = 4  # æ”¾å¤§å€æ•°ï¼ŒRealESRGAN x4plus å¯¹åº” 4
    
    # ç›®æ ‡åˆ†è¾¨ç‡ (1080P)
    TARGET_WIDTH = 1920
    TARGET_HEIGHT = 1080
    
    # æ˜¾å­˜ä¼˜åŒ–å‚æ•°
    TILE_SIZE = 6000  # RealESRGAN åˆ‡å—å¤§å°ï¼Œç”¨äºèŠ‚çœæ˜¾å­˜
    BATCH_SIZE = 8  # è§†é¢‘è¯»å–æ‰¹å¤„ç†å¤§å°
    
    # å›¾ç‰‡è¾“å‡ºå‚æ•°
    OUTPUT_FRAME_EXTENSION = ".jpg"
    JPEG_QUALITY = 95 # è¾“å‡º JPEG è´¨é‡ (0-100)ï¼Œ95 ä¿è¯é«˜è´¨é‡
    
    # [V16.0 å…³é”®ä¿®å¤] I/O çº¿ç¨‹æ•°
    # ç”¨äºå¼‚æ­¥å†™å…¥å·²å¤„ç†çš„å¸§ï¼Œé¿å… GPU ç­‰å¾… I/Oã€‚
    # ä¹‹å‰ 16 çº¿ç¨‹ä¼šå¯¼è‡´ç£ç›˜é˜Ÿåˆ—é˜»å¡ï¼Œæ”¹ä¸º 6 çº¿ç¨‹æ›´ç¨³å®š
    IO_THREADS = 6
    
    # è§†é¢‘ç¼–ç è´¨é‡
    VIDEO_CRF = '18' # Constant Rate Factor, è¶Šå°è´¨é‡è¶Šé«˜ (18-23 å¸¸ç”¨)
    
    # [V16.0 å…³é”®ä¿®å¤] å…¨å±€çº¿ç¨‹é”
    # ç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨å†™ checkpoint.txtï¼Œå½»åº•è§£å†³å¤šçº¿ç¨‹å†™æ–‡ä»¶å¯¼è‡´çš„å†²çªã€‚
    CHECKPOINT_LOCK = threading.Lock()
    
    
    # -------------------------------------------------------------
    # ğŸ› ï¸ åˆå§‹åŒ– RealESRGAN å’Œ GFPGAN å¼•æ“
    # -------------------------------------------------------------
    
    def initialize_upsampler():
        """åˆå§‹åŒ– Real-ESRGAN å’Œ GFPGAN å¼•æ“ï¼Œå¹¶å°†å…¶éƒ¨ç½²åˆ° GPU (å¦‚æœå¯ç”¨)ã€‚"""
        print("INFO: Initializing Real-ESRGAN and GFPGAN engines...")
    
        # æ£€æŸ¥æ¨¡å‹æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if not os.path.exists(REALESRGAN_MODEL_PATH) or not os.path.exists(GFPGAN_MODEL_PATH):
            print(f"FATAL ERROR: Model files not found. Please check paths.")
            return None
    
        # è‡ªåŠ¨é€‰æ‹©è®¾å¤‡
        device = 'cuda' if torch.cuda.is_available() else 'cpu'
        if device == 'cpu':
            print("WARNING: CUDA not found. Running on CPU, which will be extremely slow.")
    
        # 1. åˆå§‹åŒ– Real-ESRGAN (èƒŒæ™¯è¶…åˆ†)
        print("INFO: Initializing Real-ESRGAN core model...")
        realesrgan_model = RRDBNet(num_in_ch=3, num_out_ch=3, num_feat=64, num_block=23)
    
        bg_upsampler = RealESRGANer(
            scale=UPSCALING_FACTOR,
            model_path=REALESRGAN_MODEL_PATH,
            model=realesrgan_model,
            device=device,
            tile=TILE_SIZE,  # ä½¿ç”¨åˆ‡å—å¤„ç†å¤§å›¾
            tile_pad=10,
        )
    
        # 2. åˆå§‹åŒ– GFPGAN (äººè„¸ä¿®å¤)ï¼Œå¹¶å°† RealESRGAN ä½œä¸ºå…¶èƒŒæ™¯ä¸Šé‡‡æ ·å™¨
        print("INFO: Initializing GFPGAN face enhancer...")
        face_enhancer = GFPGANer(
            model_path=GFPGAN_MODEL_PATH,
            upscale=UPSCALING_FACTOR,
            arch='clean',
            bg_upsampler=bg_upsampler,
            device=device,
        )
    
        print("INFO: Engines initialized. Device:", face_enhancer.device)
        return face_enhancer
    
    
    # -------------------------------------------------------------
    # [V16.0 ä¿®å¤] çº¿ç¨‹å®‰å…¨çš„å¼‚æ­¥ I/O å†™å…¥
    # -------------------------------------------------------------
    def _write_frame_and_checkpoint(frame_idx, output_frame, output_path, quality):
        """
        æ‰§è¡Œæ–‡ä»¶å†™å…¥å’Œè¿›åº¦æ›´æ–°ã€‚
        æ­¤å‡½æ•°åœ¨ I/O çº¿ç¨‹æ± ä¸­å¼‚æ­¥è¿è¡Œã€‚
        """
        try:
            # 1. å†™å…¥å›¾ç‰‡ (è€—æ—¶æ“ä½œï¼Œå¹¶å‘æ‰§è¡Œ)
            cv2.imwrite(
                output_path,
                output_frame,
                [int(cv2.IMWRITE_JPEG_QUALITY), quality]
            )
    
            # 2. å†™å…¥è¿›åº¦ (åŠ é”æ‰§è¡Œ)
            # åªæœ‰è·å¾—é”çš„çº¿ç¨‹æ‰èƒ½å†™æ–‡ä»¶ï¼Œé˜²æ­¢å¤šçº¿ç¨‹åŒæ—¶å ç”¨æ–‡ä»¶å¥æŸ„å¯¼è‡´ç¨‹åºæŒ‚èµ·
            with CHECKPOINT_LOCK:
                with open(CHECKPOINT_FILE, 'w') as f:
                    # å†™å…¥ä¸‹ä¸€ä¸ªå¾…å¤„ç†çš„å¸§ç´¢å¼• (å³å·²å®Œæˆçš„å¸§æ•°)
                    f.write(str(frame_idx + 1))
    
        except Exception as e:
            print(f"\nERROR in I/O worker for frame {frame_idx}: Write failed: {e}")
    
    
    # -------------------------------------------------------------
    # æ ¸å¿ƒå‡½æ•°ï¼šè§†é¢‘å¤„ç† (åŒ…å«æ–­ç‚¹ç»­ä¼ )
    # -------------------------------------------------------------
    
    def process_video(upsampler):
        """ä»è§†é¢‘ä¸­è¯»å–å¸§ï¼Œæ‰¹é‡è¿›è¡Œ GPU æ¨ç†ï¼Œå¹¶å¼‚æ­¥å†™å…¥åˆ°ç£ç›˜ã€‚"""
    
        os.makedirs(OUTPUT_DIR, exist_ok=True)
    
        cap = cv2.VideoCapture(INPUT_VIDEO_PATH)
        if not cap.isOpened():
            print(f"ERROR: Cannot open video file: {INPUT_VIDEO_PATH}")
            return False, None
    
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        fps = cap.get(cv2.CAP_PROP_FPS)
    
        if total_frames <= 0 or fps <= 0:
            print("ERROR: Cannot retrieve frame count. Check video integrity.")
            return False, None
    
        # --- Checkpoint/Resume Logic ---
        start_frame = 0
        if os.path.exists(CHECKPOINT_FILE):
            try:
                with open(CHECKPOINT_FILE, 'r') as f:
                    content = f.read().strip()
                    if content:
                        start_frame_from_file = int(content)
                        
                        # æ£€æŸ¥æ˜¯å¦å·²å…¨éƒ¨å®Œæˆ
                        if start_frame_from_file >= total_frames:
                            print("INFO: All frames already processed based on checkpoint.")
                            cap.release()
                            # æ¸…ç† checkpoint æ–‡ä»¶
                            if os.path.exists(CHECKPOINT_FILE):
                                os.remove(CHECKPOINT_FILE)
                            return True, fps
                            
                        start_frame = start_frame_from_file
                        print(f"INFO: Checkpoint found. Resuming from frame {start_frame}...")
            except ValueError:
                print("WARNING: Checkpoint corrupted. Starting from 0.")
    
        # è®¾ç½®è§†é¢‘è¯»å–çš„èµ·å§‹ä½ç½®
        cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)
        current_frame_idx = start_frame
    
        # ä½¿ç”¨ ThreadPoolExecutor ç®¡ç† I/O çº¿ç¨‹
        with concurrent.futures.ThreadPoolExecutor(max_workers=IO_THREADS) as executor:
            futures = []  # è®°å½•æ‰€æœ‰æäº¤çš„ I/O ä»»åŠ¡
            pbar = tqdm(total=total_frames, initial=start_frame, desc="Processing", ascii=True)
    
            while current_frame_idx < total_frames:
                frame_batch = []
                frame_indices = []
                
                # --- 1. æ‰¹é‡è¯»å–ä¸è·³è¿‡é€»è¾‘ ---
                frames_to_read = 0
                temp_idx = current_frame_idx
                first_read_idx = -1
    
                # é¢„æ‰«æï¼šç¡®å®šå“ªäº›å¸§éœ€è¦çœŸæ­£è¯»å–ï¼Œå“ªäº›å¯ä»¥è·³è¿‡(å·²å­˜åœ¨)
                while frames_to_read < BATCH_SIZE and temp_idx < total_frames:
                    output_frame_path = os.path.join(OUTPUT_DIR, f"frame_{temp_idx:06d}{OUTPUT_FRAME_EXTENSION}")
    
                    if os.path.exists(output_frame_path) and os.path.getsize(output_frame_path) > 0:
                        # æ–‡ä»¶å­˜åœ¨ä¸”ä¸ä¸ºç©ºï¼Œè·³è¿‡ï¼Œå¹¶æ›´æ–°è¿›åº¦æ¡
                        temp_idx += 1
                        pbar.update(1)
                        continue
                    else:
                        # æ‰¾åˆ°ç¬¬ä¸€ä¸ªéœ€è¦å¤„ç†çš„å¸§
                        if first_read_idx == -1:
                            first_read_idx = temp_idx
                        frames_to_read += 1
                        temp_idx += 1
    
                # å®é™…æ‰§è¡Œè¯»å–æ“ä½œ
                if first_read_idx != -1:
                    # å¦‚æœè·³è¿‡äº†ä¸€äº›å¸§ï¼Œéœ€è¦é‡æ–°å®šä½è§†é¢‘æµ
                    if first_read_idx > current_frame_idx:
                        cap.set(cv2.CAP_PROP_POS_FRAMES, first_read_idx)
                    
                    current_frame_idx = first_read_idx # æ›´æ–°æŒ‡é’ˆåˆ°å®é™…è¯»å–ä½ç½®
    
                    for _ in range(frames_to_read):
                        ret, frame = cap.read()
                        if not ret:
                            # è§†é¢‘æå‰ç»“æŸ
                            break
                        frame_batch.append(frame)
                        frame_indices.append(current_frame_idx)
                        current_frame_idx += 1
                else:
                    # æœ¬æ‰¹æ¬¡æ‰€æœ‰å¸§éƒ½å·²å­˜åœ¨(è·³è¿‡äº†)
                    if temp_idx >= total_frames:
                        break
                    current_frame_idx = temp_idx
                    if not frame_batch and current_frame_idx < total_frames:
                        # å³ä½¿æ²¡æœ‰è¯»å–æ–°çš„å¸§ï¼Œä¹Ÿè¦ç¡®ä¿ç»§ç»­å¾ªç¯ç›´åˆ°ç»“æŸ
                        continue
                    elif current_frame_idx >= total_frames:
                        break
    
                # --- 2. GPU é¡ºåºæ¨ç† ---
                for i, frame in enumerate(frame_batch):
                    f_idx = frame_indices[i]
                    output_frame_path_i = os.path.join(OUTPUT_DIR, f"frame_{f_idx:06d}{OUTPUT_FRAME_EXTENSION}")
    
                    try:
                        # RealESRGAN + GFPGAN è”åˆå¤„ç†
                        _, _, output_frame = upsampler.enhance(
                            frame, has_aligned=False, only_center_face=False, paste_back=True
                        )
    
                    except Exception as e:
                        print(f"\nERROR: Processing failed for frame {f_idx}: {e}")
                        cap.release()
                        pbar.close()
                        return False, fps
    
                    # --- 3. æäº¤å¼‚æ­¥ I/O ä»»åŠ¡ ---
                    # å°†å¤„ç†ç»“æœå’Œè¿›åº¦æ›´æ–°æäº¤ç»™çº¿ç¨‹æ± 
                    future = executor.submit(
                        _write_frame_and_checkpoint,
                        f_idx,
                        output_frame,
                        output_frame_path_i,
                        JPEG_QUALITY
                    )
                    futures.append(future)
                    pbar.update(1)
    
                    # [å†…å­˜ä¼˜åŒ–] å®šæœŸæ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡å¼•ç”¨ï¼Œé˜²æ­¢ futures åˆ—è¡¨æ— é™è†¨èƒ€
                    futures = [f for f in futures if not f.done()]
    
            # å¾ªç¯ç»“æŸ
            pbar.close()
            print("\nINFO: GPU processing finished. Waiting for pending I/O writes...")
            
            # [V16.0 å…³é”®ä¿®å¤] ä¼˜é›…å…³é—­çº¿ç¨‹æ± 
            # wait=True ä¼šé˜»å¡ä¸»çº¿ç¨‹ç›´åˆ°æ‰€æœ‰ I/O ä»»åŠ¡å®Œæˆã€‚
            executor.shutdown(wait=True)
    
        cap.release()
        
        # å†æ¬¡æ£€æŸ¥å¹¶æ¸…ç† checkpoint
        if os.path.exists(CHECKPOINT_FILE):
            try:
                os.remove(CHECKPOINT_FILE)
            except:
                pass
                
        print("\nINFO: All frames processed successfully.")
        return True, fps
    
    
    # -------------------------------------------------------------
    # æ ¸å¿ƒå‡½æ•°ï¼šè§†é¢‘åˆæˆï¼ˆä½¿ç”¨ FFmpegï¼‰
    # -------------------------------------------------------------
    
    def combine_video(original_fps):
        """ä½¿ç”¨ FFmpeg å°†é«˜åˆ†è¾¨ç‡å¸§ä¸åŸå§‹éŸ³é¢‘åˆæˆä¸ºæœ€ç»ˆè§†é¢‘ã€‚"""
    
        image_sequence = os.path.join(OUTPUT_DIR, f"frame_%06d{OUTPUT_FRAME_EXTENSION}")
        final_video_path = os.path.join(OUTPUT_DIR, OUTPUT_VIDEO_NAME)
        temp_audio_path = os.path.join(OUTPUT_DIR, "temp_audio.aac")
    
        # 1. æå–éŸ³é¢‘
        print("INFO: Extracting audio...")
        # å°è¯•ä½¿ç”¨ FFmpeg æå–éŸ³é¢‘æµï¼Œ-vn è·³è¿‡è§†é¢‘æµï¼Œ-acodec copy å¤åˆ¶éŸ³é¢‘ç¼–ç 
        audio_command = [
            'ffmpeg', '-i', INPUT_VIDEO_PATH,
            '-vn', '-acodec', 'copy', temp_audio_path,
            '-y'
        ]
    
        has_audio = False
        try:
            # ä½¿ç”¨ subprocess.run æ‰§è¡Œå‘½ä»¤å¹¶æ£€æŸ¥è¿”å›ç 
            subprocess.run(audio_command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            has_audio = True
        except subprocess.CalledProcessError:
            print("WARNING: No audio stream found or extraction failed. Video will be silent.")
            has_audio = False
    
        # 2. åˆå¹¶å¸§åºåˆ—å’ŒéŸ³é¢‘
        print(f"INFO: Combining frames into {OUTPUT_VIDEO_NAME}...")
        ffmpeg_command = [
            'ffmpeg',
            '-r', str(original_fps), # è®¾ç½®è¾“å…¥å¸§ç‡
            '-i', image_sequence, # è¾“å…¥å›¾ç‰‡åºåˆ—
        ]
    
        # å¦‚æœéŸ³é¢‘æå–æˆåŠŸï¼Œåˆ™æ·»åŠ éŸ³é¢‘è¾“å…¥
        if has_audio and os.path.exists(temp_audio_path):
            ffmpeg_command.extend(['-i', temp_audio_path])
    
        # è§†é¢‘è¾“å‡ºè®¾ç½®
        ffmpeg_command.extend([
            '-c:v', 'libx264',  # ç¼–ç å™¨
            '-crf', VIDEO_CRF,  # è´¨é‡å› å­
            '-pix_fmt', 'yuv420p', # åƒç´ æ ¼å¼ï¼Œä¿è¯å…¼å®¹æ€§
            # è§†é¢‘æ»¤é•œï¼šç¼©æ”¾å¹¶å±…ä¸­åˆ°ç›®æ ‡åˆ†è¾¨ç‡ (TARGET_WIDTH x TARGET_HEIGHT)
            '-vf', f'scale={TARGET_WIDTH}:{TARGET_HEIGHT}:force_original_aspect_ratio=decrease, pad={TARGET_WIDTH}:{TARGET_HEIGHT}:(ow-iw)/2:(oh-ih)/2',
            '-y', final_video_path
        ])
    
        start_time = time.time()
        try:
            subprocess.run(ffmpeg_command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            print(f"SUCCESS: Video saved to {final_video_path}")
            print(f"Time taken: {time.time() - start_time:.2f}s")
            
            # æ¸…ç†ä¸´æ—¶éŸ³é¢‘æ–‡ä»¶
            if has_audio and os.path.exists(temp_audio_path):
                os.remove(temp_audio_path)
    
        except subprocess.CalledProcessError as e:
            print(f"FATAL ERROR: FFmpeg failed. Please check if FFmpeg is installed and accessible.")
            print(f"Error details: {e.stderr.decode()}")
    
    
    # -------------------------------------------------------------
    # ğŸ ä¸»ç¨‹åºå…¥å£
    # -------------------------------------------------------------
    
    if __name__ == "__main__":
        
        # ç¯å¢ƒæ£€æŸ¥
        if not os.path.exists(INPUT_VIDEO_PATH):
            print(f"FATAL ERROR: Input video not found: {INPUT_VIDEO_PATH}")
        else:
            # 1. åˆå§‹åŒ–æ¨¡å‹
            upsampler = initialize_upsampler()
    
            if upsampler:
                # 2. å¤„ç†å¸§
                success, fps = process_video(upsampler)
    
                # 3. åˆæˆè§†é¢‘
                if success and fps:
                    combine_video(fps)
    
        print("\n------------------------------------")
        print("ğŸ¬ Job Done.")
        print("------------------------------------")

ğŸƒ ä½¿ç”¨æ­¥éª¤
-------

1.  **ä¿å­˜ä»£ç **: å°†ä¸Šè¿°ä»£ç ä¿å­˜ä¸º `upscale_processor.py`ã€‚
2.  **ä¿®æ”¹é…ç½®**: åœ¨ä»£ç å¼€å¤´ä¿®æ”¹ `INPUT_VIDEO_PATH`, `OUTPUT_DIR`, `REALESRGAN_MODEL_PATH`, å’Œ `GFPGAN_MODEL_PATH` å››ä¸ªå˜é‡ï¼Œç¡®ä¿è·¯å¾„æ­£ç¡®ã€‚
3.  **è¿è¡Œè„šæœ¬**: åœ¨å‘½ä»¤è¡Œä¸­æ‰§è¡Œï¼š
    
        python upscale_processor.py
    
4.  **æŸ¥çœ‹ç»“æœ**: ç¨‹åºå°†åœ¨ `OUTPUT_DIR` ç›®å½•ä¸‹è¾“å‡ºä¸­é—´å¸§åºåˆ—ï¼Œå¹¶åœ¨å¤„ç†å®Œæˆåç”Ÿæˆæœ€ç»ˆè§†é¢‘ `upscaled_video_1080p.mp4`ã€‚
5.  **å¤„ç†ä¸­æ–­**: å¦‚æœç¨‹åºä¸­æ–­ï¼Œé‡æ–°è¿è¡Œå³å¯ã€‚å®ƒå°†è‡ªåŠ¨æ£€æµ‹ `checkpoint.txt` å¹¶ä»ä¸Šæ¬¡ä¸­æ–­çš„å¸§ç»§ç»­å¤„ç†ã€‚

å¸Œæœ›è¿™ä¸ª V16.0 ç»ˆæä¿®å¤ç‰ˆèƒ½å¸®åŠ©æ‚¨é«˜æ•ˆç¨³å®šåœ°å®Œæˆè§†é¢‘è¶…åˆ†ä»»åŠ¡ï¼å¦‚æœæ‚¨æƒ³è°ƒæ•´äººè„¸ä¿®å¤çš„åŠ›åº¦æˆ–èƒŒæ™¯è¶…åˆ†çš„ç»†èŠ‚ï¼Œå¯ä»¥åœ¨ä»£ç ä¸­ç ”ç©¶ RealESRGANer å’Œ GFPGANer çš„æ›´å¤šå‚æ•°ï¼ˆä¾‹å¦‚ `fidelity_weight`ï¼‰ã€‚  
é¡¹ç›®ä»£ç å’Œæ¨¡å‹æ•°æ®åœ°å€ï¼š

é€šè¿‡ç½‘ç›˜åˆ†äº«çš„æ–‡ä»¶ï¼šVividRestore.zip  
é“¾æ¥: https://pan.baidu.com/s/1baXHkciH1\_8-mQoDE4enUg æå–ç : t6gp å¤åˆ¶è¿™æ®µå†…å®¹åæ‰“å¼€ç™¾åº¦ç½‘ç›˜æ‰‹æœºAppï¼Œæ“ä½œæ›´æ–¹ä¾¿å“¦

@import url("https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap"); body { font-family: "Inter", sans-serif; background-color: rgba(244, 247, 249, 1) } pre { background-color: rgba(31, 41, 55, 1); color: rgba(249, 250, 251, 1); padding: 1rem; border-radius: 0.5rem; overflow-x: auto; line-height: 1.4; font-size: 0.875rem } code { font-family: monospace } table { width: 100%; border-collapse: collapse; margin-top: 1rem; margin-bottom: 2rem; text-align: left } th, td { padding: 0.75rem 1rem; border: 1px solid rgba(229, 231, 235, 1) } th { background-color: rgba(229, 231, 235, 1); font-weight: 600 } ul { list-style-type: disc; padding-left: 1.5rem } .container-wrapper { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1) } @media (max-width: 640px) { .blog-content { padding: 1rem } h1 { font-size: 1.5rem } h2 { font-size: 1.25rem } }