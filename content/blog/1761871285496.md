---
layout: post
title: '深入解析 JuiceFS 垃圾回收机制'
date: "2025-10-31T00:41:25Z"
---
深入解析 JuiceFS 垃圾回收机制
===================

在使用 JuiceFS 的过程中，用户可能会遇到以下常见问题：

*   删除文件后，为什么对象存储空间未能及时释放？
*   回收站中堆积大量文件，如何高效清理？
*   在短时间内批量删除文件时，删除操作为什么这么缓慢或性能下降？

JuiceFS的垃圾回收机制背后的执行流程相对复杂，用户难以直观理解文件状态变更和资源释放的时机。为帮助用户深入理解文件删除与存储回收的内部逻辑，本文将系统梳理垃圾回收的关键流程与实现原理，解析常见问题的成因，并提供高效清理与运维的操作建议。

01 前置知识：JuiceFS 文件存储结构
----------------------

JuiceFS 采用异步删除机制处理文件删除请求，可在第一时间响应用户操作，并将清理任务延后至系统空闲时执行，从而削峰降压、降低系统负载，提升整体稳定性。同时，这种分阶段的清理策略也为数据恢复预留了更大的灵活性。

这种机制的高效实现，得益于 JuiceFS 的底层设计架构。JuiceFS 采用元数据与数据分离的存储架构，并对文件数据进行切块管理。在执行删除操作时，系统并不会立即清除实际数据，而是仅在元数据层修改删除标记；真正的数据回收将在后续异步流程中完成。

要深入理解异步删除的执行逻辑，还需要了解 JuiceFS 内部的数据组织方式。系统在底层通过 Chunk、Slice、Block 三层结构来管理文件数据，这一结构不仅决定了文件在存储与访问时的性能表现，也直接影响删除过程中数据的定位、引用计数与清理策略。

*   Chunk：每个文件由一个或多个 Chunk 构成，每个 Chunk 最大为 64MB。无论文件大小如何，所有读写操作都会根据偏移量定位到对应的 Chunk，提升查找与访问效率。
*   Slice：Chunk 中的实际写入单位。每次连续写入生成一个 Slice，Slice 必须完全位于单个 Chunk 内，因此其大小不会超过 64MB。文件写入过程会产生多个 Slice。
*   Block：为提升对象存储写入效率，Slice 在写入前会被进一步拆分成多个 Block（默认最大为 4MB），并通过多线程并发写入以提高吞吐量。

02 JuiceFS 垃圾回收流程详解
-------------------

在了解完前文的背景机制之后，让我们正式进入文件删除的主流程。如果进行简单划分，JuiceFS 的删除机制大致可分为三个关键过程：回收站管理、文件删除处理和底层 Slice 清理。

### 模块 1：回收站管理

文件删除流程的起点，始于用户的删除请求。当上层接口发起文件删除操作后，系统并不会立即删除文件，而是将其移动至回收站（默认开启）。此过程中，仅有文件父目录的指向关系发生变更，文件的其他元数据信息和文件内容仍保持不变。

当文件在回收站中存留达到设定的保留期限后，系统通过后台清理任务或手动方式将其转为“待删除文件”，从而进入后续的清理流程。

为更好地理解和管理回收站中的文件，以下将具体说明其目录结构与工作机制。

回收站的路径为挂载点下的 `.trash` 目录。用户删除的文件会被保存到以删除时间（精确到小时）命名的子目录中，例如：`.trash/2024-01-15-14/`。为了避免重名冲突，进入回收站的文件会被自动重命名，重命名规则为：`<父目录ID>_<文件ID>_<原文件名>`

对于已被移入回收站的文件，系统也提供了灵活的恢复机制。详见[回收站文档](https://juicefs.com/docs/zh/community/security/trash#recover)  
移动到回收站的文件不会一直保留，JuiceFS 的回收站清理机制主要包括两种方式：

*   自动清理由系统的每小时定期触发的后台任务（cleanupTrash），按照设定的保留天数逐步清理，将文件标记删除。
*   手动清理，可通过操作系统的 `rm` 命令或 JuiceFS 提供的 `juicefs rmr` 工具直接删除回收站中的文件或目录。手动清理相比后台任务能更快地回收空间，但整个过程依然是异步的（实际回收对象存储的动作由后续其他任务执行，详见后文）。

此外，回收站清理的性能受到单个客户端处理能力的限制。当需要删除大量文件时，建议在多个客户端上同时挂载 JuiceFS 并行执行手动清理，从而显著提升大规模删除操作的整体效率。

### 模块 2：文件删除

在这一阶段，系统首先判断文件是否仍处于使用中。若文件尚未关闭（例如仍被某些进程占用），则会被暂时置于“暂缓删除”状态（sustained file），等待相关使用关系释放后再重新进入清理流程。若文件已关闭，系统会将其标记为“可清理文件”（内部状态 delfile），表示该文件可进入删除队列处理。

随后，系统尝试将这些标记为“可清理”的文件（delfile）加入“文件删除队列”。该队列用于缓存待清理文件，但为了避免影响系统性能，其容量受到限制。若队列已满，普通文件的删除操作将暂时跳过，等待后台清理任务接手。

对于回收站中的文件，若用户执行了手动删除操作，而此时删除队列已满，该操作将同步阻塞，直到队列空出位置为止。这一策略可确保手动删除行为在当前流程中完成入队，不会被跳过。

为保障所有可清理文件最终都能被处理，JuiceFS 提供了一个每小时运行一次的后台任务 `cleanupDeletedFiles`，该任务会扫描仍处于“可清理状态”的文件（delfile），并将它们批量加入删除队列，确保清理流程持续推进。

一旦文件成功进入删除队列，系统会扫描其关联的所有 chunk，并对每个 chunk 所包含的 slice 执行引用计数减一操作，然后清理 chunk 元数据。引用计数为 0 的 slice 将被标记为“待清理”，进入后续的 slice 清理阶段。

### 模块 3：slice 清理与空间回收

在上一模块中，文件关联的每个 slice 已完成引用计数更新操作。此阶段，系统会继续判断这些 slice 当前的引用计数：若引用计数仍大于 0，说明该 slice 仍被其他文件所使用，不会执行清理操作；若引用计数已经降至 0，则意味着该 slice 已完全失效，系统会将其加入 slice 删除队列，进入下一步的清理流程。

后台定时任务 `cleanupSlices` 会定期扫描该队列并完成批量清理操作，用户也可以通过手动触发 GC 来主动清除这些无效 slice。进入该流程的 slice 会被系统准确定位到对象存储中的物理 block，并完成实际的删除操作，从而释放存储空间。

需要注意的是，slice 删除队列本身也受到并发与容量的限制。系统支持通过 `--max-deletes` 参数调整并发线程数量，以控制同时进行的删除操作数，从而在资源占用与清理效率之间取得平衡。

03 碎片整理机制
---------

上文介绍了文件删除与回收的完整流程。然而，在 JuiceFS 中还存在另一类“隐性垃圾”——即重复或无用的文件碎片。由于文件在存储时会被划分为固定大小的 chunk，每个 chunk 内又包含若干个 slice。若用户对同一文件进行频繁的覆盖写入或随机写入，将导致某些 chunk 中 slice 的排列变得非常零散、不连续。这种情况就称为碎片化。

尽管碎片化并不会影响文件的正常读取，但它会带来多项性能与资源上的负面影响：

*   读取放大：读取一个 chunk 时，需要拼接多个分散的 slice，增加了 I/O 操作复杂度。
*   资源占用增加：碎片越多，对应的元数据和对象存储空间占用也随之上升，加重系统负担，降低整体性能。

为优化碎片化问题，JuiceFS 提供了碎片整理功能，通过识别并合并 chunk 中冗余或分散的 slice，将其重构为结构更紧凑的大块数据，从而显著减少碎片数量并提升存储效率。JuiceFS 支持以下两种整理机制。

自动触发：系统在文件读写过程中会监测 chunk 中 slice 的数量。当某个 chunk 内部的 slice 数达到设定阈值时，系统会自动启动一个异步任务，执行整理操作。该过程包括：

*   在元数据层申请一个新的 slice ID，用于构建连续的合并数据。
*   从对象存储中依次读取旧的 slice 数据，并将其写入新的连续数据块中。
*   原有slice引用计数减一。如果开启了回收站功能，则这部分 Slice 会标记为延迟处理，交由后台任务进行引用计数更新与清理操作。

手动触发：用户可使用 `juicefs compact` 命令主动对指定路径进行全面扫描与并发整理。其中 `--threads` 参数用于控制并发线程数，可根据业务压力灵活调整，以平衡性能与资源使用。详细的使用方法，请查看[命令文档](https://juicefs.com/docs/zh/community/command_reference#compact)。

    # 对一个或多个路径发起整理；可指定并发 
    juicefs compact /mnt/jfs/pathA /mnt/jfs/pathB --threads 16 
    # 简写 
    juicefs compact /mnt/jfs/path --p 16
    
    

此外，为了辅助用户了解当前系统中碎片的处理情况，JuiceFS 提供了监控手段帮助用户通过 `juicefs status` 命令查看关键碎片相关指标，详见下一章节。

04 垃圾回收相关工具原理与使用建议
------------------

### GC 工具

GC（Garbage Collection）是 JuiceFS 中用于手动清理的辅助工具，支持多种操作方式，包括仅检查（dry-run）、扫描并清理等。该工具的核心原理是基于元数据和对象存储数据的扫描对比，识别并处理那些不再被引用或管理的对象，确保系统数据一致性并释放无效占用的底层空间。

在某些异常场景或人为操作失误下，对象存储中可能会存在脱离 JuiceFS 元数据管理的数据片段，形成所谓的“对象存储泄露”。虽然发生概率较低，但一旦出现，可通过 GC 工具进行扫描与清除。除此之外，GC 还可用于清理元数据中遗留的无效记录，例如清理流程中未被完全移除的文件或 slice 信息，以及加速垃圾回收过程中的各个流程，如手动碎片整理、手动清理 “可清理文件”（delfile） 等。

在实际运行过程中，GC 命令会显示进度条，便于用户实时查看任务执行状态。进度条中呈现的各类状态信息可以与前文提到的图示内容一一对应，帮助用户更清晰地理解垃圾回收流程。有些用户在使用过程中，特别是在资源计费相关操作中，曾表示对这些状态项的含义感到困惑。而结合图示与状态信息进行对照解读，可以有效提升理解力，帮助掌握整个垃圾回收机制的运作逻辑。

GC 各项指标说明：

*   Pending deleted files/data: 待删除文件数/ 数据量
*   Cleaned pending files/data：本次 GC 已删除文件数/数据量
*   Listed slices：文件系统中的所有 slice 数量
*   Trash slices：回收站内的 slice
*   Cleaned trash slices/data：本次 GC 已清理的回收站 slice/数据量
*   Scanned objects：对象存储中的所有对象
*   Valid objects/data: 对象存储中的有效对象/数据量
*   Compacted objects/data:：经过碎片整理压缩后的对象/数据量
*   Leaked objects/data：泄漏的对象/数据量
*   Skipped objects/data：GC 中跳过的对象/数据量

### 状态指标

`juicefs status` 可用来查看 JuiceFS 的所有状态，其中与垃圾回收相关的内容在下方罗列。这些指标对应了清理流程中的不同阶段，能够作为判断系统清理进度与任务状态的重要依据。如果发现某类碎片数量持续增长、后台处理能力无法及时响应，用户可考虑使用手动清理方式加速处理过程，避免系统性能受损。

*   Trash Files：回收站中的暂存文件
*   Pending Deleted Files：已标记为待删除的文件
*   To be sliced：待整理的碎片任务
*   Trash Slices：回收站中的隐藏碎片（来自 compact），可用于数据恢复
*   Pending Deleted Slices：引用计数已归零、等待清理的 slice

最后，我们也为用户总结了一些基础且实用的操作建议，帮助在日常使用中更高效地管理 JuiceFS 系统资源，降低运维风险。

*   建议根据具体业务场景设置合理的回收站保留时长，以在数据可恢复性与存储成本之间取得平衡。对于文件更替频繁或对存储成本较为敏感的系统，可适当缩短保留周期，以减少空间浪费。
*   推荐运维人员定期使用 `juicefs status` 等工具，监控关键清理指标，如 Pending Delete 文件数、Delayed Slice 数量、Trash 空间占用等，以便及时发现潜在的清理滞后或资源积压问题。
*   如果系统未启用自动后台任务，则应定期执行 GC 操作或相关清理命令，主动清除元数据与对象存储中的无效残留，避免长期闲置带来的性能风险和资源浪费。
*   所有清理类任务应尽量避开业务高峰时段执行，以减少对正常读写操作的干扰，保障系统整体稳定性。通过上述策略，用户可以更有节奏地管理系统生命周期中的删除与回收过程，实现资源利用效率的持续优化。