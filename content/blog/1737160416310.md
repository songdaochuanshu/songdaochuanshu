---
layout: post
title: '深入解析 Spring AI 系列：分析 Spring AI 可观测性'
date: "2025-01-18T00:33:36Z"
---
深入解析 Spring AI 系列：分析 Spring AI 可观测性
===================================

今天我们将讨论之前略过的可观测性部分的代码。在这里，我想简单说明一下，当时这部分代码属于必须编写的固定模板，因此在最初的讨论中我们直接跳过了它。虽然这部分代码乍看之下可能显得比较复杂，但实际上它的核心功能只是链路追踪的实现而已。既然如此，接下来我们就不再赘述，直接来看一下这部分关键代码，如图所示：

![image](https://img2024.cnblogs.com/blog/1423484/202501/1423484-20250113172451098-136845465.png)

我们今天的目的也很明确，那就是不必过于纠结于其底层源码是如何运转和注入解析的。我们更关注的是这段代码在Spring AI框架中所发挥的实际作用。

micrometer
==========

如果当时你点击了该引用，你是可以找到与之相关的包依赖信息的。如果你希望获取更多的详细信息，建议访问其官方文档，详细内容请见：[https://docs.micrometer.io/micrometer/reference/observation.html](https://docs.micrometer.io/micrometer/reference/observation.html)

JMX观测
-----

为了更清晰地理解micrometer的具体工作原理，今天我们将通过两个实际的例子带领大家快速了解其运作方式。第一个例子是关于许多Java编程开发者都非常熟悉的工具——jconsole。如果你不熟悉该工具，也不必担心，你可以直接前往jdk的bin目录进行查找，具体位置如图所示。

![image](https://img2024.cnblogs.com/blog/1423484/202501/1423484-20250113172456222-214972067.png)

剩下的就需要在我们的demo聊天示例的项目依赖中添加相关依赖。代码如下：

    <groupId>io.micrometer</groupId>
        <artifactId>micrometer-observation</artifactId>
    </dependency>
    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-registry-jmx</artifactId>
    </dependency>
    

剩下的部分我们基本上不需要进行修改了。接下来，只需直接双击启动 `jconsole` 工具，并连接到我们的本地程序即可。然后，进入 MBean 标签页，我们就可以轻松地查看到相关的配置信息和监控数据。不过，需要注意的是，这些信息简洁明了并不够全面。具体情况可以参见下图所示：

![image](https://img2024.cnblogs.com/blog/1423484/202501/1423484-20250113172501456-359451307.png)

在这里，我们并没有看到源码中所添加的那些特定 key 被纳入观测范围。如下所示：

![image](https://img2024.cnblogs.com/blog/1423484/202501/1423484-20250113172505475-221103845.png)

所以目前，分布式链路追踪在系统监控和性能调优中得到了广泛应用。为了便于演示，我们简单地展示了轻量级的 Zipkin 进行链路追踪观测的基本功能。当然，除了 Zipkin，还可以选择使用其他工具，如 Prometheus 与 Grafana 的组合，或者更为全面的 SkyWalking 等方案

zipkin观测
--------

在这里，我将直接在服务器上使用 Docker 容器进行运行。请确保在启动容器时，暴露出相关的端口，以便我们的 demo 程序能够通过这些端口与容器进行通信并上传信息。以下是具体的命令：

> docker run --name zipkin -d -p 9411:9411 openzipkin/zipkin

然后需要添加部分依赖，如下所示：

    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-observation</artifactId>
    </dependency>
    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-tracing-bridge-brave</artifactId>
    </dependency>
    <dependency>
        <groupId>io.zipkin.reporter2</groupId>
        <artifactId>zipkin-reporter-brave</artifactId>
    </dependency>
    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-registry-prometheus</artifactId>
    </dependency>
    

由于 Zipkin 在使用过程中需要配置一些关键的项目信息，例如指定我们的 Zipkin 服务器地址，以及其他相关的服务端点和连接参数，因此需要在配置文件中加入这些必要的信息。具体的项目信息配置如下：

    management.endpoints.web.exposure.include=*
    management.endpoint.health.show-details=always
    
    management.zipkin.tracing.endpoint=http://ip:9411/api/v2/spans
    management.tracing.sampling.probability=1.0
    

在正常启动我们的项目之后，可以执行一次接口调用，并直接访问 Zipkin 以查看当时的接口调用情况。通过这种方式，你将能够清晰地观察到与该接口调用相关的可观测性信息，包括所有的 key 和 value。具体的结果如图所示：

![image](https://img2024.cnblogs.com/blog/1423484/202501/1423484-20250113172513265-1211056153.png)

这部分看下即可，不做重要解析。

总结
==

通过今天的讨论，我们简单探讨了可观测性部分的代码及其在 Spring AI 框架中的实际作用。尽管底层实现可能显得复杂，但其核心功能无非是链路追踪的实现，帮助我们更好地理解和优化系统性能。通过实际示例，我们演示了如何利用工具如 jconsole 和 Zipkin 来观察系统的行为及性能指标。这些工具的使用能够提供清晰的监控数据，帮助开发者更有效地进行系统诊断和性能调优。在未来的工作中，合理运用这些工具将极大提升我们的可观测性实践。

* * *

我是努力的小雨，一个正经的 Java 东北服务端开发，整天琢磨着 AI 技术这块儿的奥秘。特爱跟人交流技术，喜欢把自己的心得和大家分享。还当上了腾讯云创作之星，阿里云专家博主，华为云云享专家，掘金优秀作者。各种征文、开源比赛的牌子也拿了。

💡 想把我在技术路上走过的弯路和经验全都分享出来，给你们的学习和成长带来点启发，帮一把。

🌟 欢迎关注努力的小雨，咱一块儿进步！🌟