---
layout: post
title: 'Windows 快速启动器'
date: "2025-01-22T00:35:34Z"
---
Windows 快速启动器
=============

在日常工作和学习中，我们经常需要快速访问某些功能或资源，例如打开常用网站、启动应用程序或执行特定命令。Linux 用户可以通过 `alias` 快速实现这些操作，但在 Windows 上缺乏类似的原生支持。本文将介绍如何使用 Python 开发一个 **隐藏式文本输入框程序**，模拟 Linux 的 `alias` 功能，实现快速启动和访问。

* * *

功能概述
----

该程序的核心功能如下：

1.  **隐藏式界面**：默认情况下，程序界面隐藏，按下热键后显示。
    
2.  **快速输入**：通过键盘输入关键字，按下回车键后执行相应操作。
    
3.  **自定义映射**：通过配置文件（如 `store.txt`）定义关键字与操作的映射关系。
    
4.  **快速打开网站**：输入关键字后，自动打开对应的 URL。
    
5.  **打开文件夹**：输入关键字后，打开指定的文件夹。
    
6.  **启动应用程序**：输入关键字后，启动指定的应用程序。
    
7.  **执行系统命令**：输入关键字后，执行系统命令（如打开服务管理器）。
    
8.  **单实例运行**：确保程序只运行一个实例，避免重复启动。
    

* * *

实现原理
----

### 1\. 隐藏式界面

使用 `tkinter` 创建一个无标题栏的文本输入框界面，默认隐藏。通过全局热键（如 `Alt + Win + Z`）显示界面，并将焦点设置到输入框。

### 2\. 关键字映射

通过读取配置文件（如 `store.txt`），将关键字与操作（如 URL、文件夹路径、应用程序路径或系统命令）关联起来。例如：

google https://www.google.com u
python https://www.python.org u
ubunt D:\\ubunt f
services %SystemRoot%\\system32\\services.msc o
notepad C:\\Windows\\System32\\notepad.exe o

### 3\. 快速执行

输入关键字后，按下回车键，程序会根据配置文件执行相应操作（如打开浏览器访问 URL、打开文件夹、启动应用程序或执行系统命令）。

### 4\. 单实例运行

使用 `psutil` 检查程序是否已经运行，避免重复启动。

* * *

代码实现
----

以下是完整的 Python 代码：

python

复制

import tkinter as tk
import keyboard
import ctypes
import sys
import os
import psutil
import webbrowser
import subprocess
import time

class StoreItem:
    def \_\_init\_\_(self, keyword, content, type\_):
        self.keyword \= keyword
        self.content \= content
        self.type\_ \= type\_

class Store:
    def \_\_init\_\_(self, file\_path):
        self.file\_path \= file\_path
        self.items \= {}
        self.last\_modified \= 0
        self.load()

    def load(self):
        if not os.path.exists(self.file\_path):
            print(f"错误：未找到文件 {self.file\_path}，请确保 store.txt 和脚本在同一目录下。")
            return

        self.last\_modified \= os.path.getmtime(self.file\_path)
        self.items.clear()

        with open(self.file\_path, "r", encoding="utf-8") as file:
            for line in file:
                columns \= line.strip().split()
                if len(columns) == 3:
                    keyword, content, type\_ \= columns
                    self.items\[keyword\] \= StoreItem(keyword, content, type\_)

    def get\_item(self, keyword):
        if os.path.getmtime(self.file\_path) > self.last\_modified:
            self.load()
        return self.items.get(keyword)

def is\_already\_running():
    current\_pid \= os.getpid()
    for proc in psutil.process\_iter(\['pid', 'name'\]):
        try:
            if proc.info\['name'\] == os.path.basename(sys.argv\[0\]) and proc.info\['pid'\] != current\_pid:
                return True
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass
    return False

if is\_already\_running():
    print("程序已经在运行中，退出当前实例。")
    sys.exit(0)

user32 \= ctypes.windll.user32
imm32 \= ctypes.windll.imm32

def show\_window():
    if not root.winfo\_viewable():
        root.deiconify()
    root.lift()
    root.focus\_force()
    screen\_width \= root.winfo\_screenwidth()
    screen\_height \= root.winfo\_screenheight()
    window\_width \= root.winfo\_reqwidth()
    window\_height \= root.winfo\_reqheight()
    x \= screen\_width - window\_width - 20
    y \= 20
    root.geometry(f"+{x}+{y}")
    text\_entry.focus\_set()
    text\_entry.delete(0, tk.END)
    switch\_to\_english()

def hide\_window():
    root.withdraw()

def on\_enter(event):
    input\_text \= text\_entry.get()
    if input\_text.strip():
        ontext(input\_text)
    text\_entry.delete(0, tk.END)
    hide\_window()

def handle\_action(item):
    if item.type\_ == "u":
        webbrowser.open(item.content)
        print(f"已打开 URL: {item.content}")
    elif item.type\_ == "f":
        os.startfile(item.content)
        print(f"已打开文件夹: {item.content}")
    elif item.type\_ == "o":
        subprocess.run(item.content, shell\=True)
        print(f"已执行命令: {item.content}")

def ontext(key):
    item \= store.get\_item(key)
    if item:
        handle\_action(item)
    else:
        print(f"未找到关键字为 {key} 的记录。")

def switch\_to\_english():
    hwnd \= user32.GetForegroundWindow()
    himc \= imm32.ImmGetContext(hwnd)
    if himc:
        imm32.ImmSetOpenStatus(himc, False)
        imm32.ImmReleaseContext(hwnd, himc)

root \= tk.Tk()
root.overrideredirect(True)
root.configure(bg\="white")

text\_entry \= tk.Entry(
    root,
    width\=20,
    font\=("Arial", 12),
    bd\=0,
    highlightthickness\=1,
    justify\="left"
)
text\_entry.pack(padx\=10, pady=10)

root.withdraw()

text\_entry.bind("<Return>", on\_enter)
keyboard.add\_hotkey("alt+windows+z", show\_window)
keyboard.add\_hotkey("esc", hide\_window)
text\_entry.bind("<FocusIn>", lambda event: switch\_to\_english())

script\_dir \= os.path.dirname(os.path.abspath(\_\_file\_\_))
store\_path \= os.path.join(script\_dir, "store.txt")
store \= Store(store\_path)

root.mainloop()

* * *

配置文件示例
------

在 `store.txt` 文件中添加以下内容：

 

google https://www.google.com u
python https://www.python.org u
ubunt D:\\ubunt f
services %SystemRoot%\\system32\\services.msc o
notepad C:\\Windows\\System32\\notepad.exe o

* * *

功能说明
----

1.  **打开 URL**：
    
    *   输入 `google`，打开 `https://www.google.com`。
        
    *   输入 `python`，打开 `https://www.python.org`。
        
2.  **打开文件夹**：
    
    *   输入 `ubunt`，打开 `D:\ubunt` 文件夹。
        
3.  **启动应用程序或执行系统命令**：
    
    *   输入 `services`，打开服务管理器。
        
    *   输入 `notepad`，启动记事本。
        

* * *

使用方法
----

1.  将 Python 脚本和 `store.txt` 文件放在同一目录下。
    
2.  运行 Python 脚本。
    
3.  按下 `Alt + Win + Z` 显示界面，输入关键字后按 `Enter` 键。
    
4.  程序会根据配置文件执行相应操作。
    

* * *

打包为可执行文件
--------

使用 `PyInstaller` 将脚本打包为 Windows 可执行文件：

bash

复制

pyinstaller \--onefile \--windowed main.py

生成的 `main.exe` 文件位于 `dist` 文件夹中。

* * *

总结
--

通过抽象 `StoreItem` 和 `Store` 类，代码逻辑更加清晰和模块化。**快速启动器** 不仅支持打开网址，还能打开文件夹、启动应用程序和执行系统命令。你可以根据需要在 `store.txt` 中添加更多映射关系，实现快速访问常用资源的目标。希望这个工具能帮助你提高工作效率！