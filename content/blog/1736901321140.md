---
layout: post
title: '.Net Core 管道底层源码实现'
date: "2025-01-15T00:35:21Z"
---
.Net Core 管道底层源码实现
==================

> 在 .NET Core 中，请求处理管道是一个中间件（Middleware）链，用于处理 HTTP 请求并生成响应。管道的底层实现基于 `Microsoft.AspNetCore.Http` 命名空间中的一些核心类和接口

### 1\. 核心组件

#### 1.1 `HttpContext`

*   • `HttpContext` 是 HTTP 请求和响应的核心抽象，封装了请求信息（如请求头、请求体、查询参数等）和响应信息（如状态码、响应头、响应体等）。
*   • 每个请求都会创建一个 `HttpContext` 实例，并在整个管道中传递。

#### 1.2 `HttpRequest` 和 `HttpResponse`

*   • `HttpRequest` 和 `HttpResponse` 分别表示 HTTP 请求和响应，是 `HttpContext` 的一部分。
*   • `HttpRequest` 包含请求的详细信息，如路径、方法、头、体等。
*   • `HttpResponse` 用于设置响应的状态码、头、体等。

#### 1.3 `RequestDelegate`

*   • `RequestDelegate` 是一个委托，表示处理 HTTP 请求的方法：

    public delegate Task RequestDelegate(HttpContext context);
    

*   • 管道中的每个中间件都是一个 `RequestDelegate`。

#### 1.4 `Middleware`

*   • 中间件是一个类或方法，用于处理请求并调用管道中的下一个中间件。
*   • 中间件通常通过 `Use` 或 `Run` 方法注册到管道中。

### 2\. 定义 `ApplicationBuilder` 接口

首先，我们定义 IApplicationBuilder 接口：

    public interface IApplicationBuilder
    {
        // 添加中间件到管道中
        IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware);
    
        // 构建最终的请求处理管道
        RequestDelegate Build();
    
        // 获取或设置应用程序服务提供者
        IServiceProvider ApplicationServices { get; set; }
    
        // 获取属性字典，用于存储共享数据
        IDictionary<string, object> Properties { get; }
    }
    

* * *

### 3\. 定义 RequestDelegate 委托

管道的核心是基于委托（Delegate）和上下文（Context）的机制。

`**RequestDelegate**`：是一个表示处理 HTTP 请求的委托。

    public delegate Task RequestDelegate(HttpContext context);
    

*   • `**HttpContext**`：封装了 HTTP 请求和响应的所有信息，包括请求头、请求体、响应头、响应体等。

每个中间件本质上是一个 `RequestDelegate`，它接收 `HttpContext` 并处理请求，同时可以选择调用下一个中间件。

* * *

### 4\. 实现 `ApplicationBuilder` 类

接下来，我们实现 ApplicationBuilder 类：

    public class ApplicationBuilder : IApplicationBuilder
    {
        // 存储中间件组件的列表
        private readonly IList<Func<RequestDelegate, RequestDelegate>> _components = new List<Func<RequestDelegate, RequestDelegate>>();
    
        // 获取或设置应用程序服务提供者
        public IServiceProvider ApplicationServices { get; set; }
    
        // 获取属性字典，用于存储共享数据
        public IDictionary<string, object> Properties { get; } = new Dictionary<string, object>();
    
        // 添加中间件到管道中
        public IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware)
        {
            _components.Add(middleware);
            return this;
        }
    
        // 构建最终的请求处理管道
        public RequestDelegate Build()
        {
            // 默认的请求处理程序，返回 404 状态码
            RequestDelegate app = context =>
            {
                context.Response.StatusCode = 404;
                return Task.CompletedTask;
            };
    
            // 反向遍历中间件组件列表，构建嵌套的请求处理管道
            foreach (var component in _components.Reverse())
            {
                app = component(app);
            }
    
            return app;
        }
    }
    

* * *

### 5\. 创建中间件

我们创建一个简单的日志收集中间件来展示如何使用 `**ApplicationBuilder**` ：

    public class CustomizeMiddleware
    {
        private readonly RequestDelegate _next;
    
        // 构造函数，接受下一个中间件的委托
        public CustomizeMiddleware(RequestDelegate next)
        {
            _next = next;
        }
    
        // 中间件的请求处理方法
        public async Task Invoke(HttpContext context)
        {
            Console.WriteLine("自定义中间件: Before");
            await _next(context); // 调用下一个中间件
            Console.WriteLine("自定义中间件: After");
        }
    }
    

* * *

### 6\. 使用 `ApplicationBuilder` 构建管道

    public class Program
    {
        public static void Main(string[] args)
        {
            // 创建 ApplicationBuilder 实例
            var builder = new ApplicationBuilder();
    
            // 添加 CustomizeMiddleware 到管道中
            builder.Use(next => new CustomizeMiddleware(next).Invoke);
    
            // 添加内联中间件到管道中
            builder.Use(next => async context =>
            {
                Console.WriteLine("内联中间件: Before");
                await next(context); // 调用下一个中间件
                Console.WriteLine("内联中间件: After");
            });
    
            // 构建最终的请求处理管道
            var app = builder.Build();
    
            // 创建一个 HttpContext 实例
            var context = new DefaultHttpContext();
    
            // 执行管道
            app(context).Wait();
        }
    }
    

输入结果为：

![](https://fastly.jsdelivr.net/gh/bucketio/img18@main/2025/01/02/1735813739984-7368e6e3-3604-46a9-a177-67f85b5d4a68.png "null")

* * *

### 7.总结

.NET Core 管道的底层实现是基于委托链的机制，每个中间件都是一个 `RequestDelegate`，通过链式调用来处理 HTTP 请求和响应。管道的构建过程通过 `IApplicationBuilder` 接口完成，中间件的添加顺序决定了管道的执行顺序。通过理解管道的底层实现，可以更好地掌握 .NET Core 的请求处理机制，并能够灵活地配置和扩展管道。  
![](https://img2024.cnblogs.com/blog/2063798/202501/2063798-20250102183722859-1921801243.png)