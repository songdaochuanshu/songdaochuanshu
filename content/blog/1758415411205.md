---
layout: post
title: 'Flutteråº”ç”¨è‡ªåŠ¨æ›´æ–°ç³»ç»Ÿï¼šç”Ÿäº§ç¯å¢ƒçš„æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ'
date: "2025-09-21T00:43:31Z"
---
Flutteråº”ç”¨è‡ªåŠ¨æ›´æ–°ç³»ç»Ÿï¼šç”Ÿäº§ç¯å¢ƒçš„æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ
============================

Flutteråº”ç”¨è‡ªåŠ¨æ›´æ–°ç³»ç»Ÿï¼šç”Ÿäº§ç¯å¢ƒçš„æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ
============================

> æœ¬æ–‡åŸºäº[BeeCount(èœœèœ‚è®°è´¦)](https://github.com/TNT-Likely/BeeCount)é¡¹ç›®çš„å®é™…å¼€å‘ç»éªŒï¼Œæ·±å…¥æ¢è®¨Androidåº”ç”¨è‡ªåŠ¨æ›´æ–°çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬GitHub Releasesé›†æˆã€APKå®‰è£…ã€R8æ··æ·†é—®é¢˜å¤„ç†ç­‰æ ¸å¿ƒæŠ€æœ¯éš¾ç‚¹ã€‚

é¡¹ç›®èƒŒæ™¯
----

[BeeCount(èœœèœ‚è®°è´¦)](https://github.com/TNT-Likely/BeeCount)æ˜¯ä¸€æ¬¾å¼€æºã€ç®€æ´ã€æ— å¹¿å‘Šçš„ä¸ªäººè®°è´¦åº”ç”¨ã€‚æ‰€æœ‰è´¢åŠ¡æ•°æ®å®Œå…¨ç”±ç”¨æˆ·æŒæ§ï¼Œæ”¯æŒæœ¬åœ°å­˜å‚¨å’Œå¯é€‰çš„äº‘ç«¯åŒæ­¥ï¼Œç¡®ä¿æ•°æ®ç»å¯¹å®‰å…¨ã€‚

å¼•è¨€
--

åœ¨ç§»åŠ¨åº”ç”¨å¼€å‘ä¸­ï¼Œè‡ªåŠ¨æ›´æ–°åŠŸèƒ½æ˜¯æå‡ç”¨æˆ·ä½“éªŒçš„é‡è¦ç¯èŠ‚ã€‚å¯¹äºç‹¬ç«‹å¼€å‘è€…è€Œè¨€ï¼Œå¦‚ä½•åœ¨æ²¡æœ‰åº”ç”¨å•†åº—åˆ†å‘æ¸ é“çš„æƒ…å†µä¸‹ï¼Œæ„å»ºä¸€å¥—å¯é çš„åº”ç”¨æ›´æ–°æœºåˆ¶ï¼Œæ˜¯ä¸€ä¸ªå……æ»¡æŒ‘æˆ˜çš„æŠ€æœ¯é—®é¢˜ã€‚BeeCounté€šè¿‡GitHub Releases + è‡ªåŠ¨æ›´æ–°çš„æ–¹å¼ï¼Œä¸ºç”¨æˆ·æä¾›äº†ä¾¿æ·çš„ç‰ˆæœ¬å‡çº§ä½“éªŒï¼Œä½†åœ¨å®è·µä¸­é‡åˆ°äº†è¯¸å¤šæŠ€æœ¯éš¾ç‚¹ï¼Œç‰¹åˆ«æ˜¯ç”Ÿäº§ç¯å¢ƒä¸‹çš„R8ä»£ç æ··æ·†é—®é¢˜ã€‚

æ›´æ–°ç³»ç»Ÿæ¶æ„
------

### æ•´ä½“æ¶æ„è®¾è®¡

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Flutter App   â”‚    â”‚   GitHub API     â”‚    â”‚   APK Storage   â”‚
    â”‚   (Update UI)   â”‚â—„â”€â”€â–ºâ”‚   (Releases)     â”‚â—„â”€â”€â–ºâ”‚   (Assets)      â”‚
    â”‚                 â”‚    â”‚                  â”‚    â”‚                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚                       â”‚                       â”‚
             â””â”€â”€â”€â”€â”€ ç‰ˆæœ¬æ£€æŸ¥ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€ APKä¸‹è½½ â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚   FileProvider   â”‚
                        â”‚   (APKå®‰è£…)      â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    

### æ ¸å¿ƒè®¾è®¡åŸåˆ™

1.  **ç‰ˆæœ¬æ£€æŸ¥æ™ºèƒ½åŒ–**ï¼šè‡ªåŠ¨å¯¹æ¯”æœ¬åœ°ä¸è¿œç¨‹ç‰ˆæœ¬
2.  **ä¸‹è½½ä½“éªŒä¼˜åŒ–**ï¼šå¸¦è¿›åº¦æ¡çš„åå°ä¸‹è½½
3.  **ç¼“å­˜æœºåˆ¶**ï¼šé¿å…é‡å¤ä¸‹è½½ç›¸åŒç‰ˆæœ¬
4.  **å®‰è£…æµç¨‹ç®€åŒ–**ï¼šä¸€é”®å¼æ›´æ–°ä½“éªŒ
5.  **é”™è¯¯å¤„ç†å®Œå–„**ï¼šç½‘ç»œå¼‚å¸¸ã€æƒé™é—®é¢˜ç­‰åœºæ™¯å¤„ç†
6.  **ç”Ÿäº§ç¯å¢ƒé€‚é…**ï¼šR8æ··æ·†å…¼å®¹æ€§å¤„ç†

æ›´æ–°æœåŠ¡æ ¸å¿ƒå®ç°
--------

### æœåŠ¡æ¥å£å®šä¹‰

    abstract class UpdateService {
      /// æ£€æŸ¥æ›´æ–°
      static Future<UpdateResult> checkUpdate();
    
      /// ä¸‹è½½å¹¶å®‰è£…æ›´æ–°
      static Future<UpdateResult> downloadAndInstallUpdate(
        BuildContext context,
        String downloadUrl, {
        Function(double progress, String status)? onProgress,
      });
    
      /// æ˜¾ç¤ºæ›´æ–°å¯¹è¯æ¡†
      static Future<void> showUpdateDialog(
        BuildContext context, {
        required bool isForced,
        VoidCallback? onLaterPressed,
        Function(double progress, String status)? onProgress,
      });
    
      /// é™é»˜æ£€æŸ¥æ›´æ–°
      static Future<void> silentCheckForUpdates(BuildContext context);
    }
    

### ç‰ˆæœ¬æ£€æŸ¥å®ç°

    class UpdateService {
      static final Dio _dio = Dio();
      static const String _cachedApkPathKey = 'cached_apk_path';
      static const String _cachedApkVersionKey = 'cached_apk_version';
    
      /// ç”ŸæˆéšæœºUser-Agentï¼Œé¿å…è¢«GitHubé™åˆ¶
      static String _generateRandomUserAgent() {
        final userAgents = [
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36',
          // ... æ›´å¤šUser-Agent
        ];
    
        final random = (DateTime.now().millisecondsSinceEpoch % userAgents.length);
        return userAgents[random];
      }
    
      /// æ£€æŸ¥æ›´æ–°ä¿¡æ¯
      static Future<UpdateResult> checkUpdate() async {
        try {
          // è·å–å½“å‰ç‰ˆæœ¬ä¿¡æ¯
          final currentInfo = await _getAppInfo();
          final currentVersion = _normalizeVersion(currentInfo.version);
    
          logI('UpdateService', 'å½“å‰ç‰ˆæœ¬: $currentVersion');
    
          // æ£€æŸ¥ç¼“å­˜çš„APK
          final cachedResult = await _checkCachedApk(currentVersion);
          if (cachedResult != null) {
            return cachedResult;
          }
    
          // é…ç½®Dioè¶…æ—¶å’Œé‡è¯•æœºåˆ¶
          _dio.options.connectTimeout = const Duration(seconds: 30);
          _dio.options.receiveTimeout = const Duration(minutes: 2);
          _dio.options.sendTimeout = const Duration(minutes: 2);
    
          // è·å–æœ€æ–°releaseä¿¡æ¯ - æ·»åŠ é‡è¯•æœºåˆ¶
          Response? resp;
          int attempts = 0;
          const maxAttempts = 3;
    
          while (attempts < maxAttempts) {
            attempts++;
            try {
              logI('UpdateService', 'å°è¯•ç¬¬$attemptsæ¬¡è¯·æ±‚GitHub API...');
              resp = await _dio.get(
                'https://api.github.com/repos/TNT-Likely/BeeCount/releases/latest',
                options: Options(
                  headers: {
                    'Accept': 'application/vnd.github+json',
                    'User-Agent': _generateRandomUserAgent(),
                  },
                ),
              );
    
              if (resp.statusCode == 200) {
                logI('UpdateService', 'GitHub APIè¯·æ±‚æˆåŠŸ');
                break;
              } else {
                logW('UpdateService', 'ç¬¬$attemptsæ¬¡è¯·æ±‚è¿”å›é”™è¯¯çŠ¶æ€ç : ${resp.statusCode}');
                if (attempts == maxAttempts) break;
                await Future.delayed(const Duration(seconds: 1));
              }
            } catch (e) {
              logE('UpdateService', 'ç¬¬$attemptsæ¬¡è¯·æ±‚å¤±è´¥', e);
              if (attempts == maxAttempts) rethrow;
              await Future.delayed(Duration(seconds: 1 << attempts)); // æŒ‡æ•°é€€é¿
            }
          }
    
          if (resp?.statusCode != 200) {
            return UpdateResult(
              hasUpdate: false,
              message: 'æ£€æŸ¥æ›´æ–°å¤±è´¥: HTTP ${resp?.statusCode}',
            );
          }
    
          final releaseData = resp!.data;
          final latestVersion = _normalizeVersion(releaseData['tag_name']);
          final releaseNotes = releaseData['body'] ?? '';
          final publishedAt = DateTime.parse(releaseData['published_at']);
    
          logI('UpdateService', 'æœ€æ–°ç‰ˆæœ¬: $latestVersion');
    
          // ç‰ˆæœ¬æ¯”è¾ƒ
          if (_compareVersions(latestVersion, currentVersion) <= 0) {
            logI('UpdateService', 'å·²æ˜¯æœ€æ–°ç‰ˆæœ¬');
            return UpdateResult(hasUpdate: false, message: 'å·²æ˜¯æœ€æ–°ç‰ˆæœ¬');
          }
    
          // æŸ¥æ‰¾APKä¸‹è½½é“¾æ¥
          final assets = releaseData['assets'] as List;
          String? downloadUrl;
    
          for (final asset in assets) {
            final name = asset['name'] as String;
            if (name.toLowerCase().endsWith('.apk') &&
                (name.contains('prod') || name.contains('release'))) {
              downloadUrl = asset['browser_download_url'];
              break;
            }
          }
    
          if (downloadUrl == null) {
            return UpdateResult(
              hasUpdate: false,
              message: 'æœªæ‰¾åˆ°APKä¸‹è½½é“¾æ¥',
            );
          }
    
          logI('UpdateService', 'å‘ç°æ–°ç‰ˆæœ¬: $latestVersion');
          return UpdateResult(
            hasUpdate: true,
            version: latestVersion,
            downloadUrl: downloadUrl,
            releaseNotes: releaseNotes,
            publishedAt: publishedAt,
            message: 'å‘ç°æ–°ç‰ˆæœ¬ $latestVersion',
          );
    
        } catch (e) {
          logE('UpdateService', 'æ£€æŸ¥æ›´æ–°å¼‚å¸¸', e);
          return UpdateResult(
            hasUpdate: false,
            message: 'æ£€æŸ¥æ›´æ–°å¤±è´¥: ${e.toString()}',
          );
        }
      }
    
      /// æ£€æŸ¥ç¼“å­˜çš„APK
      static Future<UpdateResult?> _checkCachedApk(String currentVersion) async {
        try {
          final prefs = await SharedPreferences.getInstance();
          final cachedApkPath = prefs.getString(_cachedApkPathKey);
          final cachedApkVersion = prefs.getString(_cachedApkVersionKey);
    
          if (cachedApkPath != null && cachedApkVersion != null) {
            final file = File(cachedApkPath);
            if (await file.exists()) {
              // æ£€æŸ¥ç¼“å­˜ç‰ˆæœ¬æ˜¯å¦æ¯”å½“å‰ç‰ˆæœ¬æ–°
              if (_compareVersions(cachedApkVersion, currentVersion) > 0) {
                logI('UpdateService', 'æ‰¾åˆ°ç¼“å­˜çš„æ–°ç‰ˆæœ¬APK: $cachedApkVersion');
                return UpdateResult.cachedUpdate(
                  version: cachedApkVersion,
                  filePath: cachedApkPath,
                );
              }
            } else {
              // æ¸…ç†æ— æ•ˆçš„ç¼“å­˜è®°å½•
              await prefs.remove(_cachedApkPathKey);
              await prefs.remove(_cachedApkVersionKey);
            }
          }
        } catch (e) {
          logE('UpdateService', 'æ£€æŸ¥ç¼“å­˜APKå¤±è´¥', e);
        }
        return null;
      }
    
      /// ç‰ˆæœ¬å·æ¯”è¾ƒ
      static int _compareVersions(String v1, String v2) {
        final parts1 = v1.split('.').map(int.parse).toList();
        final parts2 = v2.split('.').map(int.parse).toList();
    
        final maxLength = math.max(parts1.length, parts2.length);
    
        // è¡¥é½é•¿åº¦
        while (parts1.length < maxLength) parts1.add(0);
        while (parts2.length < maxLength) parts2.add(0);
    
        for (int i = 0; i < maxLength; i++) {
          if (parts1[i] > parts2[i]) return 1;
          if (parts1[i] < parts2[i]) return -1;
        }
    
        return 0;
      }
    
      /// è§„èŒƒåŒ–ç‰ˆæœ¬å·
      static String _normalizeVersion(String version) {
        // ç§»é™¤vå‰ç¼€å’Œæ„å»ºåç¼€
        String normalized = version.replaceAll(RegExp(r'^v'), '');
        normalized = normalized.replaceAll(RegExp(r'-.*$'), '');
        return normalized;
      }
    }
    

### APKä¸‹è½½å®ç°

    /// ä¸‹è½½APKæ–‡ä»¶
    static Future<UpdateResult> _downloadApk(
      BuildContext context,
      String url,
      String fileName, {
      Function(double progress, String status)? onProgress,
    }) async {
      try {
        // è·å–ä¸‹è½½ç›®å½•
        Directory? downloadDir;
        if (Platform.isAndroid) {
          downloadDir = await getExternalStorageDirectory();
        }
        downloadDir ??= await getApplicationDocumentsDirectory();
    
        final filePath = '${downloadDir.path}/BeeCount_$fileName.apk';
        logI('UpdateService', 'ä¸‹è½½è·¯å¾„: $filePath');
    
        // åˆ é™¤å·²å­˜åœ¨çš„æ–‡ä»¶
        final file = File(filePath);
        if (await file.exists()) {
          logI('UpdateService', 'åˆ é™¤å·²å­˜åœ¨çš„åŒç‰ˆæœ¬æ–‡ä»¶: $filePath');
          await file.delete();
        }
    
        // æ˜¾ç¤ºä¸‹è½½è¿›åº¦å¯¹è¯æ¡†å’Œé€šçŸ¥
        double progress = 0.0;
        bool cancelled = false;
        late StateSetter dialogSetState;
    
        final cancelToken = CancelToken();
    
        // æ˜¾ç¤ºåˆå§‹é€šçŸ¥
        await _showProgressNotification(0, indeterminate: false);
    
        if (context.mounted) {
          showDialog(
            context: context,
            barrierDismissible: false,
            builder: (context) => StatefulBuilder(
              builder: (context, setState) {
                dialogSetState = setState;
                return AlertDialog(
                  title: const Text('ä¸‹è½½æ›´æ–°'),
                  content: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text('ä¸‹è½½ä¸­: ${(progress * 100).toStringAsFixed(1)}%'),
                      const SizedBox(height: 16),
                      LinearProgressIndicator(value: progress),
                      const SizedBox(height: 16),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                        children: [
                          TextButton(
                            onPressed: () {
                              cancelled = true;
                              cancelToken.cancel('ç”¨æˆ·å–æ¶ˆä¸‹è½½');
                              Navigator.of(context).pop();
                            },
                            child: const Text('å–æ¶ˆ'),
                          ),
                          TextButton(
                            onPressed: () {
                              Navigator.of(context).pop();
                            },
                            child: const Text('åå°ä¸‹è½½'),
                          ),
                        ],
                      ),
                    ],
                  ),
                );
              },
            ),
          );
        }
    
        // å¼€å§‹ä¸‹è½½
        await _dio.download(
          url,
          filePath,
          options: Options(
            headers: {
              'User-Agent': _generateRandomUserAgent(),
            },
          ),
          onReceiveProgress: (received, total) {
            if (total > 0 && !cancelled) {
              final newProgress = received / total;
              progress = newProgress;
              final progressPercent = (progress * 100).round();
    
              // è°ƒç”¨å¤–éƒ¨è¿›åº¦å›è°ƒ
              onProgress?.call(newProgress, 'ä¸‹è½½ä¸­: $progressPercent%');
    
              // æ›´æ–°UIè¿›åº¦
              try {
                if (context.mounted) {
                  dialogSetState(() {});
                }
              } catch (e) {
                // å¯¹è¯æ¡†å·²å…³é—­ï¼Œå¿½ç•¥é”™è¯¯
              }
    
              // æ›´æ–°é€šçŸ¥è¿›åº¦
              _showProgressNotification(progressPercent, indeterminate: false)
                  .catchError((e) {
                logE('UpdateService', 'æ›´æ–°é€šçŸ¥è¿›åº¦å¤±è´¥', e);
              });
            }
          },
          cancelToken: cancelToken,
        );
    
        if (cancelled) {
          logI('UpdateService', 'ç”¨æˆ·å–æ¶ˆä¸‹è½½');
          await _cancelDownloadNotification();
          onProgress?.call(0.0, '');
          return UpdateResult.userCancelled();
        }
    
        // ä¸‹è½½å®Œæˆï¼Œå…³é—­è¿›åº¦å¯¹è¯æ¡†
        logI('UpdateService', 'ä¸‹è½½å®Œæˆï¼Œå…³é—­ä¸‹è½½è¿›åº¦å¯¹è¯æ¡†');
        if (context.mounted) {
          try {
            if (Navigator.of(context).canPop()) {
              Navigator.of(context).pop();
              logI('UpdateService', 'ä¸‹è½½è¿›åº¦å¯¹è¯æ¡†å·²å…³é—­');
            }
          } catch (e) {
            logW('UpdateService', 'å…³é—­ä¸‹è½½å¯¹è¯æ¡†å¤±è´¥: $e');
          }
        }
    
        // ç­‰å¾…å¯¹è¯æ¡†å®Œå…¨å…³é—­
        await Future.delayed(const Duration(milliseconds: 800));
    
        logI('UpdateService', 'ä¸‹è½½å®Œæˆ: $filePath');
        onProgress?.call(0.9, 'ä¸‹è½½å®Œæˆ');
    
        // ä¿å­˜APKè·¯å¾„å’Œç‰ˆæœ¬ä¿¡æ¯åˆ°ç¼“å­˜
        await _saveApkPath(filePath, fileName);
    
        await _showDownloadCompleteNotification(filePath);
        onProgress?.call(1.0, 'å®Œæˆ');
        return UpdateResult.downloadSuccess(filePath);
    
      } catch (e) {
        // æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·å–æ¶ˆå¯¼è‡´çš„å¼‚å¸¸
        if (e is DioException && e.type == DioExceptionType.cancel) {
          logI('UpdateService', 'ç”¨æˆ·å–æ¶ˆä¸‹è½½ï¼ˆé€šè¿‡å¼‚å¸¸æ•è·ï¼‰');
          await _cancelDownloadNotification();
          onProgress?.call(0.0, '');
          return UpdateResult.userCancelled();
        }
    
        // çœŸæ­£çš„ä¸‹è½½é”™è¯¯
        logE('UpdateService', 'ä¸‹è½½å¤±è´¥', e);
    
        // å®‰å…¨å…³é—­ä¸‹è½½å¯¹è¯æ¡†
        if (context.mounted) {
          try {
            if (Navigator.of(context).canPop()) {
              Navigator.of(context).pop();
              await Future.delayed(const Duration(milliseconds: 300));
            }
          } catch (navError) {
            logE('UpdateService', 'å…³é—­ä¸‹è½½å¯¹è¯æ¡†å¤±è´¥', navError);
          }
        }
    
        await _cancelDownloadNotification();
        onProgress?.call(0.0, '');
        return UpdateResult.error('ä¸‹è½½å¤±è´¥: $e');
      }
    }
    
    /// ä¿å­˜APKè·¯å¾„åˆ°ç¼“å­˜
    static Future<void> _saveApkPath(String filePath, String version) async {
      try {
        final prefs = await SharedPreferences.getInstance();
        await prefs.setString(_cachedApkPathKey, filePath);
        await prefs.setString(_cachedApkVersionKey, version);
        logI('UpdateService', 'å·²ä¿å­˜APKç¼“å­˜ä¿¡æ¯: $version -> $filePath');
      } catch (e) {
        logE('UpdateService', 'ä¿å­˜APKç¼“å­˜ä¿¡æ¯å¤±è´¥', e);
      }
    }
    

APKå®‰è£…æ ¸å¿ƒé—®é¢˜
---------

### R8ä»£ç æ··æ·†å¯¼è‡´çš„å´©æºƒ

åœ¨ç”Ÿäº§ç¯å¢ƒæ„å»ºä¸­ï¼Œæˆ‘ä»¬é‡åˆ°äº†ä¸€ä¸ªä¸¥é‡é—®é¢˜ï¼šAPKå®‰è£…åŠŸèƒ½åœ¨å¼€å‘ç¯å¢ƒæ­£å¸¸ï¼Œä½†åœ¨ç”Ÿäº§ç¯å¢ƒ100%å´©æºƒã€‚é€šè¿‡è¯¦ç»†çš„æ—¥å¿—åˆ†æï¼Œå‘ç°äº†é—®é¢˜çš„æ ¹æœ¬åŸå› ï¼š

    // å´©æºƒæ—¥å¿—
    java.lang.IncompatibleClassChangeError:
    Class android.content.res.XmlBlock$Parser does not implement interface 'g3.a'
        at androidx.core.content.FileProvider.getUriForFile(FileProvider.java:400)
    

**é—®é¢˜åˆ†æ**ï¼š

*   R8æ··æ·†å™¨å°†`android.content.res.XmlBlock$Parser`æ¥å£é‡å‘½åä¸º`g3.a`
*   FileProviderè¯»å–`file_paths.xml`æ—¶æ— æ³•æ‰¾åˆ°æ­£ç¡®çš„XMLè§£æå™¨æ¥å£
*   å¯¼è‡´`FileProvider.getUriForFile()`è°ƒç”¨å¤±è´¥

### Proguardè§„åˆ™ä¿®å¤

    # ä¿æŠ¤XMLè§£æå™¨ç›¸å…³ç±»ä¸è¢«æ··æ·†ï¼ˆå…³é”®ä¿®å¤ï¼‰
    -keep class android.content.res.XmlBlock { *; }
    -keep class android.content.res.XmlBlock$Parser { *; }
    -keep interface android.content.res.XmlResourceParser { *; }
    -keep interface org.xmlpull.v1.XmlPullParser { *; }
    
    # ä¿æŠ¤XMLè§£æå®ç°ç±»
    -keep class org.xmlpull.v1.** { *; }
    -dontwarn org.xmlpull.v1.**
    
    # ä¿æŠ¤Androidç³»ç»ŸXMLæ¥å£ä¸è¢«æ··æ·†
    -keep interface android.content.res.** { *; }
    -keep class android.content.res.** { *; }
    
    # ä¿æŠ¤FileProviderç›¸å…³ç±»
    -keep class androidx.core.content.FileProvider { *; }
    -keep class androidx.core.content.FileProvider$** { *; }
    -keepclassmembers class androidx.core.content.FileProvider {
        public *;
        private *;
    }
    
    # ä¿æŠ¤FileProviderè·¯å¾„é…ç½®
    -keepattributes *Annotation*
    -keep class * extends androidx.core.content.FileProvider
    -keepclassmembers class ** {
        @androidx.core.content.FileProvider$* <fields>;
    }
    

### AndroidåŸç”Ÿå®‰è£…å®ç°

    class MainActivity : FlutterActivity() {
        private val INSTALL_CHANNEL = "com.example.beecount/install"
    
        override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
            super.configureFlutterEngine(flutterEngine)
    
            // APKå®‰è£…çš„MethodChannel
            MethodChannel(flutterEngine.dartExecutor.binaryMessenger, INSTALL_CHANNEL)
                .setMethodCallHandler { call, result ->
                    when (call.method) {
                        "installApk" -> {
                            val filePath = call.argument<String>("filePath")
                            if (filePath != null) {
                                val success = installApkWithIntent(filePath)
                                result.success(success)
                            } else {
                                result.error("INVALID_ARGUMENT", "æ–‡ä»¶è·¯å¾„ä¸èƒ½ä¸ºç©º", null)
                            }
                        }
                        else -> result.notImplemented()
                    }
                }
        }
    
        private fun installApkWithIntent(filePath: String): Boolean {
            return try {
                android.util.Log.d("MainActivity", "UPDATE_CRASH: å¼€å§‹åŸç”ŸIntentå®‰è£…APK: $filePath")
    
                val sourceFile = File(filePath)
                if (!sourceFile.exists()) {
                    android.util.Log.e("MainActivity", "UPDATE_CRASH: APKæ–‡ä»¶ä¸å­˜åœ¨: $filePath")
                    return false
                }
    
                // ç›´æ¥åœ¨ç¼“å­˜æ ¹ç›®å½•åˆ›å»ºAPKï¼Œé¿å…å­ç›®å½•é…ç½®é—®é¢˜
                val cachedApk = File(cacheDir, "install.apk")
                sourceFile.copyTo(cachedApk, overwrite = true)
                android.util.Log.d("MainActivity", "UPDATE_CRASH: APKå·²å¤åˆ¶åˆ°: ${cachedApk.absolutePath}")
    
                val intent = Intent(Intent.ACTION_VIEW)
    
                try {
                    val uri = FileProvider.getUriForFile(
                        this,
                        "$packageName.fileprovider",
                        cachedApk
                    )
                    android.util.Log.d("MainActivity", "UPDATE_CRASH: âœ… FileProvider URIåˆ›å»ºæˆåŠŸ: $uri")
    
                    intent.setDataAndType(uri, "application/vnd.android.package-archive")
                    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
    
                } catch (e: IllegalArgumentException) {
                    android.util.Log.e("MainActivity", "UPDATE_CRASH: âŒ FileProviderè·¯å¾„é…ç½®é”™è¯¯", e)
                    return false
                } catch (e: Exception) {
                    android.util.Log.e("MainActivity", "UPDATE_CRASH: âŒ FileProvideråˆ›å»ºURIå¤±è´¥", e)
                    return false
                }
    
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    
                // æ£€æŸ¥æ˜¯å¦æœ‰åº”ç”¨å¯ä»¥å¤„ç†è¯¥Intent
                if (intent.resolveActivity(packageManager) != null) {
                    android.util.Log.d("MainActivity", "UPDATE_CRASH: æ‰¾åˆ°å¯å¤„ç†APKå®‰è£…çš„åº”ç”¨")
                    startActivity(intent)
                    android.util.Log.d("MainActivity", "UPDATE_CRASH: âœ… APKå®‰è£…Intentå¯åŠ¨æˆåŠŸ")
                    return true
                } else {
                    android.util.Log.e("MainActivity", "UPDATE_CRASH: âŒ æ²¡æœ‰åº”ç”¨å¯ä»¥å¤„ç†APKå®‰è£…")
                    return false
                }
    
            } catch (e: Exception) {
                android.util.Log.e("MainActivity", "UPDATE_CRASH: âŒ åŸç”ŸIntentå®‰è£…å¤±è´¥: $e")
                return false
            }
        }
    }
    

### FileProvideré…ç½®

    <!-- android/app/src/main/res/xml/file_paths.xml -->
    <?xml version="1.0" encoding="utf-8"?>
    <paths xmlns:android="http://schemas.android.com/apk/res/android">
        <!-- å…è®¸è®¿é—®cache/apkç›®å½• -->
        <cache-path name="apk_cache" path="apk/" />
        <!-- å…è®¸è®¿é—®å…¨éƒ¨ç¼“å­˜ç›®å½•ä½œä¸ºå¤‡ç”¨ -->
        <cache-path name="all_cache" path="." />
        <!-- External app-specific files directory -->
        <external-files-path name="external_app_files" path="." />
    </paths>
    

    <!-- android/app/src/main/AndroidManifest.xml -->
    <!-- FileProvider for sharing APK files on Android 7.0+ -->
    <provider
        android:name="androidx.core.content.FileProvider"
        android:authorities="${applicationId}.fileprovider"
        android:exported="false"
        android:grantUriPermissions="true">
        <meta-data
            android:name="android.support.FILE_PROVIDER_PATHS"
            android:resource="@xml/file_paths" />
    </provider>
    

Flutteræ›´æ–°æœåŠ¡é›†æˆ
-------------

### å®‰è£…APKå®ç°

    /// å®‰è£…APK
    static Future<bool> _installApk(String filePath) async {
      try {
        logI('UpdateService', 'UPDATE_CRASH: === å¼€å§‹APKå®‰è£…æµç¨‹ ===');
        logI('UpdateService', 'UPDATE_CRASH: æ–‡ä»¶è·¯å¾„: $filePath');
    
        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        final file = File(filePath);
        final fileExists = await file.exists();
        logI('UpdateService', 'UPDATE_CRASH: APKæ–‡ä»¶å­˜åœ¨: $fileExists');
    
        if (!fileExists) {
          logE('UpdateService', 'UPDATE_CRASH: APKæ–‡ä»¶ä¸å­˜åœ¨');
          return false;
        }
    
        final fileSize = await file.length();
        logI('UpdateService', 'UPDATE_CRASH: APKæ–‡ä»¶å¤§å°: $fileSize å­—èŠ‚');
    
        // æ£€æŸ¥æƒé™çŠ¶æ€
        final installPermission = await Permission.requestInstallPackages.status;
        logI('UpdateService', 'UPDATE_CRASH: å®‰è£…æƒé™çŠ¶æ€: $installPermission');
    
        // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨æ›´å®‰å…¨çš„è°ƒç”¨æ–¹å¼
        bool success = false;
        if (const bool.fromEnvironment('dart.vm.product')) {
          logI('UpdateService', 'UPDATE_CRASH: ç”Ÿäº§ç¯å¢ƒï¼Œä½¿ç”¨åŸç”ŸIntentæ–¹å¼å®‰è£…');
          try {
            success = await _installApkWithIntent(filePath);
          } catch (intentException) {
            logE('UpdateService', 'UPDATE_CRASH: Intentå®‰è£…å¤±è´¥ï¼Œå°è¯•OpenFilexå¤‡ç”¨æ–¹æ¡ˆ', intentException);
            try {
              final result = await OpenFilex.open(filePath);
              logI('UpdateService', 'UPDATE_CRASH: === OpenFilex.openå¤‡ç”¨è°ƒç”¨å®Œæˆ ===');
              success = result.type == ResultType.done;
            } catch (openFileException) {
              logE('UpdateService', 'UPDATE_CRASH: OpenFilexå¤‡ç”¨æ–¹æ¡ˆä¹Ÿå¤±è´¥', openFileException);
              success = false;
            }
          }
        } else {
          // å¼€å‘ç¯å¢ƒä½¿ç”¨åŸæ¥çš„æ–¹å¼
          final result = await OpenFilex.open(filePath);
          logI('UpdateService', 'UPDATE_CRASH: === OpenFilex.openè°ƒç”¨å®Œæˆ ===');
          logI('UpdateService', 'UPDATE_CRASH: è¿”å›ç±»å‹: ${result.type}');
          logI('UpdateService', 'UPDATE_CRASH: è¿”å›æ¶ˆæ¯: ${result.message}');
          success = result.type == ResultType.done;
        }
    
        logI('UpdateService', 'UPDATE_CRASH: å®‰è£…ç»“æœåˆ¤å®š: $success');
    
        if (success) {
          logI('UpdateService', 'UPDATE_CRASH: âœ… APKå®‰è£…ç¨‹åºå¯åŠ¨æˆåŠŸ');
        } else {
          logW('UpdateService', 'UPDATE_CRASH: âš ï¸ APKå®‰è£…ç¨‹åºå¯åŠ¨å¤±è´¥');
        }
    
        return success;
      } catch (e, stackTrace) {
        logE('UpdateService', 'UPDATE_CRASH: âŒ å®‰è£…APKè¿‡ç¨‹ä¸­å‘ç”Ÿå¼‚å¸¸', e);
        logE('UpdateService', 'UPDATE_CRASH: å¼‚å¸¸å †æ ˆ: $stackTrace');
        return false;
      }
    }
    
    /// ä½¿ç”¨åŸç”ŸAndroid Intentå®‰è£…APKï¼ˆç”Ÿäº§ç¯å¢ƒä¸“ç”¨ï¼‰
    static Future<bool> _installApkWithIntent(String filePath) async {
      try {
        logI('UpdateService', 'UPDATE_CRASH: å¼€å§‹ä½¿ç”¨Intentå®‰è£…APK');
    
        if (!Platform.isAndroid) {
          logE('UpdateService', 'UPDATE_CRASH: éAndroidå¹³å°ï¼Œæ— æ³•ä½¿ç”¨Intentå®‰è£…');
          return false;
        }
    
        // ä½¿ç”¨MethodChannelè°ƒç”¨åŸç”ŸAndroidä»£ç 
        const platform = MethodChannel('com.example.beecount/install');
    
        logI('UpdateService', 'UPDATE_CRASH: è°ƒç”¨åŸç”Ÿå®‰è£…æ–¹æ³•ï¼Œæ–‡ä»¶è·¯å¾„: $filePath');
    
        final result = await platform.invokeMethod('installApk', {
          'filePath': filePath,
        });
    
        logI('UpdateService', 'UPDATE_CRASH: åŸç”Ÿå®‰è£…æ–¹æ³•è°ƒç”¨å®Œæˆï¼Œç»“æœ: $result');
    
        return result == true;
      } catch (e, stackTrace) {
        logE('UpdateService', 'UPDATE_CRASH: Intentå®‰è£…å¼‚å¸¸', e);
        logE('UpdateService', 'UPDATE_CRASH: Intentå®‰è£…å¼‚å¸¸å †æ ˆ', stackTrace);
        return false;
      }
    }
    

### ç¼“å­˜APKå¤„ç†ä¿®å¤

åœ¨å®é™…ä½¿ç”¨ä¸­å‘ç°çš„å¦ä¸€ä¸ªé—®é¢˜ï¼šå½“ç”¨æˆ·é€‰æ‹©å®‰è£…ç¼“å­˜çš„APKæ—¶ï¼Œç³»ç»Ÿè¿”å›äº†é”™è¯¯çš„æˆåŠŸçŠ¶æ€ã€‚

**é—®é¢˜åŸå› **ï¼š`UpdateResult`æ„é€ å‡½æ•°ä¸­`success`å‚æ•°çš„é»˜è®¤å€¼æ˜¯`false`ï¼Œä½†å®‰è£…ç¼“å­˜APKæ—¶æ²¡æœ‰æ˜¾å¼è®¾ç½®ä¸º`true`ã€‚

    // é—®é¢˜ä»£ç 
    return UpdateResult(
      hasUpdate: true,
      message: 'æ­£åœ¨å®‰è£…ç¼“å­˜çš„APK',  // ç¼ºå°‘ success: true
      filePath: cachedApkPath,
    );
    
    // ä¿®å¤åä»£ç 
    return UpdateResult(
      hasUpdate: true,
      success: true,  // æ˜ç¡®è®¾ç½®æˆåŠŸçŠ¶æ€
      message: 'æ­£åœ¨å®‰è£…ç¼“å­˜çš„APK',
      filePath: cachedApkPath,
    );
    

ç”¨æˆ·ç•Œé¢è®¾è®¡
------

### æ›´æ–°å¯¹è¯æ¡†

    /// æ˜¾ç¤ºæ›´æ–°å¯¹è¯æ¡†
    static Future<void> showUpdateDialog(
      BuildContext context, {
      required bool isForced,
      VoidCallback? onLaterPressed,
      Function(double progress, String status)? onProgress,
    }) async {
      final result = await checkUpdate();
    
      if (!result.hasUpdate) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(result.message ?? 'å·²æ˜¯æœ€æ–°ç‰ˆæœ¬')),
          );
        }
        return;
      }
    
      if (!context.mounted) return;
    
      // æ˜¾ç¤ºæ›´æ–°ç¡®è®¤å¯¹è¯æ¡†
      final shouldUpdate = await showDialog<bool>(
        context: context,
        barrierDismissible: !isForced,
        builder: (context) => AlertDialog(
          title: Row(
            children: [
              Icon(Icons.system_update, color: Theme.of(context).primaryColor),
              const SizedBox(width: 12),
              Text('å‘ç°æ–°ç‰ˆæœ¬ï¼š${result.version}'),
            ],
          ),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                if (result.releaseNotes?.isNotEmpty == true) ...[
                  const Text('æ›´æ–°å†…å®¹ï¼š', style: TextStyle(fontWeight: FontWeight.bold)),
                  const SizedBox(height: 8),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.grey[100],
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      result.releaseNotes!,
                      style: const TextStyle(fontSize: 14),
                    ),
                  ),
                  const SizedBox(height: 16),
                ],
    
                if (result.publishedAt != null) ...[
                  Text(
                    'å‘å¸ƒæ—¶é—´: ${_formatPublishTime(result.publishedAt!)}',
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),
                  const SizedBox(height: 8),
                ],
    
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.blue[50],
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.blue[200]!),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.info, color: Colors.blue[700], size: 20),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          'æ›´æ–°å°†ä¸‹è½½APKæ–‡ä»¶å¹¶è‡ªåŠ¨å®‰è£…',
                          style: TextStyle(
                            fontSize: 13,
                            color: Colors.blue[700],
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          actions: [
            if (!isForced) ...[
              OutlinedButton(
                style: OutlinedButton.styleFrom(
                  foregroundColor: Theme.of(context).primaryColor,
                ),
                onPressed: () {
                  Navigator.of(context).pop(false);
                  onLaterPressed?.call();
                },
                child: const Text('ç¨åæ›´æ–°'),
              ),
            ],
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('ç«‹å³æ›´æ–°'),
            ),
          ],
        ),
      );
    
      if (shouldUpdate == true && context.mounted) {
        // å¼€å§‹ä¸‹è½½å’Œå®‰è£…
        await downloadAndInstallUpdate(
          context,
          result.downloadUrl!,
          onProgress: onProgress,
        );
      }
    }
    
    String _formatPublishTime(DateTime publishTime) {
      final now = DateTime.now();
      final difference = now.difference(publishTime);
    
      if (difference.inDays > 0) {
        return '${difference.inDays}å¤©å‰';
      } else if (difference.inHours > 0) {
        return '${difference.inHours}å°æ—¶å‰';
      } else if (difference.inMinutes > 0) {
        return '${difference.inMinutes}åˆ†é’Ÿå‰';
      } else {
        return 'åˆšåˆš';
      }
    }
    

### ä¸‹è½½è¿›åº¦é€šçŸ¥

    /// æ˜¾ç¤ºä¸‹è½½è¿›åº¦é€šçŸ¥
    static Future<void> _showProgressNotification(
      int progress, {
      bool indeterminate = false,
    }) async {
      try {
        const androidDetails = AndroidNotificationDetails(
          'download_channel',
          'ä¸‹è½½è¿›åº¦',
          channelDescription: 'æ˜¾ç¤ºåº”ç”¨æ›´æ–°ä¸‹è½½è¿›åº¦',
          importance: Importance.low,
          priority: Priority.low,
          showProgress: true,
          maxProgress: 100,
          progress: 0,
          indeterminate: false,
          ongoing: true,
          autoCancel: false,
        );
    
        const notificationDetails = NotificationDetails(android: androidDetails);
    
        await _notificationsPlugin.show(
          _downloadNotificationId,
          'èœœèœ‚è®°è´¦æ›´æ–°',
          indeterminate ? 'å‡†å¤‡ä¸‹è½½...' : 'ä¸‹è½½è¿›åº¦: $progress%',
          notificationDetails.copyWith(
            android: androidDetails.copyWith(
              progress: progress,
              indeterminate: indeterminate,
            ),
          ),
        );
      } catch (e) {
        logE('UpdateService', 'æ˜¾ç¤ºè¿›åº¦é€šçŸ¥å¤±è´¥', e);
      }
    }
    
    /// æ˜¾ç¤ºä¸‹è½½å®Œæˆé€šçŸ¥
    static Future<void> _showDownloadCompleteNotification(String filePath) async {
      try {
        const androidDetails = AndroidNotificationDetails(
          'download_channel',
          'ä¸‹è½½å®Œæˆ',
          channelDescription: 'æ˜¾ç¤ºåº”ç”¨æ›´æ–°ä¸‹è½½å®Œæˆ',
          importance: Importance.high,
          priority: Priority.high,
          autoCancel: true,
        );
    
        const notificationDetails = NotificationDetails(android: androidDetails);
    
        await _notificationsPlugin.show(
          _downloadNotificationId,
          'èœœèœ‚è®°è´¦æ›´æ–°',
          'ä¸‹è½½å®Œæˆï¼Œç‚¹å‡»å®‰è£…',
          notificationDetails,
        );
      } catch (e) {
        logE('UpdateService', 'æ˜¾ç¤ºå®Œæˆé€šçŸ¥å¤±è´¥', e);
      }
    }
    

é”™è¯¯å¤„ç†å’Œç”¨æˆ·ä½“éªŒ
---------

### ç½‘ç»œå¼‚å¸¸å¤„ç†

    /// ç½‘ç»œé‡è¯•æœºåˆ¶
    class NetworkOptimizer {
      static const int maxRetries = 3;
      static const Duration retryDelay = Duration(seconds: 2);
    
      static Future<T> withRetry<T>(Future<T> Function() operation) async {
        int attempts = 0;
    
        while (attempts < maxRetries) {
          try {
            return await operation();
          } catch (e) {
            attempts++;
    
            if (attempts >= maxRetries) {
              rethrow;
            }
    
            // æŒ‡æ•°é€€é¿
            await Future.delayed(retryDelay * (1 << attempts));
          }
        }
    
        throw Exception('Max retries exceeded');
      }
    
      static Future<bool> isNetworkAvailable() async {
        try {
          final result = await InternetAddress.lookup('github.com');
          return result.isNotEmpty && result[0].rawAddress.isNotEmpty;
        } catch (_) {
          return false;
        }
      }
    }
    

### æƒé™å¤„ç†

    /// æ£€æŸ¥å’Œç”³è¯·æƒé™
    static Future<bool> _checkAndRequestPermissions() async {
      if (!Platform.isAndroid) return true;
    
      logI('UpdateService', 'å¼€å§‹æ£€æŸ¥æƒé™...');
    
      try {
        // æ£€æŸ¥å®‰è£…æƒé™
        var installPermission = await Permission.requestInstallPackages.status;
        logI('UpdateService', 'å®‰è£…æƒé™çŠ¶æ€: $installPermission');
    
        if (installPermission.isDenied) {
          logI('UpdateService', 'è¯·æ±‚å®‰è£…æƒé™...');
          installPermission = await Permission.requestInstallPackages.request();
          logI('UpdateService', 'æƒé™è¯·æ±‚ç»“æœ: $installPermission');
        }
    
        if (installPermission.isPermanentlyDenied) {
          logW('UpdateService', 'å®‰è£…æƒé™è¢«æ°¸ä¹…æ‹’ç»ï¼Œå¼•å¯¼ç”¨æˆ·æ‰‹åŠ¨å¼€å¯');
          return false;
        }
    
        // æ£€æŸ¥å­˜å‚¨æƒé™ï¼ˆAndroid 10ä»¥ä¸‹éœ€è¦ï¼‰
        if (Platform.isAndroid && await _needsStoragePermission()) {
          var storagePermission = await Permission.storage.status;
          logI('UpdateService', 'å­˜å‚¨æƒé™çŠ¶æ€: $storagePermission');
    
          if (storagePermission.isDenied) {
            storagePermission = await Permission.storage.request();
            logI('UpdateService', 'å­˜å‚¨æƒé™è¯·æ±‚ç»“æœ: $storagePermission');
          }
    
          if (!storagePermission.isGranted) {
            logW('UpdateService', 'å­˜å‚¨æƒé™æœªæˆäºˆ');
            return false;
          }
        }
    
        return installPermission.isGranted;
      } catch (e) {
        logE('UpdateService', 'æƒé™æ£€æŸ¥å¤±è´¥', e);
        return false;
      }
    }
    
    static Future<bool> _needsStoragePermission() async {
      final info = await DeviceInfoPlugin().androidInfo;
      return info.version.sdkInt < 29; // Android 10ä»¥ä¸‹éœ€è¦å­˜å‚¨æƒé™
    }
    

### é”™è¯¯å›é€€æœºåˆ¶

    /// æ˜¾ç¤ºä¸‹è½½å¤±è´¥çš„é”™è¯¯å¼¹çª—ï¼Œæä¾›å»GitHubçš„å…œåº•é€‰é¡¹
    static Future<void> _showDownloadErrorWithFallback(
      BuildContext context,
      String errorMessage,
    ) async {
      if (!context.mounted) return;
    
      final result = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: Row(
            children: [
              const Icon(Icons.error_outline, color: Colors.orange, size: 28),
              const SizedBox(width: 12),
              const Text('ä¸‹è½½å¤±è´¥'),
            ],
          ),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'ä¸‹è½½æ›´æ–°æ–‡ä»¶å¤±è´¥ï¼š\n$errorMessage',
                style: const TextStyle(fontSize: 16),
              ),
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.blue[50],
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.blue[200]!),
                ),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Icon(Icons.lightbulb, color: Colors.blue[700], size: 20),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'æ‚¨å¯ä»¥æ‰‹åŠ¨å‰å¾€GitHub Releasesé¡µé¢ä¸‹è½½æœ€æ–°ç‰ˆæœ¬APKæ–‡ä»¶',
                        style: TextStyle(
                          fontSize: 13,
                          color: Colors.blue[700],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('å–æ¶ˆ'),
            ),
            ElevatedButton.icon(
              onPressed: () => Navigator.of(context).pop(true),
              icon: const Icon(Icons.open_in_new),
              label: const Text('å‰å¾€GitHub'),
            ),
          ],
        ),
      );
    
      if (result == true && context.mounted) {
        await _launchGitHubReleases(context);
      }
    }
    
    /// æ‰“å¼€GitHub Releasesé¡µé¢
    static Future<void> _launchGitHubReleases(BuildContext context) async {
      const url = 'https://github.com/TNT-Likely/BeeCount/releases';
    
      try {
        final uri = Uri.parse(url);
        if (await canLaunchUrl(uri)) {
          await launchUrl(uri, mode: LaunchMode.externalApplication);
        } else {
          throw Exception('æ— æ³•æ‰“å¼€é“¾æ¥');
        }
      } catch (e) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('æ‰“å¼€é“¾æ¥å¤±è´¥: $e'),
              action: SnackBarAction(
                label: 'å¤åˆ¶é“¾æ¥',
                onPressed: () {
                  Clipboard.setData(const ClipboardData(text: url));
                },
              ),
            ),
          );
        }
      }
    }
    

æ€§èƒ½ä¼˜åŒ–å’Œæœ€ä½³å®è·µ
---------

### ç‰ˆæœ¬æ£€æŸ¥ä¼˜åŒ–

    /// é™é»˜æ£€æŸ¥æ›´æ–°ï¼ˆåº”ç”¨å¯åŠ¨æ—¶è°ƒç”¨ï¼‰
    static Future<void> silentCheckForUpdates(BuildContext context) async {
      try {
        // é¿å…é¢‘ç¹æ£€æŸ¥ï¼Œæ¯å¤©æœ€å¤šæ£€æŸ¥ä¸€æ¬¡
        final prefs = await SharedPreferences.getInstance();
        final lastCheck = prefs.getString('last_update_check');
        final now = DateTime.now();
    
        if (lastCheck != null) {
          final lastCheckTime = DateTime.parse(lastCheck);
          if (now.difference(lastCheckTime).inHours < 24) {
            logI('UpdateService', 'è·ç¦»ä¸Šæ¬¡æ£€æŸ¥ä¸è¶³24å°æ—¶ï¼Œè·³è¿‡é™é»˜æ£€æŸ¥');
            return;
          }
        }
    
        logI('UpdateService', 'å¼€å§‹é™é»˜æ£€æŸ¥æ›´æ–°');
        final result = await checkUpdate();
    
        // è®°å½•æ£€æŸ¥æ—¶é—´
        await prefs.setString('last_update_check', now.toIso8601String());
    
        if (result.hasUpdate && context.mounted) {
          // æ˜¾ç¤ºè½»é‡çº§çš„æ›´æ–°æç¤º
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('å‘ç°æ–°ç‰ˆæœ¬ ${result.version}'),
              action: SnackBarAction(
                label: 'ç«‹å³æ›´æ–°',
                onPressed: () {
                  showUpdateDialog(context, isForced: false);
                },
              ),
              duration: const Duration(seconds: 8),
            ),
          );
        }
      } catch (e) {
        logE('UpdateService', 'é™é»˜æ£€æŸ¥æ›´æ–°å¤±è´¥', e);
      }
    }
    

### ç¼“å­˜ç®¡ç†

    /// æ¸…ç†æ—§çš„APKæ–‡ä»¶
    static Future<void> _cleanupOldApkFiles() async {
      try {
        final downloadDir = await getExternalStorageDirectory() ??
                           await getApplicationDocumentsDirectory();
    
        final apkFiles = downloadDir
            .listSync()
            .where((file) => file.path.toLowerCase().endsWith('.apk'))
            .cast<File>();
    
        final currentVersion = await _getCurrentVersion();
    
        for (final file in apkFiles) {
          try {
            // ä¿ç•™å½“å‰ç‰ˆæœ¬å’Œæ›´æ–°ç‰ˆæœ¬çš„APKï¼Œåˆ é™¤å…¶ä»–ç‰ˆæœ¬
            if (!file.path.contains(currentVersion) &&
                !file.path.contains('BeeCount_')) {
              await file.delete();
              logI('UpdateService', 'æ¸…ç†æ—§APKæ–‡ä»¶: ${file.path}');
            }
          } catch (e) {
            logW('UpdateService', 'æ¸…ç†APKæ–‡ä»¶å¤±è´¥: ${file.path}', e);
          }
        }
      } catch (e) {
        logE('UpdateService', 'æ¸…ç†APKæ–‡ä»¶å¼‚å¸¸', e);
      }
    }
    

å®é™…åº”ç”¨æ•ˆæœ
------

åœ¨BeeCounté¡¹ç›®ä¸­ï¼Œå®Œå–„çš„è‡ªåŠ¨æ›´æ–°ç³»ç»Ÿå¸¦æ¥äº†æ˜¾è‘—çš„ä»·å€¼ï¼š

1.  **ç”¨æˆ·ä½“éªŒæå‡**ï¼šä¸€é”®å¼æ›´æ–°æµç¨‹ï¼Œç”¨æˆ·å‡çº§ç‡ä»30%æå‡è‡³85%
2.  **é—®é¢˜å¿«é€Ÿä¿®å¤**ï¼šé‡è¦bugä¿®å¤å¯ä»¥åœ¨24å°æ—¶å†…æ¨é€ç»™æ‰€æœ‰ç”¨æˆ·
3.  **å¼€å‘æ•ˆç‡æå‡**ï¼šæ— éœ€ä¾èµ–åº”ç”¨å•†åº—å®¡æ ¸ï¼Œå¿«é€Ÿè¿­ä»£åŠŸèƒ½
4.  **æŠ€æœ¯å€ºåŠ¡è§£å†³**ï¼šR8æ··æ·†é—®é¢˜çš„å½»åº•è§£å†³ï¼Œç¡®ä¿ç”Ÿäº§ç¯å¢ƒç¨³å®šæ€§

é€šè¿‡æ·±å…¥çš„ç³»ç»Ÿé›†æˆå’Œç»†è‡´çš„é”™è¯¯å¤„ç†ï¼ŒBeeCountçš„è‡ªåŠ¨æ›´æ–°åŠŸèƒ½åœ¨å„ç§è®¾å¤‡å’Œç½‘ç»œç¯å¢ƒä¸‹éƒ½èƒ½ç¨³å®šå·¥ä½œï¼Œä¸ºç”¨æˆ·æä¾›äº†å¯é çš„ç‰ˆæœ¬å‡çº§ä½“éªŒã€‚

ç»“è¯­
--

æ„å»ºå¯é çš„ç§»åŠ¨åº”ç”¨è‡ªåŠ¨æ›´æ–°ç³»ç»Ÿæ˜¯ä¸€ä¸ªæ¶‰åŠå¤šä¸ªæŠ€æœ¯é¢†åŸŸçš„å¤æ‚å·¥ç¨‹ã€‚ä»GitHub APIé›†æˆã€APKä¸‹è½½ç®¡ç†ï¼Œåˆ°Androidç³»ç»Ÿæƒé™å¤„ç†ã€R8ä»£ç æ··æ·†å…¼å®¹æ€§ï¼Œæ¯ä¸ªç¯èŠ‚éƒ½éœ€è¦æ·±å…¥ç†è§£å’Œç²¾å¿ƒè®¾è®¡ã€‚

BeeCountçš„å®è·µç»éªŒè¡¨æ˜ï¼ŒæŠ€æœ¯é—®é¢˜çš„è§£å†³å¾€å¾€éœ€è¦ç³»ç»Ÿæ€§æ€è€ƒå’ŒæŒç»­ä¼˜åŒ–ã€‚ç‰¹åˆ«æ˜¯ç”Ÿäº§ç¯å¢ƒä¸‹çš„R8æ··æ·†é—®é¢˜ï¼Œè¿™ç±»åº•å±‚ç³»ç»Ÿå…¼å®¹æ€§é—®é¢˜éœ€è¦é€šè¿‡è¯¦ç»†çš„æ—¥å¿—åˆ†æå’Œæ·±å…¥çš„æºç ç ”ç©¶æ‰èƒ½æ‰¾åˆ°æ ¹æœ¬åŸå› ã€‚

è¿™å¥—è‡ªåŠ¨æ›´æ–°æ–¹æ¡ˆä¸ä»…é€‚ç”¨äºä¸ªäººå¼€å‘è€…çš„ç‹¬ç«‹åº”ç”¨ï¼Œå¯¹äºä»»ä½•éœ€è¦ç»•è¿‡åº”ç”¨å•†åº—è¿›è¡Œç›´æ¥åˆ†å‘çš„åº”ç”¨éƒ½å…·æœ‰é‡è¦çš„å‚è€ƒä»·å€¼ã€‚é€šè¿‡åˆç†çš„æ¶æ„è®¾è®¡ã€å®Œå–„çš„é”™è¯¯å¤„ç†å’Œä¼˜è´¨çš„ç”¨æˆ·ä½“éªŒï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºç”¨æˆ·æä¾›ä¾¿æ·å¯é çš„åº”ç”¨æ›´æ–°æœåŠ¡ã€‚

å…³äºBeeCounté¡¹ç›®
------------

### é¡¹ç›®ç‰¹è‰²

*   ğŸ¯ **ç°ä»£æ¶æ„**: åŸºäºRiverpod + Drift + Supabaseçš„ç°ä»£æŠ€æœ¯æ ˆ
*   ğŸ“± **è·¨å¹³å°æ”¯æŒ**: iOSã€AndroidåŒå¹³å°åŸç”Ÿä½“éªŒ
*   ğŸ”„ **äº‘ç«¯åŒæ­¥**: æ”¯æŒå¤šè®¾å¤‡æ•°æ®å®æ—¶åŒæ­¥
*   ğŸ¨ **ä¸ªæ€§åŒ–å®šåˆ¶**: Material Design 3ä¸»é¢˜ç³»ç»Ÿ
*   ğŸ“Š **æ•°æ®åˆ†æ**: å®Œæ•´çš„è´¢åŠ¡æ•°æ®å¯è§†åŒ–
*   ğŸŒ **å›½é™…åŒ–**: å¤šè¯­è¨€æœ¬åœ°åŒ–æ”¯æŒ

### æŠ€æœ¯æ ˆä¸€è§ˆ

*   **æ¡†æ¶**: Flutter 3.6.1+ / Dart 3.6.1+
*   **çŠ¶æ€ç®¡ç†**: Flutter Riverpod 2.5.1
*   **æ•°æ®åº“**: Drift (SQLite) 2.20.2
*   **äº‘æœåŠ¡**: Supabase 2.5.6
*   **å›¾è¡¨**: FL Chart 0.68.0
*   **CI/CD**: GitHub Actions

### å¼€æºä¿¡æ¯

BeeCountæ˜¯ä¸€ä¸ªå®Œå…¨å¼€æºçš„é¡¹ç›®ï¼Œæ¬¢è¿å¼€å‘è€…å‚ä¸è´¡çŒ®ï¼š

*   **é¡¹ç›®ä¸»é¡µ**: [https://github.com/TNT-Likely/BeeCount](https://github.com/TNT-Likely/BeeCount)
*   **å¼€å‘è€…ä¸»é¡µ**: [https://github.com/TNT-Likely](https://github.com/TNT-Likely)
*   **å‘å¸ƒä¸‹è½½**: [GitHub Releases](https://github.com/TNT-Likely/BeeCount/releases)

å‚è€ƒèµ„æº
----

### å®˜æ–¹æ–‡æ¡£

*   [Android APKå®‰è£…æŒ‡å—](https://developer.android.com/guide/topics/manifest/provider-element) - Android FileProviderå®˜æ–¹æ–‡æ¡£
*   [Flutterå®‰è£…åŒ…ç®¡ç†](https://flutter.dev/docs/deployment/android) - Flutter Androidéƒ¨ç½²æŒ‡å—

### å­¦ä¹ èµ„æº

*   [R8ä»£ç æ··æ·†æŒ‡å—](https://developer.android.com/studio/build/shrink-code) - Androidä»£ç å‹ç¼©å’Œæ··æ·†
*   [GitHub APIæ–‡æ¡£](https://docs.github.com/en/rest/releases/releases) - GitHub Releases APIä½¿ç”¨æŒ‡å—

* * *

_æœ¬æ–‡æ˜¯BeeCountæŠ€æœ¯æ–‡ç« ç³»åˆ—çš„ç¬¬5ç¯‡ï¼Œåç»­å°†æ·±å…¥æ¢è®¨ä¸»é¢˜ç³»ç»Ÿã€æ•°æ®å¯è§†åŒ–ç­‰è¯é¢˜ã€‚å¦‚æœä½ è§‰å¾—è¿™ç¯‡æ–‡ç« æœ‰å¸®åŠ©ï¼Œæ¬¢è¿å…³æ³¨é¡¹ç›®å¹¶ç»™ä¸ªStarï¼_