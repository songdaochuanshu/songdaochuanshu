---
layout: post
title: 'STM32之控制变量与函数的存储位置'
date: "2026-01-25T00:52:56Z"
---
STM32之控制变量与函数的存储位置
==================

STM32 内存定位是优化系统性能、解决硬件兼容性问题的核心技巧，可解决 Cache 与 DMA 冲突、利用 ITCM/DTCM 提升访问速度、固定 DMA 缓冲区到合规的连续物理内存。

STM32之控制变量与函数的存储位置
==================

STM32 内存定位是优化系统性能、解决硬件兼容性问题的核心技巧，可解决 Cache 与 DMA 冲突、利用 ITCM/DTCM 提升访问速度、固定 DMA 缓冲区到合规的连续物理内存。

一、变量定位方法
--------

变量定位分两种方式，适配「单个变量精准定位」和「批量变量管理」场景。

### 方法 1：**attribute** + 内存地址（单个变量）

利用编译器`__attribute__((at(address)))`属性，直接绑定变量到指定地址，简单高效。

    // 示例：uint32_t数组定位到0x20001000（4字节对齐）
    __ALIGNED(4) __attribute__((at(0x20001000))) uint32_t dma_buffer[1024] = {0};
    

**注意**：

*   地址需在芯片有效内存范围，否则触发硬件故障；
*   满足数据对齐要求（char=1 字节、short=2 字节、int/float=4 字节、double=8 字节）；
*   避免与系统变量 / 栈 / 堆地址重叠（可查.map 文件确认）。

### 方法 2：**attribute** + 段名 + 分散加载文件（批量变量）

批量定位多变量时，通过「自定义段名 + 分散加载文件」实现统一管理。

#### 1\. 定义带自定义段名的变量

    // 多DMA缓冲区归类到"MY_DMA_BUFFER"段
    __attribute__((section("MY_DMA_BUFFER"))) uint32_t uart_dma_buf[512] = {0};
    __attribute__((section("MY_DMA_BUFFER"))) uint8_t i2c_dma_buf[256] = {0};
    

#### 2\. 修改分散加载文件（.sct）

    ; STM32内存定位示例 - 分散加载文件
    LR_IROM1 0x08000000 0x00020000  {      ; Flash加载区：0x08000000~0x08020000
        ER_IROM1 0x08000000 0x00020000  {  ; Flash执行区
            *.o (RESET, +First)
            *(InRoot$$Sections)
            .ANY (+RO)
            .ANY (+XO)
        }
        RW_IRAM1 0x20000000 0x00020000  {  ; 普通SRAM数据区：0x20000000~0x20020000
            .ANY (+RW +ZI)
        }
        ; 自定义DMA缓冲区段：0x20005000~0x20008000（12KB）
        RW_DMA_BUFFER 0x20005000 0x00003000  {
            *.o (MY_DMA_BUFFER)            ; 映射MY_DMA_BUFFER段到该区域
        }
    }
    

二、函数定位方法
--------

核心是将高频函数放到 ITCM 等高速内存提升执行速度，逻辑与变量类似，需映射到「执行区域」。

### 1\. 单个函数定位

通过`__attribute__((section("段名")))`标注函数，修改分散加载文件映射到 ITCM（以 STM32H7 的 ITCM=0x00000000 为例）。

#### （1）定义带段名的函数

    // PID函数归类到MY_FUNC_SECTION段
    __attribute__((section("MY_FUNC_SECTION"))) float pid_calc(float target, float current)
    {
        static float err = 0, err_last = 0;
        float kp = 1.2, ki = 0.1, kd = 0.05;
        err = target - current;
        float output = kp*err + ki*(err+err_last) + kd*(err-err_last);
        err_last = err;
        return output;
    }
    

#### （2）修改分散加载文件

    ; 含函数定位的分散加载文件
    LR_IROM1 0x08000000 0x00020000  {      ; Flash加载区
        ER_IROM1 0x08000000 0x00020000  {  ; Flash执行区
            *.o (RESET, +First)
            *(InRoot$$Sections)
            .ANY (+RO)
            .ANY (+XO)
        }
        RW_IRAM1 0x20000000 0x00020000  {  ; 普通SRAM数据区
            .ANY (+RW +ZI)
        }
        ; ITCM执行区：0x00000000~0x00010000（64KB）
        ER_ITCM 0x00000000 0x00010000  {
            *.o (MY_FUNC_SECTION)          ; 映射函数段到ITCM
        }
    }
    

### 2\. 批量函数定位

将整个.c 文件的函数定位到指定区域，两种方式：

*   编译器选项（ARMCC）：添加`--section=.text:MY_FUNC_SECTION`；
    
*   分散加载文件直接指定文件：
    
        ER_ITCM 0x00000000 0x00010000  {
            pid.o (+XO)  ; pid.c所有可执行代码放到ITCM
        }
        
    

### 3\. 验证方法

编译后打开工程`Output`文件夹的.map 文件，搜索函数名（如`pid_calc`），查看`Base Address`是否为 ITCM 起始地址（如 0x00000000 开头），确认定位成功。

三、实战技巧与注意事项
-----------

### 1\. 内存区域选择策略

内存类型

适用场景

DTCM

高频访问的全局变量（零等待周期）

ITCM

关键函数、中断服务程序

AXI SRAM

大容量 DMA 缓冲区

普通 SRAM

通用变量存储

### 2\. 缓存一致性处理

使用 Cache 时，DMA 操作需保证缓存一致性：

    // DMA发送前清理缓存
    SCB_CleanDCache_by_Addr(dma_buffer, sizeof(dma_buffer));
    
    // DMA接收后失效缓存
    SCB_InvalidateDCache_by_Addr(dma_buffer, sizeof(dma_buffer));
    

### 3\. 核心注意事项

*   地址越界：定位地址需匹配芯片内存范围，否则程序跑飞（核对芯片手册）；
*   对齐错误：函数入口地址需 4 字节对齐，否则触发 HardFault 中断；
*   Cache 一致性：Cache 区数据 / DMA 访问前需刷新缓存，避免数据错乱；
*   段冲突：自定义段勿与系统段重叠，编译溢出需调整分散加载文件地址 / 大小。

总结
--

STM32 内存定位是解决性能与兼容性问题的关键技能：

1.  变量可通过`__attribute__((at(地址)))`（单个）或段名 + 分散加载文件（批量）定位；
2.  函数需标注自定义段名，映射到 ITCM 等高速内存，通过.map 文件验证；
3.  需规避地址越界、对齐错误等问题，合理选择内存区域并处理缓存一致性。

掌握该技术可显著提升 STM32 系统性能与可靠性，是嵌入式开发者进阶的必备技能。