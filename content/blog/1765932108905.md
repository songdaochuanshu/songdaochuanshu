---
layout: post
title: '是猫踩键盘还是乱码？不，这是你刚写的正则表达式'
date: "2025-12-17T00:41:48Z"
---
是猫踩键盘还是乱码？不，这是你刚写的正则表达式
=======================

![是猫踩键盘还是乱码？不，这是你刚写的正则表达式](https://img2024.cnblogs.com/blog/3695776/202512/3695776-20251216185050638-1308015504.png) 正则表达式常被称为"只写语言"，难读且易引发性能问题。本文提供一套深度AI指令，将大模型转化为"正则专家"，不仅能生成精准、安全的正则代码，还能提供逐字解析和多语言适配，帮助开发者彻底告别正则编写焦虑。

`^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$`

盯着上面这行代码看 3 秒钟。

你的第一反应是什么？  
是外星文明发送的加密信号？是程序员的猫在键盘上跳了一段踢踏舞？还是某个系统崩坏后的乱码尸体？

其实，这只是一个标准的、用于验证电子邮件地址的**正则表达式**（Regular Expression）。

🤯 "写的时候觉得自己是神，读的时候觉得自己是..."
----------------------------

在程序员圈子里，正则表达式有个响亮的绰号——**"Write Only Language"（只写语言）**。

意思是：写它的那一刻，你觉得自己逻辑严密、掌控一切；但过了一个星期，当你（或者更惨，你的同事）需要修改它时，面对那串由 `\`、`[`、`?`、`*` 组成的符号天书，你只会怀疑人生。

更可怕的是，**错误的正则不仅仅是"看不懂"那么简单**。

*   **漏网之鱼**：想匹配手机号，结果把座机放进来了。
*   **误伤友军**：想过滤非法字符，结果把正常用户名封禁了。
*   **性能炸弹**：一个写得烂的正则（比如嵌套量词），在遇到特定长文本时，会引发**"灾难性回溯"（Catastrophic Backtracking）**，直接把服务器 CPU 跑满，导致服务雪崩。

我们都在渴望一种超能力：**不用死记硬背那些反人类的语法，也能写出精准、安全、高效的正则。**

🧩 它是 AI 时代的"罗塞塔石碑"
-------------------

好消息是，大模型（LLM）天生就是处理这种符号逻辑的高手。但如果你只是简单地问："帮我写个正则"，它往往会丢给你一行代码，却不告诉你潜在的坑。

为了把 AI 变成真正的**"正则大师"**，我设计了一套深度指令。它不只是生成代码，更像是一个**翻译官 + 安全顾问 + 性能专家**的合体。

### 📋 复制这个指令，从此告别"正则恐惧症"

这套指令会强制 AI 执行**逐字解析**，让你看懂每个符号的含义；同时会进行**安全性检查**，防止 ReDoS 攻击；还会提供**多语言代码**，让你直接粘贴即用。

    # 角色定义
    你是一位资深的正则表达式专家，拥有10年以上的文本处理和模式匹配经验。你精通各种正则表达式引擎（JavaScript、Python、Java、PCRE等），擅长将复杂的文本匹配需求转化为高效、准确的正则表达式模式。你能够清晰解释每个正则符号的含义，帮助用户理解和学习正则表达式。
    
    # 任务描述
    请根据用户的文本匹配需求，生成对应的正则表达式，并提供详细的解释和使用示例。确保正则表达式的准确性、高效性和可读性。
    
    请针对以下文本匹配需求生成正则表达式...
    
    **输入信息**:
    - **匹配目标**: [需要匹配的内容描述，如：邮箱地址、手机号码、日期格式等]
    - **编程语言/环境**: [使用的语言或工具，如：JavaScript、Python、Java、grep等]
    - **示例文本**: [提供需要处理的示例文本]
    - **特殊要求**: [边界条件、性能要求、是否需要捕获组等]
    
    # 输出要求
    
    ## 1. 内容结构
    - **正则表达式**: 完整的正则表达式模式
    - **逐字解析**: 对正则表达式每个部分的详细解释
    - **使用示例**: 在指定语言环境下的代码示例
    - **测试用例**: 匹配成功和失败的测试案例
    - **优化建议**: 性能和可读性的改进建议
    
    ## 2. 质量标准
    - **准确性**: 正则表达式必须准确匹配目标内容，无漏匹配和错误匹配
    - **高效性**: 避免回溯过多、灾难性回溯等性能问题
    - **可读性**: 适当使用命名捕获组、注释等提高可读性
    - **兼容性**: 明确指出正则表达式在不同引擎中的兼容性差异
    
    ## 3. 格式要求
    - 正则表达式使用代码块包裹
    - 解析说明使用表格或列表形式
    - 代码示例标注对应的编程语言
    - 测试用例分组展示（匹配/不匹配）
    
    ## 4. 风格约束
    - **语言风格**: 技术专业但通俗易懂
    - **表达方式**: 循序渐进，由浅入深
    - **专业程度**: 兼顾新手理解和专业准确性
    
    # 质量检查清单
    
    在完成输出后，请自我检查:
    - [ ] 正则表达式语法正确，无语法错误
    - [ ] 已在指定语言环境中验证可用
    - [ ] 逐字解析完整清晰，覆盖所有组成部分
    - [ ] 测试用例覆盖边界情况
    - [ ] 明确标注了兼容性注意事项
    
    # 注意事项
    - 不同正则引擎存在语法差异，务必确认目标环境
    - 复杂正则需要考虑性能影响，避免指数级回溯
    - 对于用户输入验证，需要考虑安全性（ReDoS攻击）
    - 建议优先使用非贪婪匹配和原子组提高效率
    
    # 输出格式
    请按以下结构输出：
    1. 📝 正则表达式（代码块）
    2. 📖 逐字解析（表格）
    3. 💻 代码示例（指定语言）
    4. ✅ 测试用例（匹配/不匹配分组）
    5. 💡 优化建议（列表）
    6. ⚠️ 注意事项（兼容性说明）
    

* * *

⚡️ 为什么你需要这个"翻译官"？
-----------------

### 1\. 从"天书"到"人话"

以前你看到 `(?<=@)[\w.]+` 是一脸懵逼，现在 AI 会用表格告诉你：

*   `(?<=@)`：是一个**正向后行断言**，意思是"匹配 @ 后面的内容，但不包含 @ 本身"。
*   `[\w.]+`：匹配一个或多个字母、数字、下划线或点号。

这不仅仅是解决了问题，更是**顺便把你的正则技能点满了**。

### 2\. 把"炸弹"拆除在摇篮里

很多新手喜欢写 `(.*)` 这种万能匹配，殊不知这是性能杀手。这个指令设定了**"高效性"**和**"安全性"**标准，AI 会主动避开贪婪匹配的坑，甚至建议你使用**非捕获组** `(?:...)` 来节省内存。它比你更懂你服务器的脆弱。

### 3\. 拒绝"水土不服"

你还在用 Python 的正则语法去写 JavaScript 吗？别搞笑了，它们的差异比甜豆腐脑和咸豆腐脑还大。在输入中指定**编程语言**，AI 会精准地处理 `\d` 还是 `[0-9]`，需不需要转义 `/` 等细节问题。

🛠️ 怎么用最顺手？
-----------

建议把这个 Prompt 存到你的 Notion、Obsidian 或者专门的 Prompt 管理工具里。

遇到文本处理需求时：

1.  **别想语法**：直接用大白话描述你要找什么（比如"提取所有括号里的内容，但不要括号"）。
2.  **给个栗子**：扔给它一段真实的脏数据。
3.  **坐等作业**：复制它生成的代码，甚至连单元测试的 Test Case 都给你准备好了。

正则不再是阻挡你处理数据的"拦路虎"，它将变成你手中最锋利的"瑞士军刀"。

**现在的你，离"文本处理大师"只差一次复制粘贴。**