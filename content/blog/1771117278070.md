---
layout: post
title: 'linux字符设备驱动'
date: "2026-02-15T01:01:18Z"
---
linux字符设备驱动
===========

Linux字符设备驱动中的内核函数讲解和使用实例

1.字符设备驱动相关系统函数简介
----------------

### 1.1 container\_of

/\*\*
 \* container\_of 通过一个结构体成员的指针，获取包含该成员的结构体的起始地址
 \* @ptr:        变量的指针
 \* @type:       指针指向的结构体类型
 \* @member:     结构体中的变量类型
 \*/
#define container\_of(ptr, type, member) ({              \\
    void \*\_\_mptr = (void \*)(ptr);                   \\
    BUILD\_BUG\_ON\_MSG(!\_\_same\_type(\*(ptr), ((type \*)0)->member) &&   \\
                     !\_\_same\_type(\*(ptr), void),            \\
                     "pointer type mismatch in container\_of"); \\
    ((type \*)(\_\_mptr - offsetof(type, member))); })

为了简化理解，可以将 container\_of 函数理解为如下表示

#define container\_of(ptr, type, member) \\
    ((type \*)((char \*)(ptr) - offsetof(type, member)))

该函数根据 结构体成员变量的指针，通过该变量相对于结构体的偏移，得到了该变量对应的结构体的指针。

这是一个非常灵活的用法，通过保存某个结构体变量的指针，可以通过该指针反向推出该结构体的指针。在后续案例中有详细解释。

### 1.2 register\_chrdev\_region

 register\_chrdev\_region 是 Linux 内核中用于注册字符设备编号范围的函数。该函数为驱动程序预留一段连续的设备号（主设备号 + 起始次设备号），后续将字符设备（通过  cdev\_add ）绑定到这些设备号上，函数原型如下

/\*\*
 \* first：dev\_t 类型，指定要注册的起始设备号。使用 MKDEV(major, minor) 宏生成
 \* count：需要注册的连续设备号数量（次设备号的范围）
 \* name：设备的名称，该名称会出现在 /proc/devices 文件中，用于标识该组设备号属于哪个驱动。
 \* 返回值: 成功返回0
 \*        参数无效返回     -EINVAL
 \*        设备号被占用返回 -EBUSY
\*/
int register\_chrdev\_region(dev\_t first, unsigned int count, const char \*name);

### 1.3 cdev\_init

 struct cdev 是内核表示字符设备的对象，每个字符设备驱动都需要创建 cdev 实例，并将其注册到内核

 cdev\_init  负责设置 cdev 的基本字段，为后续的 cdev\_add做准备

/\*
 \* dev：指向要初始化的 struct cdev 结构体的指针。
 \*       该结构体可以由驱动静态分配 (kmalloc) ，也可以动态分配 (cdev\_alloc)
 \* fops：指向 struct file\_operations 结构体的指针
 \*       该结构体包含了设备支持的各种操作函数（如 open、read、write、ioctl 等）
\*/
void cdev\_init(struct cdev \*cdev, const struct file\_operations \*fops)
{
    memset(cdev, 0, sizeof \*cdev);
    INIT\_LIST\_HEAD(&cdev->list);
    kobject\_init(&cdev->kobj, &ktype\_cdev\_default);
    cdev\->ops = fops;
}

### 1.4 cdev\_add

该函数建立了设备号与字符设备驱动的关联，使 VFS（虚拟文件系统）能够通过设备号找到对应的驱动程序，从而响应用户空间的打开、读写等操作

*   将 struct cdev 对象与设备号绑定，在内核的字符设备映射表中建立关联
*   将 cdev 对象加入内核的全局字符设备链表或哈希表，使 VFS 能够根据设备号找到对应的cdev 
*   激活设备：调用 cdev\_add 后，该设备便可以被用户空间访问（需要使用`mknod`关联到`/dev/mydevname`）

/\*
 \* p：指向 cdev\_init() 已经初始化的 struct cdev 对象的指针。
 \* dev：分配给该设备的起始设备号，应该与 register\_chrdev\_region() 向内核申请的设备号位置一致
 \* count：与该设备关联的次设备号数量
 \* 返回值：成功 0
          参数无效    -EINVAL
          设备号被占用 -EBUSY （理论上在分配设备号时已经检查过，但这里仍可能发生，如动态添加时竞争）
          内存不足    -ENOMEM
\*/
int cdev\_add(struct cdev \*p, dev\_t dev, unsigned count);

2\. 使用字符设备驱动实现共享内存
------------------

下面是使用字符设备驱动实现共享内存的案例，用来快速熟悉驱动函数的使用方法，代码参考书籍为Linux设备驱动详解

#include <linux/init.h>
#include <linux/errno.h>
#include <linux/mm.h>
#include <linux/sched.h>
#include <linux/module.h>
#include <linux/ioctl.h>
#include <linux/io.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

#define GLOBALMEM\_SIZE    1024
#define GLOBALMEM\_MAGIC    'M'
#define MEM\_CLEAR        \_IO(GLOBALMEM\_MAGIC, 0)

struct globalmem\_dev 
{
    // 字符设备
    struct cdev m\_cdev;
    // 共享内存
    unsigned char mem\[GLOBALMEM\_SIZE\];
};

static int globalmem\_major = 266;

// 存放两个字符设备私有数据
struct globalmem\_dev\* globalmem\_devp;

/\* user open fd \*/
static int globalmem\_open(struct inode\* inode, struct file\* filp) {
    
    struct globalmem\_dev\* dev;
    /\* 下面是一种常用的区分次设备号的方法
     \* 通过 globalmem\_init 初始化时传入不同的 cdev 指针实现区分 \*/
    // inode 中保存的 i\_cdev 指针是 globalmem\_init 函数中传入的，globalmem\_dev 结构体变量 m\_cdev 的指针
    // 所以通过 inode->i\_cdev 指针，即 m\_cdev 成员变量的指针，可以找到其对应的结构体指针
    dev = container\_of(inode->i\_cdev, struct globalmem\_dev, m\_cdev);

    // 将设备结构体指针传给文件私有数据指针，提供给其他函数调用时使用
    filp->private\_data = dev;
    return 0;
}

/\* user release fd\*/
static int globalmem\_release(struct inode\* inode, struct file\* filp) {
    return 0;
}

/\* user read fd \*/
static ssize\_t globalmem\_read(struct file\* filp, char \_\_user\* buf, size\_t count, loff\_t\* ppos) {
    unsigned long p = \*ppos;
    // 获得设备结构体的指针（这是通过open函数传入的指针，实现不同次设备使用不同的共享内存）
    struct globalmem\_dev\* dev = filp->private\_data;    


    if(p >= GLOBALMEM\_SIZE)
        return 0;
    if(count > GLOBALMEM\_SIZE - p)
        count \= GLOBALMEM\_SIZE - p;
    
    copy\_to\_user(buf, (void\*)(dev->mem + p), count);
    \*ppos = p + count;

    return count;
}

/\* user write fd \*/ 
static ssize\_t globalmem\_write(struct file\* filp, const char \_\_user\* buf, size\_t count, loff\_t\* ppos) {
    unsigned long p = \*ppos;

    // 获得设备结构体的指针
    struct globalmem\_dev\* dev = filp->private\_data;    

    if(p >= GLOBALMEM\_SIZE)
        return 0;
    if(count > GLOBALMEM\_SIZE - p)
        count \= GLOBALMEM\_SIZE - p;

    copy\_from\_user(dev\->mem + p, buf, count);
    \*ppos = p + count;
    return count;
}

/\* user lseek fd \*/
static loff\_t globalmem\_llseek(struct file\* filp, loff\_t offset, int orig) {
    loff\_t ret;
    switch(orig) {
    // 从起始位置开始移动指针
    case 0:
        if(offset < 0) {
            ret \= -EINVAL;
            break;
        }
        if((unsigned int)offset > GLOBALMEM\_SIZE) {
            ret \= -EINVAL;
            break;
        }
        filp\->f\_pos = (unsigned int)offset;
        ret \= filp->f\_pos;
        break;
    // 从当前位置开始移动指针
    case 1:
        if((filp->f\_pos + offset) > GLOBALMEM\_SIZE) {
            ret \= -EINVAL;
            break;
        }
        if((filp->f\_pos + offset) < 0) {
            ret \= -EINVAL;
            break;
        }
        filp\->f\_pos += offset;
        ret \= filp->f\_pos;
        break;
    default:
        ret \= -EINVAL;
    }
    return ret;
}

/\* user ioctl fd \*/
static int globalmem\_ioctl(struct inode\* inodep, struct file\* filp, unsigned int cmd, unsigned long arg) {
    // 获取设备结构体指针    
    struct globalmem\_dev\* dev = filp->private\_data;    
    
    switch(cmd) {
    case MEM\_CLEAR:
        memset(dev\->mem, 0, GLOBALMEM\_SIZE);
        break;
    default:
        return -EINVAL;
    }
    return 0;
}

static const struct file\_operations globalmem\_fops = {
    .owner \= THIS\_MODULE,
    .open \= globalmem\_open,
    .release \= globalmem\_release,
    .llseek \= globalmem\_llseek,
    .read \= globalmem\_read,
    .write \= globalmem\_write,
    .unlocked\_ioctl \= globalmem\_ioctl
};

/\* 设备驱动模块insmod加载函数 \*/
static int globalmem\_init(void) {
    // 向 Linux 内核中注册字符设备编号范围
    register\_chrdev\_region(MKDEV(globalmem\_major, 0), 2, "globalmem");

    // 为2个次设备以及共享内存分配内存
    globalmem\_devp = kmalloc(2 \* sizeof(struct globalmem\_dev), GFP\_KERNEL);
    memset(globalmem\_devp, 0, 2 \* sizeof(struct globalmem\_dev));
    
    // 初始化字符设备0的基本字段
    cdev\_init(&(globalmem\_devp\[0\].m\_cdev), &globalmem\_fops);
    globalmem\_devp\[0\].m\_cdev.owner = THIS\_MODULE;
    // 将主设备号globalmem\_major次设备号0，与字符设备驱动的关联
    cdev\_add(&(globalmem\_devp\[0\].m\_cdev), MKDEV(globalmem\_major, 0), 1);

    // 初始化字符设备1的基本字段
    cdev\_init(&(globalmem\_devp\[1\].m\_cdev), &globalmem\_fops);
    globalmem\_devp\[1\].m\_cdev.owner = THIS\_MODULE;
    // 将主设备号globalmem\_major次设备号1，与字符设备驱动的关联
    cdev\_add(&(globalmem\_devp\[1\].m\_cdev), MKDEV(globalmem\_major, 1), 1);
    return 0;
}

static int globalmem\_exit(void) {
    // 注销cdev
    cdev\_del(&(globalmem\_devp\[0\].m\_cdev));
    cdev\_del(&(globalmem\_devp\[1\].m\_cdev));
    // 释放设备结构体内存
    kfree(globalmem\_devp);    
    // 释放设备号
    dev\_t devno = MKDEV(globalmem\_major, 0);
    unregister\_chrdev\_region(devno, 2);
}


MODULE\_AUTHOR("cear");
MODULE\_LICENSE("GPL");

module\_param(globalmem\_major, int, S\_IRUGO);
module\_init(globalmem\_init);
module\_exit(globalmem\_exit);