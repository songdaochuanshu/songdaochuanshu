---
layout: post
title: "女朋友问我深浅copy到底是什么？"
date: "2022-03-22T15:26:55.747Z"
---
女朋友问我深浅copy到底是什么？
=================

![女朋友问我深浅copy到底是什么？](https://img2022.cnblogs.com/blog/2608072/202203/2608072-20220322210725411-967123670.png) copy中还有这么多条条道道？5分钟get！👆

深浅拷贝
====

![img](https://img1.baidu.com/it/u=2439995286,666154442&fm=253&fmt=auto&app=138&f=PNG?w=690&h=500)

**列表存放值的时候，是先申请一块内存空间，存放索引和内存地址的对应关系，其实通俗的来说列表内不存真正的值，是一种间接存放的对应关系；**

*   列表内存不可变类型的数据

![image](https://img2022.cnblogs.com/blog/2608072/202203/2608072-20220322210536510-472176403.png)

**就比如说，如果现在将L列表索引0位置的值修改为66，那么这个过程发生了什么？通俗理解为去L\[0\]去值11的路被销毁了，现在通往了值66，那么这个对应关系就修改了，再次索引出来的L\[0\]就是66**

![image](https://img2022.cnblogs.com/blog/2608072/202203/2608072-20220322210543751-1687341666.png)

**不管是一维的还是二维的道理都是如此；**

> 二维

![image](https://img2022.cnblogs.com/blog/2608072/202203/2608072-20220322210558132-2090823596.png)

浅拷贝
---

> 只拷贝了一层，后续需要结合可变与不可变类型理解来决定，
> 
> 如果一维列表内没有可变类型，其实浅拷贝的影响并不大，如果一维列表内有可变类型的元素，那么就会造成影响

    l = [11,22,['xx','yy']]
    '''l列表是二维的，列表套列表的结构'''
    
    # 浅拷贝
    new_l = [:]
    # 修改原列表
    l[2][0] = 'zz'
    print('新列表',new_l) # 新列表 [11,22,['zz','yy']]
    print('源列表',l)    # 原列表 [11,22,['zz','yy']]
    print(id(l[0]),id(l[1]),id(l[2]))   # 1627619440 1627619472 2225456877448
    print(id(new_l[0]),id(new_l[1]),id(new_l[2]))  # 1627619440 1627619472 2225456877448
    '''
    总结：不论修改原列表还是新列表，修改列表内的不可变类型元素不会对原列表或新列表造成影响，如果修改的是列表内的可变类型元素，那么原列表或新列表会随着修改而修改
    原理：拷贝对于不可变类型来说拷贝的是值，但是拷贝对于可变类型元素来说拷贝的是对应关系，可以通过查看原列表和新列表的id值来验证,id值是一样的	
    '''
    

**总结**：不论修改原列表还是新列表，修改列表内的不可变类型元素不会对原列表或新列表造成影响，**如果修改的是列表内的可变类型元素，那么原列表或新列表会随着修改而修改**

**原理**：拷贝对于不可变类型来说拷贝的是值，但是拷贝对于可变类型元素来说拷贝的是对应关系，可以通过查看原列表和新列表的id值来验证,id值是一样的

![image](https://img2022.cnblogs.com/blog/2608072/202203/2608072-20220322210611296-1675770054.png)

> 修改值发生了什么变化？
> 
> 不可变类型：任然不变
> 
> 可变类型：跟着改变

![image](https://img2022.cnblogs.com/blog/2608072/202203/2608072-20220322210628548-993163961.png)

深拷贝
---

> 深拷贝其实就是对浅拷贝不能处理的可变类型进行处理，对应关系更深一层copy；
> 
> 我们潜意识理解的拷贝，拷贝出来一份你玩你的我玩我的互不影响，深copy就做到如此；

导入：`from copy import deepcopy`

    from copy import deepcopy
    l = [11,22,['xx','yy']]
    new_l = deepcopy(l)
    print(l,id(l))  # [11, 22, ['xx', 'yy']] 1305767841288
    print(new_l,id(new_l))  # [11, 22, ['xx', 'yy']] 1305767841352
    print(id(l[0]),id(l[1]),id(l[2]))  # 1627619760 1627620112 2688776670984
    print(id(new_l[0]),id(new_l[1]),id(new_l[2]))  # 1627619760 1627620112 2688776669256
    
    '''
    列表的id值不一样就代表着这两个列表是不同的列表，两个完全不一样的对象，子列表也是一样
    '''
    '''不可变类型的id还是一样，不可变类型的id就不一样了，那么列表就相当于造了一个新的列表了'''
    

![image](https://img2022.cnblogs.com/blog/2608072/202203/2608072-20220322210637760-590460512.png)

**现在再修改哪个值都不会对原列表或新列表有影响**，**现在修改值只需修改对应关系再指向新值就可以了**

![image](https://img2022.cnblogs.com/blog/2608072/202203/2608072-20220322210645486-262609324.png)