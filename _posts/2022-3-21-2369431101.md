---
layout: post
title: "Spfa 求含负权边的最短路 + 判断是否存在负权回路"
date: "2022-03-21T10:19:49.608Z"
---
Spfa 求含负权边的最短路 + 判断是否存在负权回路
---------------------------

Posted on 2022-03-21 17:49  [ZheyuHarry](https://www.cnblogs.com/ZheyuHarry/)  阅读(0)  评论(0)  [编辑](https://i.cnblogs.com/EditPosts.aspx?postid=16035767)  [收藏](javascript:void(0))  [举报](javascript:void(0))

  在Bellman-Ford算法之后，我们总算迎来了spfa算法，其实就如同堆优化Dijkstra算法之于朴素版Dijkstra算法，spfa算法仅仅是对Bellman-Ford算法的一种优化，但是在形式上，它看起来特别像堆优化Dijkstra算法罢了！

  Bellman—Ford算法会遍历所有边并进行松弛操作，然而我们应该知道很多的更新是无用的，所以我们的优化就体现在这里，因为只有那些前一步被更新的点，它所连接的点才有被更新的意义，所以我们会将被更新的点放入一个队列中；

  注意点：

1) **st数组的作用**：判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。  
即便不使用st数组最终也没有什么关系，但是使用的好处在于可以提升效率。

  
2) **SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:**

1\] Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true后改变为false)；SPFA算法中的st数组仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。  
2\] Dijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是记录一下当前发生过更新的点。

3) ⭐️Bellman\_ford算法里最后return-1的判断条件写的是dist\[n\]>0x3f3f3f3f/2;而spfa算法写的是dist\[n\]==0x3f3f3f3f;其原因在于Bellman\_ford算法会遍历所有的边，**因此不管是不是和源点连通的边它都会得到更新**；但是SPFA算法不一样，它相当于采用了BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。

4) ⭐️ Bellman\_ford算法可以存在负权回路，**是因为其循环的次数是有限制的因此最终不会发生死循环**；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，**因此假如有负权回路请你不要用SPFA否则会死循环（然而我们可以用spfa来判断是否存在负权回路）**。

5) ⭐️由于SPFA算法是由Bellman\_ford算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为 O(nm) ，假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。(好像SPFA有点小小万能的感觉?)

6) ⭐️求负环一般使用SPFA算法，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环。

代码：

#include<bits/stdc++.h>  
#define x first  
#define y second  
#define maxn 150010

using namespace std;  
typedef pair<int, int> PII;

int h\[maxn\],e\[maxn\],w\[maxn\],ne\[maxn\],idx,n,m,dist\[maxn\];  
bool st\[maxn\];

void add(int a, int b, int c)  
{  
e\[idx\] = b; w\[idx\] = c; ne\[idx\] = h\[a\] ; h\[a\] = idx++;  
}

int spfa(){  
memset(dist,0x3f,sizeof(dist));  
queue<int> q;  
dist\[1\] = 0;  
q.push(1);  
st\[1\] = true;  
while(q.size()){  
int t = q.front();  
q.pop();  
st\[t\] = false;  
for(int i = h\[t\]; i != -1; i=ne\[i\]){  
int j = e\[i\];  
if(dist\[j\] > dist\[t\] + w\[i\]) {  
dist\[j\] = dist\[t\] + w\[i\];  
if(!st\[j\]){  
q.push(j);  
st\[j\] = true;  
}  
}  
}  
}  
return dist\[n\];  
}

int main()  
{  
memset(h,-1,sizeof(h));  
cin >> n >> m;  
for(int i = 1;i<=m;i++){  
int a,b,c;  
cin >> a >> b >> c;  
add(a, b, c);  
}  
int ans = spfa();  
if(ans == 0x3f3f3f3f) cout << "impossible";  
else cout << ans;  
return 0;  
}

接下来介绍spfa是可以用来判断是否存在负权回路的：

方法：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环

**y总原话：**

每次做一遍spfa()一定是正确的，但时间复杂度较高，可能会超时。初始时将所有点插入队列中可以按如下方式理解：  
在原图的基础上新建一个虚拟源点，从该点向其他所有点连一条权值为0的有向边。（所以dist不用 初始化为0x3f3f3f3f）那么原图有负环等价于新图有负环。此时在新图上做spfa，将虚拟源点加入队列中。然后进行spfa的第一次迭代，这时会将所有点的距离更新并将所有点插入队列中。执行到这一步，就等价于视频中的做法了。那么视频中的做法可以找到负环，等价于这次spfa可以找到负环，等价于新图有负环，等价于原图有负环。得证。

1、dist\[x\] 记录虚拟源点到x的最短距离

2、cnt\[x\] 记录当前x点到虚拟源点最短路的边数，初始每个点到虚拟源点的距离为0，只要他能再走n步，即cnt\[x\] >= n，则表示该图中一定存在负环，由于从虚拟源点到x至少经过n条边时，则说明图中至少有n + 1个点，表示一定有点是重复使用

3、若dist\[j\] > dist\[t\] + w\[i\],则表示从t点走到j点能够让权值变少，因此进行对该点j进行更新，并且对应cnt\[j\] = cnt\[t\] + 1,往前走一步

注意：该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点；

代码：

#include<bits/stdc++.h>  
#define maxn 2010  
#define maxm 10010

using namespace std;  
int h\[maxn\],e\[maxm\],ne\[maxm\],w\[maxm\],dist\[maxn\],cnt\[maxn\],idx,n,m;  
bool st\[maxn\];

void add(int a,int b ,int c){  
e\[idx\] = b; w\[idx\] = c; ne\[idx\] = h\[a\] ; h\[a\] = idx++;  
}

bool spfa()  
{  
queue<int> q;  
for(int i = 1;i<=n; i++){  
q.push(i);  
st\[i\] = true;  
}  
while(q.size()){  
int t = q.front();  
q.pop();  
st\[t\] = false;  
for(int i = h\[t\] ;i!=-1;i=ne\[i\]){  
int j = e\[i\];  
if(dist\[j\] > dist\[t\] + w\[i\]){  
dist\[j\] = dist\[t\] + w\[i\];  
cnt\[j\] = cnt\[t\] + 1;  
if(cnt\[j\]>=n) return true;  
if(!st\[j\]){  
q.push(j);  
st\[j\] = true;  
}  
  
}  
}  
}  
return false;  
}

int main()  
{  
memset(h, -1, sizeof h);  
cin >> n >> m;  
while (m -- )  
{  
int x,y,z;  
cin >> x >> y >> z;  
add(x,y,z);  
}  
if(spfa()) cout << "Yes";  
else cout << "No";  
return 0;  
}