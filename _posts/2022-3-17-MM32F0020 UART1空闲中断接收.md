---
layout: post
title: "MM32F0020 UART1空闲中断接收"
date: "2022-03-17T11:14:48.468Z"
---
MM32F0020 UART1空闲中断接收
=====================

**目录：**

1.MM32F0020简介

2.初始化MM32F0020 UART1空闲中断和NVIC中断

3.编写MM32F0020 UART1中断接收和空闲中断函数

4.编写MM32F0020 UART1发送字节和ASCII字符函数

5.编写MM32F0020 UART1处理空闲中断接收数据函数

6.MM32F0020 UART1发送UART1空闲中断接收到的数据到上位机串口助手

**提要：**

　　学习MM32F0020 UART1空闲中断接收数据，UART1产生空闲中断表示接收完一帧数据，可以通过空闲中断置标志来判断一帧数据接收完成，通过上位机串口助手发送8字节的十六进制数据：0x55,0x01,0x02,0x03,0x04,0x05,0x06,0x07；下位机MM32F0020的UART1空闲中断接收到一帧：0x55,0x01,0x02,0x03,0x04,0x05,0x06,0x07 共8字节数据后，通过UART1发送多字节函数，原样发送到串口助手显示出来。

**内容：**

**1、MM32F0020简介**：

（1）MM32F0020微控制器是基于Arm® Cortex®\-M0内核，最高工作频率可达48MHz；

　　（2）供电电压支持：2.0V - 5.5V；

　　（3）多达32KB的Flash，2KB的SRAM；

　　（4）1个I2C；

　　（5）2个UART；

　　（6）1个12位的共8通道的ADC；

　　（7）1个I2C或I2S；

　　（8）1个16位高级定时，1个16位通用定时器，1个16位基本定时器；

　　（9）1个IWDG和一个WWDG看门狗。

**2.初始化MM32F0020 UART1空闲中断和NVIC中断：**

　　MM32F0020 UART1的GPIO初始化，根据MM32F0020的DS数据手册选择PA12:UART1\_TX，PA3:UART1\_RX做为UART1的发送和接收数据的引脚，具体配置步骤，及其初始化如下所示：

（1）使能GPIOA外设时钟；

（2）配置IO管脚GPIO\_AFx复用为UART1功能；

（3）配置UARTx IO的管脚；

（4）配置GPIO的输出速度；

（5）配置IO管脚的工作模式；

（6）根据GPIOA配置的参数整体初始化GPIO各管脚的成员参数。

void Bsp\_UART1\_GPIO\_Init(void)
{
    GPIO\_InitTypeDef GPIO\_InitStruct;
    RCC\_AHBPeriphClockCmd(RCC\_AHBENR\_GPIOA, ENABLE); 
    //UART Initial set
    GPIO\_PinAFConfig(GPIOA, GPIO\_PinSource3, GPIO\_AF\_1);
    GPIO\_PinAFConfig(GPIOA, GPIO\_PinSource12, GPIO\_AF\_1);

    //UART1\_TX   GPIOA.12
    GPIO\_StructInit(&GPIO\_InitStruct);
    GPIO\_InitStruct.GPIO\_Pin \= GPIO\_Pin\_12;
    GPIO\_InitStruct.GPIO\_Speed \= GPIO\_Speed\_50MHz;
    GPIO\_InitStruct.GPIO\_Mode \= GPIO\_Mode\_AF\_PP;
    GPIO\_Init(GPIOA, &GPIO\_InitStruct);

    //UART1\_RX    GPIOA.3
    GPIO\_InitStruct.GPIO\_Pin = GPIO\_Pin\_3;
    GPIO\_InitStruct.GPIO\_Mode \= GPIO\_Mode\_IPU;
    GPIO\_Init(GPIOA, &GPIO\_InitStruct);
}

　　MM32F0020 UART1和NVIC中断优先级初始化，并使能UART1空闲中断功能，具体配置步骤，及其初始化如下所示：

（1）使能UART1外设时钟；

（2）调用之前配置的UART1GPIO初始化函数；

（3）调配置UART1通信波特率为115200；

（4）配置UART1字长为8位；

（5）配置UART1收发数据为1位停止位；

（6）配置UART1收发数据为无奇偶校验位；

（7）配置UART1允许串口收发数据；

（8）根据以上配置参数初始化UART1结构体成员；

（9）使能UART1中断接收和UART1空闲中断功能；

（10）配置UART1的NVIC中断优先级为0，并使能和初始化NVIC中断（优先级为0-3均可，参数越小优先级越高）。

　　根据以上配置参数，则UART1初始化代码如下所示：

void Bsp\_UART1\_NVIC\_Init(u32 baudrate)
{
    UART\_InitTypeDef UART\_InitStruct;
    NVIC\_InitTypeDef NVIC\_InitStruct;  
    //Enable UART1 Clock
    RCC\_APB1PeriphClockCmd(RCC\_APB1ENR\_UART1, ENABLE);
    //UART1 GPIO Init
    Bsp\_UART1\_GPIO\_Init();
    
    UART\_StructInit(&UART\_InitStruct);
    UART\_InitStruct.BaudRate \= baudrate;
    //The word length is in 8-bit data format.
    UART\_InitStruct.WordLength = UART\_WordLength\_8b;
    UART\_InitStruct.StopBits \= UART\_StopBits\_1;
    //No even check bit.
    UART\_InitStruct.Parity = UART\_Parity\_No;
    //No hardware data flow control.
    UART\_InitStruct.HWFlowControl = UART\_HWFlowControl\_None;
    UART\_InitStruct.Mode \= UART\_Mode\_Rx | UART\_Mode\_Tx;   
    UART\_Init(UART1, &UART\_InitStruct);
    //Enable UART1 RXIEN and RXIDLE
    UART\_ITConfig(UART1,UART\_IT\_RXIEN | UART\_IER\_RXIDLE, ENABLE);
    
    //UART1 NVIC
    NVIC\_InitStruct.NVIC\_IRQChannel = UART1\_IRQn;
    //UART1 Priority
    NVIC\_InitStruct.NVIC\_IRQChannelPriority = 0;
    //Enable UART1\_IRQn
    NVIC\_InitStruct.NVIC\_IRQChannelCmd = ENABLE;    
    NVIC\_Init(& NVIC\_InitStruct);   
    
    UART\_Cmd(UART1,ENABLE);
}

**3.编写MM32F0020 UART1中断接收和空闲中断函数：**

（1）定义UART1空闲中断接收和发送数据相关的的缓存，变量以及空闲中断标志，代码如下所示：

//UART1 Recv Buffer
u8 gUART1\_Rx\_Buf\[UART1\_RXD\_LEN\];      
//UART1 Recv Count
u16 gUART1\_Rx\_Cnt;  
//UART1 IDLE Flag
u8 gUART1\_IDLE\_Flag = 0;

（2）头文件声明与UART1空闲中断接收和发送相关的宏，缓存、变量以及函数声明等，如下所示：

//UART1 Baudrate
#define UART1\_BAUDRATE  (115200)
//UART1 Recv length
#define UART1\_RXD\_LEN   (200) 

//UART1 Recv Buffer
extern u8 gUART1\_Rx\_Buf\[UART1\_RXD\_LEN\];  
//UART1 Recv Count
extern u16 gUART1\_Rx\_Cnt;  
//UART1 IDLE Flag
extern u8 gUART1\_IDLE\_Flag;

//UART1 NVIC Init
void Bsp\_UART1\_NVIC\_Init(u32 baudrate);
//Process UART1 Recv Task
void Bsp\_UART1\_Recv\_Task(void);
//UART sends a byte data
void Bsp\_UART\_SendByte(UART\_TypeDef\* uart,u8 data);
//Send ASCII characters
void Bsp\_UART\_SendASCII(UART\_TypeDef\* uart,char \*str);
//UART sends multi-byte data
void Bsp\_UART\_SendBytes(UART\_TypeDef\* uart,u8 \*buf, u16 len);

（3）编写UART1中断接收数据和空闲中断函数，如下所示：

void UART1\_IRQHandler(void)
{
    u8 Recv;
    
     //Check receive status
    if(UART\_GetITStatus(UART1, UART\_IT\_RXIEN) == SET) 
    {                         
        UART\_ClearITPendingBit(UART1, UART\_IT\_RXIEN);
        
        Recv \= UART\_ReceiveData(UART1);
        
        gUART1\_Rx\_Buf\[gUART1\_Rx\_Cnt\] \= Recv;
        
        if(gUART1\_Rx\_Cnt < UART1\_RXD\_LEN-1)
        {
            gUART1\_Rx\_Cnt++;
        }
        else
        {
            gUART1\_Rx\_Cnt \= 0;
        }  
    }
    if(UART\_GetITStatus(UART1, UART\_IER\_RXIDLE) != RESET)
    {
        UART\_ClearITPendingBit(UART1,UART\_IER\_RXIDLE);
        gUART1\_IDLE\_Flag \= 1;
    }     
}

**4.编写MM32F0020 UART1发送字节和ASCII字符函数：**

（1）MM32F0020 UART1发送字节函数如下所示：

void Bsp\_UART\_SendByte(UART\_TypeDef\* uart,u8 data)
{
    UART\_SendData(uart,data);
    while(!UART\_GetFlagStatus(uart, UART\_FLAG\_TXEPT));
}

（2）MM32F0020  UART1发送多字节函数如下所示：

void Bsp\_UART\_SendBytes(UART\_TypeDef\* uart,u8 \*buf, u16 len)
{
    while(len--)
    {
        Bsp\_UART\_SendByte(uart,\*buf++);
    }
}

（3）MM32F0020  UART1发送ASCII字符串函数如下所示：

void Bsp\_UART\_SendASCII(UART\_TypeDef\* uart,char \*str)
{
    while(\*str)
    {
        Bsp\_UART\_SendByte(uart,\*str++);
    }
}

**5.编写MM32F0020 UART1处理空闲中断接收数据函数**

　　MM32F0020 UART1处理空闲中断接收到的数据函数如下所示，当上位机串口助手发送8字节的十六进制数据：0x55,0x01,0x02,0x03,0x04,0x05,0x06,0x07；下位机MM32F0020的UART1中断接收到一帧：0x55,0x01,0x02,0x03,0x04,0x05,0x06,0x07 共8字节数据后，通过UART1发送多字节函数，原样发送到串口助手。

void Bsp\_UART1\_Recv\_Task(void)
{
    //UART1 IDLE Flag
    if(gUART1\_IDLE\_Flag == 1)
    {
        gUART1\_IDLE\_Flag \= 0;
        
        if((gUART1\_Rx\_Buf\[0\] == 0x55) && (gUART1\_Rx\_Buf\[1\] == 0x01) && (gUART1\_Rx\_Buf\[2\] == 0x02) && (gUART1\_Rx\_Buf\[3\] == 0x03) && \\
            (gUART1\_Rx\_Buf\[4\] == 0x04) && (gUART1\_Rx\_Buf\[5\] == 0x05) && (gUART1\_Rx\_Buf\[6\] == 0x06) && (gUART1\_Rx\_Buf\[7\] == 0x07))
        {
            LED4\_TOGGLE();          
            Bsp\_UART\_SendBytes(UART1,gUART1\_Rx\_Buf,gUART1\_Rx\_Cnt);
        }
        gUART1\_Rx\_Cnt \= 0;
        memset(gUART1\_Rx\_Buf,0,sizeof(gUART1\_Rx\_Buf));
    }
}

**6.MM32F0020 UART1发送UART1空闲中断接收到的数据到上位机串口助手**

　　当上位机串口助手发送8字节的十六进制数据：0x55,0x01,0x02,0x03,0x04,0x05,0x06,0x07；下位机MM32F0020的UART1空闲中断接收到一帧：0x55,0x01,0x02,0x03,0x04,0x05,0x06,0x07 共8字节数据后，通过UART1发送多字节函数，原样发送到串口助手。

（1）在main函数中调用UART1 NVIC空闲中断使能初始化函数；

（2）在main函数的while(1)主循环中调用UART1处理空闲中断接收到的数据函数，循环检测UART1的空闲中断接收是否接收到上位机串口助手下发的数据，如有收到就原样发送到上位机串口助手上显示出来；

int main(void)
{
    //UART1 NVIC Init Baudrate 115200
    Bsp\_UART1\_NVIC\_Init(UART1\_BAUDRATE);
    
    while(1) 
    {
        //Process UART1 Recv Task
        Bsp\_UART1\_Recv\_Task();
    }
}

（3）上位机串口助手发送8字节16进制数据：0x55,0x01,0x02,0x03,0x04,0x05,0x06,0x07，下位机MM32F0020 UART1空闲中断接收到一帧数据后原样把接收到的数据发送到上位机上显示出来，如下图1所示：

![](https://img2022.cnblogs.com/blog/2342755/202203/2342755-20220317160034923-405640161.jpg)

　　　　　　　　　　　　　　　　图1

**总结：**

　　学习MM32F0020 UART1空闲中断接收数据，UART1产生空闲中断表示接收完一帧数据，可以通过空闲中断置标志来判断一帧数据接收完成，通过上位机串口助手发送8字节的十六进制数据：0x55,0x01,0x02,0x03,0x04,0x05,0x06,0x07；下位机MM32F0020的UART1空闲中断接收到一帧：0x55,0x01,0x02,0x03,0x04,0x05,0x06,0x07 共8字节数据后，通过UART1发送多字节函数，原样发送到串口助手显示出来。

**注意事项：**

　　（1）MM32F0020每个外设都有自己独立的时钟，需使能UART1 发送和接收引脚的GPIO时钟；

　　（2）使能UART1外设时钟；

　　（3）配置GPIOA的 PA12和PA3复用成UART1功能

　　（4）使能UART1接收中断和UART1空闲中断；

　　（5）使能UART1 NVIC中断，使能UART1；

　　（6）UART2的操作方法与UART1的方法一样，可参考以上UART1把对应的UART1参数改成UART2，使能UART2空闲中断，使能相应外设时钟即可。

Study is interesting