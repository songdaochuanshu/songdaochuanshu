---
layout: post
title: "面向对象编程(C++篇3)——析构"
date: "2022-03-16T08:59:56.263Z"
---
面向对象编程(C++篇3)——析构
=================

详细论述了C++类中析构函数的思想。

目录

*   [1\. 概述](#1-概述)
*   [2\. 详论](#2-详论)
    *   [2.1. 对象生命周期](#21-对象生命周期)
    *   [2.2. 不一定需要显式析构](#22-不一定需要显式析构)
    *   [2.3. 析构的必要性](#23-析构的必要性)
*   [3\. 总结](#3-总结)

1\. 概述
======

类的析构函数执行与构造函数相反的操作，当对象结束其生命周期，程序就会自动执行析构函数：

    class ImageEx
    {
    public:
        ImageEx()
        {
            cout << "Execute the constructor!" << endl;
        }
    
        ~ImageEx()
        {
            cout << "Execute the destructor!" << endl;
        }
    };
    
    int main()
    {
        ImageEx imageEx;
        return 0;
    }
    

那么同样的问题来了，为什么要有析构函数呢？

2\. 详论
======

2.1. 对象生命周期
-----------

在经典C++中，需要通过new/delete来手动管理动态内存。如果我们在类中申请一个动态数组，并且通过自定义的函数Release()来释放它：

    class ImageEx
    {
    public:
        ImageEx()
        {
            cout << "Execute the constructor!" << endl;
            data = new unsigned char[10];
        }
    
        ~ImageEx()
        {
            cout << "Execute the destructor!" << endl;
        }
    
        void Release()
        {
            delete[] data;
            data = nullptr;
        }
    
    private:
        unsigned char * data;
    };
    
    int main()
    {
        {
            ImageEx imageEx;
            imageEx.Release();
        }
    
        return 0;
    }
    

那么，当类对象离开作用域，结束生命周期之前，就必须显示调用一次成员函数Release()，否则就会造成内存泄漏：对象在调用析构函数之后，只会销毁数据成员data本身，而不是其指向的内存。

那么，一个合理的实现是，将成员函数Release()放入到析构函数：

    class ImageEx
    {
    public:
        ImageEx()
        {
            cout << "Execute the constructor!" << endl;
            data = new unsigned char[10];
        }
    
        ~ImageEx()
        {
            Release();
            cout << "Execute the destructor!" << endl;
        }
    
    private:
        unsigned char * data;
    
        void Release()
        {
            delete[] data;
            data = nullptr;
        }
    };
    
    int main()
    {
        {
            ImageEx imageEx;       
        }
    
        return 0;
    }
    

这样，当类对象离开作用域，结束生命周期之前，就自动通过析构函数，实现了动态数组的释放。好处是显而易见的：实现了类似于内置数据类型对象的生命周期管理，我们可以像使用内置数据类型对象一样使用类对象。这也体现了前文[《面向对象编程(C++篇1)——引言》](https://www.cnblogs.com/charlee44/p/15973143.html)中提到的设计原则：类是抽象的自定义数据类型。

2.2. 不一定需要显式析构
--------------

在一些现代高级编程语言(C#、Java、Javascript)中，已经不用去手动管理动态内存，取而代之的，是其与操作系统的中间件（.net，jvm，浏览器）的GC（垃圾回收）机制。而在现代C++中，提倡通过智能指针（std::shared\_ptr、std::unique\_ptr、std::weak\_ptr）来管理动态内存；对于动态数组，则使用标准容器std::vector则更好。在两者的内部都实现了前文提到的对象生命周期管理，在离开作用域后，通过析构函数自动释放管理的内存，无需再手动进行回收。

那么，一个显而易见的推论就出来了，如果我们在类中使用智能指针或者vector容器来替代new/delete管理动态内存，是不是就可以不用析构函数了?严格来说，是不用显式使用析构函数：

    class ImageEx
    {
    public:
        ImageEx():
            data(10)
        {
            cout << "Execute the constructor!" << endl;        
        }
    
    private:
        std::vector<unsigned char> data;
    };
    
    int main()
    {
        ImageEx imageEx;      
    
        return 0;
    }
    

实际上，并不是这个类不存在析构函数，而是编译器会为它生成一个合成的析构函数，在这个析构函数体中，什么也不用做。因为类中的动态内存，已经交由std::vector容器来管理。当类对象离开作用域调用析构函数之后，会销毁这个std::vector容器数据成员，进而触发其析构函数，释放其管理的内存。

2.3. 析构的必要性
-----------

根据上一节内容，不一定需要显式析构。因为现代C++的一些机制能够帮你自动管理动态内存。但是析构函数还是必要的，这是由于C++语言本身的性质决定的。作为C语言大部分内容的超集，需要兼容C语言手动管理内存的特性。更重要的是，现代操作系统几乎全部由C语言编写，与底层的交互不可避免的需要手动使用动态内存管理。

3\. 总结
======

所以我们就能理解了，C++这门语言的设计哲学就是就是这样：既想要C语言的高性能，也想要高级语言高度抽象的特性。如果我们必须兼容C语言底层设计，那我们最好使用析构函数释放动态内存；否则多数情况下，我们应该使用智能指针或者stl容器来管理动态内存，从而避免显示使用析构函数。

[上一篇](https://www.cnblogs.com/charlee44/p/15975527.html)  
[目录](https://www.cnblogs.com/charlee44/p/15973143.html)  
下一篇