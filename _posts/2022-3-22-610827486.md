---
layout: post
title: "『现学现忘』Docker基础 — 29、Docker容器数据卷的应用"
date: "2022-03-22T05:18:10.647Z"
---
『现学现忘』Docker基础 — 29、Docker容器数据卷的应用
==================================

目录

*   [1、验证容器和宿主机之间数据共享](#1验证容器和宿主机之间数据共享)
*   [2、容器停止退出后，主机修改后数据是否同步](#2容器停止退出后主机修改后数据是否同步)
*   [3、带只读权限的挂载数据卷](#3带只读权限的挂载数据卷)

1、验证容器和宿主机之间数据共享
----------------

通过上面的操作，接下来我们演示一下通过数据卷的挂载，实现容器和宿主机之间的数据共享。

**步骤1：在宿主机中的HostDataVolume目录中创建host.txt文件。**

    # 查看宿主机当前位置
    [root@192 HostDataVolume]# pwd
    /home/HostDataVolume
    
    # HostDataVolume目录中创建host.txt文件
    [root@192 HostDataVolume]# touch host.txt
    
    # 查看创建的文件
    [root@192 HostDataVolume]# ls -l
    总用量 0
    -rw-r--r--. 1 root root 0 3月  18 20:18 host.txt
    
    

**步骤2：在CentOS容器的ContainerDataVolume目录查看内容。**

    # 进入ContainerDataVolume目录
    [root@5f63a0fc88c5 /]# cd /home/ContainerDataVolume/
    [root@5f63a0fc88c5 ContainerDataVolume]# pwd
    /home/ContainerDataVolume
    
    # 查看ContainerDataVolume目录查看内容
    [root@5f63a0fc88c5 ContainerDataVolume]# ls -l
    total 0
    -rw-r--r--. 1 root root 0 Mar 18 12:18 host.txt
    

我们可以看到，宿主机`HostDataVolume`目录中创建的`host.txt`文件，同步到了CentOS容器的`ContainerDataVolume`目录中了。

**步骤3：在CentOS容器的ContainerDataVolume目录中创建container.txt文件。**

    # 查看容器中的当前位置
    [root@5f63a0fc88c5 ContainerDataVolume]# pwd
    /home/ContainerDataVolume
    
    # 创建container.txt文件
    [root@5f63a0fc88c5 ContainerDataVolume]# touch container.txt
    
    # 在host.txt文件中添加hello docker,说明数据卷中可以读写文件。
    [root@0115c0470f8d ContainerDataVolume]# vi host.txt 
    [root@0115c0470f8d ContainerDataVolume]# cat host.txt 
    hello docker
    
    # 查看ContainerDataVolume目录的内容
    [root@5f63a0fc88c5 ContainerDataVolume]# ls -l
    total 0
    -rw-r--r--. 1 root root 0 Mar 18 12:23 container.txt
    -rw-r--r--. 1 root root 0 Mar 18 12:18 host.txt
    

**步骤4：在宿主机的HostDataVolume目录中查看内容。**

    # 查看宿主机的位置
    [root@192 HostDataVolume]# pwd
    /home/HostDataVolume
    
    # 查看HostDataVolume目录中的内容
    [root@192 HostDataVolume]# ll
    总用量 0
    -rw-r--r--. 1 root root 0 3月  18 20:23 container.txt
    -rw-r--r--. 1 root root 0 3月  18 20:18 host.txt
    
    # 查看host.txt文件中是否有内容。
    [root@192 HostDataVolume]# cat host.txt 
    hello docker
    

我们可以看到，在CentOS容器的`ContainerDataVolume`目录中创建`container.txt`文件，同步到了宿主机的`HostDataVolume`目录中。

这就验证了，数据卷挂载实现了容器和宿主机之间数据共享。

2、容器停止退出后，主机修改后数据是否同步
---------------------

接上面练习，继续验证容器停止退出后，主机修改数据卷中的数据后，重启容器是否同步。

**步骤1：停止CentOS容器。**

    # 退出centos容器
    [root@5f63a0fc88c5 ContainerDataVolume]# exit
    exit
    
    # 当前docker中没有运行的容器
    [root@192 ~]# docker ps
    CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
    
    

**步骤2：在宿主机的/hmoe/HostDataVolume目录中创建文件和修改文件。**

    # 查看宿主机当前位置
    [root@192 HostDataVolume]# pwd
    /home/HostDataVolume
    
    # 创建文件host-02.txt，
    [root@192 HostDataVolume]# touch host-02.txt
    [root@192 HostDataVolume]# ll
    总用量 4
    -rw-r--r--. 1 root root  0 3月  18 20:23 container.txt
    -rw-r--r--. 1 root root  0 3月  18 21:07 host-02.txt
    -rw-r--r--. 1 root root 13 3月  18 21:03 host.txt
    
    # 修改container.txt文件，在文件中添加hello world
    [root@192 HostDataVolume]# vim container.txt 
    [root@192 HostDataVolume]# cat container.txt 
    hello world
    

**步骤3：重新启动CentOS容器，并查看ContainerDataVolume目录中的内容。**

    # 查看centos容器，是Exited状态
    [root@192 ~]# docker ps -l
    CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                    PORTS
    0115c0470f8d   centos    "/bin/bash"   10 minutes ago   Exited (0) 6 minutes ago
    
    # 启动centos容器
    [root@192 ~]# docker start 0115c0470f8d
    0115c0470f8d
    
    # 进入centos容器
    [root@192 ~]# docker attach 0115c0470f8d
    [root@0115c0470f8d /]# 
    
    # 进入ContainerDataVolume，查看内容
    [root@0115c0470f8d /]# cd /home/ContainerDataVolume/
    
    # 查看是否有host-02.txt
    [root@0115c0470f8d ContainerDataVolume]# ls -l
    total 8
    -rw-r--r--. 1 root root 12 Mar 18 13:08 container.txt
    -rw-r--r--. 1 root root  0 Mar 18 13:07 host-02.txt
    -rw-r--r--. 1 root root 13 Mar 18 13:03 host.txt
    
    # 查看container.txt文件中的内容
    [root@0115c0470f8d ContainerDataVolume]# cat container.txt
    hello world
    
    

我们可以看到，容器停止退出后，主机修改挂载的数据卷中的数据后，重启容器依然同步。

所以我们以后修改一些相关的配置文件，挂载了数据卷之后，只需要在本地修改即可，容器内会自动同步。

3、带只读权限的挂载数据卷
-------------

命令：`docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名或镜像ID`

说明`ro`：`read only` 只读。

还是复用之前的练习之上。

**步骤1：启动CentOS容器，加入带ro权限的挂载。**

    # 启动centos容器
    [root@192 ~]# docker run -it -v /home/HostDataVolume:/home/ContainerDataVolume:ro centos /bin/bash
    
    # 查看ContainerDataVolume文件夹中的内容
    [root@2c8d185e17b1 /]# ls /home/ContainerDataVolume/
    container.txt  host-02.txt  host.txt
    # 说明：
    # 因为启动容器之前ContainerDataVolume文件夹和里边的文件就存在
    # 在使用ContainerDataVolume目录做数据卷挂载，不会删除已经存在的文件。
    # 如果需要ContainerDataVolume目录中的文件，
    # 可以在上面启动centos容器之前，把宿主机/home/HostDataVolume中的目录文件全部删除。
    # 这样在启动容器之后，centos容器的ContainerDataVolume目录会自动同步，也就没有文件了。
    

**步骤2：在宿主机的/home/HostDataVolume目录中，创建host-03.txt文件。**

    # 查看宿主机的当前位置
    [root@192 HostDataVolume]# pwd
    /home/HostDataVolume
    
    # 创建host-03.txt文件
    [root@192 HostDataVolume]# touch host-03.txt
    
    # 查看是否创建成功host-03.txt文件
    [root@192 HostDataVolume]# ll
    总用量 8
    -rw-r--r--. 1 root root 12 3月  18 21:08 container.txt
    -rw-r--r--. 1 root root  0 3月  18 21:07 host-02.txt
    -rw-r--r--. 1 root root  0 3月  18 22:27 host-03.txt
    -rw-r--r--. 1 root root 13 3月  18 21:03 host.txt
    
    # 在host-03.txt添加内容
    [root@192 HostDataVolume]# vim host-03.txt 
    [root@192 HostDataVolume]# cat host-03.txt 
    hello world,hello docker.
    

**步骤3：在CentOS容器中查看/home/ContainerDataVolume目录中的内容。**

    # 查看ContainerDataVolume目录中的内容
    [root@2c8d185e17b1 /]# ls -l /home/ContainerDataVolume/
    total 8
    -rw-r--r--. 1 root root 12 Mar 18 13:08 container.txt
    -rw-r--r--. 1 root root  0 Mar 18 13:07 host-02.txt
    -rw-r--r--. 1 root root  0 Mar 18 14:27 host-03.txt
    -rw-r--r--. 1 root root 13 Mar 18 13:03 host.txt
    
    # 查看host-03.txt文件中的内容
    [root@2c8d185e17b1 /]# cat /home/ContainerDataVolume/host-03.txt 
    hello world,hello docker.
    

我们可以看到，宿主机上的创建的`host-03.txt`文件，同步到CentOS容器中了。

同时我们也可以查看到`host-03.txt`文件中的内容。

**步骤4：在CentOS容器的/home/ContainerDataVolume目录中，创建文件和编写内容。**

    # 进入ContainerDataVolume目录
    [root@2c8d185e17b1 /]# cd /home/ContainerDataVolume/
    [root@2c8d185e17b1 ContainerDataVolume]# pwd
    /home/ContainerDataVolume
    
    # 创建container-02.txt文件
    [root@2c8d185e17b1 ContainerDataVolume]# touch container-02.txt
    touch: cannot touch 'container-02.txt': Read-only file system
    # 我们可以看到提示，不能创建container-02.txt文件，因为是只读文件系统。
    
    # 修改container.txt文件中的内容
    [root@2c8d185e17b1 ContainerDataVolume]# cat container.txt 
    hello world
    [root@2c8d185e17b1 ContainerDataVolume]# vi container.txt 
    # 在我们编辑完成保存时，，出现如下图的提示：
    

![image](https://img2022.cnblogs.com/blog/909968/202203/909968-20220321130759620-1120047417.png)

意思是：设置了“只读”选项。对于写操作不支持。

**步骤5：使用`docker inspect`命令查看当前CentOS容器。**

    # 查看当前运行的centos容器
    [root@192 HostDataVolume]# docker ps
    CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS         PORTS   NAMES
    2c8d185e17b1   centos    "/bin/bash"   25 minutes ago   Up 25 minutes
    
    # 查看centos容器的具体数据
    [root@192 HostDataVolume]# docker inspect 2c8d185e17b1
    [
        {
            "Id": "2c8d185e17b113326ea298f34896b6469e7717fa7450eeec5138767a5bb6915f",
            "Created": "2021-03-18T14:20:33.842841276Z",
            ... # 省略
    
            "HostConfig": { # 主机配置
                "Binds": [
                    "/home/HostDataVolume:/home/ContainerDataVolume:ro"
                ], # 可以看到主机绑定的挂载上显示ro
    
            ... # 省略
            },
            "Mounts": [  # 容器挂载配置
                {
                    "Type": "bind",
                    "Source": "/home/HostDataVolume",
                    "Destination": "/home/ContainerDataVolume",
                    "Mode": "ro", # 这里标识的只读模式
                    "RW": false,     # 这里的读写权限,标识为false，
                    "Propagation": "rprivate"
                }  # "RW" 之前版本的表示为 "VolumesRW"参数
            ],
            "Config": {
                ... # 省略
    
                # 新版的Dodker把Volumes信息放到了Mounts的Json字待串里了
                "Volumes": null,
    
                ... # 省略
            },
    
            ... # 省略
        }
    ]
    

**总结：**

通过上面的演示：数据卷挂载设置`ro`（只读）权限，只允许宿主机单向的写操作，来同步到容器中。而容器中是无法在数据卷目录中做任何写操作，如创建文件或者修改文件内容等。

> 我感觉是：一个容器在启动时，会自动同步宿主机上挂载目录中的内容。（这点要记住）