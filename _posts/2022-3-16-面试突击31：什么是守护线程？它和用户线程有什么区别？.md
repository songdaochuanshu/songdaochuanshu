---
layout: post
title: "面试突击31：什么是守护线程？它和用户线程有什么区别？"
date: "2022-03-16T08:59:56.355Z"
---
面试突击31：什么是守护线程？它和用户线程有什么区别？
===========================

在 Java 语言中，线程分为两类：用户线程和守护线程，默认情况下我们创建的线程或线程池都是用户线程，所以用户线程也被称之为普通线程。

想要查看线程到底是用户线程还是守护线程，可以通过 Thread.isDaemon() 方法来判断，如果返回的结果是 true 则为守护线程，反之则为用户线程。

我们来测试一下默认情况下线程和线程池属于哪种线程类型？测试代码如下：

    import java.util.concurrent.LinkedBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    
    /**
     * 线程类型：守护线程 OR 用户线程
     */
    public class ThreadType {
        public static void main(String[] args) {
            // 创建线程
            Thread thread = new Thread(new Runnable() {
                @Override
                public void run() {
                    //...
                }
            });
            // 创建线程池
            ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 10,
                    0, TimeUnit.SECONDS, new LinkedBlockingQueue<>(100));
            threadPool.submit(new Runnable() {
                @Override
                public void run() {
                    System.out.println("ThreadPool 线程类型：" +
                            (Thread.currentThread().isDaemon() == true ? "守护线程" : "用户线程"));
                }
            });
            System.out.println("Thread 线程类型：" +
                    (thread.isDaemon() == true ? "守护线程" : "用户线程"));
            System.out.println("main 线程类型：" +
                    (Thread.currentThread().isDaemon() == true ? "守护线程" : "用户线程"));
        }
    }
    

以上程序的执行结果如下图所示：  
![image.png](https://cdn.nlark.com/yuque/0/2022/png/92791/1643250609819-5c79f7a3-a07f-4f54-834b-bf54cbc70638.png#clientId=uc3528924-f783-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=232&id=u219ee05b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=463&originWidth=2136&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68117&status=done&style=none&taskId=u2e9f2ce0-74c9-4af6-a86e-e2b4d8a9352&title=&width=1068)  
从上述结果可以看出，默认情况下创建的线程和线程池都是用户线程。

守护线程定义
------

**守护线程（Daemon Thread）也被称之为后台线程或服务线程，守护线程是为用户线程服务的，当程序中的用户线程全部执行结束之后，守护线程也会跟随结束。**  
守护线程的角色就像“服务员”，而用户线程的角色就像“顾客”，当“顾客”全部走了之后（全部执行结束），那“服务员”（守护线程）也就没有了存在的意义，所以当一个程序中的全部用户线程都结束执行之后，那么无论守护线程是否还在工作都会随着用户线程一块结束，整个程序也会随之结束运行。

创建守护线程
------

我们可以通过 Thread.setDaemon(true) 方法将线程设置为守护线程，比如以下代码的实现：

    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                //...
            }
        });
        // 设置线程为守护线程
        thread.setDaemon(true);
        System.out.println("Thread 线程类型：" +
                           (thread.isDaemon() == true ? "守护线程" : "用户线程"));
        System.out.println("main 线程类型：" +
                           (Thread.currentThread().isDaemon() == true ? "守护线程" : "用户线程"));
    }
    

以上程序的执行结果如下图所示：  
![image.png](https://cdn.nlark.com/yuque/0/2022/png/92791/1643250912198-123d9023-b036-4562-900b-f0fec0f500db.png#clientId=uc3528924-f783-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u456b10a2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=1980&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65671&status=done&style=none&taskId=uffb114fe-5cb6-44ca-b4ca-046e56b9c80&title=&width=990)

### 将线程池设置为守护线程

要把线程池设置为守护线程相对来说麻烦一些，需要将线程池中的所有线程都设置成守护线程，这个时候就需要使用线程工厂 ThreadFactory 来设置了（线程池中的所有线程都是通过线程工厂创建的），它的具体实现代码如下：

    public static void main(String[] args) throws InterruptedException {
        // 线程工厂（设置守护线程）
        ThreadFactory threadFactory = new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                Thread thread = new Thread(r);
                // 设置为守护线程
                thread.setDaemon(true);
                return thread;
            }
        };
        // 创建线程池
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 10,
                                                               0, TimeUnit.SECONDS, new LinkedBlockingQueue<>(100), threadFactory);
        threadPool.submit(new Runnable() {
            @Override
            public void run() {
                System.out.println("ThreadPool 线程类型：" +
                                   (Thread.currentThread().isDaemon() == true ? "守护线程" : "用户线程"));
            }
        });
        Thread.sleep(2000);
    }
    

以上程序的执行结果如下图所示：  
![image.png](https://cdn.nlark.com/yuque/0/2022/png/92791/1643251285567-72bbc22d-017f-4b09-8528-c1f99aa7de4a.png#clientId=uc3528924-f783-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=u61d1ccd6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=465&originWidth=2019&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60976&status=done&style=none&taskId=u58da8c56-4258-4151-8fd3-b5afa3d3b18&title=&width=1009.5)

守护线程 VS 用户线程
------------

通过前面的内容我们了解了什么是用户线程和守护线程了，那二者有什么区别呢？接下来我们用一个小示例来观察一下。  
接下来我们将创建一个线程，分别将这个线程设置为用户线程和守护线程，在每个线程中执行一个 for 循环，总共执行 10 次信息打印，每次打印之后休眠 100 毫秒，来观察程序的运行结果。

### 用户线程

新建的线程默认就是用户线程，因此我们无需对线程进行任何特殊的处理，执行 for 循环即可（总共执行 10 次信息打印，每次打印之后休眠 100 毫秒），实现代码如下：

    public static void main(String[] args) throws InterruptedException {
        // 创建用户线程
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i <= 10; i++) {
                    // 打印 i 信息
                    System.out.println("i:" + i);
                    try {
                        // 休眠 100 毫秒
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        // 启动线程
        thread.start();
    }
    

以上程序的执行结果如下图所示：  
![image.png](https://cdn.nlark.com/yuque/0/2022/png/92791/1643251516606-9dbf9d46-d737-4d4c-8edc-8e8b583a8374.png#clientId=uc3528924-f783-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=444&id=ud8303638&margin=%5Bobject%20Object%5D&name=image.png&originHeight=887&originWidth=2293&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88830&status=done&style=none&taskId=uf9c067ab-3db7-4885-87a3-2738f83d7ac&title=&width=1146.5)  
从上述结果可以看出，当程序执行完 10 次打印之后才会正常结束进程。

### 守护线程

    public static void main(String[] args) throws InterruptedException {
        // 创建守护线程
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i <= 10; i++) {
                    // 打印 i 信息
                    System.out.println("i:" + i);
                    try {
                        // 休眠 100 毫秒
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        // 设置为守护线程
        thread.setDaemon(true);
        // 启动线程
        thread.start();
    }
    

以上程序执行结果如下图所示：  
![image.png](https://cdn.nlark.com/yuque/0/2022/png/92791/1643251594973-a030defe-24dc-424a-b3c3-9a37222c4a7f.png#clientId=uc3528924-f783-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=196&id=u5869ad47&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=1943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47562&status=done&style=none&taskId=u2e0145b1-cc84-409d-b5f2-ed3d487e981&title=&width=971.5)  
从上述结果可以看出，当线程设置为守护线程之后，整个程序不会等守护线程 for 循环 10 次之后再进行关闭，而是当主线程结束之后，守护线程一次循环都没执行就结束了，由此可以看出守护线程和用户线程的不同。

### 守护线程注意事项

守护线程的设置 setDaemon(true) 必须要放在线程的 start() 之前，否则程序会报错。也就是说**在运行线程之前，一定要先确定线程的类型，并且线程运行之后是不允许修改线程的类型的**。  
接下来我们来演示一下，如果在程序运行执行再设置线程的类型会出现什么问题？演示代码如下：

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i <= 10; i++) {
                    // 打印 i 信息
                    System.out.println("i:" + i + ",isDaemon:" +
                                Thread.currentThread().isDaemon());
                    try {
                        // 休眠 100 毫秒
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        // 启动线程
        thread.start();
        // 设置为守护线程
        thread.setDaemon(true);
    }
    

以上程序执行结果如下图所示：  
![image.png](https://cdn.nlark.com/yuque/0/2022/png/92791/1643252223826-6487e50f-9cb1-4de4-bde6-fdddde935efd.png#clientId=uc3528924-f783-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=399&id=ua45e2360&margin=%5Bobject%20Object%5D&name=image.png&originHeight=798&originWidth=1802&originalType=binary&ratio=1&rotation=0&showTitle=false&size=467269&status=done&style=none&taskId=u4d6a2b1e-fc4d-4a7c-aab8-8491ec4aea5&title=&width=901)  
从上述结果可以看出，当我们将 setDaemon(true) 设置在 start() 之后，不但程序的执行会报错，而且设置的守护线程也不会生效。

总结
--

在 Java 语言中线程分为两类：用户线程和守护线程，默认情况下我们创建的线程或线程池都是用户线程，**守护线程是为用户线程服务的，当一个程序中的所有用户线程都执行完成之后程序就会结束运行，程序结束运行时不会管守护线程是否正在运行**，由此我们可以看出守护线程在 Java 体系中权重是比较低的，这就是守护线程和用户线程的区别。

> 是非审之于己，毁誉听之于人，得失安之于数。
> 
> 公众号：Java面试真题解析
> 
> 面试合集：[https://gitee.com/mydb/interview](https://gitee.com/mydb/interview)

关注下面二维码，订阅更多精彩内容。  
![](https://images.cnblogs.com/cnblogs_com/vipstone/848916/o_211225130402_gognzhonghao.jpg)

![](http://icdn.apigo.cn/gitchat/rabbitmq.png?imageView2/0/w/500/h/400)

![微信打赏](http://icdn.apigo.cn/myinfo/wchat-pay.png "微信打赏")  

关注公众号（加好友）： ![](http://icdn.apigo.cn/gongzhonghao2.png?imageView2/0/w/120/h/120)

  
作者： [王磊的博客](http://vipstone.cnblogs.com/)  
出处： [http://vipstone.cnblogs.com/](http://vipstone.cnblogs.com/)