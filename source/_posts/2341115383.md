---
layout: post
title: "我的设计模式之旅、12 原型模式"
date: "2022-09-18T23:21:25.899Z"
---
我的设计模式之旅、12 原型模式
================

![我的设计模式之旅、12 原型模式](https://img2022.cnblogs.com/blog/2290413/202209/2290413-20220919004645861-1688519547.png) 我的设计模式之旅，本节学习原型模式。从复制原有对象出现的两大问题思考原型模式存在的必要性。探讨原型模式的实现方法。

编程旅途是漫长遥远的，在不同时刻有不同的感悟，本文会一直更新下去。

思考总结
====

思考问题
----

**如果没有原型模式，当我们复制复杂对象，在新建相同类的对象，遍历原始对象中的所有成员变量并将成员变量复制到新对象的过程中会产生什么问题**？

*   并非所有对象都能通过这种方式复制，因为对象**可能拥有私有成员变量**，它们在对象本身以外是不可见的。
    
*   因为**你必须知道对象所属的类才能创建复制品**，所以代码必须依赖该类。有时你只知道对象所实现的接口，而不知道其所属的具体类，比如可向方法的某个参数传入实现了某个接口的任何对象。
    

什么是原型模式
-------

原型是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类。

> 原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

![image-20220919002703390](https://xiaonenglife.oss-cn-hangzhou.aliyuncs.com/static/pic/2022/09/20220919002704_image-20220919002703390.png)

**含义：**

*   原型模式将克隆过程委派给被克隆的实际对象。模式**为所有支持克隆的对象声明了一个通用接口**，该接口让你能够克隆对象，同时又**无需将代码和对象所属类耦合**。你甚至可以复制私有成员变量，因为绝大部分编程语言都允许对象访问其自身的私有成员变量。支持克隆的对象即为**原型**。

**何时使用：**

*   **如果你需要复制一些对象，同时又希望代码独立于这些对象所属的具体类，可以使用原型模式。**通常出现在代码需要处理第三方代码通过接口传递过来的对象时。即使不考虑代码耦合的情况，你的代码也不能依赖这些对象所属的具体类，因为你不知道它们的具体 信息。
*   如果子类的区别仅在于其对象的初始化方式，那么你可以使用该模式来减少子类的数量。别人创建这些子类的目的可能 是为了创建特定类型的对象。
*   当要实例化的类是在运行时刻指定时，例如，通过动态装载。
*   当一个类的实例只能有几个不同状态组合中的一种时。建立一系列预生成的、各种类型的对象作为原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
    *   当你的对象有几十个成员变量和几百种类型时，对其进行克隆甚至可以代替子类的构造。创建一系列不同类型的对象并用不同的方式对其进行配置。如果所需对象与预先配置的对象相同，那么你只需克隆原型即可，无需新建一个对象。

**实现方法：**

*   **创建原型接口，并在其中声明克隆方法。**如果你已有类层次结构，则只需在其所有类中添加该方法即可。
*   **原型类必须另行定义一个以该类对象为参数的构造函数。**构造函数**必须复制参数对象中的所有成员变量值到新建实体中。** 如果你需要修改子类，则必须调用父类构造函数，让父类复制其私有成员变量值。
*   每个类都必须显式重写克隆方法并使 用自身类名调用 new 运算符。
*   你还可以创建一个**中心化原型注册表**，用于存储常用原型。
    *   **你可以新建一个工厂类来实现注册表，或者在原型基类中添加一个获取原型的静态方法**。该方法必须能够根据客户端代 码设定的条件进行搜索。搜索条件可以是简单的字符串，或 者是一组复杂的搜索参数。找到合适的原型后，注册表应对原型进行克隆，并将复制生成的对象返回给客户端。**最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。**

**应用实例：**

*   细胞分裂

**优点：**

*   你可以克隆对象，而无需与它们所属的具体类相耦合。
*   你可以克隆预生成原型，避免反复运行初始化代码。性能提高。 逃避构造函数的约束。
*   你可以更方便地生成复杂对象。
*   你可以用继承以外的方式来处理复杂对象的不同配置。

**缺点：**

*   克隆包含循环引用的复杂对象可能会非常麻烦。
*   必须实现 Cloneable 接口。

**使用场景：**

*   资源优化场景。 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 性能和安全要求的场景。
*   通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
*   一个对象多个修改者的场景。 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。
*   **在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。**

**与其他模式的关系：**

*   原型可用于保存**命令**的历史记录。
*   大量使用**组合和装饰**的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构，而非从零开始重新构造。
*   原型并不基于继承，因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。
*   有时候原型可以作为**备忘录**的一个简化版本，其条件是你需要在历史记录中存储的对象的状态比较简单，不需要链接其 他外部资源，或者链接可以方便地重建。
*   **抽象工厂、生成器和原型**都可以用单例来实现。

**注意事项：**原型模式分浅拷贝和深拷贝，在设计原型模式的时候需要着重考虑。

参考资料
====

*   《Go语言核心编程》李文塔
*   《Go语言高级编程》柴树彬、曹春辉
*   《大话设计模式》程杰
*   《深入设计模式》亚历山大·什韦茨
*   [菜鸟教程](runoob.com/design-pattern/strategy-pattern.html)