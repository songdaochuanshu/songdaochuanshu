---
layout: post
title: "谷歌MapReduce经典论文翻译(中英对照)"
date: "2022-09-23T12:41:13.810Z"
---
谷歌MapReduce经典论文翻译(中英对照)
=======================

MapReduce: Simplified Data Processing on Large Clusters（MapReduce: 简化大型集群下的数据处理）
================================================================================

##### 作者：Jeffrey Dean and Sanjay Ghemawat

### Abstract（摘要）

MapReduce is a programming model and an associated implementation for processing and generating large data sets.  
Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs,  
and a reduce function that merges all intermediate values associated with the same intermediate key.  
Many real world tasks are expressible in this model, as shown in the paper.

MapReduce是一个关于实施大型数据集处理和生成的编程模型。  
用户指定一个用于处理**k/v对**并生成**中间态k/v对集合**的映射（map）函数，以及一个用于合并所有具有相同中间态key的中间态value值的归约（reduce）函数。  
正如本篇论文所展示的那样，很多现实世界中的任务都可以通过该模型（MapReduce）表达。

Programs written in this functional style are automatically parallelized and executed on a large cluster of commodity machines.  
The run-time system takes care of the details of partitioning the input data,scheduling the program’s execution across a set of machines, handling machine failures,  
and managing the required inter-machine communication.  
This allows programmers without any experience with parallel and distributed systems  
to easily utilize the resources of a large distributed system.

以这种函数式风格编写的程序可以在一个大型的商品级(译者小熊餐馆注：意思是很廉价、性能也很一般的意思，下同)机器集群中自动、并行的执行。  
该系统在运行时会关注如下细节：输入数据的分割，在一系列机器间跨机器的调度程序的执行，机器故障的处理以及管理集群内机器间的必要通信。  
这（使用MapReduce）使得没有任何并行计算、分布式系统经验的程序员们都可以轻松利用大型分布式系统中的资源。

Our implementation of MapReduce runs on a large cluster of commodity machines and is highly scalable:  
a typical MapReduce computation processes many terabytes of data on thousands of machines.  
Programmers find the system easy to use: hundreds of MapReduce programs have been implemented  
and upwards of one thousand MapReduce jobs are executed on Google’s clusters every day.

我们已实现的MapReduce运行在一个大型商品级机器集群上，而且具有高度的可拓展性：一个典型的MapReduce计算可以在数千台机器上处理TB级别的数据。  
程序员们发现系统很容易使用：已经有数以百计的MapReduce程序被实现，并且每天都有一千以上的MapReduce任务运行在谷歌的（计算机）集群中。

### 1 Introduction（介绍）

Over the past five years, the authors and many others at Google have implemented hundreds of special-purpose computations  
that process large amounts of raw data, such as crawled documents, web request logs, etc.  
, to compute various kinds of derived data, such as inverted indices, various representations of the graph structure of web documents,  
summaries of the number of pages crawled per host, the set of most frequent queries in a given day, etc.  
Most such computations are conceptually straightforward.  
However, the input data is usually large and the computations have to be distributed across hundreds or thousands of machines in order to finish in a reasonable amount of time.  
The issues of how to parallelize the computation, distribute the data,  
and handle failures conspire to obscure the original simple computation with large amounts of complex code to deal with these issues.

在过去的五年时间里，包括作者在内的许多谷歌工作人员实现了数以百计的、用于特殊目的的计算程序来处理大量的原始数据，例如爬虫获取到的文档、网络请求日志等等。  
其目的是为了计算出各种类型的衍生数据，例如倒排索引、多种关于web文档的图结构表示、被每个主机所爬取的页面数摘要、给定的某天中被最频繁查询的集合等等。  
大多数这样的计算在概念上都很简单，然而输入的数据却通常是巨大的。而且为了能在一个合理的时间范围内完成，计算操作需要被分配到数百甚至数千台机器上运行。  
关于如何并行计算，如何分派数据以及如何处理故障等问题被混杂在了一起，使得原本简单的计算逻辑被用于处理这些问题的大量复杂代码所模糊。

As a reaction to this complexity, we designed a new abstraction that allows us to express the simple computations  
we were trying to perform but hides the messy details of parallelization, fault-tolerance, data distribution and load balancing in a library.  
Our abstraction is inspired by the map and reduce primitives present in Lisp and many other functional languages.  
We realized that most of our computations involved applying a map operation to each logical “record” in our input in order to compute a set of intermediate key/value pairs,  
and then applying a reduce operation to all the values that shared the same key, in order to combine the derived data appropriately.  
Our use of a functional model with user specified map and reduce operations allows us to parallelize large computations easily  
and to use re-execution as the primary mechanism for fault tolerance.

为了应对这些复杂性，我们设计了一个全新的抽象，该抽象允许我们表达我们想要执行的简单计算，但是将关于并行化、容错、数据分发和负载均衡等机制中复杂、繁琐的细节隐藏在了库中。  
我们的这一抽象其设计灵感是来源于Lisp和很多其它函数式语言中的map和reduce原语。  
我们意识到我们的绝大多数计算都涉及到为每一个输入的逻辑记录应用(applying)一个map映射操作，目的是对输入集计算从而将其转化为一个中间态的k/v对集合；  
然后为了恰当地合并衍生数据，再对所有拥有相同key值的k/v对中的value值应用一个reduce规约操作。  
通过一个由用户指定具体逻辑的map和reduce操作的函数式模型，使得我们能轻易地并行化大规模的计算，并且将重复执行（自动重试）机制作为容错的主要手段。

The major contributions of this work are a simple and powerful interface that enables automatic parallelization  
and distribution of large-scale computations,  
combined with an implementation of this interface that achieves high performance on large clusters of commodity PCs.

这项工作的主要贡献在于提供了一个简单且强大的接口，该接口能够使大规模计算自动地并行化和分布式的执行。  
结合该接口的实现，得以在大型的商品级PC集群中获得很高的性能。

Section 2 describes the basic programming model and gives several examples.  
Section 3 describes an implementation of the MapReduce interface tailored towards our cluster-based computing environment.  
Section 4 describes several refinements of the programming model that we have found useful.  
Section 5 has performance measurements of our implementation for a variety of tasks.  
Section 6 explores the use of MapReduce within Google including our experiences in using it  
as the basis for a rewrite of our production indexing system.  
Section 7 discusses related and future work.

第二章介绍了基本的编程模型并给出了几个示例。  
第三章介绍了一个针对集群计算环境的MapReduce接口实现。  
第四章介绍了几个我们发现的，关于该编程模型的有效改进。  
第五章则是关于我们对各种任务所实施的性能测试。  
第六章探讨了MapReduce在谷歌内部的应用，其中包括了我们以MapReduce为基础去重建索引生成系统的经验。  
第七章讨论了一些相关的话题以及日后要做的工作。

### 2 Programming Model（编程模型）

The computation takes a set of input key/value pairs, and produces a set of output key/value pairs.  
The user of the MapReduce library expresses the computation as two functions: Map and Reduce.

这一计算获得并输入一个k/v键值对集合，然后生成并输出一个k/v键值对集合。  
MapReduce库的用户通过Map和Reduce这两个函数来表达该计算逻辑。

Map, written by the user, takes an input pair and produces a set of intermediate key/value pairs.  
The MapReduce library groups together all intermediate values associated with the same intermediate key _I_  
and passes them to the Reduce function.

Map函数是由用户编写的，其获得一个输入的k/v对并生成一个中间态的k/v对。  
MapReduce库对所有的k/v对进行分组，使得所有有着相同中间态key值的k/v对的value值组合在一起，然后将它们传递给Reduce函数。

The Reduce function, also written by the user, accepts an intermediate key _I_ and a set of values for that key.  
It merges together these values to form a possibly smaller set of values.  
Typically just zero or one output value is produced per Reduce invocation.  
The intermediate values are supplied to the user’s reduce function via an iterator.  
This allows us to handle lists of values that are too large to fit in memory.

Reduce函数也是由用户编写的，其接收一个中间态的key值和与该键对应的一组value值的集合。  
它会将这些value值进行统一的合并以形成一个可能更小的value值集合。  
通常，每次reduce调用只会生成零个或一个输出值。这个中间态的value集合通过一个迭代器提供给用户的reduce函数。  
这允许我们得以处理那些无法被完整放入内存的，过大的列表集合。

### 2.1 Example（示例）

Consider the problem of counting the number of occurrences of each word in a large collection of documents.  
The user would write code similar to the following pseudo-code:

思考一个关于在一个大型文档集合中计算每一个单词出现次数的程序。  
用户可能会写下形如以下伪代码的程序：

    map(String key, String value):
        // key: document name
        // value: document contents
        for each word w in value:
            EmitIntermediate(w,"1");
    reduce(String key, Iterator values):
        // key: a word
        // values: a list of counts
        int result = 0;
        for each v in values:
            result += ParseInt(v);
        Emit(AsString(result));
    

The map function emits each word plus an associated count of occurrences (just ‘1’ in this simple example).  
The reduce function sums together all counts emitted for a particular word.

这个map映射函数生成每一个单词以及其出现的次数（在这个简单的例子中次数恰好是1）。  
reduce函数则累加每一个生成的特定单词其所有的出现计数。

In addition, the user writes code to fill in a mapreduce specification object with the names of the input and output files, and optional tuning parameters.  
The user then invokes the MapReduce function, passing it the specification object.  
The user’s code is linked together with the MapReduce library (implemented in C++).  
Appendix A contains the full program text for this example.

此外，用户编写代码以指定的输入、输出文件的名字和可选的调优参数来填充一个规范的mapreduce对象。  
用户随后调用MapReduce函数，传递这个符合规范的对象。用户的代码与MapReduce库（c++实现）进行链接。  
附录A包含了本示例的完整程序文本。

### 2.2 Types（类型）

Even though the previous pseudo-code is written in terms of string inputs and outputs,  
conceptually the map and reduce functions supplied by the user have associated types:

尽管前面的伪代码是依据字符串类型的输入、输出编写的，但从概念上说，用户提供的map和reduce函数在类型上是有关联的：

    map (k1,v1) --> list(k2,v2)
    reduce (k2,list(v2)) --> list (v2)
    

I.e., the input keys and values are drawn from a different domain than the output keys and values.  
Furthermore, the intermediate keys and values are from the same domain as the output keys and values.

举个例子，输入的key和value和输出的key和value分属不同的域。  
此外，中间态的key和value和输出的key和value则属于相同的域。

Our C++ implementation passes strings to and from the user-defined functions  
and leaves it to the user code to convert between strings and appropriate types.

我们在c++的实现中传递字符串，以作为用户自定义函数的输入和输出，并将字符串（类型）与合适的类型间进行转化的逻辑留给用户代码实现。

### 2.3 More Examples（更多的例子）

Here are a few simple examples of interesting programs that can be easily expressed as MapReduce computations.

这里有几个很容易用MapReduce计算来表达的有趣程序的简单示例。

**Distributed Grep:** The map function emits a line if it matches a supplied pattern.  
The reduce function is an identity function that just copies the supplied intermediate data to the output.

**分布式Grep:**  
map函数如果匹配某个给定规则则输出对应的那一行。  
reduce函数是一个恒等函数，其只是将所输入的中间数据原封不动的复制到输出（译者小熊餐馆注：恒等函数：f(x) = x, 即输入=输出）。

**Count of URL Access Frequency:** The map function processes logs of web page requests and outputs <URL,1>.  
The reduce function adds together all values for the same URL and emits a <URL,total count> pair.

**URL访问频率计数:**  
map函数处理网页请求的处理日志，并且输出<URL,1>的键值对。  
reduce函数累加所有具有相同URL键值对的value值，并且输出一个<URL,总访问数>的键值对。

**Reverse Web-Link Graph:** The map function outputs (target,source) pairs for each link to a target URL found in a page named source.  
The reduce function concatenates the list of all source URLs associated with a given target URL and emits the pair:(target,_list_(source))

**反向web链接图:**  
map函数从每一个源页面（source）中找出每一个目标页URL（target）的链接，输出（target，source）格式的kv对。  
reduce函数将所有具有相同target目标页的所有源页面（source）结合在一起组成一个列表，输出这样一个kv对（target,_list_(source)）。

**Term-Vector per Host:** A term vector summarizes the most important words that occur in a document  
or a set of documents as a list of <word,frequency> pairs.  
The map function emits a <hostname,>pair for each input document (where the hostname is extracted from the URL of the document).  
The reduce function is passed all per-document term vectors for a given host.  
It adds these term vectors together, throwing away infrequent terms, and then emits a final<hostname,term vector> pair.

**每台主机的检索词向量**:  
汇总从一个或一系列文档中出现的最重要的单词作为检索词向量（term-vector），生成以<word(单词),frequency(出现频次)>格式的kv对列表。  
map函数针对每一个输入的文档，输出一个<hostname(主机名),term vector(检索词向量)>的kv对（主机名是从文档的URL中提取出来的）。  
reduce函数接收一个给定host下基于每个文档的所有term-vectors(检索词向量)。  
将这些检索词向量进行累加，抛弃掉一些出现频率较低的检索词项然后返回最终的<hostname(主机名),term vector(检索词向量)>的kv对。

**Inverted Index:** The map function parses each document, and emits a sequence of <word,document ID>pairs.  
The reduce function accepts all pairs for a given word, sorts the corresponding document IDs and emits a <word,_list_(document ID)> pair.  
The set of all output pairs forms a simple inverted index.  
It is easy to augment this computation to keep track of word positions.

**倒排索引:**  
map函数解析每一个文档，然后输出一连串<word(单词)，documentID(文档ID)>格式的kv对。  
reduce函数接收一个给定单词对应的所有kv对，针对文档ID进行排序然后返回一个<word(单词),\_list\_documentID(文档ID列表)>格式的kv对。  
所有输出的kv对集合构成了一个简单的倒排索引。基于此，我们能简单的增加记录每一个单词(在这些文档中)的位置的计算功能。

Distributed Sort: The map function extracts the key from each record, and emits a <key,record> pair.  
The reduce function emits all pairs unchanged.  
This computation depends on the partitioning facilities described in Section 4.1 and the ordering properties described in Section 4.2.

**分布式排序:**  
map函数提取每一个记录中的key值，然后返回一个<key,record>格式的kv对。  
reduce函数对所有的kv对不做修改直接返回。  
该计算依赖于后续4.1章节中所述的分区机制和4.2章节中所述的有序性机制。

### 3 Implementation(实现)

Many different implementations of the MapReduce interface are possible. The right choice depends on the environment.  
For example, one implementation may be suitable for a small shared-memory machine,  
another for a large NUMA multi-processor, and yet another for an even larger collection of networked machines.

MapReduce接口可以有很多不同的实现方式。具体哪一种更加合适则取决于具体的环境。  
例如，某一种实现方式可能适合有着较小共享内存的机器，而另一种实现方式则适用于大型的NUMA架构的多核处理器机器，还有的实现方式则更适用于基于网络的大型机器集群。

This section describes an implementation targeted to the computing environment in wide use at Google:  
large clusters of commodity PCs connected together with switched Ethernet.  
In our environment:  
(1) Machines are typically dual-processor x86 processors running Linux, with 2-4 GB of memory per machine.  
(2) Commodity networking hardware is used – typically either 100 megabits/second or 1 gigabit/second at the machine level,  
but averaging considerably less in over-all bisection bandwidth.  
(3) A cluster consists of hundreds or thousands of machines, and therefore machine failures are common.  
(4) Storage is provided by inexpensive IDE disks attached directly to individual machines.  
A distributed file system developed in-house is used to manage the data stored on these disks.  
The file system uses replication to provide availability and reliability on top of unreliable hardware.  
(5) Users submit jobs to a scheduling system. Each job consists of a set of tasks,  
and is mapped by the scheduler to a set of available machines within a cluster.

本章介绍的一个(MapReduce)实现是针对谷歌内部广泛使用的计算环境的：通过交换式以太网互相连接起来的大型商品级PC集群。  
在我们的环境中:  
(1) 机器通常是有着x86架构的双处理器的、运行linux操作系统的平台，每台机器有2-4GB的内存。  
(2) 使用商品级的网络硬件 - 通常每台机器的带宽为100M/s或者1GB/s，但其平均(实际使用的)带宽远小于整个网络带宽的一半。  
(3) 整个集群是由几百或几千台机器所组成的，因此机器故障是频繁出现的。  
(4) 存储是由直接连接到独立机器上的IDE硬盘提供的。存储在这些磁盘上的数据由一个内部自研的分布式文件系统来管理。这一文件系统采用复制机制，旨在不可靠的硬件之上实现可用性和可靠性。  
(5) 用户提交作业(job)给一个调度系统。每个作业都由一系列的任务(task)组成，任务被调度器映射到内部集群中的一组可用机器上去执行。

### 3.1 Execution Overview(执行概述)

The Map invocations are distributed across multiple machines by automatically partitioning the input data into a set of M splits.  
The input splits can be processed in parallel by different machines.  
Reduce invocations are distributed by partitioning the intermediate key space into R pieces using a partitioning function (e.g., hash(key) mod R).  
The number of partitions (R) and the partitioning function are specified by the user.

通过将输入的数据自动分割为M份，map调用得以分布在多个机器上调用执行。拆分后的输入数据可以被不同的机器并行的处理。  
通过一个分区函数将中间态的key值空间划分为R份(例如: hash(key) mod R, 对key做hash后再对R求模)，Reduce调用也得以分布式的执行。  
分区的个数(R)和分区函数都由用户来指定。  
![执行概述.png](https://img2022.cnblogs.com/blog/1506329/202209/1506329-20220923200814531-406767197.png)

Figure 1 shows the overall flow of a MapReduce operation in our implementation.  
When the user program calls the MapReduce function, the following sequence of actions occurs  
(the numbered labels in Figure 1 correspond to the numbers in the list below):

1.  The MapReduce library in the user program first splits the input files into M pieces of typically 16 megabytes to 64 megabytes (MB) per piece  
    (controllable by the user via an optional parameter).  
    It then starts up many copies of the program on a cluster of machines.
    
2.  One of the copies of the program is special – the master. The rest are workers that are assigned work by the master.  
    There are M map tasks and R reduce tasks to assign. The master picks idle workers and assigns each one a map task or a reduce task.
    
3.  A worker who is assigned a map task reads the contents of the corresponding input split.  
    It parses key/value pairs out of the input data and passes each pair to the user-defined Map function.  
    The intermediate key/value pairs produced by the Map function are buffered in memory.
    
4.  Periodically, the buffered pairs are written to local disk, partitioned into R regions by the partitioning function.  
    The locations of these buffered pairs on the local disk are passed back to the master,  
    who is responsible for forwarding these locations to the reduce workers.
    
5.  When a reduce worker is notified by the master about these locations,  
    it uses remote procedure calls to read the buffered data from the local disks of the map workers.  
    When a reduce worker has read all intermediate data, it sorts it by the intermediate keys so  
    that all occurrences of the same key are grouped together.  
    The sorting is needed because typically many different keys map to the same reduce task.  
    If the amount of intermediate data is too large to fit in memory, an external sort is used.
    
6.  The reduce worker iterates over the sorted intermediate data and for each unique intermediate key encountered,  
    it passes the key and the corresponding set of intermediate values to the user’s Reduce function.  
    The output of the Reduce function is appended to a final output file for this reduce partition.
    
7.  When all map tasks and reduce tasks have been completed, the master wakes up the user program.  
    At this point, the MapReduce call in the user program returns back to the user code.
    

图1展示了我们所实现的MapReduce操作的总体流程。当用户程序调用MapReduce函数时，会发生以下的一系列动作（图1中的数字标号与以下列表中的数字是对应的）:

1.  内嵌于用户程序中的MapReduce库首先会将输入的文件拆分为M份，每份大小通常为16MB至64MB（具体的大小可以由用户通过可选参数来控制）。  
    然后便在集群中的一组机器上启动多个程序的副本。
    
2.  其中一个程序的副本是特殊的-即master。剩下的程序副本都是worker, worker由master来分配任务。  
    这里有M个map任务和R个reduce任务需要分配。master选择空闲的worker，并且为每一个被选中的worker分配一个map任务或一个reduce任务。
    
3.  一个被分配了map任务的worker，读取被拆分后的对应输入内容。  
    从输入的数据中解析出key/value键值对，并将每一个kv对作为参数传递给用户自定义的map函数。  
    map函数产生的中间态key/value键值对会被缓存在内存之中。
    
4.  缓存在内存中的kv对会被周期性地写入通过分区函数所划分出的R个磁盘区域内。  
    这些在本地磁盘上被缓冲的kv对的位置将会被回传给master，master负责将这些位置信息转发给后续执行reduce任务的worker。
    
5.  当一个负责reduce任务的worker被master通知了这些位置信息(map任务生成的中间态kv对数据所在的磁盘信息)，  
    该worker通过远过程调用(RPC)从负责map任务的worker机器的本地磁盘中读取被缓存的数据。  
    当一个负责reduce任务的worker已经读取了所有的中间态数据，将根据中间态kv对的key值进行排序，因此所有拥有相同key值的kv对将会被分组在一起。  
    需要排序的原因是因为通常很多不同的key(的kv对集合)会被映射到同一个reduce任务中去。如果(需要排序的)中间态的数据量过大，无法完全装进内存时，将会使用外排序。
    
6.  负责reduce任务的worker迭代所有被排好序的中间态数据，并将所遇到的每一个唯一的key值和其对应的中间态value值集合传递给用户自定义的reduce函数。  
    reduce函数所产生的输出将会追加在一个该reduce分区内的、最终的输出文件内。
    
7.  当所有的map任务和reduce任务都完成后，master将唤醒用户程序。此时，调用MapReduce的用户程序(的执行流)将会返回到用户代码中。
    

After successful completion, the output of the mapreduce execution is available in the R output files  
(one per reduce task, with file names as specified by the user).  
Typically, users do not need to combine these R output files into one file – they often pass these files as input to another MapReduce call,  
or use them from another distributed application that is able to deal with input that is partitioned into multiple files.

在成功的完成计算后，MapReduce执行的输出结果将被存放在R个输出文件中(每一个reduce任务都对应一个输出文件，输出文件的名字由用户指定)。  
通常，用户无需将这R个输出文件合并为一个文件 - 他们通常传递这些文件，将其作为另一个MapReduce调用的输入，或者由另一个能处理多个被分割的输入文件的分布式应用所使用。

### 3.2 Master Data Structures(Master数据结构)

The master keeps several data structures. For each map task and reduce task, it stores the state (idle, in-progress, or completed),  
and the identity of the worker machine(for non-idle tasks).

master中维护了一些数据结构。对于每一个map和reduce任务，master存储了对应的任务状态(闲置的，运行中，或者已完成)，以及worker机器的id(针对非空闲的任务)。

The master is the conduit through which the location of intermediate file regions is propagated from map tasks to reduce tasks.  
Therefore, for each completed map task, the master stores the locations and sizes of the R intermediate file regions produced by the map task.  
Updates to this location and size information are received as map tasks are completed.  
The information is pushed incrementally to workers that have in-progress reduce tasks.

master是一个管道，将中间态文件的位置信息从map任务传递给reduce任务。  
因此，对于每个已完成的map任务，master存储了由map任务生成的R个中间态文件区域的位置和大小。  
当map任务完成时，master将更新接受到的(中间态文件区域)位置和大小信息。  
这些信息的变更会以增量的方式推送给运行中的reduce任务。

### 3.3 Fault Tolerance(容错)

Since the MapReduce library is designed to help process very large amounts of data using hundreds or thousands of machines,  
the library must tolerate machine failures gracefully.

由于MapReduce库是被设计用于在几百或几千台机器上进行大规模数据处理的，所以该库必须能优雅地处理机器故障。

##### Worker Failure(Worker故障)

The master pings every worker periodically.  
If no response is received from a worker in a certain amount of time, the master marks the worker as failed.  
Any map tasks completed by the worker are reset back to their initial idle state,  
and therefore become eligible for scheduling on other workers.  
Similarly, any map task or reduce task in progress on a failed worker is also reset to idle and becomes eligible for rescheduling.

master会周期性的ping每一个worker。  
如果在一定的时间内没有接收到来自某一worker的响应，master将会将worker标记为有故障(failed)。  
所有由该worker完成的map任务将会被重置回初始状态，因此这些map任务能被其它worker去调度执行。  
类似的，任何在这个有故障的worker上处理中的map或reduce任务状态也将被重置为初始化，并且(这些被重置的任务)能够被重新调度执行。

Completed map tasks are re-executed on a failure because their output is stored on the local disk(s) of the failed machine and is therefore inaccessible.  
Completed reduce tasks do not need to be re-executed since their output is stored in a global file system.

已完成的map任务在故障时需要被重复执行的原因在于map任务的输出是被存储在故障机器的本地磁盘上的，因此无法被访问到(宕机或者网络不通等情况)。  
而已完成的reduce任务不需要重复执行的原因在于其输出是被存储在全局的文件系统中的。

When a map task is executed first by worker A and then later executed by worker B (because A failed), all workers executing reduce tasks are notified of the re-execution.  
Any reduce task that has not already read the data from worker A will read the data from worker B.

当一个map任务在worker A上被首次执行，不久后又被worker B执行(因为worker A发生了故障)，所有执行reduce任务的worker将会被通知需要重新执行。  
所有还没有从worker A处读取(完整)数据的reduce任务将改为从worker B处读取数据。

MapReduce is resilient to large-scale worker failures.  
For example, during one MapReduce operation, network maintenance on a running cluster was causing groups of 80 machines at a time to become unreachable for several minutes.  
The MapReduce master simply re-executed the work done by the unreachable worker machines, and continued to make forward progress,eventually completing the MapReduce operation.

MapReduce能从大范围的worker故障中迅速的恢复。  
例如，在一个MapReduce操作运行期间内，一个正在运行的集群上的一次网络维护导致了80台机器在几分钟内无法访问的。  
MapReduce的master只需要将这些无法访问的机器上的任务重新的执行，然后继续向前推进，最终完成这个MapReduce操作。

### Master Failure(Master故障)

It is easy to make the master write periodic checkpoints of the master data structures described above.  
If the master task dies, a new copy can be started from the last checkpointed state.  
However, given that there is only a single master, its failure is unlikely;  
therefore our current implementation aborts the MapReduce computation if the master fails.  
Clients can check for this condition and retry the MapReduce operation if they desire.

可以简单的让master周期性的将上述的master数据结构以检查点的形式持久化。  
如果master任务机器宕机了，一个新的master备份机器将会从最新的检查点状态处启动。  
然而，考虑到只有一台master机器，是不太可能出现故障的；因此如果master故障了，我们当前的实现会中止MapReduce计算。  
客户端可以检查master的这些状态，并根据需要重试MapReduce操作。

### Semantics in the Presence of Failures(面对故障时的语义)

When the user-supplied map and reduce operators are deterministic functions of their input values,  
our distributed implementation produces the same output as would have been produced  
by a non-faulting sequential execution of the entire program.

当用户提供的map和reduce算子都是基于其输入的确定性函数时，我们所实现的分布式(计算)的输出与整个程序的一个无故障的顺序串行执行后会的输出(结果)是一样的。

We rely on atomic commits of map and reduce task outputs to achieve this property.  
Each in-progress task writes its output to private temporary files.  
A reduce task produces one such file, and a map task produces R such files (one per reduce task).  
When a map task completes, the worker sends a message to the master and includes the names of the R temporary files in the message.  
If the master receives a completion message for an already completed map task, it ignores the message.  
Otherwise, it records the names of R files in a master data structure.

我们依赖map和reduce任务输出结果的原子性提交机制来实现这一特性。  
每一个处理中的任务将它们的输出写入其(任务)私有的临时文件中。  
一个reduce任务产生一个这样的文件，同时一个map任务产生R个这样的文件(共R个文件，R个reduce任务每个各对应一个文件)。  
当一个map任务完成后，对应worker会发送给master一个消息，消息内包含了这R个临时文件名字的。  
如果master接受到一个(已被标记为)已完成状态任务的完成消息时，其会忽略该消息。  
否则，将这R个文件的名字记录到master(维护)的数据结构中。

When a reduce task completes, the reduce worker atomically renames its temporary output file to the final output file.  
If the same reduce task is executed on multiple machines, multiple rename calls will be executed for the same final output file.  
We rely on the atomic rename operation provided by the underlying file system to guarantee  
that the final file system state contains just the data produced by one execution of the reduce task.

当一个reduce任务完成了，执行reduce任务的worker会原子性的将临时的输出文件重命名为最终的输出文件。  
如果在多台机器上有相同的reduce任务被执行，在同一个最终输出文件上将会被执行多次重命名调用。  
我们依赖底层文件系统所提供的原子性重命名操作来保证最终文件系统中恰好只保存了一次reduce任务执行的数据。

The vast majority of our map and reduce operators are deterministic,  
and the fact that our semantics are equivalent to a sequential execution in this case makes  
it very easy for programmers to reason about their program’s behavior.  
When the map and/or reduce operators are non-deterministic, we provide weaker but still reasonable semantics.

In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output  
for R1 produced by a sequential execution of the non-deterministic program.  
However, the output for a different reduce task R2 may correspond to the output for R2 produced  
by a different sequential execution of the non-deterministic program.

我们绝大多数的map和reduce算子都是确定性的(即：输出完全由输入决定，同样地输入一定有着同样地输出)，  
在这种情况下我们(分布式架构下并行执行)的语义等价于(单机单线程)顺序串行执行，这一事实使得程序员很容易理解他们程序的行为。  
当map或reduce算子是非确定性的，我们提供了一个稍弱但依然合理的语义。  
存在非确定性算子的情况下，一个特定reduce任务R1的输出等同于R1在非确定性程序下(单机单线程)顺序串行执行的输出。  
然而，另一个与R1不同的reduce任务R2的输出将会对应于R2在一个不同的非确定程序中以顺序串行执行的输出。

Consider map task M and reduce tasks R1 and R2 .  
Let e(Ri) be the execution of Ri that committed (there is exactly one such execution).  
The weaker semantics arise because e(R1) may have read the output produced by one execution of M  
and e(R2) may have read the output produced by a different execution of M.

考虑下目前有一个map任务M和两个reduce任务R1和R2。  
假设e(Ri)代表Ri任务已经被提交的一次执行(恰好只执行一次)。  
由于e(R1)可能在一次执行中读取M任务产生的输出，同时e(R2)可能会在另一次执行中读取M任务产生的输出，此时将会出现弱语义。

[针对MapReduce强语义、弱语义概念译者自己的理解](#info)

### 3.4 Locality(局部性)

Network bandwidth is a relatively scarce resource in our computing environment.  
We conserve network bandwidth by taking advantage of the fact that the input data(managed by GFS) is stored on the local disks of the machines that make up our cluster.  
GFS divides each file into 64 MB blocks, and stores several copies of each block (typically 3 copies) on different machines.  
The MapReduce master takes the location information of the input files into account and attempts to schedule a map task on a machine that contains a replica of the corresponding input data.  
Failing that, it attempts to schedule a map task near a replica of that task’s input data (e.g., on a worker machine that is on the same network switch as the machine containing the data).  
When running large MapReduce operations on a significant fraction of the workers in a cluster, most input data is read locally and consumes no network bandwidth.

在我们的计算环境中，网络带宽是一个相对稀缺的资源。  
我们利用输入的数据(被GFS管理)被存储在组成我们集群的机器的本地磁盘上这一事实来节约网络带宽。  
GFS将每个文件分割为64MB的块，同时为每一个块存储几个备份(通常是3个副本)在不同的机器上。  
MapReduce的master调度map任务时将输入文件的位置信息考虑在内，尽量在包含对应输入数据副本的机器上调度执行一个map任务。  
如果任务失败了，调度map任务时会让执行任务的机器尽量靠近任务所需输入数据所在的机器(举个例子，被选中的worker机器与包含数据的机器位于同一网络交换机下)。  
当集群中的相当一部分worker都在执行大型MapReduce操作时，绝大多数的输入数据都在本地读取从而不会消耗网络带宽。

### 3.5 Task Granularity(任务粒度)

We subdivide the map phase into M pieces and the reduce phase into R pieces, as described above.  
Ideally,M and R should be much larger than the number of worker machines.  
Having each worker perform many different tasks improves dynamic load balancing, and also speeds up recovery when a worker fails:  
the many map tasks it has completed can be spread out across all the other worker machines.

如上所述，我们将map阶段的任务拆分为M份，同时将reduce阶段的任务拆分为R份。  
理想情况下，M和R的值都应该远大于worker机器的数量。  
让每一个worker执行很多不同的任务可以提高动态负载均衡的效率，  
同时也能加快当一个worker故障时的恢复速度：（故障worker机器上）很多已经完成的map任务可以分散到所有其它的worker机器上去(重新执行)。

There are practical bounds on how large M and R can be in our implementation,  
since the master must make O(M + R) scheduling decisions and keeps O(M ∗ R)state in memory as described above.  
(The constant factors for memory usage are small however:  
the O(M ∗R) piece of the state consists of approximately one byte of data per map task/reduce task pair.)

在我们的实现中，对M和R的实际大小做了限制，因为master必须O(M+R)的调度决定，同时要保持O(M_R)个如上所处的内存状态。  
(然而这对于内存的总体使用率来说影响还是较小的：这O(M_R)份的状态里，构成每个map/reduce任务对的数据(只)占大约1字节。)

Furthermore, R is often constrained by users because the output of each reduce task ends up in a separate output file.  
In practice, we tend to choose M so that each individual task is roughly 16 MB to 64 MB of input data  
(so that the locality optimization described above is most effective),  
and we make R a small multiple of the number of worker machines we expect to use.  
We often perform MapReduce computations with M = 200,000 and R = 5,000, using 2,000 worker machines.

除此之外，用户通常会限制R的大小，因为每一个reduce任务的输出最后都会在一个被拆分的输出文件中。  
实际上，我们倾向于设置M的大小使得每个独立任务所需的输入数据大约在16MB至64MB之间(使得上文所述的局部性优化效果最好), 同时我们设置R的大小为我们预期使用worker机器数量的小几倍。  
我们执行MapReduce计算时，通常使用2000台worker机器，并设置M的值为200000，R的值为5000。

### 3.6 Backup Tasks(后备任务)

One of the common causes that lengthens the total time taken for a MapReduce operation is a “straggler”:  
a machine that takes an unusually long time to complete one of the last few map or reduce tasks in the computation.  
Stragglers can arise for a whole host of reasons.  
For example, a machine with a bad disk may experience frequent correctable errors that slow its read performance from 30 MB/s to 1 MB/s.  
The cluster scheduling system may have scheduled other tasks on the machine,  
causing it to execute the MapReduce code more slowly due to competition for CPU, memory, local disk, or network bandwidth.  
A recent problem we experienced was a bug in machine initialization code that caused processor caches to be disabled:  
computations on affected machines slowed down by over a factor of one hundred.

导致MapReduce运算总耗时变长的一个常见的原因是存在“落伍者”：即一台机器花费了异常长的时间去完成计算中最后的几个map或reduce任务。  
导致“落伍者”出现的原因多种多样。  
举个例子，一台有着坏磁盘的机器可能会在(读取磁盘时)频繁进行纠错，使得磁盘的读取性能从每秒30MB下降到每秒1MB。  
集群调度系统可能还将其它任务也调度到了这台机器上，由于CPU、内存、本地磁盘或网络带宽的竞争，使得MapReduce代码的执行变得更加的缓慢。  
我们最近遇到的一个问题是由机器初始化代码中的一个bug导致的，其禁用了处理器的缓存：受到影响的机器其计算速度(比正常情况下)慢了100倍以上。

We have a general mechanism to alleviate the problem of stragglers.  
When a MapReduce operation is close to completion, the master schedules backup executions of the remaining in-progress tasks.  
The task is marked as completed whenever either the primary or the backup execution completes.  
We have tuned this mechanism so that it typically increases the computational resources used by the operation by no more than a few percent.  
We have found that this significantly reduces the time to complete large MapReduce operations.  
As an example, the sort program described in Section 5.3 takes 44% longer to complete when the backup task mechanism is disabled.

我们有一个通用的机制来减轻“落伍者”问题带来的影响。  
当一个MapReduce运算接近完成时，master将会调度剩下的处理中的任务进行后备执行(backup executions)。  
无论是主执行完成还是后备执行完成，这些任务都会被标记为已完成。  
我们已对这个机制进行了优化，使得这一操作令所使用的计算资源增加通常不会超过几个百分点。  
我们发现这一操作明显减少了大型MapReduce操作的完成时间。  
例如，如果禁用后备任务这一机制，在5.3节中所述的排序程序将多花费44%的时间才能完成。

### 4 Refinements(改进)

Although the basic functionality provided by simply writing Map and Reduce functions is sufficient for most needs, we have found a few extensions useful.  
These are described in this section.

尽管已提供的编写简单Map和Reduce函数的功能能满足大多数需求，但我们还发现了一些有价值的拓展。  
本章节将对此进行介绍。

### 4.1 Partitioning Function(分区函数)

The users of MapReduce specify the number of reduce tasks/output files that they desire (R).  
Data gets partitioned across these tasks using a partitioning function on the intermediate key.  
A default partitioning function is provided that uses hashing (e.g. “hash(key) mod R”).  
This tends to result in fairly well-balanced partitions.  
In some cases, however, it is useful to partition data by some other function of the key.  
For example, sometimes the output keys are URLs, and we want all entries for a single host to end up in the same output file.  
To support situations like this, the user of the MapReduce library can provide a special partitioning function.  
For example, using “hash(Hostname(urlkey)) mod R” as the partitioning function causes all URLs from the same host to end up in the same output file.

MapReduce用户期望能指定reduce任务/输出文件的数量。  
在这些任务中，使用一个基于中间态key的分区函数对数据进行分区。  
(我们)提供了一个使用哈希取模的默认分区函数(例如：“hash(key) mod R”)。  
这往往会得到一个非常均衡的分区结果。  
然而在有些情况下，使用其它的一些基于key的分区函数对数据进行分区是很有用的。  
举个例子，有时(map任务)输出的key是URL，且我们希望同一个主机上的所有条目最后都写入同一个输出文件中。  
为了支持这种场景，MapReduce库的用户可以提供一个自定义的分区函数。  
举个例子，使用“hash(Hostname(urlkey)) mod R”作为分区函数，就可以使得来自同一个主机的所有URL(条目)最终都写入同一个输出文件中。

### 4.2 Ordering Guarantees(有序性保证)

We guarantee that within a given partition, the intermediate key/value pairs are processed in increasing key order.  
This ordering guarantee makes it easy to generate a sorted output file per partition,  
which is useful when the output file format needs to support efficient random access lookups by key,  
or users of the output find it convenient to have the data sorted.

我们保证在给定的分区内，中间态的k/v对是以中间态key值递增的顺序处理的。  
这一有序性保证使得能简单的为每个分区生成一个已排序的输出文件，  
当输出文件的格式需要支持基于key来进行高效随机查找时(这一机制)会很有价值,或者用户需要已经排好序的数据时会很方便。

### 4.3 Combiner Function(组合器函数)

In some cases, there is significant repetition in the intermediate keys produced by each map task,  
and the user-specified Reduce function is commutative and associative.  
A good example of this is the word counting example in Section 2.1.  
Since word frequencies tend to follow a Zipf distribution, each map task will produce hundreds or thousands of records of the form <the, 1>.  
All of these counts will be sent over the network to a single reduce task and then added together by the Reduce function to produce one number.  
We allow the user to specify an optional Combiner function that does partial merging of this data before it is sent over the network.

在一些情况下，每个map任务所生成的中间态key存在明显的重复，同时用户自定义的reduce函数具备可交换性和可结合性。  
2.1章节中的单词计数的示例程序就是一个很好的例子。  
由于单词出现的频率遵循齐夫分布(Zipf distribution)，因此每一个map任务都将生成几百或几千的形如<the,1>的记录。  
所有的这些计数将通过网络发送给一个单独的reduce任务，然后再通过reduce函数累加它们而生成一个数字。  
我们允许用户指定一个可选的Combiner函数,在数据通过网络发送前该函数将对数据进行不完全的合并。

The Combiner function is executed on each machine that performs a map task.  
Typically the same code is used to implement both the combiner and the reduce functions.  
The only difference between a reduce function and a combiner function is how the MapReduce library handles the output of the function.  
The output of a reduce function is written to the final output file.  
The output of a combiner function is written to an intermediate file that will be sent to a reduce task.

Combiner函数能在每一个执行map任务的机器上执行。  
通常情况下，combiner函数和reduce函数的代码实现是相同的。  
reduce函数和combiner函数间唯一的不同在于MapReduce是如何处理函数的输出。  
一个reduce函数的输出会写入最终的输出文件中。  
而一个combiner函数的输出会被写入到一个中间态的文件中，并且将会发送给reduce任务。

Partial combining significantly speeds up certain classes of MapReduce operations.  
Appendix A contains an example that uses a combiner.

部分合并可以明显加快某些MapReduce操作的速度。  
附录A中包含了一个使用combiner的例子。

### 4.4 Input and Output Types(输入和输出的类型)

The MapReduce library provides support for reading input data in several different formats.  
For example, “text” mode input treats each line as a key/value pair: the key is the offset in the file and the value is the contents of the line.  
Another common supported format stores a sequence of key/value pairs sorted by key.  
Each input type implementation knows how to split itself into meaningful ranges for processing as separate map tasks  
(e.g. text mode’s range splitting ensures that range splits occur only at line boundaries).  
Users can add support for a new input type by providing an implementation of a simple reader interface,  
though most users just use one of a small number of predefined input types.

MapReduce库为多种不同格式输入数据的读取提供了支持。  
例如，"文本"模式下将每一行的输入视为一个kv键值对：key是该行在文件中的偏移量，而value是该行的内容。  
另一种所支持的常用格式则存储基于key排序的一连串kv键值对。  
每一个输入类型的实现知道如何将输入的数据划分为有意义的区间，用以在一个独立的map任务中处理。  
(举个例子，文本模式划分区间时确保了只会在每一行的边界上出现区间的划分)  
通过提供一个简单的reader接口实现，用户可以增加支持一种新的输入类型，即使大多数用户只会使用一个或少数几个预定义的输入类型。

A reader does not necessarily need to provide data read from a file.  
For example, it is easy to define a reader that reads records from a database, or from data structures mapped in memory.

reader不一定只能通过读取文件来提供数据。  
举个例子，很容易定义一个reader去数据库中读取记录，或者从被映射在内存中的数据结构中读取数据。

In a similar fashion, we support a set of output types for producing data in different formats  
and it is easy for user code to add support for new output types.

类似的，我们也支持多种不同格式的输出数据，且用户代码中可以轻松地支持新增的一种新输出类型。

### 4.5 Side-effects(副作用)

In some cases, users of MapReduce have found it convenient to produce auxiliary files as additional outputs from their map and/or reduce operators.  
We rely on the application writer to make such side-effects atomic and idempotent.  
Typically the application writes to a temporary file and atomically renames this file once it has been fully generated.

在某些场景下，MapReduce的用户发现从他们的map或reduce操作中生成辅助文件作为额外的输出可以为其带来一些便利。  
我们依赖应用程序的作者(自己在程序中保证)使得这些副作用具有原子性和幂等性。  
通常，应用程序会(将额外的输出)写入一个临时文件，并且一旦完全生成该文件后便原子性的重命名这一文件。

We do not provide support for atomic two-phase commits of multiple output files produced by a single task.  
Therefore, tasks that produce multiple output files with cross-file consistency requirements should be deterministic.  
This restriction has never been an issue in practice.

我们没有为单个任务生成多个文件的场景提供原子性二阶段提交的支持。  
因此，会生成多个输出文件且具有跨文件一致性需求的任务应该是确定性的（任务是确定性函数算子）。  
在我们的实践中，这一限制并没有带来什么问题。

### 4.6 Skipping Bad Records(跳过错误的记录)

Sometimes there are bugs in user code that cause the Map or Reduce functions to crash deterministically on certain records.  
Such bugs prevent a MapReduce operation from completing.  
The usual course of action is to fix the bug, but sometimes this is not feasible; perhaps the bug is in a third-party library for which source code is unavailable.  
Also, sometimes it is acceptable to ignore a few records, for example when doing statistical analysis on a large data set.  
We provide an optional mode of execution where the MapReduce library detects which records cause deterministic crashes and skips these records in order to make forward progress.

有时用户的代码中存在一些bug，造成了Map或Reduce函数在处理某些数据时一定会崩溃。这些bug会阻止MapReduce操作的完成。  
通常的做法是修复这个bug，但有时这是行不通的；可能这个bug位于三方库中，且无法获得其源代码。  
当然，有时忽略掉少量的数据是可接受的，比如对一个大型数据集上进行统计分析时。  
我们提供了一个可选的执行模式，当MapReduce库检测到某些记录一定会导致崩溃时，跳过这些记录并继续向前推进。

Each worker process installs a signal handler that catches segmentation violations and bus errors.  
Before invoking a user Map or Reduce operation, the MapReduce library stores the sequence number of the argument in a global variable.  
If the user code generates a signal, the signal handler sends a “last gasp” UDP packet that contains the sequence number to the MapReduce master.  
When the master has seen more than one failure on a particular record, it indicates that the record should be skipped when it issues the next re-execution of the corresponding Map or Reduce task.

每个worker进程都安装了一个信号处理器，用于捕获段异常(segmentation violations)和总线错误(bus errors)。  
在调用用户的Map或Reduce操作前，MapReduce库会将参数的序列号存储在一个全局变量中。  
如果用户代码产生了一个信号，则信号处理器将会向MapReduce的master发送一个包含了(该参数)序列号的"最后喘息(last gasp)"UDP包。  
当master一个特定的记录不止一次的导致故障时，master会指示对应的Map或Reduce任务在下一次重新执行时应该跳过该记录。

### 4.7 Local Execution(本地执行)

Debugging problems in Map or Reduce functions can be tricky, since the actual computation happens in a distributed system,  
often on several thousand machines, with work assignment decisions made dynamically by the master.  
To help facilitate debugging, profiling, and small-scale testing, we have developed an alternative implementation of the MapReduce library  
that sequentially executes all of the work for a MapReduce operation on the local machine.  
Controls are provided to the user so that the computation can be limited to particular map tasks.  
Users invoke their program with a special flag and can then easily use any debugging or testing tools they find useful (e.g. gdb).

在实际计算发生在分布式系统中时，调试Map或Reduce函数会变得很棘手，通常由master动态的在几千台机器上决定工作的分配。  
为了更利于调试、分析和小规模的测试，我们开发了一个(运行在本地机器上的)MapReduce库的可替代实现，该库能让所有的MapReduce工作在本地机器上顺序执行。  
控制权被交给了用户,使得计算可以被限制在指定的Map任务中。  
用户通过一个特殊的标志来调用他们的程序，然后可以轻松地使用任何他们觉得好用的调试或者测试工具(例如：gdb)。

### 4.8 Status Information(状态信息)

The master runs an internal HTTP server and exports a set of status pages for human consumption.  
The status pages show the progress of the computation, such as how many tasks have been completed,  
how many are in progress, bytes of input, bytes of intermediate data, bytes of output, processing rates, etc.  
The pages also contain links to the standard error and standard output files generated by each task.  
The user can use this data to predict how long the computation will take, and whether or not more resources should be added to the computation.  
These pages can also be used to figure out when the computation is much slower than expected.

master机器运行了一个内置地Http服务器，并提供了一系列地状态信息页面供用户访问。  
状态信息页面会展示计算的进度，例如有多少任务已经完成，多少任务正在执行中，输入数据的字节数，中间数据的字节数，输出数据的字节数，处理速度等等信息。  
页面也包含了指向每个任务对应的标准误差(standard error)和标准输出文件的链接。  
用户可以使用这些数据预测还要多长时间完成计算，以及是否需要为该计算投入更多资源。  
这些页面也可用于找出为什么实际的计算比所预期的要慢的原因。

In addition, the top-level status page shows which workers have failed, and which map and reduce tasks they were processing when they failed.  
This information is useful when attempting to diagnose bugs in the user code.

此外，高级状态页面展示了哪些worker机器发生了故障，以及哪些map和reduce任务在执行时发生了故障。  
在尝试调试用户代码中的bug时这些信息会很有用。

### 4.9 Counters(计数器)

The MapReduce library provides a counter facility to count occurrences of various events.  
For example, user code may want to count total number of words processed or the number of German documents indexed, etc.

MapReduce库提供了一个计数器的功能，用于计数不同事件出现的次数。  
例如，用户代码可能会想要统计已经处理过的单词总数或者被编入德文文档的索引数等等。

To use this facility, user code creates a named counter object and then increments the counter appropriately in the Map and/or Reduce function.  
For example:

为了使用这一功能，用户代码中需要创建一个名为计数器的对象，然后在Map或Reduce函数中以恰当的方式对计数器进行累加操作。  
例如：

    Count* uppercase;
    uppercase = GetCounter("uppercase");
    
    map(String name, String contents) :
        for each word w in contents:
            if(isCapitalized(w)):
                uppercase->Increment();
            EmitIntermediate(w,"1");
    

The counter values from individual worker machines are periodically propagated to the master (piggybacked on the ping response).  
The master aggregates the counter values from successful map and reduce tasks and returns them to the user code when the MapReduce operation is completed.  
The current counter values are also displayed on the master status page so that a human can watch the progress of the live computation.  
When aggregating counter values, the master eliminates the effects of duplicate executions of the same map or reduce task to avoid double counting.  
(Duplicate executions can arise from our use of backup tasks and from re-execution of tasks due to failures.)

独立worker机器中的counter值会周期性的传递给master(在ping响应包中附带)  
master将来自已经成功完成的map和reduce任务中的counter值聚合在一起，并在MapReduce任务完成时返回给用户代码。  
当前的counter值也会展示在master的状态页上，使得用户可以看到实时的计算进度。  
在聚合counter值时，master消除了同一个map或reduce任务多次执行的影响，避免了重复计数。  
(多次执行出现的原因是我们的备份任务或任务故障时的重复执行导致的)

Some counter values are automatically maintained by the MapReduce library,  
such as the number of input key/value pairs processed and the number of output key/value pairs produced.

有些counter值是由MapReduce自行维护的，例如已处理的输入k/v对的数量和已生成的输出k/v对的数量。

Users have found the counter facility useful for sanity checking the behavior of MapReduce operations.  
For example, in some MapReduce operations, the user code may want to ensure that the number of output pairs produced exactly equals the number of input pairs processed,  
or that the fraction of German documents processed is within some tolerable fraction of the total number of documents processed.

用户发现计数器功能能很好的用于检查MapReduce操作的行为是否正常。  
例如，在某些MapReduce操作中，用户代码想要确保已生成的k/v对数量严格等于已处理的输入k/v对数量，或者确保已处理的德语文档数量在已处理的全部文档中的占比是否处于一个可接受的比例内。

### 5 Performance(性能)

In this section we measure the performance of MapReduce on two computations running on a large cluster of machines.  
One computation searches through approximately one terabyte of data looking for a particular pattern.  
The other computation sorts approximately one terabyte of data.

在这一章节，我们通过在大型机器集群上运行的两个MapReduce计算来测量MapReduce的性能。  
其中一个计算是在大约1TB的数据中检索特定的模式。  
另一个计算是对大约1TB的数据进行排序。

These two programs are representative of a large subset of the real programs written by users  
of MapReduce–one class of programs shuffles data from one representation to another,  
and another class extracts a small amount of interesting data from a large data set.

上述两个程序代表了现实中大多数MapReduce用户所编写的程序，一类程序将数据从一种表示方式转化为另一种表示方式，而另一类程序则从一个大的数据集中提取出少量感兴趣的数据。

### 5.1 Cluster Configuration(集群配置)

All of the programs were executed on a cluster that consisted of approximately 1800 machines.  
Each machine had two 2GHz Intel Xeon processors with Hyper-Threading enabled, 4GB of memory, two 160GB IDE disks, and a gigabit Ethernet link.  
The machines were arranged in a two-level tree-shaped switched network  
with approximately 100-200 Gbps of aggregate band-width available at the root.  
All of the machines were in the same hosting facility and therefore the round-trip time between any pair of machines was less than a millisecond.

所有的程序都在一个由大约1800台机器组成的集群上被执行。  
每台机器都配置有两颗开启了超线程功能的、2GHZ主频的Intel至强处理器，4GB的内存，两块160GB容量的IDE硬盘，以及一条千兆的以太网链路。  
所有机器都被安置在一个双层的树形交换网络中，根节点处的总可用网络带宽大概为100-200GB每秒。  
所有的机器都位于同一个主机托管设施(hosting facility)内，因此任意一对机器间的(网络交互的)往返时间都低于1毫秒。

Out of the 4GB of memory, approximately 1-1.5GB was reserved by other tasks running on the cluster.  
The programs were executed on a weekend afternoon, when the CPUs, disks, and network were mostly idle.

在4GB的内存中，大约1-1.5GB的内存是为集群上要运行的其它任务而保留的。  
任务是在周末的下午执行的，(因为)这个时间点CPU、硬盘和网络一般都是空闲的。

### 5.2 Grep(Globally search a Regular Expression and Print 基于正则表达式的全局搜索并打印)

The grep program scans through 10^10 100-byte records, searching for a relatively rare three-character pattern (the pattern occurs in 92,337 records).  
The input is split into approximately 64MB pieces (M = 15000), and the entire output is placed in one file (R = 1).

grep程序扫描通过扫描10^10个100字节大小的记录，搜索一个相对比较少见的3字符模式(这个模式只出现在92337条记录中)。  
输入数据被分割为大约64MB大小的块(M = 15000)，并且完整的输出被放在了一个文件中(R = 1)。

![Figure 2：Data transfer rate over time.png](https://img2022.cnblogs.com/blog/1506329/202209/1506329-20220923200905307-1399478456.png)

Figure 2 shows the progress of the computation over time.  
The Y-axis shows the rate at which the input data is scanned.  
The rate gradually picks up as more machines are assigned to this MapReduce computation,  
and peaks at over 30 GB/s when 1764 workers have been assigned.  
As the map tasks finish, the rate starts dropping and hits zero about 80 seconds into the computation.  
The entire computation takes approximately 150 seconds from start to finish.  
This includes about a minute of startup overhead. The overhead is due to the propagation of the program to all worker machines,  
and delays interacting with GFS to open the set of 1000 input files and to get the information needed for the locality optimization.

图二展示了随时间推移的计算进度。  
Y轴标识着扫描输入数据的速率。  
随着越来越多的机器被分配给当前MapReduce计算，扫描输入数据的速率也越来越快，并且当分配了1764个worker机器时其峰值达到了30GB每秒。  
当map任务完成后，扫描输入数据的速率开始下降并在计算执行到大约80秒的时候降至0。  
整个计算从开始到结束大概耗时150秒。  
这其中包括了一分钟左右的启动开销。  
这一开销是由于需要将程序分发到所有的worker机器上，以及为了打开1000个输入文件集合而与GFS交互并获得局部性优化信息的延迟。

### 5.3 Sort(排序)

The sort program sorts 10^10 100-byte records (approximately 1 terabyte of data).  
This program is modeled after the TeraSort benchmark.

这个排序程序对10^10个100字节大小的记录进行排序(大约1TB的数据)。  
这个程序是参照TeraSort基准测试程序而编写的。

The sorting program consists of less than 50 lines of user code.  
A three-line Map function extracts a 10-byte sorting key from a text line and emits the key  
and the original text line as the intermediate key/value pair.  
We used a built-in Identity function as the Reduce operator.  
This functions passes the intermediate key/value pair unchanged as the output key/value pair.  
The final sorted output is written to a set of 2-way replicated GFS files(i.e., 2 terabytes are written as the output of the program).

排序程序包含了少于50行的用户代码。  
一个三行的Map函数从一个文本行中提取出一个10字节大小的、用于排序的key并且发出该key，并将原始的文本行作为value而生成中间态的k/v键值对。  
我们使用内置的恒等函数(Identity function)作为Reduce算子。  
这个函数传入中间态的k/v键值对，并且不做任何修改的将之作为输出的k/v键值对。  
最终完成排序的输出被写入了一个双向复制的GFS文件集合中(即程序总共写入、输出了2TB的数据)。

As before, the input data is split into 64MB pieces(M = 15000).  
We partition the sorted output into 4000 files (R = 4000).  
The partitioning function uses the initial bytes of the key to segregate it into one of R pieces.

如上所述，输入的数据被分给为64MB的块(M = 15000)。  
我们将排好序后的输出数据分割为4000个文件(R = 4000)。  
分区函数基于key的初始字节值将其分割为R份。

Our partitioning function for this benchmark has built-in knowledge of the distribution of keys.  
In a general sorting program, we would add a pre-pass MapReduce operation  
that would collect a sample of the keys and use the distribution of the sampled keys to compute split-points for the final sorting pass.

我们的基准测试中内置的分区函数是了解key值具体分布的。  
在一个常规的排序程序中，我们会预先插入一个MapReduce操作，该操作将会收集key值的一个样本并且基于key值样本的分布情况来计算最终排序时需要的分割点。  
![figure3 Data transfer rates over time for different executions of the sort program.png](https://img2022.cnblogs.com/blog/1506329/202209/1506329-20220923200932216-401402020.png)

Figure 3 (a) shows the progress of a normal execution of the sort program.  
The top-left graph shows the rate at which input is read.  
The rate peaks at about 13 GB/s and dies off fairly quickly since all map tasks finish before 200 seconds have elapsed.  
Note that the input rate is less than for grep.  
This is because the sort map tasks spend about half their time and I/O bandwidth writing intermediate output to their local disks.  
The corresponding intermediate output for grep had negligible size.

图3的a部分展示了一个排序程序的正常执行过程。  
左上角的图表标识了输入数据读取的速率。  
输入数据速率的峰值为13GB每秒，由于所有的map任务都在200秒内完成了因此其非常快速地降到了零。  
请注意输入速率是小于上述地grep程序的。  
这是因为排序的map任务有一半的耗时和I/O带宽用于将的中间态的输出写入它们机器的本地磁盘。  
而相应的，grep任务的中间态输出则可以忽略不计。

The middle-left graph shows the rate at which data is sent over the network from the map tasks to the reduce tasks.  
This shuffling starts as soon as the first map task completes.  
The first hump in the graph is for the first batch of approximately 1700 reduce tasks  
(the entire MapReduce was assigned about 1700 machines, and each machine executes at most one reduce task at a time).  
Roughly 300 seconds into the computation, some of these first batch of reduce tasks finish and we start shuffling data for the remaining reduce tasks.  
All of the shuffling is done about 600 seconds into the computation.

左边排中间的图表标识了map任务通过网络将数据发送给reduce任务的速率。  
这一转换在第一个map任务完成不久后便开始了。  
图表中的第一个高峰对应着第一批的大约1700个reduce任务(整个MapReduce分配了1700台机器，并且每一台机器同一时间至多只能执行一个reduce任务)  
大概执行了300秒的计算时，第一批的一些reduce任务陆续完成并且剩余的reduce任务继续转换数据。  
所有的转换大概在计算执行了600秒时完成。

The bottom-left graph shows the rate at which sorted data is written to the final output files by the reduce tasks.  
There is a delay between the end of the first shuffling period  
and the start of the writing period because the machines are busy sorting the intermediate data.  
The writes continue at a rate of about 2-4 GB/s for a while. All of the writes finish about 850 seconds into the computation.  
Including startup overhead, the entire computation takes 891 seconds.  
This is similar to the current best reported result of 1057 seconds for the TeraSort benchmark.

左下方的图表标识了reduce任务将排序好的数据写入最终的输出文件的速率。  
在第一个转换(shuffling)阶段结束到开始写入之间存在一点延迟，其原因是机器此时正忙于对中间态的数据进行排序。  
写入数据的以2-4GB每秒的速率持续了一段时间。所有的写入大约在计算执行至850秒左右时完成。  
包括启动的开销在内，整个计算过程共耗时891秒。  
这与TeraSort基准测试目前已报告的最快记录很相近。

A few things to note: the input rate is higher than the shuffle rate and the output rate because of our locality optimization  
– most data is read from a local disk and bypasses our relatively bandwidth constrained network.  
The shuffle rate is higher than the output rate because the output phase writes two copies of the sorted data  
(we make two replicas of the output for reliability and availability reasons).  
We write two replicas because that is the mechanism for reliability and availability provided by our underlying file system.  
Network bandwidth requirements for writing data would be reduced if the underlying file system used erasure coding rather than replication.

有几点值得注意：

*   输入的速录比转换和输出的速率要高很多，其原因在于我们进行了局部性优化。大多数的数据是从本地的硬盘中读取的，从而避免使用我们相对有限的网络带宽。
*   转换速率比输出速率要高很多，其原因在于输出阶段写入了已排序数据的两个备份(出于可靠性和可用性的考虑，我们构建了两个输出数据的备份)。  
    我们写入两个备份的原因在于这是我们底层文件系统所提供的可靠性和可用性的机制。
*   如果底层文件系统使用纠错码(Erasure Coding)来代替复制(来保证可靠性)，则需要写入数据时所需要的网络带宽将减少很多。

### 5.4 Effect of Backup Tasks(后备任务的影响)

In Figure 3 (b), we show an execution of the sort program with backup tasks disabled.  
The execution flow is similar to that shown in Figure 3 (a), except that there is a very long tail where hardly any write activity occurs.  
After 960 seconds, all except 5 of the reduce tasks are completed.  
However these last few stragglers don’t finish until 300 seconds later.  
The entire computation takes 1283 seconds, an increase of 44% in elapsed time.

在图3的b部分，我们展示了禁用后备任务时排序程序的执行状况。  
执行流与图3的a部分很相似，除了最后面有一个非常长的尾部，且其几乎没有任何写入发生(注意观察代表done的那条竖线)。  
在960s后，除了5个reduce任务外其它任务都已经完成。  
然而最后几个“落伍者”任务直到300秒后才相继完成。整个计算过程共花费了1283秒，(相比正常执行的情况)增加了44%的耗时。

### 5.5 Machine Failures(机器故障)

In Figure 3 (c), we show an execution of the sort program  
where we intentionally killed 200 out of 1746 worker processes several minutes into the computation.  
The underlying cluster scheduler immediately restarted new worker processes on these machines  
(since only the processes were killed, the machines were still functioning properly).

在图3的c部分，我们展示了一个排序程序的执行流程，在其计算过程中我们故意在几分钟内杀死(killed)了1746台worker机器中的200台机器(的worker进程)。  
底层的集群调度器立即在这些机器上重新启动新的worker进程(因为只是杀掉了worker进程，机器依然是正常工作的)。

The worker deaths show up as a negative input rate since some previously completed map work disappears  
(since the corresponding map workers were killed) and needs to be redone.  
The re-execution of this map work happens relatively quickly.  
The entire computation finishes in 933 seconds including startup overhead (just an increase of 5% over the normal execution time).

worker进程被杀死时展示一个负的输入速率，因为之前已完成的任务失效了(因为对应的map worker被杀掉了)并且这些任务需要被重新执行。  
map任务的重新执行相对来说是比较快的。  
包括启动开销在内，整个计算过程共耗时933秒（相较于正常执行时的耗时，只增加了5%）

### 6 Experience(经验)

We wrote the first version of the MapReduce library in February of 2003, and made significant enhancements to it in August of 2003,  
including the locality optimization, dynamic load balancing of task execution across worker machines, etc.  
Since that time, we have been pleasantly surprised at how broadly applicable the MapReduce library has been for the kinds of problems we work on.  
It has been used across a wide range of domains within Google, including:

*   large-scale machine learning problems,
*   clustering problems for the Google News and Froogle products,
*   extraction of data used to produce reports of popular queries (e.g. Google Zeitgeist),
*   extraction of properties of web pages for new experiments and products  
    (e.g. extraction of geographical locations from a large corpus of web pages for localized search), and
*   large-scale graph computations.

我们于2003年2月编写了第一版的MapReduce库，并且在2003年的8月对其进行了重大改进，其中包括局部性优化、跨worker机器间任务执行的动态负载均衡等等。  
从那时起，我们惊喜的看到MapReduce库被广泛的应用于我们工作中所遇到的各种问题上。  
MapReduce库已在谷歌内的许多领域中被广泛的使用，其中包括：

*   大规模的机器学习问题
*   Google新闻和Froogle产品的聚类问题(clustering problems)
*   基于常见查询所产出的报告提取数据(例如，Google Zeitgeist (注：Google开发的一款网络查询分析程序))
*   基于新实验和产品的网页提取相关属性(例如，从用于本地化搜索的大型网页语料库中提取地理位置)
*   大规模的图计算

![Figure 4: MapReduce instances over time](https://img2022.cnblogs.com/blog/1506329/202209/1506329-20220923201052530-255973079.png)

![Table 1: MapReduce jobs run in August 2004.png](https://img2022.cnblogs.com/blog/1506329/202209/1506329-20220923201112728-857731529.png)

Figure 4 shows the significant growth in the number of separate MapReduce programs  
checked into our primary source code management system over time,  
from 0 in early 2003 to almost 900 separate instances as of late September 2004.  
MapReduce has been so successful because it makes it possible to write a simple program  
and run it efficiently on a thousand machines in the course of half an hour, greatly speeding up the development and prototyping cycle.  
Furthermore, it allows programmers who have no experience with distributed and/or parallel systems to exploit large amounts of resources easily.

图4展示了登记在我们主要的源码管理系统中的独立MapReduce程序数量随着时间的推移有着显著的增长，  
从2003年年初的0个,再到2004年的9月有了接近900个独立的MapReduce程序实例了。  
MapReduce如此成功的原因在于其使得编写一个简单的程序，并在半小时内于上千台机器上高效的运行成为了可能，这极大地加快了开发和原型设计的周期。  
此外，MapReduce允许没有任何分布式或并行系统开发经验的程序员得以轻松的利用大量的(计算)资源。

At the end of each job, the MapReduce library logs statistics about the computational resources used by the job.  
In Table 1, we show some statistics for a subset of MapReduce jobs run at Google in August 2004.

在每个job完成时，MapReduce库会以日志的形式记录对应job所使用的计算资源的统计信息。  
在表1中，我们展示了谷歌在2004年8月所运行的MapReduce job的一个子集的(所使用计算资源的)一些统计信息。

### 6.1 Large-Scale Indexing(大规模索引)

One of our most significant uses of MapReduce to date has been a complete rewrite  
of the production indexing system that produces the data structures used for the Google web search service.  
The indexing system takes as input a large set of documents that have been retrieved by our crawling system, stored as a set of GFS files.  
The raw contents for these documents are more than 20 terabytes of data.  
The indexing process runs as a sequence of five to ten MapReduce operations.  
Using MapReduce(instead of the ad-hoc distributed passes in the prior version of the indexing system) has provided several benefits:

迄今为止，我们对MapReduce最重要的一个应用就是完全重写了索引生成系统，其生成的数据结构被用于Google web的搜索服务。  
索引系统将我们的爬虫系统所检索到的、被存储为一系列GFS文件的大量文档作为输入。  
这些文档的原始内容的数据大小超过了20TB。  
整个索引处理过程由5到10个连续的MapReduce操作组成。  
使用MapReduce(而不是之前版本索引系统的点对点分布式传输)能带来几个好处:

*   The indexing code is simpler, smaller, and easier to understand, because the code that deals with fault tolerance,  
    distribution and parallelization is hidden within the MapReduce library.  
    For example, the size of one phase of the computation dropped from approximately 3800 lines of C++ code  
    to approximately 700 lines when expressed using MapReduce.

*   索引相关的代码变得更简单、(代码量)更少和更容易理解，因为处理容错、分布式和并行化的代码被隐藏在了MapReduce库内部。  
    例如，某一计算阶段的代码量在(改为)使用MapReduce表达后从(原来的)大约3800行c++代码降低至大约700行。

*   The performance of the MapReduce library is good enough that we can keep conceptually unrelated computations separate,  
    instead of mixing them together to avoid extra passes over the data.  
    This makes it easy to change the indexing process.  
    For example, one change that took a few months to make in our old indexing system took only a few days to implement in the new system.

*   MapReduce库的性能是足够好的，这使得我们可以将概念上无关的计算进行拆分，而不是将它们混合在一起，从而避免额外的数据传输。  
    这使得可以简单的改变索引的处理过程。  
    举个例子，在我们老的索引系统中曾进行的一次改动耗费了我们几个月的时间，而在新系统中去实现则只需要几天时间。

*   The indexing process has become much easier to operate, because most of the problems caused by machine failures, slow machines,  
    and networking hiccups are dealt with automatically by the MapReduce library without operator intervention.  
    Furthermore, it is easy to improve the performance of the indexing process by adding new machines to the indexing cluster.

*   处理索引变得更容易操作，因为大多数机器故障、机器执行缓慢和网络间歇性断开(networking hiccups)等问题都由MapReduce库自动处理了，而不需操作员介入。  
    此外，通过向索引处理的集群中添加新的机器可以轻松地提高索引处理的性能。

### 7 Related Work(相关工作)

Many systems have provided restricted programming models and used the restrictions to parallelize the computation automatically.  
For example,an associative function can be computed over all prefixes of an N element array in logN time  
on N processors using parallel prefix computations.  
MapReduce can be considered a simplification and distillation of some of these models based on our experience with large real-world computations.  
More significantly, we provide a fault-tolerant implementation that scales to thousands of processors.  
In contrast, most of the parallel processing systems have only been implemented  
on smaller scales and leave the details of handling machine failures to the programmer.

很多系统都提供了受限制的编程模型，并且使用这些约束来自动的将计算并行化。  
举个例子，使用并行前缀计算时，一个结合函数可以在N个处理器上，以logN的时间计算出一个N元素数组的所有前缀。  
MapReduce可以被认为是基于我们在现实世界中关于大型计算的经验所总结出的一些模型的一个简化和精炼。  
更重要的是，我们提供了一个可拓展到几千个处理器规模的容错实现。  
相比之下，大多数的并行处理系统的实现只能运用在更小的规模下，并且将处理机器故障的细节留给了程序员(去实现)。

Bulk Synchronous Programming and some MPI primitives provide higher-level abstractions that make it easier for programmers to write parallel programs.  
A key difference between these systems and MapReduce is that MapReduce exploits a restricted programming model  
to parallelize the user program automatically and to provide transparent fault-tolerance.

整体同步程序(Bulk Synchronous Programming)和一些消息传递接口(MPI Message-Passing Interface)原语提供了更高级别的抽象，使得程序员可以更加简单的编写并行程序。  
这些系统与MapReduce最关键的不同在于MapReduce利用一个受限的编程模型令用户程序自动的并行化并且了提供透明的(用户无需感知的)容错机制。

Our locality optimization draws its inspiration from techniques such as active disks, where computation is pushed into processing elements  
that are close to local disks, to reduce the amount of data sent across I/O subsystems or the network.  
We run on commodity processors to which a small number of disks are directly connected instead of running directly on disk controller processors,  
but the general approach is similar.

我们局部性优化机制的灵感源自active disks等技术，推进计算并使得所要处理的元素是靠近本地磁盘的，以减少通过网络I/O子系统发送的数据量。  
我们的计算运行在直连少量磁盘的商用处理器上，而不是直接运行在有着磁盘控制器的处理器(disk controller processors)上，但大致的方法是类似的。

Our backup task mechanism is similar to the eager scheduling mechanism employed in the Charlotte System.  
One of the shortcomings of simple eager scheduling is that if a given task causes repeated failures, the entire computation fails to complete.  
We fix some instances of this problem with our mechanism for skipping bad records.

我们的后备任务机制类似于Charlotte系统中所应用的紧急调度(eager scheduling)机制。  
简单的紧急调度机制的一个缺点就是如果一个给定的任务反复失败，则整个计算将无法完成。  
我们通过跳过有问题记录的机制，一定程度上的修复了这一问题。

The MapReduce implementation relies on an in-house cluster management system  
that is responsible for distributing and running user tasks on a large collection of shared machines.  
Though not the focus of this paper, the cluster management system is similar in spirit to other systems such as Condor.

MapReduce的实现依赖于一个内部的集群管理系统，该系统负责在大量的共享机器中分发和运行用户的任务。  
虽然这并不是本论文的重点，但该集群管理系统从本质上来说和Condor系统非常相似。

The sorting facility that is a part of the MapReduce library is similar in operation to NOW-Sort.  
Source machines (map workers) partition the data to be sorted and send it to one of R reduce workers.  
Each reduce worker sorts its data locally (in memory if possible).  
Of course NOW-Sort does not have the user-definable Map and Reduce functions that make our library widely applicable.

排序机制做为MapReduce库的一部分，在操作上与NOW-Sort类似。  
源机器(map workers)将待排序的数据进行分区，并将其发送给R个reduce worker中的一个。  
每一个reduce worker在本地对数据进行(尽可能的在内存中排序)。  
当然，NOW-Sort不支持使得可用户自定义的Map和Reduce函数，相比之下我们的MapReduce库则有着更广的适用范围。

River provides a programming model where processes communicate with each other by sending data over distributed queues.  
Like MapReduce, the River system tries to provide good average case performance  
even in the presence of non-uniformities introduced by heterogeneous hardware or system perturbations.  
River achieves this by careful scheduling of disk and network transfers to achieve balanced completion times.  
MapReduce has a different approach.  
By restricting the programming model, the MapReduce framework is able to partition the problem into a large number of fine-grained tasks.  
These tasks are dynamically scheduled on available workers so that faster workers process more tasks.  
The restricted programming model also allows us to schedule redundant executions of tasks near the end of the job  
which greatly reduces completion time in the presence of non-uniformities  
(such as slow or stuck workers).

River提供了一个编程模型，该模型中进程间通过向分布式队列中发送数据来进行通信。  
和MapReduce一样，即使由于异构的硬件或者系统扰动而导致了(计算资源的)不均衡，River系统也试图在这种场景下提供足够均衡的性能。  
River通过仔细的对磁盘和网络传输进行调度，用以实现任务完成时间的平衡。  
MapReduce则采用了不同的方法。  
通过受限的编程模型，MapReduce框架能够将一个问题分割为大量细粒度的任务。  
这些任务会在可用的worker机器上动态的调度，因此运行速度更快的worker能够处理更多的任务。  
这一受限的编程模型也允许我们在job接近完成时进行冗余任务的调度，这可以极大地减少在非均衡场景下的任务完成时间(比如存在缓慢或者卡住不动的worker)。

BAD-FS has a very different programming model from MapReduce, and unlike MapReduce,  
is targeted to the execution of jobs across a wide-area network.  
However, there are two fundamental similarities.  
Both systems use redundant execution to recover from data loss caused by failures.  
Both use locality-aware scheduling to reduce the amount of data sent across congested network links.

BAD-FS是一个与MapReduce非常不同的编程模型。与MapReduce不同，其致力于跨广域网的执行job。  
然而，这里有两个很相似的基本点。  
两个系统都使用冗余的执行来恢复由故障导致的数据丢失。  
两者都使用距离敏感的调度策略，用以减少在拥挤的网络链路上所发送数据的数量。

TACC is a system designed to simplify construction of highly-available networked services.  
Like MapReduce, it relies on re-execution as a mechanism for implementing fault-tolerance.

TACC是一个旨在简化高性能网络服务构造的框架。  
和MapReduce一样，其也依赖重复执行机制来实现故障容错。

### 8 Conclusions(总结)

The MapReduce programming model has been successfully used at Google for many different purposes.  
We attribute this success to several reasons.  
First, the model is easy to use, even for programmers without experience with parallel and distributed systems,  
since it hides the details of parallelization, fault-tolerance, locality optimization, and load balancing.  
Second, a large variety of problems are easily expressible as MapReduce computations.  
For example, MapReduce is used for the generation of data for Google’s production web search service,  
for sorting, for data mining, for machine learning, and many other systems.  
Third, we have developed an implementation of MapReduce that scales to large clusters of machines comprising thousands of machines.  
The implementation makes efficient use of these machine resources  
and therefore is suitable for use on many of the large computational problems encountered at Google.

MapReduce编程模型已经成功的在谷歌中被广泛应用。  
我们认为这一成功出于几个原因。  
首先，这一模型很容易使用，因为其隐藏了并行化、故障容错、局部性优化以及负载均衡的细节，即使是没有并行计算和分布式系统经验的程序员也能轻松地使用。  
其次，各种各样的问题都能用MapReduce计算轻松地表达。  
例如，MapReduce被用于为谷歌的网络搜索产品生成数据、也被用于排序、用于数据挖掘、用于机器学习以及其它的很多系统。  
再次，我们已开发的MapReduce实现可以被扩展到包含数千台机器的大型集群中。  
这一实现使得众多机器资源能被有效的利用，因此其很适合谷歌所遇到的许多大型计算问题。

We have learned several things from this work.  
First, restricting the programming model makes it easy to parallelize and distribute computations and to make such computations fault-tolerant.  
Second, network bandwidth is a scarce resource.  
A number of optimizations in our system are therefore targeted at reducing the amount of data sent across the network:  
the locality optimization allows us to read data from local disks,  
and writing a single copy of the intermediate data to local disk saves network bandwidth.  
Third, redundant execution can be used to reduce the impact of slow machines, and to handle machine failures and data loss.

我们从这项工作中学到了一些事情。  
首先，受限制的计算模型能够简化并行化和分布式计算，并且能够令这些计算具有容错性。  
其次，网络带宽是一种稀缺资源。  
因此我们的系统中有许多致力于减少在网络中传输数据数量的优化：局部性优化允许我们从本地磁盘中读取数据，以及将中间态数据的单个备份写入本地磁盘以节约网络带宽。  
再次，冗余的重复执行可以用于减少慢机器的影响，以及处理机器故障和数据丢失。

### Acknowledgements(致谢)

Josh Levenberg has been instrumental in revising and extending the user-level MapReduce API with a number of new features  
based on his experience with using MapReduce and other people’s suggestions for enhancements.  
MapReduce reads its input from and writes its output to the Google File System.  
We would like to thank Mohit Aron, Howard Gobioff, Markus Gutschke, David Kramer, Shun-Tak Leung, and Josh Redstone  
for their work in developing GFS.  
We would also like to thank Percy Liang and Olcan Sercinoglu for their work in developing the cluster management system used by MapReduce.  
Mike Burrows, Wilson Hsieh, Josh Levenberg, Sharon Perl, Rob Pike, and Debby Wallach provided helpful comments on earlier drafts of this paper.  
The anonymous OSDI reviewers, and our shepherd, Eric Brewer, provided many useful suggestions of areas where the paper could be improved.  
Finally, we thank all the users of MapReduce within Google’s engineering organization  
for providing helpful feedback, suggestions, and bug reports.

Josh Levenberg基于他使用MapReduce的经验以及其它人提出的优化建议，在修改MapReduce的用户级API和为其拓展很多新特性的过程中发挥了重要作用。  
MapReduce是基于谷歌文件系统GFS读取输入数据和写出输出数据的。  
我们要感谢Mohit Aron、Howard Gobioff、Markus Gutschke、David Kramer、Shun Tak Leung和Josh Redstone为开发GFS所做的工作。  
我们也要感谢Percy Liang和Olcan Sercinoglu为开发MapReduce集群管理系统所做的工作。  
Mike Burrows, Wilson Hsieh, Josh Levenberg, Sharon Perl, Rob Pike和Debby Wallach为这篇论文的前期草稿提供了很有帮助的建议。  
匿名的OSDI评论员和我们的审核者Eric Brewer就论文可以改进的方面提供了许多有用的建议。  
最后，我们感谢谷歌工程部的所有MapReduce用户，感谢他们提供的有价值的反馈、建议和bug报告。

### A Word Frequency(一个单词频率统计程序)

This section contains a program that counts the number of occurrences of each unique word in a set of input files specified on the command line.

这一章节包含了一个程序，用于计算由命令行指定的一组输入文件集合中每个唯一单词的出现次数。

    #include "mapreduce/mapreduce.h"
    // User’s map function 
    class WordCounter : public Mapper { 
        public: virtual void Map(const MapInput& input) { 
            const string& text = input.value(); const int n = text.size(); for (int i = 0; i < n; ) { 
                // Skip past leading whitespace 
                while ((i < n) && isspace(text[i])) 
                   i++;
                // Find word end 
                int start = i; 
                while ((i < n) && !isspace(text[i]))
                   i++;
                if (start < i) 
                   Emit(text.substr(start,i-start),"1");
            }
        }
    };   
    
    
    REGISTER_MAPPER(WordCounter);
    // User’s reduce function 
    class Adder : public Reducer { 
        virtual void Reduce(ReduceInput* input) { 
            // Iterate over all entries with the 
            // same key and add the values 
            int64 value = 0; 
            while (!input->done()) { 
                value += StringToInt(input->value()); 
                input->NextValue();
            }
            // Emit sum for input->key() 
            Emit(IntToString(value));
        }
    };
    
    REGISTER_REDUCER(Adder);
    int main(int argc, char** argv) { 
        ParseCommandLineFlags(argc, argv);
        MapReduceSpecification spec;
        // Store list of input files into "spec" 
        for (int i = 1; i < argc; i++) { 
            MapReduceInput* input = spec.add_input(); 
            input->set_format("text"); 
            input->set_filepattern(argv[i]); 
            input->set_mapper_class("WordCounter");
        }
        // Specify the output files: 
        // /gfs/test/freq-00000-of-00100 
        // /gfs/test/freq-00001-of-00100 
        // ... 
        MapReduceOutput* out = spec.output();
        out->set_filebase("/gfs/test/freq"); 
        out->set_num_tasks(100); 
        out->set_format("text"); 
        out->set_reducer_class("Adder");
        // Optional: do partial sums within map 
        // tasks to save network bandwidth 
        out->set_combiner_class("Adder");
    
    
        // Tuning parameters: use at most 2000 
        // machines and 100 MB of memory per task 
    
        spec.set_machines(2000); 
        spec.set_map_megabytes(100); 
        spec.set_reduce_megabytes(100);
    
        // Now run it 
        MapReduceResult result; 
        if (!MapReduce(spec, &result)) abort();
    
        // Done: ’result’ structure contains info
        // about counters, time taken, number of 
        // machines used, etc.
        return 0;
    }
    

##### 针对MapReduce强语义、弱语义概念译者自己的理解

(译者小熊餐馆注：  
上面这段内容比较晦涩，这里根据我举个简单的例子来帮助大家理解。  
假设有一段话：“Your name is Tom? My name is Tom, too.”，原始需求是想利用MapReduce计算统计分词后每个单词出现的次数(例子里句子很短是为了描述，实际上可以是海量的文档)。  
我们自定义的Map函数是确定性的函数算子，输入这个字符串进行Map操作后总是会返回以下9个kv对(key是单词，value是出现的次数): <Your,1>, <name,1>, <is,1>, <Tom,1>, <My,1>, <name,1>, <is,1>, <Tom,1>, <too,1>。  
无论Map函数是单机单线程顺序执行，还是在集群中并行的执行，结果都是明确不变的，也就是上述的强语义的概念。  
MapReduce库会把Key相同的kv对进行分组，并将其传递给我们自定义的reduce函数，下面是分组后会传给reduce函数算子的参数：  
<Tom,list(1,1)>, <name,list(1,1)>, <is,list(1,1)>, <Your,list(1)>, <My,list(1)>, <too,list(1)>。  
在原始需求下，当map函数计算的结果不变时，无论reduce函数算子何时执行，也无论出现故障重复执行了几次，得到的结果一定和单机单线程顺序执行相同，这也是强语义。  
结果：<Tom,2>, <name,2>, <is,2>, <Your,1>, <My,1>, <too,1>。 (key为单词，value为出现的次数)  
而如果改变原始需求，除了累加单词总共出现的次数还要返回reduce计算时的当前机器id。  
那么此时的reduce函数就属于不确定的函数算子了，因为即使输入相同，但每一次的执行获得的结果都不一定相等（调度到不同机器上执行，机器id不同，输出的结果也就不同）。  
假设有两台reduce任务worker，id分别为aaa和bbb。  
id为aaa的worker机器上reduce任务的执行结果就是<Tom,2-aaa>, <name,2-aaa>, <is,2-aaa>, <Your,1-aaa>, <My,1-aaa>, <too,1-aaa>,是为结果result\_aaa。  
id为bbb的worker机器上reduce任务的执行结果则是<Tom,2-bbb>, <name,2-bbb>, <is,2-bbb>, <Your,1-bbb>, <My,1-bbb>, <too,1-bbb>,是为结果result\_bbb。  
上述的弱语义表示，无论出现了什么机器故障，虽然无法准确的得知结果到底是哪一个，但最终结果不是result\_aaa就是result\_bbb，反正一定是某一个reduce任务生成的完整输出数据，而绝不可能出现跨任务的数据重复、冗余、缺失等问题。  
)

翻译过程中大量参考了以下大佬的文章，非常感谢  
[https://zhuanlan.zhihu.com/p/122571315](https://zhuanlan.zhihu.com/p/122571315)  
[https://blog.csdn.net/gqv2009/article/details/74674061](https://blog.csdn.net/gqv2009/article/details/74674061)  
[https://www.cnblogs.com/hehe520/p/6147464.html](https://www.cnblogs.com/hehe520/p/6147464.html)