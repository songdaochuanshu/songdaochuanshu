---
layout: post
title: "【机器学习】李宏毅——Recurrent Neural Network(循环神经网络)"
date: "2022-12-17T05:13:42.684Z"
---
【机器学习】李宏毅——Recurrent Neural Network(循环神经网络)
===========================================

![【机器学习】李宏毅——Recurrent Neural Network(循环神经网络)](https://img2023.cnblogs.com/blog/2966067/202212/2966067-20221217110512603-1152807945.png) 本文主要对循环神经网络的内部原理进行了阐述，包括多种常见模型

假设我们当前要做一个人工智能客服系统，那该系统就需要对用户输入的话语进行辨认，例如用户输入：

> I want to arrive Taipei on November 2nd

那么该系统就能够辨认出来Taipei是目的地，而后面是时间。那么我们可以用一个简单的前向网络来实现这个事情，输出为这个单词属于哪个含义的概率。但这会存在问题，例如输入以下：

> I want to leave Taipei on November 2nd

**同样输入都是Taipei，但是第一个句子是作为目的地，第二个句子是作为出发地，那么普通的前向网络是无法对同一个输出做出不同的输出的**。因此就希望此时使用的网络能够**具有一定的记忆性，即在看到Taipei之前因为已经读入了前一个词汇(arrive、leave)，那么就根据这前面的词汇来进行辅助判断**。

### RNN的结构特点

![在这里插入图片描述](https://img-blog.csdnimg.cn/0432acea585b408e9d6e3c290d733440.png#pic_center)

其主要的特点在于**每个隐含层的输出都会存放在一个另外的位置中(\\(a\_1,a\_2\\))，并且隐含层接受的输入包括原本的输入和当前存储记忆中的值**，假设权重都是1，那么该隐含层的输入就是\\(a\_1+a\_2+x\_1+x\_2\\)。并且在第一次输入的时候由于记忆中没有值因此需要赋予初始值。

而这样存在记忆的结构就使得**RNN对于输入的顺序是敏感的，不同的输入之间并不是独立的，它们顺序一旦变化就会引起输出的大不相同**。那么如果用RNN来处理之前的任务：

![在这里插入图片描述](https://img-blog.csdnimg.cn/ebc2b85499d34760af303967615e4897.png#pic_center)

**注意这里并不是用到了三个网络结构，而是同一个网络在不同的时间点被使用了三次**。那么这就可能使得**输入同样的词汇结果输出是不一样的，因为前面的输入也会影响该结果**。

而RNN同样也可以往deep发展：

![在这里插入图片描述](https://img-blog.csdnimg.cn/89409bcc4eb04f00b498b4860fbb5a9a.png#pic_center)

### RNN网络的变体

下面介绍RNN网络的变体：

#### Elman Network & Jordan Network

这两种网络都是RNN的推广，架构的主要区别在于：

*   Elman Network每个隐含层的记忆中存储的是该隐含层的输出，跟RNN是一样的
*   Jordan Network中**隐含层存储的都是前一个输入样本的输出\\(y^{t-1}\\)，这种网络架构具有更好的解释性因为输出我们知道它具有什么含义，而如果是隐含层的输出我们很难明确其含义，也就很难明确网络学习到什么东西**

#### Bidirectional RNN（双向）

这个结构的特点在于**对于网络的架构是双向的，即正向是跟前面一样，反向呢是从尾部不断读到头部（因为顺序不同输出也就不相同），然后再把每个对应的输出结合起来给输出层作为输入**，即将正向的\\(x^t\\)的输出和反向的\\(x^t\\)的输出一起作为输出层的输入得到真正输出\\(y^t\\)：

![在这里插入图片描述](https://img-blog.csdnimg.cn/565633da9b8a4a96adb2cd7655d9df54.png#pic_center)

那么这就导致在**在对每个输入做判断的时候，相当于综合了前后的所有信息来做判断**。

### Long Short-term Memory(LSTM)

顾名思义，就是具有比较长期记忆能力的RNN网络，前面的RNN 网络都是只要有了新的输入进来，记忆结点中就会被重写，但LSTM不一样，其主要特点的结构如下，其具有三个Gate

![在这里插入图片描述](https://img-blog.csdnimg.cn/41423f678a674f98bf378c96000d9c18.png#pic_center)

*   Input Gata：输入端的闸门，**在每次有新的输入进行神经网络后隐含层将会产生新的输出，而这个新的输出是否能够写入记忆结点中就取决于Input Gata，只有其是打开状态才能进行写入**
*   Ouput Gata：输出端的闸门，**只有当该闸门打开时，才能够读取其中的内容来作为隐含层的另一个输入**
*   Forget Gata：**该闸门控制什么时间点应该将当前记忆结点中的内容忘记掉**

上面各个Gata的打开和关闭都是网络自己学习到的。因此**每一个记忆结点就有四个输入（输入数值和三个控制信号）和一个输出**

下面来看其具体的运作行为：

![在这里插入图片描述](https://img-blog.csdnimg.cn/193e64d537264a128c2c5ea9e26df2ad.png#pic_center)

*   输出z经过激活函数g得到g(z)，然后Input Gata的输出\\(z\_i\\)经过激活函数(Gata的激活函数一般为sigmoid)得到\\(f(z\_i)\\)
*   原来记忆单元中的值为c，而Forget Gate的输出与c相乘，计算得到\\(c\`=g(z)f(z\_i)+cf(z\_f)\\)，作为记忆单元中信的存储值
*   记忆单元中的值经过h得到\\(h(c\`)\\)，再与输出单元的输出相乘并进行输出

**为什么采用Sigmoid函数来作为Gate的激活函数呢？因为它的输出在0到1之间，可以认为是该闸门打开的程度**。而这里可以看出ForgetGate打开的时候（输出为1）是对原来的值进行记忆的，只有关闭的时候才是对原来的值清零的。也可以看出**输出的值跟所有闸门的打开关闭是息息相关的**。这边所有Gate的输入都是学习得到的。

上面所说的只是单个结点，整体的网络就相当于**将神经元换成这整个记忆单元**，如下图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/0c78c963440c405783aa9ef43e03c36a.png#pic_center)

因此认为神经元数目相同时，**LSTM参数量是普通的四倍**。而实际上LSTM并不会这么简单：

![在这里插入图片描述](https://img-blog.csdnimg.cn/361c3f12de044284905b5da6a1cc23f1.png#pic_center)

可以认为**x是乘以了四个矩阵（权重矩阵）得到了四个向量，这四个向量的长度和该层LSTM记忆单元的数目一样，然后每一个作为LSTM的输入，因此刚好就四个输入，如上图**。因此如果多个串起来就是：

![在这里插入图片描述](https://img-blog.csdnimg.cn/4d876702c303448da37a2b99b49dad4a.png#pic_center)

但实际上仍不是LSTM的完全体，完全体如下：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/8865bd32fa6c44f2abb59e78de404e4f.png#pic_center)

就是**将上一层的输出和记忆单元当前的值和这一层的输入拼在一起作为输入**，再加上多层：

![在这里插入图片描述](https://img-blog.csdnimg.cn/3ea0338f359f4edd94d567d38091c649.png#pic_center)

**这就是LSTM的完全体了**。

### Loss Function

![在这里插入图片描述](https://img-blog.csdnimg.cn/c9e5e0ad7cda49c99e610bd79e35db40.png#pic_center)

**将输出的词性或者是标注作为目标向量，损失函数就是输出向量与目标向量的距离**。

### 学习算法Backpropagation through time(BPTT)

跟之前的网络一样，RNN对于网络参数的学习仍然是采用梯度下降的方式。而为了高效的计算梯度就有了BPTT这个算法（课程没有介绍这部分）。

但是RNN的训练并不容易：

![在这里插入图片描述](https://img-blog.csdnimg.cn/b879283dad2145c9b420a8702e3e2813.png#pic_center)

这是因为它的损失函数非常地特殊：

![在这里插入图片描述](https://img-blog.csdnimg.cn/caea69309565427ca2f0be1b75c016f2.png#pic_center)

这就导致损失函数计算梯度的时候经常跳动，总体损失也剧烈变化。而实际上做法**可以将梯度设置一个阈值，超过则默认为阈值就可以了，不然可能会陡峭导致梯度无穷大**。为什么会有上面这么陡峭的损失函数呢？来看下图的结构：

![在这里插入图片描述](https://img-blog.csdnimg.cn/e4c3f3b79ae34257a6410dd140b8f52c.png#pic_center)

**在很小的区间内，权重非常微小的变化就会导致输出剧烈的变化，因此很难通过学习率来应对**。这主要是因为同一个参数在不同的时间点多次被使用所导致的。

**而如果将RNN换成LSTM，它可以解决上述出现的梯度消失（Gradient vanishing）的问题，这可能会在面试中提及**。

#### 为什么LSTM可以解决梯度消失的问题

*   **RNN里面每一轮都会使得记忆结点中的值被清洗掉，而在LSTM中可以认为其记忆结点中的值是与输入进行累加的。因此可以认为一旦权重变化会导致记忆结点中的值发生变化，这个变化就会一直存在（除非Forget Gate决定将其洗掉，这是很少数的情况），因此除非ForgetGate关闭，否则都不会有Gradient vanishing 的问题**。RNN中由于每次都清洗，因为可以认为权重的变化而引起的最终结果的变化时剧烈的，而LSTM是在原来有的基础上做变化，这就可以中和掉一些。

或者可以采用GRU，其只有两个gate，更简单但是表现也不差