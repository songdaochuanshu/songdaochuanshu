---
layout: post
title: "浅析Nordic nRF5 SDK例程架构"
date: "2023-04-08T01:03:18.039Z"
---
浅析Nordic nRF5 SDK例程架构
=====================

很多刚接触Nordic nRF5 SDK的初学者出于对新平台的不熟悉，会觉得这个SDK很难，本文讲浅析nRF5 SDK中例程的架构，让初学者能够快速上手SDK。

在开始之前，先推荐阅读观看下面这些文章和视频，这些文章和视频都出自Nordic中国区的FAE，强烈推荐。

1、【\[nRF5\] nRF5 SDK Getting Start-哔哩哔哩】 [https://b23.tv/FxfJBVW](https://b23.tv/FxfJBVW) 

2、【Nordic nRF5 SDK和softdevice介绍】[https://www.cnblogs.com/iini/p/9095551.html](https://www.cnblogs.com/iini/p/9095551.html)

3、【nRF5 SDK软件架构及softdevice工作原理】[https://www.cnblogs.com/iini/p/9332463.html](https://www.cnblogs.com/iini/p/9332463.html)

其实在【nRF5 SDK软件架构及softdevice工作原理】这篇文章中已经总结了SDK的软件架构，这里我直接引用出来：

“当我们开发Nordic平台的BLE应用时，主要需要做两件事：

1.  第1件事：初始化。为了简化初始化工作，Nordic SDK所有模块初始化时，只需要将相应API输入结构体参数清0即可完成初始化工作，也就是说，只要你保证初始化参数为0，蓝牙协议栈就可以工作起来，这对很多Nordic初学者来说，大大减轻了开发工作量。
2.  第2件事：写蓝牙事件回调处理函数。一般来说，你的应用逻辑都是放在蓝牙事件回调处理函数中，所以写好回调处理函数代码，你的开发工作就完成了大半了。”

本文将通过介绍 bsp 和 ble\_app\_uart 这两个例程来分析nRF5 SDK的例程架构，这两个例程可以在nRF5\_SDK\_17.1.0\_ddde560\\examples\\peripheral和nRF5\_SDK\_17.1.0\\examples\\ble\_peripheral下找到。

一、bsp 例程浅析

bsp是不带协议栈的裸机例程，所以main函数非常简单，下面具体分析一下这几个函数的作用。

int main(void)
{
    clock\_initialization();

    uint32\_t err\_code \= app\_timer\_init();
    APP\_ERROR\_CHECK(err\_code);

    APP\_ERROR\_CHECK(NRF\_LOG\_INIT(NULL));
    NRF\_LOG\_DEFAULT\_BACKENDS\_INIT();

    NRF\_LOG\_INFO("BSP example started.");
    bsp\_configuration();

    while (true)
    {
        NRF\_LOG\_FLUSH();
        \_\_SEV();
        \_\_WFE();
        \_\_WFE();
        // no implementation needed
    }
}

1、clock\_initialization是直接通过配置寄存器来配置低频时钟，这里是使用了外部32.768kHz晶振做为时钟源。需要注意的是，因为bsp是不带协议栈的裸机工程，所以如果用到低频时钟源的时候，需要对其初始化。

/\*\*@brief Function for initializing low frequency clock.
 \*/
void clock\_initialization()
{
    NRF\_CLOCK\->LFCLKSRC            = (CLOCK\_LFCLKSRC\_SRC\_Xtal << CLOCK\_LFCLKSRC\_SRC\_Pos);
    NRF\_CLOCK\->EVENTS\_LFCLKSTARTED = 0;
    NRF\_CLOCK\->TASKS\_LFCLKSTART    = 1;

    while (NRF\_CLOCK->EVENTS\_LFCLKSTARTED == 0)
    {
        // Do nothing.
    }
}

在带协议栈的例程中，因为协议栈会用到低频时钟源。协议栈初始化的时候调用了nrf\_sdh\_enable\_request，我们可以从该函数中看到在sd\_softdecice\_enable写入低频时钟配置对低频时钟源进行了初始化，所以在带协议栈的例程中只要初始化协议栈即可，不用再初始化低频时钟源。

ret\_code\_t nrf\_sdh\_enable\_request(void)
{
    ret\_code\_t ret\_code;

    if (m\_nrf\_sdh\_enabled)
    {
        return NRF\_ERROR\_INVALID\_STATE;
    }

    m\_nrf\_sdh\_continue \= true;

    // Notify observers about SoftDevice enable request.
    if (sdh\_request\_observer\_notify(NRF\_SDH\_EVT\_ENABLE\_REQUEST) == NRF\_ERROR\_BUSY)
    {
        // Enable process was stopped.
        return NRF\_SUCCESS;
    }

    // Notify observers about starting SoftDevice enable process.
    sdh\_state\_observer\_notify(NRF\_SDH\_EVT\_STATE\_ENABLE\_PREPARE);
　　//配置低频时钟的参数
    nrf\_clock\_lf\_cfg\_t const clock\_lf\_cfg =
    {
        .source       \= NRF\_SDH\_CLOCK\_LF\_SRC,
        .rc\_ctiv      \= NRF\_SDH\_CLOCK\_LF\_RC\_CTIV,
        .rc\_temp\_ctiv \= NRF\_SDH\_CLOCK\_LF\_RC\_TEMP\_CTIV,
        .accuracy     \= NRF\_SDH\_CLOCK\_LF\_ACCURACY
    };

    CRITICAL\_REGION\_ENTER();
#ifdef ANT\_LICENSE\_KEY
    ret\_code \= sd\_softdevice\_enable(&clock\_lf\_cfg, app\_error\_fault\_handler, ANT\_LICENSE\_KEY);
#else
    ret\_code \= sd\_softdevice\_enable(&clock\_lf\_cfg, app\_error\_fault\_handler);
#endif
    m\_nrf\_sdh\_enabled \= (ret\_code == NRF\_SUCCESS);
    CRITICAL\_REGION\_EXIT();

    if (ret\_code != NRF\_SUCCESS)
    {
        return ret\_code;
    }

    m\_nrf\_sdh\_continue  \= false;
    m\_nrf\_sdh\_suspended \= false;

    // Enable event interrupt.
    // Interrupt priority has already been set by the stack.
    softdevices\_evt\_irq\_enable();

    // Notify observers about a finished SoftDevice enable process.
    sdh\_state\_observer\_notify(NRF\_SDH\_EVT\_STATE\_ENABLED);

    return NRF\_SUCCESS;
}

 完成低频时钟的配置后，接下来是调用 app\_timer\_init 对定时器进行初始化。这个函数是Nordic的库中已经封装好的函数，所以在main直接调用即可，nRF52系列有 Timer0-Timer4 一共5个Timer可以用，这里需要注意的是协议栈开启后会占用Timer0。

![](https://img2023.cnblogs.com/blog/2936392/202304/2936392-20230404143157540-995316881.png)

 这里推荐阅读Nordic中国区FAE写的一篇文章，详细介绍了app\_timer的用法和常见问题：[https://www.cnblogs.com/iini/p/9347460.html](https://www.cnblogs.com/iini/p/9347460.html)

2、NRF\_LOG\_INIT 和 NRF\_LOG\_DEFAULT\_BACKENDS\_INIT 的作用是Log模块初始化，调用这两个函数之后，就可以在代码中调用 NRF\_LOG\_INFO、NRF\_LOG\_ERROR、NRF\_LOG\_WARNING、NRF\_LOG\_DEBUG 这几个函数来打印LOG。Noridc在SDK的代码中通过上述的四个LOG等级写入了大量的日志，通过打印不同级别的LOG日志，可以帮助开发者调试和快速找到代码不合理的设计导致的出错。

关于如何调试Debug问题，可以参考Nordic中国区FAE的文章 [https://www.cnblogs.com/iini/p/9279618.html](https://www.cnblogs.com/iini/p/9279618.html)

我们也可以在bsp的main函数中看到，LOG模块初始化完成后，调用NRF\_LOG\_INFO打印了“BSP example started.”

3、接下来就是bsp的初始化，这里也是调用了SDK中的库函数bsp\_init，在里面写入了两个参数。

/\*\*@brief Function for initializing bsp module.
 \*/
void bsp\_configuration()
{
    uint32\_t err\_code;

    err\_code \= bsp\_init(BSP\_INIT\_LEDS | BSP\_INIT\_BUTTONS, bsp\_evt\_handler);
    APP\_ERROR\_CHECK(err\_code);
}

bsp\_init的函数定义在bsp.h中，查看其注释可以知道两个入参分别是使用外设的类型和回调函数。在main 中 BSP\_INIT\_LEDS 和 BSP\_INIT\_BUTTONS 分别是对LED和BUTTON进行了初始化。

/\*\*@brief       Function for initializing BSP.
 \*
 \* @details     The function initializes the board support package to allow state indication and
 \*              button reaction. Default events are assigned to buttons.
 \* @note        Before calling this function, you must initiate the following required modules:
 \*              - @ref app\_timer for LED support
 \*              - @ref app\_gpiote for button support
 \*
 \* @param\[in\]   type               Type of peripherals used.
 \* @param\[in\]   callback           Function to be called when button press/event is detected.
 \*
 \* @retval      NRF\_SUCCESS               If the BSP module was successfully initialized.
 \* @retval      NRF\_ERROR\_INVALID\_STATE   If the application timer module has not been initialized.
 \* @retval      NRF\_ERROR\_NO\_MEM          If the maximum number of timers has already been reached.
 \* @retval      NRF\_ERROR\_INVALID\_PARAM   If GPIOTE has too many users.
 \* @retval      NRF\_ERROR\_INVALID\_STATE   If button or GPIOTE has not been initialized.
 \*/
uint32\_t bsp\_init(uint32\_t type, bsp\_event\_callback\_t callback);

下面我们来看看bsp的回调函数bsp\_evt\_handler，在回调中使用了按键中断，DK板上的Button1和Button2按下的时候，会产生相对应的事件。

/\*\*@brief Function for handling bsp events.
 \*/
void bsp\_evt\_handler(bsp\_event\_t evt)
{
    uint32\_t err\_code;
    switch (evt)
    {
        case BSP\_EVENT\_KEY\_0:
            if (actual\_state != BSP\_INDICATE\_FIRST)
                actual\_state\--;
            else
                actual\_state \= BSP\_INDICATE\_LAST;
            break;

        case BSP\_EVENT\_KEY\_1:

            if (actual\_state != BSP\_INDICATE\_LAST)
                actual\_state++;
            else
                actual\_state \= BSP\_INDICATE\_FIRST;
            break;

        default:
            return; // no implementation needed
    }
    err\_code \= bsp\_indication\_set(actual\_state);
    NRF\_LOG\_INFO("%s", (uint32\_t)indications\_list\[actual\_state\]);
    APP\_ERROR\_CHECK(err\_code);
}

我们可以在bsp\_event\_t中找到全部bsp事件。

/\*\*@brief BSP events.  
\*  
\* @note Events from BSP\_EVENT\_KEY\_0 to BSP\_EVENT\_KEY\_LAST are by default assigned to buttons.  
\*/

typedef enum
{
    BSP\_EVENT\_NOTHING \= 0,                  /\*\*< Assign this event to an action to prevent the action from generating an event (disable the action). \*/
    BSP\_EVENT\_DEFAULT,                      /\*\*< Assign this event to an action to assign the default event to the action. \*/
    BSP\_EVENT\_CLEAR\_BONDING\_DATA,           /\*\*< Persistent bonding data should be erased. \*/
    BSP\_EVENT\_CLEAR\_ALERT,                  /\*\*< An alert should be cleared. \*/
    BSP\_EVENT\_DISCONNECT,                   /\*\*< A link should be disconnected. \*/
    BSP\_EVENT\_ADVERTISING\_START,            /\*\*< The device should start advertising. \*/
    BSP\_EVENT\_ADVERTISING\_STOP,             /\*\*< The device should stop advertising. \*/
    BSP\_EVENT\_WHITELIST\_OFF,                /\*\*< The device should remove its advertising whitelist. \*/
    BSP\_EVENT\_BOND,                         /\*\*< The device should bond to the currently connected peer. \*/
    BSP\_EVENT\_RESET,                        /\*\*< The device should reset. \*/
    BSP\_EVENT\_SLEEP,                        /\*\*< The device should enter sleep mode. \*/
    BSP\_EVENT\_WAKEUP,                       /\*\*< The device should wake up from sleep mode. \*/
    BSP\_EVENT\_SYSOFF,                       /\*\*< The device should enter system off mode (without wakeup). \*/
    BSP\_EVENT\_DFU,                          /\*\*< The device should enter DFU mode. \*/
    BSP\_EVENT\_KEY\_0,                        /\*\*< Default event of the push action of BSP\_BUTTON\_0 (only if this button is present). \*/
    BSP\_EVENT\_KEY\_1,                        /\*\*< Default event of the push action of BSP\_BUTTON\_1 (only if this button is present). \*/
    BSP\_EVENT\_KEY\_2,                        /\*\*< Default event of the push action of BSP\_BUTTON\_2 (only if this button is present). \*/
    BSP\_EVENT\_KEY\_3,                        /\*\*< Default event of the push action of BSP\_BUTTON\_3 (only if this button is present). \*/
    BSP\_EVENT\_KEY\_4,                        /\*\*< Default event of the push action of BSP\_BUTTON\_4 (only if this button is present). \*/
    BSP\_EVENT\_KEY\_5,                        /\*\*< Default event of the push action of BSP\_BUTTON\_5 (only if this button is present). \*/
    BSP\_EVENT\_KEY\_6,                        /\*\*< Default event of the push action of BSP\_BUTTON\_6 (only if this button is present). \*/
    BSP\_EVENT\_KEY\_7,                        /\*\*< Default event of the push action of BSP\_BUTTON\_7 (only if this button is present). \*/
    BSP\_EVENT\_KEY\_LAST \= BSP\_EVENT\_KEY\_7,
} bsp\_event\_t;

在 bsp 原始例程中的bsp回调函数中，按下Button1是倒序显示bsp\_indication\_t这个结构体中定义好的LED状态并在串口打印bsp\_indication\_t中的事件。

/\*\*@brief BSP indication states.
 \*
 \* @details See @ref examples\_bsp\_states for a list of how these states are indicated for the PCA10028/PCA10040 board and the PCA10031 dongle.
 \*/
typedef enum
{
    BSP\_INDICATE\_FIRST \= 0,
    BSP\_INDICATE\_IDLE  \= BSP\_INDICATE\_FIRST, /\*\*< See \\ref BSP\_INDICATE\_IDLE.\*/
    BSP\_INDICATE\_SCANNING,                   /\*\*< See \\ref BSP\_INDICATE\_SCANNING.\*/
    BSP\_INDICATE\_ADVERTISING,                /\*\*< See \\ref BSP\_INDICATE\_ADVERTISING.\*/
    BSP\_INDICATE\_ADVERTISING\_WHITELIST,      /\*\*< See \\ref BSP\_INDICATE\_ADVERTISING\_WHITELIST.\*/
    BSP\_INDICATE\_ADVERTISING\_SLOW,           /\*\*< See \\ref BSP\_INDICATE\_ADVERTISING\_SLOW.\*/
    BSP\_INDICATE\_ADVERTISING\_DIRECTED,       /\*\*< See \\ref BSP\_INDICATE\_ADVERTISING\_DIRECTED.\*/
    BSP\_INDICATE\_BONDING,                    /\*\*< See \\ref BSP\_INDICATE\_BONDING.\*/
    BSP\_INDICATE\_CONNECTED,                  /\*\*< See \\ref BSP\_INDICATE\_CONNECTED.\*/
    BSP\_INDICATE\_SENT\_OK,                    /\*\*< See \\ref BSP\_INDICATE\_SENT\_OK.\*/
    BSP\_INDICATE\_SEND\_ERROR,                 /\*\*< See \\ref BSP\_INDICATE\_SEND\_ERROR.\*/
    BSP\_INDICATE\_RCV\_OK,                     /\*\*< See \\ref BSP\_INDICATE\_RCV\_OK.\*/
    BSP\_INDICATE\_RCV\_ERROR,                  /\*\*< See \\ref BSP\_INDICATE\_RCV\_ERROR.\*/
    BSP\_INDICATE\_FATAL\_ERROR,                /\*\*< See \\ref BSP\_INDICATE\_FATAL\_ERROR.\*/
    BSP\_INDICATE\_ALERT\_0,                    /\*\*< See \\ref BSP\_INDICATE\_ALERT\_0.\*/
    BSP\_INDICATE\_ALERT\_1,                    /\*\*< See \\ref BSP\_INDICATE\_ALERT\_1.\*/
    BSP\_INDICATE\_ALERT\_2,                    /\*\*< See \\ref BSP\_INDICATE\_ALERT\_2.\*/
    BSP\_INDICATE\_ALERT\_3,                    /\*\*< See \\ref BSP\_INDICATE\_ALERT\_3.\*/
    BSP\_INDICATE\_ALERT\_OFF,                  /\*\*< See \\ref BSP\_INDICATE\_ALERT\_OFF.\*/
    BSP\_INDICATE\_USER\_STATE\_OFF,             /\*\*< See \\ref BSP\_INDICATE\_USER\_STATE\_OFF.\*/
    BSP\_INDICATE\_USER\_STATE\_0,               /\*\*< See \\ref BSP\_INDICATE\_USER\_STATE\_0.\*/
    BSP\_INDICATE\_USER\_STATE\_1,               /\*\*< See \\ref BSP\_INDICATE\_USER\_STATE\_1.\*/
    BSP\_INDICATE\_USER\_STATE\_2,               /\*\*< See \\ref BSP\_INDICATE\_USER\_STATE\_2.\*/
    BSP\_INDICATE\_USER\_STATE\_3,               /\*\*< See \\ref BSP\_INDICATE\_USER\_STATE\_3.\*/
    BSP\_INDICATE\_USER\_STATE\_ON,              /\*\*< See \\ref BSP\_INDICATE\_USER\_STATE\_ON.\*/
    BSP\_INDICATE\_LAST \= BSP\_INDICATE\_USER\_STATE\_ON
} bsp\_indication\_t;

4、最后就是while死循环中的函数，NRF\_LOG\_FLUSH是用来处理缓存中的LOG，\_\_SEV() 和 \_\_WFE() 是ARM的指令，用来上报事件和在低功耗下等待事件发生。

    while (true)
    {
        NRF\_LOG\_FLUSH();
        \_\_SEV();
        \_\_WFE();
        \_\_WFE();
        // no implementation needed
    }

5、练习：

原始 bsp 例程中的bsp回调函数对于初学者而言不太友好，我们可以写一个简单的 bsp 回调函数，在按下DK板上对应的按键1-4的时候，在RTT打印相应的Log。

void bsp\_evt\_handler(bsp\_event\_t evt)
{
    switch (evt)
    {
        case BSP\_EVENT\_KEY\_0:
            NRF\_LOG\_INFO("Button 1 is pressed");
            break;

        case BSP\_EVENT\_KEY\_1:
            NRF\_LOG\_INFO("Button 2 is pressed");
            break;

        case BSP\_EVENT\_KEY\_2:
            NRF\_LOG\_INFO("Button 3 is pressed");
            break;

        case BSP\_EVENT\_KEY\_3:
            NRF\_LOG\_INFO("Button 4 is pressed");
            break;

         
        default:
            return;
    }
}

将 bsp 例程中的 bsp\_evt\_handler 替换为上面的代码，编译并下载到DK中，打开串口工具，按下对应的按键就可以看到串口打印相应的LOG。

![](https://img2023.cnblogs.com/blog/2936392/202304/2936392-20230404165022743-1876690968.png)

 小结：熟悉了 bsp 这个例程，我们再去看examples\\ble\_peripheral下其他的外设例程，就会发现架构是相同的，都是先初始化外设，写入外设的配置参数，然后再根据相应事件结构体中给出的事件编写回调函数，在回调中处理中断发生时要做的事即可。

二、ble\_app\_uart 例程浅析

ble\_app\_uart 是带协议栈的一个例程，此例程是一个较为实用的例程，它使用了NUS服务（Nordic UATR Service）可以通过串口实现蓝牙的上下行收发数据，因此只要改变发送的外设，就可以改为其他外设，如SPI或者I2C来收发数据。熟悉了 bsp 例程，你就会发现 ble\_app\_uart 例程是一个放大版的 bsp 例程，下面我们将分析这个例程。

1、首先来看main函数，从这个例程中就更可以看出NRF5 SDK的例程软件架构，在main中初始化了所有的功能模块，然后在初始化中配置相应模块的回调，当回调中的事件触发时来做中断处理。

int main(void)
{
    bool erase\_bonds;

    // Initialize.
    uart\_init();
    log\_init();
    timers\_init();
    buttons\_leds\_init(&erase\_bonds);
    power\_management\_init();
    ble\_stack\_init();
    gap\_params\_init();
    gatt\_init();
    services\_init();
    advertising\_init();
    conn\_params\_init();

    // Start execution.
    printf("\\r\\nUART started.\\r\\n");
    NRF\_LOG\_INFO("Debug logging for UART over RTT started.");
    advertising\_start();

    // Enter main loop.
    for (;;)
    {
        idle\_state\_handle();
    }
}

2、第一个函数 uart\_init 中是定义了串口相关的一些参数，如串口引脚、流控、波特率等参数，然后把这些参数写入APP\_UART\_FIFO\_INIT来初始化串口。

/\*\*@brief  Function for initializing the UART module.
 \*/
/\*\*@snippet \[UART Initialization\] \*/
static void uart\_init(void)
{
    uint32\_t                     err\_code;
    app\_uart\_comm\_params\_t const comm\_params =
    {
        .rx\_pin\_no    \= RX\_PIN\_NUMBER,
        .tx\_pin\_no    \= TX\_PIN\_NUMBER,
        .rts\_pin\_no   \= RTS\_PIN\_NUMBER,
        .cts\_pin\_no   \= CTS\_PIN\_NUMBER,
        .flow\_control \= APP\_UART\_FLOW\_CONTROL\_DISABLED,
        .use\_parity   \= false,
#if defined (UART\_PRESENT)
        .baud\_rate    \= NRF\_UART\_BAUDRATE\_115200
#else
        .baud\_rate    \= NRF\_UARTE\_BAUDRATE\_115200
#endif
    };

    APP\_UART\_FIFO\_INIT(&comm\_params,
                       UART\_RX\_BUF\_SIZE,
                       UART\_TX\_BUF\_SIZE,
                       uart\_event\_handle,
                       APP\_IRQ\_PRIORITY\_LOWEST,
                       err\_code);
    APP\_ERROR\_CHECK(err\_code);
}

APP\_UART\_FIFO\_INIT的定义如下，要初始化串口需要写入五个参数，串口相关参数的结构体、RX和TX的buffer大小、回调函数、IRQ优先级。

/\*\*@brief Macro for safe initialization of the UART module in a single user instance when using
 \*        a FIFO together with UART.
 \*
 \* @param\[in\]   P\_COMM\_PARAMS   Pointer to a UART communication structure: app\_uart\_comm\_params\_t
 \* @param\[in\]   RX\_BUF\_SIZE     Size of desired RX buffer, must be a power of 2 or ZERO (No FIFO).
 \* @param\[in\]   TX\_BUF\_SIZE     Size of desired TX buffer, must be a power of 2 or ZERO (No FIFO).
 \* @param\[in\]   EVT\_HANDLER     Event handler function to be called when an event occurs in the
 \*                              UART module.
 \* @param\[in\]   IRQ\_PRIO        IRQ priority, app\_irq\_priority\_t, for the UART module irq handler.
 \* @param\[out\]  ERR\_CODE        The return value of the UART initialization function will be
 \*                              written to this parameter.
 \*
 \* @note Since this macro allocates a buffer and registers the module as a GPIOTE user when flow
 \*       control is enabled, it must only be called once.
 \*/
#define APP\_UART\_FIFO\_INIT(P\_COMM\_PARAMS, RX\_BUF\_SIZE, TX\_BUF\_SIZE, EVT\_HANDLER, IRQ\_PRIO, ERR\_CODE) \\
    do                                                                                             \\
    {                                                                                              \\
        app\_uart\_buffers\_t buffers;                                                                \\
        static uint8\_t     rx\_buf\[RX\_BUF\_SIZE\];                                                    \\
        static uint8\_t     tx\_buf\[TX\_BUF\_SIZE\];                                                    \\
                                                                                                   \\
        buffers.rx\_buf      \= rx\_buf;                                                              \\
        buffers.rx\_buf\_size \= sizeof (rx\_buf);                                                     \\
        buffers.tx\_buf      \= tx\_buf;                                                              \\
        buffers.tx\_buf\_size \= sizeof (tx\_buf);                                                     \\
        ERR\_CODE \= app\_uart\_init(P\_COMM\_PARAMS, &buffers, EVT\_HANDLER, IRQ\_PRIO);                  \\
    } while (0)

接下来我们来看uart的事件，从这里我们可以看出，串口收到数据后会产生一个事件APP\_UART\_DATA\_READY

typedef enum
{
    APP\_UART\_DATA\_READY,          /\*\*< An event indicating that UART data has been received. The data is available in the FIFO and can be fetched using @ref app\_uart\_get. \*/
    APP\_UART\_FIFO\_ERROR,          /\*\*< An error in the FIFO module used by the app\_uart module has occured. The FIFO error code is stored in app\_uart\_evt\_t.data.error\_code field. \*/
    APP\_UART\_COMMUNICATION\_ERROR, /\*\*< An communication error has occured during reception. The error is stored in app\_uart\_evt\_t.data.error\_communication field. \*/
    APP\_UART\_TX\_EMPTY,            /\*\*< An event indicating that UART has completed transmission of all available data in the TX FIFO. \*/
    APP\_UART\_DATA,                /\*\*< An event indicating that UART data has been received, and data is present in data field. This event is only used when no FIFO is configured. \*/
} app\_uart\_evt\_type\_t;

所以我们可以在回调函数中使用这个事件，当产生这个事件的时候说明串口有数据发过来，可以调用app\_uart\_get来接收串口数据，收到数据后再调用ble\_nus\_data\_send向蓝牙发送串口收到的数据。

/\*\*@brief   Function for handling app\_uart events.
 \*
 \* @details This function will receive a single character from the app\_uart module and append it to
 \*          a string. The string will be be sent over BLE when the last character received was a
 \*          'new line' '\\n' (hex 0x0A) or if the string has reached the maximum data length.
 \*/
/\*\*@snippet \[Handling the data received over UART\] \*/
void uart\_event\_handle(app\_uart\_evt\_t \* p\_event)
{
    static uint8\_t data\_array\[BLE\_NUS\_MAX\_DATA\_LEN\];
    static uint8\_t index = 0;
    uint32\_t       err\_code;

    switch (p\_event->evt\_type)
    {
        case APP\_UART\_DATA\_READY:
            UNUSED\_VARIABLE(app\_uart\_get(&data\_array\[index\]));
            index++;

            if ((data\_array\[index - 1\] == '\\n') ||
                (data\_array\[index \- 1\] == '\\r') ||
                (index \>= m\_ble\_nus\_max\_data\_len))
            {
                if (index > 1)
                {
                    NRF\_LOG\_DEBUG("Ready to send data over BLE NUS");
                    NRF\_LOG\_HEXDUMP\_DEBUG(data\_array, index);

                    do
                    {
                        uint16\_t length \= (uint16\_t)index;
                        err\_code \= ble\_nus\_data\_send(&m\_nus, data\_array, &length, m\_conn\_handle);
                        if ((err\_code != NRF\_ERROR\_INVALID\_STATE) &&
                            (err\_code != NRF\_ERROR\_RESOURCES) &&
                            (err\_code != NRF\_ERROR\_NOT\_FOUND))
                        {
                            APP\_ERROR\_CHECK(err\_code);
                        }
                    } while (err\_code == NRF\_ERROR\_RESOURCES);
                }

                index \= 0;
            }
            break;

        case APP\_UART\_COMMUNICATION\_ERROR:
            APP\_ERROR\_HANDLER(p\_event\->data.error\_communication);
            break;

        case APP\_UART\_FIFO\_ERROR:
            APP\_ERROR\_HANDLER(p\_event\->data.error\_code);
            break;

        default:
            break;
    }
}

3、log\_init、timers\_init、buttons\_leds\_init这三个函数的作用分别在 bsp 例程中已经有过详细介绍，在此不多做赘述。

4、power\_management\_init中调用了nrf\_pwr\_mgmt\_init()，其函数定义如下，主要是用于初始化低功耗管理模块，在实际的应用中可以直接使用。

/\*\*@brief   Function for initializing power management.
 \*
 \* @warning Depending on configuration, this function sets SEVONPEND in System Control Block (SCB).
 \*          This operation is unsafe with the SoftDevice from interrupt priority higher than SVC.
 \*
 \* @retval NRF\_SUCCESS
 \*/
ret\_code\_t nrf\_pwr\_mgmt\_init(void);

5、ble\_stack\_init 是一个非常重要的函数，其作用是初始化BLE协议栈，对于初学者而言不需要过多去查看协议栈初始化的具体细节，只要照搬例程中的初始化函数即可，这些需要关注的是回调函数ble\_evt\_handler

/\*\*@brief Function for the SoftDevice initialization.
 \*
 \* @details This function initializes the SoftDevice and the BLE event interrupt.
 \*/
static void ble\_stack\_init(void)
{
    ret\_code\_t err\_code;

    err\_code \= nrf\_sdh\_enable\_request();
    APP\_ERROR\_CHECK(err\_code);

    // Configure the BLE stack using the default settings.
    // Fetch the start address of the application RAM.
    uint32\_t ram\_start = 0;
    err\_code \= nrf\_sdh\_ble\_default\_cfg\_set(APP\_BLE\_CONN\_CFG\_TAG, &ram\_start);
    APP\_ERROR\_CHECK(err\_code);

    // Enable BLE stack.
    err\_code = nrf\_sdh\_ble\_enable(&ram\_start);
    APP\_ERROR\_CHECK(err\_code);

    // Register a handler for BLE events.
    NRF\_SDH\_BLE\_OBSERVER(m\_ble\_observer, APP\_BLE\_OBSERVER\_PRIO, ble\_evt\_handler, NULL);
}

这里我们分析一下例程中的ble\_evt\_handler，首先来看ble\_evt\_t这个结构体，这是一个非常复杂的结构体，给出了Gap、Gattc、Gatts、L2CAP等会产生的所有事件对应的结构体。

/\*\*@brief Common BLE Event type, wrapping the module specific event reports. \*/
typedef struct
{
  ble\_evt\_hdr\_t header;           /\*\*< Event header. \*/
  union
  {
    ble\_common\_evt\_t  common\_evt; /\*\*< Common Event, evt\_id in BLE\_EVT\_\* series. \*/
    ble\_gap\_evt\_t     gap\_evt;    /\*\*< GAP originated event, evt\_id in BLE\_GAP\_EVT\_\* series. \*/
    ble\_gattc\_evt\_t   gattc\_evt;  /\*\*< GATT client originated event, evt\_id in BLE\_GATTC\_EVT\* series. \*/
    ble\_gatts\_evt\_t   gatts\_evt;  /\*\*< GATT server originated event, evt\_id in BLE\_GATTS\_EVT\* series. \*/
    ble\_l2cap\_evt\_t   l2cap\_evt;  /\*\*< L2CAP originated event, evt\_id in BLE\_L2CAP\_EVT\* series. \*/
  } evt;                          /\*\*< Event union. \*/
} ble\_evt\_t;

这里涉及到BLE协议相关的知识，简单来说BLE协议栈的host层可以从下到上分为L2CAP、ATT、GAP、GATT四层，一般而言只需要应用程序中只需要处理GAP和Gatt层的事件即可。

![](https://img2023.cnblogs.com/blog/2936392/202304/2936392-20230404181624440-1230515476.png)

对于初学者而言，在没有详细了解蓝牙协议的情况下，建议照搬例程中已经写好的ble\_evt\_handler函数，只在应用层在ble\_evt\_handler的事件中根据自己的需求加入一些逻辑处理，例如BLE连接、断开后串口打印数据或是改变某个GPIO的状态。协议栈产生的GAP和GATT事件在ble\_gap.h、ble\_gattc.h、ble\_gatts.h这三个文件中，感兴趣的朋友可以自己去这两个文件中查看所有事件和其注释，这里我们只分析例程中的回调给出的这些事件的作用。

/\*\*@brief Function for handling BLE events.
 \*
 \* @param\[in\]   p\_ble\_evt   Bluetooth stack event.
 \* @param\[in\]   p\_context   Unused.
 \*/
static void ble\_evt\_handler(ble\_evt\_t const \* p\_ble\_evt, void \* p\_context)
{
    uint32\_t err\_code;

    switch (p\_ble\_evt->header.evt\_id)
    {
        case BLE\_GAP\_EVT\_CONNECTED:
            NRF\_LOG\_INFO("Connected");
            err\_code \= bsp\_indication\_set(BSP\_INDICATE\_CONNECTED);
            APP\_ERROR\_CHECK(err\_code);
            m\_conn\_handle \= p\_ble\_evt->evt.gap\_evt.conn\_handle;
            err\_code \= nrf\_ble\_qwr\_conn\_handle\_assign(&m\_qwr, m\_conn\_handle);
            APP\_ERROR\_CHECK(err\_code);
            break;

        case BLE\_GAP\_EVT\_DISCONNECTED:
            NRF\_LOG\_INFO("Disconnected");
            // LED indication will be changed when advertising starts.
            m\_conn\_handle = BLE\_CONN\_HANDLE\_INVALID;
            break;

        case BLE\_GAP\_EVT\_PHY\_UPDATE\_REQUEST:
        {
            NRF\_LOG\_DEBUG("PHY update request.");
            ble\_gap\_phys\_t const phys =
            {
                .rx\_phys \= BLE\_GAP\_PHY\_AUTO,
                .tx\_phys \= BLE\_GAP\_PHY\_AUTO,
            };
            err\_code \= sd\_ble\_gap\_phy\_update(p\_ble\_evt->evt.gap\_evt.conn\_handle, &phys);
            APP\_ERROR\_CHECK(err\_code);
        } break;

        case BLE\_GAP\_EVT\_SEC\_PARAMS\_REQUEST:
            // Pairing not supported
            err\_code = sd\_ble\_gap\_sec\_params\_reply(m\_conn\_handle, BLE\_GAP\_SEC\_STATUS\_PAIRING\_NOT\_SUPP, NULL, NULL);
            APP\_ERROR\_CHECK(err\_code);
            break;

        case BLE\_GATTS\_EVT\_SYS\_ATTR\_MISSING:
            // No system attributes have been stored.
            err\_code = sd\_ble\_gatts\_sys\_attr\_set(m\_conn\_handle, NULL, 0, 0);
            APP\_ERROR\_CHECK(err\_code);
            break;

        case BLE\_GATTC\_EVT\_TIMEOUT:
            // Disconnect on GATT Client timeout event.
            err\_code = sd\_ble\_gap\_disconnect(p\_ble\_evt->evt.gattc\_evt.conn\_handle,
                                             BLE\_HCI\_REMOTE\_USER\_TERMINATED\_CONNECTION);
            APP\_ERROR\_CHECK(err\_code);
            break;

        case BLE\_GATTS\_EVT\_TIMEOUT:
            // Disconnect on GATT Server timeout event.
            err\_code = sd\_ble\_gap\_disconnect(p\_ble\_evt->evt.gatts\_evt.conn\_handle,
                                             BLE\_HCI\_REMOTE\_USER\_TERMINATED\_CONNECTION);
            APP\_ERROR\_CHECK(err\_code);
            break;

        default:
            // No implementation needed.
            break;
    }
}

 下面是我直接从SDK中拷贝了这些事件的注释，从注释中可以看出这些事件基本是把BLE连接过程中会发生的事件列了出来。

BLE\_GAP\_EVT\_CONNECTED                      /\*\*< Connected to peer
BLE\_GAP\_EVT\_DISCONNECTED                　　/\*\*< Disconnected from peer.
BLE\_GAP\_EVT\_PHY\_UPDATE\_REQUEST　　　　　　　　/\*\*< PHY Update Request.
BLE\_GAP\_EVT\_SEC\_PARAMS\_REQUEST     　　　　　/\*\*< Request to provide security parameters.
BLE\_GATTS\_EVT\_SYS\_ATTR\_MISSING       　　　 /\*\*< A persistent system attribute access is pending.        
BLE\_GATTC\_EVT\_TIMEOUT                      /\*\*< Timeout event.    
BLE\_GATTS\_EVT\_TIMEOUT                      /\*\*< Peer failed to respond to an ATT request in time.

（1）、手机或者其他主机设备后，BLE协议栈会产生BLE\_GAP\_EVT\_CONNECTED这个事件，在这个事件产生后，回调函数在应用层对其的处理是首先使用LOG函数打印连接信息。然后调用bsp\_indication\_set改变DK板上LED的状态，让LED状态进入BSP\_INDICATE\_CONNECTED这个连接状态，通过查看 bsp.c 中的相关函数，我们可以知道这个连接状态是让DK板上的LED1进入常亮状态。最后是调用nrf\_ble\_qwr\_conn\_handle\_assign，这个函数的功能是用于将连接句柄m\_conn\_handle分配给 Queued Writes 模块。 简单来说，这个m\_conn\_handle相当于协议栈给连接的对端设备分配的号码，nrf\_ble\_qwr\_conn\_handle\_assign的作用就是把这个号码与 Queued Writes 模块关联起来，Queued Writes 模块用于处理对端BLE设备在GATT上的操作。

        case BLE\_GAP\_EVT\_CONNECTED:
            NRF\_LOG\_INFO("Connected");
            err\_code \= bsp\_indication\_set(BSP\_INDICATE\_CONNECTED);
            APP\_ERROR\_CHECK(err\_code);
            m\_conn\_handle \= p\_ble\_evt->evt.gap\_evt.conn\_handle;
            err\_code \= nrf\_ble\_qwr\_conn\_handle\_assign(&m\_qwr, m\_conn\_handle);
            APP\_ERROR\_CHECK(err\_code);
            break;

NRF\_BLE\_QWR\_DEF(m\_qwr);                        /\*\*< Context for the Queued Write module.\*/

（2）、手机或者其他主机设备后，BLE协议栈会产生BLE\_GAP\_EVT\_DISCONNECTED这个事件，从例程中可以看到，在这个事件产生后，回调函数对其的处理是使用LOG函数打印断开连接的信息，然后重置m\_conn\_handle的值。

        case BLE\_GAP\_EVT\_DISCONNECTED:
            NRF\_LOG\_INFO("Disconnected");
            // LED indication will be changed when advertising starts.
            m\_conn\_handle = BLE\_CONN\_HANDLE\_INVALID;
            break;

（3）、BLE\_GAP\_EVT\_PHY\_UPDATE\_REQUEST这个事件主要是针对对端设备请求更新PHY的速率，当对端设备请求更新PHY速率后，协议栈会产生此事件，从例程中可以看到，在这个事件产生后对其的处理是配置PHY参数，并调用sd\_ble\_gap\_phy\_update更新PHY速率。

        case BLE\_GAP\_EVT\_PHY\_UPDATE\_REQUEST:
        {
            NRF\_LOG\_DEBUG("PHY update request.");
            ble\_gap\_phys\_t const phys =
            {
                .rx\_phys \= BLE\_GAP\_PHY\_AUTO,
                .tx\_phys \= BLE\_GAP\_PHY\_AUTO,
            };
            err\_code \= sd\_ble\_gap\_phy\_update(p\_ble\_evt->evt.gap\_evt.conn\_handle, &phys);
            APP\_ERROR\_CHECK(err\_code);
        } break;

（4）、BLE\_GAP\_EVT\_SEC\_PARAMS\_REQUEST是安全相关参数请求事件，在配对信息交换阶段，BLE\_GAP\_EVT\_SEC\_PARAMS\_REQUEST事件会由协议栈上报给应用层。在这个事件中，从机会把自己的信息与主机进行交换，其中就包含了从机的IO能力、配对完成是否绑定等信息。

        case BLE\_GAP\_EVT\_SEC\_PARAMS\_REQUEST:
            // Pairing not supported
            err\_code = sd\_ble\_gap\_sec\_params\_reply(m\_conn\_handle, BLE\_GAP\_SEC\_STATUS\_PAIRING\_NOT\_SUPP, NULL, NULL);
            APP\_ERROR\_CHECK(err\_code);
            break;

 （5）、BLE\_GATTS\_EVT\_SYS\_ATTR\_MISSING这是事件是当没有存储系统属性时，协议栈上报此事件，回调函数中的处理是调用sd\_ble\_gatts\_sys\_attr\_set函数来设置系统属性。

        case BLE\_GATTS\_EVT\_SYS\_ATTR\_MISSING:
            // No system attributes have been stored.
            err\_code = sd\_ble\_gatts\_sys\_attr\_set(m\_conn\_handle, NULL, 0, 0);
            APP\_ERROR\_CHECK(err\_code);
            break;

（6）、BLE\_GATTC\_EVT\_TIMEOUT和BLE\_GATTS\_EVT\_TIMEOUT是当主机和从机连接超时协议栈产生的事件，回调函数中的处理是调用sd\_ble\_gap\_disconnect函数来断开连接。

        case BLE\_GATTC\_EVT\_TIMEOUT:
            // Disconnect on GATT Client timeout event.
            err\_code = sd\_ble\_gap\_disconnect(p\_ble\_evt->evt.gattc\_evt.conn\_handle,
                                             BLE\_HCI\_REMOTE\_USER\_TERMINATED\_CONNECTION);
            APP\_ERROR\_CHECK(err\_code);
            break;

        case BLE\_GATTS\_EVT\_TIMEOUT:
            // Disconnect on GATT Server timeout event.
            err\_code = sd\_ble\_gap\_disconnect(p\_ble\_evt->evt.gatts\_evt.conn\_handle,
                                             BLE\_HCI\_REMOTE\_USER\_TERMINATED\_CONNECTION);
            APP\_ERROR\_CHECK(err\_code);
            break;

6、gap\_params\_init函数是用来配置gap的相关参数，包括设备名称、连接间隔、Slave latency、监督超时时间、GAP连接的安全模式等。一般来说，配置比较多的是设备名称、连接间隔、Slave latency这三个参数，其他沿用例程中的配置即可。

/\*\*@brief Function for the GAP initialization.
 \*
 \* @details This function will set up all the necessary GAP (Generic Access Profile) parameters of
 \*          the device. It also sets the permissions and appearance.
 \*/
static void gap\_params\_init(void)
{
    uint32\_t                err\_code;
    ble\_gap\_conn\_params\_t   gap\_conn\_params;
    ble\_gap\_conn\_sec\_mode\_t sec\_mode;

    BLE\_GAP\_CONN\_SEC\_MODE\_SET\_OPEN(&sec\_mode);

    err\_code \= sd\_ble\_gap\_device\_name\_set(&sec\_mode,
                                          (const uint8\_t \*) DEVICE\_NAME,
                                          strlen(DEVICE\_NAME));
    APP\_ERROR\_CHECK(err\_code);

    memset(&gap\_conn\_params, 0, sizeof(gap\_conn\_params));

    gap\_conn\_params.min\_conn\_interval \= MIN\_CONN\_INTERVAL;
    gap\_conn\_params.max\_conn\_interval \= MAX\_CONN\_INTERVAL;
    gap\_conn\_params.slave\_latency     \= SLAVE\_LATENCY;
    gap\_conn\_params.conn\_sup\_timeout  \= CONN\_SUP\_TIMEOUT;

    err\_code \= sd\_ble\_gap\_ppcp\_set(&gap\_conn\_params);
    APP\_ERROR\_CHECK(err\_code);
}

7、gatt\_init用于初始化GATT库。其中，nrf\_ble\_gatt\_init 函数用于初始化GATT协议栈，gatt\_evt\_handler 函数用于处理GATT事件。nrf\_ble\_gatt\_att\_mtu\_periph\_set函数用于设置GATT服务器的MTU大小。

/\*\*@brief Function for initializing the GATT library. \*/
void gatt\_init(void)
{
    ret\_code\_t err\_code;

    err\_code \= nrf\_ble\_gatt\_init(&m\_gatt, gatt\_evt\_handler);
    APP\_ERROR\_CHECK(err\_code);

    err\_code \= nrf\_ble\_gatt\_att\_mtu\_periph\_set(&m\_gatt, NRF\_SDH\_BLE\_GATT\_MAX\_MTU\_SIZE);
    APP\_ERROR\_CHECK(err\_code);
}

在gatt\_init的回调函数gatt\_evt\_handler中主要处理当ATT MTU更新之后的事，这里ATT MTU是L2CAP层的内容，对于初学者而言不需要去深入了解，在自己的项目中只需要照搬例程中的代码即可。

/\*\*@brief Function for handling events from the GATT library. \*/
void gatt\_evt\_handler(nrf\_ble\_gatt\_t \* p\_gatt, nrf\_ble\_gatt\_evt\_t const \* p\_evt)
{
    if ((m\_conn\_handle == p\_evt->conn\_handle) && (p\_evt->evt\_id == NRF\_BLE\_GATT\_EVT\_ATT\_MTU\_UPDATED))
    {
        m\_ble\_nus\_max\_data\_len \= p\_evt->params.att\_mtu\_effective - OPCODE\_LENGTH - HANDLE\_LENGTH;
        NRF\_LOG\_INFO("Data len is set to 0x%X(%d)", m\_ble\_nus\_max\_data\_len, m\_ble\_nus\_max\_data\_len);
    }
    NRF\_LOG\_DEBUG("ATT MTU exchange completed. central 0x%x peripheral 0x%x",
                  p\_gatt\->att\_mtu\_desired\_central,
                  p\_gatt\->att\_mtu\_desired\_periph);
}

7、services\_init也是一个非常重要的函数，从机端所有的服务都是在这里添加并初始化，Nordic为我们提供了一个库在SDK根目录下的components\\ble\\ble\_services这个文件夹中，这里有常用的一些服务的库，例如DIS(Devies Information、Service)、DFU、HIDS等，所以想要在从机添加服务只需要在services\_init函数中调用对应的服务初始化接口，然后编写对应服务的回调函数即可，具体可以参考NUS服务的初始化。

需要注意的是在这里的nrf\_ble\_qwr\_init是用来初始化之前提到的Queued Writes 模块的函数，在初始化服务的时候首先要初始化Queued Writes模块。

/\*\*@snippet \[Handling the data received over BLE\] \*/

/\*\*@brief Function for initializing services that will be used by the application.
 \*/
static void services\_init(void)
{
    uint32\_t           err\_code;
    ble\_nus\_init\_t     nus\_init;
    nrf\_ble\_qwr\_init\_t qwr\_init \= {0};

    // Initialize Queued Write Module.
    qwr\_init.error\_handler = nrf\_qwr\_error\_handler;

    err\_code \= nrf\_ble\_qwr\_init(&m\_qwr, &qwr\_init);
    APP\_ERROR\_CHECK(err\_code);

    // Initialize NUS.
    memset(&nus\_init, 0, sizeof(nus\_init));

    nus\_init.data\_handler \= nus\_data\_handler;

    err\_code \= ble\_nus\_init(&m\_nus, &nus\_init);
    APP\_ERROR\_CHECK(err\_code);
}

![](https://img2023.cnblogs.com/blog/2936392/202304/2936392-20230406174914632-1105924135.png)

 这里ble\_app\_uart例程只使用了NUS服务，所以我们来看看NUS服务的回调函数nus\_data\_handler做了什么，当产生BLE\_NUS\_EVT\_RX\_DATA这个事件时，p\_evt->params.rx\_data.p\_data这个指针收到BLE的数据，回调函数中调用app\_uart\_put这个函数将收到的数据打印到串口。

/\*\*@brief Function for handling the data from the Nordic UART Service.
 \*
 \* @details This function will process the data received from the Nordic UART BLE Service and send
 \*          it to the UART module.
 \*
 \* @param\[in\] p\_evt       Nordic UART Service event.
 \*/
/\*\*@snippet \[Handling the data received over BLE\] \*/
static void nus\_data\_handler(ble\_nus\_evt\_t \* p\_evt)
{

    if (p\_evt->type == BLE\_NUS\_EVT\_RX\_DATA)
    {
        uint32\_t err\_code;

        NRF\_LOG\_DEBUG("Received data from BLE NUS. Writing data on UART.");
        NRF\_LOG\_HEXDUMP\_DEBUG(p\_evt\->params.rx\_data.p\_data, p\_evt->params.rx\_data.length);

        for (uint32\_t i = 0; i < p\_evt->params.rx\_data.length; i++)
        {
            do
            {
                err\_code \= app\_uart\_put(p\_evt->params.rx\_data.p\_data\[i\]);
                if ((err\_code != NRF\_SUCCESS) && (err\_code != NRF\_ERROR\_BUSY))
                {
                    NRF\_LOG\_ERROR("Failed receiving NUS message. Error 0x%x. ", err\_code);
                    APP\_ERROR\_CHECK(err\_code);
                }
            } while (err\_code == NRF\_ERROR\_BUSY);
        }
        if (p\_evt->params.rx\_data.p\_data\[p\_evt->params.rx\_data.length - 1\] == '\\r')
        {
            while (app\_uart\_put('\\n') == NRF\_ERROR\_BUSY);
        }
    }

}

8、advertising\_init也是一个非常重要的函数，所有的广播参数都在这里设置，包括广播周期、广播包中的相关参数等，配置的方式通过配置相对应的参数，然后调用ble\_advertising\_init去设置。这些需要注意的是，配置完广播参数之后，还要调用ble\_advertising\_conn\_cfg\_tag\_set来更改即将用于连接的连接设置标记。

/\*\*@brief Function for initializing the Advertising functionality.
 \*/
static void advertising\_init(void)
{
    uint32\_t               err\_code;
    ble\_advertising\_init\_t init;

    memset(&init, 0, sizeof(init));

    init.advdata.name\_type          \= BLE\_ADVDATA\_FULL\_NAME;
    init.advdata.include\_appearance \= false;
    init.advdata.flags              \= BLE\_GAP\_ADV\_FLAGS\_LE\_ONLY\_LIMITED\_DISC\_MODE;

    init.srdata.uuids\_complete.uuid\_cnt \= sizeof(m\_adv\_uuids) / sizeof(m\_adv\_uuids\[0\]);
    init.srdata.uuids\_complete.p\_uuids  \= m\_adv\_uuids;

    init.config.ble\_adv\_fast\_enabled  \= true;
    init.config.ble\_adv\_fast\_interval \= APP\_ADV\_INTERVAL;
    init.config.ble\_adv\_fast\_timeout  \= APP\_ADV\_DURATION;
    init.evt\_handler \= on\_adv\_evt;

    err\_code \= ble\_advertising\_init(&m\_advertising, &init);
    APP\_ERROR\_CHECK(err\_code);

    ble\_advertising\_conn\_cfg\_tag\_set(&m\_advertising, APP\_BLE\_CONN\_CFG\_TAG);
}

广播相关参数的设置都在ble\_advertising\_init\_t这个结构体中，一般用到比较多的是config、advata和srdata，config中主要是涉及配置广播周期参数，广播超时时间等，advata和srdata主要是配置广播包和扫描响应包。一般而言，建议是把数据放在广播包中，但广播包只有31个字节，如果你的广播数据比较长，例如你希望在广播包加入设备名称、UUID、地址等数据，如果在广播包中放不下全部数据，也可以把不重要的数据放在扫描响应包中，广播包和扫描响应包的长度都是31个字节。

typedef struct
{
    ble\_advdata\_t           advdata;       /\*\*< Advertising data: name, appearance, discovery flags, and more. \*/
    ble\_advdata\_t           srdata;        /\*\*< Scan response data: Supplement to advertising data. \*/
    ble\_adv\_modes\_config\_t  config;        /\*\*< Select which advertising modes and intervals will be utilized.\*/
    ble\_adv\_evt\_handler\_t   evt\_handler;   /\*\*< Event handler that will be called upon advertising events. \*/
    ble\_adv\_error\_handler\_t error\_handler; /\*\*< Error handler that will propogate internal errors to the main applications. \*/
} ble\_advertising\_init\_t;

广播初始化中还有一个广播的回调函数on\_adv\_evt，这个回调主要处理在广播模式下的事件，例程中只罗列了两个简单的事件，BLE\_ADV\_EVT\_FAST是在快速广播模式下，改变LED灯的状态，进入BSP\_INDICATE\_ADVERTISING模式，从bsp.c中可以得知此状态是让DK板上的LED1闪烁。BLE\_ADV\_EVT\_IDLE是广播超时之后产生的事件，广播超时时间可以在上面结构体的config中找到相应参数去配置，例程中对此的处理是此事件产生后，进入休眠模式。

/\*\*@brief Function for handling advertising events.
 \*
 \* @details This function will be called for advertising events which are passed to the application.
 \*
 \* @param\[in\] ble\_adv\_evt  Advertising event.
 \*/
static void on\_adv\_evt(ble\_adv\_evt\_t ble\_adv\_evt)
{
    uint32\_t err\_code;

    switch (ble\_adv\_evt)
    {
        case BLE\_ADV\_EVT\_FAST:
            err\_code \= bsp\_indication\_set(BSP\_INDICATE\_ADVERTISING);
            APP\_ERROR\_CHECK(err\_code);
            break;
        case BLE\_ADV\_EVT\_IDLE:
            sleep\_mode\_enter();
            break;
        default:
            break;
    }
}

9、conn\_params\_init这个函数的作用是初始化连接参数，连接参数包括了BLE主机与从机连接过程中协商的一些参数，例如连接间隔、从启动事件（连接或通知开始）到第一次调用sd\_ble\_gap\_conn\_param\_update的时间、第一次之后每次调用sd\_ble\_gap\_conn\_param\_update之间的时间、在放弃协商之前尝试的次数等参数。

/\*\*@brief Function for initializing the Connection Parameters module.
 \*/
static void conn\_params\_init(void)
{
    uint32\_t               err\_code;
    ble\_conn\_params\_init\_t cp\_init;

    memset(&cp\_init, 0, sizeof(cp\_init));

    cp\_init.p\_conn\_params                  \= NULL;
    cp\_init.first\_conn\_params\_update\_delay \= FIRST\_CONN\_PARAMS\_UPDATE\_DELAY;
    cp\_init.next\_conn\_params\_update\_delay  \= NEXT\_CONN\_PARAMS\_UPDATE\_DELAY;
    cp\_init.max\_conn\_params\_update\_count   \= MAX\_CONN\_PARAMS\_UPDATE\_COUNT;
    cp\_init.start\_on\_notify\_cccd\_handle    \= BLE\_GATT\_HANDLE\_INVALID;
    cp\_init.disconnect\_on\_fail             \= false;
    cp\_init.evt\_handler                    \= on\_conn\_params\_evt;
    cp\_init.error\_handler                  \= conn\_params\_error\_handler;

    err\_code \= ble\_conn\_params\_init(&cp\_init);
    APP\_ERROR\_CHECK(err\_code);
}

具体的连接参数可以在ble\_conn\_params\_init\_t这个结构体中找到。对于初学者而言，如果你对BLE协议不熟悉，对这些参数具体的用途不清楚，这里建议照搬例程中的代码，不去做改动，只需要知道此函数的作用即可。

/\*\*@brief Connection Parameters Module init structure. This contains all options and data needed for
 \*        initialization of the connection parameters negotiation module. \*/
typedef struct
{
    ble\_gap\_conn\_params\_t \*       p\_conn\_params;                    //!< Pointer to the connection parameters desired by the application. When calling ble\_conn\_params\_init, if this parameter is set to NULL, the connection parameters will be fetched from host.
    uint32\_t                      first\_conn\_params\_update\_delay;   //!< Time from initiating event (connect or start of notification) to first time sd\_ble\_gap\_conn\_param\_update is called (in number of timer ticks).
    uint32\_t                      next\_conn\_params\_update\_delay;    //!< Time between each call to sd\_ble\_gap\_conn\_param\_update after the first (in number of timer ticks). Recommended value 30 seconds as per BLUETOOTH SPECIFICATION Version 4.0.
    uint8\_t                       max\_conn\_params\_update\_count;     //!< Number of attempts before giving up the negotiation.
    uint16\_t                      start\_on\_notify\_cccd\_handle;      //!< If procedure is to be started when notification is started, set this to the handle of the corresponding CCCD. Set to BLE\_GATT\_HANDLE\_INVALID if procedure is to be started on connect event.
    bool                          disconnect\_on\_fail;               //!< Set to TRUE if a failed connection parameters update shall cause an automatic disconnection, set to FALSE otherwise.
    ble\_conn\_params\_evt\_handler\_t evt\_handler;                      //!< Event handler to be called for handling events in the Connection Parameters.
    ble\_srv\_error\_handler\_t       error\_handler;                    //!< Function to be called in case of an error.
} ble\_conn\_params\_init\_t;

在ble\_conn\_params\_init\_t中有两个回调函数，分别是事件回调和错误回调，在例程中对应的是on\_conn\_params\_evt和conn\_params\_error\_handler，这两个回调函数用于处理连接过程中的事件和连接参数错误的情况。

可以看到在 on\_conn\_params\_evt 中，只对BLE\_CONN\_PARAMS\_EVT\_FAILED这个事件做了处理，查看注释可以知道此事件是连接参数协商失败会产生的，对其的处理是调用sd\_ble\_gap\_disconnect断开连接。

conn\_params\_error\_handler是对连接参数错误的回调，例程中对其处理是直接调用 APP\_ERROR\_HANDLER 来检查错误。

/\*\*@brief Function for handling an event from the Connection Parameters Module.
 \*
 \* @details This function will be called for all events in the Connection Parameters Module
 \*          which are passed to the application.
 \*
 \* @note All this function does is to disconnect. This could have been done by simply setting
 \*       the disconnect\_on\_fail config parameter, but instead we use the event handler
 \*       mechanism to demonstrate its use.
 \*
 \* @param\[in\] p\_evt  Event received from the Connection Parameters Module.
 \*/
static void on\_conn\_params\_evt(ble\_conn\_params\_evt\_t \* p\_evt)
{
    uint32\_t err\_code;

    if (p\_evt->evt\_type == BLE\_CONN\_PARAMS\_EVT\_FAILED)
    {
        err\_code \= sd\_ble\_gap\_disconnect(m\_conn\_handle, BLE\_HCI\_CONN\_INTERVAL\_UNACCEPTABLE);
        APP\_ERROR\_CHECK(err\_code);
    }
}

/\*\*@brief Function for handling errors from the Connection Parameters module.
 \*
 \* @param\[in\] nrf\_error  Error code containing information about what went wrong.
 \*/
static void conn\_params\_error\_handler(uint32\_t nrf\_error)
{
    APP\_ERROR\_HANDLER(nrf\_error);
}

10、完成初始化所有模块的初始化之后，例程中是调用了 printf 和 NRF\_LOG\_INFO 打印了Log，二者的区别是printf直接在串口打印，而NRF\_LOG\_INFO是需要开启Log打印模块的。advertising\_start的作用是开启广播，例程中的advertising\_start函数是调用了ble\_advertising\_start这个函数来实现开启广播的。

/\*\*@brief Function for starting advertising.
 \*/
static void advertising\_start(void)
{
    uint32\_t err\_code \= ble\_advertising\_start(&m\_advertising, BLE\_ADV\_MODE\_FAST);
    APP\_ERROR\_CHECK(err\_code);
}

11、最后就是for循环中的代码，在带协议栈的例程中，是调用idle\_state\_handle来实现CPU在低功耗状态等待和上报事件，其效果和 \_\_SEV() 和 \_\_WFE() 类似。但是因为在BLE协议栈开启后，CPU要优先处理协议栈相关的任务，且协议栈开启后不能直接操作底层寄存器和指令，所以需要调用协议栈提供的接口来实现， 这就是nrf\_pwr\_mgmt\_run的作用 ，它用于处理空闲模式并进入System ON睡眠模式，在BLE状态下，如果CPU处于空闲状态，就会进入sd\_app\_evt\_wait()函数，来等待协议栈上报事件。这就是之前 power\_management\_ini t中要调用 nrf\_pwr\_mgmt\_init 对低功耗管理模块初始化的原因，因为要在for循环中使用nrf\_pwr\_mgmt\_run。

/\*\*@brief Function for handling the idle state (main loop).
 \*
 \* @details If there is no pending log operation, then sleep until next the next event occurs.
 \*/
static void idle\_state\_handle(void)
{
    if (NRF\_LOG\_PROCESS() == false)
    {
        nrf\_pwr\_mgmt\_run();
    }
}

12、练习

介绍完ble\_app\_uart这个例程，我们来做一个小练习，修改设备的广播名称、连接间隔、广播周期。

（1）广播名称在例程中是在 gap\_params\_init 函数中通过sd\_ble\_gap\_device\_name\_set来设置的，例程中是用了DEVICE\_NAME这个宏定义来控制，所以只需要更改这个宏定义即可。

#define DEVICE\_NAME                     "Nordic\_UART"                               err\_code \= sd\_ble\_gap\_device\_name\_set(&sec\_mode,
                                          (const uint8\_t \*) DEVICE\_NAME,
                                          strlen(DEVICE\_NAME));

（2）、连接间隔同样是在gap\_params\_init 函数配置，通过配置ble\_gap\_conn\_params\_t中的min\_conn\_interval和max\_conn\_interval来实现，这是一个范围值，之所以是一个范围值是为了兼容不同的主机设备，因为不同的主机设备的连接间隔是不同的。ble\_app\_uart例程中默认的范围值是20-75ms，我们可以通过修改最小连接间隔和最大连接间隔来修改实际的连接间隔。连接间隔越大，功耗越低，但是相对应的，连接时间和发送数据的速率会降低。

#define MIN\_CONN\_INTERVAL            MSEC\_TO\_UNITS(20, UNIT\_1\_25\_MS)/\*\*< Minimum acceptable connection interval (20 ms), Connection interval uses 1.25 ms units. \*/
#define MAX\_CONN\_INTERVAL            MSEC\_TO\_UNITS(75, UNIT\_1\_25\_MS)/\*\*< Maximum acceptable connection interval (75 ms), Connection interval uses 1.25 ms units. \*/ gap\_conn\_params.min\_conn\_interval \= MIN\_CONN\_INTERVAL;
gap\_conn\_params.max\_conn\_interval \= MAX\_CONN\_INTERVAL;

（3）、广播周期则是在advertising\_init中通过配置ble\_advertising\_init\_t中的ble\_adv\_fast\_interval或者ble\_adv\_slow\_interval来实现，需要注意的是ble\_app\_uart中使用的是fast advertising，相对应的还有slow advertising，二者的区别只是广播数据包的发送频率，fast advertising的发送频率比slow advertising的发送频率更高。

#define APP\_ADV\_INTERVAL           64  /\*\*< The advertising interval (in units of 0.625 ms. This value corresponds to 40 ms). \*/
init.config.ble\_adv\_fast\_interval \= APP\_ADV\_INTERVAL;

 小结：从ble\_app\_uart的例程就更可以看出，Nordic的例程的软件架构主要就是相应模块的初始化和回调函数，在开发自己的工程的时候，建议在SDK中找一个和你实际产品类似例程，在其基础上去做开发，而不是新建一个新的工程从零开始，因为例程中已经完成了主体软件架构的搭建，可以直接使用例程中BLE部分的相关初始化代码和回调函数，只需要根据实际情况去做微调一些参数即可，剩余的只是开发者在相应的例程中根据自己产品的实际需求去添砖加瓦即可。