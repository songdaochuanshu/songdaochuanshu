---
layout: post
title: "ReentrantLock å…¬å¹³é”æºç  ç¬¬0ç¯‡"
date: "2022-07-07T15:20:35.146Z"
---
ReentrantLock å…¬å¹³é”æºç  ç¬¬0ç¯‡
=======================

ReentrantLock å…¬å¹³é”æºç 

ReentrantLock 0
===============

å…³äºReentrantLockçš„æ–‡ç« å…¶å®å†™è¿‡çš„,ä½†å½“æ—¶å†™çš„æ„Ÿè§‰ä¸æ˜¯å¤ªå¥½,å°±ç»™åˆ äº†,é‚£ä¸ºå•¥åˆè¦å†å†™ä¸€éå‘¢

æœ€è¿‘é—²ç€æ²¡äº‹æƒ³è‡ªå·±å†™ä¸ªé”,ç„¶åæ•´äº†å‡ å¤©å‡ºæ¥åä¸æ˜¯è·‘ä¸¢çº¿ç¨‹å°±æ˜¯å’Œæ²¡åŠ é”ä¸€æ ·,è€Œä¸”äº”å…­æ®µå°±ä¸€ä¸ªcasæ€§èƒ½å¾ˆå·®,æ„Ÿè§‰ç¦»å¤§å¸ˆå†™çš„å·®åä¸‡å…«åƒé‡Œ

äºæ˜¯!æˆ‘å°±æƒ³é‡æ–°ç ”ç©¶ç ”ç©¶çœ‹çœ‹å¤§å¸ˆå’‹å†™çš„,è¿™ç¯‡åšå®¢ä¹Ÿç®—ä¸ªç¬”è®°å§,è¿™ç¯‡çœ‹çš„æ˜¯ReentrantLockçš„å…¬å¹³é”,å‡†å¤‡å†™ä¸ªä¸¤ä¸‰ç¯‡å…³äºReentrantLock å°±è¿™ä¸¤å¤©å†™!

è¿™ç¯‡åšå®¢å®Œå…¨ä¸ªäººç†è§£,å¦‚æœæœ‰ä¸å¯¹çš„åœ°æ–¹æ¬¢è¿æ‚¨è¯„è®ºæˆ–è€…ç§ä¿¡æˆ‘,æˆ‘éå¸¸ä¹æ„æ¥å—æ‚¨çš„æ„è§æˆ–å»ºè®®

CAS
---

é¦–å…ˆè¦çŸ¥é“,ReentrantLockæ˜¯åŸºæœ¬éƒ½æ˜¯åœ¨javaä»£ç å±‚é¢å®ç°çš„,è€Œæœ€ä¸»è¦çš„ä¸€ä¸ªä¸œè¥¿å°±æ˜¯`CAS` compare and swap æ¯”è¾ƒå¹¶äº¤æ¢

![](https://img2022.cnblogs.com/blog/1687169/202207/1687169-20220707220504458-1999897602.jpg)

è¿™ä¸ªæ“ä½œå¯ä»¥çœ‹æˆä¸ºæ˜¯ä¸€ä¸ªåŸå­æ€§çš„,åœ¨javaä¸­å¯ä»¥ä½¿ç”¨åå°„è·å–åˆ°Unsafeç±»æ¥è¿›è¡Œcasæ“ä½œ

    public test() {
        try {
            Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
            if (!unsafeField.isAccessible()) {
                unsafeField.setAccessible(true);
            }
            unsafe = (Unsafe) unsafeField.get(null);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }
    

Park
----

åœ¨jucåŒ…ä¸‹**LockSupport**ç±»ä¸­æœ‰ä¸¤ä¸ªæ–¹æ³•`park`å’Œ`unpark` è¿™ä¸¤ä¸ªå°±åƒæ˜¯waitå’Œnotify/notifyAll,ä½†æ˜¯åˆä¸ç›¸åŒ,å¯ä»¥æš‚æ—¶ç†è§£ä¸ºå°±æ˜¯æš‚åœçº¿ç¨‹å’Œå¯åŠ¨çº¿ç¨‹

è¯¦ç»†çš„ä»‹ç»å¯ä»¥çœ‹çœ‹è¿™ä¸ªåšå®¢ : [https://www.jianshu.com/p/da76b6ab56be](https://www.jianshu.com/p/da76b6ab56be)

å…³äºå¦‚ä½•ä½¿ç”¨ReentrantLockå°±ä¸åœ¨èµ˜è¿°äº†ç›´æ¥å¼€å§‹çœ‹ä»£ç ,æœ¬æ¥æ˜¯æƒ³æŠŠç±»çš„å…³ç³»å›¾æ”¾è¿™çš„,ä½†æ˜¯æˆ‘çš„ideaå¥½åƒæœ‰ç‚¹é—®é¢˜,ä½ ä»¬å¯ä»¥è‡ªå·±æ‰“å¼€ideaçœ‹,`ctrl+alt+u`æ‰“å¼€ç±»çš„å…³ç³»å›¾

    public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock(true);
        lock.lock();
        lock.unlock();
    }
    

æ„é€ æ–¹æ³•
----

    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
    

lockæ–¹æ³•
------

    public void lock() {
        sync.lock();
    }
    

ç‚¹åˆ°é‡Œé¢å®é™…è°ƒç”¨çš„æ˜¯`FairSync`ç±»ä¸­çš„`lock()`æ–¹æ³•

    final void lock() {
        acquire(1);
    }
    

    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    

tryAcuqireæ–¹æ³•
------------

    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
    

é¦–å…ˆæ˜¯è·å–äº†å½“å‰çš„çº¿ç¨‹,ä¹‹åæœ‰ä¸ªgetState,è¿™ä¸ªæ–¹æ³•è¿”å›çš„æ˜¯å½“å‰è¿™ä¸ªé”çš„çŠ¶æ€

    protected final int getState() {
        return state;
    }
    

### hasQueuedPredecessors

å…ˆæ¥çœ‹Node,è¿™ä¸ªNodeæ˜¯ä¸€ä¸ªç»„æˆåŒå‘é“¾è¡¨çš„å®ä½“ç±»,å‡ ä¸ªé‡è¦çš„å±æ€§

    volatile int waitStatus;
    
    volatile Node prev;
    
    volatile Node next;
    
    volatile Thread thread;
    
    Node nextWaiter;
    

`waitStatus` å­˜æ”¾å½“å‰ç»“ç‚¹çš„çŠ¶æ€

`prev` å­˜æ”¾ä¸Šä¸ªç»“ç‚¹

`next` å­˜æ”¾ä¸‹ä¸ªç»“ç‚¹

`thread` å­˜æ”¾çº¿ç¨‹

`nextWaiter` ç¿»è¯‘æ˜¯ä¸‹ä¸ªæœåŠ¡å‘˜,æˆ‘ç†è§£æ˜¯ä¸ºä¸‹ä¸ªèŠ‚ç‚¹æœåŠ¡,åé¢å’±ä»¬ç»†è¯´

    public final boolean hasQueuedPredecessors() {
        Node t = tail; 
        Node h = head;
        Node s;
        return h != t &&
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }
    

è¿™é‡Œæœ‰ä¸¤ä¸ªå±æ€§,tailå°¾ç»“ç‚¹,headå¤´ç»“ç‚¹,ä¹‹åä¸‹é¢ä¸€ä¸ªåˆ¤æ–­åˆ†åˆ«æ˜¯

å¤´ç»“ç‚¹ä¸ç­‰äºå°¾ç»“ç‚¹ `å¹¶ä¸”` (å¤´ç»“ç‚¹çš„ä¸‹ä¸€ç»“ç‚¹ä¸ç­‰äºnull`æˆ–è€…`å¤´ç»“ç‚¹åé¢ä¸€ä¸ªç»“ç‚¹çš„çº¿ç¨‹ä¸ç­‰äºå½“å‰çº¿ç¨‹)

    if (c == 0) {
        if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    

åœ¨`hasQueuedPredecessors()`æ¥ç€å°±æ˜¯ä¸€ä¸ªcas,ä¿®æ”¹çš„è¿™ä¸ªé”çš„çŠ¶æ€

å¦‚æœæˆåŠŸ,åˆ™è°ƒç”¨`setExclusiveOwnerThread()`

    protected final void setExclusiveOwnerThread(Thread thread) {
        exclusiveOwnerThread = thread;
    }
    

å°†å½“å‰çº¿ç¨‹å­˜æ”¾åˆ°exclusiveOwnerThreadå±æ€§ä¸­

é‚£ä¹ˆåœ¨æ²¡æœ‰å†²çªçš„æƒ…å†µä¸‹lockçš„æ–¹æ³•å°±èµ°å®Œäº†,ç°åœ¨å’±ä»¬å‡è®¾åªæœ‰ä¸€ä¸ªçº¿ç¨‹,ä»å¤´æ¥æ‹ä¸€ä¸‹åŠ é”çš„è¿‡ç¨‹

### è¯•è·‘ä¸€ä¸‹

å’±ä»¬é¡ºç€é€»è¾‘æ‹ä¸€ä¸‹,ä»æœ€å¼€å§‹çš„lock()æ–¹æ³•å¼€å§‹,å‰é¢çš„å°±ä¸å†™äº†,ç›´æ¥åˆ°acquire

    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    

è¿›å…¥acquire

    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
    }
    

å› ä¸ºè¿™ä¸ª`getState()`æ–¹æ³•è·å–çš„æ˜¯å±æ€§`state` è€Œè¿™ä¸ªå±æ€§åˆæ²¡æœ‰å…¶ä»–çš„èµ‹å€¼æ“ä½œ,åˆå§‹åŒ–å°±æ˜¯0,è¿›å…¥`if(c==0)`

ä¹‹åè¿›å…¥`hasQueuedPredecessors()`

    public final boolean hasQueuedPredecessors() {
        Node t = tail; 
        Node h = head;
        Node s;
        return h != t &&
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }
    

é¦–å…ˆç¬¬ä¸€ä¸ªåˆ¤æ–­å°±å·²ç»æ˜¯falseäº†,å› ä¸ºtailå’Œheadéƒ½æ²¡æœ‰è¿›è¡Œè¿‡åˆå§‹åŒ–,éƒ½æ˜¯null,æ‰€ä»¥ç­‰äº,ç›´æ¥è¿”å› false,è€Œåœ¨`hasQueuedPredecessors()`æ–¹æ³•å‰é¢è¿˜æœ‰ä¸€ä¸ª`!`å–åä¸ºtrue,ç›´æ¥è¿›å…¥ifä»£ç å—

è®¾ç½®å®Œ`exclusiveOwnerThread`å±æ€§åå°±return true,èµ°å‡ºlock()æ–¹æ³•,åŠ é”æ–¹æ³•ç»“æŸ

exclusiveOwnerThreadå±æ€§å­˜æ”¾çš„æ˜¯å½“å‰é‚£ä¸ªçº¿ç¨‹åœ¨å æœ‰é”

è¿™æ˜¯åœ¨æ²¡æœ‰çº¿ç¨‹è·å–é”å†²çªçš„æƒ…å†µä¸‹,å¦‚æœç°åœ¨ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶æ¥çš„è¯,è¿˜æ˜¯çœ‹`tryAcquire`æ–¹æ³•

    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
    

å’±ä»¬ç°åœ¨å‡è®¾çº¿ç¨‹Aè·å–åˆ°é”,å»æ‰§è¡Œä¸šåŠ¡ä»£ç äº†,çº¿ç¨‹Bè¿›å…¥

`getState()`è·å–çš„å€¼å°±ä¸åœ¨æ˜¯0äº†,å› ä¸ºçº¿ç¨‹Aæ‰§è¡Œå®Œ`compareAndSetState(0, acquires)`æ”¹çš„å°±æ˜¯`getState()`æ–¹æ³•è·å–çš„stateå±æ€§

é‚£ä¹ˆè¿›å…¥`else if (current == getExclusiveOwnerThread())` å“è¿™ä¸ªä¸æ˜¯è·å–å½“å‰å æœ‰é”çš„é‚£ä¸ªçº¿ç¨‹çš„æ–¹æ³•å—,æ˜¯çš„

é‚£ä¸ºä»€ä¹ˆæœ‰è¿™ä¸ªåˆ¤æ–­å‘¢,ReentrantLockçš„ç‰¹æ€§ é‡å…¥é”,å•¥å«é‡å…¥é”?:`åŒä¸€ä¸ªçº¿ç¨‹å¯ä»¥å¤šæ¬¡è·å–åŒä¸€ä¸ªé”` ä¾‹å¦‚ä¸‹é¢çš„ä¾‹å­

    public class Test{
        private static final ReentrantLock LOCK=new ReentrantLock(true);
    
        public void a(){
            LOCK.lock();
            b();
            LOCK.unlock();
        }
    
        public void b(){
            LOCK.lock();
            //xxxxxx
            LOCK.unlock();
        }
    }
    

å¦‚æœæ²¡æœ‰é‡å…¥é”çš„ç‰¹æ€§,é‚£ä¹ˆè¿™ä¸ªæ–¹æ³•æ˜¯ä¸æ˜¯å°±æ­»é”äº†å‘¢?,å‡è®¾å½“æˆ‘ä»¬ä¸€ä¸ªçº¿ç¨‹å»è°ƒç”¨aæ–¹æ³•æ—¶..

*   a : å…„å¼Ÿæˆ‘éœ€è¦é”æ‰èƒ½æ‰§è¡Œä½ çš„ä»£ç å•Š
    
*   b : é‚£ä½ å…ˆè§£é”å•Š
    
*   a : æˆ‘è¦è°ƒç”¨å®Œä½ æˆ‘æ‰èƒ½è§£é”å•Š
    
*   b : é‚£ä½ ä¸è§£é”å’‹è°ƒç”¨æˆ‘å•Š
    

........

å¥½äº†å›åˆ°ä»£ç ä¸­,å°±æ˜¯å°†é”æŒæœ‰çš„çŠ¶æ€+1,è®¾ç½®åè¿”å›true,å› ä¸ºæˆ‘ä»¬ç°åœ¨æ˜¯Bçº¿ç¨‹,æ‰€ä»¥è¿™ä¸ªifä¸æˆç«‹,è¿”å›false

å›åˆ°`acquireæ–¹æ³•`

    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    

å› ä¸ºtryAcquireä¸ºfalse,å–åç»§ç»­æ‰§è¡Œ`acquireQueued(addWaiter(Node.EXCLUSIVE), arg)`

### addWaiter

å…ˆæ¥çœ‹é‡Œé¢çš„`addWaiteræ–¹æ³•`å§,ä¼ äº†ä¸€ä¸ªå‚æ•°`Node.EXCLUSIVE`

    static final Node EXCLUSIVE = null;
    

è¿™ä¸ªå‚æ•°æ˜¯Nodeç±»ä¸­çš„ä¸€ä¸ªå±æ€§

    private Node addWaiter(Node mode) {
        //åˆ›å»ºä¸€ä¸ªNode
        Node node = new Node(Thread.currentThread(), mode);
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
    

Nodeçš„æœ‰å‚æ„é€ å¦‚ä¸‹

    Node(Thread thread, Node mode) {     // Used by addWaiter
        this.nextWaiter = mode;
        this.thread = thread;
    }
    

é¦–å…ˆæ˜¯åˆ›å»ºäº†ä¸€ä¸ªNodeç»“ç‚¹,ä¹‹ååˆ¤æ–­å¦‚æœtailç»“ç‚¹ä¸ä¸ºnull,å› ä¸ºAçº¿ç¨‹èµ°å®ŒtryAcquireç›´æ¥è¿”å›äº†,tailå’Œheadéƒ½æ˜¯null,æ‰€ä»¥ifä¸æˆç«‹,è¿›å…¥`enq`æ–¹æ³•

    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
    

é¦–å…ˆè¿˜æ˜¯è·å–tail,é‚£ä¹ˆè¿™æ—¶å€™è¿˜æ˜¯ä¸ºnull,å› ä¸ºæˆ‘ä»¬çš„å‡è®¾å°±ä¸¤ä¸ªçº¿ç¨‹,Açº¿ç¨‹å·²ç»å»æ‰§è¡Œä¸šåŠ¡äº†,æ‰€ä»¥è¿›å»ç¬¬ä¸€ä¸ªif

é€šè¿‡casæ¥è®¾ç½®å¤´èŠ‚ç‚¹ä¸ºä¸€ä¸ª`new Node()` æ³¨æ„!è¿™é‡Œæ˜¯æ–°newçš„Node,è®¾ç½®å®Œåå°†å¤´åœ¨è®¾ç½®ç»™å°¾,é‚£ä¹ˆæ­¤æ—¶çš„èŠ‚ç‚¹å…³ç³»å¦‚ä¸‹

![](https://img2022.cnblogs.com/blog/1687169/202207/1687169-20220707220522400-1363737380.jpg)

em?? å’±ä»¬è¿™BèŠ‚ç‚¹ä¹Ÿæ²¡æœ‰æ·»åŠ è¿›é“¾è¡¨å•Š,åˆ«æ€¥,çœ‹çœ‹ä¸Šé¢çš„`for(;;)`

åœ¨ä¸‹æ¬¡å¾ªç¯çš„æ—¶å€™tailè¿˜ç­‰äºnullå—?ç­”æ¡ˆæ˜¯å¦å®šçš„

ä¹‹åè¿˜æ˜¯å¤´èŠ‚ç‚¹èµ‹å€¼ç»™t,å°†BèŠ‚ç‚¹çš„ä¸Šä¸€ä¸ªè®¾ç½®ä¸ºt,casè®¾ç½®tail,æˆåŠŸåtèŠ‚ç‚¹çš„nextè®¾ç½®ä¸ºBèŠ‚ç‚¹,è¿”å›t (è¿”å›çš„å€¼å…¶å®æ²¡æ¥æ”¶)

æŒºç®€å•çš„é€»è¾‘è¯´çš„å¤ªè´¹åŠ²äº†,è¿˜æ˜¯çœ‹å›¾å§,æ‰§è¡Œå®Œç¬¬äºŒéforåèŠ‚ç‚¹å…³ç³»å¦‚ä¸‹

![](https://img2022.cnblogs.com/blog/1687169/202207/1687169-20220707220527637-104676429.jpg)

è¿™ä¸ªenqæ–¹æ³•æ˜¯ç™¾åˆ†ç™¾èƒ½ç¡®å®šè¿™ä¸ªèŠ‚ç‚¹å·²ç»æ·»åŠ è¿›å»çš„,å› ä¸ºä½ ä¸æ·»åŠ è¿›å»å°±å‡ºä¸æ¥è¿™ä¸ªæ–¹æ³•,é‚£ä¹ˆè¿”å›`addWaiter`æ–¹æ³•,èµ°å®Œè¿™ä¸ª`enq`å°±è¿˜æœ‰ä¸€å¥è¯,return node;

### acquireQueued

    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    

é‚£ä¹ˆä¸€è¿›æ¥å°±å®šä¹‰äº†ä¸€ä¸ª`failed`ç”¨æ¥å¤„ç†å¦‚æœå‘ç”Ÿé”™è¯¯éœ€è¦å°†é“¾è¡¨ä¸­é”™è¯¯çš„èŠ‚ç‚¹ç§»é™¤,å’±å…ˆä¸çœ‹

ä¹‹åçš„ä¸€ä¸ª`interrupted`å­˜æ”¾æ˜¯å¦è¢«æ‰“æ–­è¿‡,ç»§ç»­å‘ç°è¿˜æ˜¯ä¸€ä¸ª`for(;;)`,ç¬¬ä¸€æ­¥æ‰§è¡Œäº†`node.predecessor()`

    final Node predecessor() throws NullPointerException {
        Node p = prev;
        if (p == null)
            throw new NullPointerException();
        else
            return p;
    }
    

ä¹Ÿå°±æ˜¯å…ˆè·å–äº†ä¸‹BèŠ‚ç‚¹çš„ä¸Šä¸€ä¸ª,ä¹Ÿå°±æ˜¯é‚£ä¸ªçº¿ç¨‹ä¸ºnullçš„ç©ºèŠ‚ç‚¹**(æ³¨æ„:ä¸æ˜¯null,è€Œæ˜¯ä¸€ä¸ªç©ºçš„Node)**

åˆ¤æ–­ä¸Šä¸ªèŠ‚ç‚¹æ˜¯ä¸æ˜¯head,å¦‚æœæ˜¯,åˆ™å°è¯•è·å–é”,è¿™ä¸ªtryAcquire()æ–¹æ³•å°±æ˜¯å¼€å§‹çš„é‚£ä¸ªæ–¹æ³•,é‚£ä¹ˆè¿™ä¸€æ­¥æ˜¯ä»€ä¹ˆæ„æ€å‘¢

> ReentrantLockçš„åšæ³•,å¦‚æœå¿…é¡»åˆ›å»ºé“¾è¡¨,åˆ™headæŒ‡å‘çš„NodeèŠ‚ç‚¹ä¸€ç›´å°±æ˜¯ä¸€ä¸ªç©ºèŠ‚ç‚¹

è¿™å¥è¯å¯èƒ½ä¸å¤ªä¸¥è°¨,ä½†æ˜¯åœ¨é“¾è¡¨å­˜åœ¨çš„å¤§éƒ¨åˆ†æ—¶é—´å†…,headä¹Ÿç¡®å®æŒ‡å‘çš„æ˜¯ä¸€ä¸ªç©ºèŠ‚ç‚¹

ç»§ç»­çœ‹ä»£ç ,å‡è®¾ç°åœ¨Açº¿ç¨‹è¿˜æ˜¯æ²¡æœ‰å®Œæˆä¸šåŠ¡ä»£ç ,æ²¡æœ‰æ‰§è¡Œunlock(),é‚£ä¹ˆæˆ‘ä»¬è¿›å…¥ä¸‹ä¸ªif,

    if (shouldParkAfterFailedAcquire(p, node) &&parkAndCheckInterrupt())
        interrupted = true;
    

### shouldParkAfterFailedAcquire

    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            return true;
        if (ws > 0) {
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
    

ä»£ç ä¸å¤š,ä½†æ˜¯ä¸å¤ªå¥½ç†è§£ å¼€å§‹è¿˜æ˜¯è·å–BèŠ‚ç‚¹ä¸Šä¸ªèŠ‚ç‚¹çš„çŠ¶æ€,ä¹Ÿå°±æ˜¯é‚£ä¸ªç©ºèŠ‚ç‚¹,å› ä¸ºå’±ä»¬ä¸€è·¯ä»£ç è·Ÿè¿‡æ¥çš„,æ²¡æœ‰çœ‹åˆ°å“ªé‡Œå¯¹ç©ºèŠ‚ç‚¹çš„stateå±æ€§è¿›è¡Œè¿‡ä¿®æ”¹,æ‰€ä»¥å®ƒè¿˜æ˜¯0

é‚£ä¹ˆç¬¬ä¸€ä¸ªåˆ¤æ–­

    static final int SIGNAL    = -1;  //Nodeç±»ä¸­çš„å±æ€§
    

ç©ºèŠ‚ç‚¹çš„çŠ¶æ€æ˜¯å¦ä¸º-1,æ˜¾ç„¶ä¸æ˜¯,`if(ws>0)`ä¹Ÿä¸ä¼šè¿›,ç›´æ¥è¿›å…¥else,casä¿®æ”¹ç©ºèŠ‚ç‚¹çš„çŠ¶æ€,æ”¹ä¸ºäº†-1,ç„¶åè¿”å›

    if (shouldParkAfterFailedAcquire(p, node) &&parkAndCheckInterrupt())
        interrupted = true;
    

å› ä¸ºæ˜¯&&é˜»æ–­äº†åé¢çš„æ–¹æ³•,æ‰€ä»¥ä¸è¿›å…¥,é‚£ä¹ˆæœ¬æ¬¡å¾ªç¯ç»“æŸ,æœ€å¤–å±‚æ˜¯ä¸ª`for(;;)`æ‰€ä»¥ä¸‹æ¬¡å¾ªç¯å¼€å§‹

æˆ‘ä»¬è¿˜æ˜¯å‡è®¾é€šè¿‡`tryAcquire()`æ²¡æœ‰è·å–åˆ°é”,åˆè¿›å…¥äº†`shouldParkAfterFailedAcquire`

é‚£ä¹ˆè¿™æ¬¡ç¬¬ä¸€ä¸ªifæˆ‘ä»¬å°±ä¼šè¿›å»,å› ä¸ºä¸Šæ¬¡å¾ªç¯å·²ç»å°†BèŠ‚ç‚¹å‰é¢çš„ä¸€ä¸ªç©ºèŠ‚ç‚¹çš„çŠ¶æ€æ”¹ä¸º-1äº†,return true

å›åˆ°ifé‚£ä¹ˆå°±è¿›å…¥parkAndCheckInterruptæ–¹æ³•

    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this); 
        return Thread.interrupted();
    }
    

park,é‚£ä¹ˆBçº¿ç¨‹å°±åœåœ¨è¿™é‡Œäº†,æŠŠç›®å…‰å›åˆ°Açº¿ç¨‹,å®ƒç»ˆäºæ‰§è¡Œå®Œä¸šåŠ¡ä»£ç äº†,æ‰§è¡Œ`unlock`

unlock
------

    public void unlock() {
        sync.release(1);
    }
    

    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
    

çœ‹ç¬¬ä¸€ä¸ªifä¸­çš„`tryRelease`

    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
    

ç¬¬ä¸€ä»¶äº‹å°±æ˜¯å°†é”çš„çŠ¶æ€-1,å› ä¸ºå®ƒé‡å…¥ä¸€æ¬¡å°±+1,è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè°ƒç”¨lockå¤šå°‘æ¬¡å°±éœ€è¦è°ƒç”¨unlockå¤šå°‘æ¬¡,å› ä¸ºè¦ä¿è¯é”çš„çŠ¶æ€ä¸º0

ä¹‹ååˆ¤æ–­åŠ é”çš„çº¿ç¨‹å’Œè§£é”çš„çº¿ç¨‹æ˜¯ä¸æ˜¯åŒä¸€ä¸ª,ä¸æ˜¯æŠ›å‡ºå¼‚å¸¸

`boolean free = false;`è¿™ä¸ªæ¥æ ‡è¯†è¿™ä¸ªé”æ˜¯ä¸æ˜¯å·²ç»æ²¡æœ‰äººæŒæœ‰äº†,å› ä¸ºAçº¿ç¨‹å°±è°ƒç”¨äº†ä¸€æ¬¡lock,æ‰€ä»¥`if(c==0)`æˆç«‹

å°†free æ”¹ä¸ºtrueåå°†å½“å‰æŒæœ‰é”çš„çº¿ç¨‹è®¾ç½®ä¸ºnull,è®¾ç½®é”çš„çŠ¶æ€,è¿”å›true,å›åˆ°`release`æ–¹æ³•

å› ä¸ºè¿”å›true,æ‰€ä»¥è¿›å…¥if,åˆ¤æ–­headèŠ‚ç‚¹ä¸ä¸ºç©º,å¹¶ä¸”å¤´èŠ‚ç‚¹çš„çŠ¶æ€ä¸ä¸º0

é‚£ä¹ˆå¤´èŠ‚ç‚¹æ˜¯ç©ºçš„å—? -ä¸æ˜¯ å› ä¸ºBèŠ‚ç‚¹åœ¨åˆå§‹åŒ–é“¾è¡¨æ˜¯æ·»åŠ äº†ä¸€ä¸ªç©ºçš„èŠ‚ç‚¹(**å†è¯´ä¸€éä¸æ˜¯null!æ˜¯ç©ºçš„NodeèŠ‚ç‚¹**)

é‚£ä¹ˆå¤´èŠ‚ç‚¹çš„çŠ¶æ€æ˜¯0å—? -ä¸æ˜¯ æˆ‘ä»¬åœ¨ç¬¬äºŒæ¬¡æ‰§è¡Œ`shouldParkAfterFailedAcquire()`æ–¹æ³•æ—¶å·²ç»å°†å¤´èŠ‚ç‚¹çš„çŠ¶æ€è®¾ç½®ä¸º-1äº†

é‚£ä¹ˆè¿›å…¥`unparkSuccessor()`

        private void unparkSuccessor(Node node) {
            int ws = node.waitStatus;
            if (ws < 0)
                compareAndSetWaitStatus(node, ws, 0);
            Node s = node.next;
            if (s == null || s.waitStatus > 0) {
                s = null;
                for (Node t = tail; t != null && t != node; t = t.prev)
                    if (t.waitStatus <= 0)
                        s = t;
            }
            if (s != null)
                LockSupport.unpark(s.thread);
        }
    

è·å–,caså°†å¤´èŠ‚ç‚¹çš„çŠ¶æ€èµ‹å€¼ä¸º0,è·å–å¤´èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹,ä¹Ÿå°±æ˜¯æˆ‘ä»¬çš„BèŠ‚ç‚¹,é‚£ä¹ˆ`if (s == null || s.waitStatus > 0)` ä¸ºfalse,èµ°æœ€ä¸‹é¢çš„`if(s!=null)`

å°±ä¸€å¥è¯ unpark(s.thread)

åˆ°æ­¤,ABçº¿ç¨‹éƒ½èµ°å®Œäº†

ç¯‡å¹…æœ‰ç‚¹é•¿äº†,è¿™ä¸¤å¤©å†æ¥ç€å†™,æ‹œæ‹œğŸ˜€