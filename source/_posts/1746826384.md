---
layout: post
title: "B. Build the Permutation"
date: "2022-04-08T14:16:41.691Z"
---
B. Build the Permutation
------------------------

Posted on 2022-04-08 22:02  [ZheyuHarry](https://www.cnblogs.com/ZheyuHarry/)  阅读(0)  评论(0)  [编辑](https://i.cnblogs.com/EditPosts.aspx?postid=16120068)  [收藏](javascript:void(0))  [举报](javascript:void(0))

![](https://img2022.cnblogs.com/blog/2739426/202204/2739426-20220408213922629-1042230073.png)

题目分析：我们先简单的分析一下这道题是在干什么啊，给我们三个整数n，a，b，问我们能否构造这样的排列使得序列中有a个极大值，b个极小值，能的话就给出任意一种可能的情况，不能的话就输出-1；

其实一开始我分析这道题的方法不是很好，这道题最好的解决方法不是举几个栗子然后观察规律，而是应该学会数形结合，我们可以发现这其实就是一个数列，我们把每个孤立的点之间连成线就可以得到一个函数图像，a其实就是图像极大值的个数，b就是图像极小值的个数；

如图：

![](https://img2022.cnblogs.com/blog/2739426/202204/2739426-20220408215104411-1399945527.png)

于是我们先来找出答案是-1的情况：

我们可以发现两个相邻的极小值之间有且只有一个极大值，两个相邻的极大值之间也是如此，所以我们可以知道a和b的差值最多为1，不然就会出现两个极小值之间没有极大值的情况；

然后我们可以看出n的最小值也就是点的个数的最小值是a+b+2，所以我们可以特判处两个不能构造的情况

                                            **if(abs(a - b) > 1 || a + b + 2 > n) cout << -1 << '\\n';**

接下来我们再根据a和b的具体大小来看一看应该怎么构造：

a   >  b时：

![](https://img2022.cnblogs.com/blog/2739426/202204/2739426-20220408220015292-973919024.png)

a   <   b 时：

![](https://img2022.cnblogs.com/blog/2739426/202204/2739426-20220408215854448-1994803686.png)

a  ==  b时：

![](https://img2022.cnblogs.com/blog/2739426/202204/2739426-20220408215527872-38547437.png)

分析：这道题如果这样用图分析了其实不难，比较困难的事我该怎么用数值去表示具体的每个点，避免有重复或者遗漏！我们要根据a和b的具体数值来套入图中，然后写循环；

代码：[Submission #153007728 - Codeforces](https://codeforces.com/contest/1608/submission/153007728)