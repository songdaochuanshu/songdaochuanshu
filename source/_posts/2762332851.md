---
layout: post
title: "HCNP Routing&Switching之BFD"
date: "2022-07-17T21:16:10.596Z"
---
HCNP Routing&Switching之BFD
==========================

![HCNP Routing&amp;Switching之BFD](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717172240608-1573494592.png) BFD是Bidirectional Forwarding Detection的缩写，翻译成中文就是双向转发检测；该技术主要用于通信链路故障检测；我们知道传统的链锯故障检测机制有硬件检测，比如通过SDH（Synchronous Digital Hierarchy，同步数字体系）告警检测链路故障，这种方式的优点就是很快发现故障，但不是所有介质都能提供硬件检测；其次就是我们比较熟悉的慢HELLO机制；所谓慢hello机制就是通过采用路由协议中的hello报文机制；这种检测机制检测到故障都需要一定的时间，且一般都是秒级；这样一来对于高速数据传输的核心链路，如果故障在超过1秒才检测出来，这会导致大量的数据丢失；对于延迟敏感的业务，例如语音业务，这肯定是不能接受的，并且这种慢hello机制是严重依赖路由协议；除此之外不同协议有时会提供专用的检测机制，但在系统间互联互通时，这种专用的检测机制通常难以部署；

　　BFD技术背景

　　什么是BFD？它的主要作用是做什么的，这是我们学习BFD需要搞清楚的地方；

　　BFD是Bidirectional Forwarding Detection的缩写，翻译成中文就是双向转发检测；该技术主要用于通信链路故障检测；我们知道传统的链锯故障检测机制有硬件检测，比如通过SDH（Synchronous Digital Hierarchy，同步数字体系）告警检测链路故障，这种方式的优点就是很快发现故障，但不是所有介质都能提供硬件检测；其次就是我们比较熟悉的慢HELLO机制；所谓慢hello机制就是通过采用路由协议中的hello报文机制；这种检测机制检测到故障都需要一定的时间，且一般都是秒级；这样一来对于高速数据传输的核心链路，如果故障在超过1秒才检测出来，这会导致大量的数据丢失；对于延迟敏感的业务，例如语音业务，这肯定是不能接受的，并且这种慢hello机制是严重依赖路由协议；除此之外不同协议有时会提供专用的检测机制，但在系统间互联互通时，这种专用的检测机制通常难以部署；为了减小设别故障对业务的影响，提高网络的可用性，设备需要能够尽快检测到与相邻设备间的通信故障，以便能够及时采取措施，从而保证业务继续进行；BFD主要解决了上述检测机制的不足，它是更通用，标准化，与介质无关，协议无关，为上层协议服务；使用BFD以后，全网统一的检测机制，用于快速、监控网络中链路或路由的转发连通状况，保证邻居之间能够快速检测到通信故障，从而快速建立起备用通道恢复通信；简单讲BFD就是用于快速检测出通信双方通信链路故障的检测机制。它的特点就是无关介质和协议，更通用和标准，为上层协议服务；

　　BFD工作机制

　　BFD本身没有发现机制，它主要靠上层协议通知来建立BFD会话，周期性发送BFD控制报文进行检测，检测到故障后，再通知上层协议；这里需要解释下，虽然BFD也是通过周期性发送控制报文来进行检测，它和慢hello的路由协议检测机制不同的是，BFD发送控制报文的速度要比慢hello路由协议要快很多，当然BFD发送报文的速度是通过双方BFD配置协商而来，而慢hello路由协议一般都是固定不变的；BFD的控制报文可以控制在微秒级；

　　BFD会话建立过程

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717154052940-1975981469.png)

　　提示：上图是以ospf为例，BFD会话建立流程；首先上层ospf协议通过自己的hello机制发现邻居并建立连接；在ospf建立了新邻居关系时，将邻居的参数及检测参数都会通告给BFD（包括目标地址和源地址等）；然后BFD根据收到的参数进行计算并建立起会话；

　　BFD故障处理过程

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717154542095-949724951.png)

　　提示：以ospf为例，当网络出现故障时，首先由BFD检测到网络发生故障，然后BFD的会话会被拆除；BFD拆除会话以后会通知本地三层协议进程BFD邻居不可达；此时本地上层协议收到BFD的通知以后会终止上层协议的邻居关系；这样一来就实现了本地上层协议快速发现故障（这比通过上层协议本身的hello包检测机制要快很多）；如果网络中存在备用路径；路由器将会选择备用路径；

　　BFD状态机制

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717155135599-1237614876.png)

　　提示：BFD状态机的建立和拆除都采用三次握手，以确保两端系统都能知道状态的变化，最终目的就是可靠，类似TCP的三次握手，都是确保可靠性；

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717155310482-704581318.png)

　　提示：BFD状态首先由down状态开始，即会话没有建立起；在收到对方发送到状态为down的BFD控制报文以后，本端BFD的状态会从原有的down进入到init初始化的状态；然后本端会发送状态为init的BFD控制报文给对端，此时对端收到本端发送到状态为init的控制报文后，会从原有的down状态转变为init状态；然后对端发送状态为init的控制报文，本端收到以后，会从原来的init状态转变为up状态，然后本端发送状态为up的控制报文，对端收到以后会从init状态转变为up状态；只有两端的状态都为up时，此时BFD会话才算建立；

　　状态迁移规则：对端状态变化，检测定时器超时；比如在对端发送状态为init的控制报文时，由于各种原因本端没有收到，此时如果对端等待一定时间还是没有收到本端发送的init状态控制报文，对端会从原有的init状态迁移为down状态；对于up状态也是一样，如果在一定时间类没有收到本端的up状态的报文，对端会从up状态迁移至down状态；所谓对端状态变化是指本端收到对端发送到状态报文后，会触发本端的状态变化，比如对端发送down状态时，如果本端收到，本端状态会从down状态转变为init状态；对端发送init状态，如果本端收到会触发本端从init状态转变为up状态；

　　BFD会话工作方式

　　BFD会话工作方式主要分两种，一种是控制报文方式，所谓控制报文方式是指链路两端会话通过控制报文狡猾检测链路的状态；另外一种就是echo报文方式，这种方式主要用于某一端不支持BFD的场景；链路某一端通过发送echo报文由另一端转发回来，实现链路双向监测；

　　BFD报文格式

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717161451025-81147958.png)

　　提示：BFD使用组播地址为224.0.0.184作为目标地址进行工作；其中控制报文的方式有两个udp端口，分别是3784和4784；3784主要用于单跳检测；4784主要用于多跳检测；如果是echo报文方式，对应udp端口为3785；BFD报文除了常规字段如版本（vers），状态(sta)，长度(length)等，重要的有delect mult 检测倍数，my discriminator(本端的标识)，your discriminator(对端的标识)，desired min tx interval 期望的最小发送间隔，required min rx interval 要求的最小接收间隔，required min echo RX interval要求echo的最小接收间隔（echo方式）；下面的auth type auth len，以及authentication data 这些都是用于认证相关字段；

　　BFD运行模式

　　会话前模式

　　会话建立前的模式主要分主动模式和被动模式，所谓主动模式是指主动发送BFD控制报文，不管是否收到对端发来的BFD控制报文，都会发送BFD报文；被动模式是指不会主动发送BFD控制报文，直到收到对端发送到BFD控制报文；简单讲就是主动模式会主动发送BFD控制报文，它不管是否收到对端的控制报文，它都会发；而被动模式只有收到对端的控制报文后才开始发送本端的控制报文；这也就意味着要想建立起BFD会话，我们至少有一端需要运行为主动模式，会话才能正常建立，如果两端都是被动模式，BFD会话是建立不起来的；默认运行在主动模式；

　　会话建立后模式

　　会话建立后的模主要有异步模式和查询模式，所谓异步模式是指周期性地发送BFD控制报文，如果在检测时间内没有收到BFD控制报文则将会话down掉；查询模式是指一旦BFD会话建立，不再周期性发送BFD控制报文，而是通过其他机制检测连通性，减少大量BFD会话报文所带来的开销；

　　BFD应用场景

　　1、检测IP链路：在ip链路上建立BFD会话，利用BFD检测机制快速检测故障；BFD检测ip链路支持单跳检测和多跳检测；

　　单跳检测

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717163608147-589199823.png)

　　提示：所谓单跳检测就是指检测直连系统的ip连通性；单挑就是指ip的下一跳就只有一跳；通常单挑检测就是直接绑定出接口即可；

　　多跳检测

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717163819701-464948786.png)

　　提示：所谓多跳检测就是指检测两个系统间的任意路径，可以跨越很多跳，也可能发生重叠；通常多跳检测是直接绑定ip地址而不是接口；即便是直连链路，如果我们绑定ip地址也是属于多跳检测；

　　2、单臂回声功能

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717164021076-1950799434.png)

　　提示：单臂回声是指对于只有一端支持BFD的环境，通过BFD报文的换回操作检测转发链路的连通性；这里需要注意一点单臂回声功能只能用于单跳BFD会话中；

　　3、BFD与接口状态联动

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717164224951-137211396.png)

　　提示：与接口状态联动主要用于减少非直连链路故障说导致的问题；如上交换机A和B运行vrrp，如果中间两个交换机之间的链路down掉以后，不管谁是master，backup端只能等到超时以后才会变为master；此时由于中间链路断掉，对应master会收不到其他设备发送到vrrp报文，当然它就会认为它是独立的，从而导致两个设备都有可能成为master；如果我们配置了接口关联，当链路发生故障对应接口会被标记为down,此时不管是master端还是backup端感知到对应接口为down以后，对应状态都会转变为init状态；从而避免出现两个master的情况；简单讲与接口状态联动就是提高接口感应链路故障的灵敏度；从而更早的发现故障；

　　4、BFD与静态路由联动

　　与动态路由协议不同，静态路由本身没有检测机制，所以当网络发生故障的时候，需要管理员介入；BFD为静态路由绑定会话，检测链路故障（由up转为down）后，BFD会将故障上报路由管理系统，有路由管理模块将这条路由设置为“非激活”状态（此条路由不可用，从ip路由表中删除）；

　　5、BFD与OSPF联动

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717170450384-1016374769.png)

　　提示：将BFD和OSPF关联起来，通过BFD对链路故障的快速感应进而通知ospf协议，从而加快ospf协议对网络拓扑变化的响应；

　　ospf绑定BFD和未绑定BFD会话的区别

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717170215298-2134345809.png)

　　6、BFD与BGP联动

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717171225905-1628807916.png)

　　BGP协议通过周期性的向对等体发送keepalived报文实现邻居检测机制，但这种机制检测到故障所需时间比较长，超过1分钟；当数据达到吉比特速率级别时，将会导致大量的数据丢失；利用BFD的快速检测机制，迅速发现BGP邻居间链路故障，并报告给BGP协议，从而实现BGP路由的快速收敛；

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717171025898-1787139392.png)

　　7、BFD与VRRP联动

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717171316301-1262670453.png)

　　提示：将BFD应用于backup对master的检测，VRRP通过监视BFD会话状态实现主备快速切换，切换时间控制在50毫秒以内；VRRP通过监视BFD的会话状态，如果有故障产生，BFD会通知VRRP，vrrp收到bfd的通知以后，会自动将backup的优先级增加或者将master的优先级降低从而来实现快速切换；一般建议将backup的优先级增大，同时master端关联接口状态，从而避免出现两个master的情况；

　　BFD配置

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717205708679-1731699686.png)

　　如上拓扑配置sw1到sw4二层端口检测，当sw2和sw3之间链路断开，关联sw1的g0/0/1口软down，sw4的g0/0/1口软down

　　为了使实验很方便的看到效果，建议把4个交换机的stp直接关掉，屏蔽stp对bfd的影响；

　　在sw1开启bfd，并绑定g0/0/1口的端口检测

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717210651214-1142206755.png)

　　提示：第一条命令是全局开启bfd检测；第二条命令是创建g0/0/1口二层链路的检测；如果创建的是三层接口检测后面peer-ip 就直接跟对应ip地址即可；

　　配置本地标识符和远程标识符

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717210858297-319441934.png)

 　　提示：本地标识符在对端配置就是远程标识符，远程标识符在对端就是本地标识符；本地标识符和远程标识符不能配置成一样；但是远程标识符可以配置成一样；

　　提交配置

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717211134840-996395492.png)

　　提示：bfd配置只有提交以后才会生效；

　　抓包查看bfd控制报文

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717211825242-448501150.png)

　　提示：可以看到我们能够正常抓到sw1发送的BFD控制报文；其中本地标识符是我们设置的11（16进制就是0b）,远程标识符22（16进制就是16）；会话状态是down;目标地址是224.0.0.184，端口为3784，这意味着我们配置的是单跳检测；

　　配置sw4的bfd

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717212403937-539796032.png)

　　验证bfd会话

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717212447472-1344083594.png)

　　提示：可以看到现在sw1和sw4配置的bfd会话已经正常建立；

　　现在抓包查看控制报文信息

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717212741974-550208776.png)

　　提示：现在抓包除了我们配置的标识以外，现在的会话状态是up状态，对应最小发送间隔和最小接受间隔都从原来的一个随机数字固定了下来；这是因为一开始会话没有建立，两者不能正常协商出一个发送间隔和接受间隔，所以就以一个随机的时间来；

　　配置sw1和sw4与接口状态关联

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717213248529-1488010615.png)

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717213326654-907094644.png)

　　查看BFD会话详细信息

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717213447579-680508823.png)

　　提示：可以看到对应BFD已经关联了接口状态；

　　验证：端口sw2和sw3之间的链路，看看对应sw1和sw4对应g0/0/1的接口是否会down呢？

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717213900963-687866874.gif)

　　提示：可以看到我们把sw2的g0/0/2口down掉以后，对应bfd会触发sw1和sw4的g0/0/1口down；这是因为BFD会话down掉以后，触发对应接口状态也跟着down掉；

　　配置最小发送时间和最小接收时间以及本地检测倍数

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717215640581-31619446.png)

　　提示：以上配置表示sw1最小发送间隔为100毫米发送一次，即1秒发送10次；默认情况下最小发送间隔为1秒，最小接收间隔也为1秒；

　　现在抓包看看对应sw1是否是1秒发送10个包呢？

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717214920031-346214751.gif)

　　提示：可以看到sw1并不是1秒发送10个包；其实原因很简单，就是因为sw4最小接收间隔为1秒，它接受没有那么快，所以导致sw1发送也不会那么快；

　　配置sw4最小发送间隔为200毫秒，接收间隔为100毫秒，看看对应发包速率是怎样的呢？

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717215217696-139294879.png)

　　抓包查看发包速率

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717215922158-1964894674.gif)

　　提示：可以看到在sw4上修改了最小发送间隔和最小接收间隔以后，对应发包的速度明显快了很多；这意味着本端发包速度和对端接收间隔有关系；同理对端发包的速度和本端的接收间隔有关系；

　　本地检测倍数和最小发送间隔、最小接收间隔之间的关系

　　本端检测时间间隔=对端检测倍数×max(对端发送间隔，本端接收间隔)

　　配置BFD与vrrp联动

　　删除原有的接口关联

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717222724698-1421153757.png)

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717222818808-921801761.png)

　　在sw1上新建三层接口，并创建虚拟vip为254

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717223019009-2088349133.png)

　　在sw4上新建三层接口，并创建虚拟vip为254

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717223141989-1868919906.png)

　　验证vrrp

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717223236214-20735823.png)

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717223245558-854480280.png)

　　提示：可以看到sw1是backup，sw4是master；

　　在sw1上vrrp关联bfd并设置发生故障对应优先级增加80

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717223513569-1057028624.png)

　　提示：这里的配置BFD的session id要看本地标识符；

　　验证：把sw2的g0/0/2down掉，看看对应vrrp的backup是否会升级为master？

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717223906642-2127692033.gif)

　　提示：可以看到当我们把sw2的g0/0/2口down掉以后，对应sw1从原来的backup变为了master；

　　查看sw1的vrrp优先级是否发生了变化？

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717224101295-1618325722.png)

　　提示：可以看到我们之前配置的优先级为150，现在运行优先级为230；这是因为bfd检测到链路断掉以后，对应触发了vrrp增加80优先级；

　　查看sw4的角色是否有变化呢？

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717224228768-1883254370.png)

　　提示：可以看到sw4的角色还是master，并没有发生变化；这是因为sw2和sw3之间的链路断开以后，sw4并没有收到比它更高优先级的vrrp消息，所以它认为它就是master；

　　配置sw4关联接口状态

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717224430369-1347334223.png)

　　恢复链路然后再断开，看看对应sw4的角色是否会发生变化呢？

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717224634959-1375380766.gif)

　　提示：可以看到配置了接口关联以后，对应sw4的角色不再是master；

　　配置BFD与ospf联动

　　sw1和sw4的ospf配置

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717225440338-775048096.png)

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717225455061-1776656272.png)

　　在没有关联bfd时，当链路down掉以后，看看对应ospf的邻居是否down掉？

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717225836524-1800857107.gif)

　　提示：可以看到没有关联bfd会话时，对应链路down掉以后，ospf邻居并不会马上断掉，需要等待很长时间才能断掉（40秒）；

　　opsf关联bfd会话

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717230108160-628121604.png)

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717230151890-1855724749.png)

　　验证bfd session

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717230412226-848878047.png)

　　提示：可以看到bfd会话多了一个；这里说明一下bfd和ospf关联，bfd会话会动态生成一个；

　　查看bfd会话详情

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717230609973-1671085618.png)

　　验证：现在断开链路，看看ospf邻居是否立即断开呢？

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717230755722-1533510961.gif)

　　提示：可以看到现在我们断开链路，对应ospf邻居也随之被断开；这是因为bfd检测到链路故障，通知了ospf；当然我们也可以在bfd里绑定接口状态；

　　配置BFD与静态路由联动

　　在sw1上配置两条静态路由，并设置不同优先级

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717231950620-588791400.png)

　　配置静态路由关联BFD会话

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717232131244-1652690663.png)

　　断开链路前验证路由表

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717232217725-1503158100.png)

　　断开链路，然后再次验证路由表看看有什么变化？

![](https://img2022.cnblogs.com/blog/1503305/202207/1503305-20220717232357156-1998706304.gif)

　　提示：可以看到现在链路断开以后，对应路由表里的路由也随之发生了变化；原来的默认路由现在变成了非活动的路由，说明bfd检测到对应链路故障；

作者：[Linux-1874](https://www.cnblogs.com/qiuhom-1874/)

出处：[https://www.cnblogs.com/qiuhom-1874/](https://www.cnblogs.com/qiuhom-1874/)

本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.