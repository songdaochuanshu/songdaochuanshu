---
layout: post
title: "1分钟理清楚C++类模板和模板类区别"
date: "2022-12-09T08:21:00.576Z"
---
1分钟理清楚C++类模板和模板类区别
==================

![1分钟理清楚C++类模板和模板类区别](https://img2023.cnblogs.com/blog/2999540/202212/2999540-20221208233141322-1263078317.png) 简明扼要的解释C++中类模板和模板类两者的区别与联系。

1、定义区别       
-------------

　　类模板和模板类主要关注点是后一个单词。

　　**类模板：**主要描述的是模板，这个模板是类的模板。可以理解为一个通用的类，这个类中的数据成员，成员函数的形参类型以及成员函数的返回值类型不用具体的指定，这些类型都是虚拟的。在使用类模板进行对象定义的时候，才会根据对象的实际参数类型来替代类模板中的虚拟类型。通俗一点来说，可以看作是做蛋糕的模具。类模板标准定义格式如下：

1 template <typename 类型参数>
2 class 类名
3 {
4 类成员声明
5 };

　　或者：

1 template <class 类型参数>
2 class 类名
3 {
4 类成员声明
5 };

　　（1）template：这是声明类模板的关键字，表明这是一个类模板。

　　（2）尖括号<>中，typename和class的作用都一样，都是用作来申明后面的参数是一个虚拟的数据参数类型。

　　（3）类型参数：用C++标识符：Type或者T来表示，表示这是一个虚拟的数据类型名，此时在类模板中不给定具体的数据类型，实例化成模板类后，就需要给定具体的数据类型。

　　**模板类：**主要描述的是类，这个类使用类模板进行声明。将类模板中的虚拟类型参数指定成一个具体的数据类型参数。通俗一点来说可以看作是通过蛋糕模具做出来的蛋糕。

2、程序举例
------

        1，定义一个比较两个元素大小的类模板；

        2，使用该类模板进行实例化，实现用模板类定义对象。

 1 #include <iostream>
 2 using namespace std; 3 template <class T> //声明一个模板，虚拟数据类型名为T
 4 class Compare //类模板名为Compare
 5 {
 6    public : 7    Compare(T a, T b)
 8    {
 9        x = a;
10        y = b;
11 }
12    
13    T max( )  //类模板中的成员函数
14 {
15        return (x > y) ? x : y;
16 }
17 
18    private :
19 T x;
20 T y;
21 };
22 
23 int main()
24 {
25 Compare<int\>fun1(5,8);       //用类模板定义对象fun1，此时T被int替代 
26 Compare<float\>fun2(9.1,9.7); //用类模板定义对象fun2，此时T被float替代 
27 Compare<char\>fun3('a','h');  //用类模板定义对象fun3，此时T被char替代 
28 cout<<"最大值是:"<<fun1.max()<<endl;   
29 cout<<"最大值是:"<<fun2.max()<<endl;
30 cout<<"最大值是:"<<fun3.max()<<endl;
31 return  0;
32 }

　　最终程序打印结果依次为：

1 最大值是:8
2 最大值是:9.7
3 最大值是:h

　　可以从程序举例中看出使用类模板Compare进行实例化，生成了3个类型分别为Compare<int>、Compare<float>、Compare<char>的模板类，这3个模板类经实例化后又生成了3个对象成员fun1、fun2、fun3。对象成员可以调用类模板中定义的成员函数max()。类模板表示了通用的类，模板类表示了经过实例化后带具体数据类型参数的类。

　　另外，在类模板中，类模板的成员函数是在类模板体内定义。而类模板中的成员函数也可以在类模板体外定义。那么就需要遵循以下规则：

　　（1）需要在成员函数定义之前进行模板声明；

　　（2）在成员函数名前加上"类名<类型参数>::";

　　之前的程序举例中main函数之前的类模板声明就要改为如下格式：

 1 template<typename T>   //声明一个模板，虚拟数据类型名为T
 2 class Compare 3 {
 4   public : 5    Compare(T a, T b)
 6    {
 7        x = a; 8        y = b; 9 }
10    
11    T max( )  //类模板中的成员函数
12    
13    private :
14 T x;
15 T y;
16 };
17 
18 template<typename T> //在成员函数定义之前进行模板声明
19 T Compare<T>::max() //在成员函数名前加上"类名<类型参数>::"
20 {
21     return (x > y) ? x : y;
22 }

* * *

**更多技术内容和书籍资料获取敬请关注微信公众号“明解嵌入式”**

![](https://img2022.cnblogs.com/blog/2999540/202210/2999540-20221022000235287-740833429.png)

本文来自博客园，作者：[Sharemaker](https://www.cnblogs.com/Sharemaker/)，转载请注明原文链接：[https://www.cnblogs.com/Sharemaker/p/16967748.html](https://www.cnblogs.com/Sharemaker/p/16967748.html)