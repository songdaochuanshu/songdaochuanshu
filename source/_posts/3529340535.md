---
layout: post
title: "XCode汇编调试"
date: "2023-03-23T01:07:49.992Z"
---
XCode汇编调试
=========

**开启Xcode汇编调试**

选中Always Show Disassembly项。

XCode -> Debug -> Debug Workflow -> Always Show Disassembly

![0](https://img2023.cnblogs.com/blog/826860/202303/826860-20230322233215771-444611743.png)

在计算机中，虽然数据是存储在内存中，但内存中数据的加减计算并不是在内存中直接进行的。

而是把内存中的数据赋值到寄存器中，然后CPU在寄存器中计算好后把结果再赋值到内存中的。

![0](https://img2023.cnblogs.com/blog/826860/202303/826860-20230322233215729-1702459626.png)

对内存中3做加1计算，并把几个4存储到蓝色内存块中

movq 红色存储空间, %rax addq $0x1, $rax movq %rax, 蓝色地址空间

汇编语言和机器语言是一一对应的。

汇编语言通过汇编器可以变成机器语言，机器语言通过反汇编又可以转成汇编语言。

高级语言通过编译器可以变成汇编语言，汇编语言无法通过反编译转成高级语言了。

**汇编语言种类**

8086汇编（16bit）

x86汇编（32bit）

x64汇编（64bit）

ARM汇编（嵌入式，移动设备）

对应iOS开发来说，iOS模拟器使用的AT&T汇编，iOS真机使用的ARM汇编。

**OC和Swift调试的汇编指令是AT&T**

它的数据移动操作顺序是从左往右，比如movq指令是将左边寄存器的值移动到右边的寄存器中。

数据的移动：

movq -0x18(%rbp) , %rax //表示将%rbp-0x18 这个内存地址中保存的值移到 %rax寄存器中

地址的移动：

leaq -0x18(%rbp) , %rax //表示将%rbp-0x18 这个地址移到 %rax寄存器中

call 内存地址 // 方法调用

jmp 内存地址 // if 跳转

addq $0x1, $rax // 赋值，把左边的值设置到右边的寄存器中

![0](https://img2023.cnblogs.com/blog/826860/202303/826860-20230322233215804-1509551434.png)

mov 与 movq相比多了一个q, 这个q是什么意思呢？

q代表保存数据要用多少个字节,q:64-bits, 8字节。

指令在内存中是顺序保存的，基本上每条指令占4字节。

**call和jmp指令相似**

call是方法调用，jmp是if判断。

call是和ret配合使用的 call 0x00是跳到这个函数地址，等函数执行完，走到ret后会回到call指令的下一句的。

jmp是顺序执行，jmp 0x00后一直顺序往下执行。

call和jmp跳一个动态的函数地址时，命令是call \*的，如：call \*%rax。

![0](https://img2023.cnblogs.com/blog/826860/202303/826860-20230322233215853-994608809.png)

从寄存器的发展来看是由小到大，比如从x86的32字节，到x64的64字节，它们是怎么兼容的呢？

解决方法是共用一个64位寄存器的内存，按照所占内存大小，从低位往高位占据。比如32位寄存器只使用64位全部空间的一半，占据寄存器的低地址区。

%rip, %rdx, 以r开头的是64位8字节寄存器

%esi, %idx, 以e开头的是32位4字节寄存器

其他的

ax ,bx, cx 占2字节

ah, al 占1字节

**lldb汇编调试指令**

内存/寄存器读写

读取寄存器中的值

register read/格式
register read/x

修改寄存器中的值

register write 寄存器名称 数值
register write rax 0

读取内存中的值

x/数值-格式-字节大小 内存地址
x/3xw 0x000010

修改内存中的值

memory write 内存地址 数值
memory write 0x000010 10

汇编断点调试

thread step-inst-over, nexti, ni //单步运行，把子函数当做一个整体，一步执行
thread step-inst, stepi, si //单步运行，遇到子函数进入子函数

**内存地址计算**

当汇编调用，程序走到断点的位置时，要验证movq $0xa, 0x459d(%rip)这块汇编执行的效果时

会手动计算内存地址 = %rip + 0x459d

注意，此时从寄存器%rip拿到的值是错的，因为CPU的指令寄存器是保存的下一条指令要执行的地址

而当前断点断住了，相当于在CPU准备执行这个命令时会有一次执行下调指令的计算没有做，如果直接读取，那么读到的是还是CPU上一次的更新执行当前指令地址的值，正确的执行上下文时，应该是下一条指令的地址值。

![0](https://img2023.cnblogs.com/blog/826860/202303/826860-20230322233215793-863744279.png)

%rip： 指令寄存器

iOS传参优先使用寄存器传参，寄存器不够了用栈传参。

**内存地址格式规律**

0x4bdc(%rip)，一般是全局变量，全局区（数据段）
-0x78(%rbp), 一般是局部变量，栈空间
0x10(%rax), 一般是堆空间

**常用寄存器**

rax, rbx, rcx, rdx, rdi, rsi, rbp, rsp
r8,r9,r10,r11,r12,r13,r14,r15

rax 常用于函数返回值

rcx, rdx, rdi, rsi, r8, r9常用于存放函数参数。

rbp, rsp用于栈操作

rip作为指令指针（存放的是下一条执行指令的地址， 一旦CPU读取一条指令，rip自动指向下一条指令）