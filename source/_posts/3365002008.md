---
layout: post
title: "『忘了再学』Shell基础 — 13、环境变量（一）"
date: "2022-05-18T06:24:51.025Z"
---
『忘了再学』Shell基础 — 13、环境变量（一）
==========================

目录

*   [1、用户自定义的环境变量](#1用户自定义的环境变量)
    *   [（1）环境变量设置](#1环境变量设置)
    *   [（2）查询自定义环境变量](#2查询自定义环境变量)
    *   [（3）删除自定义环境变量](#3删除自定义环境变量)
*   [2、系统自带的环境变量——PATH环境变量](#2系统自带的环境变量path环境变量)
    *   [（1）PATH环境变量](#1path环境变量)
    *   [（2）PATH环境变量的作用](#2path环境变量的作用)
    *   [（3）配置命令的环境变量](#3配置命令的环境变量)

> 提示：
> 
> 在Shell中，环境变量分为两种。一种是用户自定义的环境变量，另一种是系统自带的环境变量。
> 
> 而在系统自带的环境变量中，PATH环境变量、PS1环境变量、LANG语系变量需要进行说明一下。
> 
> 本篇文章主要说明用户自定义的环境变量，和PATH环境变量。

1、用户自定义的环境变量
------------

### （1）环境变量设置

使用`export`关键字声明的变量就是环境变量。  
格式：

    [root@localhost ~]# export AGE="18"
    

也可以先定义一个自定义变量，然后把自定义变量声明称环境变量。如下：

    [root@localhost ~]# AGE=18
    [root@localhost ~]# export AGE
    

> 注：  
> 环境变量名称一般要用大写。  
> 环境变量的作用域，在父子Shell中都可查看。

### （2）查询自定义环境变量

`env`命令和`set`命令的区别是，set命令可以查看所有变量，而`env`命令只能查看环境变量。（具体看上一篇文章）

这里说明一下`env`命令和`set`命令所查看的一些重要的内容，以后就不详细说明了。

**（1）`env`命令**

![image](https://img2022.cnblogs.com/blog/909968/202205/909968-20220518110628947-1324737762.png)

**（2）`set`命令**

`env`命令可以查询到所有的环境变量，但是还有一些变量是`env`命令查看不到的，这些变量虽然不是环境变量，却是和Bash操作接口相关的变量，这些变量也对我们的Bash操作终端起到了重要的作用。这些变量就只能用`set`命令来查看了，只列出重要的内容，如下：

![image](https://img2022.cnblogs.com/blog/909968/202205/909968-20220518110724460-1607887821.png)

### （3）删除自定义环境变量

和用户定义变量一样，用`unset`命令删除变量。

    #删除环境变量 gender
    [root@localhost ~]# unset gender
    

2、系统自带的环境变量——PATH环境变量
---------------------

系统自带的环境变量的名称和作用都不能够改变。

系统的环境变量，用上边介绍的`env`命令和`set`命令都可以查出。我们接下来说明几个比较重点的环境变量。

### （1）PATH环境变量

查看当前系统PATH环境变量的值：

    [root@localhost ~ ] # echo $PATH
    /usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
    

每次执行`env`命令和`set`命令都要在好多变量中找我们需要查看的变量很麻烦，可以使用上面的方式直接查看我们所需的变量的值。

### （2）PATH环境变量的作用

**PATH变量的作用：系统查找命令的路径。**

你回想一下，在说明Shell执行脚本运行的时候说过，有两种方法可以执行Shell脚本，一个是通过绝对路径或者相对路径执行脚本，如：`/root/hello.sh`或者`./hello.sh`。还有一种方法是直接执行bash命令执行脚本，如：`bash hello.sh`。我们当时建议用第一种方式。（在Linux系统中，所有的执行文件，都应该使用绝对路径来执行它）

但是我们有没有发现，比如我们之前所执行过的一些系统命令，如`ls`命令，我们知道`ls`命令在系统的bin目录下。如下图：

![image](https://img2022.cnblogs.com/blog/909968/202205/909968-20220518110745828-964081918.png)

但是我们直接执行`ls`命令，并没有使用绝对路径，系统就能够执行`ls`命令，这是为什么呢？

根本原因就是在这个PATH环境变量中。  
PATH环境变量中配置的这些路径，就是系统查找命令的路径。也就是说当我们输入了一个程序名，如果没有写命令的路径，系统就会到PATH环境变量定义的路径中去寻找，是否有可以执行的程序。从左到右一个一个目录查找你所要执行的命令，找到了就直接执行，而如果把所有的目录都搜索完了，也没有找到你所执行的命令，就会报错，提示你`-bash:变量名:command not found（命令没找到）`。换句话说也就是你这个命令执行的不正确，也或者说你所执行的命令，并没有配置在PATH环境变量中。

> 注意：PATH环境变量的值中，是用“：”分割的路径。

### （3）配置命令的环境变量

我们如何才能让一个自定义的程序或者脚本，不用输入绝对路径就能够执行呢？

有两种方式：

*   第一种方式：直接把程序或者脚本的可执行文件，直接复制到PATH环境变量下的任一个目录下即可。
    
        #拷贝hello.sh文件到bin目录下
        [root@localhost ~]# cp /root/sh/hello.sh  /bin/
        
        #hello.sh脚本即可以直接执行
        [root@localhost ~]# hello.sh
        Perhaps only heart no holdings, to being on land, settle.
        也许只有心无所持，才能随遇而安。
        
    
*   第二种方式：把程序或者脚本所有在的路径，添加到PATH环境变量中即可。  
    通过变量的叠加就可以实现：
    
        #在变量PATH的后面，加入/root/sh目录
        [root@localhost ~]# PATH="$PATH":/root/sh
        
        #查询PATH的值，变量叠加生效了
        [root@localhost ~]# echo $PATH
        /usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin:/root/sh
        
    
    > 注意的是，我们这样定义的PATH环境变量只是临时生效，一旦重启或注销就会消失，如果想要永久生效，需要写入环境变量配置文件`/etc/profile`中。（可查看后续文章）