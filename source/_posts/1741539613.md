---
layout: post
title: "在GO中调用C源代码#基础篇1"
date: "2022-05-07T07:17:55.440Z"
---
在GO中调用C源代码#基础篇1
===============

开坑说明
----

最近在编写客户端程序或与其他部门做功能集成时多次碰到了跨语言的sdk集成，虽说方案很多诸如rpc啊，管道啊，文件io啊，unix socket啊之类的不要太多，但最完美的基础方式还是让程序与sdk结合到一起（个人观点，不喜勿喷），顺便研究了下在go调用标准c接口的种种方法与坑，内容不少，有空便慢慢更新了。

内嵌形式
----

先让我们来看一个最简单的cgo实例

    package main
    
    //#include <stdio.h>
    import "C"
    
    func main() {
    	C.puts(C.CString("Hello World"))
    }
    

输出

    Hello World
    

通过"C包"调用了c中常见的puts函数同时传入通过C.Cstring把go 中string转化为的c string(相当于char \*)。其实“C”这个并不是一个包，而是通过import "C"语句启用了go编译器cgo相关的功能让gcc也参与到了编译中。这种方式通过紧贴在import "C"语句上面的注释中编写c代码并在后续代码中使用C对象调用。当然也可以通过这种方式调用自定义的c函数。

    package main
    import "C"
    
    /*#include <stdio.h>
    
    void say_hello_with_name(char * name){
    	printf("hello %s\n", name);
    }
     */
    import "C"
    
    func main() {
    	C.say_hello_with_name(C.CString("oscar"))
    }
    
    

输出

    hello oscar
    

外置的C代码
------

内置的C代码固然很方便，但用到cgo大多数的使用场景是我有一个需要复用的c代码库，像是c++的stl库亦或者是linux c中的什么已经封装好的第三方依赖。这些时候便需要外置一些c的文件.h .c .cpp之类与.go文件混编。先看一个最简单的例子（调用linux的系统账户认证）。

    // auth.h
    int auth(char *user, char *passwd);
    

    // auth.c
    #include <shadow.h>
    #include <stdio.h>
    #include <unistd.h>
    
    int auth(char *user, char *passwd){
        char *obtpwd;
        struct spwd *spasswd;
    
        spasswd = getspnam(user);
        obtpwd = crypt(passwd, spasswd->sp_pwdp);
        if(strcmp(spasswd->sp_pwdp, obtpwd) == 0)
        return 0;
        else return 1;
    }
    
    

    // main.go
    package main
    
    /*
    #cgo LDFLAGS: -lcrypt
    
    #include "auth.h"
    */
    import "C"
    import "fmt"
    
    func main() {
    	var username, password string
    
    	fmt.Println("Please enter your username and password: ")
        _, _ = fmt.Scanln(&username, &password)
    
    	rst := C.auth(C.CString(username), C.CString(password))
    	fmt.Println(rst)
    }
    

保证上述三个文件在同一个go工程目录下运行 _go build -o main_ 构建工程。_#cgo LDFLAGS: -lcrypt_ 这个一行是cgo给gcc的编译参数，相关的编译参数与连接参数有空了在后面的文章里说明，-lcrypt 表示编译时需要去连接libcrypt这个库。  
注意，这种c go 混编的方式个人是不建议的，cgo对外置c代码片构建支持非常差，我无法在cgo中通过编译参数指定c代码片的搜索路径（头文件倒是没啥问题），这也就意味着当项目被调用的c代码片都得在项目根目录下，这可太糟糕了。个人觉得如果有大量的外部依赖c语言的库请分开编译，c库使用gcc编译成静态或动态库在让go在编译时连接为好，写个makefile分开分步编译也不是什么麻烦事，还是上面的例子，让我们把编译的过程稍加修改。

### 1\. 构建libauth.a静态库

    gcc -c -o auth.o -lcrypt auth.c
    ar rcs libauth.a auth.o
    

得到libauth.a

### 2\. 对main.go稍加修改

    package main
    
    /*
    #cgo CFLAGS: -I./
    #cgo LDFLAGS: -L. -lauth -lcrypt
    
    #include "auth.h"
    */
    import "C"
    import "fmt"
    
    func main() {
    	var username, password string
    
    	fmt.Println("Please enter your username and password: ")
        _, _ = fmt.Scanln(&username, &password)
    
    	rst := C.auth(C.CString(username), C.CString(password))
    	fmt.Println(rst)
    }
    

此处修改主要是新增了libauth.a静态库的链接参数

### 3\. 编译

    go build -o main main.go
    

可以把上述的步骤整下写个简单的makefile

    .PHONY : all
    
    all: main
    
    libauth.a: auth.c
    	gcc -c -o auth.o -lcrypt auth.c
    	ar rcs libauth.a auth.o
    
    main: main.go libauth.a
    	go build -o main main.go
    
    clean:
    	rm -f auth.o libauth.a main
    

这样也让我们得出产物的过程变得相对简单快捷