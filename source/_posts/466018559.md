---
layout: post
title: "计算机基本工作原理"
date: "2022-05-16T01:27:01.167Z"
---
计算机基本工作原理
=========

计算机基本工作原理
=========

冯诺依曼结构基本思想
----------

冯诺依曼结构基本思想主要包括以下几个方面：

1.  采用“存储程序”工作方式：将事先编写好的程序和原始数据送入主存后才能执行程序，一旦程序被启动执行，计算机能在不需要操作人员干预下自动完成逐条指令取出和执行的任务。
2.  计算机由运算器、控制器、存储器、输入设备和输出设备5个基本部件组成。
3.  存储器不仅能存放数据，也能存放指令。形式上数据和指令没有区别，但计算机能区分它们；控制器应能自动执行指令；运算器能进行算术运算，也能进行逻辑运算；操作人通过输入/输出设备使用计算机。
4.  计算机内部以二进制形式表示指令和数据；每条指令由操作码和地址码两部分组成，操作码指出操作类型，地址码指出操作数的地址；由一串指令组成程序。

冯诺依曼机基本结构
---------

根据冯诺依曼结构基本思想，可以给出一个模型计算机的基本硬件结构。如图1.1所示。

![](https://img2022.cnblogs.com/blog/1334023/202205/1334023-20220503085901999-146236179.png)

图1.1 模型机的硬件基本结构

模型机主要包括：

1.  用来存放指令和数据的**主存储器**，简称**主存**或**内存**。
2.  用来进行逻辑运算的部件，即**算术逻辑部件**（Arithmetic Logic Unit，简称ALU），在ALU操作控制信号ALUop的控制下，ALU可以对输入端A和B进行不同的运算，得到结果F。
3.  用于自动逐条取出指令并进行译码的部件，即**控制部件**（Control Unit，简称CU），也称**控制器**。
4.  用来和用户交互的输入设备和输出设备。

在图1.1中，为了临时存放从主存取来的数据或运算的结果，还需要若干**通用寄存器**（General Purpose Register），组成**通用寄存器组**（GPRs），ALU两个输入端A和B的数据来自通用寄存器；ALU运算的结果会产生标志信息，例如：结果是否为0（零标志ZF）、是否为负数（符号标志SF）等，这些标志信息需要记录在专门的**标志寄存器**中；从主存取来的指令需要临时保存在**指令寄存器**（Instruction Register，简称IR）中；CPU为了自动按序读取主存中的指令，还需要有一个**程序计数器**（Program Counter，简称PC），在执行当前指令过程中，自动计算出下一条指令的地址并送到PC中保存。通常把控制部件、运算部件和各类寄存器互连组成的电路称为**中央处理器**（Central Procesing Unit，简称CPU），简称处理器。

CPU需要从通用寄存器中取数据到ALU运算，或把ALU运算的结果保存到通用寄存器中，因此，需要给每个通用寄存器进行编号；同样，主存中每个单元也需要编号，称为**主存单元地址**，简称**主存地址**。 通用急促器和主存都属于存储部件，通常，计算机中的存储部件从0开始编号，例如，图1.1中4个通用寄存器编号分别为0~3；16个主存单元编号分别为0~15。

CPU为了从主存取指令和存取数据，需要通用传输介质与主存相连，通常把连接不同部件进行信息传输的介质称为**总线**，其中，包含了用于传输地址信息、数据信息和控制信息的地址线、数据线和控制线。CPU访问主存时，需先将主存地址、读写命令分别送到总线的地址线、控制线，然后通过数据线发送或接收数据。CPU送到地址线的主存地址应先存放在**主存地址寄存器**（Memary Adies Regster，简称MAR）中，发送到或从数据线取来的信息存放在**主存数据寄存器**（Memory Data Register，简称MDR）中。

程序和指令的执行过程
----------

冯诺依曼结构计算机的功能通过执行程序实现，程序的执行过程就是所包含的指令执行过程。

**指令**（instruction）是用0和1表示的一串0/1序列，用来指示CPU完成一个特定的原子操作。例如，**取数指令**（load）从主存单元中取出数据存放到通用寄存器中；**存数指令**（store）将通用寄存器的内容写入主存单元；**加法指令**（add）将两个通用寄存器内容相加后送入结果寄存器；**传送指令**（mov）将一个通用寄存器的内容传送到另一个通用寄存器；如此等等。

指令通常被划分为若干个字段，有操作码、地址码等字段。**操作码字段**指出指令的操作类型，如取数、存数、加、减、传送、跳转等；**地址码字段**指出指令所处理的操作数的地址，如寄存器编号、主存单元编号等。

下面用一个简单的例子说明在图1.1所示的计算机上程序和指令的执行过程。假定图1.1所示的模型机字长为8位；有4个通用寄存器r0~r3，编号分别为0~3；有16个主存单元，编号为0~15。每个主存单元和CPU的ALU、通用寄存器、IR、MDR的宽度都是8位，PC和MAR的宽度都是4位；连接CPU和主存的总线中有4位地址线、8位数据线和若干控制线（包括读写命令线）。该模型机采用8位定长指令字，即每条指令有8位，指令格式有R型和M型两种，如图1.2所示。

![](https://img2022.cnblogs.com/blog/1334023/202205/1334023-20220503095115471-1703658704.png)

 图1.2 定长指令字格式

图1.2中，op为操作码字段，R型指令的op为0000、0001时，分别定义为寄存器间传送（mov）和加（add）操作，M型指令的op为1110和1111时，分别定义为取数（load）和存数（store）操作；rs和rt为通用寄存器编号；addr为主存单元地址。

图1.2中，R\[r\]表示编号为r的通用寄存器中的内容，M\[addr\]表示地址为addr的主存单元的内容，“←”表示从右向左传送数据。指令1110  0110的功能为R\[0\]←M\[0110\]表示将6号主存单元（地址为0110）中的内容取到0号寄存器；指令0001 0001的功能为R\[0\]←R\[0\]+R\[1\]，表示将0号和1号寄存器内容相加的结果送到0号寄存器。

若在该模型机上实现z=x+y，x和y分别存放在主存5号和6号单元中，结果z存放在7号单元中，则相应程序在主存单元中的初始内容如图1.3所示。

![](https://img2022.cnblogs.com/blog/1334023/202205/1334023-20220503105158057-727735502.png)

图1.3 实现z=x+y的程序在主存单元中的初始内容

“存储程序”工作方式规定，程序执行前，需将程序包含的指令和数据先送入主存，一旦启动程序执行，则计算机必须能够在不需要操作人员干预下自动完成逐条指令取出和执行的任务。如1.4所示，一个程序的执行就是周而复始地执行一条条指令的过程。每条指令的执行过程包括：从主存取指令、对指令进行译码、PC增量（途中的PC+“1”表示PC的内容加上当前这一条指令的长度 ）、取操作数并执行、将结果送主存或寄存器保存。

![](https://img2022.cnblogs.com/blog/1334023/202205/1334023-20220503105644384-30293107.png)

图1.4 程序执行过程

程序执行前。首先将程序的起始地址存放在PC中，取指令时，将PC的内容作为地址访问主存。每条指令执行过程中，都需要计算下条将执行指令的主存地址，并送到PC中。若当前指令为顺序型指令，则下条指令为PC的内容加上当前指令的长度；若当前指令为跳转型指令，则下条指令地址为指令中指定的目标地址。当前指令执行完后，根据PC的值到主存中取到的是下条将要执行的指令，因而计算机能够周而复始地自动取出并执行一条条指令。

对于图1.3中的程序，程序首地址（即指令I1所在地址）为0，因此，程序开始执行时，PC的内容为0000。根据程序执行流程，该程序运行过程中，所执行的指令顺序为I1→I2→I3→I4→I5。每条指令在图1.1所示模型机中的执行过程及结果如图1.5所示。

![](https://img2022.cnblogs.com/blog/1334023/202205/1334023-20220503135657754-569664016.png)

图1.5 实现z=x+y功能的每条指令执行过程

如图1.5所示，在图1.1的模型机中执行指令I1的过程如下：指令I1存放在第0单元，故取指令操作为IR←M\[0000\]，表示将主存0单元中的内容取到指令寄存器IR中，故取指令阶段结束时，IR中内容为1110 0110；然后，将高4位1110（op字段）送到控制部件进行指令译码；同时控制PC进行“+1”操作，PC内容变为0001；因为是取数指令，所以控制器产生“主存读”控制信号Read，同时控制在取数并执行阶段将Read信号送控制线、指令后4位的0110（addr字段）作为主存地址送MAR并自动送地址线，经过一段时间以后，主存将0110（6#）单元中的33（变量y）送到数据线并自动存储在MDR中；最后由控制器控制将MDR内容送0号通用寄存器，因为，指令I1的执行结果为R\[0\]=33。其他指令的执行过程类似。程序最后执行的结果为主存0111（7#）单元内容（变量z）变为49，即M\[7\]=49。

指令执行各阶段都包含若干个微操作，微操作需要相应的控制信号进行控制。

取指令阶段IR←M\[PC\]微操作有：MAR←PC；控制线←Read；IR←MDR。

取数阶段R\[0\]←M\[addr\]微操作有：MAR←addr；控制线←Read；R\[0\]←MDR。

存数阶段M\[addr\]←R\[0\]微操作有：MAR←addr；MRD←R\[0\]；控制线←Write。

ALU运算R\[0\]←R\[0\]+R\[1\]微操作有：A←R\[0\]；B←R\[1\]；ALUop←add；R\[0\]←F。

ALU操作有加（add）、减（sub）、与（and）、或（or）、传送（mov）等类型，如图1.1所示，ALU操作控制信号ALUop可以控制ALU进行不同的运算。例如，ALUop←mov时，ALU的输出F=A；ALUop←add时，ALU的输出F=A+B。

这里的Read、Write、mov、add等微操作控制信号都是控制部件对op字段进行译码后送出的，如图1.1中的虚线所示就是控制信号线。每条指令执行过程中，所包含的微操作具有先后顺序关系，需要定时信号进行定时。通常，CPU中所有微操作都由时钟信号进行定时，时钟信号的宽度为一个时钟周期。一条指令的执行时间包含一个或多个时钟周期。