---
layout: post
title: "上周内容回顾"
date: "2022-07-03T12:31:13.887Z"
---
上周内容回顾
======

内容回顾
====

*   列表的内置方法list

    列表在调用内置方法之后不是产生新的值,而是改变它的自身
    1.统计列表内数据的个数
    	关键字:len
    2.增
    2.1 尾部追加一个数据
    	关键字:append() 括号内无论放什么数据类型，都会当一个整体追加
    2.2 任何位置追加一数据
    	关键字:insert() 括号内不管放什么数据类型，也是会当一个整体追加
    2.3扩展列表
    方式一: for 循环
    方式二: 使用 + 号
    方式三: extend() 括号内必须是支持 for循环的数据类型
    推荐使用第三种方式 底层原理就是 for循环加append方法
    3.查询数据或修改
    3.1 查询数据 通过索引即可
    3.2 修改数据 把需要修改的数据值索引修改
    4.删除数据
    4.1 通用删除策略
    	关键字:del 索引修改
    4.2 指名道姓的删
    	关键字:remove() 括号内放入明确要删除的数据值
    4.3 先取出数据值 然后再删
    	关键字:pop() 什么都不放默认取出尾部数据值 然后再删
    	同时也可以通过索引取出数据值 然后再删除
    5.查看数据值对应的索引值
    	关键字:index()
    6.统计某个数据值出现的次数
    	关键字:count()
    7.排序
    	升序 关键字:sort
    	降序 关键字:sort(reverse = True)
    8.翻转
    	关键字:reverse 前后跌倒
    9.比较运算
    	l1 = [66,22]
    	l2 = [11,22,33,44,55]
    	print(l1 > l2) # True 按照第一个位置来比较
    

*   字典的内置方法

    类型转换
    字典很少涉及到类型转换 都是直接定义使用
    1.字典内的K:V键值对是无序的 所以无法索引取值
    2.取值操作
    	关键字:get
    3.统计字典内数据的个数
    	关键字:len
    4.修改数据与新增
    	通过索引K 来修改
    	在没有K 的时候是增加
    5.删除数据
    方式一
    	关键字:del
    方式二
    	关键字:pop
    方式三
    	关键字:popitem
    6.快速获取键、值、键值对数据
    方式一
    	关键字:keys()
    方式二
    	关键字:values()
    方式三
    	关键字:items()
    8.修改字典数据 键存在则是修改 不存在则是新增
    	关键字:updata
    9.快速构造字典 给的值默认 
    	关键字:fromkeys
    10.键存在获取对应的数据值 键不存在设置并返回新的值
    	关键字:setdefault
    

*   元组的内置方法

    支持 for循环的数据类型都可以转成元组
    1.索引取值
    2.统计元组内数据的个数 len
    3.查与改
    	元组支持查看 不支持修改
    

*   集合的内置方法

    类型转换
    	支持 for循环的 并且数据必须是不可变类型
    1.定义空集合 set()
    2.集合内数据必须是不可变类型(整型 浮点型 字符串 元组 布尔值)
    3.集合自带去重功能
    4.关系运算
    	& | ^ > <
    

*   可变类型与不可变类型

    1.可变的类型:list
    	值改变(内存方法) 内存地址可以不变
    列表内置方法是修改自身,索引是可变类型
    2.不可变的类型:str int float
    	值改变(内置方法) 内存地址肯定变
    字符串的内置方法是产出一个新的数据 需要用另一个变量名接收 所以是不可变类型
    

*   垃圾回收机制

    什么是垃圾回收机制
    	在python中编辑会产生很多的数据值 当没有绑定变量名的数据值则会被当成垃圾回收
    '''python会自动申请内存和释放空间'''
    1.引用计数
    	当数据值身上计数不为0时表示还有用 不会被回收
    	当数据值身上计数为0时 则会被垃圾机制当成垃圾给回放
    2.标记清除
    	专门用于解决循环引用的问题 将内存中所产生的数据值全部检查一遍 是否存在循环打上标记后一次性清除
    3.分代回收
    	标记清除每隔一段时间就要把所以的数据排查一遍 资源消耗过大
    	为了减轻垃圾机制的资源损耗 所以开发了三代垃圾管理机制 越往下排查的的频率就越低
    

*   字符编码简介

    1.只有文本文件才有字符的概念
    2.计算机内部存取的数据本质(二进制)
    	计算机其实只认识0和1
    3.为什么我们在使用计算机的时候能随意敲出各国的文字
    	因为计算机不认识我们人家的语言 所以我们人类定义了一种数字的转换关系
    4.转换关系不能随便改变 应该有统一的标准
    	字符编码表 记录了人类的字符与数据对应的关系
    

*   字符编码的发展史

    1.一家独大
    	计算机是由美国人发明的 美国人需要让计算机识别英文字符
    ps:英文所有的字符加起来不超过127个(2的七次方)但是美国人考虑到后续可能会出现新的字符所以加了以备不时之需(2的八次方)
    ASCII编码表:内部记录了英文字符与数字的对应关系 1bytes来储存字符
    2.群雄割据
    因为ASCII编码表只能表示英文不能表示中文,后来我们中国就开发了一套可以识别中文的编码表
    	GBK编码表:内部记录了中文字符、英文字符与数据的对应关系
    		2bytes起步储存中文(遇到生僻字会使用更多的字节)
    		1bytes储存英文
    韩国所对应的编码表
    	EUS_kr编码表:内部记录了韩文、英文字符与数字的对应关系
    日本所对应的编码表
    	shift_JIS编码表:内部记录了日文、英文字符与数字的对应关系
    注意:此时各国的计算机文件文本无法直接交互 会出现乱码的情况
    3.天下统一
    万国码(unicde):兼容万国的字符
    	所有的字符都以2bytes起步储存
    utf家族(针对unicde版本的优化):utf8
    	英文还是采用1bytes
    	其他统一采用3bytes
    注:内存使用unicde 硬盘使用utf8
    

*   字符编码的实操

    1.只有字符串可以参与编码与解码 其他数据类型需要先转换成字符串才可以
    2.如何解决乱码
    	当初使用什么代码存的就使用什么代码来解
    3.编码与解码
    	把人类的字符按照指定的编码转换成计算机能识别的数字
    4.解释器层面
    	python2默认的编码是ASCII码
    	文件头 # coding:utf8
    	定义字符串:需要在字符串的前面加上u
    为什么要这么做呢 因为python2的时候还没有发明出utf8 所有只能采取补救措施
    	python默认的编码就是utf8
    

*   文件的操作介绍

    1.文件操作
    	通过编写代码自动来操作文件读写
    2.什么是文件
    	双击文件图标是从硬盘加载数据到内存
    	写文件之后保存其实就是将内存的数据刷到硬盘
    	文件其实就是操作系统暴露给用户操作计算机的快捷方式之一
    3.如何使用代码操作文件
    	open('文件路径','读写模式','字符编码')
    	方法一:
    	f = open()
    	f.close()
    	方法二:
    	with open() as 变量名
    	子代码运行之后自动调用close()方法
    4.针对文件路径可能有特殊含义字母与撬棍的组合
    	在字符串的前面加上字母'r'取消特殊含义
    

*   文件的读写模式

    '''补充知识
    1.with语法支持一次性打开多个文件
    with open(r'a.txt','r',encoding='utf8') as f1, open(r'b.txt','r',encoding='utf8') as f2, open(r'c.txt','r'encoding='utf8') as f3...
    2.补全python语法 但是不执行任何操作
    	pass (推荐使用)
    	... 不推荐使用
    3.通常情况下英语单词的结尾如果加上了able表示该单词具备了描写能力
    	readable 具备读取内容的能力
    	writable 具备填写内容的能力
    '''
    1.r模式的使用 (默认的只读)
    	with open(r'a.txt','r'encoding='utf8') as f:
    	res = f.read()
    	print(res)
    如果文件不存在时则会报错 文件存在时会打开等待读取
    2.w模式的使用 只写
    	with open(r'b.txt','w'encoding='utf8') as f:
    	f.write('你们好鸭\n')
    	f.write('我是新来的\n')
    当文件不存在时会创建一个空文件 文件存在时会清空文件内容等待填写新的内容
    3.a模式的使用(只追加写)
    	with open(r'c.txt','a',encoding='utf8') as f:
    	f.write('你们好鸭\n')
    	f.write('我是新来的\n')
    当文件不存在时会创建空文件 不会清空该文件里的内容 只会在文件的末尾等待填写新的内容
    

*   文件的操作模式

    文本模式 t
    	rt，wt，at
    1.只能操作文本文件
    2.必须指定encoding参数
    3.读写都是以字符串为单位
    二进制模式 bytes
    	rb，wb，ab 必须自己指定 不能省略
    1.能够操作所有类型的文件
    2.不需要指定encoding参数
    3.读写都是以bytes为单位
    

*   文件的诸多方法

    read() # 一次性读取文件的内容并且光标会停在末尾 继续读取则为空
    readdline() # 一次只读一行内容
    readdlines() # 按照行的方式读取所有内容并组织成列表的方式返回
    readable() # 判断文件是否可读
    writable() # 判断文件是否可写
    write() # 填写文件内容
    writelines() # 支持填写容器类型 内部可以存放多个数据值类型
    flush() # 将内存文件数据立刻刷到硬盘 (相当于主动帮按了ctrl+s)
    '''当文件数据比较大时，不建议一次性读取'''
    可以使用 for循环读取 文件支持 for循环一次只读一行
    	for line in f:
    	print(line)
    

*   文件内光标的移动

    1.在文本模式下read的括号内数字是几就表示读多少个字节
    with open(r'a.txt','r',encoding='utf8')as f:
    	data = f.read(3)
    	print(data)
    2.在二进制模式下read的括号内数字是几就表示读多少个字节,英文是一个字节 中文是三个字节 括号内的数字不能大于小于字节 否则和报错
    with open(r'a.txt','rb')as f:
    	data = f.read(3)
    	print(data.decode.('utf8'))
    f.tell() 获取光标的移动的字节数
    seek(offset,whence) 模式
    	offset 控制光标移动的位移量
    	whence模式0,1,2
    	0的参照物是从文件开头的位置
    	1的参照物是从光标当前所在的位置
    	2的参照物是从文件末尾的位置 应该倒着移动
    注:1和2模式只能在二进制模式下使用 0无所谓
    

*   文件的数据修改

    """机械硬盘的存储数据原理
    	1.数据的修改 其实就是覆盖写
    	2.数据的删除 占有态跟自由态"""
    修改方式一
    覆盖写:先读取文件里的内容到内存 在内存中完成修改 之后w模式打开该文件写入
    	with open(r'a.txt','r',encoding='utf8')as f:
    		data = f.read()
    	new_data = data.replace('你好'，'不好')
    	with open(r'a.txt','w',encoding='utf8')as f1:
    		f1.write(new.data)
    优点是只占用硬盘一块空间
    缺点就是数据量比较大的时候会造成内存爆满
    修改方式二
    重命名:先将文件内容读取至内存 在内存中完成修改 之后在保存到另一个文件中 在将原来的文件删除 将新的文件重命名原文件
    import os
    with open('a.txt','r'encoding='utf8')as f,\ 
    open('.a.txt.swap','w',encoding='utf8')as wrife_f:
    	for line in read_f:
    	  wrife_f.write(line.replace('Sb','Nb'))
    os.remove('a.txt')
    os.rename('.a.txt.swap','a.txt')
    优点 不会造成内存溢出
    缺点是可能会有那么一段时间需要占用两个硬盘空间 也可能是在内存没刷在硬盘