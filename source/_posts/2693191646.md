---
layout: post
title: "Android 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - SurfaceFlinger  GPUåˆæˆ/CLIENTåˆæˆæ–¹å¼ - éšç¬”1"
date: "2022-05-10T01:18:04.216Z"
---
Android 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - SurfaceFlinger GPUåˆæˆ/CLIENTåˆæˆæ–¹å¼ - éšç¬”1
============================================================

SurfaceFlingerä¸­çš„å›¾å±‚é€‰æ‹©GPUåˆæˆ(CLIENTåˆæˆæ–¹å¼)æ—¶ï¼Œä¼šæŠŠå¾…åˆæˆçš„å›¾å±‚é€šè¿‡ renderengine ç»˜åˆ¶åˆ°ä¸€å—GraphicBufferä¸­ï¼Œç„¶åæŠŠè¿™å—å›¾å½¢ç¼“å­˜é€šè¿‡è°ƒç”¨setClientTargetä¼ é€’ç»™HWCæ¨¡å—ï¼ŒHWCè¿›ä¸€æ­¥å¤„ç†åæŠŠè¿™ä¸ªGraphicBufferä¸­çš„å›¾åƒå‘ˆç°åˆ°å±å¹•ä¸Šã€‚æœ¬ç¯‡å°†ä»‹ç»GPUåˆæˆçš„ç›®çš„GraphicBufferæ˜¯ä»å“ªé‡Œæ¥çš„ï¼Ÿ

* * *

**å¿…è¯»ï¼š**

#### **Android 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - å¼€ç¯‡**

* * *

ä¸€ã€å‰è¨€
----

`**SurfaceFlinger**`ä¸­çš„å›¾å±‚é€‰æ‹©GPUåˆæˆ(CLIENTåˆæˆæ–¹å¼)æ—¶ï¼Œä¼šæŠŠå¾…åˆæˆçš„å›¾å±‚Layersé€šè¿‡`**renderengine(SkiaGLRenderEngine)**`ç»˜åˆ¶åˆ°ä¸€å—`**GraphicBuffer**`ä¸­ï¼Œç„¶åæŠŠè¿™å—`**GraphicBuffer**`å›¾å½¢ç¼“å­˜é€šè¿‡è°ƒç”¨`**setClientTarget**`ä¼ é€’ç»™HWCæ¨¡å—ï¼ŒHWCè¿›ä¸€æ­¥å¤„ç†åæŠŠè¿™ä¸ª`**GraphicBuffer**`ä¸­çš„å›¾åƒå‘ˆç°åˆ°å±å¹•ä¸Šã€‚

æœ¬ç¯‡æ–‡ç« ï¼Œæˆ‘ä»¬å…ˆèšç„¦ä¸€ç‚¹åšä»‹ç»ï¼šç”¨äºå­˜å‚¨GPUåˆæˆåçš„å›¾å½¢æ•°æ®çš„`**GraphicBuffer**`æ˜¯ä»å“ªé‡Œæ¥çš„ï¼Ÿä¸‹é¢çš„è®²è§£ä¼šå›´ç»•è¿™ä¸ªé—®é¢˜å±•å¼€ã€‚

äºŒã€ä»dumpsys SurfaceFlingerä¸­çš„ä¿¡æ¯è°ˆèµ·
-------------------------------

å¦‚æœä½ æŸ¥çœ‹è¿‡`**dumpsys SurfaceFlinger**`çš„ä¿¡æ¯ï¼Œä¹Ÿè®¸ä½ æ³¨æ„è¿‡ä¸€äº›`**GraphicBufferAllocator/GraphicBufferMapper**`æ‰“å°å‡ºçš„ä¸€äº›ä¿¡æ¯ï¼Œè¿™äº›ä¿¡æ¯è®°å½•äº†æ‰€æœ‰é€šè¿‡Grallocæ¨¡å—allocateå’Œimportçš„å›¾å½¢ç¼“å­˜çš„ä¿¡æ¯ã€‚

å¦‚ä¸‹æ˜¯åœ¨æˆ‘çš„å¹³å°ä¸‹æˆªå–çš„`**dumpsys SurfaceFlinger**`éƒ¨åˆ†ä¿¡æ¯ï¼š

    GraphicBufferAllocator buffers:
        Handle |        Size |     W (Stride) x H | Layers |   Format |      Usage | Requestor
    0xf3042b90 | 8100.00 KiB | 1920 (1920) x 1080 |      1 |        1 | 0x    1b00 | FramebufferSurface
    0xf3042f30 | 8100.00 KiB | 1920 (1920) x 1080 |      1 |        1 | 0x    1b00 | FramebufferSurface
    0xf3046020 | 8100.00 KiB | 1920 (1920) x 1080 |      1 |        1 | 0x    1b00 | FramebufferSurface
    Total allocated by GraphicBufferAllocator (estimate): 24300.00 KB
    Imported gralloc buffers:
    + name:FramebufferSurface, id:e100000000, size:8.3e+03KiB, w/h:780x438, usage: 0x40001b00, req fmt:5, fourcc/mod:875713089/576460752303423505, dataspace: 0x0, compressed: true
    	planes: B/G/R/A:	 w/h:780x440, stride:1e00 bytes, size:818000
    + name:FramebufferSurface, id:e100000001, size:8.3e+03KiB, w/h:780x438, usage: 0x40001b00, req fmt:5, fourcc/mod:875713089/576460752303423505, dataspace: 0x0, compressed: true
    	planes: B/G/R/A:	 w/h:780x440, stride:1e00 bytes, size:818000
    + name:FramebufferSurface, id:e100000002, size:8.3e+03KiB, w/h:780x438, usage: 0x40001b00, req fmt:5, fourcc/mod:875713089/576460752303423505, dataspace: 0x0, compressed: true
    	planes: B/G/R/A:	 w/h:780x440, stride:1e00 bytes, size:818000
    Total imported by gralloc: 5e+04KiB

ä¸Šé¢çš„ä¿¡æ¯ä¸­å¯ä»¥çœ‹åˆ°ä¸€äº›å„¿å†¥å†¥ä¹‹ä¸­è²Œä¼¼ã€ä¼¼ä¹ã€å¥½åƒå¾ˆæœ‰æ„æ€çš„å­—çœ¼ï¼š`**FramebufferSurface**`ã€‚

ä½œä¸ºRequestorçš„`**FramebufferSurface**`å»è¯·æ±‚åˆ†é…äº†**ä¸‰å—**å›¾å½¢ç¼“å­˜ï¼Œè¿˜è§„å®šäº†widthã€heightã€formatã€usageç­‰ä¿¡æ¯ã€‚

* * *

**å¦‚ä¸Šä½ çœ‹åˆ°çš„è¿™3å—GraphicBufferï¼Œå°±æ˜¯ç”¨æ¥å­˜å‚¨CPUåˆæˆåçš„å›¾å½¢æ•°æ®çš„ã€‚**

* * *

ä¸‰ã€åˆ›å»ºä¸åˆå§‹åŒ–FramebufferSurfaceçš„æµç¨‹
-----------------------------

FramebufferSurfaceçš„åˆå§‹åŒ–é€»è¾‘éœ€è¦ä»SurfaceFlingerçš„åˆå§‹åŒ–è°ˆèµ·ï¼Œåœ¨æ–‡ç« Android 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - SurfaceFlingerçš„å¯åŠ¨å’Œæ¶ˆæ¯é˜Ÿåˆ—å¤„ç†æœºåˆ¶ï¼ˆå››ï¼‰

ä¸­ï¼Œæ›¾åˆ†æè¿‡ï¼Œ`**SurfaceFlinger::init()**`ä¸­ä¼šå»æ³¨å†ŒHWCçš„å›è°ƒå‡½æ•°`**mCompositionEngine->getHwComposer().setCallback(this)**`ï¼Œå½“ç¬¬ä¸€æ¬¡æ³¨å†Œcallbackæ—¶ï¼Œ`**onComposerHalHotplug()**`ä¼šç«‹å³åœ¨è°ƒç”¨`**registerCallback()**`çš„çº¿ç¨‹ä¸­è¢«è°ƒç”¨ï¼Œå¹¶è·¨è¿›ç¨‹å›è°ƒåˆ°`**SurfaceFlinger::onComposerHalHotplug**`ã€‚ç„¶åä¸€è·¯é£å¥”ï¼š

![](https://img2022.cnblogs.com/blog/979092/202205/979092-20220509135556061-1763416853.png)

åœ¨`**SurfaceFlinger::processDisplayAdded**`è¿™ä¸ªæ–¹æ³•ä¸­å»åˆ›å»ºäº†BufferQueueå’ŒFramebufferSurfaceï¼Œç®€å•ç†è§£ä¸ºè¿æ¥ä¸Šäº†æ˜¾ç¤ºå±å¹•(Display)ï¼Œé‚£å°±è¦ç»™å‡†å¤‡ä¸€ä¸ªBufferQueueï¼Œä»¥ä¾¿GPUåˆæˆUIç­‰å›¾å±‚æ—¶ï¼Œå¯ä»¥å‘è¿™ä¸ªBufferQueueç´¢è¦GraphicBufferæ¥å­˜å‚¨åˆæˆåçš„å›¾å½¢æ•°æ®ï¼Œå†å‘ˆç°åˆ°å±å¹•ä¸Šå»ï¼ˆæˆ‘çš„å‚»ç“œå¼ç†è§£ï¼‰

æ‘˜å–å…³é”®ä»£ç å¦‚ä¸‹ï¼š

    [/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp]
    void SurfaceFlinger::processDisplayAdded(const wp<IBinder>& displayToken,
                                             const DisplayDeviceState& state) {
        ......
        sp<compositionengine::DisplaySurface> displaySurface; 
        sp<IGraphicBufferProducer> producer;
        // åˆ›å»ºBufferQueue,è·å–åˆ°ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ï¼Œè€Œä¸”æ¶ˆè´¹è€…ä¸æ˜¯SurfaceFlingerå“¦
        sp<IGraphicBufferProducer> bqProducer;
        sp<IGraphicBufferConsumer> bqConsumer;
        getFactory().createBufferQueue(&bqProducer, &bqConsumer, /*consumerIsSurfaceFlinger =*/false);
    
        if (state.isVirtual()) { // è™šæ‹Ÿå±å¹•ï¼Œä¸ç®¡å®ƒ
            const auto displayId = VirtualDisplayId::tryCast(compositionDisplay->getId());
            LOG_FATAL_IF(!displayId);
            auto surface = sp<VirtualDisplaySurface>::make(getHwComposer(), *displayId, state.surface,
                                                           bqProducer, bqConsumer, state.displayName);
            displaySurface = surface;
            producer = std::move(surface);
        } else { // çœ‹è¿™ä¸ªcase
            ALOGE_IF(state.surface != nullptr,
                     "adding a supported display, but rendering "
                     "surface is provided (%p), ignoring it",
                     state.surface.get());
            const auto displayId = PhysicalDisplayId::tryCast(compositionDisplay->getId());
            LOG_FATAL_IF(!displayId);
            // åˆ›å»ºäº†FramebufferSurfaceå¯¹è±¡ï¼ŒFramebufferSurfaceç»§æ‰¿è‡ªcompositionengine::DisplaySurface
            // FramebufferSurfaceæ˜¯ä½œä¸ºæ¶ˆè´¹è€…çš„è§’è‰²å·¥ä½œçš„ï¼Œæ¶ˆè´¹SF GPUåˆæˆåçš„å›¾å½¢æ•°æ®
            displaySurface =
                    sp<FramebufferSurface>::make(getHwComposer(), *displayId, bqConsumer,
                                                 state.physical->activeMode->getSize(),
                                                 ui::Size(maxGraphicsWidth, maxGraphicsHeight));
            producer = bqProducer;
        }
    
        LOG_FATAL_IF(!displaySurface);
        // åˆ›å»ºDisplayDeviceï¼Œå…¶åˆå»åˆ›å»ºRenderSurfaceï¼Œä½œä¸ºç”Ÿäº§è€…è§’è‰²å·¥ä½œï¼ŒdisplaySurfaceå°±æ˜¯FramebufferSurfaceå¯¹è±¡
        const auto display = setupNewDisplayDeviceInternal(displayToken, std::move(compositionDisplay),
                                                           state, displaySurface, producer);
        mDisplays.emplace(displayToken, display);
        ......   
    }

ç…ä¸€ç… FramebufferSurafaceçš„æ„é€ å‡½æ•°ï¼Œæ²¡å•¥å¤æ‚çš„ï¼Œå°±æ˜¯ä¸€äº›è®¾ç½®ï¼Œåˆå§‹åŒ–ä¸€äº›æˆå‘˜

    FramebufferSurface::FramebufferSurface(HWComposer& hwc, PhysicalDisplayId displayId,
                                           const sp<IGraphicBufferConsumer>& consumer,
                                           const ui::Size& size, const ui::Size& maxSize)
          : ConsumerBase(consumer),
            mDisplayId(displayId),
            mMaxSize(maxSize),
            mCurrentBufferSlot(-1),
            mCurrentBuffer(),
            mCurrentFence(Fence::NO_FENCE),
            mHwc(hwc),
            mHasPendingRelease(false),
            mPreviousBufferSlot(BufferQueue::INVALID_BUFFER_SLOT),
            mPreviousBuffer() {
        ALOGV("Creating for display %s", to_string(displayId).c_str());
    
        mName = "FramebufferSurface";
        mConsumer->setConsumerName(mName); // è®¾ç½®æ¶ˆè´¹è€…çš„åå­—æ˜¯ "FramebufferSurface"
        mConsumer->setConsumerUsageBits(GRALLOC_USAGE_HW_FB |  // è®¾ç½®usage
                                           GRALLOC_USAGE_HW_RENDER |
                                           GRALLOC_USAGE_HW_COMPOSER);
        const auto limitedSize = limitSize(size);
        mConsumer->setDefaultBufferSize(limitedSize.width, limitedSize.height); // è®¾ç½®buffer å¤§å°
        mConsumer->setMaxAcquiredBufferCount( 
                SurfaceFlinger::maxFrameBufferAcquiredBuffers - 1);
    }

å†è¿›åˆ°`**SurfaceFlinger::setupNewDisplayDeviceInternal**`ä¸­çœ‹çœ‹ç›¸å…³çš„é€»è¾‘ï¼š

    [/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp]
    sp<DisplayDevice> SurfaceFlinger::setupNewDisplayDeviceInternal(
            const wp<IBinder>& displayToken,
            std::shared_ptr<compositionengine::Display> compositionDisplay,
            const DisplayDeviceState& state,
            const sp<compositionengine::DisplaySurface>& displaySurface, 
            const sp<IGraphicBufferProducer>& producer) {
        ......
        creationArgs.displaySurface = displaySurface;  // displaySurfaceå°±æ˜¯FramebufferSurfaceå¯¹è±¡   
        
        // produceræ˜¯å‰é¢processDisplayAddedä¸­åˆ›å»ºçš„
        auto nativeWindowSurface = getFactory().createNativeWindowSurface(producer);
        auto nativeWindow = nativeWindowSurface->getNativeWindow();
        creationArgs.nativeWindow = nativeWindow;
    
        ....
        // å‰é¢ä¸€å¤§å¨ä»£ç æ˜¯åœ¨åˆå§‹è¯creationArgsï¼Œè¿™äº›å‚æ•°ç”¨æ¥åˆ›å»ºDisplayDevice
        // creationArgs.nativeWindowä¼šæŠŠå‰é¢åˆ›å»ºçš„producerå…³è”åˆ°äº†DisplayDevice
        sp<DisplayDevice> display = getFactory().createDisplayDevice(creationArgs);
        
        // åé¢ä¸€å¤§å¨ï¼Œå¯¹displayè¿›è¡Œäº†äº›è®¾ç½®
        if (!state.isVirtual()) {
            display->setActiveMode(state.physical->activeMode->getId());
            display->setDeviceProductInfo(state.physical->deviceProductInfo);
        }
        ....
    }

æ¥ä¸‹æ¥å°±æ˜¯ `**DisplayDevice**` çš„æ„é€ å‡½æ•°äº†ï¼Œé‡Œé¢ä¸»è¦æ˜¯åˆ›å»ºäº†RenderSurfaceå¯¹è±¡ï¼Œç„¶åå¯¹å…¶è¿›è¡Œåˆå§‹åŒ–

    [/frameworks/native/services/surfaceflinger/DisplayDevice.cpp]
    DisplayDevice::DisplayDevice(DisplayDeviceCreationArgs& args)
          : mFlinger(args.flinger),
            mHwComposer(args.hwComposer),
            mDisplayToken(args.displayToken),
            mSequenceId(args.sequenceId),
            mConnectionType(args.connectionType),
            mCompositionDisplay{args.compositionDisplay},
            mPhysicalOrientation(args.physicalOrientation),
            mSupportedModes(std::move(args.supportedModes)),
            mIsPrimary(args.isPrimary) {
        mCompositionDisplay->editState().isSecure = args.isSecure;
        // åˆ›å»ºRenderSurfaceï¼Œargs.nativeWindow å³ä¸ºproducer,æŒ‡å‘ç”Ÿäº§è€…
        mCompositionDisplay->createRenderSurface(
                compositionengine::RenderSurfaceCreationArgsBuilder()
                        .setDisplayWidth(ANativeWindow_getWidth(args.nativeWindow.get()))
                        .setDisplayHeight(ANativeWindow_getHeight(args.nativeWindow.get()))
                        .setNativeWindow(std::move(args.nativeWindow))
                        .setDisplaySurface(std::move(args.displaySurface)) // displaySurfaceå°±æ˜¯FramebufferSurfaceå¯¹è±¡
                        .setMaxTextureCacheSize(
                                static_cast<size_t>(SurfaceFlinger::maxFrameBufferAcquiredBuffers))
                        .build());
    
        if (!mFlinger->mDisableClientCompositionCache &&
            SurfaceFlinger::maxFrameBufferAcquiredBuffers > 0) {
            mCompositionDisplay->createClientCompositionCache(
                    static_cast<uint32_t>(SurfaceFlinger::maxFrameBufferAcquiredBuffers));
        }
    
        mCompositionDisplay->createDisplayColorProfile(
                compositionengine::DisplayColorProfileCreationArgs{args.hasWideColorGamut,
                                                                   std::move(args.hdrCapabilities),
                                                                   args.supportedPerFrameMetadata,
                                                                   args.hwcColorModes});
    
        if (!mCompositionDisplay->isValid()) {
            ALOGE("Composition Display did not validate!");
        }
        // åˆå§‹åŒ–RenderSurface
        mCompositionDisplay->getRenderSurface()->initialize();
    
        setPowerMode(args.initialPowerMode);
    
        // initialize the display orientation transform.
        setProjection(ui::ROTATION_0, Rect::INVALID_RECT, Rect::INVALID_RECT);
    }

æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-05-10 å‘å¸ƒäºåšå®¢å›­

RenderSurfaceä½œä¸ºç”Ÿäº§è€…çš„è§’è‰²å·¥ä½œï¼Œæ„é€ å‡½æ•°å¦‚ä¸‹ï¼Œç•™æ„å¯æˆå‘˜displaySurfaceå°±æ˜¯SurfaceFlingerä¸­åˆ›å»ºçš„FramebufferSurfaceå¯¹è±¡

ä¹Ÿå°±æ˜¯ ä½œä¸ºç”Ÿäº§è€…çš„RenderSurfaceä¸­æŒæœ‰ æ¶ˆè´¹è€…çš„å¼•ç”¨ displaySurfaceï¼Œå¯ä»¥å‘¼å«FramebufferSurfaceçš„æ–¹æ³•

    [ /frameworks/native/services/surfaceflinger/CompositionEngine/src/RenderSurface.cpp]
    RenderSurface::RenderSurface(const CompositionEngine& compositionEngine, Display& display,
                                 const RenderSurfaceCreationArgs& args)
          : mCompositionEngine(compositionEngine),
            mDisplay(display),
            mNativeWindow(args.nativeWindow),
            mDisplaySurface(args.displaySurface),  // displaySurfaceå°±æ˜¯FramebufferSurfaceå¯¹è±¡
            mSize(args.displayWidth, args.displayHeight),
            mMaxTextureCacheSize(args.maxTextureCacheSize) {
        LOG_ALWAYS_FATAL_IF(!mNativeWindow);
    }

æˆ‘ä»¬çœ‹çœ‹ä»–çš„`**RenderSurface::initialize()**`æ–¹æ³•

    [/frameworks/native/services/surfaceflinger/CompositionEngine/src/RenderSurface.cpp]
    void RenderSurface::initialize() {
        ANativeWindow* const window = mNativeWindow.get();
    
        int status = native_window_api_connect(window, NATIVE_WINDOW_API_EGL);
        ALOGE_IF(status != NO_ERROR, "Unable to connect BQ producer: %d", status);
        status = native_window_set_buffers_format(window, HAL_PIXEL_FORMAT_RGBA_8888);
        ALOGE_IF(status != NO_ERROR, "Unable to set BQ format to RGBA888: %d", status);
        status = native_window_set_usage(window, DEFAULT_USAGE);
        ALOGE_IF(status != NO_ERROR, "Unable to set BQ usage bits for GPU rendering: %d", status);
    }

ä¸Šè¿°æ–¹æ³•ä¹Ÿå¾ˆç®€å•ï¼Œå°±æ˜¯ä½œä¸ºproducerå»å’Œ`**BufferQueue**`å»ºç«‹connectï¼Œå¹¶è®¾ç½®formatä¸ºRGBA\_8888ï¼Œè®¾ç½®usageä¸º`**GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_TEXTURE**`

* * *

ä¸ºäº†éªŒè¯ä¸Šè¿°åˆ†æçš„æµç¨‹æ˜¯æ­£ç¡®çš„ï¼Œæˆ‘åœ¨`**BufferQueueProducer::connect**`ä¸­åŠ logæ¥æ‰“å°è°ƒç”¨æ ˆçš„ä¿¡æ¯ï¼Œå¦‚ä¸‹ï¼Œæ˜¯ä¸æ˜¯å’Œåˆ†æçš„ä¸€æ ·å•Š

    11-13 00:52:58.497   227   227 D BufferQueueProducer: connect[1303] /vendor/bin/hw/android.hardware.graphics.composer@2.4-service start
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#00 pc 0005e77f  /system/lib/libgui.so (android::BufferQueueProducer::connect(android::sp<android::IProducerListener> const&, int, bool, android::IGraphicBufferProducer::QueueBufferOutput*)+1282)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#01 pc 000a276b  /system/lib/libgui.so (android::Surface::connect(int, android::sp<android::IProducerListener> const&, bool)+138)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#02 pc 0009de41  /system/lib/libgui.so (android::Surface::hook_perform(ANativeWindow*, int, ...)+128)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#03 pc 00121b1d  /system/bin/surfaceflinger (android::compositionengine::impl::RenderSurface::initialize()+12)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#04 pc 00083cc5  /system/bin/surfaceflinger (android::DisplayDevice::DisplayDevice(android::DisplayDeviceCreationArgs&)+1168)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#05 pc 000d8bed  /system/bin/surfaceflinger (android::SurfaceFlinger::processDisplayAdded(android::wp<android::IBinder> const&, android::DisplayDeviceState const&)+4440)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#06 pc 000d0db5  /system/bin/surfaceflinger (android::SurfaceFlinger::processDisplayChangesLocked()+2436)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#07 pc 000cef6b  /system/bin/surfaceflinger (android::SurfaceFlinger::processDisplayHotplugEventsLocked()+6422)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#08 pc 000d2c7f  /system/bin/surfaceflinger (android::SurfaceFlinger::onComposerHalHotplug(unsigned long long, android::hardware::graphics::composer::V2_1::IComposerCallback::Connection)+334)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#09 pc 0009afab  /system/bin/surfaceflinger (_ZN7android12_GLOBAL__N_122ComposerCallbackBridge9onHotplugEyNS_8hardware8graphics8composer4V2_117IComposerCallback10ConnectionE$d689f7ac1c60e4abeed02ca92a51bdcd+20)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#10 pc 0001bb97  /system/lib/android.hardware.graphics.composer@2.1.so (android::hardware::graphics::composer::V2_1::BnHwComposerCallback::_hidl_onHotplug(android::hidl::base::V1_0::BnHwBase*, android::hardware::Parcel const&, android::hardware::Parcel*, std::__1::function<void (android::hardware::Parcel&)>)+166)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#11 pc 000275e9  /system/lib/android.hardware.graphics.composer@2.4.so (android::hardware::graphics::composer::V2_4::BnHwComposerCallback::onTransact(unsigned int, android::hardware::Parcel const&, android::hardware::Parcel*, unsigned int, std::__1::function<void (android::hardware::Parcel&)>)+228)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#12 pc 00054779  /system/lib/libhidlbase.so (android::hardware::BHwBinder::transact(unsigned int, android::hardware::Parcel const&, android::hardware::Parcel*, unsigned int, std::__1::function<void (android::hardware::Parcel&)>)+96)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#13 pc 0004fc67  /system/lib/libhidlbase.so (android::hardware::IPCThreadState::transact(int, unsigned int, android::hardware::Parcel const&, android::hardware::Parcel*, unsigned int)+2174)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#14 pc 0004f2e5  /system/lib/libhidlbase.so (android::hardware::BpHwBinder::transact(unsigned int, android::hardware::Parcel const&, android::hardware::Parcel*, unsigned int, std::__1::function<void (android::hardware::Parcel&)>)+36)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#15 pc 0002bdf1  /system/lib/android.hardware.graphics.composer@2.4.so (android::hardware::graphics::composer::V2_4::BpHwComposerClient::_hidl_registerCallback_2_4(android::hardware::IInterface*, android::hardware::details::HidlInstrumentor*, android::sp<android::hardware::graphics::composer::V2_4::IComposerCallback> const&)+296)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#16 pc 0002ed8d  /system/lib/android.hardware.graphics.composer@2.4.so (android::hardware::graphics::composer::V2_4::BpHwComposerClient::registerCallback_2_4(android::sp<android::hardware::graphics::composer::V2_4::IComposerCallback> const&)+34)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#17 pc 00085627  /system/bin/surfaceflinger (android::Hwc2::impl::Composer::registerCallback(android::sp<android::hardware::graphics::composer::V2_4::IComposerCallback> const&)+98)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#18 pc 00092d63  /system/bin/surfaceflinger (android::impl::HWComposer::setCallback(android::HWC2::ComposerCallback*)+2206)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#19 pc 000cd35b  /system/bin/surfaceflinger (android::SurfaceFlinger::init()+438)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#20 pc 000feb03  /system/bin/surfaceflinger (main+862)
    11-13 00:52:58.581   227   227 E BufferQueueProducer: stackdump:#21 pc 0003253b  /apex/com.android.runtime/lib/bionic/libc.so (__libc_init+54)
    11-13 00:52:58.582   227   227 D BufferQueueProducer: connect[1307] /vendor/bin/hw/android.hardware.graphics.composer@2.4-service end

**æ³¨æ„** æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-05-10 å‘å¸ƒäºåšå®¢å›­

**æ³¨æ„** æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-05-10 å‘å¸ƒäºåšå®¢å›­

**æ³¨æ„** æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-05-10 å‘å¸ƒäºåšå®¢å›­

è¿™é‡Œæœ‰ä¸€ä¸ªå°ç»†èŠ‚è¦ç•™æ„ä¸‹ï¼Œå› ä¸º`**SurfaceFlinger::onComposerHalHotplug**`æ˜¯HWCå›è°ƒè¿‡æ¥çš„ï¼Œæ‰€ä»¥ä»£ç æ‰§è¡Œæ˜¯åœ¨`**android.hardware.graphics.composer@2.4-service**`è¿™ä¸ªè¿›ç¨‹ä¸­çš„ã€‚

`**BufferQueueProducer::connect**`ä¸­è®°å½•çš„`**mConnectedPid**`å°±æ˜¯composer serviceçš„PID

    [ /frameworks/native/libs/gui/BufferQueueProducer.cpp]
    mCore->mConnectedPid = BufferQueueThreadState::getCallingPid();

åœ¨dump BufferQueueçš„ä¿¡æ¯æ—¶ï¼Œæ ¹æ®PIDè·å–çš„ producer name ä¹Ÿå°±æ˜¯ `**android.hardware.graphics.composer@2.4-service**`

    [/frameworks/native/libs/gui/BufferQueueCore.cpp]
    void BufferQueueCore::dumpState(const String8& prefix, String8* outResult) const {
        ...
        getProcessName(mConnectedPid, producerProcName);
        getProcessName(pid, consumerProcName);
        ....
    }

å¦‚ä¸‹æ˜¯æˆ‘çš„å¹³å°dumpsys SurfaceFlingerçš„ä¿¡æ¯æ‰“å°å‡ºæ¥çš„Composition RenderSurface Stateçš„ä¿¡æ¯ï¼Œçœ‹çœ‹æ˜¯ä¸æ˜¯å’Œä»£ç çš„è®¾ç½®éƒ½æœ‰å¯¹åº”èµ·æ¥ï¼š

ğŸ˜… mConsumerName=FramebufferSurface

ğŸ¥³ producer=\[342:/vendor/bin/hw/android.hardware.graphics.composer@2.4-service\]

ğŸ˜ consumer=\[223:/system/bin/surfaceflinger\])

ğŸ™„ format/size/usageä¹Ÿéƒ½å¯ä»¥å¯¹åº”åˆ°ä»£ç çš„è®¾ç½®

       Composition RenderSurface State:
       size=[1920 1080] ANativeWindow=0xef2c3278 (format 1) flips=605 
      FramebufferSurface: dataspace: Default(0)
       mAbandoned=0
       - BufferQueue mMaxAcquiredBufferCount=2 mMaxDequeuedBufferCount=1
         mDequeueBufferCannotBlock=0 mAsyncMode=0
         mQueueBufferCanDrop=0 mLegacyBufferDrop=1
         default-size=[1920x1080] default-format=1      transform-hint=00 frame-counter=580
         mTransformHintInUse=00 mAutoPrerotation=0
       FIFO(0):
       (mConsumerName=FramebufferSurface, mConnectedApi=1, mConsumerUsageBits=6656, mId=df00000000, producer=[342:/vendor/bin/hw/android.hardware.graphics.composer@2.4-service], consumer=[223:/system/bin/surfaceflinger])
       Slots:
        >[01:0xeec82110] state=ACQUIRED 0xef4429c0 frame=2 [1920x1080:1920,  1]
        >[02:0xeec806f0] state=ACQUIRED 0xef443100 frame=580 [1920x1080:1920,  1]
         [00:0xeec81f00] state=FREE     0xef440580 frame=579 [1920x1080:1920,  1]

å››ã€å¯¹ä¸Šè¿°åˆ†æçš„ä¸€ä¸ªå°ç»“å’ŒçŒœæƒ³
---------------

ä¸Šè¿°å†…å®¹ä¸­å‡ºç°çš„ä¸€äº›å­—çœ¼ï¼Œä¸ç¦ä»¤äººâ€çæƒ³è¿ç¯‡â€œ

SurfaceFlingeråˆ›å»ºäº†BufferQueue ==> Producer & Consumer

åˆ›å»ºäº†RenderSurfaceä½œä¸ºç”Ÿäº§è€…ï¼Œå®ƒæŒæœ‰Producer

åˆ›å»ºäº†FramebufferSurfaceä½œä¸ºæ¶ˆè´¹è€…ï¼Œå®ƒæŒæœ‰Consumer

å‰é¢åˆ†æBufferQueueçš„å·¥ä½œåŸç†æ—¶ï¼Œæœ‰è®²è¿‡ï¼š

ç”Ÿäº§è€…ä¸æ–­çš„dequeueBuffer & queueBuffer ; è€Œæ¶ˆè´¹è€…ä¸æ–­çš„acquireBuffer & releaseBuffer ,è¿™æ ·å›¾åƒç¼“å­˜å°±åœ¨ ç”Ÿäº§è€… -- BufferQueue -- æ¶ˆè´¹è€… é—´æµè½¬èµ·æ¥äº†ã€‚

çœ‹çœ‹ä½œä¸ºç”Ÿäº§è€…çš„RenderSurfaceä¸­æ–¹æ³•ï¼š

    [/frameworks/native/services/surfaceflinger/CompositionEngine/include/compositionengine/RenderSurface.h]
    /**
     * Encapsulates everything for composing to a render surface with RenderEngine
     */
    class RenderSurface {
        ....
        // Allocates a buffer as scratch space for GPU composition
        virtual std::shared_ptr<renderengine::ExternalTexture> dequeueBuffer(
                base::unique_fd* bufferFence) = 0;
    
        // Queues the drawn buffer for consumption by HWC. readyFence is the fence
        // which will fire when the buffer is ready for consumption.
        virtual void queueBuffer(base::unique_fd readyFence) = 0;
        ...
    };

ç†Ÿæ‚‰çš„å‘³é“ï¼š

dequeueBuffer : åˆ†é…ä¸€ä¸ªç¼“å†²åŒºä½œä¸ºGPUåˆæˆçš„æš‚å­˜ç©ºé—´

queueBuffer :Â  å…¥é˜Ÿåˆ—å·²ç»˜åˆ¶å¥½çš„å›¾å½¢ç¼“å­˜ä¾›HWCä½¿ç”¨

åŒæ ·å¦‚æœå»æŸ¥çœ‹ä½œä¸ºæ¶ˆè´¹è€…çš„FramebufferSurfaceä¹Ÿä¼šçœ‹åˆ°acquireBuffer & releaseBufferçš„è°ƒç”¨ï¼Œå¦‚ä¸‹ï¼š

    [/frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp]
    status_t FramebufferSurface::nextBuffer(uint32_t& outSlot,
            sp<GraphicBuffer>& outBuffer, sp<Fence>& outFence,
            Dataspace& outDataspace) {
        Mutex::Autolock lock(mMutex);
    
        BufferItem item;
        status_t err = acquireBufferLocked(&item, 0); // è·å–å¾…æ˜¾ç¤ºçš„buffer
    
        ...
            
        status_t result = mHwc.setClientTarget(mDisplayId, outSlot, outFence, outBuffer, outDataspace); // ä¼ é€’ç»™HWCè¿›ä¸€æ­¥å¤„ç†æ˜¾ç¤º
    
        return NO_ERROR;
    }

* * *

**å¤§æ¦‚ä¼šæœ‰è¿™æ ·ä¸€ç§é€»è¾‘å¤„ç†æµç¨‹ï¼š**

**å½“éœ€è¦GPUåˆæˆæ—¶ï¼Œä¼šé€šè¿‡ç”Ÿäº§è€…RenderSurface::dequeueBufferè¯·æ±‚ä¸€å—å›¾å½¢ç¼“å­˜ï¼Œç„¶åGPUå°±åˆæˆ/ç»˜å›¾ï¼ŒæŠŠæ•°æ®ä¿å­˜åˆ°è¿™å—å›¾å½¢ç¼“å­˜ä¸­ï¼Œé€šè¿‡RenderSurface::queueBufferæäº¤è¿™å—ç¼“å­˜**

**è°ƒç”¨mDisplaySurface->advanceFrame()é€šçŸ¥æ¶ˆè´¹è€…æ¥æ¶ˆè´¹:**

**FramebufferSurface::advanceFrame ==>FramebufferSurface::nextBuffer ==> acquireBufferLocked**

**å»è¯·æ±‚å¯ç”¨çš„å›¾å½¢ç¼“å­˜ï¼Œè¿™ä¸ªbufferä¸­å­˜å‚¨æœ‰GPUåˆæˆçš„ç»“æœï¼Œç„¶åé€šè¿‡setClientTargetæŠŠè¿™ä¸ªbufferä¼ é€’ç»™HWCåšå¤„ç†æ˜¾ç¤ºã€‚**

* * *

Â æœ€å¼€å§‹æˆ‘ä»¬æå‡ºçš„é—®é¢˜ï¼šç”¨äºå­˜å‚¨GPUåˆæˆåçš„å›¾å½¢æ•°æ®çš„`**GraphicBuffer**`æ˜¯ä»å“ªé‡Œæ¥çš„ï¼Ÿåˆ†æåˆ°è¿™é‡Œå¤§æ¦‚åº”è¯¥æœ‰è®²æ˜ç™½å§

æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-05-10 å‘å¸ƒäºåšå®¢å›­

äº”ã€è¡¥å……çŸ¥è¯†ç‚¹
-------

### 5.1 ç”¨äºGPUåˆæˆçš„GraphicBufferçš„æ•°é‡æ§åˆ¶

é€šè¿‡å±æ€§å€¼æ¥æ§åˆ¶æ•°é‡ ro.surface\_flinger.max\_frame\_buffer\_acquired\_buffersï¼Œå¦‚ä½•æ§åˆ¶çš„å¯ä»¥çœ‹SFçš„ä»£ç 

    [/frameworks/native/services/surfaceflinger/sysprop/SurfaceFlingerProperties.sysprop]
    # Controls the number of buffers SurfaceFlinger will allocate for use in FramebufferSurface.
    prop {
        api_name: "max_frame_buffer_acquired_buffers"
        type: Long
        scope: Public
        access: Readonly
        prop_name: "ro.surface_flinger.max_frame_buffer_acquired_buffers"
    }

è¿™ä¸ªå±æ€§å€¼ã€‚æ§åˆ¶ç”¨äºGPUåˆæˆçš„FramebufferSurfaceåˆ†é…å‡ ä¸ªGraphicBuffer,ï¼Œä¸€èˆ¬æ˜¯ 3 ä¸ª

### 5.2 **ä¸€ä¸ªç–‘é—®**

**ä¸ºä»€ä¹ˆåœ¨allocatorå‡ºæ‰“å°å‡ºæ¥çš„Framebufferçš„format=1 (PIXEL\_FORMAT\_RGBA\_8888) , è€Œimporterå¤„æ‰“å°å‡ºæ¥çš„Framebufferçš„format=5 (PIXEL\_FORMAT\_BGRA\_8888)Â  ?**

**ç”±äºå¯¹æ•´ä¸ªä½“ç³»æ¶æ„äº†è§£è¿˜ä¸æ˜¯å¾ˆæ·±å…¥ï¼Œä¸ºäº†æ‰¾åˆ°è¿™ä¸ªé—®é¢˜çš„åŸå› ï¼Œç¡®å®è´¹äº†ä¸å°‘åŠŸå¤«ã€‚å…¶å®ç­”æ¡ˆåœ¨ Gralloc HAL ä¸­ã€‚**

**æˆ‘çš„å¹³å°é‡‡ç”¨çš„æ˜¯ Mali GPUï¼ŒGralloc HALä½¿ç”¨çš„æ˜¯Â [Open Source Mali GPUs Gralloc Module](https://developer.arm.com/downloads/-/mali-drivers/android-gralloc-module)** **ä¸ºåŸºç¡€çš„Source codeã€‚**

**åœ¨ Gralloc çš„ä»£ç å®ç°ä¸­æœ‰å®šä¹‰ä¸€ä¸ªå®å¼€å…³ GRALLOC\_HWC\_FORCE\_BGRA\_8888 ï¼Œæ‰“å¼€è¿™ä¸ªå®çš„æ—¶å€™ï¼ŒSurfaceFlingerä¸­çš„ RenderSurface::initialize() è®¾ç½®çš„RGBA\_8888 ä¼šåœ¨Gralloc allocate/mapæ—¶å¼ºè½¬ä¸ºäº†BGRA\_8888æ¥å¤„ç†ã€‚å…·ä½“çš„å¯ä»¥å¼€å¯å’Œå…³é—­è¿™ä¸ªå®çœ‹dumpsys SurfaceFlingerå¯¹æ¯”  
**

    # When enabled, forces format to BGRA_8888 for FB usage when HWC is in use
    GRALLOC_HWC_FORCE_BGRA_8888?=0

**æˆ‘çš„å¹³å°å¯¹æ¯”çš„ä¿¡æ¯ï¼š**

    // å…³é—­GRALLOC_HWC_FORCE_BGRA_8888è¿™ä¸ªå®å®šä¹‰ï¼Œä»æ˜¯frameworkè®¾ç½®çš„RGBA8888
    + name:FramebufferSurface, id:e400000000, size:8.1e+03KiB, w/h:780x438, usage: 0x1b00, req fmt:1, fourcc/mod:875708993/0, dataspace: 0x0, compressed: false
            planes: R/G/B/A:         w/h:780x438, stride:1e00 bytes, size:7e9000
                
    // æ‰“å¼€GRALLOC_HWC_FORCE_BGRA_8888è¿™ä¸ªå®å®šä¹‰ï¼Œå¼ºåˆ¶è½¬ä¸ºäº†BGRA8888
    + name:FramebufferSurface, id:e200000000, size:8.1e+03KiB, w/h:780x438, usage: 0x1b00, req fmt:1, fourcc/mod:875713089/0, dataspace: 0x0, compressed: false
            planes: B/G/R/A:         w/h:780x438, stride:1e00 bytes, size:7e9000

### 5.3 ç”¨äºGPUåˆæˆçš„GraphicBufferçš„sizeï¼ˆwidth & heightï¼‰æ˜¯ç”±ä»€ä¹ˆå†³å®šçš„ï¼Ÿ

ç­”æ¡ˆæ˜¯å½“å‰å±å¹•çš„åˆ†è¾¨ç‡ï¼Œä¹Ÿå°±æ˜¯ Displayçš„ active mode

æ¯”å¦‚æˆ‘çš„Android TVå¹³å°ï¼Œè®¾ç½®ä¸åŒçš„ç”µè§†åˆ†è¾¨ç‡

    // 720 TV
    GraphicBufferAllocator buffers:
        Handle |        Size |     W (Stride) x H | Layers |   Format |      Usage | Requestor
    0xf2d8e0d0 | 3600.00 KiB | 1280 (1280) x  720 |      1 |        1 | 0x    1b00 | FramebufferSurface
    0xf2d937d0 | 3600.00 KiB | 1280 (1280) x  720 |      1 |        1 | 0x    1b00 | FramebufferSurface
    0xf2d98050 | 3600.00 KiB | 1280 (1280) x  720 |      1 |        1 | 0x    1b00 | FramebufferSurface
    
    // 1080 TV
    GraphicBufferAllocator buffers:
        Handle |        Size |     W (Stride) x H | Layers |   Format |      Usage | Requestor
    0xf2d81d10 | 8100.00 KiB | 1920 (1920) x 1080 |      1 |        1 | 0x    1b00 | FramebufferSurface
    0xf2d83840 | 8100.00 KiB | 1920 (1920) x 1080 |      1 |        1 | 0x    1b00 | FramebufferSurface
    0xf2d85ab0 | 8100.00 KiB | 1920 (1920) x 1080 |      1 |        1 | 0x    1b00 | FramebufferSurface
    
    // 4K TV(é™åˆ¶ro.surface_flinger.max_graphics_height/width)
    GraphicBufferAllocator buffers:
        Handle |        Size |     W (Stride) x H | Layers |   Format |      Usage | Requestor
    0xe8041b40 | 8100.00 KiB | 1920 (1920) x 1080 |      1 |        1 | 0x    1b00 | FramebufferSurface
    0xe8045c80 | 8100.00 KiB | 1920 (1920) x 1080 |      1 |        1 | 0x    1b00 | FramebufferSurface
    0xe804fa30 | 8100.00 KiB | 1920 (1920) x 1080 |      1 |        1 | 0x    1b00 | FramebufferSurface

ä¸‹é¢çš„å±æ€§æ˜¯å—å¹³å°é™åˆ¶ï¼ŒGPUæœ€å¤§å¯ä»¥æ”¯æŒçš„åˆæˆçš„size

    console:/ $ getprop | grep max_graphics
    [ro.surface_flinger.max_graphics_height]: [1080]
    [ro.surface_flinger.max_graphics_width]: [1920]

æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-05-10 å‘å¸ƒäºåšå®¢å›­

å¤§æ¦‚å°±è®²è¿™äº›å§ï¼Œä¹‹åæƒ³åˆ°ä»€ä¹ˆé—®é¢˜å†è¡¥å……ã€‚

å¿ƒæœ‰çŒ›è™ï¼Œç»†å—…è”·è–‡ï¼Œç”Ÿæ´»å°±è¯¥æ— æƒ§æ— æ‚”

* * *

![](https://img2022.cnblogs.com/blog/979092/202203/979092-20220322104528841-687741034.jpg)

ä½œè€…ï¼š[](https://www.cnblogs.com/roger-yu)[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)

å‡ºå¤„ï¼š[](https://www.cnblogs.com/roger-yu)[https://www.cnblogs.com/roger-yu/p/16230337.html](https://www.cnblogs.com/roger-yu/p/16230337.html)

æœ¬æ–‡ç‰ˆæƒå½’ä½œè€…å’Œåšå®¢å›­å…±æœ‰ï¼Œè½¬è½½å¿…é¡»ç»™å‡ºåŸæ–‡é“¾æ¥ï¼Œå¹¶ä¿ç•™æ­¤æ®µå£°æ˜ï¼Œå¦åˆ™ä¿ç•™è¿½ç©¶æ³•å¾‹è´£ä»»çš„æƒåˆ©