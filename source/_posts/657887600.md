---
layout: post
title: "测试平台系列(95) 前置条件支持简单的python脚本"
date: "2022-05-29T07:17:57.246Z"
---
测试平台系列(95) 前置条件支持简单的python脚本
============================

> 大家好~我是`米洛`！  
>   
> 我正在从0到1打造一个开源的接口测试平台, 也在编写一套与之对应的`教程`，希望大家多多支持。  
>   
> 欢迎关注我的公众号`米洛的测开日记`，获取最新文章教程!

### 回顾

上一节我们构思了一下怎么去支持Python脚本，在和@joker讨论以后，考虑到python脚本不会太复杂，所以我们这一节我们就先实现`exec`的版本。

### exec初体验

exec是一个比较厉害的`内置库`，它为想要执行python代码的用户提供了便利，与之对应的还有execfile版本，这个是文件版本的exec，也就是说，他接受的参数从一段代码变成了一个指定的`文件`。

上一节我们似乎介绍了exec的普通用法，那今天我们就讲讲怎么通过exec拿到对应的执行结果，毕竟对于执行结果我们是会渴望能拿到的。

*   实现第一个python方法: **获取本月第一天的日期**

    import datetime
    
    
    def get_first_day_of_month():
        # 把day指定为01，肯定就是第一天啦
        return datetime.today().strftime("%Y-%m-01")
    

python代码是如此编写的，那exec里面我们怎么拿到这个方法的结果呢？

**首先呢，exec是没用返回值的。我们只能通过，在exec执行的代码块里面定义变量去接收返回值。**

    import datetime
    
    
    return_value = datetime.today().strftime("%Y-%m-01")
      
    

那么在我们的`后台代码`里面，就可以拿到return\_value作为变量。

**但我实际在fastapi的方法里面，发现是不生效的。会报return\_value not defined，但是单个执行文件确实是可以。**

于是我采用了新的方法，定义一个dict，传给exec，这样exec里面用到的变量等信息，都会返回到dict里面。

    command = """
    import datetime
    
    
    return_value = datetime.today().strftime("%Y-%m-01")
    """
    loc = dict()
    exec(command, loc)
    print(loc['return_value'])
    

![](https://img2022.cnblogs.com/blog/726435/202205/726435-20220529132001086-1757917457.png)

### 编写在线执行exec接口

其实本身是不想提供这个接口的，因为大部分脚本都可以在本地测试后传上来，但想了下，有就有吧，对于os.remove这样危险的语句还是得禁止掉。

不过由于是演示，我就不禁止了。

![](https://img2022.cnblogs.com/blog/726435/202205/726435-20220529132001003-820594209.png)

先看一张效果图，执行完成后会有数据返回。但一定要注意的是，如果想拿到返回值，必须要有:

`current_time = xxx`，并且把返回值设置为current\_time。

为什么呢？因为exec本身是拿不到返回值的，如果你去exec语句里面定义一个变量:

    current_time2 = "234"
    

这样就能在loc里面取到返回值了，所以如果要求有返回值，则必须写上上述的python语句。

我们就是通过exec执行代码，定义变量为返回值，接着取出该变量的方式实现整个过程的。

来看下代码怎么写:

![](https://img2022.cnblogs.com/blog/726435/202205/726435-20220529131959948-1635184575.png)

和上文提到的一样，如果没有返回值的话，直接就是None了。

### 编写python数据构造器

![](https://img2022.cnblogs.com/blog/726435/202205/726435-20220529132000988-588437858.png)

和redis操作很相似，实现run方法，也是记录数据并拿到返回值。

### 改写获取数据构造器的方法

![](https://img2022.cnblogs.com/blog/726435/202205/726435-20220529132001069-1490414276.png)

新增Python类型，注意这里我把这些数字，0-3都放到了Config类里面。

**提醒一下各位，比如我这里的方法没有给出对应的文件路径，大家可以全局搜索，找到之。**

对应Config.py也增加了这样的子类。

![](https://img2022.cnblogs.com/blog/726435/202205/726435-20220529131959852-298841579.png)

### 前端部分的改动

![](https://img2022.cnblogs.com/blog/726435/202205/726435-20220529132001007-651698761.png)

页面基本是沿用的Redis的部分，在外部也稍微改造了一下:

![](https://img2022.cnblogs.com/blog/726435/202205/726435-20220529132001101-1126662936.png)

改用开关的形式，看起来更直观。

* * *

今天的内容就介绍到这里了，欢迎大家积极提出建议，一起打造一款开源工具。