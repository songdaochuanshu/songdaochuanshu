---
layout: post
title: "Redis缓冲区溢出及解决方案"
date: "2023-04-13T01:03:47.685Z"
---
Redis缓冲区溢出及解决方案
===============

缓冲区(buffer)，是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。

一、Redis缓冲区溢出影响
==============

在Redis中，主要有三个场景用到了缓冲区的概念。

*   在客户端和服务器端之间进行通信时，用来暂存客户端发送的命令数据，或者是服务器端返回给客户端的数据结果
*   在主从节点间进行数据同步时，Redis使用缓冲区来暂存主节点接收的写命令和数据
*   在Redis进行AOF持久化的时候Redis为了避免频繁写磁盘同样用到了缓冲区的概念

缓冲区概念最初是操作系统为了缓和 CPU 与 I/O 设备速度不匹配的矛盾，提高 CPU 和 I/O 设备的并行性而引入的。

对于高速设备与低速设备的不匹配，势必会让高速设备花时间等待低速设备。有了缓冲区的概念就可以很好的解决这个问题。缓冲区也是生产者消费者模式的重要体现。

![](https://img2023.cnblogs.com/blog/524341/202304/524341-20230412144212704-477302754.png)

1、缓冲区溢出导致网络连接关闭
---------------

如果 qubf-free 耗尽，就会引起客户端输入缓冲区溢出，Redis 的处理方法就是把客户端连接关闭，导致的结果就是业务程序无法进行数据存取。

2、缓冲区溢出导致命令数据丢失或者崩溃
-------------------

通常情况下，会有很多的客户端连接，当客户端连接占用的内存总量，超过了 Redis 的 maxmemory 配置时，就会触发 Redis 进行数据淘汰，影响业务程序的访问性能。

甚至多个客户端会导致 Redis 内存占用过大，也会导致内存溢出问题，进而引起 Redis 崩溃。

二、客户端缓冲区
========

客户端缓冲区又有两个，输入缓冲区和输出缓冲区，都是为了解决客户端和服务器端的请求发送和处理速度不匹配所设置的。

![](https://img2023.cnblogs.com/blog/524341/202304/524341-20230412144247972-487454542.png)

输入缓冲区暂存的是客户端发来的命令，其常见的溢出原因有两个：

1.  写入了BigKey，如一次性写入了百万级别的哈希或集合数据，超过了缓冲区的大小
2.  服务端处理请求的速度过慢导致阻塞，无法及时处理请求，使得客户端发送的请求在缓冲区内越积越多。

输出缓冲区暂存的是 Redis 主线程要返回给客户端的数据。

这个数据，既有简单且大小固定的 OK 响应（例如，执行 SET 命令）或报错信息，也有大小不固定的、包含具体数据的执行结果（例如，执行 HGET 命令）

输出缓冲区常见的溢出原因有三种：

1.  返回BigKey的大量结果
2.  执行了某些不合理的命令
3.  缓冲区大小设置不合理

从输入和输出缓冲区常见导致溢出的原因来看，BigKey是最可能导致溢出的原因，因此我们应该尽量避免使用BigKey。

对于输入缓冲区，因为没有办法改变其大小(默认每个客户端1G)，我们只能通过控制命令的发送和处理速度入手，尽量避免阻塞。

对于输出缓冲区则要避免一些返回大量结果的命令的使用如KEYS，MONITOR等，同时可以通过调整输出缓冲区的大小来避免溢出。

三、复制缓冲区
=======

复制缓冲区是用于Redis主从节点之间复制时使用的。由于主从节点间的数据复制包括全量复制和增量复制两种。因此复制缓冲区也分为复制缓冲区和复制积压缓冲区两种。

1、复制缓冲区
-------

在全量复制过程中，主节点在向从节点传输 RDB 文件的同时，会继续接收客户端发送的写命令请求。这些写命令就会先保存在复制缓冲区中，等 RDB 文件传输完成后，再发送给从节点去执行。主节点上会为每个从节点都维护一个复制缓冲区，来保证主从节点间的数据同步。

![](https://img2023.cnblogs.com/blog/524341/202304/524341-20230412144312287-1611694009.png)

对于复制缓冲区，如果主库传输 RDB 文件以及从库加载 RDB 文件耗时长，同时主库接收的写命令操作较多，就会导致复制缓冲区被写满而溢出。

想要避免复制缓冲区溢出，一方面我们可以控制主节点保存的数据量大小，这样可以让RDB文件的传输以及从库加载时间变快，以避免复制缓冲区累积过多命令。

也可以根据主节点的数据量大小、主节点的写负载压力和主节点本身的内存大小来更合理的设置复制缓冲区的大小来避免溢出，此外，由于主节点会为每一个从节点设置一个复制缓冲区，如果集群中的从节点数非常多的话，主节点的内存开销就会非常大，因此我们应该尽量避免一个主节点有过多的从节点。

2、复制积压缓冲区
---------

增量复制时，主节点和从节点进行常规同步时，会把写命令也暂存在复制积压缓冲区中。如果从节点和主节点间发生了网络断连，等从节点再次连接后，可以从复制积压缓冲区中同步尚未复制的命令操作。

![](https://img2023.cnblogs.com/blog/524341/202304/524341-20230412144330529-1014571106.png)

需要注意的是复制积压缓冲区是一个大小有限的环形缓冲区。

当主节点把复制积压缓冲区写满后，会覆盖缓冲区中的旧命令数据。此时会造成主从节点的数据不一致。

针对这个问题，一般的应对的方法是调大复制积压缓冲区的大小，这个大小的计算方式一般可以使用

缓冲区大小=（主库写入命令速度 \* 操作大小 - 主从库间网络传输命令速度 \* 操作大小）\* 2

如果如果并发请求量非常大，调整缓冲区大小的方式还不能解决，那么可以考虑使用切片集群的方式解决

四、AOF缓冲区
========

AOF缓冲区是Redis在AOF持久化的所设置的缓冲区，AOF缓冲区也有两种AOF缓冲区和AOF重写缓冲区。

1、AOF缓冲区
--------

我们都知道，即使是固态硬盘，它的读写速度也是与内存的读写速度相差很多的。AOF缓冲区就主要是Redis用来解决主进程执行命令速度与磁盘写入速度不同步所设置的，通过AOF缓冲区可以有效地避免频繁对硬盘进行读写，进而提升性能。Redis在AOF持久化的时候，会先把命令写入到AOF缓冲区，然后通过回写策略来写入硬盘AOF文件。

![](https://img2023.cnblogs.com/blog/524341/202304/524341-20230412144615123-1116945132.png)

AOF缓冲区的溢出可能与磁盘写入速度有关系，也可能与AOF回写策略有关系，当大量命令积压在AOF缓冲区，超过其设置阈值之后，就会导致缓冲区溢出，想要避免这个问题，我们可以通过调整回写策略，或者调整AOF缓冲区大小的方式来解决。

2、AOF重写缓冲区
----------

AOF重写缓冲区是Redis在子进程进行AOF重写的时候，父进程接受了新的命令，此时会把命令写入AOF重写缓冲区，等到子进程重写完成后，把AOF重写缓冲区命令追加到新的AOF文件中。

![](https://img2023.cnblogs.com/blog/524341/202304/524341-20230412144619907-1375595329.png)

 AOF重写缓冲区的溢出与AOF重写期间主进程所处理的命令数有关系，当AOF重写期间Redis主进程处理了大量的命令，这些命令都会写入AOF重写缓冲区，当超过设定阈值之后，就会导致溢出。

避免AOF重写缓冲区的溢出我们也可以通过调整AOF重写缓冲区的大小来解决。

五、总结
====

这篇文章总结了缓冲区的概念，分析了Redis的三个缓冲区，以及可能造成其溢出的原因和解决办法。

对于缓冲区溢出其实主要有两种原因，一是缓冲区大小不够，二是消费者处理的速度太慢，而生产者生产的太快，导致大量内容积压在缓冲区，进而导致溢出。

而解决方案就可以通过调整缓冲区的大小，或者调整生产者与消费者之间生产与处理消息的速度，使其处于一个相对平衡的状态。

本文来自博客园，作者：[邴越](https://www.cnblogs.com/binyue/)，转载请注明原文链接：[https://www.cnblogs.com/binyue/p/17309762.html](https://www.cnblogs.com/binyue/p/17309762.html)