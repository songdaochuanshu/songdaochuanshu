---
layout: post
title: "【Java并发入门】02 Java内存模型：看Java如何解决可见性和有序性问题"
date: "2022-11-30T23:18:13.001Z"
---
【Java并发入门】02 Java内存模型：看Java如何解决可见性和有序性问题
========================================

如何解决其中的**可见性**和**有序性**导致的问题，这也就引出来了今天的主角——Java 内存模型。

一、什么是 Java 内存模型？
----------------

导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是**禁用缓存和编译优化**，但这样虽然解决了问题，但也导致带来的性能优化都没了。

因此，解决方案是：提出一套规则和方法，是程序员能在该禁用的时候禁用，不该禁用的时候不禁用。

Java 内存模型规范就是来解决这个问题的 —— 提供按需禁用缓存和编译优化的方法  
具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则，这也正是本期的重点内容。

二、Happens-Before 规则
-------------------

Q：如何理解 Happens-Before 呢？  
A：**前面一个操作的结果对后续操作是可见的。但不能理解为前一个操作发生在后续操作的前面。**  
**只要最终语义是对的，编译器怎么优化都行。**

**1、程序的顺序性规则**  
这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。

**2、volatile 变量规则**  
这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。

**3、传递性**  
这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。

**4、管程中锁的规则**  
这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。

**5、线程 start() 规则**  
这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。

**6、线程 join() 规则**  
它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。

### 疑惑

Q：volatile、synchronized 和 final 能理解是提供给程序员用的，六项 Happens-Before 规则是约束谁的呢？  
A：这是给程序员的保障，按照提供的规则写，就能保证 Happens-Before 的语义。

参考文章：

> [Java内存模型以及happens-before规则](https://juejin.cn/post/6844903600318054413)