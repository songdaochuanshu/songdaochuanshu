---
layout: post
title: "SpringMVC笔记"
date: "2022-03-28T13:26:22.001Z"
---
SpringMVC笔记
===========

![SpringMVC笔记](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328203137313-1222645436.png) SpringMVC学习笔记

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328200924452-109753857.png)

目录

*   [一、SpringMVC简介](#一springmvc简介)
    *   *   [1、什么是MVC](#1什么是mvc)
        *   [2、什么是SpringMVC](#2什么是springmvc)
        *   [3、SpringMVC的特点](#3springmvc的特点)
        *   [4、SpringMVC的原理](#4springmvc的原理)
*   [二、HelloWorld](#二helloworld)
    *   *   [1、开发环境](#1开发环境)
        *   [2、创建maven工程](#2创建maven工程)
            *   *   [a> 添加web模块](#a-添加web模块)
                *   [b> 打包方式：war `pom.xml`](#b-打包方式war--pomxml)
                *   [c> 引入依赖](#c-引入依赖)
        *   [3、配置web.xml](#3配置webxml)
            *   *   [a>默认配置方式](#a默认配置方式)
                *   [b>扩展配置方式](#b扩展配置方式)
        *   [4、创建请求控制器](#4创建请求控制器)
        *   [5、创建springMVC的配置文件](#5创建springmvc的配置文件)
        *   [6、测试HelloWorld](#6测试helloworld)
            *   *   [a>实现对首页的访问](#a实现对首页的访问)
                *   [b>通过超链接跳转到指定页面](#b通过超链接跳转到指定页面)
        *   [7、总结](#7总结)
*   [三、@RequestMapping注解](#三requestmapping注解)
    *   *   [1、@RequestMapping注解的功能](#1requestmapping注解的功能)
        *   [2、@RequestMapping注解的位置](#2requestmapping注解的位置)
        *   [3、@RequestMapping注解的value属性](#3requestmapping注解的value属性)
        *   [4、@RequestMapping注解的method属性](#4requestmapping注解的method属性)
        *   [5、@RequestMapping注解的params属性（了解）](#5requestmapping注解的params属性了解)
        *   [6、@RequestMapping注解的headers属性（了解）](#6requestmapping注解的headers属性了解)
        *   [7、SpringMVC支持`ant`风格的路径](#7springmvc支持ant风格的路径)
        *   [8、SpringMVC支持路径中的占位符（重点）](#8springmvc支持路径中的占位符重点)
*   [四、SpringMVC获取请求参数](#四springmvc获取请求参数)
    *   *   [1、通过ServletAPI获取](#1通过servletapi获取)
        *   [2、通过控制器方法的形参获取请求参数](#2通过控制器方法的形参获取请求参数)
        *   [3、@RequestParam](#3requestparam)
        *   [4、@RequestHeader](#4requestheader)
        *   [5、@CookieValue](#5cookievalue)
        *   [6、通过POJO获取请求参数](#6通过pojo获取请求参数)
        *   [7、解决获取请求参数的乱码问题](#7解决获取请求参数的乱码问题)
*   [五、域对象共享数据](#五域对象共享数据)
    *   *   [1、使用ServletAPI向request域对象共享数据](#1使用servletapi向request域对象共享数据)
        *   [2、使用ModelAndView向request域对象共享数据](#2使用modelandview向request域对象共享数据)
        *   [3、使用Model向request域对象共享数据](#3使用model向request域对象共享数据)
        *   [4、使用map向request域对象共享数据](#4使用map向request域对象共享数据)
        *   [5、使用ModelMap向request域对象共享数据](#5使用modelmap向request域对象共享数据)
        *   [6、Model、ModelMap、Map的关系](#6modelmodelmapmap的关系)
        *   [7、向session域共享数据](#7向session域共享数据)
        *   [8、向application域共享数据](#8向application域共享数据)
*   [六、SpringMVC的视图](#六springmvc的视图)
    *   *   [1、ThymeleafView](#1thymeleafview)
        *   [2、转发视图](#2转发视图)
        *   [3、重定向视图](#3重定向视图)
        *   [4、视图控制器view-controller](#4视图控制器view-controller)
*   [七、RESTful](#七restful)
    *   *   [1、RESTful简介](#1restful简介)
            *   *   [a>资源](#a资源)
                *   [b>资源的表述](#b资源的表述)
                *   [c>状态转移](#c状态转移)
        *   [2、RESTful的实现](#2restful的实现)
        *   [3、HiddenHttpMethodFilter](#3hiddenhttpmethodfilter)
*   [八、RESTful案例](#八restful案例)
    *   *   [1、准备工作](#1准备工作)
        *   [2、功能清单](#2功能清单)
        *   [3、具体功能：访问首页](#3具体功能访问首页)
            *   *   [a>配置view-controller](#a配置view-controller)
                *   [b>创建页面](#b创建页面)
        *   [4、具体功能：查询所有员工数据](#4具体功能查询所有员工数据)
            *   *   [a>控制器方法](#a控制器方法)
                *   [b>创建employee\_list.html](#b创建employee_listhtml)
        *   [5、具体功能：删除](#5具体功能删除)
            *   *   [a>创建处理delete请求方式的表单](#a创建处理delete请求方式的表单)
                *   [b>删除超链接绑定点击事件](#b删除超链接绑定点击事件)
                *   [c>控制器方法](#c控制器方法)
        *   [6、具体功能：跳转到添加数据页面](#6具体功能跳转到添加数据页面)
            *   *   [a>配置view-controller](#a配置view-controller-1)
                *   [b>创建employee\_add.html](#b创建employee_addhtml)
        *   [7、具体功能：执行保存](#7具体功能执行保存)
            *   *   [a>控制器方法](#a控制器方法-1)
        *   [8、具体功能：跳转到更新数据页面](#8具体功能跳转到更新数据页面)
            *   *   [a>修改超链接](#a修改超链接)
                *   [b>控制器方法](#b控制器方法)
                *   [c>创建employee\_update.html](#c创建employee_updatehtml)
        *   [9、具体功能：执行更新](#9具体功能执行更新)
            *   *   [a>控制器方法](#a控制器方法-2)
*   [八、HttpMessageConverter](#八httpmessageconverter)
    *   *   [1、@RequestBody](#1requestbody)
        *   [2、RequestEntity](#2requestentity)
        *   [3、@ResponseBody](#3responsebody)
        *   [4、SpringMVC处理json](#4springmvc处理json)
        *   [5、SpringMVC处理ajax](#5springmvc处理ajax)
        *   [6、@RestController注解](#6restcontroller注解)
        *   [7、ResponseEntity](#7responseentity)
*   [九、文件上传和下载](#九文件上传和下载)
    *   *   [1、文件下载](#1文件下载)
        *   [2、文件上传](#2文件上传)
*   [十、拦截器](#十拦截器)
    *   *   [1、拦截器的配置](#1拦截器的配置)
        *   [2、拦截器的三个抽象方法](#2拦截器的三个抽象方法)
        *   [3、多个拦截器的执行顺序](#3多个拦截器的执行顺序)
        *   [4、案例：验证用户是否登录 (认证用户)](#4案例验证用户是否登录-认证用户)
*   [十一、异常处理器](#十一异常处理器)
    *   *   [1、基于配置的异常处理](#1基于配置的异常处理)
        *   [2、基于注解的异常处理](#2基于注解的异常处理)
*   [十二、注解配置SpringMVC](#十二注解配置springmvc)
    *   *   [1、创建初始化类，代替web.xml](#1创建初始化类代替webxml)
        *   [2、创建SpringConfig配置类，代替spring的配置文件](#2创建springconfig配置类代替spring的配置文件)
        *   [3、创建WebConfig配置类，代替SpringMVC的配置文件](#3创建webconfig配置类代替springmvc的配置文件)
        *   [4、测试功能](#4测试功能)
*   [十三、SpringMVC执行流程](#十三springmvc执行流程)
    *   *   [1、SpringMVC常用组件](#1springmvc常用组件)
        *   [2、DispatcherServlet初始化过程](#2dispatcherservlet初始化过程)
            *   *   [a>初始化WebApplicationContext](#a初始化webapplicationcontext)
                *   [b>创建WebApplicationContext](#b创建webapplicationcontext)
                *   [c>DispatcherServlet初始化策略](#cdispatcherservlet初始化策略)
        *   [3、DispatcherServlet调用组件处理请求](#3dispatcherservlet调用组件处理请求)
            *   *   [a>processRequest()](#aprocessrequest)
                *   [b>doService()](#bdoservice)
                *   [c>doDispatch()](#cdodispatch)
                *   [d>processDispatchResult()](#dprocessdispatchresult)
        *   [4、SpringMVC的执行流程](#4springmvc的执行流程)
*   [十四、乱码问题](#十四乱码问题)
*   [十五、报错解决](#十五报错解决)

一、SpringMVC简介
=============

### 1、什么是MVC

MVC是一种**软件架构思想**，将软件按照模型、视图、控制器来划分。

`M`：`Model`，模型层，指工程中的`JavaBean`，作用是**处理数据**。

​ JavaBean分为两类：

*   一类称为实体类Bean：专门存储业务数据的，如 Student、User 等。
*   一类称为业务处理 Bean：指 `Service` 或 `Dao` 对象，专门用于**处理业务逻辑**和**数据访问**。

`V`：`View`，视图层，指工程中的`html`或`jsp`等页面，作用是与用户进行**交互**，**展示数据**。

`C`：`Controller`，控制层，指工程中的`servlet`，作用是**接收请求和响应浏览器**。

**MVC的工作流程：**  
用户通过视图层发送请求到服务器，在服务器中请求被`Controller`接收，`Controller`调用相应的`Model`层处理请求，处理完毕将结果返回到`Controller`，`Controller`再根据请求处理的结果找到相应的`View`视图，渲染数据后最终响应给浏览器。

### 2、什么是SpringMVC

SpringMVC是Spring的一个后续产品，是**Spring的一个子项目**。

SpringMVC 是 Spring 为`表述层`开发提供的一整套完备的解决方案。在表述层框架历经 **Strust、WebWork、Strust2** 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的**首选方案**。

> 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet

### 3、SpringMVC的特点

*   **Spring 家族原生产品**，与 IOC 容器等基础设施无缝对接。
*   **基于原生的Servlet**，通过了功能强大的**前端控制器DispatcherServlet**，对请求和响应进行统一处理。
*   表述层各细分领域需要解决的问题**全方位覆盖**，提供**全面解决方案。**
*   **代码清新简洁**，大幅度提升开发效率。
*   内部组件化程度高，可插拔式组件**即插即用**，想要什么功能配置相应组件即可。
*   **性能卓著**，尤其适合现代大型、超大型互联网项目要求

### 4、SpringMVC的原理

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328201101945-1143112039.png)

1.  `DispatcherServlet`表示**前端控制器**，是整个SpringMVC的**核心控制中**心。用户发出请求，`DispatcherServlet`接收请求并拦截请求。
    *   假设请求的url为：[http://localhost:8080/SpringMVC/hello](http://localhost:8080/SpringMVC/hello)
    *   如上url拆分成三部分：
        *   [http://localhost:8080](http://localhost:8080) 服务器域名
        *   SpringMVC部署在服务器上的web站点
        *   helo表示控制器
    *   通过分析，如上url表示为：请求位于服务器 localhost:8080 上的SpringMVC站点的hello控制器。
2.  `HandlerMapping`为**处理器映射**。`DispatcherServlet`调用`HandlerMapping`，`HandlerMapping`根据请求`url`查找`Handler`。
3.  `HandlerExecution`表示具体的`Handler`，其主要作用是根据url查找控制器，如上`url`被查找控制器为：`hello`。
4.  `HandlerExecution`将解析后的信息传递给`DispatcherServlet`，如**解析控制器映射**等。
5.  `HandlerAdapter`表示**处理器适配器**，其按照特定的规则去执行Handler。
6.  `Handler`让具体的`Controller`执行。

> 代码解析

1.  配置`DispatcherServlet`**前端控制器**
    
        <servlet>
            <servlet-name>springmvc</servlet-name>
            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
            <init-param>
                <param-name>contextConfigLocation</param-name>
                <param-value>classpath:springmvc-servlet.xml</param-value>
            </init-param>
            <load-on-startup>1</load-on-startup>
        </servlet>
        <servlet-mapping>
            <servlet-name>springmvc</servlet-name>
            <url-pattern>/</url-pattern>
        </servlet-mapping>
        
    
    通过`<init-param>`标签配置SpringMVC的配置文件，在这个配置文件中配置需要的映射器、适配器和视图解析器。
    
2.  配置`HandlerMapping`**处理器映射**
    
        <!--配置映射器 实际开发中不适用-->
        <bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" />
        
    
3.  配置`HandlerAdapter`**处理器适配器**
    
        <!--配置适配器-->
        <bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" />
        
    
4.  创建请求控制器并创建其对象于SpringMVC配置文件中
    
        public class Principle implements Controller {
        
            @Override
            public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
                
                ModelAndView view = new ModelAndView();
        
                //业务代码
                String result = "HelloSpringMVC";
                view.addObject("msg", result);
        
                //视图跳转
                view.setViewName("test");
        
                return view;
            }
        }
        
    
        <bean id="/principle" class="com.th.conteoller.Principle"/>
        
    
5.  配置`ViewResolver`**视图解析器**
    
        <!--配置视图解析器 可模板引擎： Thymeleaf Freemarker等-->
        <bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
            <property name="prefix" value="/WEB-INF/jsp/" />
            <property name="suffix" value=".jsp" />
        </bean>
        
    
6.  页面展示
    
        <%@ page contentType="text/html;charset=UTF-8" language="java" %>
        <html>
        <head>
            <title>Test</title>
        </head>
        <body>
        ${msg}
        </body>
        </html>
        
    

二、HelloWorld
============

### 1、开发环境

IDE、构建工具：maven3.5.4、服务器：tomcat7、Spring版本：5.3.1

### 2、创建maven工程

##### a> 添加web模块

##### b> 打包方式：war `pom.xml`

    <!--配置打包方式-->
    <packaging>war</packaging>
    

##### c> 引入依赖

    <dependencies>
        <!-- SpringMVC -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.3.1</version>
        </dependency>
    
        <!-- 日志 -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.3</version>
        </dependency>
    
        <!-- ServletAPI -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>3.1.0</version>
            <scope>provided</scope>
        </dependency>
    
        <!-- Spring5和Thymeleaf整合包 -->
        <dependency>
            <groupId>org.thymeleaf</groupId>
            <artifactId>thymeleaf-spring5</artifactId>
            <version>3.0.12.RELEASE</version>
        </dependency>
    </dependencies>
    

注：由于 Maven 的**传递性**，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。

![img001](SpringMVC%E7%AC%94%E8%AE%B0.assets%5Cimg001.png)

### 3、配置web.xml

注册SpringMVC的前端控制器`DispatcherServlet`。

##### a>默认配置方式

此配置作用下，SpringMVC的配置文件默认位于`WEB-INF`下，默认名称为`\<servlet-name>-servlet.xml`，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为`springMVC-servlet.xml`。而在Maven构建的项目中，要求配置文件存放在resource目录下，这样的默认配置显然不够友好，因此有了扩展配置方式。

    <!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 -->
    <servlet>
        <servlet-name>springMVC</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>springMVC</servlet-name>
        <!--
            设置springMVC的核心控制器所能处理的请求的请求路径
            /所匹配的请求可以是/login或.html或.js或.css方式的请求路径
            但是/不能匹配.jsp请求路径的请求
        -->
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    

`/*`代表的是所有文件，包括jsp文件。这是与`/`的区别。

##### b>扩展配置方式

可通过`init-param`标签设置SpringMVC配置文件的**位置和名称**，通过`load-on-startup`标签设置SpringMVC前端控制器`DispatcherServlet`的初始化时间

    <!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 -->
    <servlet>
        <servlet-name>springMVC</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 -->
        <init-param>
            <!-- contextConfigLocation为固定值 -->
            <param-name>contextConfigLocation</param-name>
            <!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources -->
            <param-value>classpath:springMVC.xml</param-value>
        </init-param>
        <!-- 
     		作为框架的核心组件，在启动过程中有大量的初始化操作要做
    		而这些操作放在第一次请求时才执行会严重影响访问速度
    		因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时
    	-->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springMVC</servlet-name>
        <!--
            设置springMVC的核心控制器所能处理的请求的请求路径
            /所匹配的请求可以是/login或.html或.js或.css方式的请求路径
            但是/不能匹配.jsp请求路径的请求
        -->
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    

> 注：
> 
> <url-pattern>标签中使用/和/\*的区别：
> 
> / 所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求，因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面
> 
> /\*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/\*的写法

### 4、创建请求控制器

由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即**请求控制器**。

请求控制器中每一个处理请求的方法成为控制器方法

因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在

    @Controller
    public class HelloController {
        
    }
    

当然也可以通过实现`Controller`接口，重写`handleRequest`方法实现一个控制器，但是这种方法的弊端是每个控制器只能实现一个视图跳转。

### 5、创建springMVC的配置文件

    <!-- 自动扫描包 -->
    <context:component-scan base-package="com.atguigu.mvc.controller"/>
    
    <!-- 配置Thymeleaf视图解析器 -->
    <bean id="viewResolver" class="org.thymeleaf.spring5.view.ThymeleafViewResolver">
        <property name="order" value="1"/>
        <property name="characterEncoding" value="UTF-8"/>
        <property name="templateEngine">
            <bean class="org.thymeleaf.spring5.SpringTemplateEngine">
                <property name="templateResolver">
                    <bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">
        
                        <!-- 视图前缀 -->
                        <property name="prefix" value="/WEB-INF/templates/"/>
        
                        <!-- 视图后缀 -->
                        <property name="suffix" value=".html"/>
                        <property name="templateMode" value="HTML5"/>
                        <property name="characterEncoding" value="UTF-8" />
                    </bean>
                </property>
            </bean>
        </property>
    </bean>
    
    <!-- 
       处理静态资源，例如html、js、css、jpg
      若只设置该标签，则只能访问静态资源，其他请求则无法访问
      此时必须设置<mvc:annotation-driven/>解决问题
     -->
    <mvc:default-servlet-handler/>
    
    <!-- 开启mvc注解驱动 -->
    <mvc:annotation-driven>
        <mvc:message-converters>
            <!-- 处理响应中文内容乱码 -->
            <bean class="org.springframework.http.converter.StringHttpMessageConverter">
                <property name="defaultCharset" value="UTF-8" />
                <property name="supportedMediaTypes">
                    <list>
                        <value>text/html</value>
                        <value>application/json</value>
                    </list>
                </property>
            </bean>
        </mvc:message-converters>
    </mvc:annotation-driven>
    

### 6、测试HelloWorld

##### a>实现对首页的访问

在请求控制器中创建处理请求的方法

    // @RequestMapping注解：处理请求和控制器方法之间的映射关系
    // @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径
    // localhost:8080/springMVC/
    @RequestMapping("/")
    public String index() {
        //设置视图名称
        return "index";
    }
    

##### b>通过超链接跳转到指定页面

在主页`index.html`中设置超链接。

    <!DOCTYPE html>
    <html lang="en" xmlns:th="http://www.thymeleaf.org">
    <head>
        <meta charset="UTF-8">
        <title>首页</title>
    </head>
    <body>
        <h1>首页</h1>
        <a th:href="@{/hello}">HelloWorld</a><br/>
    </body>
    </html>
    

在`html`标签中需要加入的**命名空间**：`xmlns:th="http://www.thymeleaf.org"`。

在请求控制器中创建处理请求的方法

    @RequestMapping("/hello")
    public String HelloWorld() {
        return "target";
    }
    

### 7、总结

浏览器发送请求，若请求地址符合前端控制器的`url-pattern`，该请求就会被前端控制器`DispatcherServlet`处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中`@RequestMapping`注解的`value`属性值进行匹配，若匹配成功，**该注解所标识的控制器方法就是处理请求的方法**。处理请求的方法需要返回一个**字符串类型的视图名称**，该视图名称会被**视图解析器**解析，加上前缀和后缀组成视图的路径，通过`Thymeleaf`对视图进行渲染，最终转发到视图所对应页面。

三、@RequestMapping注解
===================

### 1、@RequestMapping注解的功能

从注解名称上我们可以看到，`@RequestMapping`注解的作用就是**将请求和处理请求的控制器方法关联**起来，建立映射关系。

`SpringMVC` 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。

### 2、@RequestMapping注解的位置

`@RequestMapping`标识一个类：设置映射请求的请求路径的**初始信息**

`@RequestMapping`标识一个方法：设置映射请求请求路径的**具体信息**

    @Controller
    @RequestMapping("/test")
    public class RequestMappingController {
    
    	//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping
        @RequestMapping("/testRequestMapping")
        public String testRequestMapping(){
            return "success";
        }
    
    }
    

### 3、@RequestMapping注解的value属性

`@RequestMapping`注解的`value`属性通过请求的**请求地址匹配请求映射**

`@RequestMapping`注解的`value`属性是一个**字符串类型的数组**，表示该请求映射能够匹配多个请求地址所对应的请求

`@RequestMapping`注解的`value`属性**必须设置**，至少通过请求地址匹配请求映射

    <a th:href="@{/testRequestMapping}">测试@RequestMapping的value属性-->/testRequestMapping</a><br>
    <a th:href="@{/test}">测试@RequestMapping的value属性-->/test</a><br>
    

    @RequestMapping(
            value = {"/testRequestMapping", "/test"}
    )
    public String testRequestMapping(){
        return "success";
    }
    

### 4、@RequestMapping注解的method属性

`@RequestMapping`注解的`method`属性通过请求的请求方式（`get`或`post`）匹配请求映射

`@RequestMapping`注解的`method`属性是一个`RequestMethod`类型的**数组**，表示该请求映射能够匹配多种请求方式的请求

若当前请求的请求地址满足请求映射的`value`属性，但是请求方式不满足`method`属性，则浏览器报错`405：Request method 'POST' not supported`

    <a th:href="@{/test}">测试@RequestMapping的value属性-->/test</a><br>
    <form th:action="@{/test}" method="post">
        <input type="submit">
    </form>
    

    @RequestMapping(
            value = {"/testRequestMapping", "/test"},
            method = {RequestMethod.GET, RequestMethod.POST}
    )
    public String testRequestMapping(){
        return "success";
    }
    

> 注：
> 
> 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了**`@RequestMapping`的派生注解**
> 
> 处理get请求的映射-->**`@GetMapping`**
> 
> 处理post请求的映射-->**`@PostMapping`**
> 
> 处理put请求的映射-->**`@PutMapping`**
> 
> 处理delete请求的映射-->**`@DeleteMapping`**
> 
> 2、常用的请求方式有`get`，`post`，`put`，`delete`
> 
> 但是目前浏览器只支持`get`和`post`，若在`form`表单提交时，为`method`设置了其他请求方式的字符串（`put`或`delete`），则按照默认的请求方式`get`处理
> 
> 若要发送`put`和`delete`请求，则需要通过spring提供的过滤器`HiddenHttpMethodFilter`，在`RESTful`部分会讲到

### 5、@RequestMapping注解的params属性（了解）

`@RequestMapping`注解的`params`属性通过请求的请求参数匹配请求映射

`@RequestMapping`注解的`params`属性是一个字**符串类型的数组**，可以通过四种表达式设置请求参数和请求映射的匹配关系

"`param`"：要求请求映射所匹配的请求**必须携带param请求参数**

"`!param`"：要求请求映射所匹配的请求**必须不能携带param请求参数**

"`param=value`"：要求请求映射所匹配的请求**必须携带param请求参数且param=value**

"`param!=value`"：要求请求映射所匹配的请求必须**携带param请求参数但是param!=value**

    <a th:href="@{/test(username='admin',password=123456)">测试@RequestMapping的params属性-->/test</a><br>
    <!--thymeleaf可以通过()传递参数，表示/test?username=admin&password=123456-->
    

    @RequestMapping(
            value = {"/testRequestMapping", "/test"}
            ,method = {RequestMethod.GET, RequestMethod.POST}
            ,params = {"username","password!=123456"}
    )
    public String testRequestMapping(){
        return "success";
    }
    

> 注：
> 
> 若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions "username, password!=123456" not met for actual request parameters: username={admin}, password={123456}

### 6、@RequestMapping注解的headers属性（了解）

`@RequestMapping`注解的`headers`属性通过请求的请求头信息匹配请求映射

`@RequestMapping`注解的`headers`属性是一个**字符串类型的数组**，可以通过四种表达式设置请求头信息和请求映射的匹配关系

"`header`"：要求请求映射所匹配的请求**必须携带header请求头信息**

"`!header`"：要求请求映射所匹配的请求必须**不能携带header请求头信息**

"`header=value`"：要求请求映射所匹配的请求**必须携带header请求头信息且header=value**

"`header!=value`"：要求请求映射所匹配的请求**必须携带header请求头信息且header!=value**

若当前请求满足`@RequestMapping`注解的`value`和`method`属性，但是不满足`headers`属性，此时页面显示`404`错误，即资源未找到

### 7、SpringMVC支持`ant`风格的路径

针对`@RequestMapping`的`value`属性进行**模糊匹配**。

`？`：表示任意的单个字符

`*`：表示任意的0个或多个字符

`**`：表示任意的一层或多层目录

注意：在使用\*\*时，只能使用/\*\*/xxx的方式

    @RequestMapping("ant1/a?a")
    public String antTest1(){
        return "success";
    }
    
    @RequestMapping("ant2/a*b")
    public String antTest2(){
        return "success";
    }
    
    @RequestMapping("**/ant3")
    public String antTest3(){
        return "success";
    }
    

### 8、SpringMVC支持路径中的占位符（重点）

针对`@RequestMapping`的`value`属性进行**模糊匹配**。

`原始方式`：/deleteUser?id=1

`rest方式`：/deleteUser/1

SpringMVC路径中的占位符常用于`RESTful`风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的`@RequestMapping`注解的`value`属性中通过占位符{xxx}表示传输的数据，在**通过`@PathVariable`注解，将占位符所表示的数据赋值给控制器方法的形参**。

    <a th:href="@{/testRest/1/admin}">测试路径中的占位符-->/testRest</a><br>
    

    @RequestMapping("/testRest/{id}/{username}")
    public String testRest(@PathVariable("id") String id, @PathVariable("username") String username){
        System.out.println("id:"+id+",username:"+username);
        return "success";
    }
    //最终输出的内容为-->id:1,username:admin
    

四、SpringMVC获取请求参数
=================

### 1、通过ServletAPI获取

将`HttpServletRequest`作为控制器方法的形参，此时`HttpServletRequest`类型的参数表示封装了当前请求的请求报文的对象

    @RequestMapping("/testParam")
    public String testParam(HttpServletRequest request){
        String username = request.getParameter("username");
        String password = request.getParameter("password");
        System.out.println("username:"+username+",password:"+password);
        return "success";
    }
    

### 2、通过控制器方法的形参获取请求参数

在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在`DispatcherServlet`中就会将请求参数赋值给相应的形参

    <a th:href="@{/testParam(username='admin',password=123456)}">测试获取请求参数-->/testParam</a><br>
    

    @RequestMapping("/testParam")
    public String testParam(String username, String password){
        System.out.println("username:"+username+",password:"+password);
        return "success";
    }
    

> 注：
> 
> 若请求所传输的请求参数中有多个同名的请求参数(如：前端多选框)，此时可以在控制器方法的形参中设置**字符串数组**【String\[\]】或者**字符串类型**【String】的形参接收此请求参数。
> 
> 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 。如：\[a,b,c\]
> 
> 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果 。如：a,b,c

### 3、@RequestParam

`@RequestParam`是将请求参数和控制器方法的形参创建映射关系

`@RequestParam`注解一共有三个属性：

`value`：指定为形参赋值的请求参数的**参数名**

    @Controller
    public class UserController {
        /**http://localhost:8080/t2?username=ThreePure
         * 通过@RequestParam注解完成前端参数名与接收端参数的映射*/
        @GetMapping("/t2")
        public String test2(@RequestParam("username")String name, Model model){
            //1、接收前端参数
            System.out.println("接收到前端数据为："+name);
            //2、将返回结果传递给前端 Model
            model.addAttribute("msg", name);
            //3、视图跳转
            return "test";
        }
    }
    

`required`：设置**是否必须传输此请求参数**，默认值为`true`。

若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置`defaultValue`属性，则页面报错`400：Required String parameter 'xxx' is not present`；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null

`defaultValue`：不管required属性值为true或false，当value所指定的请求参数**没有传输或传输的值为""时**，则使用默认值为形参赋值

### 4、@RequestHeader

`@RequestHeader`是将**请求头信息和控制器方法的形参**创建映射关系

`@RequestHeader`注解一共有三个属性：`value`、`required`、`defaultValue`，用法同@RequestParam。

    @RequestMapping("/paramHeader")
    public String paramTest2(@RequestHeader(value = "Host",required = true,defaultValue = "host8080") String hostName){
    	//hostName:localhost:8080
        System.out.println("hostName:"+hostName);
        return "success";
    }
    

### 5、@CookieValue

`@CookieValue`是将**cookie数据和控制器方法的形参**创建映射关系

`@CookieValue`注解一共有三个属性：`value`、`required`、`defaultValue`，用法同`@RequestParam`。

与@RequestParam、@RequestHeader用法类似。

### 6、通过POJO获取请求参数

可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值

    <form th:action="@{/testpojo}" method="post">
        用户名：<input type="text" name="username"><br>
        密码：<input type="password" name="password"><br>
        性别：<input type="radio" name="sex" value="男">男<input type="radio" name="sex" value="女">女<br>
        年龄：<input type="text" name="age"><br>
        邮箱：<input type="text" name="email"><br>
        <input type="submit">
    </form>
    

    @RequestMapping("/testpojo")
    public String testPOJO(User user){
        System.out.println(user);
        return "success";
    }
    //最终结果-->User{id=null, username='张三', password='123', age=23, sex='男', email='123@qq.com'}
    

### 7、解决获取请求参数的乱码问题

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328201406834-1048577963.png)

解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器`CharacterEncodingFilter`，但是必须在`web.xml`中进行注册

    <!--配置springMVC的编码过滤器-->
    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceResponseEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    

> 注：
> 
> SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效

五、域对象共享数据
=========

对重要针对于servlet、session、application三种域对象。

### 1、使用ServletAPI向request域对象共享数据

    @RequestMapping("/testServletAPI")
    public String testServletAPI(HttpServletRequest request){
        request.setAttribute("testScope", "hello,servletAPI");
        return "success";
    }
    

### 2、使用ModelAndView向request域对象共享数据

    @RequestMapping("/testModelAndView")
    public ModelAndView testModelAndView(){
        /**
         * ModelAndView有Model和View的功能
         * Model主要用于向请求域共享数据
         * View主要用于设置视图，实现页面跳转
         */
        ModelAndView mav = new ModelAndView();
        //向请求域共享数据
        mav.addObject("testScope", "hello,ModelAndView");
        //设置视图，实现页面跳转
        mav.setViewName("success");
        return mav;
    }
    

### 3、使用Model向request域对象共享数据

    @RequestMapping("/testModel")
    public String testModel(Model model){
        model.addAttribute("testScope", "hello,Model");
        return "success";
    }
    

### 4、使用map向request域对象共享数据

    @RequestMapping("/testMap")
    public String testMap(Map<String, Object> map){
        map.put("testScope", "hello,Map");
        return "success";
    }
    

### 5、使用ModelMap向request域对象共享数据

    @RequestMapping("/testModelMap")
    public String testModelMap(ModelMap modelMap){
        modelMap.addAttribute("testScope", "hello,ModelMap");
        return "success";
    }
    

### 6、Model、ModelMap、Map的关系

`Model`、`ModelMap`、`Map`类型的参数其实本质上都是 `BindingAwareModelMap` 类型的

    public interface Model{}
    public class ModelMap extends LinkedHashMap<String, Object> {}
    public class ExtendedModelMap extends ModelMap implements Model {}
    public class BindingAwareModelMap extends ExtendedModelMap {}
    

都是通过他们的实现类或者子类`org.springframework.validation.support.BindingAwareModelMap`来实现。

### 7、向session域共享数据

    @RequestMapping("/testSession")
    public String testSession(HttpSession session){
        session.setAttribute("testSessionScope", "hello,session");
        return "success";
    }
    

    <!--通过session.属性名获取这个属性的值-->
    <p th:text="${session.testSessionScope}"></p>
    

### 8、向application域共享数据

    @RequestMapping("/testApplication")
    public String testApplication(HttpSession session){
    	ServletContext application = session.getServletContext();
        application.setAttribute("testApplicationScope", "hello,application");
        return "success";
    }
    

    <!--通过application.属性名获取这个属性的值-->
    <p th:text="${application.testApplicationScope}"></p>
    

六、SpringMVC的视图
==============

SpringMVC中的视图是`View`接口，视图的作用渲染数据，将模型`Model`中的数据展示给用户

SpringMVC视图的种类很多，默认有**转发视图**`InternalResourceView`和**重定向视图**`RedirectView`

当工程引入`jstl`的依赖（解决jsp中嵌入java代码的繁琐），转发视图会自动转换为`JstlView`。

若使用的视图技术为`Thymeleaf`，在SpringMVC的配置文件中配置了**Thymeleaf的视图解析器**，由此视图解析器解析之后所得到的是ThymeleafView。

### 1、ThymeleafView

**当控制器方法中所设置的视图名称没有任何前缀时**，如：`forward`和`redirect`，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称**拼接视图前缀和视图后缀**所得到的最终路径，会通过**转发**的方式实现跳转。

    @RequestMapping("/testHello")
    public String testHello(){
        return "hello";
    }
    

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328201726583-1607410692.png)

### 2、转发视图

SpringMVC中默认的转发视图是`InternalResourceView`

SpringMVC中创建转发视图的情况：

当控制器方法中所设置的视图名称以"`forward`:"为前缀时，创建`InternalResourceView`视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"`forward`:"去掉，剩余部分作为最终路径通过**转发的方式实现跳转**。

例如"forward:/"，"forward:/employee"

    @RequestMapping("/testForward")
    public String testForward(){
        return "forward:/testHello";
    }
    

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328202054150-257144419.png)

### 3、重定向视图

SpringMVC中默认的重定向视图是`RedirectView`

当控制器方法中所设置的视图名称以"`redirect`:"为前缀时，创建`RedirectView`视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"`redirect`:"去掉，剩余部分作为最终路径通过重定向的方式实现跳转

例如"redirect:/"，"redirect:/employee"

        @RequestMapping("/testRedirect")
        public String testRedirect(){
            return "redirect:/testHello";
        }
    

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328202116434-140107195.png)

> 注：
> 
> 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径

> 转发与重定向的区别

**转发**：浏览器发送一次请求后由服务器再发送请求，所以浏览器地址还是浏览器第一次向服务器发送的请求。转发可使用请求域中的数据，也可以访问`WEB-INF`下资源。

**重定向**：重定向两次去请求都是浏览器发送，所以浏览器上的地址为浏览器第二次向服务器发送的地址。重定向不可以使用请求域中的数据，不可以访问`WEB-INF`下资源（安全性，只能由服务器内部访问）。但是重定向可以跨域（如访问其他网址资源）。

### 4、视图控制器view-controller

当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用`view-controller`标签进行表示

    <!--
    	path：设置处理的请求地址
    	view-name：设置请求地址所对应的视图名称
    -->
    <mvc:view-controller path="/testView" view-name="success"></mvc:view-controller>
    

> 注：
> 
> 当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：
> 
> <mvc:annotation-driven />

七、RESTful
=========

### 1、RESTful简介

`REST`：**Re**presentational **S**tate **T**ransfer，表现层资源状态转移。

##### a>资源

资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。

##### b>资源的表述

资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。

##### c>状态转移

状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。

### 2、RESTful的实现

具体说，就是 HTTP 协议里面，四个表示操作方式的动词：`GET`、`POST`、`PUT`、`DELETE`。

它们分别对应四种基本操作：**GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。**

REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。

操作

传统方式

REST风格

查询操作

getUserById?id=1

user/1-->get请求方式

保存操作

saveUser

user-->post请求方式

删除操作

deleteUser?id=1

user/1-->delete请求方式

更新操作

updateUser

user-->put请求方式

### 3、HiddenHttpMethodFilter

由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？

SpringMVC 提供了 **HiddenHttpMethodFilter** 帮助我们**将 POST 请求转换为 DELETE 或 PUT 请求**

**HiddenHttpMethodFilter** 处理put和delete请求的条件：

a>**当前请求的请求方式必须为post**

b>**当前请求必须传输请求参数\_method**

满足以上条件，**HiddenHttpMethodFilter** 过滤器就会将当前请求的请求方式转换为请求参数\_method的值，因此请求参数\_method的值才是最终的请求方式

在web.xml中注册**HiddenHttpMethodFilter**

    <filter>
        <filter-name>HiddenHttpMethodFilter</filter-name>
        <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>HiddenHttpMethodFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    

> 注：
> 
> 目前为止，SpringMVC中提供了两个过滤器：`CharacterEncodingFilter`和`HiddenHttpMethodFilter`
> 
> 在`web.xml`中注册时，**必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter**
> 
> 原因：
> 
> *   在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的
>     
> *   request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作
>     
> *   而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：
>     
> *       String paramValue = request.getParameter(this.methodParam);
>         
>     

八、RESTful案例
===========

### 1、准备工作

和传统 CRUD 一样，实现对员工信息的增删改查。

*   搭建环境
    
*   准备实体类
    
        package com.atguigu.mvc.bean;
        
        public class Employee {
        
           private Integer id;
           private String lastName;
        
           private String email;
           //1 male, 0 female
           private Integer gender;
           
           public Integer getId() {
              return id;
           }
        
           public void setId(Integer id) {
              this.id = id;
           }
        
           public String getLastName() {
              return lastName;
           }
        
           public void setLastName(String lastName) {
              this.lastName = lastName;
           }
        
           public String getEmail() {
              return email;
           }
        
           public void setEmail(String email) {
              this.email = email;
           }
        
           public Integer getGender() {
              return gender;
           }
        
           public void setGender(Integer gender) {
              this.gender = gender;
           }
        
           public Employee(Integer id, String lastName, String email, Integer gender) {
              super();
              this.id = id;
              this.lastName = lastName;
              this.email = email;
              this.gender = gender;
           }
        
           public Employee() {
           }
        }
        
    
*   准备dao模拟数据
    
        package com.atguigu.mvc.dao;
        
        import java.util.Collection;
        import java.util.HashMap;
        import java.util.Map;
        
        import com.atguigu.mvc.bean.Employee;
        import org.springframework.stereotype.Repository;
        
        
        @Repository
        public class EmployeeDao {
        
           private static Map<Integer, Employee> employees = null;
           
           static{
              employees = new HashMap<Integer, Employee>();
        
              employees.put(1001, new Employee(1001, "E-AA", "aa@163.com", 1));
              employees.put(1002, new Employee(1002, "E-BB", "bb@163.com", 1));
              employees.put(1003, new Employee(1003, "E-CC", "cc@163.com", 0));
              employees.put(1004, new Employee(1004, "E-DD", "dd@163.com", 0));
              employees.put(1005, new Employee(1005, "E-EE", "ee@163.com", 1));
           }
           
           private static Integer initId = 1006;
           
           public void save(Employee employee){
              if(employee.getId() == null){
                 employee.setId(initId++);
              }
              employees.put(employee.getId(), employee);
           }
           
           public Collection<Employee> getAll(){
              return employees.values();
           }
           
           public Employee get(Integer id){
              return employees.get(id);
           }
           
           public void delete(Integer id){
              employees.remove(id);
           }
        }
        
    

### 2、功能清单

功能

URL 地址

请求方式

访问首页√

/

GET

查询全部数据√

/employee

GET

删除√

/employee/2

DELETE

跳转到添加数据页面√

/toAdd

GET

执行保存√

/employee

POST

跳转到更新数据页面√

/employee/2

GET

执行更新√

/employee

PUT

### 3、具体功能：访问首页

##### a>配置view-controller

    <mvc:view-controller path="/" view-name="index"/>
    

##### b>创建页面

    <!DOCTYPE html>
    <html lang="en" xmlns:th="http://www.thymeleaf.org">
    <head>
        <meta charset="UTF-8" >
        <title>Title</title>
    </head>
    <body>
    <h1>首页</h1>
    <a th:href="@{/employee}">访问员工信息</a>
    </body>
    </html>
    

### 4、具体功能：查询所有员工数据

##### a>控制器方法

    @RequestMapping(value = "/employee", method = RequestMethod.GET)
    public String getEmployeeList(Model model){
        Collection<Employee> employeeList = employeeDao.getAll();
        model.addAttribute("employeeList", employeeList);
        return "employee_list";
    }
    

##### b>创建employee\_list.html

    <!DOCTYPE html>
    <html lang="en" xmlns:th="http://www.thymeleaf.org">
    <head>
        <meta charset="UTF-8">
        <title>Employee Info</title>
        <script type="text/javascript" th:src="@{/static/js/vue.js}"></script>
    </head>
    <body>
    
        <table border="1" cellpadding="0" cellspacing="0" style="text-align: center;" id="dataTable">
            <tr>
                <th colspan="5">Employee Info</th>
            </tr>
            <tr>
                <th>id</th>
                <th>lastName</th>
                <th>email</th>
                <th>gender</th>
                <th>options(<a th:href="@{/toAdd}">add</a>)</th>
            </tr>
            <tr th:each="employee : ${employeeList}">
                <td th:text="${employee.id}"></td>
                <td th:text="${employee.lastName}"></td>
                <td th:text="${employee.email}"></td>
                <td th:text="${employee.gender}"></td>
                <td>
                    <a class="deleteA" @click="deleteEmployee" th:href="@{'/employee/'+${employee.id}}">delete</a>
                    <a th:href="@{'/employee/'+${employee.id}}">update</a>
                </td>
            </tr>
        </table>
    </body>
    </html>
    

### 5、具体功能：删除

##### a>创建处理delete请求方式的表单

    <!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 -->
    <form id="delete_form" method="post">
        <!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 -->
        <input type="hidden" name="_method" value="delete"/>
    </form>
    

##### b>删除超链接绑定点击事件

引入vue.js

    <script type="text/javascript" th:src="@{/static/js/vue.js}"></script>
    

删除超链接

    <a class="deleteA" @click="deleteEmployee" th:href="@{'/employee/'+${employee.id}}">delete</a>
    

通过vue处理点击事件

    <script type="text/javascript">
        var vue = new Vue({
            el:"#dataTable",
            methods:{
                //event表示当前事件
                deleteEmployee:function (event) {
                    //通过id获取表单标签
                    var delete_form = document.getElementById("delete_form");
                    //将触发事件的超链接的href属性为表单的action属性赋值
                    delete_form.action = event.target.href;
                    //提交表单
                    delete_form.submit();
                    //阻止超链接的默认跳转行为
                    event.preventDefault();
                }
            }
        });
    </script>
    

##### c>控制器方法

    @RequestMapping(value = "/employee/{id}", method = RequestMethod.DELETE)
    public String deleteEmployee(@PathVariable("id") Integer id){
        employeeDao.delete(id);
        return "redirect:/employee";
    }
    

> 注意：

添加完js文件后在打的包下可能还是没有该js文件，需要使用Maven重新打包。另外即便如此，还可能报错，这是因为前端控制器接管了js文件导致，需要配置`<mvc:default-servlet-handler />`属性（不在使用SpringMVC的DispatcherServlet控制，而是使用Servlet默认的控制器DefaultServletHttpRequestHandler处理），使静态资源得以开放被访问。

### 6、具体功能：跳转到添加数据页面

##### a>配置view-controller

    <mvc:view-controller path="/toAdd" view-name="employee_add"></mvc:view-controller>
    

##### b>创建employee\_add.html

    <!DOCTYPE html>
    <html lang="en" xmlns:th="http://www.thymeleaf.org">
    <head>
        <meta charset="UTF-8">
        <title>Add Employee</title>
    </head>
    <body>
    
    <form th:action="@{/employee}" method="post">
        lastName:<input type="text" name="lastName"><br>
        email:<input type="text" name="email"><br>
        gender:<input type="radio" name="gender" value="1">male
        <input type="radio" name="gender" value="0">female<br>
        <input type="submit" value="add"><br>
    </form>
    
    </body>
    </html>
    

### 7、具体功能：执行保存

##### a>控制器方法

    @RequestMapping(value = "/employee", method = RequestMethod.POST)
    public String addEmployee(Employee employee){
        employeeDao.save(employee);
        return "redirect:/employee";
    }
    

### 8、具体功能：跳转到更新数据页面

##### a>修改超链接

    <a th:href="@{'/employee/'+${employee.id}}">update</a>
    

##### b>控制器方法

    @RequestMapping(value = "/employee/{id}", method = RequestMethod.GET)
    public String getEmployeeById(@PathVariable("id") Integer id, Model model){
        Employee employee = employeeDao.get(id);
        model.addAttribute("employee", employee);
        return "employee_update";
    }
    

##### c>创建employee\_update.html

    <!DOCTYPE html>
    <html lang="en" xmlns:th="http://www.thymeleaf.org">
    <head>
        <meta charset="UTF-8">
        <title>Update Employee</title>
    </head>
    <body>
    
    <form th:action="@{/employee}" method="post">
        <input type="hidden" name="_method" value="put">
        <input type="hidden" name="id" th:value="${employee.id}">
        lastName:<input type="text" name="lastName" th:value="${employee.lastName}"><br>
        email:<input type="text" name="email" th:value="${employee.email}"><br>
        <!--
            th:field="${employee.gender}"可用于单选框或复选框的回显
            若单选框的value和employee.gender的值一致，则添加checked="checked"属性
        -->
        gender:<input type="radio" name="gender" value="1" th:field="${employee.gender}">male
        <input type="radio" name="gender" value="0" th:field="${employee.gender}">female<br>
        <input type="submit" value="update"><br>
    </form>
    
    </body>
    </html>
    

### 9、具体功能：执行更新

##### a>控制器方法

    @RequestMapping(value = "/employee", method = RequestMethod.PUT)
    public String updateEmployee(Employee employee){
        employeeDao.save(employee);
        return "redirect:/employee";
    }
    

八、HttpMessageConverter
======================

`HttpMessageConverter`，**报文信息转换器**，将请求报文转换为Java对象，或将Java对象转换为响应报文。

HttpMessageConverter提供了两个注解和两个类型：`@RequestBody`，`@ResponseBody`，`RequestEntity`，`ResponseEntity`

### 1、@RequestBody

`@RequestBody`可以获取**请求体**，需要在控制器方法设置一个形参，使用`@RequestBody`进行标识，当前请求的请求体就会为当前注解所标识的形参赋值

    <form th:action="@{/testRequestBody}" method="post">
        用户名：<input type="text" name="username"><br>
        密码：<input type="password" name="password"><br>
        <input type="submit">
    </form>
    

    @RequestMapping("/testRequestBody")
    public String testRequestBody(@RequestBody String requestBody){
        System.out.println("requestBody:"+requestBody);
        return "success";
    }
    

输出结果：

requestBody:username=admin&password=123456

### 2、RequestEntity

`RequestEntity`封装**请求报文**的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过`getHeaders()`获取请求头信息，通过`getBody()`获取请求体信息

    @RequestMapping("/testRequestEntity")
    public String testRequestEntity(RequestEntity<String> requestEntity){
        System.out.println("requestHeader:"+requestEntity.getHeaders());
        System.out.println("requestBody:"+requestEntity.getBody());
        return "success";
    }
    

输出结果：  
requestHeader:\[host:"localhost:8080", connection:"keep-alive", content-length:"27", cache-control:"max-age=0", sec-ch-ua:"" Not A;Brand";v="99", "Chromium";v="90", "Google Chrome";v="90"", sec-ch-ua-mobile:"?0", upgrade-insecure-requests:"1", origin:"[http://localhost:8080](http://localhost:8080)", user-agent:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"\]  
requestBody:username=admin&password=123

### 3、@ResponseBody

@ResponseBody用于标识一个控制器方法，可以将该方法的**返回值直接作为响应报文的响应体**响应到浏览器，而不是一个视图名称。

    @RequestMapping("/testResponseBody")
    @ResponseBody
    public String testResponseBody(){
        return "success";
    }
    

结果：浏览器页面显示success

与原生Servlet的API类似：

    @RequestMapping("/testResponse")
    public void testResponse(HttpServletResponse response) throws IOException {
        response.getWriter().println("Hello,Response");
    }
    

### 4、SpringMVC处理json

json有两种形式，一种是**Json对象**（{}），一种是**Json数组**（\[\]）。

@ResponseBody处理json的步骤：

a>导入`jackson`的依赖

    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.12.1</version>
    </dependency>
    

b>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在`HandlerAdaptor`中会自动装配一个消息转换器：`MappingJackson2HttpMessageConverter`，可以将响应到浏览器的Java对象转换为Json格式的字符串。

    <mvc:annotation-driven />
    

c>在处理器方法上使用@ResponseBody注解进行标识

d>将Java对象直接作为控制器方法的返回值返回，就会自动转换为**Json格式的字符串**。

    @RequestMapping("/testResponseUser")
    @ResponseBody
    public User testResponseUser(){
        return new User(1001,"admin","123456",23,"男");
    }
    

浏览器的页面中展示的结果：

{"id":1001,"username":"admin","password":"123456","age":23,"sex":"男"}

> 可以创建一个jackson的对象映射器，用来解析数据

    //创建一个jackson的对象映射器，用来解析数据
           ObjectMapper mapper = new ObjectMapper();
           //创建一个对象
           User user = new User("秦疆1号", 3, "男");
           //将我们的对象解析成为json格式
           String str = mapper.writeValueAsString(user);
    

e> 解决乱码问题

1.  通过@RequestMaping的produces属性来实现
    
        @RequestMapping(value = "/json1",produces = "application/json;charset=utf-8")
        
    
2.  Spring配置统一指定StringHttpMessageConverter转换配置
    
        <mvc:annotation-driven>
           <mvc:message-converters register-defaults="true">
               <bean class="org.springframework.http.converter.StringHttpMessageConverter">
                   <constructor-arg value="UTF-8"/>
               </bean>
               <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
                   <property name="objectMapper">
                       <bean class="org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean">
                           <property name="failOnEmptyBeans" value="false"/>
                       </bean>
                   </property>
               </bean>
           </mvc:message-converters>
        </mvc:annotation-driven>
        
    

> 与`jackson`类似的还有`FastJson`

fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。

    <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>fastjson</artifactId>
       <version>1.2.60</version>
    </dependency>
    

fastjson 三个主要的类：

**JSONObject 代表 json 对象**

*   JSONObject实现了Map接口。
*   JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取"键：值"对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。

**JSONArray 代表 json 对象数组**

*   内部是有List接口中的方法来完成操作的。

**JSON代表 JSONObject和JSONArray的转化**

*   JSON类源码分析与使用
*   仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。

### 5、SpringMVC处理ajax

a>请求超链接：

    <div id="app">
    	<a th:href="@{/testAjax}" @click="testAjax">testAjax</a><br>
    </div>
    

b>通过`vue`和`axios`处理点击事件：

    <script type="text/javascript" th:src="@{/static/js/vue.js}"></script>
    <script type="text/javascript" th:src="@{/static/js/axios.min.js}"></script>
    <script type="text/javascript">
        var vue = new Vue({
            el:"#app",
            methods:{
                testAjax:function (event) {
                    axios({
                        method:"post",
                        url:event.target.href,
                        params:{
                            username:"admin",
                            password:"123456"
                        }
                    }).then(function (response) {
                        alert(response.data);
                    });
                    event.preventDefault();
                }
            }
        });
    </script>
    

c>控制器方法：

    @RequestMapping("/testAjax")
    @ResponseBody
    public String testAjax(String username, String password){
        System.out.println("username:"+username+",password:"+password);
        return "hello,ajax";
    }
    

### 6、@RestController注解

`@RestController`注解是`springMVC`提供的一个复合注解，标识在控制器的类上，就相当于为类添加了`@Controller`注解，并且为其中的每个方法添加了`@ResponseBody`注解。这样子，里面所有的方法都只会返回 `json` 字符串了，不用再每一个都添加`@ResponseBody` ！前后端分离开发中常用。

### 7、ResponseEntity

`ResponseEntity`用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文，案例：文件下载。

九、文件上传和下载
=========

### 1、文件下载

使用ResponseEntity实现下载文件的功能

    @RequestMapping("/testDown")
    public ResponseEntity<byte[]> testResponseEntity(HttpSession session) throws IOException {
        //获取ServletContext对象
        ServletContext servletContext = session.getServletContext();
        //获取服务器中文件的真实路径
        String realPath = servletContext.getRealPath("/static/img/1.jpg");
        //创建输入流
        InputStream is = new FileInputStream(realPath);
        //创建字节数组
        byte[] bytes = new byte[is.available()];
        //将流读到字节数组中
        is.read(bytes);
        //创建HttpHeaders对象设置响应头信息
        MultiValueMap<String, String> headers = new HttpHeaders();
        //设置要下载方式以及下载文件的名字
        headers.add("Content-Disposition", "attachment;filename=1.jpg");
        //设置响应状态码
        HttpStatus statusCode = HttpStatus.OK;
        //创建ResponseEntity对象
        ResponseEntity<byte[]> responseEntity = new ResponseEntity<>(bytes, headers, statusCode);
        //关闭输入流
        is.close();
        return responseEntity;
    }
    

### 2、文件上传

文件上传要求`form`表单的请求方式必须为`post`，并且添加属性`enctype="multipart/form-data"`，只有在这样的情况下，浏览器才会把用户选择的文件以**二进制数据**发送给服务器；

SpringMVC中将上传的文件封装到`MultipartFile`对象中，通过此对象可以获取文件相关信息

上传步骤：

a>添加依赖：

    <!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->
    <dependency>
        <groupId>commons-fileupload</groupId>
        <artifactId>commons-fileupload</artifactId>
        <version>1.3.1</version>
    </dependency>
    

b>在SpringMVC的配置文件中添加配置（文件上传解析器）：

    <!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象-->
    <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
        
       <!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 -->
       <property name="defaultEncoding" value="utf-8"/>
       <!-- 上传文件大小上限，单位为字节（10485760=10M） -->
       <property name="maxUploadSize" value="10485760"/>
       <property name="maxInMemorySize" value="40960"/>
    </bean>
    

【**注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误**】

c>控制器方法：

    @RequestMapping("/testUp")
    public String testUp(MultipartFile photo, HttpSession session) throws IOException {
        //获取上传的文件的文件名
        String fileName = photo.getOriginalFilename();
        //处理文件重名问题
        String hzName = fileName.substring(fileName.lastIndexOf("."));
        fileName = UUID.randomUUID().toString() + hzName;
        //获取服务器中photo目录的路径
        ServletContext servletContext = session.getServletContext();
        String photoPath = servletContext.getRealPath("photo");
        File file = new File(photoPath);
        if(!file.exists()){
            file.mkdir();
        }
        String finalPath = photoPath + File.separator + fileName;
        //实现上传功能
        photo.transferTo(new File(finalPath));
        return "success";
    }
    

CommonsMultipartFile 的 常用方法：

*   **String getOriginalFilename()：获取上传文件的原名**
*   **InputStream getInputStream()：获取文件流**
*   **void transferTo(File dest)：将上传文件保存到一个目录文件中**

十、拦截器
=====

**过滤器与拦截器的区别：**拦截器是`AOP`思想的具体应用。

**过滤器**

*   servlet规范中的一部分，任何java web工程都可以使用
*   在url-pattern中配置了`/*`之后，可以对所有要访问的资源进行拦截

**拦截器**

*   拦截器属于`SpringMVC框架`，只有使用了SpringMVC框架的工程才能使用
*   拦截器只会拦截访问的**控制器方法**， 如果访问的是`jsp/html/css/image/js`是不会进行拦截的

### 1、拦截器的配置

SpringMVC中的拦截器用于拦截控制器方法的执行

SpringMVC中的拦截器需要实现`HandlerInterceptor`

SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：

    <!--配置拦截器-->
    <mvc:interceptors>
        ……
    </mvc:interceptors>
    

可以配置多个拦截器，在`mvc:interceptors`标签中添加`bean`、`ref`、`mvc:interceptor`标签添加拦截器。`bean`、`ref`添加的拦截器无法设置拦截规则，因此会**将所有请求进行拦截**。

    <bean class="com.atguigu.interceptor.FirstInterceptor"></bean>
    <ref bean="firstInterceptor"></ref>
    <!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 -->
    
    <mvc:interceptor>
        <!--/** 包括路径及其子路径-->
        <!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截-->
        <!--/admin/** 拦截的是/admin/下的所有-->
        <mvc:mapping path="/**"/>
        <mvc:exclude-mapping path="/testRequestEntity"/>
        <ref bean="firstInterceptor"></ref>
    </mvc:interceptor>
    <!-- 
    	以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求
    -->
    

### 2、拦截器的三个抽象方法

SpringMVC中的拦截器有三个抽象方法：

`preHandle`：**控制器方法执行之前执行**`preHandle()`，其`boolean`类型的返回值表示**是否拦截或放行**，返回`true`为放行，即调用控制器方法；返回`false`表示拦截，即不调用控制器方法。

`postHandle`：**控制器方法执行之后**执行`postHandle()`。

`afterComplation`：处理完视图和模型数据，**渲染视图完毕之后执行**`afterComplation()`。

### 3、多个拦截器的执行顺序

a>若每个拦截器的preHandle()都返回true

此时多个拦截器的执行顺序和拦截器在SpringMVC的**配置文件的配置顺序有关**：

preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照**配置的反序执行**

b>若某个拦截器的preHandle()返回了false

preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行

### 4、案例：验证用户是否登录 (认证用户)

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException {
           // 如果是登陆页面则放行
           System.out.println("uri: " + request.getRequestURI());
        
           if (request.getRequestURI().contains("login")) {
               return true;
          }
    
           HttpSession session = request.getSession();
    
           // 如果用户已登陆也放行
           if(session.getAttribute("user") != null) {
               return true;
          }
    
           // 用户没有登陆跳转到登陆页面
           request.getRequestDispatcher("/WEB-INF/jsp/login.jsp").forward(request, response);
           return false;
      }
    

十一、异常处理器
========

### 1、基于配置的异常处理

SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：`HandlerExceptionResolver`

`HandlerExceptionResolver`接口的实现类有：`DefaultHandlerExceptionResolver`和`SimpleMappingExceptionResolver`。

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328202444214-1884026274.png)

SpringMVC提供了自定义的异常处理器`SimpleMappingExceptionResolver`，使用方式：

    <bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <props>
            	<!--
            		properties的键表示处理器方法执行过程中出现的异常(全类名)
            		properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面
            	-->
                <prop key="java.lang.ArithmeticException">error</prop>
            </props>
        </property>
        <!--
        	exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享，可在错误页面获取并显示。
        -->
        <property name="exceptionAttribute" value="ex"></property>
    </bean>
    

error视图中 `<p th:text="${ex}"></p><br>`取出`ex`中表示的具体错误信息。

### 2、基于注解的异常处理

    //@ControllerAdvice将当前类标识为异常处理的组件
    @ControllerAdvice
    public class ExceptionController {
    
        //@ExceptionHandler用于设置所标识方法处理的异常
        @ExceptionHandler(ArithmeticException.class)
        //ex表示当前请求处理中出现的异常对象
        public String handleArithmeticException(Exception ex, Model model){
            model.addAttribute("ex", ex);
            return "error";
        }
    
    }
    

十二、注解配置SpringMVC
================

使用配置类和注解代替web.xml和SpringMVC配置文件的功能

### 1、创建初始化类，代替web.xml

在**`Servlet3.0`**环境中，容器会在类路径中查找实现`javax.servlet.ServletContainerInitializer`接口的类，如果找到的话就用它来配置Servlet容器。  
Spring提供了这个接口的实现，名为`**SpringServletContainerInitializer**`，这个类反过来又会查找实现`WebApplicationInitializer`的类并将配置的任务交给它们来完成。`Spring3.2`引入了一个便利的`WebApplicationInitializer`基础实现，名为`AbstractAnnotationConfigDispatcherServletInitializer`，当我们的类扩展了`AbstractAnnotationConfigDispatcherServletInitializer`并将其部署到`Servlet3.0`容器的时候，容器会自动发现它，并用它来配置Servlet上下文。

    public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {
    
        /**
         * 指定spring的配置类
         * @return
         */
        @Override
        protected Class<?>[] getRootConfigClasses() {
            return new Class[]{SpringConfig.class};
        }
    
        /**
         * 指定SpringMVC的配置类
         * @return
         */
        @Override
        protected Class<?>[] getServletConfigClasses() {
            return new Class[]{WebConfig.class};
        }
    
        /**
         * 指定DispatcherServlet的映射规则，即url-pattern
         * @return
         */
        @Override
        protected String[] getServletMappings() {
            return new String[]{"/"};
        }
    
        /**
         * 添加过滤器
         * @return
         */
        @Override
        protected Filter[] getServletFilters() {
            CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();
            encodingFilter.setEncoding("UTF-8");
            encodingFilter.setForceRequestEncoding(true);
            HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();
            return new Filter[]{encodingFilter, hiddenHttpMethodFilter};
        }
    }
    

### 2、创建SpringConfig配置类，代替spring的配置文件

    @Configuration
    public class SpringConfig {
    	//ssm整合之后，spring的配置信息写在此类中
    }
    

### 3、创建WebConfig配置类，代替SpringMVC的配置文件

    @Configuration
    //扫描组件
    @ComponentScan("com.atguigu.mvc.controller")
    //开启MVC注解驱动
    @EnableWebMvc
    public class WebConfig implements WebMvcConfigurer {
    
        //使用默认的servlet处理静态资源
        @Override
        public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
            configurer.enable();
        }
    
        //配置文件上传解析器
        @Bean
        public CommonsMultipartResolver multipartResolver(){
            return new CommonsMultipartResolver();
        }
    
        //配置拦截器
        @Override
        public void addInterceptors(InterceptorRegistry registry) {
            FirstInterceptor firstInterceptor = new FirstInterceptor();
            registry.addInterceptor(firstInterceptor).addPathPatterns("/**");
        }
        
        //配置视图控制
        
        /*@Override
        public void addViewControllers(ViewControllerRegistry registry) {
            registry.addViewController("/").setViewName("index");
        }*/
        
        //配置异常映射
        /*@Override
        public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
            SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();
            Properties prop = new Properties();
            prop.setProperty("java.lang.ArithmeticException", "error");
            //设置异常映射
            exceptionResolver.setExceptionMappings(prop);
            //设置共享异常信息的键
            exceptionResolver.setExceptionAttribute("ex");
            resolvers.add(exceptionResolver);
        }*/
    
        //配置生成模板解析器
        @Bean
        public ITemplateResolver templateResolver() {
            WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();
            // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得
            ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(
                    webApplicationContext.getServletContext());
            templateResolver.setPrefix("/WEB-INF/templates/");
            templateResolver.setSuffix(".html");
            templateResolver.setCharacterEncoding("UTF-8");
            templateResolver.setTemplateMode(TemplateMode.HTML);
            return templateResolver;
        }
    
        //生成模板引擎并为模板引擎注入模板解析器
        @Bean
        public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {
            SpringTemplateEngine templateEngine = new SpringTemplateEngine();
            templateEngine.setTemplateResolver(templateResolver);
            return templateEngine;
        }
    
        //生成视图解析器并未解析器注入模板引擎
        @Bean
        public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {
            ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
            viewResolver.setCharacterEncoding("UTF-8");
            viewResolver.setTemplateEngine(templateEngine);
            return viewResolver;
        }
    }
    

### 4、测试功能

    @RequestMapping("/")
    public String index(){
        return "index";
    }
    

十三、SpringMVC执行流程
================

### 1、SpringMVC常用组件

*   DispatcherServlet：**前端控制器**，不需要工程师开发，由框架提供。

作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求。

*   HandlerMapping：**处理器映射器**，不需要工程师开发，由框架提供。

作用：根据请求的url、method等信息查找Handler，即控制器方法，也就是@RequestMapping。

*   Handler：**处理器**，需要工程师开发。

作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理。

*   HandlerAdapter：**处理器适配器**，不需要工程师开发，由框架提供。

作用：通过HandlerAdapter对处理器（控制器方法）进行执行。

*   ViewResolver：**视图解析器**，不需要工程师开发，由框架提供。

作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView。

*   View：**视图**

作用：将模型数据通过页面展示给用户。

### 2、DispatcherServlet初始化过程

DispatcherServlet 本质上是一个 Servlet，所以遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328202703331-1806842159.png)

##### a>初始化WebApplicationContext

所在类：org.springframework.web.servlet.FrameworkServlet

    protected WebApplicationContext initWebApplicationContext() {
        WebApplicationContext rootContext =
            WebApplicationContextUtils.getWebApplicationContext(getServletContext());
        WebApplicationContext wac = null;
    
        if (this.webApplicationContext != null) {
            // A context instance was injected at construction time -> use it
            wac = this.webApplicationContext;
            if (wac instanceof ConfigurableWebApplicationContext) {
                ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
                if (!cwac.isActive()) {
                    // The context has not yet been refreshed -> provide services such as
                    // setting the parent context, setting the application context id, etc
                    if (cwac.getParent() == null) {
                        // The context instance was injected without an explicit parent -> set
                        // the root application context (if any; may be null) as the parent
                        cwac.setParent(rootContext);
                    }
                    configureAndRefreshWebApplicationContext(cwac);
                }
            }
        }
        if (wac == null) {
            // No context instance was injected at construction time -> see if one
            // has been registered in the servlet context. If one exists, it is assumed
            // that the parent context (if any) has already been set and that the
            // user has performed any initialization such as setting the context id
            wac = findWebApplicationContext();
        }
        if (wac == null) {
            // No context instance is defined for this servlet -> create a local one
            // 创建WebApplicationContext
            wac = createWebApplicationContext(rootContext);
        }
    
        if (!this.refreshEventReceived) {
            // Either the context is not a ConfigurableApplicationContext with refresh
            // support or the context injected at construction time had already been
            // refreshed -> trigger initial onRefresh manually here.
            synchronized (this.onRefreshMonitor) {
                // 刷新WebApplicationContext
                onRefresh(wac);
            }
        }
    
        if (this.publishContext) {
            // Publish the context as a servlet context attribute.
            // 将IOC容器在应用域共享
            String attrName = getServletContextAttributeName();
            getServletContext().setAttribute(attrName, wac);
        }
    
        return wac;
    }
    

##### b>创建WebApplicationContext

所在类：org.springframework.web.servlet.FrameworkServlet

    protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {
        Class<?> contextClass = getContextClass();
        if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {
            throw new ApplicationContextException(
                "Fatal initialization error in servlet with name '" + getServletName() +
                "': custom WebApplicationContext class [" + contextClass.getName() +
                "] is not of type ConfigurableWebApplicationContext");
        }
        // 通过反射创建 IOC 容器对象
        ConfigurableWebApplicationContext wac =
            (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
    
        wac.setEnvironment(getEnvironment());
        // 设置父容器
        wac.setParent(parent);
        String configLocation = getContextConfigLocation();
        if (configLocation != null) {
            wac.setConfigLocation(configLocation);
        }
        configureAndRefreshWebApplicationContext(wac);
    
        return wac;
    }
    

##### c>DispatcherServlet初始化策略

FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件

所在类：org.springframework.web.servlet.DispatcherServlet

    protected void initStrategies(ApplicationContext context) {
       initMultipartResolver(context);
       initLocaleResolver(context);
       initThemeResolver(context);
       initHandlerMappings(context);
       initHandlerAdapters(context);
       initHandlerExceptionResolvers(context);
       initRequestToViewNameTranslator(context);
       initViewResolvers(context);
       initFlashMapManager(context);
    }
    

### 3、DispatcherServlet调用组件处理请求

##### a>processRequest()

FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)

所在类：org.springframework.web.servlet.FrameworkServlet

    protected final void processRequest(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
    
        long startTime = System.currentTimeMillis();
        Throwable failureCause = null;
    
        LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
        LocaleContext localeContext = buildLocaleContext(request);
    
        RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
        ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);
    
        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
        asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());
    
        initContextHolders(request, localeContext, requestAttributes);
    
        try {
    		// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写
            doService(request, response);
        }
        catch (ServletException | IOException ex) {
            failureCause = ex;
            throw ex;
        }
        catch (Throwable ex) {
            failureCause = ex;
            throw new NestedServletException("Request processing failed", ex);
        }
    
        finally {
            resetContextHolders(request, previousLocaleContext, previousAttributes);
            if (requestAttributes != null) {
                requestAttributes.requestCompleted();
            }
            logResult(request, response, failureCause, asyncManager);
            publishRequestHandledEvent(request, response, startTime, failureCause);
        }
    }
    

##### b>doService()

所在类：org.springframework.web.servlet.DispatcherServlet

    @Override
    protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
        logRequest(request);
    
        // Keep a snapshot of the request attributes in case of an include,
        // to be able to restore the original attributes after the include.
        Map<String, Object> attributesSnapshot = null;
        if (WebUtils.isIncludeRequest(request)) {
            attributesSnapshot = new HashMap<>();
            Enumeration<?> attrNames = request.getAttributeNames();
            while (attrNames.hasMoreElements()) {
                String attrName = (String) attrNames.nextElement();
                if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {
                    attributesSnapshot.put(attrName, request.getAttribute(attrName));
                }
            }
        }
    
        // Make framework objects available to handlers and view objects.
        request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
        request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
        request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
        request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());
    
        if (this.flashMapManager != null) {
            FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
            if (inputFlashMap != null) {
                request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
            }
            request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
            request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);
        }
    
        RequestPath requestPath = null;
        if (this.parseRequestPath && !ServletRequestPathUtils.hasParsedRequestPath(request)) {
            requestPath = ServletRequestPathUtils.parseAndCache(request);
        }
    
        try {
            // 处理请求和响应
            doDispatch(request, response);
        }
        finally {
            if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
                // Restore the original attribute snapshot, in case of an include.
                if (attributesSnapshot != null) {
                    restoreAttributesAfterInclude(request, attributesSnapshot);
                }
            }
            if (requestPath != null) {
                ServletRequestPathUtils.clearParsedRequestPath(request);
            }
        }
    }
    

##### c>doDispatch()

所在类：org.springframework.web.servlet.DispatcherServlet

    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        HttpServletRequest processedRequest = request;
        HandlerExecutionChain mappedHandler = null;
        boolean multipartRequestParsed = false;
    
        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
    
        try {
            ModelAndView mv = null;
            Exception dispatchException = null;
    
            try {
                processedRequest = checkMultipart(request);
                multipartRequestParsed = (processedRequest != request);
    
                // Determine handler for the current request.
                /*
                	mappedHandler：调用链
                    包含handler、interceptorList、interceptorIndex
                	handler：浏览器发送的请求所匹配的控制器方法
                	interceptorList：处理控制器方法的所有拦截器集合
                	interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行
                */
                mappedHandler = getHandler(processedRequest);
                if (mappedHandler == null) {
                    noHandlerFound(processedRequest, response);
                    return;
                }
    
                // Determine handler adapter for the current request.
               	// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法
                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
    
                // Process last-modified header, if supported by the handler.
                String method = request.getMethod();
                boolean isGet = "GET".equals(method);
                if (isGet || "HEAD".equals(method)) {
                    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                    if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {
                        return;
                    }
                }
    			
                // 调用拦截器的preHandle()
                if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                    return;
                }
    
                // Actually invoke the handler.
                // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象
                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
    
                if (asyncManager.isConcurrentHandlingStarted()) {
                    return;
                }
    
                applyDefaultViewName(processedRequest, mv);
                // 调用拦截器的postHandle()
                mappedHandler.applyPostHandle(processedRequest, response, mv);
            }
            catch (Exception ex) {
                dispatchException = ex;
            }
            catch (Throwable err) {
                // As of 4.3, we're processing Errors thrown from handler methods as well,
                // making them available for @ExceptionHandler methods and other scenarios.
                dispatchException = new NestedServletException("Handler dispatch failed", err);
            }
            // 后续处理：处理模型数据和渲染视图
            processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
        }
        catch (Exception ex) {
            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
        }
        catch (Throwable err) {
            triggerAfterCompletion(processedRequest, response, mappedHandler,
                                   new NestedServletException("Handler processing failed", err));
        }
        finally {
            if (asyncManager.isConcurrentHandlingStarted()) {
                // Instead of postHandle and afterCompletion
                if (mappedHandler != null) {
                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
                }
            }
            else {
                // Clean up any resources used by a multipart request.
                if (multipartRequestParsed) {
                    cleanupMultipart(processedRequest);
                }
            }
        }
    }
    

##### d>processDispatchResult()

    private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
                                       @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
                                       @Nullable Exception exception) throws Exception {
    
        boolean errorView = false;
    
        if (exception != null) {
            if (exception instanceof ModelAndViewDefiningException) {
                logger.debug("ModelAndViewDefiningException encountered", exception);
                mv = ((ModelAndViewDefiningException) exception).getModelAndView();
            }
            else {
                Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
                mv = processHandlerException(request, response, handler, exception);
                errorView = (mv != null);
            }
        }
    
        // Did the handler return a view to render?
        if (mv != null && !mv.wasCleared()) {
            // 处理模型数据和渲染视图
            render(mv, request, response);
            if (errorView) {
                WebUtils.clearErrorRequestAttributes(request);
            }
        }
        else {
            if (logger.isTraceEnabled()) {
                logger.trace("No view rendering, null ModelAndView returned.");
            }
        }
    
        if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
            // Concurrent handling started during a forward
            return;
        }
    
        if (mappedHandler != null) {
            // Exception (if any) is already handled..
            // 调用拦截器的afterCompletion()
            mappedHandler.triggerAfterCompletion(request, response, null);
        }
    }
    

### 4、SpringMVC的执行流程

1.  用户向服务器发送请求，请求被SpringMVC 前端控制器 `DispatcherServlet`捕获。
    
2.  `DispatcherServlet`对请求`URL`进行解析，得到请求**资源标识符（`URI`）**，判断请求`URI`对应的映射：
    

a) 不存在

i. 再判断是否配置了`mvc:default-servlet-handler`

ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328202844845-940443735.png)

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328202904376-1486038434.png)

iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328202929234-1180753194.png)

![](https://img2022.cnblogs.com/blog/2154800/202203/2154800-20220328202945836-498530516.png)

b) 存在则执行下面的流程

3.  根据该`URI`，调用`HandlerMapping`获得该`Handler`配置的所有相关的对象（包括`Handler`对象以及`Handler`对象对应的拦截器），最后以`HandlerExecutionChain`执行链对象的形式返回。
    
4.  `DispatcherServlet` 根据获得的`Handler`，选择一个合适的`HandlerAdapter`。
    
5.  如果成功获得`HandlerAdapter`，此时将开始执行**拦截器**的`preHandler(…)`方法【正向】
    
6.  提取`Request`中的**模型数据**，填充**`Handler`入参**，开始执行`Handler`（Controller)方法，处理请求。在填充`Handler`的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：
    
    1.  `HttpMessageConveter`： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息
    2.  数据转换：对请求消息进行数据转换。如String转换成Integer、Double等
    3.  数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等
    4.  数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中
7.  `Handler`执行完成后，向`DispatcherServlet` 返回一个`ModelAndView`对象。
    
8.  此时将开始执行**拦截器的`postHandle(...)`方法**【逆向】。
    
9.  根据返回的`ModelAndView`（此时会判断是否存在异常：如果存在异常，则执行`HandlerExceptionResolver`进行异常处理）选择一个适合的`ViewResolver`进行视图解析，根据`Model`和`View`，来渲染视图。
    
10.  渲染视图完毕执行拦截器的`afterCompletion(…)`方法【逆向】。
    
11.  将渲染结果返回给客户端。
    

十四、乱码问题
=======

1.  > 传统Servlet使用过滤器实现
    
2.  > 使用SpringMVC提供的过滤器
    
    在web.xml中配置SpringMVC .修改了xml文件重启服务器。
    
        <filter>
           <filter-name>encoding</filter-name>
           <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
           <init-param>
               <param-name>encoding</param-name>
               <param-value>utf-8</param-value>
           </init-param>
        </filter>
        <filter-mapping>
           <filter-name>encoding</filter-name>
           <url-pattern>/*</url-pattern>
        </filter-mapping>
        
    
3.  > 对于一些其他情况，需要修改Tomcat的编码
    
        <Connector URIEncoding="utf-8" port="8080" protocol="HTTP/1.1"
                  connectionTimeout="20000"
                  redirectPort="8443" />
        
    
4.  > 自定义过滤器【来源网上】
    
        import javax.servlet.*;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletRequestWrapper;
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;
        import java.io.UnsupportedEncodingException;
        import java.util.Map;
        
        /**
        * 解决get和post请求 全部乱码的过滤器
        */
        public class GenericEncodingFilter implements Filter {
        
           @Override
           public void destroy() {
          }
        
           @Override
           public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
               //处理response的字符编码
               HttpServletResponse myResponse=(HttpServletResponse) response;
               myResponse.setContentType("text/html;charset=UTF-8");
        
               // 转型为与协议相关对象
               HttpServletRequest httpServletRequest = (HttpServletRequest) request;
               // 对request包装增强
               HttpServletRequest myrequest = new MyRequest(httpServletRequest);
               chain.doFilter(myrequest, response);
          }
        
           @Override
           public void init(FilterConfig filterConfig) throws ServletException {
          }
        
        }
        
        //自定义request对象，HttpServletRequest的包装类
        class MyRequest extends HttpServletRequestWrapper {
        
           private HttpServletRequest request;
           //是否编码的标记
           private boolean hasEncode;
           //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰
           public MyRequest(HttpServletRequest request) {
               super(request);// super必须写
               this.request = request;
          }
        
           // 对需要增强方法 进行覆盖
           @Override
           public Map getParameterMap() {
               // 先获得请求方式
               String method = request.getMethod();
               if (method.equalsIgnoreCase("post")) {
                   // post请求
                   try {
                       // 处理post乱码
                       request.setCharacterEncoding("utf-8");
                       return request.getParameterMap();
                  } catch (UnsupportedEncodingException e) {
                       e.printStackTrace();
                  }
              } else if (method.equalsIgnoreCase("get")) {
                   // get请求
                   Map<String, String[]> parameterMap = request.getParameterMap();
                   if (!hasEncode) { // 确保get手动编码逻辑只运行一次
                       for (String parameterName : parameterMap.keySet()) {
                           String[] values = parameterMap.get(parameterName);
                           if (values != null) {
                               for (int i = 0; i < values.length; i++) {
                                   try {
                                       // 处理get乱码
                                       values[i] = new String(values[i]
                                              .getBytes("ISO-8859-1"), "utf-8");
                                  } catch (UnsupportedEncodingException e) {
                                       e.printStackTrace();
                                  }
                              }
                          }
                      }
                       hasEncode = true;
                  }
                   return parameterMap;
              }
               return super.getParameterMap();
          }
        
           //取一个值
           @Override
           public String getParameter(String name) {
               Map<String, String[]> parameterMap = getParameterMap();
               String[] values = parameterMap.get(name);
               if (values == null) {
                   return null;
              }
               return values[0]; // 取回参数的第一个值
          }
        
           //取所有值
           @Override
           public String[] getParameterValues(String name) {
               Map<String, String[]> parameterMap = getParameterMap();
               String[] values = parameterMap.get(name);
               return values;
          }
        }
        
    
    一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！**然后在web.xml中配置该自定义过滤器即可！**
    

十五、报错解决
=======

1.  > More than one fragment with the name \[spring\_web\] was found. This is not legal with relative ordering. See section \*\*\*
    
    错误原因：两个配置文件的顺序需要指定
    
    解决办法：增加web.xml文件中添加代码