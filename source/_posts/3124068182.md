---
layout: post
title: "大小端存储是什么鬼？"
date: "2022-09-04T18:23:00.435Z"
---
大小端存储是什么鬼？
==========

关于大小端存储的事儿大家也听过不少了，我就再总结一下子，顺便梳理一下分析的思路，感兴趣就一起来聊聊~

_以下内容为本人的著作，如需要转载，请声明原文链接 [微信公众号「englyf」](https://www.cnblogs.com/englyf/p/16656222.html)[https://www.cnblogs.com/englyf/p/16656222.html](https://www.cnblogs.com/englyf/p/16656222.html)_

* * *

大小端存储的划分是为了解决长度大于一个字节的数据类型内容在存储地址上以不同顺序分布的问题。

比如16位的short整形，32位的int整形，64位的long整形，它们在存储地址上，其实最小的划分单位是字节，那么高低位的字节排列在从低到高的存储地址上有什么规定呢？

如果最高位的字节数据存在最低地址上，而次高位的字节数据按次序排列在次低的地址上，那么这种存储方式就叫`大端存储`。

如果最低位的字节数据存在最低地址上，而次低位的字节数据按次序排列在次低的地址上，那么这种存储方式就叫`小端存储`。

那么怎么去判断当前系统属于大端存储还是小端存储呢？

### 判断方法一：利用单字节类型强制转换多字节类型变量获取返回值比较

下面让我们看看实例代码：

    #include <iostream>
    
    using namespace std;
    
    bool IsSystemBigEndianStorage()
    {
        short src = 1;
        char comp = (char)src;
    
        return (comp == 0);
    }
    
    int main()
    {
        bool ret = IsSystemBigEndianStorage();
        if (ret) {
            cout << "big endian" << endl;
        } else {
            cout << "small endian" << endl;
        }
    
        return 0;
    }
    

首先把单字节范围内的数据值（比如1）赋给更大长度的类型（比如2个字节的short）变量`src`，然后利用单字节长度的数据类型（char）强制转换变量`src`，会在内存空间上截取变量`src`对应存储在最低地址的一个字节数据并返回。

    bool IsSystemBigEndianStorage()
    {
        short src = 1;
        char comp = (char)src;
    
        return (comp == 0);
    }
    

可以看到变量src的高位字节数据为0，低位字节数据为1，各不相同。

![](https://img2022.cnblogs.com/blog/2962155/202209/2962155-20220904214310464-958584089.png)

如果`(char)src`的返回值等于0，就表示存储在最低地址的字节数据等于高位字节数据0x00，属于`大端存储`，否则表示属于`小端存储`。

### 判断方法二：利用联合体类型union比较内部的单字节数据

修改一下上面的函数`IsSystemBigEndianStorage`：

    bool IsSystemBigEndianStorage()
    {
        union {
            short a;
            char b;
        } temp;
        temp.a = 1;
    
        return (temp.b == 0);
    }
    

可以看到变量`temp.a`的高位字节数据为0，低位字节数据为1，各不相同。

![](https://img2022.cnblogs.com/blog/2962155/202209/2962155-20220904214349218-368777764.png)

根据内存空间中字节对齐的规律，联合体union类型，各成员变量的起始地址是一样的。即使各成员变量的数据长度不一样也不影响。

也就是说`temp.a`最低地址空间的数据内容就是`temp.b`的数据内容。

![](https://img2022.cnblogs.com/blog/2962155/202209/2962155-20220904214422349-1793884175.png)

如果`temp.b`的值等于0，就表示存储在最低地址的字节数据等于高位字节数据0x00，属于`大端存储`，否则表示属于`小端存储`。

### 关于网络字节顺序

网络中充斥着各种各样的终端设备或者中间代理路由等，数据利用网络进行传输，传输的基本数据单位也是字节，于是多字节类型的数据也会面临大小端的传输顺序定义。

所以，在传输前和传输后的设备怎么同步这个多字节类型数据的存储呢？由传输前后端的设备共同决定吗？

比如两个不同地区的人碰到一起，如果没有约定俗成的共同语言，一样不知如何去交流。

![](https://img2022.cnblogs.com/blog/2962155/202209/2962155-20220904214437100-655253846.png)

在数据成功传送和解读完整前，数据两端的设备不会理解对方的意图，那么就有必要由第三方来统一明确定义传输顺序。

于是，TCP/IP 协议规定了网络传输多字节类型数据时，先传输高位的字节数据，次高位的字节数据在其后接着传输。而数据在被网络接口发送到网络时，需要从内存逐字节读取出来，从低地址往高地址开始发送。那么可见在网络传输中，数据的字节顺序形式是大端存储。

### 本地数据怎么和网络字节顺序转换？

下面针对本地系统为linux举个例子

从本地系统存储顺序转换为网络字节顺序

    uint32_t htonl(uint32_t hostlong);
    uint16_t htons(uint16_t hostshort);
    

从网络字节顺序转换为本地系统存储顺序

    uint32_t ntohl(uint32_t netlong);
    uint16_t ntohs(uint16_t netshort);
    

* * *