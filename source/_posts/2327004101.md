---
layout: post
title: "git版本回退"
date: "2022-10-17T09:34:24.091Z"
---
git版本回退
=======

![git版本回退](https://img2022.cnblogs.com/blog/2521867/202210/2521867-20221017145911764-2104131804.png) 实践中学习进步，git的本地仓库回退和远程仓库回退教程

> 学习git reset之前先了解git的四区五状态

概念
==

一张图理解**四个区**

![](https://img2022.cnblogs.com/blog/2521867/202210/2521867-20221017135218643-1475043397.png)

再是**五个状态**：

*   未修改（Origin）：上次提交后就没改动过
    
*   已修改（Modified）：上次提交后有修改
    
*   已暂存（Staged）：通过git add 追踪了的
    
*   已提交（Committed）：通过git commit 提交到了本地仓库
    
*   已推送（Pushed）：通过git push 推送到了远程仓库
    

本地仓库版本回退
========

    $ git reset [--soft | --mixed | --hard] [HEAD]  #回退，默认为--mixed
    ​
    --soft 、--mixed、--hard就是三个恢复等级。
    ​
    $ git reset --soft HEAD    #回退到指定版本
    $ git reset --soft HEAD~3   # 回退上上上一个版本 
    ​
    $ git reset --hard HEAD~3  # 回退上上上一个版本  
    $ git reset –hard bae128  # 回退到某个版本回退点之前的所有信息。 
    $ git reset --hard origin/master    # 将本地的状态回退到和远程的一样

> 我需求一般都在--hard，就是我从第a个版本开始敲，删了些核心代码写了些鸡肋代码，这个时候就可以 git reset --hard 回退到我上一次提交的版本，也就是第a个版本。这个好理解，但是需要明白三个参数的区别，回退撤销的同时会不会影响本地库的代码，add追踪的代码，追踪前工作区的代码...就需要弄明白几个参数的作用了。

![](https://img2022.cnblogs.com/blog/2521867/202210/2521867-20221017135904010-319306906.jpg)

*   **\--soft**  ，已经add的暂存区以及工作空间的所有东西都不变。  
    PS：`就是撤销我的commit，即未做commit操作`  
    
*   **\--mixed**，默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。  
    PS：已经add的暂存区会丢失掉，工作空间的代码什么的是不变的。我测试过了，就是`仅仅取消追踪，我工作区修改的代码没影响`
    
*   **\--hard**，撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交。 那么一切就全都恢复了，  
    PS：aad的暂存区消失，代码什么的也恢复到以前状态。我测试过了，就是`取消追踪，我工作区修改的恢复到我上一次提交的版本，之前commit提交到本地仓库的也会删掉，换句话说新写的代码等于没写，删了的等于没删`
    

可能需要用到的命令

    $ git log    #查看提交记录，但不能查看已经删除的记录。
    $ git diff   #查看修改过的但未add追踪的文件
    $ git status  #查看add追踪过的文件
    $ git reflog   #可以查看看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录。

远程仓库版本回退
========

> 学习了上边本地库版本回退之后，我就有了我自己的想法思路。
> 
> 主要还是暂时没有碰到类似需求吧，纯当学习了

场景
--

当我commit代码到了本地库，又push到了远程库，不一会我发现刚推送的版本有错误，我需要将远程库回退到上一个版本，怎么办？

![](https://img2022.cnblogs.com/blog/2521867/202210/2521867-20221017140622266-859154463.png)

我的思路
----

先查看一下想要回退的上一个版本的head，然后reset回退指定版本

    $ git reflog
    $ git reset --hard Obfafd

此时本地库落后远程库一次提交，那肯定直接推不过去的，因为提交记录落后，那就强推吧嘻嘻

    $ git commit -mf "强推"

这样远程库就与本地库记录一致，代码一致，我要的效果达到了，但是如果在公司我可能会挨打，因为-f 强推极其不优雅。我这边记录倒是同步了，我这一强推就可能导致了别的小伙伴的本地库超前远程库几次提交。

所有这种方式留给自己的私有仓库用差不多

正确方式
----

> 经过查阅资料，实际测试我又学到了

经过一个测试说明吧

首先早上我推送了一个版本到远程库，晚上发现了一段文字没说明白，因为在中午可能有小伙伴提交过版本，所以我不敢也不能强推

![](https://img2022.cnblogs.com/blog/2521867/202210/2521867-20221017145304740-1075002459.png)

我现在需要将远程库恢复到上一个版本（按理说小伙伴推送过了，我即使恢复到上一个也没用，因为上一个是小伙伴的版本，这个也是被他合并过的，也就是说这个版本我的说明文字还是在，可以多恢复几次，或者指定恢复，这里测试不纠结了），

输入命令`git revert HEAD`  表示回退到上一个版本（会打开vi编辑器输入提交信息），此时虽然代码回退了，但是记录却是向前的，与commit非常相似，所以在之后还需要push提交到远程仓库

![](https://img2022.cnblogs.com/blog/2521867/202210/2521867-20221017145129982-1274061645.png)

当我用revert回退之后，所有人pull之后，他们的代码也自动的回退了。相当于一次补偿提交 然后 git push 到远程仓库，如此一来谁都没影响到，妙啊！！！

再看到远程库的提交记录也可以看到

![](https://img2022.cnblogs.com/blog/2521867/202210/2521867-20221017145545920-1903212305.png)

**总结一下回退远程仓库：**

1.      $ git revert HEAD
        $ git push 
    

**如此两步骤即可，因为大家在push之前都会pull**

😅如有错误敬请斧正，欢迎评论区留言👀