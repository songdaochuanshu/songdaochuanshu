---
layout: post
title: "Spring Iocæºç åˆ†æç³»åˆ—--Beanå®ä¾‹åŒ–è¿‡ç¨‹(ä¸€)"
date: "2022-05-26T17:25:25.668Z"
---
Spring Iocæºç åˆ†æç³»åˆ—--Beanå®ä¾‹åŒ–è¿‡ç¨‹(ä¸€)
==============================

Spring Iocæºç åˆ†æç³»åˆ—--Beanå®ä¾‹åŒ–è¿‡ç¨‹(ä¸€)
==============================

å‰è¨€
--

ä¸Šä¸€ç¯‡æ–‡ç« [Spring Iocæºç åˆ†æç³»åˆ—--Iocå®¹å™¨æ³¨å†ŒBeanPostProcessoråç½®å¤„ç†å™¨ä»¥åŠäº‹ä»¶æ¶ˆæ¯å¤„ç†](https://www.cnblogs.com/codegitz/p/16285975.html)å·²ç»å®Œæˆäº†å¯¹IoCå®¹å™¨å¯åŠ¨æ–¹æ³•ä¹Ÿå°±æ˜¯`refresh()`æ–¹æ³•çš„ç®€å•åˆ†æã€‚ä½†æ˜¯ä¹‹å‰çš„åˆ†æåœ¨å¯¹å®¹å™¨å®ä¾‹åŒ–Beançš„è¿‡ç¨‹çš„ç•¥è¿‡äº†ï¼Œç•™åˆ°äº†è¿™åç»­çš„æ–‡ç« åˆ†æï¼Œæ‰€ä»¥è¿™ç¯‡æ–‡ç« ä¼šå¯¹Beançš„å®ä¾‹åŒ–è¿‡ç¨‹åšä¸€ä¸ªä»‹ç»ã€‚

é¦–å…ˆæ¥ç†ä¸€ä¸‹æœ¬æ–‡çš„æ€è·¯ï¼š**å…³é”®è¯æ˜¯å®ä¾‹åŒ–**ã€‚ç”±äºSpringæ˜¯åˆ©ç”¨åå°„å®ç°çš„å®ä¾‹åŒ–ï¼Œè„‘å­é‡Œå…ˆç®€å•æƒ³ä¸€ä¸‹Javaé‡Œåˆ©ç”¨å‘å°„å®ä¾‹åŒ–ä¸€ä¸ªå¯¹è±¡éœ€è¦å“ªäº›æ­¥éª¤å’Œæ“ä½œã€‚æ¯«æ— ç–‘é—®ï¼Œæˆ‘ä»¬é¦–å…ˆè¦çŸ¥é“å¯¹è±¡çš„`class`ï¼Œæ¥ç€éœ€è¦ç¡®å®šä½¿ç”¨ä»€ä¹ˆæ„é€ å‡½æ•°ä»¥åŠç¡®å®šæ„é€ å‡½æ•°çš„å‚æ•°ç­‰ã€‚åˆ©ç”¨è¿™äº›å·²ç»åŸºæœ¬å¯ä»¥å®ç°ä¸€ä¸ªå¯¹è±¡çš„å®ä¾‹åŒ–ï¼Œå½“ç„¶å®é™…ä¸Šéœ€è¦çš„ä¸œè¥¿å¯èƒ½æ›´å¤šæ›´å¤æ‚ï¼Œè¿™é‡Œåªæ˜¯ä¸¾ä¸ªä¾‹å­ã€‚é‚£ä¹ˆéœ€è¦çš„è¿™äº›ä¿¡æ¯å¯ä»¥å»å“ªé‡Œæå–å‘¢ï¼Ÿå¯¹Springæœ‰äº†è§£çš„å¯èƒ½éƒ½é©¬ä¸Šèƒ½æƒ³åˆ°`BeanDefinition`ï¼Œè¿™æ˜¯ä¸€ä»½åŸæ–™è¡¨ï¼Œé‡Œé¢æœ‰æˆ‘ä»¬æ„é€ ä¸€ä¸ªå®ä¾‹åŒ–å¯¹è±¡æ‰€éœ€çš„æ‰€æœ‰å‚æ•°ã€‚å¦‚æœä¸å¤ªç†è§£è¿™ä¸ªå®šä¹‰ï¼Œå¯ä»¥å‚è€ƒä¸€ä¸‹ä¸Šç¯‡æ–‡ç« çš„ä¾‹å­ã€‚

å¦‚æœä¸æ¸…æ¥šBeanDefinitionæ˜¯ä»å“ªé‡Œæ¥çš„ä»¥åŠä¸æ¸…æ¥šå¦‚ä½•å®šä¹‰çš„ï¼Œå¯ä»¥å‚è€ƒä¹‹å‰çš„æ–‡ç« [Spring Iocæºç åˆ†æç³»åˆ—--Iocæºç å…¥å£åˆ†æ](https://www.cnblogs.com/codegitz/p/16243680.html)çš„å…³é”®å®ç°ç³»åˆ—æ–¹æ³• `loadBeanDefinitions ()`ã€‚è¿™ç¯‡æ–‡ç« è®²è§£æ³¨å†Œçš„æ—¶å€™åªæ˜¯è¯´äº†æ³¨å†Œåˆ°å®¹å™¨é‡Œï¼Œå¹¶æ²¡æœ‰è¯´æ˜å…·ä½“æ˜¯æ³¨å†Œåˆ°äº†å“ªé‡Œï¼Œè¿™é‡Œç‚¹æ˜ä¸€ä¸‹ï¼Œæ‰€è°“è®²`BeanDefinition`æ³¨å†Œåˆ°å®¹å™¨é‡Œï¼Œå°±æ˜¯å°†`BeanDefinition`æ”¾å…¥åˆ°å®¹å™¨çš„ä¸€ä¸ªMapé‡Œï¼Œå…·ä½“æ˜¯æ³¨å†Œåˆ°äº†`DefaultListableBeanFactory`çš„`beanDefinitionMap`å±æ€§é‡Œï¼Œ`beanName`ä¼šä¿å­˜åˆ°`beanDefinitionNames`å±æ€§é‡Œï¼Œè¿™æ˜¯ä¸ª`list`é›†åˆï¼Œé‡Œé¢çš„`beanName`ä¼šä¿æŒæ³¨å†Œæ—¶å€™çš„é¡ºåºã€‚

å®ä¾‹åŒ–çš„å¼€å§‹å°±æ˜¯ä»éå†æ‰€æœ‰çš„`beanName`å¼€å§‹ï¼Œè¯ä¸å¤šè¯´ï¼Œå¼€å§‹åˆ†æå§ã€‚

æºç åˆ†æ
----

### beanå®ä¾‹åŒ–å…¥å£

è¿˜è®°å¾—å®ä¾‹åŒ–å…¥å£çš„æ–¹æ³•åå—ï¼Ÿå›å¿†ä¸€ä¸‹ï¼Œç®—äº†ï¼Œåæ­£ä¹Ÿä¸ä¼šæœ‰äººè®°å¾—ã€‚æ˜¯`beanFactory.preInstantiateSingletons()`ï¼Œå…·ä½“å®ç°æ˜¯åœ¨`DefaultListableBeanFactory`ç±»é‡Œã€‚

è·Ÿè¿›ä»£ç æŸ¥çœ‹ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œè¿™æ®µä»£ç åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç¬¬ä¸€ä¸ªforå¾ªç¯ç”¨äºå…ˆå®ä¾‹åŒ–å¯¹è±¡ï¼Œç¬¬äºŒä¸ªforå¾ªç¯å®Œæˆä¸€äº›å®ä¾‹åŒ–ä¹‹åçš„å›è°ƒæ“ä½œã€‚æˆ‘ä»¬å…ˆæ¥çœ‹ç¬¬ä¸€ä¸ªforå¾ªç¯ï¼Œé¦–å…ˆæ˜¯éå†æ‰€æœ‰çš„`beanNames`è·å–`BeanDefinition`ï¼Œç„¶åæ ¹æ®`å·¥å‚bean`å’Œ`éå·¥å‚bean`è¿›è¡Œç›¸åº”å¤„ç†ï¼Œæœ€åè°ƒç”¨`getBean(beanName)`å®ä¾‹åŒ–å¯¹è±¡ã€‚**æ³¨æ„è¿™é‡Œå®ä¾‹åŒ–çš„æ˜¯éæŠ½è±¡çš„ã€å•ä¾‹çš„å¹¶ä¸”æ˜¯éæ‡’åŠ è½½çš„beanï¼Œè¿™ä¸ªå‰æéå¸¸é‡è¦ã€‚**

    	public void preInstantiateSingletons() throws BeansException {
    		if (logger.isTraceEnabled()) {
    			logger.trace("Pre-instantiating singletons in " + this);
    		}
    
    		// Iterate over a copy to allow for init methods which in turn register new bean definitions.
    		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.
    		// æ‰€æœ‰bdçš„åç§°
    		List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);
    
    		// Trigger initialization of all non-lazy singleton beans...
    		// éå†æ‰€æœ‰bdï¼Œä¸€ä¸ªä¸ªè¿›è¡Œåˆ›å»º
    		for (String beanName : beanNames) {
    			// è·å–åˆ°æŒ‡å®šåç§°å¯¹åº”çš„bd
    			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
    			// å¯¹ä¸æ˜¯å»¶è¿ŸåŠ è½½çš„å•ä¾‹çš„Beanè¿›è¡Œåˆ›å»º
    			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
    				// åˆ¤æ–­æ˜¯å¦æ˜¯ä¸€ä¸ªFactoryBean
    				if (isFactoryBean(beanName)) {
    					// å¦‚æœæ˜¯ä¸€ä¸ªfactoryBeançš„è¯ï¼Œå…ˆåˆ›å»ºè¿™ä¸ªfactoryBeanï¼Œåˆ›å»ºfactoryBeanæ—¶ï¼Œéœ€è¦åœ¨beanNameå‰é¢æ‹¼æ¥ä¸€ä¸ª&ç¬¦å·
    					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
    					if (bean instanceof FactoryBean) {
    						final FactoryBean<?> factory = (FactoryBean<?>) bean;
    						boolean isEagerInit;
    						if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
    							isEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)
    											((SmartFactoryBean<?>) factory)::isEagerInit,
    									getAccessControlContext());
    						}
    						else {
    							// åˆ¤æ–­æ˜¯å¦æ˜¯ä¸€ä¸ªSmartFactoryBeanï¼Œå¹¶ä¸”ä¸æ˜¯æ‡’åŠ è½½çš„ï¼Œå°±æ„å‘³ç€ï¼Œåœ¨åˆ›å»ºäº†è¿™ä¸ªfactoryBeanä¹‹åè¦ç«‹é©¬è°ƒç”¨å®ƒçš„getObjectæ–¹æ³•åˆ›å»ºå¦å¤–ä¸€ä¸ªBean
    							isEagerInit = (factory instanceof SmartFactoryBean &&
    									((SmartFactoryBean<?>) factory).isEagerInit());
    						}
    						if (isEagerInit) {
    							getBean(beanName);
    						}
    					}
    				}
    				else {
    					// ä¸æ˜¯factoryBeançš„è¯ï¼Œæˆ‘ä»¬ç›´æ¥åˆ›å»ºå°±è¡Œäº†
    					getBean(beanName);
    				}
    			}
    		}
    
    		// Trigger post-initialization callback for all applicable beans...
    		// åœ¨åˆ›å»ºäº†æ‰€æœ‰çš„Beanä¹‹åï¼Œéå†ä¸ºæ‰€æœ‰é€‚ç”¨çš„ bean è§¦å‘åˆå§‹åŒ–åå›è°ƒï¼Œä¹Ÿå°±æ˜¯è¿™é‡Œä¼šå¯¹å»¶è¿Ÿåˆå§‹åŒ–çš„beanè¿›è¡ŒåŠ è½½...
    		for (String beanName : beanNames) {
    			// è¿™ä¸€æ­¥å…¶å®æ˜¯ä»ç¼“å­˜ä¸­è·å–å¯¹åº”çš„åˆ›å»ºçš„Beanï¼Œè¿™é‡Œè·å–åˆ°çš„å¿…å®šæ˜¯å•ä¾‹çš„
    			Object singletonInstance = getSingleton(beanName);
    			// åˆ¤æ–­æ˜¯å¦æ˜¯ä¸€ä¸ªSmartInitializingSingletonï¼Œ
    			// æœ€å…¸å‹çš„å°±æ˜¯æˆ‘ä»¬ä¹‹å‰åˆ†æè¿‡çš„EventListenerMethodProcessorï¼Œ
    			// åœ¨è¿™ä¸€æ­¥å®Œæˆäº†å¯¹å·²ç»åˆ›å»ºå¥½çš„Beançš„è§£æï¼Œä¼šåˆ¤æ–­å…¶æ–¹æ³•ä¸Šæ˜¯å¦æœ‰ @EventListeneræ³¨è§£ï¼Œ
    			// ä¼šå°†è¿™ä¸ªæ³¨è§£æ ‡æ³¨çš„æ–¹æ³•é€šè¿‡EventListenerFactoryè½¬æ¢æˆä¸€ä¸ªäº‹ä»¶ç›‘å¬å™¨å¹¶æ·»åŠ åˆ°ç›‘å¬å™¨çš„é›†åˆä¸­
    			if (singletonInstance instanceof SmartInitializingSingleton) {
    				final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
    				if (System.getSecurityManager() != null) {
    					AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
    						smartSingleton.afterSingletonsInstantiated();
    						return null;
    					}, getAccessControlContext());
    				}
    				else {
    					smartSingleton.afterSingletonsInstantiated();
    				}
    			}
    		}
    	}
    

### è·å–BeanDefinition

é¦–å…ˆè·Ÿè¿›`getMergedLocalBeanDefinition(beanName)`æ–¹æ³•ï¼Œè¿™é‡Œé¦–å…ˆä¼šå°è¯•ä»`mergedBeanDefinitions`é‡Œå»è·å–ï¼Œè¿™ä¸ª`mergedBeanDefinitions`å­˜æ”¾ç€å·²ç»åˆå¹¶è¿‡çš„`BeanDefinition`ï¼Œè·å–ä¸åˆ°å†çœŸæ­£è°ƒç”¨`getMergedBeanDefinition(beanName, getBeanDefinition(beanName))`å»è·å–ã€‚

    	/**
    	 * Return a merged RootBeanDefinition, traversing the parent bean definition
    	 * if the specified bean corresponds to a child bean definition.
    	 *
    	 * è¿”å›ä¸€ä¸ªåˆå¹¶çš„ RootBeanDefinitionï¼Œå¦‚æœæŒ‡å®šçš„ bean å¯¹åº”äºå­ bean å®šä¹‰ï¼Œåˆ™éå†çˆ¶ bean å®šä¹‰ã€‚
    	 *
    	 * @param beanName the name of the bean to retrieve the merged definition for
    	 * @return a (potentially merged) RootBeanDefinition for the given bean
    	 * @throws NoSuchBeanDefinitionException if there is no bean with the given name
    	 * @throws BeanDefinitionStoreException in case of an invalid bean definition
    	 */
    	protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException {
    		// Quick check on the concurrent map first, with minimal locking.
    		// é¦–å…ˆæ£€æŸ¥ mergedBeanDefinitions ï¼Œæœ€å°ç¨‹åº¦å½±å“å¹¶å‘æ€§èƒ½
    		RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);
    		if (mbd != null && !mbd.stale) {
    			return mbd;
    		}
    		return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));
    	}
    

å…ˆçœ‹`getBeanDefinition(beanName)`ï¼Œè¿™ä¸ªæ–¹æ³•å°±æ˜¯ç®€å•çš„å»`beanDefinitionMap`é‡Œè·å–`BeanDefinition`ï¼Œå¦‚æœè·å–ä¸åˆ°ï¼Œå°±æŠ›å‡ºå¼‚å¸¸ã€‚`beanDefinitionMap`å°±æ˜¯ä¸Šé¢è¯´åˆ°çš„`BeanDefinition`å­˜æ”¾çš„åœ°æ–¹ã€‚

    	public BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {
    		BeanDefinition bd = this.beanDefinitionMap.get(beanName);
    		if (bd == null) {
    			if (logger.isTraceEnabled()) {
    				logger.trace("No bean named '" + beanName + "' found in " + this);
    			}
    			throw new NoSuchBeanDefinitionException(beanName);
    		}
    		return bd;
    	}
    

æ¥ä¸‹æ¥å°±è¿›å…¥åˆ°`getMergedBeanDefinition()`æ–¹æ³•è·å–`BeanDefinition`ï¼Œä¸ºå•¥è¦ä»`beanDefinitionMap`è·å–äº†è¿˜è¿›è¡Œä¸€ä¸ªmergedè·å–å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºBeanæœ‰å±‚æ¬¡å…³ç³»ï¼Œå­ç±»éœ€è¦åˆå¹¶çˆ¶ç±»çš„å±æ€§æ–¹æ³•ç­‰ï¼Œæ‰€ä»¥è¦è¿›è¡Œä¸€æ¬¡åˆå¹¶ï¼Œåˆå¹¶å®Œæˆåä¼šæ”¾å…¥åˆ°`mergedBeanDefinitions`é‡Œï¼ŒåŠŸèƒ½å’Œå±æ€§ååŒºåˆ†åº¦è¿˜æ˜¯ååˆ†è´´åˆ‡çš„ğŸ•ã€‚

è·Ÿè¿›æ–¹æ³•ï¼Œä»£ç å·²æ·»åŠ æ³¨é‡Šï¼Œæ¯”è¾ƒç®€å•ï¼Œè·Ÿç€çœ‹çœ‹å°±è¡Œã€‚

    	/**
    	 * Return a RootBeanDefinition for the given top-level bean, by merging with
    	 * the parent if the given bean's definition is a child bean definition.
    	 *
    	 * å¦‚æœç»™å®š bean çš„å®šä¹‰æ˜¯å­ bean å®šä¹‰ï¼Œåˆ™é€šè¿‡ä¸çˆ¶çº§åˆå¹¶è¿”å›ç»™å®šé¡¶çº§ bean çš„ RootBeanDefinitionã€‚
    	 *
    	 * @param beanName the name of the bean definition
    	 * @param bd the original bean definition (Root/ChildBeanDefinition)
    	 * @return a (potentially merged) RootBeanDefinition for the given bean
    	 * @throws BeanDefinitionStoreException in case of an invalid bean definition
    	 */
    	protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)
    			throws BeanDefinitionStoreException {
    
    		return getMergedBeanDefinition(beanName, bd, null);
    	}
    
    	/**
    	 * Return a RootBeanDefinition for the given bean, by merging with the
    	 * parent if the given bean's definition is a child bean definition.
    	 *
    	 * å¦‚æœç»™å®š bean çš„å®šä¹‰æ˜¯å­ bean å®šä¹‰ï¼Œåˆ™é€šè¿‡ä¸çˆ¶åˆå¹¶è¿”å›ç»™å®š bean çš„ RootBeanDefinition
    	 *
    	 * @param beanName the name of the bean definition
    	 * @param bd the original bean definition (Root/ChildBeanDefinition)
    	 * @param containingBd the containing bean definition in case of inner bean,
    	 * or {@code null} in case of a top-level bean
    	 *    å¦‚æœæ˜¯å†…éƒ¨ beanï¼Œåˆ™åŒ…å« bean å®šä¹‰ï¼Œå¦‚æœæ˜¯é¡¶çº§ beanï¼Œåˆ™ä¸º {@code null}
    	 * @return a (potentially merged) RootBeanDefinition for the given bean
    	 * @throws BeanDefinitionStoreException in case of an invalid bean definition
    	 */
    	protected RootBeanDefinition getMergedBeanDefinition(
    			String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)
    			throws BeanDefinitionStoreException {
    
    		synchronized (this.mergedBeanDefinitions) {
    			RootBeanDefinition mbd = null;
    			RootBeanDefinition previous = null;
    
    			// Check with full lock now in order to enforce the same merged instance.
    			// ç°åœ¨æ£€æŸ¥å®Œå…¨é”å®šä»¥å¼ºåˆ¶æ‰§è¡Œç›¸åŒçš„åˆå¹¶å®ä¾‹ã€‚
    			if (containingBd == null) {
    				mbd = this.mergedBeanDefinitions.get(beanName);
    			}
    
    			if (mbd == null || mbd.stale) {
    				previous = mbd;
    				mbd = null;
    				if (bd.getParentName() == null) {
    					// Use copy of given root bean definition.
    					// ä½¿ç”¨ç»™å®šæ ¹ bean å®šä¹‰çš„å‰¯æœ¬ã€‚
    					if (bd instanceof RootBeanDefinition) {
    						mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();
    					}
    					else {
    						mbd = new RootBeanDefinition(bd);
    					}
    				}
    				else {
    					// Child bean definition: needs to be merged with parent.
    					// å­beanå®šä¹‰ï¼šéœ€è¦ä¸çˆ¶åˆå¹¶ã€‚
    					BeanDefinition pbd;
    					try {
    						String parentBeanName = transformedBeanName(bd.getParentName());
    						if (!beanName.equals(parentBeanName)) {
    							pbd = getMergedBeanDefinition(parentBeanName);
    						}
    						else {
    							BeanFactory parent = getParentBeanFactory();
    							if (parent instanceof ConfigurableBeanFactory) {
    								pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);
    							}
    							else {
    								throw new NoSuchBeanDefinitionException(parentBeanName,
    										"Parent name '" + parentBeanName + "' is equal to bean name '" + beanName +
    										"': cannot be resolved without an AbstractBeanFactory parent");
    							}
    						}
    					}
    					catch (NoSuchBeanDefinitionException ex) {
    						throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,
    								"Could not resolve parent bean definition '" + bd.getParentName() + "'", ex);
    					}
    					// Deep copy with overridden values.
    					// å…·æœ‰è¦†ç›–å€¼çš„æ·±æ‹·è´ã€‚
    					mbd = new RootBeanDefinition(pbd);
    					mbd.overrideFrom(bd);
    				}
    
    				// Set default singleton scope, if not configured before.
    				// å¦‚æœä¹‹å‰æœªé…ç½®ï¼Œåˆ™è®¾ç½®é»˜è®¤å•ä¾‹èŒƒå›´ã€‚
    				if (!StringUtils.hasLength(mbd.getScope())) {
    					mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);
    				}
    
    				// A bean contained in a non-singleton bean cannot be a singleton itself.
    				// Let's correct this on the fly here, since this might be the result of
    				// parent-child merging for the outer bean, in which case the original inner bean
    				// definition will not have inherited the merged outer bean's singleton status.
    				// åŒ…å«åœ¨éå•ä¾‹ bean ä¸­çš„ bean æœ¬èº«ä¸èƒ½æ˜¯å•ä¾‹ã€‚
    				// è®©æˆ‘ä»¬åœ¨è¿™é‡Œå³æ—¶çº æ­£è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºè¿™å¯èƒ½æ˜¯å¤–éƒ¨ bean çš„çˆ¶å­åˆå¹¶çš„ç»“æœï¼Œ
    				// åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒåŸå§‹å†…éƒ¨ bean å®šä¹‰å°†ä¸ä¼šç»§æ‰¿åˆå¹¶çš„å¤–éƒ¨ bean çš„å•ä¾‹çŠ¶æ€ã€‚
    				if (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) {
    					mbd.setScope(containingBd.getScope());
    				}
    
    				// Cache the merged bean definition for the time being
    				// (it might still get re-merged later on in order to pick up metadata changes)
    				// æš‚æ—¶ç¼“å­˜åˆå¹¶çš„ bean å®šä¹‰ï¼ˆå®ƒå¯èƒ½ç¨åä»ä¼šé‡æ–°åˆå¹¶ä»¥è·å–å…ƒæ•°æ®æ›´æ”¹ï¼‰
    				if (containingBd == null && isCacheBeanMetadata()) {
    					this.mergedBeanDefinitions.put(beanName, mbd);
    				}
    			}
    			if (previous != null) {
    				copyRelevantMergedBeanDefinitionCaches(previous, mbd);
    			}
    			return mbd;
    		}
    

### åˆ›å»ºBean

è·å–`BeanDefinition`å®Œæˆåï¼Œæ¥ä¸‹æ¥å°±è°ƒç”¨`getBean(beanName)`è¿›è¡Œbeançš„å®ä¾‹åŒ–äº†ã€‚å½“ç„¶è¿™é‡Œçš„åˆ›å»ºè¿˜æ˜¯åˆ†äº†å·¥å‚Beanå’Œéå·¥å‚Beanä¸¤ä¸ªé€»è¾‘ï¼Œå¦‚æœæ˜¯ä¸€ä¸ªå·¥å‚Beanï¼Œé‚£ä¹ˆ`getBean(beanName)`è¿™ä¸€æ­¥åªä¼šåˆ›å»ºä¸€ä¸ªå·¥å‚Beanï¼Œæ¥ä¸‹æ¥ä¼šé€šè¿‡`isEagerInit`å‚æ•°åˆ¤æ–­æ˜¯å¦éœ€è¦åˆå§‹åŒ–å·¥å‚Beançš„å¯¹è±¡ï¼Œå¦‚æœéœ€è¦ï¼Œå†è°ƒç”¨`getBean(beanName)`å»ç«‹é©¬è·å–å·¥å‚Beanéœ€è¦ç”Ÿäº§çš„å¯¹è±¡ã€‚ä¸æ˜¯å·¥å‚Beançš„è¯ï¼Œç›´æ¥ä¸€æ­¥åˆ°ä½åˆ›å»ºå¯¹è±¡äº†ï¼Œå°‘ä¸€åˆ†æ›²æŠ˜ã€‚

è·Ÿè¿›ä»£ç æŸ¥çœ‹ï¼Œå¯ä»¥çœ‹åˆ°çœŸæ­£çš„æ‰§è¡Œä»£ç çš„æ˜¯åœ¨`doGetBean()`æ–¹æ³•é‡Œã€‚è·Ÿè¿›`doGetBean()`æ–¹æ³•ï¼Œå‘ç°ä»£ç éå¸¸çš„é•¿ï¼Œè¿™é‡Œæˆ‘ä¼šæŠŠè¿™ä¸ªæ–¹æ³•åˆ‡åˆ†æˆå‡ å—å»è§£æã€‚

    	public Object getBean(String name) throws BeansException {
    		return doGetBean(name, null, null, false);
    	}
    

ç”±äºä»£ç é‡æ¯”è¾ƒå¤§ï¼Œè¿™é‡Œè´´ä¸€å¼ å›¾ï¼Œå±•ç¤ºå„ä¸ªéƒ¨åˆ†é—´çš„ä½œç”¨ï¼Œç„¶åå¯¹æ¯ä¸ªéƒ¨åˆ†è¿›è¡Œé€æ­¥åˆ†æã€‚

![1653547332139](https://img2022.cnblogs.com/blog/2264262/202205/2264262-20220526181735944-2067895184.png)

çœ‹èµ·æ¥æ˜¯ä¸æ˜¯å¾ˆç®€å•ï¼Œå…¶å®æ¯ä¸€éƒ¨åˆ†éƒ½åŒ…å«äº†å¤§é‡çš„ç»†èŠ‚æ“ä½œï¼Œå…ˆæ¥çœ‹ç¬¬ä¸€æ­¥çš„åç§°è½¬æ¢ï¼Œè¿™ä¸ªæ¯”è¾ƒç®€å•ã€‚

#### åç§°è½¬æ¢

è¿™ä¸€æ­¥å°±æ˜¯æŠŠ`&`å¼€å¤´çš„`name`è½¬æ¢æˆä¸å¸¦`&`çš„`name`ã€‚

    	/**
    	 * Return the bean name, stripping out the factory dereference prefix if necessary,
    	 * and resolving aliases to canonical names.
    	 *
    	 * è¿”å› bean åç§°ï¼Œå¿…è¦æ—¶å»é™¤å·¥å‚å–æ¶ˆå¼•ç”¨å‰ç¼€ï¼Œå¹¶å°†åˆ«åè§£æä¸ºè§„èŒƒåç§°ã€‚
    	 *
    	 * @param name the user-specified name
    	 * @return the transformed bean name
    	 */
    	protected String transformedBeanName(String name) {
    		return canonicalName(BeanFactoryUtils.transformedBeanName(name));
    	}
    

å¯ä»¥çœ‹åˆ°è¿™é‡Œä¼šæœ‰ä¸ªå¾ªç¯å»å¤„ç†ï¼Œå¸¦æœ‰å¤šä¸ª&çš„éƒ½ä¼šè¢«å»æ‰ã€‚

    	/**
    	 * Return the actual bean name, stripping out the factory dereference
    	 * prefix (if any, also stripping repeated factory prefixes if found).
    	 *
    	 * è¿”å›å®é™…çš„ bean åç§°ï¼Œå»é™¤å·¥å‚å–æ¶ˆå¼•ç”¨å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼Œä¹Ÿå»é™¤é‡å¤çš„å·¥å‚å‰ç¼€ï¼Œå¦‚æœæ‰¾åˆ°ï¼‰ã€‚
    	 *
    	 * @param name the name of the bean
    	 * @return the transformed name
    	 * @see BeanFactory#FACTORY_BEAN_PREFIX
    	 */
    	public static String transformedBeanName(String name) {
    		Assert.notNull(name, "'name' must not be null");
    		if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {
    			return name;
    		}
    		return transformedBeanNameCache.computeIfAbsent(name, beanName -> {
    			do {
    				beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());
    			}
    			while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));
    			return beanName;
    		});
    	}
    

ç¡®å®šåç§°ï¼Œä¸€ä¸ªBeanå¯èƒ½ä¼šæœ‰å¾ˆå¤šå§”æ´¾çš„åˆ«åï¼Œè¿™ä¸ªæ—¶å€™éœ€è¦ç¡®å®šæœ€æ ¹æœ¬çš„é‚£ä¸ª`name`ï¼Œç”¨è¿™ä¸ªæœ€æ ¹æœ¬çš„`name`æ¥ä½œä¸º`beanName`å»è¿›è¡Œåç»­çš„æ“ä½œï¼Œè¿™é‡ŒåŒæ ·æœ‰ä¸ªå¾ªç¯å»å¤„ç†ï¼Œå› ä¸ºåˆ«åä¹Ÿä¼šæœ‰å¤šé‡ï¼Œä¼šå­˜åœ¨åˆ«åçš„åˆ«åè¿™ç§æƒ…å†µã€‚

    	/**
    	 * Determine the raw name, resolving aliases to canonical names.
    	 * ç¡®å®šåŸå§‹åç§°ï¼Œå°†åˆ«åè§£æä¸ºè§„èŒƒåç§°ã€‚
    	 * @param name the user-specified name
    	 * @return the transformed name
    	 */
    	public String canonicalName(String name) {
    		String canonicalName = name;
    		// Handle aliasing...
    		// å¤„ç†åˆ«å...
    		String resolvedName;
    		do {
    			// å¯èƒ½ä¼šæœ‰åˆ«åå±‚å±‚åµŒå¥—çš„æƒ…å†µï¼Œæ‰€ä»¥éœ€è¦è·å–åˆ°æœ€ç»ˆçš„åç§°
    			resolvedName = this.aliasMap.get(canonicalName);
    			if (resolvedName != null) {
    				canonicalName = resolvedName;
    			}
    		}
    		while (resolvedName != null);
    		return canonicalName;
    	}
    

#### ä»å®¹å™¨ç¼“å­˜ä¸­è·å–Bean

åœ¨ä¸Šä¸€æ­¥ä¸­æˆ‘ä»¬å·²ç»è·å–åˆ°äº†çœŸæ­£çš„`beanName`ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥ï¼Œå°±å¯ä»¥åˆ©ç”¨è¿™ä¸ª`beanName`åˆ°å®¹å™¨çš„ç¼“å­˜ä¸­å°è¯•è·å–beanï¼Œå¦‚æœä¹‹å‰å·²ç»åˆ›å»ºè¿‡ï¼Œè¿™é‡Œå°±å¯ä»¥ç›´æ¥è·å–åˆ°beanã€‚è¿™é‡Œçš„ç¼“å­˜åŒ…æ‹¬ä¸‰çº§ï¼Œä½†æ˜¯**è¿™ä¸‰çº§ç¼“å­˜å¹¶ä¸æ˜¯åŒ…å«çš„å…³ç³»ï¼Œè€Œæ˜¯ä¸€ç§äº’æ–¥çš„å…³ç³»**ï¼Œä¸€ä¸ªbeanæ— è®ºå¤„äºä½•ç§çŠ¶æ€ï¼Œå®ƒåœ¨åŒä¸€æ—¶åˆ»åªèƒ½å¤„äºæŸä¸ªç¼“å­˜å½“ä¸­ã€‚

è·Ÿè¿›`getSingleton(beanName)`æ–¹æ³•ä»£ç ã€‚

    	public Object getSingleton(String beanName) {
    		return getSingleton(beanName, true);
    	}
    

å¯ä»¥çœ‹åˆ°è¿™é‡Œé»˜è®¤ç»™å¤šäº†ä¸€ä¸ªå‚æ•°ä¸º`true`ï¼Œè¿™å‚æ•°ä¸º`allowEarlyReference`ï¼Œç”¨æ¥æ§åˆ¶æ˜¯å¦å…è®¸å¾ªç¯ä¾èµ–ã€‚æ–¹æ³•ä»£ç æ³¨é‡Šæ¯”è¾ƒè¯¦ç»†ï¼Œå°±æ˜¯é€ä¸ªç¼“å­˜å»è·å–ï¼Œè·Ÿç€çœ‹ä¸€ä¸‹é—®é¢˜ä¸å¤§ã€‚ç¬¬ä¸€æ¬¡è¿›æ¥è‚¯å®šæ˜¯è·å–ä¸åˆ°ä»»ä½•ä¸œè¥¿çš„ï¼Œæ‰€ä»¥è¿™é‡Œä¼šè¿”å›`null`ã€‚

    	/**
    	 * Return the (raw) singleton object registered under the given name.
    	 * <p>Checks already instantiated singletons and also allows for an early
    	 * reference to a currently created singleton (resolving a circular reference).
    	 *
    	 * è¿”å›åœ¨ç»™å®šåç§°ä¸‹æ³¨å†Œçš„ï¼ˆåŸå§‹ï¼‰å•ä¾‹å¯¹è±¡ã€‚
    	 * <p>æ£€æŸ¥å·²ç»å®ä¾‹åŒ–çš„å•ä¾‹ï¼Œå¹¶å…è®¸æå‰å¼•ç”¨å½“å‰åˆ›å»ºçš„å•ä¾‹ï¼ˆè§£å†³å¾ªç¯å¼•ç”¨ï¼‰ã€‚
    	 *
    	 * @param beanName the name of the bean to look for è¦æŸ¥æ‰¾çš„ bean çš„åç§°
    	 * @param allowEarlyReference whether early references should be created or not æ˜¯å¦åº”åˆ›å»ºæ—©æœŸå¼•ç”¨
    	 * @return the registered singleton object, or {@code null} if none found æ³¨å†Œçš„å•ä¾‹å¯¹è±¡ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆ™ä¸º {@code null}
    	 */
    	@Nullable
    	protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    		// æ£€æµ‹ä¸€çº§ç¼“å­˜ä¸­æ˜¯å¦å­˜åœ¨å®ä¾‹
    		Object singletonObject = this.singletonObjects.get(beanName);
    		if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
    			// å¦‚æœä¸ºç©ºï¼Œåˆ™é”å®šå…¨å±€å˜é‡è¿›è¡Œå¤„ç†
    			synchronized (this.singletonObjects) {
    				// ä»äºŒçº§ç¼“å­˜ earlySingletonObjects ä¸­è·å–
    				singletonObject = this.earlySingletonObjects.get(beanName);
    				// äºŒçº§ç¼“å­˜ä¸­æ²¡æœ‰ï¼Œå¹¶ä¸” allowEarlyReference = true å…è®¸æå‰åˆ›å»ºæ—©æœŸå¼•ç”¨ï¼Œåˆ™åˆ°ä¸‰çº§ç¼“å­˜ä¸­è·å–
    				// æ—©æœŸå¼•ç”¨ä¸€èˆ¬æ˜¯ç”¨æ¥æŒ‡å‘éœ€è¦ç»è¿‡ä»£ç†çš„beanæˆ–è€…æ˜¯éœ€è¦å»¶è¿Ÿåˆå§‹åŒ–çš„bean
    				if (singletonObject == null && allowEarlyReference) {
    					// å½“æŸäº›æ–¹æ³•éœ€è¦æå‰åˆå§‹åŒ–çš„æ—¶å€™ï¼Œåˆ™ä¼šè°ƒç”¨addSingletonFactoryæ–¹æ³•
    					// å°†å¯¹åº”çš„objectFactoryåˆå§‹åŒ–ç­–ç•¥å­˜å‚¨åœ¨singletonFactories
    					ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
    					if (singletonFactory != null) {
    						// è¿™é‡Œçš„å®ç°æ˜¯ä¸€ä¸ªlambadaè¡¨è¾¾å¼ï¼Œå…·ä½“çš„å®ç°æœ‰å¾ˆå¤šç§
    						// è°ƒç”¨é¢„å…ˆè®¾å®šçš„getObjectæ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨ä¹‹å‰åŠ å…¥çš„ getEarlyBeanReference()æ–¹æ³•
    						// æ­¤è¡¨è¾¾å¼æ˜¯åœ¨ doCreateBean() æ–¹æ³•ä¸­è°ƒç”¨ addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)) åŠ å…¥çš„
    						singletonObject = singletonFactory.getObject();
    						// å°†beanåŠ å…¥äºŒçº§ç¼“å­˜ä¸­
    						this.earlySingletonObjects.put(beanName, singletonObject);
    						// åŒæ—¶ä»ä¸‰çº§ç¼“å­˜ä¸­å°†beanç§»é™¤ï¼Œä¹Ÿå°±æ˜¯ç§»é™¤ä¸€ä¸ªObjectFactoryï¼Œå¯¹åº”ä¸ºä¸€ä¸ªlambadaè¡¨è¾¾å¼
    						this.singletonFactories.remove(beanName);
    					}
    				}
    			}
    		}
    		return singletonObject;
    	}
    

#### ç¼“å­˜å­˜åœ¨bean

è¿™é‡Œè®²è§£çš„æ˜¯æˆªå›¾çš„ç¬¬ä¸‰éƒ¨åˆ†ï¼Œä»£ç æ˜¯ç¬¬260è¡Œåˆ°276è¡Œå·¦å³ã€‚

    		if (sharedInstance != null && args == null) {
    			// çœç•¥éƒ¨åˆ†æ—¥å¿—...
    			// å¦‚æœç›´æ¥ä»å•ä¾‹æ± ä¸­è·å–åˆ°äº†è¿™ä¸ª bean(sharedInstance),æˆ‘ä»¬èƒ½ç›´æ¥è¿”å›å—ï¼Ÿ
    			// å½“ç„¶ä¸èƒ½ï¼Œå› ä¸ºè·å–åˆ°çš„ Bean å¯èƒ½æ˜¯ä¸€ä¸ª factoryBean,
    			// å¦‚æœæˆ‘ä»¬ä¼ å…¥çš„ name æ˜¯ & + beanName è¿™ç§å½¢å¼çš„è¯ï¼Œ
    			// é‚£æ˜¯å¯ä»¥è¿”å›çš„ï¼Œä½†æ˜¯æˆ‘ä»¬ä¼ å…¥çš„æ›´å¯èƒ½æ˜¯ä¸€ä¸ª beanNameï¼Œ
    			// é‚£ä¹ˆè¿™ä¸ªæ—¶å€™ Spring å°±è¿˜éœ€è¦è°ƒç”¨è¿™ä¸ª sharedInstance çš„ getObject æ–¹æ³•æ¥åˆ›å»ºçœŸæ­£è¢«éœ€è¦çš„ Bean
    			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
    		}
    

å¯ä»¥çœ‹åˆ°ï¼Œå»é™¤æ—¥å¿—åï¼Œåªå‰©ä¸‹ä¸€ä¸ªä¸»è¦çš„æ–¹æ³•ï¼Œè·Ÿè¿›`getObjectForBeanInstance()`ä»£ç æŸ¥çœ‹ã€‚å¯ä»¥çœ‹åˆ°è¿™é‡Œä¼šè¿›è¡Œä¸€äº›ç±»å‹çš„åˆ¤æ–­ï¼Œä¼šå°è¯•ä»ç¼“å­˜è·å–ï¼Œæœ€åä¼šè°ƒç”¨`getObjectFromFactoryBean`æ–¹æ³•ä»`FactoryBean`é‡Œè·å–å®ä¾‹å¯¹è±¡ã€‚

    	/**
    	 * Get the object for the given bean instance, either the bean
    	 * instance itself or its created object in case of a FactoryBean.
    	 *
    	 * è·å–ç»™å®š bean å®ä¾‹çš„å¯¹è±¡ï¼Œbean å®ä¾‹æœ¬èº«æˆ–å…¶åˆ›å»ºçš„å¯¹è±¡ï¼ˆå¦‚æœæ˜¯ FactoryBeanï¼‰ã€‚
    	 *
    	 * @param beanInstance the shared bean instance
    	 * @param name name that may include factory dereference prefix
    	 * @param beanName the canonical bean name
    	 * @param mbd the merged bean definition
    	 * @return the object to expose for the bean
    	 */
    	protected Object getObjectForBeanInstance(
    			Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {
    
    		// Don't let calling code try to dereference the factory if the bean isn't a factory.
    		// å¦‚æœæŒ‡å®šçš„nameæ˜¯å·¥å‚ç›¸å…³ï¼ˆä»¥&ä¸ºå‰ç¼€ï¼‰ä¸” beanInstanceåˆä¸æ˜¯FactoryBeanç±»å‹åˆ™éªŒè¯ä¸é€šè¿‡
    		if (BeanFactoryUtils.isFactoryDereference(name)) {
    			if (beanInstance instanceof NullBean) {
    				return beanInstance;
    			}
    			if (!(beanInstance instanceof FactoryBean)) {
    				throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());
    			}
    			if (mbd != null) {
    				mbd.isFactoryBean = true;
    			}
    			return beanInstance;
    		}
    
    		// Now we have the bean instance, which may be a normal bean or a FactoryBean.
    		// If it's a FactoryBean, we use it to create a bean instance, unless the
    		// caller actually wants a reference to the factory.
    
    		// ç°åœ¨æˆ‘ä»¬æœ‰äº† bean å®ä¾‹ï¼Œå®ƒå¯èƒ½æ˜¯æ™®é€šçš„ bean æˆ– FactoryBeanã€‚
    		// å¦‚æœå®ƒæ˜¯ä¸€ä¸ª FactoryBeanï¼Œæˆ‘ä»¬ä½¿ç”¨å®ƒæ¥åˆ›å»ºä¸€ä¸ª bean å®ä¾‹ï¼Œé™¤éè°ƒç”¨è€…å®é™…ä¸Šæƒ³è¦ä¸€ä¸ªå¯¹å·¥å‚çš„å¼•ç”¨ã€‚
    		// å¦‚æœæ˜¯æ™®é€šbeanï¼Œç›´æ¥è¿”å›äº†
    		if (!(beanInstance instanceof FactoryBean)) {
    			return beanInstance;
    		}
    
    		//åŠ è½½factoryBean
    		Object object = null;
    		if (mbd != null) {
    			mbd.isFactoryBean = true;
    		}
    		else {
    			//å°è¯•ä»ç¼“å­˜ä¸­è·å–
    			object = getCachedObjectForFactoryBean(beanName);
    		}
    		if (object == null) {
    			// Return bean instance from factory.
    			// åˆ°è¿™é‡Œå¯ä»¥ç¡®å®š beanInstance ä¸€å®šæ˜¯ FactoryBean ç±»å‹
    			FactoryBean<?> factory = (FactoryBean<?>) beanInstance;
    			// Caches object obtained from FactoryBean if it is a singleton.
    			// å¦‚æœæ˜¯å•ä¾‹ï¼Œåˆ™ç¼“å­˜ä» FactoryBean è·å¾—çš„å¯¹è±¡ã€‚
    			// containsBeanDefinition æ£€æµ‹ beanDefinitionMap ä¸­ä¹Ÿå°±æ˜¯åœ¨æ‰€æœ‰å·²ç»åŠ è½½çš„ç±»ä¸­æ£€æµ‹æ˜¯å¦å®šä¹‰ beanName
    			if (mbd == null && containsBeanDefinition(beanName)) {
    				// å°†å­˜å‚¨XMLæ–‡ä»¶çš„ GenericBeanDefinition è½¬æ¢ä¸º RootBeanDefinitionï¼Œå¦‚æœæŒ‡å®šçš„ beanName æ˜¯å­ bean çš„è¯
    				// ä¼šåŒæ—¶åˆå¹¶çˆ¶ç±»çš„ç›¸å…³å±æ€§
    				mbd = getMergedLocalBeanDefinition(beanName);
    			}
    			//æ˜¯å¦æ˜¯ç”¨ç”¨æˆ·è‡ªå·±å®šä¹‰çš„è¿˜æ˜¯ç”¨ç¨‹åºæœ¬èº«å®šä¹‰çš„
    			boolean synthetic = (mbd != null && mbd.isSynthetic());
    			object = getObjectFromFactoryBean(factory, beanName, !synthetic);
    		}
    		return object;
    	}
    

è·Ÿè¿›`getObjectFromFactoryBean()`æ–¹æ³•ï¼Œè¯¥æ–¹æ³•é¦–å…ˆä¹Ÿæ˜¯ä»ç¼“å­˜è·å–ï¼Œç„¶åè°ƒç”¨`doGetObjectFromFactoryBean()`çœŸæ­£è·å–beanå¯¹è±¡ï¼Œè¿™é‡Œä¼šåŒºåˆ†å•ä¾‹å’ŒåŸå‹åˆ†åˆ«å»è·å–ï¼Œå•ä¾‹è·å–å®Œæˆåä¼šæ”¾å…¥ç¼“å­˜ï¼ŒåŸå‹åˆ™æ¯æ¬¡éƒ½æ–°å»ºï¼Œæ‰€ä»¥åŸå‹beançš„åˆ›å»ºå‰å‰ååä¼šçœç•¥å¾ˆå¤šæ­¥éª¤ã€‚è·å–å®Œæˆåæ ¹æ®`shouldPostProcess`åˆ¤æ–­æ˜¯å¦éœ€è¦åç½®å¤„ç†ï¼Œä»è€Œæ‰§è¡Œ`BeanPostProcessor#postProcessAfterInitialization()`åç½®å¤„ç†å™¨çš„æ–¹æ³•ï¼Œæœ€åå°†å¯¹è±¡æ”¾å…¥ç¼“å­˜ä¸­ã€‚è¿™äº›å¤„ç†æ€è·¯è·Ÿæˆ‘ä»¬å¹³æ—¶å†™ä¸šåŠ¡ä»£ç çš„æ€è·¯ä¹Ÿæ˜¯éå¸¸ç±»ä¼¼çš„ï¼Œå¯ä»¥äº’ç›¸å€Ÿé‰´ä¸€ä¸‹ã€‚

    	/**
    	 * Obtain an object to expose from the given FactoryBean.
    	 *
    	 * ä»ç»™å®šçš„ FactoryBean ä¸­è·å–è¦å…¬å¼€çš„å¯¹è±¡ã€‚
    	 *
    	 * @param factory the FactoryBean instance
    	 * @param beanName the name of the bean
    	 * @param shouldPostProcess whether the bean is subject to post-processing beanæ˜¯å¦ç»è¿‡åå¤„ç†
    	 * @return the object obtained from the FactoryBean
    	 * @throws BeanCreationException if FactoryBean object creation failed
    	 * @see org.springframework.beans.factory.FactoryBean#getObject()
    	 */
    	protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {
    		//å¦‚æœæ˜¯å•ä¾‹çš„è¯
    		if (factory.isSingleton() && containsSingleton(beanName)) {
    			//åŠ é”ï¼Œä¿è¯å•ä¾‹
    			synchronized (getSingletonMutex()) {
    				//å…ˆä»ç¼“å­˜ä¸­è·å–
    				Object object = this.factoryBeanObjectCache.get(beanName);
    				if (object == null) {
    					//ä»FactoryBeanä¸­è·å–bean
    					object = doGetObjectFromFactoryBean(factory, beanName);
    					// Only post-process and store if not put there already during getObject() call above
    					// (e.g. because of circular reference processing triggered by custom getBean calls)
    					// å¦‚æœåœ¨ä¸Šé¢çš„ getObject() è°ƒç”¨æœŸé—´å°šæœªæ”¾ç½®ï¼Œåˆ™ä»…è¿›è¡Œåå¤„ç†å’Œå­˜å‚¨ï¼ˆä¾‹å¦‚ï¼Œç”±äºè‡ªå®šä¹‰ getBean è°ƒç”¨è§¦å‘çš„å¾ªç¯å¼•ç”¨å¤„ç†ï¼‰
    					Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
    					if (alreadyThere != null) {
    						object = alreadyThere;
    					}
    					else {
    						if (shouldPostProcess) {
    							if (isSingletonCurrentlyInCreation(beanName)) {
    								// Temporarily return non-post-processed object, not storing it yet..
    								// æš‚æ—¶è¿”å›éåå¤„ç†å¯¹è±¡ï¼Œæš‚ä¸å­˜å‚¨..
    								return object;
    							}
    							beforeSingletonCreation(beanName);
    							try {
    								//è°ƒç”¨ObjectFactoryçš„åç½®å¤„ç†å™¨
    								object = postProcessObjectFromFactoryBean(object, beanName);
    							}
    							catch (Throwable ex) {
    								throw new BeanCreationException(beanName,
    										"Post-processing of FactoryBean's singleton object failed", ex);
    							}
    							finally {
    								afterSingletonCreation(beanName);
    							}
    						}
    						if (containsSingleton(beanName)) {
    							this.factoryBeanObjectCache.put(beanName, object);
    						}
    					}
    				}
    				return object;
    			}
    		}
    		else {
    			// ä» FactoryBean è·å–å¯¹è±¡
    			Object object = doGetObjectFromFactoryBean(factory, beanName);
    			if (shouldPostProcess) {
    				try {
    					// åç½®å¤„ç†ä» FactoryBean è·å–çš„å¯¹è±¡
    					object = postProcessObjectFromFactoryBean(object, beanName);
    				}
    				catch (Throwable ex) {
    					throw new BeanCreationException(beanName, "Post-processing of FactoryBean's object failed", ex);
    				}
    			}
    			return object;
    		}
    	}
    

è·Ÿè¿›`doGetObjectFromFactoryBean()`æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å°±æ›´ç®€å•äº†ï¼Œå°±æ˜¯è°ƒç”¨å·¥å‚beançš„`getObject()`æ–¹æ³•è¿”å›beanã€‚

    	/**
    	 * Obtain an object to expose from the given FactoryBean.
    	 *
    	 * ä»ç»™å®šçš„ FactoryBean ä¸­è·å–è¦å…¬å¼€çš„å¯¹è±¡ã€‚
    	 *
    	 * @param factory the FactoryBean instance
    	 * @param beanName the name of the bean
    	 * @return the object obtained from the FactoryBean
    	 * @throws BeanCreationException if FactoryBean object creation failed
    	 * @see org.springframework.beans.factory.FactoryBean#getObject()
    	 */
    	private Object doGetObjectFromFactoryBean(final FactoryBean<?> factory, final String beanName)
    			throws BeanCreationException {
    
    		Object object;
    		try {
    			//éœ€è¦æƒé™æ ¡éªŒ
    			if (System.getSecurityManager() != null) {
    				// çœç•¥éƒ¨åˆ†ä»£ç ...
    			}
    			else {
    				//ç›´æ¥è°ƒç”¨factory.getObject()æ–¹æ³•
    				object = factory.getObject();
    			}
    		}
    		catch (Throwable ex) {
    			// çœç•¥éƒ¨åˆ†å¼‚å¸¸å¤„ç†...
    		}
    
    		// Do not accept a null value for a FactoryBean that's not fully
    		// initialized yet: Many FactoryBeans just return null then.
    		// ä¸è¦ä¸ºå°šæœªå®Œå…¨åˆå§‹åŒ–çš„ FactoryBean æ¥å— null å€¼ï¼šè®¸å¤š FactoryBean åªè¿”å› nullã€‚
    		if (object == null) {
    			if (isSingletonCurrentlyInCreation(beanName)) {
    				throw new BeanCurrentlyInCreationException(
    						beanName, "FactoryBean which is currently in creation returned null from getObject");
    			}
    			object = new NullBean();
    		}
    		return object;
    	}
    

åˆ°è¿™é‡Œï¼Œå›¾ç‰‡ä¸Šçš„ç¬¬ä¸‰éƒ¨åˆ†è¿‡å®Œäº†ã€‚æ¥ä¸‹æ¥æ˜¯ç¬¬å››æ­¥ã€‚

#### çœŸæ­£è¿›å…¥åˆ›å»ºBeançš„æµç¨‹

ç»è¿‡å‰é¢è¿™ä¹ˆå¤šé“ºå«ï¼Œæ‰çœŸæ­£èµ°åˆ°äº†åˆ›å»ºBeançš„åœ°æ–¹ã€‚è¿™é‡Œä¼šæ¯”è¾ƒå¤æ‚ä¸”å•°å—¦ï¼Œéœ€è¦ç‚¹è€å¿ƒçœ‹å®Œã€‚

è¿™éƒ¨åˆ†ä»£ç å¦‚ä¸‹ï¼Œå¯ä»¥è·Ÿç€æ³¨é‡Šçœ‹ä¸‹è¿™æ®µä»£ç ã€‚è¿™é‡Œå…ˆå¯¹åŸå‹ç±»å‹çš„å¾ªç¯ä¾èµ–è¿›è¡Œæ ¡éªŒï¼ŒåŸå‹beanå‡ºç°å¾ªç¯ä¾èµ–ç›´æ¥æŠ›å¼‚å¸¸ã€‚ç„¶åå›å»çˆ¶å®¹å™¨é‡Œè·å–ï¼Œç´§æ¥ç€åˆå¤„ç†äº†è¢«`@DependsOn`æ³¨è§£æ ‡æ³¨çš„ä¾èµ–ï¼Œç„¶åå†è¿›è¡Œbeançš„åˆ›å»ºã€‚

    			// Fail if we're already creating this bean instance:
    			// We're assumably within a circular reference.
    			// åœ¨ç¼“å­˜ä¸­è·å–ä¸åˆ°è¿™ä¸ªBean
    			// åŸå‹ä¸‹çš„å¾ªç¯ä¾èµ–ç›´æ¥æŠ¥é”™
    			if (isPrototypeCurrentlyInCreation(beanName)) {
    				throw new BeanCurrentlyInCreationException(beanName);
    			}
    
    			// Check if bean definition exists in this factory.
    			// æ ¸å¿ƒè¦ä¹‰ï¼Œæ‰¾ä¸åˆ°æˆ‘ä»¬å°±ä»çˆ¶å®¹å™¨ä¸­å†æ‰¾ä¸€æ¬¡
    			// æˆ‘ä»¬ç®€å•çš„ç¤ºä¾‹æ˜¯ä¸ä¼šæœ‰çˆ¶å®¹å™¨å­˜åœ¨çš„ï¼Œè¿™ä¸€å—å¯ä»¥ç†è§£ä¸ºé€’å½’åˆ°çˆ¶å®¹å™¨ä¸­æŸ¥æ‰¾ï¼Œè·Ÿåœ¨å½“å‰å®¹å™¨æŸ¥æ‰¾é€»è¾‘æ˜¯ç±»ä¼¼çš„
    			BeanFactory parentBeanFactory = getParentBeanFactory();
    			if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
    				// Not found -> check parent.
    				// ä»çˆ¶å®¹å™¨è·å–ï¼Œæ ¹æ®ä¸åŒçš„å‚æ•°è°ƒç”¨ä¸åŒçš„æ–¹æ³•
    				String nameToLookup = originalBeanName(name);
    				if (parentBeanFactory instanceof AbstractBeanFactory) {
    					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
    							nameToLookup, requiredType, args, typeCheckOnly);
    				}
    				else if (args != null) {
    					// Delegation to parent with explicit args.
    					return (T) parentBeanFactory.getBean(nameToLookup, args);
    				}
    				else if (requiredType != null) {
    					// No args -> delegate to standard getBean method.
    					return parentBeanFactory.getBean(nameToLookup, requiredType);
    				}
    				else {
    					return (T) parentBeanFactory.getBean(nameToLookup);
    				}
    			}
    
    			// å¦‚æœä¸ä»…ä»…æ˜¯ä¸ºäº†ç±»å‹æ¨æ–­ï¼Œä¹Ÿå°±æ˜¯ä»£è¡¨æˆ‘ä»¬è¦å¯¹è¿›è¡Œå®ä¾‹åŒ–
    			// é‚£ä¹ˆå°±å°†beanæ ‡è®°ä¸ºæ­£åœ¨åˆ›å»ºä¸­ï¼Œå…¶å®å°±æ˜¯å°†è¿™ä¸ªbeanNameæ”¾å…¥åˆ°alreadyCreatedè¿™ä¸ªseté›†åˆä¸­
    			if (!typeCheckOnly) {
    				markBeanAsCreated(beanName);
    			}
    
    			try {
    				// ä¸ºä»€ä¹ˆè¿™é‡Œéœ€è¦å†è·å–ä¸€æ¬¡ï¼Œå› ä¸ºç»è¿‡ä¹‹å‰çš„æ“ä½œï¼ŒRootBeanDefinition å¯èƒ½å·²ç»å‘ç”Ÿäº†æ”¹å˜ï¼Œ
    				// å…¶ä¸­çš„ stale å±æ€§å¯èƒ½å·²ç»è®¾ä¸º trueï¼Œè¿™æ—¶éœ€è¦å»å®¹å™¨é‡Œé‡æ–°è·å–ï¼Œè€Œä¸æ˜¯ç›´æ¥ä»ç¼“å­˜ä¸­è¿”å›
    				// ä¾‹å¦‚ä¸Šé¢çš„ markBeanAsCreated() æ–¹æ³•å°±ä¼šä¿®æ”¹ stale å±æ€§
    				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
    				// æ£€æŸ¥åˆå¹¶åçš„bdæ˜¯å¦æ˜¯abstract,è¿™ä¸ªæ£€æŸ¥ç°åœ¨å·²ç»æ²¡æœ‰ä½œç”¨äº†ï¼Œå¿…å®šä¼šé€šè¿‡
    				checkMergedBeanDefinition(mbd, beanName, args);
    
    				// Guarantee initialization of beans that the current bean depends on.
    				// @DependsOnæ³¨è§£æ ‡æ³¨çš„å½“å‰è¿™ä¸ªBeanæ‰€ä¾èµ–çš„beanåç§°çš„é›†åˆï¼Œ
    				// å°±æ˜¯è¯´åœ¨åˆ›å»ºå½“å‰è¿™ä¸ªBeanå‰ï¼Œå¿…é¡»è¦å…ˆå°†å…¶ä¾èµ–çš„Beanå…ˆå®Œæˆåˆ›å»º
    				String[] dependsOn = mbd.getDependsOn();
    				if (dependsOn != null) {
    					// éå†æ‰€æœ‰ç”³æ˜çš„ä¾èµ–
    					for (String dep : dependsOn) {
    						// å¦‚æœè¿™ä¸ªbeanæ‰€ä¾èµ–çš„beanåˆä¾èµ–äº†å½“å‰è¿™ä¸ªbean,å‡ºç°äº†å¾ªç¯ä¾èµ–ï¼Œç›´æ¥æŠ¥é”™
    						if (isDependent(beanName, dep)) {
    							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
    									"Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
    						}
    						// æ³¨å†Œbeanè·Ÿå…¶ä¾èµ–çš„ä¾èµ–å…³ç³»ï¼Œkeyä¸ºä¾èµ–ï¼Œvalueä¸ºä¾èµ–æ‰€ä»å±çš„bean
    						registerDependentBean(dep, beanName);
    						try {
    							// å…ˆåˆ›å»ºå…¶ä¾èµ–çš„Bean
    							getBean(dep);
    						}
    						catch (NoSuchBeanDefinitionException ex) {
    							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
    									"'" + beanName + "' depends on missing bean '" + dep + "'", ex);
    						}
    					}
    				}
    
    				// Create bean instance.åˆ›å»ºbeanå®ä¾‹
    				// æˆ‘ä»¬ç›®å‰åªåˆ†æå•ä¾‹çš„åˆ›å»ºï¼Œå•ä¾‹çœ‹æ‡‚äº†ï¼ŒåŸå‹è‡ªç„¶å°±æ‡‚äº†
    				if (mbd.isSingleton()) {
    					// è¿™é‡Œå†æ¬¡è°ƒç”¨äº† getSingleton() æ–¹æ³•ï¼Œ
    					// è¿™é‡Œè·Ÿæ–¹æ³•å¼€å¤´è°ƒç”¨çš„ getSingleton() çš„åŒºåˆ«åœ¨äºï¼Œ
    					// è¿™ä¸ªæ–¹æ³•å¤šä¼ å…¥äº†ä¸€ä¸ª ObjectFactory ç±»å‹çš„å‚æ•°ï¼Œ
    					// è¿™ä¸ª ObjectFactory ä¼šè¿”å›ä¸€ä¸ª Bean
    					sharedInstance = getSingleton(beanName, () -> {
    						try {
    							return createBean(beanName, mbd, args);
    						}
    						catch (BeansException ex) {
    							// Explicitly remove instance from singleton cache: It might have been put there
    							// eagerly by the creation process, to allow for circular reference resolution.
    							// Also remove any beans that received a temporary reference to the bean.
    							// ä»å•ä¾‹ç¼“å­˜ä¸­æ˜¾å¼åˆ é™¤å®ä¾‹ï¼šå®ƒå¯èƒ½å·²è¢«åˆ›å»ºè¿‡ç¨‹æå‰åœ°æ”¾åœ¨é‚£é‡Œï¼Œä»¥å…è®¸å¾ªç¯å¼•ç”¨è§£æã€‚
    							// è¿˜è¦åˆ é™¤ä»»ä½•æ¥æ”¶åˆ°å¯¹ bean çš„ä¸´æ—¶å¼•ç”¨çš„ beanã€‚
    							destroySingleton(beanName);
    							throw ex;
    						}
    					});
    					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
    				}
    
    				else if (mbd.isPrototype()) {
    					// It's a prototype -> create a new instance.
    					Object prototypeInstance = null;
    					try {
    						beforePrototypeCreation(beanName);
    						prototypeInstance = createBean(beanName, mbd, args);
    					}
    					finally {
    						afterPrototypeCreation(beanName);
    					}
    					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
    				}
    
    				else {
    					String scopeName = mbd.getScope();
    					final Scope scope = this.scopes.get(scopeName);
    					if (scope == null) {
    						throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
    					}
    					try {
    						Object scopedInstance = scope.get(beanName, () -> {
    							beforePrototypeCreation(beanName);
    							try {
    								return createBean(beanName, mbd, args);
    							}
    							finally {
    								afterPrototypeCreation(beanName);
    							}
    						});
    						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
    					}
    					catch (IllegalStateException ex) {
    						// çœç•¥éƒ¨åˆ†å¼‚å¸¸å¤„ç†...
    					}
    				}
    			}
    			catch (BeansException ex) {
    				cleanupAfterBeanCreationFailure(beanName);
    				throw ex;
    			}
    

å…¶å®å»æ‰éƒ¨åˆ†æ ¡éªŒï¼Œå»æ‰éƒ¨åˆ†å¤æ‚åœºæ™¯ä¸‹æ‰ä¼šæœ‰çš„é€»è¾‘ï¼Œæ ¸å¿ƒä»£ç å°±æ˜¯`getSingleton(String beanName, ObjectFactory<?> singletonFactory)` æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯ä¸æ˜¯æœ‰ç‚¹çœ¼ç†Ÿï¼Œ`getSingleton()`æœ‰ä¸‰ä¸ªåŒåçš„é‡è½½æ–¹æ³•ã€‚å‰ä¸¤ä¸ªä¸Šé¢å·²ç»è§è¿‡ï¼Œè¿™é‡Œæ˜¯ç¬¬ä¸‰ä¸ªã€‚

![1653556824388](https://img2022.cnblogs.com/blog/2264262/202205/2264262-20220526181815112-1835051849.png)

ä»”ç»†çœ‹è¿™æ®µä»£ç ï¼Œ`singletonFactory`éƒ¨åˆ†ä¼ å…¥çš„æ˜¯ä¸ª`lambada`è¡¨è¾¾å¼ï¼Œé‡Œé¢æ˜¯æ­£å¸¸åˆ›å»ºbeançš„`createBean()`æ–¹æ³•ã€‚

    sharedInstance = getSingleton(beanName, () -> {
    						try {
    							return createBean(beanName, mbd, args);
    						}
    						catch (BeansException ex) {
    							// çœç•¥éƒ¨åˆ†å¼‚å¸¸å¤„ç†...
    						}
    					});
    

ç»“åˆ`getSingleton()`æ–¹æ³•æŸ¥çœ‹ï¼Œè¯¥æ–¹æ³•å¤„ç†ä¸€äº›å‰ç½®åˆ¤æ–­å’Œåç½®å¤„ç†åï¼Œæ ¸å¿ƒçš„ä»£ç å°±æ˜¯`singletonFactory.getObject()`æ–¹æ³•ï¼Œè¿™é‡Œæ‰§è¡Œçš„å°±æ˜¯ä¸Šé¢ä¼ å…¥çš„`lambada`è¡¨è¾¾å¼ï¼Œä¹Ÿå°±æ˜¯ä¼šæ‰§è¡Œåˆ°`createBean(beanName, mbd, args)`æ–¹æ³•ã€‚`createBean(beanName, mbd, args)`åˆæ˜¯ä¸€ä¸ªå¾ˆæ›²æŠ˜çš„æ–¹æ³•ï¼Œç®€ç›´æ˜¯æ›²æŠ˜ä»–å¦ˆç»™æ›²æŠ˜å¼€é—¨ï¼Œæ›²æŠ˜åˆ°å®¶äº†ã€‚æ‰€ä»¥æˆ‘æ‰“ç®—ä¸‹ä¸€ç¯‡Spring Iocæºç åˆ†æç³»åˆ—--Beanå®ä¾‹åŒ–è¿‡ç¨‹(äºŒ)è¯´ã€‚åœ¨åˆ›å»ºå®Œæˆåï¼Œä¼šæŠŠbeanæ”¾å…¥å•ä¾‹ç¼“å­˜`singletonObjects`ä¸­ã€‚

    	/**
    	 * Return the (raw) singleton object registered under the given name,
    	 * creating and registering a new one if none registered yet.
    	 *
    	 * è¿”å›ä»¥ç»™å®šåç§°æ³¨å†Œçš„ï¼ˆåŸå§‹ï¼‰å•ä¾‹å¯¹è±¡ï¼Œå¦‚æœå°šæœªæ³¨å†Œï¼Œåˆ™åˆ›å»ºå¹¶æ³¨å†Œä¸€ä¸ªæ–°å¯¹è±¡ã€‚
    	 *
    	 * @param beanName the name of the bean
    	 * @param singletonFactory the ObjectFactory to lazily create the singleton
    	 * with, if necessary
    	 * @return the registered singleton object
    	 */
    	public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
    		Assert.notNull(beanName, "Bean name must not be null");
    		synchronized (this.singletonObjects) {
    			// ä»å•ä¾‹æ± ä¸­è·å–ï¼Œç¬¬ä¸€æ¬¡è¿›æ¥è¿™ä¸ªåœ°æ–¹è‚¯å®šè·å–ä¸åˆ°
    			Object singletonObject = this.singletonObjects.get(beanName);
    			if (singletonObject == null) {
    				// å·¥å‚å·²ç»åœ¨é”€æ¯é˜¶æ®µäº†ï¼Œè¿™ä¸ªæ—¶å€™è¿˜åœ¨åˆ›å»ºBeançš„è¯ï¼Œå°±ç›´æ¥æŠ›å‡ºå¼‚å¸¸
    				if (this.singletonsCurrentlyInDestruction) {
    					// çœç•¥éƒ¨åˆ†æ—¥å¿—åŠå¼‚å¸¸å¤„ç†...
    				}
    				// åœ¨å•ä¾‹åˆ›å»ºå‰ï¼Œè®°å½•ä¸€ä¸‹æ­£åœ¨åˆ›å»ºçš„å•ä¾‹çš„åç§°ï¼Œ
    				// å°±æ˜¯æŠŠbeanNameæ”¾å…¥åˆ°singletonsCurrentlyInCreationè¿™ä¸ªseté›†åˆä¸­å»
    				beforeSingletonCreation(beanName);
    				boolean newSingleton = false;
    				boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
    				if (recordSuppressedExceptions) {
    					this.suppressedExceptions = new LinkedHashSet<>();
    				}
    				try {
    					// è¿™é‡Œè°ƒç”¨äº†singletonFactoryçš„getObjectæ–¹æ³•ï¼Œ
    					// å¯¹åº”çš„å®ç°å°±æ˜¯åœ¨doGetBeanä¸­çš„é‚£ä¸€æ®µlambdaè¡¨è¾¾å¼
    					singletonObject = singletonFactory.getObject();
    					newSingleton = true;
    				}
    				catch (IllegalStateException ex) {
    					// Has the singleton object implicitly appeared in the meantime ->
    					// if yes, proceed with it since the exception indicates that state.
    					// å•ä¾‹å¯¹è±¡æ˜¯å¦åŒæ—¶éšå¼å‡ºç° -> å¦‚æœæ˜¯ï¼Œåˆ™ç»§ç»­æ‰§è¡Œï¼Œå› ä¸ºå¼‚å¸¸æŒ‡ç¤ºè¯¥çŠ¶æ€ã€‚
    					singletonObject = this.singletonObjects.get(beanName);
    					if (singletonObject == null) {
    						throw ex;
    					}
    				}
    				catch (BeanCreationException ex) {
    					// çœç•¥éƒ¨åˆ†å¼‚å¸¸å¤„ç†...
    				}
    				finally {
    					if (recordSuppressedExceptions) {
    						this.suppressedExceptions = null;
    					}
    					// åœ¨å•ä¾‹å®Œæˆåˆ›å»ºåï¼Œå°†beanNameä»singletonsCurrentlyInCreationä¸­ç§»é™¤
    					// æ ‡å¿—ç€è¿™ä¸ªå•ä¾‹å·²ç»å®Œæˆäº†åˆ›å»º
    					afterSingletonCreation(beanName);
    				}
    				if (newSingleton) {
    					// æ·»åŠ åˆ°å•ä¾‹æ± ä¸­
    					addSingleton(beanName, singletonObject);
    				}
    			}
    			return singletonObject;
    		}
    	}
    

#### è¿›è¡Œç±»å‹è½¬æ¢

è¿™é‡Œå·²ç»åˆ†æåˆ°äº†æˆªå›¾çš„ç¬¬äº”éƒ¨åˆ†ï¼Œç”±äºç¬¬å››éƒ¨åˆ†çœŸæ­£åˆ›å»ºbeançš„éƒ¨åˆ†æ”¾åˆ°äº†ä¸‹ä¸€ç¯‡Spring Iocæºç åˆ†æç³»åˆ—--Beanå®ä¾‹åŒ–è¿‡ç¨‹(äºŒ)å»åˆ†æï¼Œæ‰€ä»¥åˆ°è¿™é‡Œçš„æ—¶å€™ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†beançš„åˆ›å»ºï¼Œè¿™ä¸ªæ—¶å€™ï¼Œå¦‚æœæ–¹æ³•ä¼ å…¥çš„`requiredType`ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå°±éœ€è¦è¿›è¡Œç±»å‹è½¬æ¢ï¼Œå¦‚æœè½¬æ¢å¤±è´¥ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ã€‚è½¬æ¢æˆåŠŸåˆ™è¿”å›å½“å‰å®Œæˆç±»å‹è½¬æ¢çš„`convertedBean`ã€‚è‡³æ­¤ï¼Œåˆ›å»ºbeançš„æµç¨‹ç»“æŸï¼Œå·²ç»å¯ä»¥è¿”å›ä¸€ä¸ªå¯ä½¿ç”¨çš„beanï¼Œæ˜¯ä¸æ˜¯è¿˜æ˜¯æŒºç®€å•çš„ã€‚æµç¨‹æ¸…æ™°ã€‚å…³äºSpringçš„ç±»å‹è½¬æ¢å’Œæ ¡éªŒä¹Ÿå¯ä»¥åˆ†ä¸€ç¯‡æ–‡ç« å»åˆ†æ`TypeConverter`å’Œ`ConversionService`åœ¨Springä½“ç³»é‡Œçš„å‰ä¸–ä»Šç”Ÿï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ã€‚

    		// Check if required type matches the type of the actual bean instance.
    		// æ£€æŸ¥æ‰€éœ€ç±»å‹æ˜¯å¦ä¸å®é™… bean å®ä¾‹çš„ç±»å‹åŒ¹é…ã€‚
    		if (requiredType != null && !requiredType.isInstance(bean)) {
    			try {
    				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
    				if (convertedBean == null) {
    					throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
    				}
    				return convertedBean;
    			}
    			catch (TypeMismatchException ex) {
    				if (logger.isTraceEnabled()) {
    					logger.trace("Failed to convert bean '" + name + "' to required type '" +
    							ClassUtils.getQualifiedName(requiredType) + "'", ex);
    				}
    				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
    			}
    		}
    

### å›è°ƒSmartInitializingSingletonå®ç°ç±»

åˆ°è¿™é‡Œå®Œæˆå•ä¾‹beançš„åˆ›å»ºäº†ï¼Œé‚£å°±åˆ°äº†æœ€åä¸€æ­¥äº†ï¼Œå›è°ƒ`SmartInitializingSingleton#afterSingletonsInstantiated()`æ–¹æ³•ï¼Œè¿™é‡Œæ²¡å•¥å¥½è¯´çš„ï¼Œå°±æ˜¯ç¬¬äºŒä¸ªå¾ªç¯å¹²çš„äº‹ã€‚éå†æ‰€æœ‰çš„`beanNames`ï¼Œç„¶åå®Œæˆå›è°ƒã€‚

è¿™é‡Œçš„å›è°ƒæœ‰å¾ˆå¤šå®ç°ç±»ï¼Œæ¯”è¾ƒç»å…¸çš„æ˜¯`EventListenerMethodProcessor`ç±»ï¼Œè¯¥ç±»ä¼šåœ¨è¿™ä¸€æ­¥å®Œæˆäº†å¯¹å·²ç»åˆ›å»ºå¥½çš„Beançš„è§£æï¼Œä¼šåˆ¤æ–­å…¶æ–¹æ³•ä¸Šæ˜¯å¦æœ‰ `@EventListener`æ³¨è§£ï¼Œä¼šå°†è¿™ä¸ªæ³¨è§£æ ‡æ³¨çš„æ–¹æ³•é€šè¿‡`EventListenerFactory`è½¬æ¢æˆä¸€ä¸ªäº‹ä»¶ç›‘å¬å™¨å¹¶æ·»åŠ åˆ°ç›‘å¬å™¨çš„é›†åˆä¸­ã€‚

æ€»ç»“
--

è¿™ç¯‡æ–‡ç« è¿˜æ˜¯æŒ‰ç…§ä¹‹å‰çš„è¡Œæ–‡æ€è·¯ï¼Œåˆ†æå¾—æ¯”è¾ƒæ‰å¹³ï¼Œæ¯ä¸ªæ–¹æ³•éƒ½æ²¡æœ‰ç‰¹åˆ«è¿‡åˆ†çš„æ·±å…¥å»è®²è§£ï¼Œå› ä¸ºé‚£æ ·å¤ªæ·±äº†å¾ˆå¤šäººå—ä¸äº†ï¼Œå®¹æ˜“ç¿»è½¦ã€‚

å›é¡¾ä¸€ä¸‹æœ¬æ–‡çš„æ€è·¯ï¼Œå…ˆæ˜¯é¡ºç€ä¸Šæ–‡çš„å…¥å£ï¼Œå¼€å§‹åˆ†æbeançš„åˆ›å»ºã€‚é¦–å…ˆæ˜¯è·å–BeanDefinitionï¼Œç„¶åæ˜¯è°ƒç”¨`getBean(beanName)`æ–¹æ³•è¿›è¡Œå¯¹è±¡çš„å®ä¾‹åŒ–ã€‚è¯¥æ–¹æ³•ç”±ä¸€ä¸ªæˆªå›¾ï¼Œåˆ†ä¸ºäº†äº”éƒ¨åˆ†å»è§£æã€‚åˆ†ä¸ºäº†å“ªäº”éƒ¨åˆ†è¿˜è®°å¾—å—ï¼Ÿå¿˜è®°äº†ï¼Ÿé‚£ä¸æ€ªä½ ï¼Œæˆ‘çå‡ æŠŠå†™çš„ã€‚

ç¬¬å››æ­¥åˆ›å»ºbeançš„éƒ¨åˆ†æˆ‘ç•™åˆ°äº†ä¸‹ä¸€ç¯‡å»åˆ†æï¼Œè¿™æ ·æ€è·¯åº”è¯¥ä¹Ÿæ¯”è¾ƒæ¸…æ™°ï¼Œä¸ä¼šé‚£ä¹ˆå®¹æ˜“ç¿»è½¦ã€‚

å¦‚æœæœ‰äººçœ‹åˆ°è¿™é‡Œï¼Œé‚£åœ¨è¿™é‡Œè€è¯é‡æã€‚**ä¸å›å…±å‹‰ï¼Œè·¯æ¼«æ¼«å…¶ä¿®è¿œå…®ï¼Œå¾å°†ä¸Šä¸‹è€Œæ±‚ç´¢ã€‚**