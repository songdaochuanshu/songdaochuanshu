---
layout: post
title: "软件项目管理 6.7.参数估算法"
date: "2022-06-07T10:20:38.478Z"
---
软件项目管理 6.7.参数估算法
================

> **【公众号@ “项目管理研究所” 将会第一时间更新文章并分享《行业分析报告》】**  
> `归档于软件项目管理初级学习路线`  
> 第六章 软件项目成本计划  
> [《初级学习路线合集 》](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkwMjM3NjI5MQ==&action=getalbum&album_id=2398183244304416771#wechat_redirect)

* * *

前言
==

大家好，这节我们学习软件项目管理---参数估算法，重点介绍COCOMO模型。

一、参数估算法——定义
-----------

参数估算也称为模型估算，是根据项目数据集合出来的模型，代码行，人数，时间，工时等都是项目数据。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117629-1251509342.png)

所以参数估算模型是通过统计技术得出的数学模型，然后根据这个模型估算软件项目的规模或者成本，参数模型是基于历史项目数据，项目类型不同，项目环境不同，项目数据也就不同，数据不同得出的模型也就不同。

有很多组织根据自己的研究对象得出不同的估算模型。

例如：这些模型的输入是代码行（LOC）

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118142-1992248800.png)

这些模型的输入是功能点（FP）

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118114-1882598577.png)

尽管模型各不相同，但是有基本相似的公式模式，如图所示：

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118004-914351769.png)

接下来我们通过研究2个模型来了解参数模型的思路，既 Walston-Felix模型和COCOMO模型。

二、Walston-Felix模型
-----------------

Walston-Felix模型是1977年，IBM的Walston和Felix根据63套项目数据，回归分析得出的。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117520-265845221.png)

其中E = 5.2 \* 代码行的0.91次幂，表示代码行与工作量的关系。

其中D = 4.1 \* 代码行的0.36次幂， 代表代码行与项目进度的关系。

其中最后一个模型公式，既文档页数 = 49 \* 代码行的1.01次幂 。

便知道我们不能随便照抄别人的模型，因为不同的企业团队要求不同，文档页数肯定也不同，所以应该采用适合自己项目的模型。

下面我们举个例子：某项目采用JAVA语言来完成，估计有366个功能点，根据自己定义的该项目 代码行与功能点的关系。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117454-833645893.png)

既 L（代码行）等于366 \* 46 约等于16.386K代码行，则根据模型估算公式 E（工作量）等于66人月，DOC（文档页数）约等于826页。

三、COCOMO模型
----------

COCOMO模型既结构化成本模型，是目前应用最广泛的参数型软件成本估计模型，最初是由Boehm在1981年提出的，称为COCOMO 81模型。他是通过60多套项目数据分析得出的模型，20世纪90年代中期，随着软件工程技术的发展，又提出了COCOMO II模型。

COCOMO模型基本原理如下图所示：

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118065-1267381599.png)

COCOMO模型分为三个级别：基本COCOMO模型，中等COCOMO模型，高级COCOMO模型。  
级别不同，估算的精度也不同。  
![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118025-180742596.png)  
针对每个级别的模型又分为三个项目类型：既有机型，嵌入式型，半嵌入式型或者叫半有机型。

先介绍COCOMO 81的三个级别模型。

1.  基本COCOMO模型是静态单变量模型，不考虑任何成本驱动，适合在开发的初始阶段，项目的相关信息很少，只适合粗略的技术估算。
2.  中等COCOMO模型是在项目的需求确定以后，对项目有所了解之后使用，在基本模型的基础上通过产品，平台，人员，项目等方面的属性影响因素来调整工作量的估算，估算精度提高了。
3.  高级COCOMO模型是在设计完成后使用，考虑开发不同阶段，影响因素的不同影响，对项目进行精确化的估算，一但软件的各个模块都已经确定，估算者就可以使用高级COOMO模型，所以他的估算精度是最高的。

针对上面的每个模型，将项目分为三种类型，有机型，嵌入式，半嵌入式或者叫半有机型。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117692-1288203016.png)

1.  有机型项目是最常规简单的项目类型，例如各种网站项目，信息化系统等等，相对较小，较简单的软件项目，开发人员对开发项目等目标理解比较充分，与软件系统相关的工作经验比较丰富，对软件的使用环境比较熟悉，受硬件的约束比较小，程序的规模不是很大。
    
2.  嵌入式项目类型，他主要是各类系统程序，例如实时处理。控制系统等等。通常与某种硬件设备紧密结合在一起，对接口，数据结构，算法的要求比较高，软件规模任意，例如航天用的控制系统，大型指挥系统等等。
    
3.  半嵌入式项目类型，他是介于上述两种软件之间，规模和复杂度都属于中等或者更高，例如编译器，连接器，分析器等等。
    

这是基本COCOMO-81模型公式：E=a \* (KLOC)的b次幂。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118027-26003438.png)

a和b的取值与项目类型有关，如下图是不同项目类型的系数表：

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118209-465512397.png)

下面举一个33.3k代码行的软件开发项目例子：最后得出的结果也就是项目规模是152人月。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118177-1016636708.png)

我们再看中等COCOMO-81模型，他是对基本模型的调整，在基本模型的基础上再乘以 乘法因子，乘法因子是根据成本驱动属性得来的，其中a,b才是根据不同项目类型有不同取值。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117520-1375112522.png)

中等COOCMO-81模型关键是乘法因子，它来自于成本驱动属性，分4个大类，分别是产品属性，平台属性，人员属性，过程属性。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118061-1732480354.png)

这四个大类又细分为15个驱动因子，例如产品属性有3个因子，可靠性，信息量，复杂性。每个驱动因子的取值范围有很低，低，正常，高，非常高，极高级别。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118234-1052540819.png)

例如产品复杂性驱动因子很低的取值为0.7，非常高的取值为1.30，既复杂性越高取值越大。

我们再看分析员能力这个驱动因子，非常低是为1.46，非常高是为0.71，既能力越高取值越低 。

乘法因子等于这15个驱动因子取值后相乘，如果大于1说明工作量往高调整，小于1说明工作量往低调整。

我们继续看一个33.3k代码行的软件开发项目例子：采用中等CoCoMo模型计算项目规模，乘法因子根据15个驱动因子取值相乘后得出1.09，代入公式得出项目规模成本为166人月。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118131-1467895518.png)  
对比前面的基本模型，估算值有了一定的调整，因为我们对项目的产品，人员，平台，过程有了更细的了解。

我们再看高级COCOMO模型，他比前面两个模型的精度又提高了，主要体现在两个方面。第一个方面是针对不同的子系统采用的不同的模型估算，另外一方面是针对模型属性进行更加细化的调整。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118200-791169966.png)

15个因子，每个因子在不同的阶段影响不同，取值不同。例如应用经验AEXP这个驱动因子，在开发的不同阶段，其作用是不同的，影响最大的阶段是需求阶段，设计阶段弱化了。

那么针对每个等级，这个驱动因子在不同阶段取值是不同的，例如对于非常低的级别，需求和产品设计阶段的取值为1.40，在详细设计阶段的取值为1.30，编码和测试阶段的取值为1.25，因此提高了估算的精度，但是实践中实施起来会比较麻烦。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117666-790270709.png)

四、COCOMO II
-----------

COCOMO II是95年左右，Ｂoehm在81模型的基础上，结合了软件工程技术的发展提出来的。

COCOMO II模型也分为3个等级，应用组装模型，早期设计模型，后体系结构模型。他们分别适合规划阶段，设计阶段，开发阶段使用。  
![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117696-652201846.png)

应用组装模型适合原型构造或者复用构件组合项目时采用。他基于应用点或者称为对象点 除以一个标准的应用点的生产率，应用点数量的估算可以是显示的屏幕数、网页数、报表数量、程序模块数量等等。

如下图所示 公式为：工作量 = NAP \* （1-复用代码量的百分比）/ PROD

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117767-1229434713.png)

早期设计模型适用于项目的初期，需求已经确定，在系统设计的初始阶段只设计了基本的软件结构，还没有对体系结构进行详细的设计，这一阶段的主要任务是简单、快速的完成一个大概的成本估算。

那么公式如下图所示：其中PM是工作量，A是常数，S是代码行的规模，E是指数比例因子，B可以校准（目前暂定为B=0.91），SF是指数驱动因子。

指数比例因子的效果是对规模较大的项目，预计的工作量将增加，那么EM是工作量系数。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118204-1868828849.png)

因此软件开发工作量需要代码量行数的非线性函数，既基于可用代码行以及5个规模指数因子，7个工作量乘数因子。

计算指数比例因子最重要的依据是驱动因子和工作量系数，5个指数驱动因子属性和取值如表所示：

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118230-552427265.png)

事实上对于一个项目而言，这些属性的缺乏将不成比例的增加更多的工作量，它分为很低、低、正常、高、很高、极高等级别。

早期设计的工作量系数有7个，这些系数可以评定为非常低、很低、低、正常、高、很高、极高等级别。

我们再来看COCOMO II的后体系结构模型，我们看一下公式，那么该模型与早期设计模型基本是一致的，不同之处在于工作量系数不同。

Ｂoehm讲后体系结构模型中的工作量系数化成产品因素，人员因素，项目因素，平台因素四个大类，共17个属性的驱动因子。

与COCOMO-81模型的15个驱动因子相比，COCOMO II模型的后体系结构模型增加了一些软件工程发展中的一些因素，同时也删除了一些因素。  
![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117631-1622915748.png)

复用模型
----

另外，如果需要估计复用代码或者已生成代码所需工作量，可以采用复用模型，公式如下：

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118066-1870020183.png)  
计算出等价代码行（ESLOC）后，ESLOC可以作为代码行的输入，采用早期设计模型或者后体系设计模型来估算工作量。

总结
==

总之 参数模型是根据项目数据进行分析，基本上是进行回归分析，从而得出回归模型作为参数模型。

这个参数模型可以是线性的，也可以是非线性的，相当于是监督学习的回归分析方法，例如线性回归，多项式回归，逻辑回归，神经网络，集成方法等...

例如这是某项目的一些数据：  
![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118024-1077317801.png)  
通过线性回归分析，计算出参数模型，根据这个模型可以进行此类项目的估算。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118140-323619221.png)

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117675-38978277.png)

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118175-1821399318.png)

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118135-1911046878.png)

那么这是另外一类的项目数据，我们采用神经网络算法进行模型估算。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117520-1445397473.png)

这是对项目数据进行数字化和归一化的结果。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118351-1303150644.png)

我们采用三层的BP神经网络建模。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117989-1255795538.png)

通过隐层节点的数目，网络学习率，隐层和输出层激活函数的分析研究，可以确定网络权值和阈值的变化量，从而确认了参数模型。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143117769-41474262.png)

这是模型应用的误差图示，误差率在可以接受的范围之内。

![](https://img2022.cnblogs.com/blog/1683514/202206/1683514-20220607143118045-1286695082.png)

总之参数模型方法需要具有良好的项目数据为基础，存在成熟的项目估算模型。特点是比较简单,而且也比较准确。如果模型选择不当或者数据不准,也会导致偏差。

到这里，第六章 第七节参数估算法就讲解完毕了！下一节介绍专家估算法~

如果您觉得这篇文章有帮助到您的的话不妨点赞支持一下哟~~😉

`后续将持续更新【软件项目管理初级学习路线】的全知识点，大家感兴趣的多多关注博主哟~`  
————————————————