---
layout: post
title: "朴素贝叶斯算法"
date: "2022-04-12T03:00:39.664Z"
---
朴素贝叶斯算法
=======

一、从生活角度来理解朴素贝叶斯算法

朴素贝叶斯算法是统计学味道最浓的一款算法，也是最能体现我们日常生活经验的算法；

与我们读万卷书行万里路形成我们自己的生活经验类似，朴素贝叶斯算法也是基于收集的历史数据分析得到相关事情发生的原因，从而形成解决问题的模型；

与我们面对未知的未来类似，基于自己的生活经验计算各种可能的情况，最终选择一个最大可能的方向进行努力 ，朴素贝叶斯算法也是基于学习的模型计算给定的输入属于各个分类的概率，并选择概率最大的分类作为结果；

从我们出生开始，就在不断的进行学习，通过上学、不同的人生体验、阅读不同类型的书籍来学习；我们把人生的前二十多年全力投入到学习之中，就是要尽最大的可能通过各种方式来丰富自己面对未来不确定性的经验；只不过由于各种客观或者主观条件的限制，我们的内化的经验可能会误差比较大，同时可能也不具有统计性规律；

二、从数学的角度来理解朴素贝叶斯算法

朴素贝叶斯法实现简单，学习与预测的效率都很高，是一种常用的方法；该算法是基于贝叶斯定理和特征条件独立假设的分类算法；该算法首先通过分析训练数据得到先验概率、似然度，从而得到输入输出的联合概率分布；最后基于此训练模型，利用贝叶斯定理计算得到输入的后验概率最大的分类；

联合概率P(X,Y)是通过计算先验概率和条件概率得到的；

朴素贝叶斯法通过训练数据集学习得到先验概率

\\\[P(Y = c\_{k}) , k = 1,2,3,...,K \\\]

条件概率

\\\[P(X = x | Y = c\_{k}) = P(X^{(1)} = x^{(1)},..., X^{(n)} = x^{(n)}| Y = c\_{k}), k = 1,2,3,...,K \\\]

由于算法假设特征条件独立性假设，所以条件概率转化为

\\\[P(X = x | Y = c\_{k}) = P(X^{(1)} = x^{(1)},..., X^{(n)} = x^{(n)}| Y = c\_{k}) = \\prod\_{j=1}^{n} P(X^{(j)} = x^{(j)}| Y = c\_{k}) \\\]

当预测分类的时候，对给定的输入x，通过学习到的模型计算后验概率分布，k|X=x），将后验概率最大的类作为x的类输出。后验概率计算根据贝叶斯定理进行：

\\\[P(Y = c\_{k} | X = x) = \\frac{P(X = x | Y = c\_{k}) P(Y = c\_{k})}{P(X = x)} = \\frac{P(X = x | Y = c\_{k}) P(Y = c\_{k})}{\\sum\_{k} P(X = x|Y = c\_{k})P(Y = c\_{k})} \\\]

由于分母P(X = x)是对整个训练样本进行计算的，所以这里类似一个常数，故可以忽略；同时结合上边特征独立性得到的条件概率，可以得到

\\\[y = \\underset{c\_{k}}{argmax} P(Y = c\_{k}) \\prod\_{j} P(X^{(j)} = x^{(j)} | Y = c\_{k}) \\\]

三、朴素贝叶斯算法分类示例

在Scikit-Learn库中，基于贝叶斯这一大类的算法模型的相关类库都在sklearn.naive\_bayes包之中；

    from sklearn.datasets import load_iris
    from sklearn.naive_bayes import MultinomialNB
    
    X, y = load_iris(return_X_y= True)
    clf = MultinomialNB().fit(X, y)
    r = clf.predict(X)
    print(r)
    s = clf.score(X, y)
    print(s)
    
    
    
    # [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    #  0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 2 1 2 1
    #  1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
    #  2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 2 1 2 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2
    #  2 2]
    # 0.9533333333333334