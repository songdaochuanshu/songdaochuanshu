---
layout: post
title: "并发编程基础底层原理学习（四）"
date: "2022-06-10T19:15:03.352Z"
---
并发编程基础底层原理学习（四）
===============

##### 重排序

在程序执行时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为三种类型。

*   **编译器优化的重排序**。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
*   **指令级并行的重排序**。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
*   **内存系统的重排序**。由于处理器使用缓存和读/写缓冲区，使得加载和存储操作可能是在乱序执行。

重排序可能会导致多线程程序出现内存可见性问题。指令几并行重排序和内存系统重排序属于处理器重排序，对于处理器重排序，JMM会要求Java编译器在生成指令时，插入特定的**内存屏障指令**，通过内存屏障指令来禁止特定类型的处理器重排序。

###### 内存屏障类型

屏障类型

指令示例

说明

LoadLoad Barriers

Load1; LoadLoad; Load2

确保Load1数据的装载先于Load2及所有后续装载指令的装载

Store Store Barriers

Store1; StoreStore;Store2;

确保Store1数据对其他处理器可见先于Store2及所有后续的存储指令的存储

LoadStore Barriers

Store1; StoreLoad; Load2

确保Store1数据装载先于Store2及所有后续的存储指令刷新到内存

StoreLoad Barriers

Store1; StoreLoad; Load2

确保Store1数据对其他处理器变得可见（指刷新到内存）先于Load2及所有后续装载指令的装载。

##### happen-before

从JDK5开始，Java使用JSR-133内存模型，JSR-133使用happen-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happen-before关系。

Happen-before规则如下：

*   程序顺序规则：一个线程中的每个操作，happen-before于该线程中的任意后续操作。
*   监视器锁规则：对一个锁的解锁，happen-before于随后对这个锁的加锁。
*   volatile变量规则：对一个volatile 域的写，happen-before于任意后续对这个volatile域的读
*   传递性：如果A happen-before B，且B happen-before C，那么 A happen-before C。

##### 引发并发安全的三大因素

###### 可见性

可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。

    // 线程1
    int a = 0;
    a = 1;
    // 线程2
    int b = a;
    

假如线程1由cpu1执行，线程2由cpu2执行，当执行a=1时，会把a的初始值0加载到cpu1的高速缓存中，然后赋值为1，此时cpu1高速缓存中a的值变成了1，但是还没有立即刷新到主内存。此时cpu2执行b=a时会从主内存中读取a的值然后加载到cpu2的高速缓存，此时a在主内存的值仍然是0，那么b的值此时为0而不是1。这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。线程1对共享变量a进行修改之后，线程2没有立即看到修改之后a的值，由此引发了可见性的问题。

###### 原子性

原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

###### 有序性

重排序都可能会导致多线程程序出现内存可见性问题