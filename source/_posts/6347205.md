---
layout: post
title: "递归"
date: "2022-04-03T08:20:34.611Z"
---
递归
==

1.  **递归**

无限调用自身这个函数，每次调用总会改动一个关键变量，直到这个关键变量达到边界的时候，不再调用。

递归必须要具备的两个条件

一个是调用自己一个是终止条件 这两个条件必须同时具备，并且一个都不能少。终止条件必须是在递归最开始的地方，也就是下面这样

public void recursion(参数0) {

if (终止条件) {

return;

}

recursion(参数1);

}

不能把终止条件写在递归结束的位置，下面这种写法是错误的

public void recursion(参数0) {  
recursion(参数1);  
if (终止条件) {  
return;  
}  
}  
  
如果这样的话，递归永远退不出来了，就会出现堆栈溢出异常(StackOverflowError)。

但实际上递归可能调用自己不止一次，并且很多递归在调用之前或调用之后都会有一些逻辑上的处理，比如下面这样。

public void recursion(参数0) {  
if (终止条件) {  
return;  
}

可能有一些逻辑运算  
recursion(参数1)  
可能有一些逻辑运算  
recursion(参数2)  
……  
recursion(参数n)  
可能有一些逻辑运算  
}  
————————————————

实例：递归的理解是先往下一层层传递，当碰到终止条件的时候会反弹，最终会反弹到调用处

\[1，1，2，3，5，8，13……\]

我们参照递归的模板来写下，首先终止条件是当n等于1或者2的时候返回1，也就是数列的前两个值是1，代码如下

  
![](https://img2022.cnblogs.com/blog/2777850/202204/2777850-20220403155204691-1335876211.png)

\-----------------------------------------------

乘积

第6-7行是终止条件，第9行是调用自己

 ![](https://img2022.cnblogs.com/blog/2777850/202204/2777850-20220403155349175-1965386322.png)

 n等于5的时候来画个图看一下递归究竟是怎么调用的

![](https://img2022.cnblogs.com/blog/2777850/202204/2777850-20220403155819024-1273697665.png)