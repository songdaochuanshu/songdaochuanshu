---
layout: post
title: "API Schema in kubernetes"
date: "2022-05-18T03:18:40.224Z"
---
API Schema in kubernetes
========================

目录

*   [什么是schema](#什么是schema)
    *   [数据库中的schema](#数据库中的schema)
*   [Kubernetes中的schema](#kubernetes中的schema)
*   [通过示例了解schema](#通过示例了解schema)

什么是schema
---------

schema一词起源于希腊语中的`form`或`figure`，但具体应该如何定义`schema`取决于应用环境的上下文。`schema`有不同的类型，其含义与数据科学、教育、营销和SEO以及心理学等领域密切相关。

> 在维基百科中将schema解释为，**图式**，在心里学中主要描述一种思维或行为类型，用来组织资讯的类别，以及资讯之间的关系。它也可以被描述为先入为主思想的心理结构，表示世界某些观点的框架，或是用于组织和感知新资讯的系统。

但在计算机中的schema其实与这个解释很接近了，从很多地方都可以看到 _schema_ 这个名词，例如 database，openldap，programing language等的。这里可以简单的吧_schema_ 理解为 **元数据集合** （metadata component），主要包含元素及属性的声明，与其他数据结构组成。

### 数据库中的schema

在数据库中，`schema` 就像一个骨架结构，代表整个数据库的逻辑视图。它设计了应用于特定数据库中数据的所有约束。当在数据建模时，就会产生一个schema。在谈到关系数据库\]和面向对象数据库时经常使用schema。有时也指将结构或文本的描述。

数据库中schema描述数据的形状以及它与其他模型、表和库之间的关系。在这种情况下，数据库条目是schema的一个实例，包含schema中描述的所有属性。

数据库schema通常分为两类：定义数据文件实际存储方式的\*\*物理数据库schema **；和**逻辑数据库schema \*\*，它描述了应用于存储数据的所有逻辑约束，包括完整性、表和视图。常见包括

*   星型模式（star schema）
*   雪花模式（snowflake schema）
*   事实星座模型（fact constellation schema 或 galaxy schema）

星型模式是类似于一个简单的数据仓库图，包括一对多的事实表和维度表。它使用非规范化数据。

![](https://img2022.cnblogs.com/blog/1380340/202205/1380340-20220517210818772-251112741.png)

雪花模式是更为复杂的一种流行的数据库模式，在该模式下，维度表是规范化的，可以节省存储空间并最大限度地减少数据冗余。

事实星座模式远比星型模式和雪花模式复杂得多。它拥有多个共享多个维度表的事实表。

![](https://img2022.cnblogs.com/blog/1380340/202205/1380340-20220517210831153-2047917274.png)

Kubernetes中的schema
------------------

通过上面的阐述，大概上可以明白 schema究竟是什么东西了，在Kubernetes中也有schema的概念，通过对kubernetes中资源（GVK）的规范定义、相互关系间的映射等，schema即k8s资源对象元数据。

而kubernetes中资源对象即 `Group` `Version` `Kind` 这些被定义在 `staging/src/k8s.io/api/type.go`中，即平时所操作的yaml文件，例如

    apiVersion: apps/v1
    kind: Deployment  
    metadata:
      name:  ngx
      namespace: default
    spec:
      selector:  
        matchLabels:
          app: ngx
      template:  
        metadata:
          labels:
            app: nginx
        spec:
          containers:
          - name: ngx-schema
            image: nginx
            ports:
            - containerPort: 80
    

![](https://img2022.cnblogs.com/blog/1380340/202205/1380340-20220517210847529-1377371256.png)

而对应的的即为`TypeMeta` 、`ObjectMeta` 和 `DeploymentSpec`,

`TypeMeta` 为 `kind` 与 `apiserver`

`ObjectMeta` 为 `Name` 、`Namespace` `CreationTimestamp`等段。

`DeploymentSpec` 则对应了 yaml 中的 spec。

而整个yaml组成了 一个 k8s的资源对象。

    type Deployment struct {
    	metav1.TypeMeta `json:",inline"`
    	// Standard object metadata.
    	// +optional
    	metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
    
    	// Specification of the desired behavior of the Deployment.
    	// +optional
    	Spec DeploymentSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
    
    	// Most recently observed status of the Deployment.
    	// +optional
    	Status DeploymentStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
    }
    

`register.go` 则是将对应的资源类型注册到schema中的类

    var (
    	// TODO: move SchemeBuilder with zz_generated.deepcopy.go to k8s.io/api.
    	// localSchemeBuilder and AddToScheme will stay in k8s.io/kubernetes.
    	SchemeBuilder      = runtime.NewSchemeBuilder(addKnownTypes)
    	localSchemeBuilder = &SchemeBuilder
    	AddToScheme        = localSchemeBuilder.AddToScheme
    )
    
    // Adds the list of known types to the given scheme.
    func addKnownTypes(scheme *runtime.Scheme) error {
    	scheme.AddKnownTypes(SchemeGroupVersion,
    		&Deployment{},
    		&DeploymentList{},
    		&StatefulSet{},
    		&StatefulSetList{},
    		&DaemonSet{},
    		&DaemonSetList{},
    		&ReplicaSet{},
    		&ReplicaSetList{},
    		&ControllerRevision{},
    		&ControllerRevisionList{},
    	)
    	metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
    	return nil
    }
    

而 `apimachinery` 包则是 schema的实现，通过看其内容可以发下，kubernetes中 schema就是 **GVK** 的属性约束 与 **GVR** 之间的映射。

通过示例了解schema
------------

例如在 `apps/v1/deployment` 这个资源，在代码中表示 `k8s.io/api/apps/v1/types.go` ，如果需要对其资源进行扩展那么需要怎么做？如，建立一个 `StateDeplyment` 资源

    type Deployment struct {
    	metav1.TypeMeta `json:",inline"`
    	// Standard object metadata.
    	// +optional
    	metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
    
    

如上述代码所示，Deployment 中的 `metav1.TypeMeta` 和 `metav1.ObjectMeta`

![](https://img2022.cnblogs.com/blog/1380340/202205/1380340-20220517210903330-1550884347.png)

那么我们复制一个 Deployment 为 StateDeployment，注意，因为 Deployment的两个属性， `metav1.TypeMeta` 和 `metav1.ObjectMeta` 分别实现了不同的方法，如图所示

![](https://img2022.cnblogs.com/blog/1380340/202205/1380340-20220517210910548-243263694.png)

所以在实现方法时，需要实现 `DeepCopyinfo` ， `DeepCopy` 和继承接口 `Object` 的 `DeepCopyObject` 方法

    // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
    func (in *StateDeployment) DeepCopyInto(out *StateDeployment) {
    	*out = *in
    	out.TypeMeta = in.TypeMeta
    	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
    	in.Spec.DeepCopyInto(&out.Spec)
    	in.Status.DeepCopyInto(&out.Status)
    	return
    }
    
    // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StateDeployment.
    func (in *StateDeployment) DeepCopy() *StateDeployment {
    	if in == nil {
    		return nil
    	}
    	out := new(StateDeployment)
    	in.DeepCopyInto(out)
    	return out
    }
    
    // DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
    func (in *StateDeployment) DeepCopyObject() runtime.Object {
    	if c := in.DeepCopy(); c != nil {
    		return c
    	}
    	return nil
    }
    

那么扩展一个资源的整个流为：

*   资源类型在：`k8s.io/api/{Group}/types.go`
*   资料类型的实现接口 `k8s.io/apimachinery/pkg/runtime/interfaces.go.Object`
*   其中是基于 `Deployment` 的类型，`metav1.TypeMeta` 和 `metav1.ObjectMeta`
*   `metav1.TypeMeta` 实现了 `GetObjectKind()` ；`metav1.ObjectMeta` 实现了`DeepCopyinfo=()` ， `DeepCopy()` ，还需要实现 `DeepCopyObject()`
*   最后注册资源到schema中 `k8s.io/api/apps/v1/register.go`

作者：[钢闸门](http://lc161616.cnblogs.com/)  

出处：[http://lc161616.cnblogs.com/](http://lc161616.cnblogs.com/)

本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。

**阿里云优惠：[点击力享低价](https://www.aliyun.com/minisite/goods?userCode=l1acknzz&share_source=copy_link)**

**墨墨学英语：[帮忙点一下](
https://www.maimemo.com/share/page?uid=11934970&pid=f21c0f2a3a395fd55a2ce7619fdc7738&tid=3c095460df2440b7f16205a536893440)**