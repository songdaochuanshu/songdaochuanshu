---
layout: post
title: "重学c#系列——linq(2) [二十八]"
date: "2022-12-15T02:47:57.827Z"
---
重学c#系列——linq(2) \[二十八\]
=======================

### 前言

前文提及到了一些基础的linq的基础，那么这一节是一些补充。

### 正文

关于一个orderby的问题。

比如我们输入两个order by。

![](https://img2023.cnblogs.com/blog/1289794/202212/1289794-20221214232217700-693290123.png)

这里告诉我们多个order by是没有意义的，如果多个那么就是最后一个是有意义的。

这里要使用，不要去记最后一个是有意义的，这会让你的思维混乱，记得用一个orderby就好。用完order by之后就可以用then by了。

这里提及一下原理，前面提及到包装器，为什么生效的是最后一个呢。

![](https://img2023.cnblogs.com/blog/1289794/202212/1289794-20221214233833614-1442859551.png)

通过包装成一个OrderedEnumerable：

![](https://img2023.cnblogs.com/blog/1289794/202212/1289794-20221214233846576-87907648.png)

然后foreach 前文说过其实是调用GetEnumerator：

![](https://img2023.cnblogs.com/blog/1289794/202212/1289794-20221214234014921-1463150762.png)

那么只要最后一个包装才生效。

这里其实是做了优化的，为什么多个order by 只有一个生效，这是符合现实的。

比如一个是前面男生后面女生 ，前面女生后面男生，那么排序只有一个生效，前面的排序都是无效的。

order by之后，要使用then by，这个then by 就是order by排完序之后的排序。

比如order by前面男生后面女生，那么then by 是按照身高进行排序。

那么就是男生从第低到高，女生从低搞到，这样子的排序。

then by 其实也是OrderedEnumerable。

![](https://img2023.cnblogs.com/blog/1289794/202212/1289794-20221214234639380-255381585.png)

CreateOrderedEnumerable 值得看一下:

![](https://img2023.cnblogs.com/blog/1289794/202212/1289794-20221214234726452-954424163.png)

看到这个parent，那么应该想到链式结构。

就是通过这种链式结构，完成了这个order by 和 then by。有兴趣可以看一下。数据结构这不就用上了。

有兴趣可以看下。 原理就是上一个排序的时候，如果相等，那么就交给下一个排序进行比较。

    张三  26  180
    
    李四  25 180
    
    王哥 27 179
    
    张三  17 175
    张三  26  175
    

orderby(name).thenby(age).thenby(high)

比如就是按照name和age 还有high。

那么首先会得到3个数组:

    张三 李四 王哥 张三 张三 
    

    26,25,27,17，26
    

    180，180，179，175，175
    

那么第一个数组会进行快速排序，当张三 0号 张三 3号相等的时候。

那么就会差第二个数组的0号和3号比较，因为26大17，那么17就排在前面。（order 从小到大）

当张三0号和张三4号相等，然后第二个数组的0号和4号也相等，那么就看第三个数组的0号和4号了。

大致就是这个理论了，其实只是做了一次排序。

### 结

下一节为groupjoin和selectmany还有匿名匿名类型linq，下下节为linq表达式。

该系列剩余40余篇，c# IL 阅读在汇编系列之后，为重学c#系列的外篇。