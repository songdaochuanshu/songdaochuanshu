---
layout: post
title: "Simple, Fast Malicious Multiparty Private Set Intersection-解读"
date: "2022-06-03T11:15:09.676Z"
---
Simple, Fast Malicious Multiparty Private Set Intersection-解读
=============================================================

> 文本记录阅读该论文的笔记。

这是文章框架，来自视频。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220601154619843-91718567.png)

介绍
--

本文主要解决恶意攻击下安全的多方PSI，主要用到两大技术OPPRF和OKVS，构造合谋和不合谋的协议。

基础知识
----

### OPPRF

> 这部分在OPRF中有介绍：[OPRF](https://www.cnblogs.com/pam-sh/p/16216240.html "OPRF")

#### PRF

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602132935030-1345490252.png)  
伪随机函数，产生的结果类似于伪随机数。

#### OPRF

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602133220088-1519159997.png)  
不经意的伪随机函数，在两方情况下，\\(P\_2\\)对于\\(P\_1\\)的输出结果是不知道的，\\(P\_1\\)也不知道\\(P\_2\\)的密钥\\(k\\)。

可以根据OPRF构造一个简单的两方PSI协议：  
（1）\\(P\_2\\)将\\(F\_k(x)\\)发送给\\(P\_1\\);  
（2）\\(P\_1\\)将发送来的\\(F\_k(x)\\)和自己的\\(F\_k(y)\\)对比是否一样，如果一样，则说明\\(y\\)属于交集。

#### PPRF

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602133900590-1504772484.png)  
可编程的伪随机函数，即将一组点集\\((x,y)\\)编码到PRF中，输入\\(x\\)，可以得到对应的\\(y\\)。

#### OPPRF

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602134707917-1158208003.png)  
不经意可编程的伪随机函数，在两方情况下，\\(P\_2\\)这边有一组点集\\((a,b)\\)，\\(P\_1\\)输入\\(x\\)，如果\\(x\\)在\\(a\\)中，则返回对应的\\(y\\)，否则返回一个伪随机数。其中\\(P\_2\\)不知道\\(P\_1\\)的输入和输出，\\(P\_1\\)也不知道\\(P\_2\\)的密钥\\(k\\)。

这里的\\(hint\\)可以看作是一个和输入有关系的随机数，在以多项式插值实现的方法中：\\(P\_2\\)将这一组点集插入到一个多项式中\\(f(.)\\)，同时使用\\(hint\\)去“混淆”该多项式（比如，移动等），然后将混淆后的多项式\\(f'(.)\\)发给\\(P\_1\\)，进而获得\\(f'(x)\\)。

### OKVS

#### KVS

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602135745226-2040694723.png)  
键值对存储，可以看成一个数据结构，提供两个算法：  
（1）Encode  
能将一组数据\\((k,v)\\)编码到一个对\\(S\\)象中，以可忽略的概率会出错。  
（2）Decode  
可以根据\\(x\\)和对象\\(S\\)，如果\\((x,y)\\)在对象\\(S\\)中的话，则输出对应的\\(y\\)，否则输出一个随机值。

如果是将一组点\\((x,y)\\)编码到一个多项式\\(f(.)\\)，那么多项式的系数就是\\(S\\)，可以根据\\(S\\)和\\(s\\)，得到\\(f(x)\\)。  
当然实现不会这么简单～

#### OKVS

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602143220088-2068029276.png)  
不经意的键值对存储。对于敌手而言，输出的\\(y\\)值是不可区分的。

#### 区别

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602151338048-252219032.png)  
所以主要还是以OKVS为主设计协议。

### Zero-Sharing

在“Practical multi-party private set intersection from symmetric-key techniques”中也用到过。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602152137769-461661807.png)  
即，能让同一个键对应的值的异或和为0

### ZeroXOR

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220603111128018-897785089.png)  
即，需要输出的是满足条件的键。

方案
--

### 不合谋

#### 三方例子

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602153918002-1564769616.png)  
（1）A拥有密钥\\(k\\)，将\\(k\\)发送给\\(B\\)，\\(B\\)得到\\(PRF\_k(y\_i)\\)，\\(A\\)自己计算出\\(PRF\_k(x\_i)\\)。  
此时三方的数据为：A有\\((x\_i,PRF\_k(x\_i))\\)，B有\\((y\_i,PRF\_k(y\_i))\\)，\\(C\\)有\\((z\_i)\\)  
（2）\\(A\\)将自己的数据通过OKVS编码为对象\\(OKVS(x\_i,PRF\_k(x\_i))\\)，发送给C，如果\\(z\_i=x\_i\\)，则\\(C\\)获得对应的\\(PRF\_k(x\_i))\\)，否则获得随机数（\\(C\\)本身是不知道的）  
（3）然后将\\(A\\)看作是云，\\(B\\)和\\(C\\)将各自结果发给\\(A\\)去比较，如果相同，则表示\\(x\_i=y\_i=z\_i\\)，属于交集，否则不属于交集。

注意：不能直接将\\(B\\)的结果发送给\\(C\\)，因为\\(C\\)方是有对象\\(OKVS(x\_i,PRF\_k(x\_i))\\)，可以无限次数查询，可以“试出”\\(B\\)的\\(y\_i\\)。  
也不能直接将\\(C\\)的结果发送给\\(B\\)，因为\\(B\\)方有密钥\\(k\\)。【大胆一点想，如果A和B之间如果使用OPRF的话，那B就不知道密钥了】

> 该方案不能防止恶意攻击：

**第一种情况：\\(A\\)恶意编码错误**  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602155710482-243751355.png)  
即如果\\(A\\)估计在OKVS时故意编码错误，就会导致PSI出现错误！

解决办法：  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602155905316-634040040.png)  
（1）\\(B\\)的数据\\(PRF\_k(y\_i)\\)拼接上自己的值\\(y\_i\\)；\\(C\\)的数据\\(Decode(z\_i)\\)拼接上自己的值\\(z\_i\\)

这样就能防止恶意的\\(A\\)搞破坏了！

**第二种情况：在比较\\(B\\)和\\(C\\)的结果时，\\(A\\)恶意返回部分部分交集（1）或者恶意返回全集（2）**  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602161107690-739758048.png)

解决办法：  
（1）就是\\(B\\)和\\(C\\)将其结果拷贝\\(\\lambda\\)份并串接，发送给\\(A\\)，如果\\(A\\)搞破坏，返回部分交集，则\\(B\\)和\\(C\\)就知道有问题。【大胆一点，直接将拷贝\\(\\lambda\\)份发过去，判断返回结果是不是\\(\\lambda\\)个交集，是不是也能判断！】  
（2）\\(B\\)和\\(C\\)事先协商出\\(D\_0,D\_1,d\_2\\)，这样\\(A'\\)和\\(A^2\\)肯定有交集，但又不是全集。  
最后对返回结果判断：  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602162337258-748947256.png)

#### 扩展到多方

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602162535191-1253306716.png)  
这里在各方都有了\\(PRF\\)后，需要逐个迭代：\\(B\\)和\\(C\_1\\)的数据在\\(A\\)（云端）对比，将其结果与\\(C\_2\\)的数据在\\(A\\)（云端）对比，直到全部比较完，得到最中的交集元素，如果中间就“断掉”了，说明该元素肯定不是所有方的交集元素。

该方案因为需要迭代逐个对比，所以复杂度很高

下面改进，降低复杂度：  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602165459490-422022290.png)  
（1）\\(P\_1\\)分别给\\(P\_2,...,P\_{n-2}\\)发送密钥\\(k2,...,k\_{n-2}\\)，\\(P\_2,...,P\_{n-2}\\)分别得到\\(PRF\_{k\_2}(y\_2),...,PRF\_{k\_{n-2}}(y\_{n-2})\\)，\\(P\_1\\)也会计算出\\(PRF\_{k\_2}(x),...,PRF\_{k\_{n-2}}(x)\\)。

（2）\\(P\_1\\)将自己的数据\\(PRF\_{k\_2}(x),...,PRF\_{k\_{n-2}}(x)\\)异或得到\\(PRF\_{k\_2}(x)\\bigoplus...\\bigoplus PRF\_{k\_{n-2}}(x)=PRF\\)，然后将其进行OKVS编码得到\\(F=OKVS(x,PRF)\\)，发送给\\(P\_n\\)  
【这里是先异或起来，再执行OKVS；还是先OKVS，再异或起来？】

（3）\\(P\_n\\)根据自己的值\\(z\\)，去解码得到\\(F(z)\\)，若\\(x=z\\)，则\\(F(z)=PRF\_{k\_2}(x)\\bigoplus...\\bigoplus PRF\_{k\_{n-2}}(x)\\)，否则，就是一个不可区分的随机数。

（4）\\(P\_2,...,P\_{n-2}\\)分别将自己的数据\\(PRF\_{k\_2}(y\_2),...,PRF\_{k\_{n-2}}(y\_{n-2})\\)进行OKVS编码为\\(F\_2',...,F\_{n-2}'\\)，再将其异或\\(F\_2'\\bigoplus ...\\bigoplus F\_{n-2}'=F'\\)，发送给\\(P\_{n-1}\\)。

（5）\\(P\_{n-1}\\)使用自己的值\\(y\_{n-1}\\)进行解码，得到\\(F'(y\_{n-1})\\)，若\\(y\_{n-1}=y\_{2}=...=y\_{n-2}\\)，则\\(F'(y\_{n-1})=PRF\_{k\_2}(y\_2)\\bigoplus...\\bigoplus PRF\_{k\_{n-2}}(y\_{n-2})\\)，否则，就是一个不可区分的随机数。

（6）\\(P\_n\\)和\\(P\_{n-1}\\)将各自结果发给\\(P\_1\\)去比较，如果相同，则表示\\(y\_{n-1}=y\_{2}=...=y\_{n-2}=z=x\\)，属于交集，否则不属于交集。

> 以上协议，不抗合谋攻击，并且\\(P\_1\\)拥有全部的密钥\\(k\_i\\)，很不安全。

### 合谋

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220602183315909-1007122846.png)  
这里共有\\(n\\)个参与房，\\(t\\)个合谋方，且满足\\(v=n-t\\)  
（1）\\(P\_1,...,P\_{v-1}\\)方每个都为\\(P\_{v+1},...,P\_{n}\\)生成密钥\\((k\_{1,v+1},...,k\_{1,n}),...,(k\_{v-1,v+1},...,k\_{v-1,n})\\)，并发送出去。

（2）\\(P\_1,...,P\_{v-1}\\)方计算出\\((PRF(x\_1,k\_{1,v+1}),...,PRF(x\_1,k\_{1,n})),...,(PRF(x\_{v-1},k\_{v-1,v+1}),...,PRF(x\_{v-1},k\_{v-1,n}))\\)；\\(P\_{v+1},...,P\_{n}\\)方各自计算出\\((PRF(x\_{v+1},k\_{1,v+1}),...,PRF(x\_{v+1},k\_{v-1,v+1})),...,(PRF(x\_{n},k\_{1,n}),...,PRF(x\_{n},k\_{v-1,n}))\\)，然后每方将自己的数据异或得到\\((x\_{v+1},PRF(x\_{v+1},k\_{1,v+1})\\bigoplus...\\bigoplus PRF(x\_{v+1},k\_{v-1,v+1})),...,(x\_{n},(PRF(x\_{n},k\_{1,n})\\bigoplus...\\bigoplus PRF(x\_{n},k\_{v-1,n}))\\)，然后将所有的PRF值异或\\(PRF(x\_{v+1},k\_{1,v+1})\\bigoplus...\\bigoplus PRF(x\_{v+1},k\_{v-1,v+1})\\bigoplus...\\bigoplus PRF(x\_{n},k\_{1,n})\\bigoplus...\\bigoplus PRF(x\_{n},k\_{v-1,n})\\)

（3）\\(P\_1,...,P\_{v-1}\\)方先将自己的数据异或\\((x\_{1},PRF(x\_1,k\_{1,v+1})\\bigoplus...\\bigoplus PRF(x\_{1},k\_{1,n})),...,(x\_{v-1},PRF(x\_{v-1},k\_{v-1,v+1})\\bigoplus...\\bigoplus PRF(x\_{v-1},k\_{v-1,n}))\\)，再使用OKVS将自己异或后的数据编码\\(F\_1,...,F\_{v-1}\\)，发送给\\(P\_v\\)方

（4）\\(P\_v\\)方用自己的数据\\(x\_v\\)解码得到\\(F\_1(x\_v),...,F\_{v-1}(x\_v)\\)，然后再异或起来得到\\((x\_v,F\_1(x\_v)\\bigoplus...\\bigoplus F\_{v-1}(x\_v))\\),如果\\(x\_v=x\_1=...=x\_{v-1}\\)，则\\((F\_1(x\_v)\\bigoplus...\\bigoplus F\_{v-1}(x\_v))=PRF(x\_1,k\_{1,v+1})\\bigoplus...\\bigoplus PRF(x\_{1},k\_{1,n})\\bigoplus...\\bigoplus PRF(x\_{v-1},k\_{v-1,v+1})\\bigoplus...\\bigoplus PRF(x\_{v-1},k\_{v-1,n})\\)

（5）\\(P\_v\\)和\\(P\_{v+1},...,P\_{n}\\)将各自结果发给\\(P\_1\\)去比较，如果相同，则表示\\(x\_1=...=x\_{v-1}=x\_v=x\_{v+1}=...x\_n\\)，属于交集，否则不属于交集。

上面需要满足一个条件：  
**最后的结果异或起来为0**。

#### 优化

> 加入Zero-XOR，和Zero- Sharing技术。

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220603111734924-1665620624.png)  
各方数据为X\_i=\\((x\_i,y\_i)\\)：  
（1）\\(P\_i\\)方使用Zero- Sharing，对于每一个数据（键）\\(x\_i\\)，生成对应的零分享值\\(s\_i\\)

（2）\\(P\_1,...,P\_{n-1}\\)方和\\(P\_n\\)之间使用OPPRF：\\(P\_i\\)方作为发送者，将零分享值与本身值异或，得到\\((x\_i,s\_i\\bigoplus y\_i)\\)；\\(P\_n\\)作为接收者，输入\\(x\_n\\)，若\\((x\_j,s\_i\\bigoplus y\_i)\\in X\_i\\),得到\\(z\_j=s\_i\\bigoplus y\_i\\)，否则，得到一个伪随机数

（3）\\(P\_n\\)输出\\((x\_n,z\_n=\\bigoplus\_{j\\in \[n-1\]}z\_j)\\)

总结
--

推荐参考
----

（1）知乎的解读：[Simple, Fast Malicious Multiparty Private Set Intersection](https://zhuanlan.zhihu.com/p/499645095 "Simple, Fast Malicious Multiparty Private Set Intersection")  
（2）B站上一位同学的组会视频：[https://www.bilibili.com/video/BV1DL411w7Zk/](https://www.bilibili.com/video/BV1DL411w7Zk/)  
（3）[叮！多方隐私集合求交发来“会议邀请”](https://www.ccvalue.cn/article/1388347.html "叮！多方隐私集合求交发来“会议邀请”")