---
layout: post
title: "C++逆向 可变参数Hook"
date: "2022-04-21T09:19:17.822Z"
---
C++逆向 可变参数Hook
==============

目录

*   [C++逆向 可变参数Hook](#c逆向-可变参数hook)
    *   [0x00 前言：](#0x00-前言)
    *   [0x01 C++可变参数：](#0x01-c可变参数)
        *   [可变参数简介](#可变参数简介)
        *   [可变参数代码实战](#可变参数代码实战)
    *   [0x02 逆向分析C++可变参数原理](#0x02-逆向分析c可变参数原理)
    *   [0x03 printf Hook实战](#0x03-printf-hook实战)
    *   [Pwn菜鸡学习小分队](#pwn菜鸡学习小分队)

C++逆向 可变参数Hook
==============

0x00 前言：
--------

我们在做逆向分析的时候，经常会需要去Hook一个程序的日志输出函数。

而这种日志输出函数一般参数都不确定，这就会引起一个问题。我们如何知道参数个数？如何知道他有哪些参数呢？

0x01 C++可变参数：
-------------

### 可变参数简介

在C++中，可变参数的函数定义可以写成如下格式。用`...`来声明可变参数。

    void test(int a,int b,...)
    {
        //Code...
    }
    

在调用可变参数的函数时，可以在后面不断添加参数，例如。

    test(1,2,3,4,5,"hello","test",6);
    

### 可变参数代码实战

那么回归正题，test函数里如何知道它传进来的后面所有参数个数呢？

这就需要用到`stdarg.h`头文件中的几个关键字了`va_list`、`va_start`、`va_end`。

    #include <stdio.h>
    #include <stdarg.h>
    void test(int a,int b,...)
    {
    	va_list      arg_ptr;//定义可变参数指针
    	va_start(arg_ptr,b); //b为最后一个固定参数
        printf("Address = %p",arg_ptr);//将arg_ptr的地址进行输出。
    	va_end(arg_ptr);     //清空可变参数指针
    }
    int main(int argc,char *argv[])
    {
        test(1,2,3,4,5,"hello","test,6");
    }
    

1.  首先va\_list定义了一个可变参数的指针。
2.  va\_start函数传入，可变参数指针和最后一个固定参数，传出引用可变参数指针。
3.  输出可变参数指针地址。
4.  清空可变参数指针内存空间。

0x02 逆向分析C++可变参数原理
------------------

将上面的代码用VC6编译出来后进行调试分析。

![image-20220421135733283](https://img2022.cnblogs.com/blog/2080041/202204/2080041-20220421143600414-117804361.png)

找到特征。

![image-20220421135827066](https://img2022.cnblogs.com/blog/2080041/202204/2080041-20220421143603187-1057275108.png)

在汇编代码中，定位到main函数。

![image-20220421135910019](https://img2022.cnblogs.com/blog/2080041/202204/2080041-20220421143607091-803020340.png)

接着在汇编处`call va_arg.401005`处下一个断点。可以看到他将参数一个个push到了堆栈中。

![image-20220421140216455](https://img2022.cnblogs.com/blog/2080041/202204/2080041-20220421143609531-852553917.png)

接着按`F7`跟入`test`函数。

通过对汇编代码的分析，我大概知道了`va_start函数()`为什么要将最后一个固定参数传入。因为他需要用最后一个固定参数在堆栈中进行偏移的计算，计算出可变参数的地址。

遍历该堆栈，当遍历到的值是入口点，说明可变参数已经遍历完成。

![image-20220421142455669](https://img2022.cnblogs.com/blog/2080041/202204/2080041-20220421142456877-390085497.png)

![image-20220421142401651](https://img2022.cnblogs.com/blog/2080041/202204/2080041-20220421143614397-1619980678.png)

0x03 printf Hook实战
------------------

这里我随便选了一个系统的可变参数函数，`printf`可以将格式化后的字符串进行输出，符合我们可变参数函数的要求。

![image-20220421143230764](https://img2022.cnblogs.com/blog/2080041/202204/2080041-20220421143617325-658936625.png)

Pwn菜鸡学习小分队
----------

欢迎加入探讨 逆向知识和PWN

![img](https://img2020.cnblogs.com/blog/2080041/202112/2080041-20211210151444680-2028183859.png)

本文来自博客园，作者：VxerLee，转载请注明原文链接：[https://www.cnblogs.com/VxerLee/p/16174029.html](https://www.cnblogs.com/VxerLee/p/16174029.html) 专注逆向、网络安全 ——VxerLee