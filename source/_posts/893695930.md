---
layout: post
title: "HCNP Routing&Switching之组播技术-组播路由协议PIM"
date: "2022-04-02T02:54:35.530Z"
---
HCNP Routing&Switching之组播技术-组播路由协议PIM
=====================================

![HCNP Routing&amp;Switching之组播技术-组播路由协议PIM](https://img2022.cnblogs.com/blog/1503305/202203/1503305-20220331214353594-62446511.png) PIM（Protocol Independent Multicast，翻译成中文就是协议无关组播）；所谓协议无关是指给组播提供路由信息的可以是静态路由、RIP、OSPF、IS-IS、BGP等任何一种单播路由协议；这里的无关是指组播路由与是何种单播路由协议无关；只要通过单播路由能够产生对应组播路由表项即可；之所以PIM高度依赖单播来生成组播路由表项，是因为组播路由是利用单播路由表的路由信息进行组播报文RPF检查，从而来创建组播路由表项，转发组播报文；

　　前文我们了解了组播技术中组播分发树相关话题，回顾请参考[https://www.cnblogs.com/qiuhom-1874/p/16019334.html](https://www.cnblogs.com/qiuhom-1874/p/16019334.html)；今天我们来聊一聊组播路由协议PIM相关话题；组播路由协议和我们前边学习的单播路由协议本质上没有什么不同，不同的是组播路由协议主要生成描述组播数据转发路径，而单播路由协议是用来生成描述单播数据转发路径；

　　组播路由协议PIM

　　PIM（Protocol Independent Multicast，翻译成中文就是协议无关组播）；所谓协议无关是指给组播提供路由信息的可以是静态路由、RIP、OSPF、IS-IS、BGP等任何一种单播路由协议；这里的无关是指组播路由与是何种单播路由协议无关；只要通过单播路由能够产生对应组播路由表项即可；之所以PIM高度依赖单播来生成组播路由表项，是因为组播路由是利用单播路由表的路由信息进行组播报文RPF检查，从而来创建组播路由表项，转发组播报文；

　　组播路由协议概述

　　组播路由协议PIM主要运行在组播路由器之间，负责建立和维护组播路由，建立从组播源到多个接收端的无环转发路径，即分发树；并正确、高效地转发组播数据包；

　　PIM的模式

![](https://img2022.cnblogs.com/blog/1503305/202203/1503305-20220331213800233-858786125.png)

　　提示：PIM有两种模式， 密集模式和稀疏模式；这两种模式分别对应组播的两种类型的分发树，密集模式对应源树，稀疏模式对应共享树；密集模式主要用户规模不大的组播网络环境中，而稀疏模式主要用户大规模组播网络环境中；对于不同模式的PIM，其工作流程各不相同，但最终的目的都是生成传播组播数据的无环路径；

　　PIM-DM工作流程

　　PIM-DM（pim Dense Mode ,协议无关组播-密集模式），该模式使用“推（push）”方式来传送数据，适用于小型网络，组播组成员相对比较密集；

　　PIM-DM的工作流程主要经过邻居发现、扩散、剪枝、状态刷新、嫁接、Assert断言机制；

　　1、邻居发现

![](https://img2022.cnblogs.com/blog/1503305/202203/1503305-20220331215611522-964750753.png)

　　提示：PIM路由器之间会周期性的发送hello包，用于发现邻居、建立并维护邻居关系，这个和单播中的ospf协议很类似，只有建立起邻居以后，才会有后续的信息交换生成路由表项；当共享网段路由器运行的IGMP版本是V1时，此时pim会选举DR来充当igmp里的查询器；因为IGMPv1本身不具有查询器选举的功能；v2,v3IGMP自身有查询器选举功能，不依赖pim；pim邻居发现过程，双方都把hello包发往224.0.0.13这个组播地址，这个组播地址就是用于pim hello地址；即运行pim的路由器，都会监听224.0.0.13这个地址；

　　邻居发现-DR选举

　　选举DR，充当IGMPv1的查询器，其选举规则如下

　　1、对比优先级，优先级高者成为DR；

　　2、如果优先级一样，则对比ip地址，ip地址大者成为DR

　　注意：igmp v2 查询器选举规则是ip地址越小越优先和v1依赖pim选举dr充当查询器的规则相反；

　　2、组播报文扩散过程（Flooding）

![](https://img2022.cnblogs.com/blog/1503305/202203/1503305-20220331220854162-1609514696.png)

　　提示：所谓扩散是将组播报文扩散到每一个运行PIM-DM的网段，沿途每一台路由器都建立（s,g）表项；不管对应路由器下是否有接收者，对应组播数据都会先扩散过去；当然这种扩散会带来资源的消耗（带宽和路由器内存等），因为沿途路由器都会建立（s,g）表项；这里需要注意只有通过RPF检查后的接口才会创建路由表项；

　　3、剪枝加入过程（Prune/Join）

![](https://img2022.cnblogs.com/blog/1503305/202203/1503305-20220331221507794-2067293067.png)

　　提示：为了减少资源的消耗，对没有组播数据转发到分枝进行剪枝（Prune）操作，只保留包含接收者的分支；剪枝操作就是对应没有接收者的分枝向上游接口发送Prune消息，用来告诉上游路由器对应接口不需要发送组播数据；即对应上游路由器相关接口就不需建立（s,g）表项；如果共享网段上有路由器连接接收者，则该路由器需向上游发送join消息覆盖其他路由器发送到prune消息；如上图RTD发送prune消息以后，对应RTC对应接口就不会建立（s,g）表项，但是RTE和RTD是共享网段，RTD发送Prune消息，对应RTE也会收到，但是RTE下有接收者，所以RTE会发送join消息来覆盖RTD发送到prune消息；所以对应RTC来说，它对应接口还是会建立表项；剪枝是有剪枝超时计时器，这个时间是210秒；也就是说210秒过后如果没有人发送prune消息，对应接口又会恢复成转发数据的状态；

　　SPT的形成

![](https://img2022.cnblogs.com/blog/1503305/202203/1503305-20220331224545302-1534577726.png)

　　提示：经过上述的扩散-剪枝过程以后，形成组播源到组播接收者之间的SPT；扩散-剪枝过程是周期进行，由定时器控制，这个定时器是180s；也就是说每180s就会扩散一次；所以上述的剪枝超时210秒正常情况下都不会超时，即对应没有接收者的路由对应接口不会变为转发状态；

　　4、状态刷新机制

![](https://img2022.cnblogs.com/blog/1503305/202203/1503305-20220331225313253-670154388.png)

　　提示：状态刷新主要用来降低组播报文扩散到频率，节省网络带宽；状态刷新是离组播源最近的路由器发送state refresh消息，该消息会沿SPT的路径向每个路由器扩散，收到该消息的路由器，对应路由器上接口的扩散、剪枝定时器都会刷新，从而降低扩散-剪枝所带来的网络资源消耗；状态刷新的发送周期是60秒；

　　5、嫁接（Graft）机制

![](https://img2022.cnblogs.com/blog/1503305/202203/1503305-20220331230308384-1601545287.png)

　　提示：当被剪枝分支的节点上出现了组播组成员时，为了减少该节点恢复成转发状态所需的时间，使用嫁接（graft）机制主动恢复其对应组播数据的转发；当路由器需要上游发送组播报文时，向上游发送Graft消息，上游路由器收到Graft消息后恢复Graft ACK消息进行确认，对应路由器的接口就会转变为转发状态；如上图所示，RTF上如果有新的接收者出现，首先接收者通过IGMP发送成员报告，当RTF收到成员报告以后，它会立即向其上游RTC发送Graft消息，RTC收到graft消息以后，向RTF恢复graft ACK确认，此时，RTC和RTF上对应接口就会建立表项，对应接口也会恢复成转发状态，进行数据转发；

　　6、Assert断言机制

![](https://img2022.cnblogs.com/blog/1503305/202203/1503305-20220331231227871-221110945.png)

　　提示：断言机制主要针对在一个网段内如果存在多台组播路由器，则相同的组播报文会被重复发送到该网段，通过断言机制可以选定网段上唯一的组播数据转发者；如上图所示，RTA和RTB到达组播源是等价路由，那么对于RTC来说，如果没有断言机制，它可能从RTA和RTC都收到组播数据，这样一来RTC就会收到两份一模一样的数据；为了解决RTC收到重复的组播报文，此时RTA和RTB会发送Assert消息，对应A和B收到对方的Assert消息以后，根据规则，其中一方路由器会停止转发数据；

　　Assert选举网段上唯一的组播数据转发者规则

　　1、比较到组播源的优先级，优先级高者胜出成为组播数据转发者；

　　2、如果优先级一样，则比较到组播源的度量值，度量值小者成为组播数据转发者；

　　3、如果优先级、度量值都一样，则比较本地接口ip地址，ip地址大者成为组播数据转发者；

　　实验：如下拓扑配置pim 密集模式

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401204533175-193938157.png)

　　配置PC1

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401204434703-1024702501.png)

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401204457995-1035880412.png)

　　配置PC2

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401204641438-1872172415.png)

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401204702868-2123768166.png)

　　配置组播源

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401204749964-503078635.png)

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401204855454-1548126467.png)

　　配置R1

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

sys
sys R1 
int g0/0/0
ip add 11.0.0.254 24
int g0/0/1
ip add 13.0.0.1 24

ospf 123 router-id 1.1.1.1
area 0
net 11.0.0.254 0.0.0.0
net 13.0.0.1 0.0.0.0
q
q

multicast routing\-enable

int g0/0/0
pim dm
igmp en
int g0/0/1
pim dm 

View Code

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401205400906-505113009.png)

　　提示：因为R1是靠近接收者的路由器，所以对应接口下需要开启igmp；跑ospf是让三个路由器的网络互通；当然你也可以使用静态、RIP等都可以，只要网络互通即可；

　　配置R2

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

sys
sys R2 
int g0/0/0
ip add 22.0.0.254 24
int g0/0/1
ip add 23.0.0.2 24

ospf 123 router-id 2.2.2.2
area 0
net 22.0.0.254 0.0.0.0
net 23.0.0.2 0.0.0.0
q
q

multicast routing\-enable

int g0/0/0
pim dm
igmp en
int g0/0/1
pim dm 

View Code

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401205638559-1168957714.png)

　　配置R3

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

sys
sys R3
int g0/0/0
ip add 13.0.0.3 24
int g0/0/1
ip add 23.0.0.3 24
int g0/0/2
ip add 31.0.0.3 24

ospf 123 router-id 3.3.3.3
area 0
net 13.0.0.3 0.0.0.0
net 23.0.0.3 0.0.0.0
net 31.0.0.3 0.0.0.0
q
q

multicast routing\-enable

int g0/0/0
pim dm
int g0/0/1
pim dm
int g0/0/2
pim dm

View Code

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401205816436-910126290.png)

　　验证R1ospf邻居和路由情况

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401210142471-1575493399.png)

　　提示：可以看到R1和R3建立起邻居，其状态为full;

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401210054677-2052521181.png)

　　提示：可以看到R1已经学习到R2和R3上的路由；

　　验证R2ospf邻居和路由情况

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401210238894-48495027.png)

　　提示：可以看到R2已经和R3建立起ospf邻居，且状态为full；对应R2已经学习到R1和R3上宣告的路由；

　　验证R3ospf邻居和路由情况

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401210435274-503497639.png)

　　提示：可以看到R3和R1和R2分别建立起ospf邻居，且状态为full；对应R3也学习到R1和R2上的路由；至此组播的基础环境已经搭建好；

　　验证：R1、R2、R3组播邻居

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401210631462-1888435952.png)

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401210658746-1780603621.png)

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401210721841-1128785818.png)

　　提示：可以看到R1、R2分别和R3互相建立起邻居；

　　启动组播源，在R2上抓包

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401211125792-39519160.png)

　　提示：可以看到我们启动组播源以后，对应在R2发送了prune消息；这是因为R2上没有接收者，所以在把组播数据扩散到全网路由器以后，没有接收者的路由器发送prune消息，进行剪枝；

　　验证：查看pim路由

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401211340466-540590638.png)

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401211402043-1803218185.png)

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401211424343-850787783.png)

　　提示：可以看到三个路由器通过扩散剪枝这个过程后，对应pim的路由就生成了；这三个路由器上生成的pim表项都有一个特点是自由上游口，没有下游口，这是因为R1和R2都没有出现接收者；

　　将pc2加入组播组，抓包查看对应数据包

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401211818115-1492201902.png)

　　提示：可以看到pc2加入组播组，对应靠近接收者的接口会收到接收者发送的igmp 成员报告，R2收到igmp的成员报告后，立刻向上游R3发送嫁接（graft）消息，R3收到R2的嫁接消息以后，对应恢复graft-ack进行确认；此时R2和R3的pim路由就会有下游接口；

　　验证：查看R2和R3的pim路由，看看对应是否有下游接口？

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401212238345-134288874.png)

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401212254394-1923954179.png)

　　提示：可以看到R2和R3的pim路由中都产生了下游接口；

　　把pc1加入组播组，看看R3上的路由有什么变化？

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401212448858-1015296535.png)

　　提示：可以看到pc1加入组播组以后，对应R3路由中就多了一个下游接口；

　　验证：查看R1的pim路由，看看有什么变化？

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401212600757-922070483.png)

　　提示：可以看到R1的路由表中对应路由也有了下游接口；同时我们也注意到也多了一条共享树（\*,g）的表项；这是因为R1下有了接收者以后，对应就会生成共享树；

　　pc1离开组播组，看看R1的路由有什么变化？

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401212851158-1048881774.png)

　　提示：可以看到PC1离开组播组以后，对应R1的路由中对应下游接口也没有了，随之（\*,g）的路由表项也没有了；

　　查看R2路由表的详细信息

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401213229008-177229098.png)

　　提示：pim都是基于接口的，所以查看详细信息我们需要查看某一个接口下的详细信息；其中我们可以看到详细信息中列出了pim版本信息，模式，DR 的地址，这里我们使用的是默认igmp v2的版本，所以他这里不会充当igmp的查询器，由igmpv2的规则自动选举产生；除此之外还有hello包间隔时间是30秒，死亡时间是105秒，断言assert死亡时间是180秒；剪枝加入的间隔时间是60秒，超时时间是210秒，状态刷新时间是60秒，嫁接延迟时间是3秒；

　　实验：如下拓扑图配置pim 抓包查看assert消息

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401220425371-2085092460.png)

　　R1的配置

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

sys
sys R1
int g0/0/0
ip add 11.0.0.1 24
int g0/0/1
ip add 12.0.0.1 24

multicast routing\-enable

int g0/0/0
pim dm
int g0/0/1
pim dm 

View Code

　　R2的配置

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

sys
sys R2
int g0/0/0
ip add 11.0.0.2 24
int g0/0/1
ip add 22.0.0.2 24

multicast routing\-enable

int g0/0/0
pim dm
int g0/0/1
pim dm 

View Code

　　运行组播源，在lsw2上任意接口抓包

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401221403858-990980353.png)

　　提示：可以看到当我们启动组播源以后，对应在lsw2上就能抓到assert包，其中R1R2都会发送的assert包，当assert包都发送以后，会根据各自包中携带的信息进行对比，根据规则在此环境中R2应该要胜出，因为在在优先级和开销都一样的情况下，本地接口ip地址大者胜出；

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401222054458-881296087.gif)

　　提示：可以看到在assert包没发送之前，R1和R2都在转发组播数据；

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401222642290-1987462733.gif)

　　提示：可以看到assert包发送以后，后续都是R2在转发数据；

　　验证：查看R2的g0/0/1口的mac地址是否是12bd?

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220401222822399-1527049833.png)

　　提示：可以看到我们抓到组播数据报中对应源mac地址正是R2的g0/0/1的mac地址，说明我们在交换机上抓到包都是由R2转发，R1因为assert没有胜出，所以R1并不转发数据；

作者：[Linux-1874](https://www.cnblogs.com/qiuhom-1874/)

出处：[https://www.cnblogs.com/qiuhom-1874/](https://www.cnblogs.com/qiuhom-1874/)

本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.