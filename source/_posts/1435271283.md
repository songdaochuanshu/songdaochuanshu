---
layout: post
title: "控制Python浮点数输出位数"
date: "2022-04-16T07:17:04.995Z"
---
控制Python浮点数输出位数
===============

![控制Python浮点数输出位数](https://img2022.cnblogs.com/blog/2277440/202204/2277440-20220415215727399-1164009757.png) 在python的输出结果中，尤其是浮点数的输出，当我们需要写入文本文件时，最好是采用统一的输出格式，这样也能够增强结果的可读性。而对于浮点数输出位数的控制，可以通过{:.4f}、%.4f来指定打印或者输出时的字符串占据空间，也可以通过round函数来对输出前的结果进行转化。而如果是取有效数字，需要用到{:.4}，这几种方法没有优劣，只有看不同的场景，选取不同的精度控制方案。

技术背景
====

在Python的一些长效任务中，不可避免的需要向文本文件、二进制文件或者数据库中写入一些数据，或者是在屏幕上输出一些文本，此时如何控制输出数据的长度是需要我们注意的一个问题。比如对于一个二进制文件，如果输出的浮点数长度一直在发生变化，则写入到文件之后，读取的人按照比特位进行读取就会读到一堆错误的数据。因此，我们需要控制输出位数，尤其是浮点数要格外小心。

常规控制方法
======

一般情况下，我们可以通过`round`来设置输出浮点数的有效数字，其原理是对于一个给定的浮点数直接取前n位的有效数字，后续的数字四舍五入。而`%.4f`和`{:.4f}`这两种格式化，是在输出时取小数点后4位打印，跟先取有效数字再打印是不一样的，后面会提到。先看下这几个方式的输出异同点：

    In [1]: pi_10=31.415926
    
    In [2]: print (round(pi_10,4))
    31.4159
    
    In [3]: print ('%.4f' % pi_10)
    31.4159
    
    In [4]: print ('{:.4f}'.format(pi_10))
    31.4159
    

上面的例子是小数点前和小数点后都有多位数字，另外类似的可以看下小数点前只有0的数字的输出结果：

    In [5]: pi_10=0.31415926
    
    In [6]: print (round(pi_10,4))
    0.3142
    
    In [7]: print ('{:.4f}'.format(pi_10))
    0.3142
    
    In [8]: print ('%.4f' % pi_10)
    0.3142
    

在上面的两个案例中，我们发现三者的输出结果都是一样的。但是前面提到了先取有效数字再输出，跟先输出再取有效数字的区别，可以通过下面的一个案例体现出来：

    In [9]: pi_10=3.1415926E-08
    
    In [10]: print (round(pi_10,4))
    0.0
    
    In [11]: print ('{:.4f}'.format(pi_10))
    0.0000
    
    In [12]: print ('%.4f' % pi_10)
    0.0000
    

这里的输入是一个小数点后有很多0的浮点数，但是这里用的是科学计数法，也就是\\(3.1415926\*10^{-8}\\)，此时我们用这三种输出方式，得到的结果全都是0，而且第一种方案更是直接小数点后都没满4位。这是因为在用round取有效数字时，发现小数点后的数字太多，把当前的浮点数直接当成了`0.0`而不是`0.0000`，而后面两个方案的过程更像是在打印出来这个数字之后，再把超过有效位数的数字去掉，因此会保留小数点后的4个0。但是，即使如此，得到的结果也不是我们所想要的结果。因为这个数字虽然很小，但是可能只是由于单位问题，并不代表这个数字产生的影响就是0，因此直接用这种取小数点后有效数字的方法可能会出问题。

取有效数字
=====

这里我们要介绍的取有效数字的方法，不再是去小数点后的有效数字，而是整体的有效数字。方法也很简单，就是把上一个章节中的`{:.4f}`改成`{:.4}`，同样的可以通过这么几个案例来理解控制有效数字的结果：

    In [13]: pi_10=3.1415926E-08
    
    In [14]: print ('{:.4}'.format(pi_10))
    3.142e-08
    
    In [15]: pi_10=0.31415926
    
    In [16]: print ('{:.4}'.format(pi_10))
    0.3142
    
    In [17]: pi_10=31.415926
    
    In [18]: print ('{:.4}'.format(pi_10))
    31.42
    

我们发现，输出的结果会根据输入的格式改变而改变，如果输入的小数位0过多，输出结果会被自动转换成科学计数法。而不仅仅是针对浮点数，`{:.4}`还可以作用在字符串中，效果如下：

    In [19]: string='Hello World!'
    
    In [20]: print ('{:.4}'.format(string))
    Hell
    

总结概要
====

在python的输出结果中，尤其是浮点数的输出，当我们需要写入文本文件时，最好是采用统一的输出格式，这样也能够增强结果的可读性。而对于浮点数输出位数的控制，可以通过{:.4f}、%.4f来指定打印或者输出时的字符串占据空间，也可以通过round函数来对输出前的结果进行转化。而如果是取有效数字，需要用到{:.4}，这几种方法没有优劣，只有看不同的场景，选取不同的精度控制方案。

版权声明
====

本文首发链接为：[https://www.cnblogs.com/dechinphy/p/fprint.html](https://www.cnblogs.com/dechinphy/p/fprint.html)

作者ID：DechinPhy

更多原著文章请参考：[https://www.cnblogs.com/dechinphy/](https://www.cnblogs.com/dechinphy/)

打赏专用链接：[https://www.cnblogs.com/dechinphy/gallery/image/379634.html](https://www.cnblogs.com/dechinphy/gallery/image/379634.html)

腾讯云专栏同步：[https://cloud.tencent.com/developer/column/91958](https://cloud.tencent.com/developer/column/91958)

“留一手”加剧内卷，“讲不清”浪费时间。