---
layout: post
title: "C# 正则表达式判断是否是有效的文件、文件夹路径"
date: "2022-04-01T01:40:49.114Z"
---
C# 正则表达式判断是否是有效的文件、文件夹路径
========================

C# 正则表达式判断是否是有效的文件、文件夹路径
========================

省流
--

    /// <summary>
    /// 是否有效的文件，文件夹路径
    /// </summary>
    /// <param name="val"></param>
    /// <returns>是，返回true；不是返回false</returns>
    public bool IsValidFolderPath(string val)
    {
        Regex regex = new Regex(@"^([a-zA-Z]:\\)([-\u4e00-\u9fa5\w\s.()~!@#$%^&()\[\]{}+=]+\\?)*$");
        Match result = regex.Match(val);
        return result.Success;
    }
    
    // "F:\\Total客户端项目\\客户端项目\\2017-01-09 Client\\(aa)\\V1.3.4\\New_1.2\\V13&V14\\.()~!@#$%^&()-+="; // 匹配结果：true
    

解释：

分为2大段，一段匹配盘符，一段匹配后续文件、文件夹路径

1.  ^`([a-zA-Z]:\\)`：必须以盘符的形式开头。
    
    `^`表示从起始位置匹配，`[a-zA-Z]`表示第1位必须是`a~z`或`A~Z`其中之一。`:\\`表示第1位后必须接字符串`:\`。`\\`是正则中`\`的转义。
    
2.  `([-\u4e00-\u9fa5\w\s.()~!@#$%^&()\[\]{}+=]+\\?)*$`：后续以一定取值范围组成一个个结构。
    
    先看\[\]内，`\u4e00-\u9fa5`表示匹配汉字，`\w`，`\s`都是元字符有其对应的匹配范围。其余这些字符`-.()~!@#$%^&()\[\]{}+=`就代表它们自身。其中`\[`是`[`的转义，`\]`是`]`的转义。`[~]+`表示`[]`中的内容至少需要出现1次。`\\?`表示，`[~]`内的字符写完后，可以在后面接一个字符`\`，也可以不接。`(~)*`表示`()`内容可以重复任意次数，也可以一次不出现。`$`表示匹配到结束位置，搭配前面的`^`表示整个输入字符串的结构都得符合这个正则表达式。
    

几点注意：

1.  上面得`[~]`指代表达式中`[]`的所有内容，`（~）`指代表达式中`（）`的所有内容，应该挺好理解吧。
2.  写了解释主要是自己总结一下，你看估计也看不懂，要不直接拿去用，要不老老实实去学吧，这些都是基础，就把正则表达式的基础学了基本就够用。
3.  不同系统下可不可以匹配汉字是不一样的。比如C#环境里`\w`好像就可以匹配汉字，但javascript环境里`\w`就匹配不了汉字。
4.  正则自己的转义和放入字符串中的转义挺容易懵的，写的时候要注意。
5.  个人理解，只有一个路径，是判断不出来这个路径是文件还是文件夹的，因为文件夹名也可以叫`setup.exe`，文件名也可以没有后缀。windows的文件命名规范中只不允许9个字符的出现。`/ \ ? * : " < > |`其他都可以。

学习编写验证过程
--------

鉴于网上找了好几个都是垃圾,既不好使也不知道到底在判断啥，所以不得不万事靠自己。

学习自https://deerchao.cn/tutorials/regex/regex.htm

### 元字符metacharacter

字符

相关解释

\\b

匹配单词的开头或结尾，也就是单词的分界处。可用于精确查找一个单词

.

匹配除了换行以外的任意字符

\*

\*前面的内容可以重复任意次

+

+前面的内容可以连续重复1或任意更多次。通俗一点说，就是至少得匹配一次。

?

?前面的内容可以连续重复0或1次。

{x}

x：数字。{x}前面的内容必须重复x次

{x,}

x。{x,}前面的内容必须重复至少x次

{x,y}

x,y：数字。{x,y}前面的内容必须重复x,y之间的次数，包括x，y

(xxx)

表示分组

\[x,y,z\]

表示单个匹配

\\d

匹配一位十进制数字，也就是0~9

\[0-9\]

\\s

匹配任意空白符，空格，制表符，换行符，中文全角空格等

\\w

匹配数字，字母，下划线【中文】

\[a-z0-9A-Z\_\]

^

匹配字符串的开始位置

$

匹配字符串的结束位置

如何从一个字符串中查找字符串‘hi’？

    Regex regex = new Regex("hi");
    // 注意：如history，high等词中的hi也会被匹配。
    

如何精确查找hi这个词？使用\\b

    Regex regex = new Regex(@"\bhi\b");
    

这样就可以精确查找到‘hi’这个词。

如何查找hi，xxxxx，Lucy?

    Regex regex = new Regex(@"\bhi\b.*\bLucy\b");
    // `.*`不能换行。是匹配不包含换行的任意数量字符
    

如何匹配一个中国电话号码？格式为：`xx-xxxxxxxxxxxxxxx`

    Regex regex = new Regex(@"\d\d-\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d");
    

如何匹配一个188开头的电话号码？

    Regex regex = new Regex(@"\d\d-188\d\d\d\d\d\d\d\d\d\d\d\d");
    

这如果要匹配一个100位数字岂不是都写不下了，所以必然存在优化写法。

    Regex regex = new Regex(@"\d{2}-188\d{12}");
    

\\d{2} 的话能不能匹配85555这种？与high中匹配hi一样？

如果没有限制也是会都匹配的，如果想要精确匹配，也要在前后使用元字符\\b

如果有长号有短号想一起匹配怎么办？

    Regex regex = new Regex(@"\d{2,3}-188\d{6,12}");
    

解析一个电话号相关的表达式`^\(?0\d{2}[) -]?\d{8}`

1.  `^`:表示验证字符串必须以`（`或0开头
2.  `\(?` : `\(`是`(`的转义，`?`表示出现1次或不出现
3.  `0\d{2}` : 表示0起始后面跟2位数字
4.  `[) -]?`：表示数字后面的1位或者什么都没有，或者是`）`,`空格`,`-`3个中的一个
5.  `\d{8}`：表示8位数字。

    string phone = "(010)88886666";
    string phone1 = "(010x88886666";
    string phone2 = "011)-888866660000";
    string phone3 = "011-888866660000";
    string phone4 = "99011-88886666";
    Regex regex30 = new Regex(@"^\(?0\d{2}[) -]?\d{8}");
    Match resultphone = regex30.Match(phone);// 匹配成功
    Match resultphone1 = regex30.Match(phone1);// 匹配失败，因为010后出现了[]中不存在的字符
    Match resultphone2 = regex30.Match(phone2);// 匹配失败，因为[]后没有接8位数字，不是说-也在[]中就可以，[]永远只匹配一个位置
    Match resultphone3 = regex30.Match(phone3);// 匹配成功，因为这个正则表达式没有用$限制结尾
    Match resultphone4 = regex30.Match(phone4);// 匹配失败，因为这个正则表达式用^限制了开头，必须为（或0。
    

### 关于`^`和`$`

以前老不理解这玩意都啥用，其实就是对匹配范围进行限制。以一段数字字符为例。

正常使用`9/d{2}`进行匹配，匹配条件可以解释为，“以9开头并在后面跟任意2位数字的字符串”可以匹配成功，也就是998。

但如果使用^进行限制`^9/d{2}`。匹配条件就变为“输入字符串必须是以9并在后面跟任意2位数字开头的字符串”。匹配就会失败。

把9去掉`^/d{2}`，匹配条件就变为“输入字符串必须是以任意2位数字开头的字符串”。匹配就会成功。

若用$限制`/d{2}$`，匹配条件就变为“输入字符串必须是以任意2位数字结尾的字符串”。匹配成功。

若改为`58$`，匹配条件就变为“输入字符串必须是以‘58’结尾的字符串”。匹配就会失败。

若用`^，$`限制，`^/d{2}$`,匹配条件就变为“输入字符串必须是2位数字的字符串”，匹配失败。

改为`^/d{18}$`，,匹配条件就变为“输入字符串必须是18位数字的字符串”，匹配成功。

代码如下：

    string numberStr2 = "123456789987645312";
    Regex regex2 = new Regex(@"9\d{2}");
    Match result2 = regex2.Match(numberStr2);
    
    Regex regex3 = new Regex(@"^9\d{2}");
    Match result3 = regex3.Match(numberStr2);
    
    Regex regex4 = new Regex(@"\d{2}$");
    Match result4 = regex4.Match(numberStr2);
    
    Regex regex5 = new Regex(@"58$");
    Match result5 = regex5.Match(numberStr2);
    
    Regex regex6 = new Regex(@"^\d{2}$");
    Match result6 = regex6.Match(numberStr2);
    
    Regex regex7 = new Regex(@"^\d{18}$");
    Match result7 = regex7.Match(numberStr2);
    

### 关于`()`，`[]`,和`{}`

首先是{}，这个没什么说的，就是表示重复次数的。{2}，{2,},{2,5}这种。

其次\[\]表示单个匹配。只能表示1个位置，这个位置的内容必须为\[\]中的选项之一。

看到这么描述大约有以下几种疑问

单独使用\[\]有啥用？

    Regex regex8 = new Regex(@"[打]");
    Match result8 = regex8.Match(Str8);
    
    Regex regex9 = new Regex(@"[打s]");
    Match result9 = regex9.Match(Str8);
    
    Regex regex10 = new Regex(@"[打s黑]");
    Match result10 = regex10.Match(Str8);
    
    Regex regex11 = new Regex(@"[黑]");
    Match result11 = regex11.Match(Str8);
    
    Regex regex12 = new Regex(@"打");
    Match result12 = regex12.Match(Str8);
    
    Regex regex13 = new Regex(@"黑s打");
    Match result13 = regex13.Match(Str8);// 匹配失败
    
    Regex regex14 = new Regex(@"[黑s打]");// 匹配成功，找到‘打’
    Match result14 = regex14.Match(Str8);
    
    // 单独使用就是从头至尾匹配输入字符串的每一个字符。找到输入字符串中第一个能与[]中任意一个字符匹配的上的。
    // 如果[]中只有1个字符，那有没有[]完全一样。如果[]内有多个字符是不一样的。
    // 想象不出来使用场景，[]在实际应用中也大多配合其他条件一起使用
    

\[\]里要是有元字符怎么办？

解决方法很简单：转义。

但具体怎么转其实还是有点绕。这个绕不是说有多难，而是这个点你需要有印象，遇到的时候要能反映过来。

这个我认为很容易懵的点在于C#自身字符串的转义与正则表达式的转义混合。

首先明确一下C#中的转义，C#中转义有2种方法：

    // 字符原文：
    //a我打[]{}aa\bb"cc''dd^ee/dff
    //another row
    // '[',']','{','}',''','^','/'本身就不需要转义，需要转义的是'\','"',换行
    
    // 第1种 需要转义的符号前加'\'
    string stringStr1 = "a我打[]{}aa\\bb\"cc''dd^ee/dff\r\nanother row";
    // 第2种，整个字符串用'@'修饰
    // 这种情况下，'\'，换行不用转义了。但'"'还需要转义，因为不转义字符串就提前结束了，用两个双引号'""'表示普通字符'"'
    string stringStr2 = @"a我打[]{}aa\bb""cc''dd^ee/dff
    another row";
    

正则表达式中需要转义的符号很多，所有元字符全部需要转义。但好消息是转义方式只有1种，就是在需要转义的符号前加`\`。

这再把这些表达式放入C#字符串中，就分不清到底是字符串转义，还是正则转义，正则转义后进入字符串会不会又要转义等等等等。懵。

元字符包括：( ) \[ \] { } \\ ^ $ | ? \* . + /。 ”/“需不需要转义好像有点争议。查了一下发现很多编译器关于正则的转义是有一些默认处理的，也没找到个权威的规则，就视具体情况而定。

    // 上面的例子，匹配一个9开头跟2个数字的字符
    Regex regex15 = new Regex("9\d{2}"); // 这样写就会报错，因为正则'\d'中的'\'是c#字符串中转义的标识。这么写C#就会认为'\d'是一个转义符，而又不知道转义成了什么，就会报错：CS1009：无法识别的转义序列。
    // 所需要将'\'转义，如上使用@或另一种转义方法都可以
    Regex regex16 = new Regex(@"9\d{2}");
    Regex regex17 = new Regex("9\\d{2}");
    
    // 另一个很需要有印象的例子。就是一个位置只能使用字符'\'或字符'd'
    // 其实很简单，用[]就行
    Regex regex18 = new Regex("[\d]");//如上报错：CS1009：无法识别的转义序列。
    // 一开没转义，改为
    Regex regex19 = new Regex("[\\d]");//编译通过，完活。
    string str10 = @"a我打[]{}aa\bb""cc''dd^ee/dff\\";
    Match result19 = regex19.Match(str10);// 匹配失败
    // 然而result19的结果是 匹配失败。
    // 这就是字符转义与正则转义的混合。
    // '\\d'仅处理了字符串中'\'的问题，没有解决正则'[\d]'中'\'也需要转义的问题；
    // 想要实现一个位置只能使用字符'\'或字符'd'，正确的正则表达应该为[\\d]
    // 那么再将其放入C#字符串中，每个'\'都要再转义一次，即为
    Regex regex20 = new Regex("[\\\\d]");
    Match result20 = regex20.Match(str10);
    // 或
    Regex regex21 = new Regex(@"[\\d]");
    Match result21 = regex21.Match(str10);
    // 我还好奇了一下[]中有重复字符会怎样
    Regex regex22 = new Regex(@"[\\\\d]");
    Match result22 = regex22.Match(str10);
    // 结果好像没啥区别，有相同字符无所谓的，没影响
    
    // 这里后续使用又发现了一点，补充一下
    // 前文提到:
    Regex regex19 = new Regex("[\\d]");
    string str10 = @"a我打[]{}aa\bb""cc''dd^ee/dff\\";
    Match result19 = regex19.Match(str10);
    // 会编译通过，但是匹配失败。这里遗漏了一个问题，就是new Regex("[\\d]");到底再匹配什么？
    // 答案就是它再匹配'/d'，也就是任意以为0~9的数字
    string str101 = @"a我打[]{}aa\bb""cc''dd^ee/dff\\";
    string str102 = @"a我打[]{}aa\bb""cc''d9d^ee/dff\\";//中间加了个9
    Regex regex191 = new Regex("[\\d]");
    Match result191 = regex191.Match(str101);//匹配失败
    Match result192 = regex191.Match(str102);//匹配成功，找到9
    //所以[],不止能匹配[]中的实际内容，还可以配合元字符匹配所有那一类字符
    

`[]`搭配`-`可以表示连续的字符

    Regex regex22 = new Regex("[0-3]");// 某位置匹配0~3，也就是0，1，2，3
    

`[]`搭配`^`可以表示排除

    Regex regex23 = new Regex("[^0-3]");//  某位置匹配除了0，1，2，3都可以。
    

可以复习一下要是就想匹配`-`，`^`，甚至`[]`怎么办？

    Regex regex24 = new Regex("[\\^\\[\\]\\-]");
    //或
    Regex regex25 = new Regex(@"[\^\[\]\-]");
    

这里实际试了一下这些特殊字符，除了`[ 和 ]`不转义也能匹配，迷惑。

最后就是()，()有很多功能，包括限制多选结构的范围，分组，捕获文本，环视，特殊模式处理。

我感觉比较基础的使用就是限制多选与分组。

    // 匹配必须整段一模一样的abc或bcd或cde，
    Regex regex26 = new Regex("(abc|bcd|cde)");
    
    // 匹配必须有连续2个adb的重复，也就是abcabc，abcaabc不行
    Regex regex27 = new Regex("(abc){2}");