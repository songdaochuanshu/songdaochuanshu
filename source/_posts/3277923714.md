---
layout: post
title: "stm32F103RCT6使用FFT运算分析波形详解（非常新手）"
date: "2022-04-28T13:37:32.748Z"
---
stm32F103RCT6使用FFT运算分析波形详解（非常新手）
================================

本文详细的讲解了FFT的实现，简直是手把手了。我也是慢慢学过来的，知道网上的教程对于初学者不是很友好，所以决定自己写一份博客来记录下来我的经验

最近学校电赛院队招新，出的招新题就是低频示波器的。之前一直没有弄懂FFT，借着这次机会实现了一下。

*   FFT原理详解

　　FFT，就是快速傅里叶变换，这个操作能够将时域信号转化成频域信号，然后对信号进行分析

　　这样说可能有点抽象。讲细点就是指能够直观的看出来目标信号的频率是多少。x轴坐标本来是表示时间，FFT之后变成了表示频率，就是这个意思

　　对于信号处理，FFT之后的结果，波峰一般会出现在我们希望测得信号的频率附近（十分相近）

*   官方文件解释

stm32官方给了几个用于处理FFT的文件，如图所示：

![](https://img2022.cnblogs.com/blog/2734128/202204/2734128-20220416001230786-811034151.png)

 其中有两个汇编文件两个头文件：汇编文件是定义了FFT的计算函数，我们直接调用即可

cr4\_fft\_1024\_stm32.s是包含了计算1024个点的FFT的函数的汇编文件，另一个汇编文件同理

stm32\_dsp.h里面有关于FFT处理函数的声明，我们包含了这个头文件之后直接调用函数即可

*   算法解释

 1 //进行FFT运算等操作
 2 void FFT\_Wave(void)
 3 {
 4   u16 i;
 5   float mid\_value; 6   while(!ADC\_flag)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
 7   {
 8     LED1 = !LED1;
 9     delay\_ms(100);
10 }
11   ADC\_flag = 0;
12   
13   //获取最大值最小值
14   adc\_value\_max = adc\_value\_min = ADC\_buff\[1\];
15   for(i = 0;i < NPT;i++)
16 {
17     //寻找最大值最小值
18     if(ADC\_buff\[i\] >= adc\_value\_max)
19 {
20       adc\_value\_max = ADC\_buff\[i\];
21 }
22     if(ADC\_buff\[i\] <= adc\_value\_min)
23 {
24       adc\_value\_min = ADC\_buff\[i\];
25 }
26     //先清空数组
27     fftin\[i\] = 0;
28     //移位，让后面16位为虚部
29     fftin\[i\] = ((s16)ADC\_buff\[i\] << 16);
30 }
31   cr4\_fft\_1024\_stm32(fftout,fftin,1024);//FFT
32 GetPowerMag();
33   //计算电压值
34   Vpp\_true = (adc\_value\_max - adc\_value\_min) \* 3.3 / 4096.0;//获得Vpp值
35   mid\_value = (adc\_value\_max + adc\_value\_min) / 2;
36   for(int i = 0;i < NPT;i++)
37 {
38     if(ADC\_buff\[i\] > mid\_value)
39 {
40       rect\_duty++;
41 }
42 }
43   rect\_duty = rect\_duty / 1024 \* 100;
44 }

这是FFT的主体函数

第一步我们先要等待ADC采集完成，将数据存入数组当中准备进行处理

 第二步是在采样值当中寻找最大值和最小值（遍历数组即可）

第三步是对数组进行移位处理（前面的是实部，后面的是虚部，由于我们采集到的电压都是实数，所以虚部都置0）

第四步是使用ST官方提供的函数进行FFT运算，得到运算之后的数组

第五步是根据频谱查找我们信号所对应的频率，也就是对频谱图当中所有的频率进行幅值的比较，找出幅值最大时所对应的频率，即为我们所需要测量的频率，其他的都可以看作噪声

在我们找到该频率之后，不能立刻输出，要与ADC的采样率相乘再除以1024，之后才能得到我们想要的信号频率

GetPowerMag函数定义如下：

 1 void GetPowerMag(void)
 2 {
 3   s16 lX,lY;
 4   u32 i;
 5   float maxmag; 6   for(i = 0;i < NPT / 2;i++)
 7   {
 8     lX = (fftout\[i\] << 16) >> 16;
 9     lY = (fftout\[i\] >> 16);
10     float X = 1024 \* ((float)lX) / 32768;
11     float Y = 1024 \* ((float)lY) / 32768;
12     float mag = sqrt(X \* X + Y \* Y) / 1024;
13     FFT\_Mag\[i\] = (u32)(mag \* 65536);
14 }
15   FFT\_Mag\[0\] >>= 1;//频谱图第一个是直流分量，无需乘2
16   for(int i = 0;i < NPT / 2;i++)
17 {
18     if((maxmag < FFT\_Mag\[i\]) && (i != 0))
19 {
20       maxmag = FFT\_Mag\[i\];
21       temp = i;
22 }
23 }
24   F\_hz = temp \* sampling\_rate / 1024.0;
25 }

至此，我们就得到了我们所需信号的频率

鉴于本小白能力有限，如果有纰漏或改进之处，欢迎指正

**特别提醒：ADC采样率应遵循奈奎斯特采样定理！采样率不是越高越好！**