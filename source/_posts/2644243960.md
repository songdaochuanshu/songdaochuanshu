---
layout: post
title: "重新整理汇编—————汇编的基础理论前置篇"
date: "2022-05-22T03:09:35.501Z"
---
重新整理汇编—————汇编的基础理论前置篇
=====================

### 前言

什么是汇编呢？ 就是说0 1 太难记了。

比如000100100101 到底是什么呢？ 很难去人类去理解。

但是呢，cpu 对0、1 理解的很透彻了。 这个时候呢，人和cpu 之间的交流就出现了障碍了。

然后呢，人是高等生物，有思想的，但是cpu没有，那么就只能人迁就cpu了，迁就的一方往往就有点不幸福了。

那么人这个时候就很痛苦，但是又离不开cpu。那么这个时候人就想啊，要是自己说的话要是有人翻译，cpu 能够理解就完事了。

好在cpu很简单，会做的事情不多，要是能把其固定的套路用自己的语言翻译成cpu语言就很好了。 这个搞翻译的就是汇编，汇编语言通过编译器然后转换成二进制，然后cpu就懂了。

cpu 比较简单，会的东西不多，那么汇编如果单从语言上讲非常简单。 但是为什么很多人对汇编不感冒呢？那个不是汇编难，是用汇编做工程难。

怎么说呢？ 比如说要搭建一个房子，汇编一个语句执行一条命令。先把15243514的砖放在第一块，然后把15243614放在第二块。

那这样啥时候能搞定啊？ 工程能力差啊。然后高级语言，比如s += 20, 这个就是要翻译成很多汇编语言的，如果去手敲估计得发脾气的。

那么高级语言干了什么事呢？高级语言，就是把人经常用到的东西，做成一个汇编包呗。比如上面的s+=20,那么是加法有对应的汇编去转换。

当然了，转换没有这么简单，这又是一门学问，如何开发一门语言。扯得很远了，进入正文吧。

### 正文

汇编语言由3类组成：

1.  汇编指令(机器码的助记符)
    
2.  伪指令(由编译器执行)
    
3.  其他符号（有编译器识别）
    

汇编语言的核心是汇编指令，它决定了汇编语言的特性。

一个一个举例哈。

比如: mov ax bx,这还就是汇编指定，最终就是会转换成机器码

什么是伪指令呢？ 这个就是编译器认识，但是机器不认识。这里不直接说汇编，比如c 语言的include，这个就只有编译器认识了，编译器把include 的包引用进来，但是机器肯定不认识的。

第三个是其他符号哈， 我们指定cpu 只能做加法的，如果是其他减、乘、除怎么处理呢？ 得编译器从加法的角度翻译了。

然后这个汇编还得去了解一个东西，那就是存储器，准确的来说就是内存。

因为cpu 做的事情从那么来，到哪里去，都存在内存中，所以这个还得去瞄一眼。

这里就有一个问题，那就是cpu 只能从内存中读取数据，然后将数据计算完毕又给了内存。

那么有一个问题，那就是cpu 是如何从磁盘上读取东西的呢？ 这个真的不是cpu 去直接操作的，它哪有这么聪明，只不过任何操作内存的都需要cpu，这个计算机原理篇会解释。

指令和数据都是应用概念。

在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息，这是值得是对于内存来说，而不是对于cpu来说哈。

然后存储有一个概念，那就是存储单元。比如byte 字节， kB 千字节等。

那么cpu是如何操作内存的呢？

cpu 要想进行数据的读写，必须和外部器件，进行3类数据的交互。

1.  存储单元的地址(地址信息)
    
2.  器件选择，读或写命令(控制信息)
    
3.  读或写的数据(数据信息)
    

那么有个问题，cpu 如何对内存进行读和写哈。

![](https://img2022.cnblogs.com/blog/1289794/202205/1289794-20220519214704070-1039331428.png)

上面就是说有3根线一个是地址线、一个是数据线、一个是控制线。

显示地址线把地址传给内存、然后控制线把数控制命令传给内存，然后内存就把数据通过数据线传给了cpu。

这里的内存不只是包括内存条、还包括显卡内存、网卡内存，这些硬件都是有内存的哈。

写也是一样，比如地址线发出写的指令、然后地址线发出地址，然后数据线发出数据，然后就存到了内存中。

这里有一个问题哈，那就是这些都是cpu 主动去执行的，那么其他器件怎么主动和cpu 进行交互呢？

这里网卡举例，然后网卡收到数据后，那么会对cpu 发送中断指令， cpu 中断指令收到中断指令后，人家也不知道怎么出区里，说白了就是一个信号。

然后cpu 会将这个发送给操作系统，操作系统知道怎么去处理，cpu 怎么会去通知操作系统呢？ 那是因为操作系统给cpu 启动的时候注入了一些信号的执行操作。

这就要从操作系统如何启动的说起了，计算机原理篇整理下。这里只是说明一下，cpu 只能去操作内存，单身不局限与内存条的内存，其他硬件也有内存。

然后说一下这个地址总线，这个地址总线是怎么样的呢？ 上面提及到这个地址总线是传输内存的地址的，这个地址总线不是单根线。

有些人可能接触到网络，网络是定义比如说ip协议，前20个字节干什么的，然后前20字节里面的前4个字节干什么的，比如发送地址就是前4个字节。

实际的是这样的。

![](https://img2022.cnblogs.com/blog/1289794/202205/1289794-20220520003138052-199721421.png)

我这上面画了8个箭头哈，也就是地址是8位的，假如这里画了32根箭头那么这个就是32位的，如果是64，那么就是64位的。

现在大多数cpu 都是64位了，也就是说地址是一次性传过去的，不是说传过去然后内存存储器做切割，然后判断哈，没有这么聪明的，如果是这样效率也很低。

然后就是这个数据总线，cpu 与内存或者其他器件之间的数据传输，是通过数据总线来进行的。

数据总线的宽度决定了cpu 和 外接的数据传输速度。

历史: 8088cpu 的数据总线的线是8条，8086 cpu 的数据总线是16条。

为什么都是8的倍数呢，是因为8位为一个字节这个时候就很流行了，计算机存储的基本单位就位。

控制总线： cpu对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。

有多少根控制总线，就意味着cpu 提供了对外部器件的多少种控制。

所以控制总线的宽度决定了cpu 为外部器件的控制能力。

下面是控制总线的定义:

控制总线（ControlBus）简称CB。控制总线主要用来传送控制信号和时序信号。

控制信号中，有的是微处理器送往存储器和输入输出设备接口电路的，比如：读/写信号、片选信号、中断响应信号等；也有是其它部件反馈给CPU的，比如：中断申请信号、复位信号、总线请求信号、设备就绪信号等。

小结:

1.  汇编指令是对机器指令的助记符，同机器指令一一对应。
    
2.  每一种cpu 都有自己的汇编指令集。
    
3.  cpu 可以使用的信息在存储器中存放。
    
4.  在存储器中指令和数据没有任何区别，都是二进制。
    
5.  存储单元从0开始顺序编号
    
6.  每一个cpi芯片都有很多管脚，这些管脚和总线相连。也可以说，这些管脚引出了总线。
    

一个cpu可以引出三种总线的宽度标志，这个cpu的不同方面的性能。

1.  地址总线宽度决定了cpu的寻址能力。
    
2.  数据总线的宽度决定了cpu与其他器件进行数据传送一次数据传送量。
    
3.  控制总线宽度决定了cpu对系统中其他器件的控制能力。
    

可能有人还是对控制总线不理解,这里控制总线是什么被?

    微型计算机中控制总线提供的完整信息是所有存储器和I/O设备的时序信号和控制信号、来自I/O设备和存储器的响应信号。
    
    控制总线，英文名称：ControlBus，简称：CB。控制总线主要用来传送控制信号和时序信号。控制信号中，有的是微处理器送往存储器和输入输出设备接口电路的，比如：读/写信号、片选信号、中断响应信号等；也有是其它部件反馈给CPU的，比如：中断申请信号、复位信号、总线请求信号、设备就绪信号等。因此，控制总线的传送方向由具体控制信号而定，一般是双向的，控制总线的位数要根据系统的实际控制需要而定。实际上控制总线的具体情况主要取决于CPU。
    
    控制总线，连接在一起并完成和实现它们之间的通讯与数据传送的，因此总线的概念是理解PC和主板的组成结构、工作原理及部件之间相互关系统的基础。是用来传送控制信息的信号线，这些控制信息包括CPU对内存和输入输出接口的读写信号，输入输出接口对CPU提出的中断请求或DMA请求信号，CPU对这些输入输出接口回答与响应信号，输入输出接口的各种工作状态信号以及其他各种功能控制信号。控制总线来往于CPU、内存和输入输出设备之间，其特点是：在单向、双向、双态等种形态，是总线中最复杂、最灵活、功能最强的，其数量、种类、定义随机型不同而不同。
    

再硬件一点理解，要从ISA插槽插槽理解了。

cpu 不是有很多针脚吗？

如下：

![](https://img2022.cnblogs.com/blog/1289794/202205/1289794-20220521101759773-305633124.png)

下面是插槽位置对应的总线关系:

    1、地址总线：SA0~SA19(I/O）和LA17~LA23(I/O)
    LⅪ测试总线技术
    LⅪ测试总线技术
    2、数据总线：SD0~SD7(I/O）和SD8~SD15(I/O)3、控制总线：BALE(0)---USAddresslatchenable：系统地址锁存允许
    4、SYSCLK(0)---SYSTEMCLOCK系统时钟信号
    5、IR23~7,9~12,15(Z)---这是用于I/O设备通过中断控制器向CPU发送的中断请求(interruptrequest)信号
    6、SMEMR#和SMEMW#(0)---这是命令内存将数据送至数据总线的信号
    7、MEMR#和MEMW#(I/O)---内存读（MEMR）或内存写（MEMW#)信号
    8、DRQ0~3,5~7⑵---这是DMA请求（DMARequesc)信号
    9、DACK0#~3,5~7(0)---(DMAAcknowledge,DMA响应）这是对DRQ0~3,5~7的响应信号
    10、AEN(0)---地址允许（Addressenable)信号
    11、REFRESH#(I/O)---内存刷新(DRAMrefresh)信号
    12、SBHE(I/O)---系统总线字节允许（systembushighenable）信号
    13、MASTER⑵---主控信号
    14、MEMCS16#⑵---存储器16位片选(Memory16bitchipselect)信号
    15、ZOCS16#⑵---I/O16位片选(I/O16bitchipselect)信号
    16、OWS⑵---零等待状态(ZeroWaitState)信号
    

这里就可以发现不同的针脚对应着不同的功能了。之所以这么设计，是因为cpu 能做的事情很简单，不可能比如说几个针脚不同组合就完成控制总线的功能。

cpu 不需要复杂组合的组合，特定的针脚不同的电信号就是不同的不同的功能。

然后这里就会发现一个问题哈，那就是cpu 怎么知道把地址传给谁？去哪里取呢？

其实在cpu 的视角和软件视角不一样，cpu的视角是将整个内存看做一整块的内存，而不是几个不同硬件的内存，操作不同位置的内存，就是操控不同的硬件设备。

这个就要从主板说起。

在每一台pc机中，都有一个主板，主板有核心器件和一些主要主要器件。

这些器件通过总线（地址总线、数据总线、控制总线）相连。

接口卡： 计算机系统中，所有可用程序控制其工作的设备，必须收到cpu控制。

cpu 对外部不能直接控制，如显示器、音响、打印机等。 直接控制这些设备进行工作的是插在扩展插槽上的接口卡。

各类存储器芯片： 从读写属性上分为两类。

随机存储器（RAM） 和只读存储器。

内存条这种就是随机存储器，特点就是断电之后会没掉。

只读存储器，比如装有rom的bios。 这个rom 的全称那就是read only memory。

bios：bisic input/output system,基本输入输出系统。

bios 是由主板和各类接口卡(如：显卡、网卡等)厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。

在主板和某些接口卡上插有存储相应的bios的rom。

这里很多人都以为只有主板有bios？ 显卡、网卡都有的。

为什么显卡和网卡会有bios？想这样一个问题，那就是cpu将数据传给显卡，显卡如果没有bios，那么怎么处理？GPU没有程序它能知道怎么运行？对吧。

他们有自己的程序，去操作硬件的。cpu 擅长做的还是central processsing unit，重要处理器，相当于人类的大脑了。

其他部件相当于手脚，手脚里面有自己的处理哈。

从功能和连接分类：

1.  随机存储ram
2.  装有bios的rom
3.  接口卡上的ram（显存）

ram 全称， random access memory。

什么叫access哈，因为write 和 read，所以叫做access哈。

![](https://img2022.cnblogs.com/blog/1289794/202205/1289794-20220521211810105-1648713715.png)

上述的那些存储器在物理上是独立的器件。

但是他们在以下两点相同：

1.  都和cpu的总线相接。
2.  cpu对它们进行读或者写的时候都通过控制总线发出内存读写命令。

对于cpu 来说并不知道那个内存是哪个的。

![](https://img2022.cnblogs.com/blog/1289794/202205/1289794-20220521212847258-1020457715.png)

对于cpu来说他们是一个整体的概念。

他们在启动的时候会告诉cpu他们的大小是多少，cpu也只是知道，但也不知道怎么处理，知道发给哪个的是操作系统的事。

比如操作系统要刷新显卡，那么会发送到显卡的地址。操作系统怎么知道位置的？ cpu 告诉的。

所以我们想加一个内存的时候，开机的时候插进去没有反应，这个要重启才会生效。

假设，上图中的内存空间地址段分配如下：

地址0~7FFFH空间为主随机存储器的地址空间。

地址8000H\_9FFFH的8kb 空间为显存地址空间。

地址A000H~FFFFH 的24kb 空间为各个rom的空间地址值。

8086pc的内存地址空间分配:

![](https://img2022.cnblogs.com/blog/1289794/202205/1289794-20220521213905448-232394274.png)

### 结

以上为个人整理，如有错误望请指出。该系列为ce（游戏辅助）的前置系列。