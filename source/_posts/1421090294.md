---
layout: post
title: "java 分布式游戏服务器框架，集群游戏服务器框架，游戏服务器网关框架 ioGame 网络游戏服务器框架"
date: "2022-11-18T14:18:14.952Z"
---
java 分布式游戏服务器框架，集群游戏服务器框架，游戏服务器网关框架 ioGame 网络游戏服务器框架
====================================================

ioGame
------

**国内首个基于蚂蚁金服 SOFABolt 的 java 网络游戏服务器框架；无锁异步化、事件驱动的架构设计**

**通过 ioGame 可以很容易的搭建出一个集群无中心节点、有状态多进程的分步式游戏服务器**

**无中间件依赖、代码即文档、JSR380、断言 + 异常机制 = 更少的维护成本、开发成本**

**同样的一套业务代码无需变更，可以同时支持多种协议：websocket、socket**

**轻量级、启动快、更节约、更简单、开箱即用、无配置文件、超高性能**

**近原生的快、业务框架平均每秒可以执行 1152 万次业务逻辑**

**在业务开发中自带神级特性：业务代码访问定位与跳转**

**架构部署多样性：即可相互独立，又可相互融合**

**各个逻辑服之间可以相互的进行跨进程通信**

**可同时与同类型多个游戏逻辑服通信**

**支持玩家动态绑定逻辑服节点**

**对webMVC开发者友好**

**无 spring 强依赖**

* * *

### **最小依赖**

ioGame 已经上传到中央仓库

[https://search.maven.org/search?q=a:bolt-run-one](https://search.maven.org/search?q=a:bolt-run-one)

ioGame 是轻量级的网络游戏服务器框架，ioGame 没有中间件的强依赖，即无需安装任何其他的中间件产品；此时，你只需一个依赖即可获得整个框架，并同时支持开头介绍的全部功能特性。

<dependency>
    <groupId>com.iohao.game</groupId>
    <artifactId>bolt-run-one</artifactId>
    <version>${ioGame.version}</version>
</dependency>

将变量 ${ioGame.version} 替换成最新版本就可以了。

* * *

愿景
--

让网络游戏服务器的编程变得轻松简单！

网络游戏框架简介
--------

ioGame 是一个由 **java** 语言编写的**网络游戏服务器框架**。支持 websocket、tcp ，适用于**全球同服**、回合制游戏、策略游戏、即时战斗等游戏服务器的开发。具有高性能、稳定、易用易扩展、超好编程体验等特点。可做为 H5、手游、端游的 java 游戏服务器。

ioGame 是轻量级的网络游戏服务器框架，在使用 ioGame 时，只需一个依赖即可获得整个框架，而无需在安装其他服务，如： Nginx、Redis、MQ、Mysql、ZooKeeper、Protobuf协议编译工具 ... ...等。简单点说，就是无需安装其他产品，就能支持开头介绍的内容特性；这意味着在使用上简单了，在部署上也为企业节约了成本。

通过 ioGame 你可以很容易的搭建出一个稳定、高性能、集群无中心节点、分步式、自带负载均衡、跨进程通信、避免类爆炸设计的网络游戏服务器。游戏框架借助于蚂蚁金服 [sofa-bolt](https://www.sofastack.tech/projects/sofa-bolt/overview/) 通信框架来提供通信方面的稳定与高性能。

在 ioGame 中能让你遗忘 Netty，你几乎没有机会能直接的接触到 Netty 的**复杂**，但却能享受 Netty 带来的**高性能**。对开发者要求极低，为开发者节约开发时间。

即使之前没有游戏编程的经验，也能参与到游戏编程中。如果你之前具备一些游戏开发或者 webMVC 相关的知识，则会更容易上手游戏服务器的开发。

开发者基于 ioGame 编写的项目、模块通常是条理清晰的，得益于框架对路由的合理设计。当我们整理好这些模块后，对于其他开发者接管项目或后续的维护中，会是一个不错的帮助（[模块的整理与建议](https://www.yuque.com/iohao/game/ruaqza/#OBwXQ)）。

基于 ioGame 编写的项目，通常是语法简洁的、高性能的、低延迟的。框架最低要求使用 JDK17，这样即可以让项目享受到 ZGC 带来的改进，还能享受语法上的简洁。从 JDK17 开始 GC 已经处理得越来越好了，JDK17 中的 ZGC 远低于其亚毫秒级暂停时间的目标；当开发者使用 JDK17 时，相当于在你们的项目中变相的引入了一位 JVM 调优大师，详细请看 [JDK17 垃圾回收GC性能飞跃提升](https://www.jdon.com/57736)。

在部署上，支持多服单进程的方式部署（类似单体应用、在分步式开发时，调试更加方便）、也支持多服多进程多机器的方式部署。在部署方式上可以随意切换，而不需要更改代码；日常中按照单体思维开发，在生产上可以使用多进程的方式部署；当然，也可以使用单进程的方式部署。

ioGame 框架职责清晰、业务开发几乎零学习成本、源码有高质量注释、示例多、使用文档多，开发体验最佳、业务代码自动生成与游戏前端对接的文档、逻辑服之间可跨进程跨机器通信、业务代码定位--神级特性、异常机制。提供了丰富的在线高质量使用文档，为你的团队助力，带上你们的小伙伴一起，这样就不用手把手的教了。

ioGame 可以很方便的与 spring 集成（5 行代码）。

综上，ioGame 屏蔽了很多复杂且重复性的工作；超棒的开发体验，使用简单，无中间件依赖，只需一个依赖即可获得整个框架；减少了学习成本、减少了使用成本、减少了开发者的工作量、减少了项目的运维成本。并可为项目中的功能模块结构、开发流程等进行清晰的组织定义，减少了后续的项目维护成本。从而让开发团队更方便快捷高效的开发游戏项目。

* * *

架构简图
----

![](https://img2022.cnblogs.com/blog/2927290/202211/2927290-20221118193204507-1230051436.png)

通过 ioGame 你可以很容易的搭建出一个集群、分步式的网络游戏服务器！

无锁异步化与事件驱动的架构设计、集群无中心节点、自带负载均衡、分布式支持、可动态增减机器、避免类爆炸的设计；

图中的每个游戏对外服、每个游戏逻辑服、每个 broker （游戏网关）都可以在单独的进程中部署，逻辑服之间可以跨进程通信（游戏对外服也是逻辑服的一种）。

**游戏网关集群**

broker （游戏网关）可以**集群**的方式部署，集群无中心节点、自带负载均衡。ioGame 本身就包含服务注册，你不需要外接一个服务注册中心，如 Eureka，ZooKeeper 等（变相的节约服务器成本）。

通过 broker （游戏网关） 的介入，之前非常复杂的负载均衡设计，如服务注册、健康度检查（后续版本提供）、到服务端的连接维护等这些问题，在 ioGame 中都不需要了，结构也简单了很多。实际上单台 broker （游戏网关） 性能已经能够满足了，因为游戏网关只做了转发。

**逻辑服**

逻辑服通常说的是游戏对外服和游戏逻辑服。逻辑服可以有很多个，逻辑服扩展数量的理论上限是 netty 的连接上限。

**游戏对外服**

对外服保持与用户（玩家）的长连接。先来个假设，假如我们的一台硬件支持我们建立用户连接的上限是 5000 人，当用户量达到 7000 人时，我们可以多加一个对外服务器来进行分流减压。由于游戏对外服扩展的简单性，意味着支持同时在线玩家可以轻松的达到百万、千万甚至更多。

即使我们启动了多个游戏对外服，开发者也不需要关心这些玩家连接到了哪个游戏对外服的问题，这些玩家总是能接收到广播（推送）消息的，因为框架已经把这些事情给做了；在玩家的角度我们只有“一个”服务器，同样的，在开发者的角度我们只有“一个”游戏对外服；

**在结构组合上（部署多样性）**

在部署上，支持多服单进程的方式部署（类似单体应用、在分步式开发时，调试更加方便）、也支持多服多进程多机器的方式部署。

架构由三部分组成：1.游戏对外服、2.Broker（游戏网关）、3.游戏逻辑服；**三者既是相互独立的，又是可以相互融合的**（相互独立、相互融合；话虽简单，实际实现却不简单）。如：

*   游戏对外服、Broker（游戏网关）、游戏逻辑服这三部分，在一个进程中；【单体应用；在开发分步式时，调试更加方便】
*   游戏对外服、Broker（游戏网关）、游戏逻辑服这三部分，在多个进程中；【分布式】
*   游戏对外服、Broker（游戏网关）这两部分在一个进程中；而游戏逻辑服在多个进程中；【类似之前游戏的传统架构】
*   甚至可以不需要游戏对外服，只使用Broker（游戏网关）和游戏逻辑服这两部分，用于其他系统业务；

因为 ioGame 遵循面向对象的设计原则（单一职责原则、开闭原则、里式替换原则、依赖倒置原则、接口隔离原则、迪米特法则）等，所以使得架构的职责分明，可以灵活的进行组合；

游戏对外服是架构的三部分之一，默认的游戏对外服是基于 netty 实现的。如果有需要，将来我们还可以使用基于 [mina](https://mina.apache.org/)、[smart-socket](https://gitee.com/smartboot/smart-socket) 等通信框架编写，额外提供一个游戏对外服的实现；即使是使用 [mina](https://mina.apache.org/)、[smart-socket](https://gitee.com/smartboot/smart-socket) 提供的游戏对外服，也并不会影响现有的游戏逻辑服业务逻辑，因为游戏对外服满足单一职责原则，只维护用户（玩家）长连接相关的。

开发人员几乎都遇见过这么一种情况；在项目初期阶段，通常是以单体项目的方式进行开发，随着需求不断的增加与迭代，会演变成一个臃肿的项目；此时在对一个整体进行拆分是困难的，成本是极高的。甚至是不可完成的，最后导致完全的重新重构；

ioGame 提供了在结构组合上的部署多样性，通过组合的方式，在项目初期就可以避免这些拆分问题。在开发阶段中，我们可以使用单体应用开发思维，降低了开发成本。通过单体应用的开发方式，在开发分步式项目时，调试更加的方便；这既能兼顾分步式开发、项目模块的拆分，又能降低团队的开发成本；

**架构优点**

架构有很高程度的抽象，让设计者更加关注于业务，而无需考虑底层的实现、通信参数等问题。

逻辑服的位置透明性；同时，由于模块化、抽象化，使得整个架构各服务器之间耦合度很低，逻辑服注册即可用，大大增加了可伸缩性、可维护性，动态扩展变得简单而高效。由于逻辑服是注册到 Broker（游戏网关） 上的，所以逻辑服可以动态的增加、删除、改变；由于逻辑服之间耦合度较小，调试和测试的工作也是可控的；

架构比较清晰的就是，游戏对外服负责维护客户端的接入（用户、玩家的连接），游戏逻辑服专心负责业务逻辑，他们之间的调度由 Broker（游戏网关）来负责；因为架构拆分的合理，所以特别方便用 k8s 来自由伸缩部署这三种服，哪个服水位高就扩容哪个，水位过去了又可以缩容。

* * *

ioGame 支持的通讯方式
--------------

![](https://img2022.cnblogs.com/blog/2927290/202211/2927290-20221118193329158-1549719025.png)

ioGame 支持 3 种类型的通讯方式，分别是**单次请求处理、推送、逻辑服间**的相互通信；下面分别对这 3 种类型的通讯方式相关的应用场景举几个例子。

框架对这 3 种类型的通讯方式提供了代码调用点的日志，简单点说就是框架可以让开发者知道，是在哪一行代码中触发的业务逻辑。

我们可以想象一下，假如框架没有提供代码调用点的日志会是什么样的；比如，游戏前端发送一个业务请求到游戏服务器中，但是处理这个请求的业务方法，会触发多个响应（通常是推送、广播）给游戏前端。一但时间久了，开发者是很难知道分别响应了哪些业务数据给游戏前端，特别是一些二手项目；所以这将是一个灾难性的问题，因为这会耗费大量的时间来寻找这些相关的业务代码。

* * *

快速入门
----

### 业务交互简图

![](https://img2022.cnblogs.com/blog/2927290/202211/2927290-20221118193441294-1596415438.jpg)

抽象的说，游戏前端与游戏服务器的的交互由上图组成。游戏前端与游戏服务器可以自由的双向交互，交互的业务数据由 .proto 作为载体。协议文件是对业务数据的描述载体，用于游戏前端与游戏服务器的数据交互。

当游戏前端和游戏服务端建立了连接后，就可以开始相互传递业务数据，处理各自的业务了。好了，看完业务交互介绍后，开始编写一个游戏业务处理示例吧，接下来我们先定一个业务数据协议。

**协议文件**

协议文件是对业务数据的描述载体，用于游戏前端与游戏服务器的数据交互。Protocol Buffers 是Google公司开发的一种数据描述语言，也简称 [PB](https://www.oschina.net/p/protocol+buffers)。当然协议文件描述还可以是 json、xml或者任意自定义的，因为最后传输时会转换为二进制，但游戏开发中 PB 是目前的最佳。

**游戏前端**

游戏前端的展现可以是 [Unity](https://unity.cn/)、 [UE(虚幻)](https://www.unrealengine.com/zh-CN/)、 [Cocos](https://www.cocos.com/)或者其他的游戏引擎。这些游戏引擎只是展现游戏画面的一种形式，数据交互则由通信来完成（TCP、UDP 等）。游戏前端可以是 [Unity](https://unity.cn/)、 [UE(虚幻)](https://www.unrealengine.com/zh-CN/)、 [Cocos](https://www.cocos.com/)或者其他的游戏引擎。

### 快速入门代码示例

这里主要介绍游戏服务器相关的，下面这个示例介绍了服务器编程可以变得如此简单。

**协议文件定义**

首先我们自定义一个协议文件，这个协议文件作为我们的业务载体描述。这个协议是纯java代码编写的，使用的是 jprotobuf，jprotobuf 是对 [google protobuf](https://www.oschina.net/p/protocol+buffers) 的简化使用，性能同等。

可以把这理解成DTO、POJO、业务数据载体等，其主要目的是用于业务数据的传输；

1 /\*\* 请求 \*/
2 @ProtobufClass
3 @FieldDefaults(level = AccessLevel.PUBLIC)
4 public class HelloReq {
5 String name;
6 }

**Action**

游戏服务器的编程，游戏服务器接收业务数据后，对业务数据进行处理；

1 @ActionController(1)
2 public class DemoAction {
3     @ActionMethod(0)
4     public HelloReq here(HelloReq helloReq) {
5         HelloReq newHelloReq = new HelloReq();
6         newHelloReq.name = helloReq.name + ", I'm here ";
7         return newHelloReq;
8 }
9 }

一个方法在业务框架中表示一个 Action（即一个业务动作）。

方法声名的参数是用于接收前端传入的业务数据，在方法 return 时，数据就可以被游戏前端接收到。程序员可以不需要关心业务框架的内部细节。

从上面的示例可以看出，这和普通的 java 类并无区别，同时这种设计方式**避免了类爆炸**。如果只负责编写游戏业务，那么对于业务框架的学习可以到此为止了。

游戏编程就是如此简单！

**问：我可以开始游戏服务****器****的编程了吗？**

是的，你已经可以开始游戏服务器的编程了。

**访问示例（控制台）**

当我们访问 here 方法时（通常由游戏前端来请求），控制台将会打印

┏━━━━━ Debug. \[(DemoAction.java:4).here\] ━━━ \[cmd:1 - subCmd:0 - cmdMerge:65536\]
┣ userId : 888
┣ 参数: helloReq : HelloReq(name\=塔姆)
┣ 响应: HelloReq(name\=塔姆, I'm here )
┣ 时间: 0 ms (业务方法总耗时)
┗━━━━━ Debug \[DemoAction.java\] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**控制台打印说明**

Debug. \[(DemoAction.java:4).here\]：
表示执行业务的是 DemoAction 类下的 here 方法，4 表示业务方法所在的代码行数。
在工具中点击控制台的 DemoAction.java:4 这条信息，就可以跳转到对应的代码中（快速导航到对应的代码），这是一个开发良好体验的开始！

userId :  
当前发起请求的 用户 id。

参数 :  
通常是游戏前端传入的值。

响应：
通常是业务方法返回的值 ，业务框架会把这个返回值推送到游戏前端。

时间：
执行业务方法总耗时，我们可根据业务方法总耗时的时长来优化业务。

路由信息：\[cmd - subCmd\]
路由是唯一的访问地址。

有了以上信息，游戏开发者可以很快的定位问题。如果没有可视化的信息，开发中会浪费很多时间在前后端的沟通上。问题包括：

*   是否传参问题 （游戏前端说传了）
*   是否响应问题（游戏后端说返回了）
*   业务执行时长问题 （游戏前端说没收到响应， 游戏后端说早就响应了）

其中代码导航可以让开发者快速的跳转到业务类对应代码中，在多人合作的项目中，可以快速的知道业务经过了哪些方法的执行，使得我们可以快速的进行阅读或修改；

适合人群？
-----

1.  长期从事 web 内部系统开发人员， 想了解游戏的
2.  刚从事游戏开发的
3.  未从事过游戏开发，但却对其感兴趣的
4.  对设计模式在实践中的应用和 sofa-bolt 有兴趣的学习者
5.  可以接受新鲜事物的
6.  想放弃祖传代码的

推荐实际编程经验一年以上的人员