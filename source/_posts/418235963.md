---
layout: post
title: "å…¶å® Gradle Transform å°±æ˜¯ä¸ªçº¸è€è™ â€”â€” Gradle ç³»åˆ—(4)"
date: "2022-05-18T06:24:51.161Z"
---
å…¶å® Gradle Transform å°±æ˜¯ä¸ªçº¸è€è™ â€”â€” Gradle ç³»åˆ—(4)
==========================================

å‰è¨€
--

ç›®å‰ï¼Œä½¿ç”¨ AGP Transform API è¿›è¡Œå­—èŠ‚ç æ’æ¡©å·²ç»éå¸¸æ™®éäº†ï¼Œä¾‹å¦‚ Boosterã€ç¥ç­–ç­‰æ¡†æ¶ä¸­éƒ½æœ‰ Transform çš„å½±å­ã€‚Transform å¬èµ·æ¥å¾ˆé«˜å¤§ä¸Šï¼Œå…¶æœ¬è´¨å°±æ˜¯ä¸€ä¸ª Gradle Taskã€‚åœ¨è¿™ç¯‡æ–‡ç« é‡Œï¼Œæˆ‘å°†å¸¦ä½ ç†è§£ Transform çš„å·¥ä½œæœºåˆ¶ã€ä½¿ç”¨æ–¹æ³•å’Œæ ¸å¿ƒæºç è§£æï¼Œå¹¶é€šè¿‡ä¸€ä¸ª Demo å¸®åŠ©ä½ èä¼šè´¯é€šã€‚

è¿™ç¯‡æ–‡ç« æ˜¯å…¨é¢æŒæ¡ Gradle æ„å»ºç³»ç»Ÿç³»åˆ—çš„ç¬¬ 4 ç¯‡ï¼š

*   [1ã€Gradle åŸºç¡€](https://juejin.cn/post/7092367604211253256)
*   [2ã€Gradle æ’ä»¶](https://juejin.cn/post/7098383560746696718/)
*   3ã€Gradle ä¾èµ–ç®¡ç†
*   [4ã€APG Transform](https://juejin.cn/post/7098752199575994405/)

> è¯·ç‚¹èµåŠ å…³æ³¨ï¼Œä½ çš„æ”¯æŒå¯¹æˆ‘éå¸¸é‡è¦ï¼Œæ»¡è¶³ä¸‹æˆ‘çš„è™šè£å¿ƒã€‚  
> ğŸ”¥ Hiï¼Œæˆ‘æ˜¯å°å½­ã€‚æœ¬æ–‡å·²æ”¶å½•åˆ° GitHub Â· Android-NoteBook ä¸­ã€‚è¿™é‡Œæœ‰ Android è¿›é˜¶æˆé•¿çŸ¥è¯†ä½“ç³»ï¼Œæœ‰å¿—åŒé“åˆçš„æœ‹å‹ï¼Œæ¬¢è¿è·Ÿç€æˆ‘ä¸€èµ·æˆé•¿ã€‚ï¼ˆè”ç³»æ–¹å¼åœ¨ GitHubï¼‰

* * *

1\. è®¤è¯† Transform
----------------

### 1.1 ä»€ä¹ˆæ˜¯ Transformï¼Ÿ

Transform API æ˜¯ Android Gradle Plugin 1.5 å°±å¼•å…¥çš„ç‰¹æ€§ï¼Œä¸»è¦ç”¨äºåœ¨ Android æ„å»ºè¿‡ç¨‹ä¸­ï¼Œåœ¨ Classâ†’Dex è¿™ä¸ªèŠ‚ç‚¹ä¿®æ”¹ Class å­—èŠ‚ç ã€‚åˆ©ç”¨ Transform APIï¼Œæˆ‘ä»¬å¯ä»¥æ‹¿åˆ°æ‰€æœ‰å‚ä¸æ„å»ºçš„ Class æ–‡ä»¶ï¼Œå€ŸåŠ© Javassist æˆ– ASM ç­‰å­—èŠ‚ç ç¼–è¾‘å·¥å…·è¿›è¡Œä¿®æ”¹ï¼Œæ’å…¥è‡ªå®šä¹‰é€»è¾‘ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œè¿™äº›è‡ªå®šä¹‰é€»è¾‘æ˜¯ä¸ä¸šåŠ¡é€»è¾‘æ— å…³çš„ã€‚

ä½¿ç”¨ Transform çš„å¸¸è§çš„åº”ç”¨åœºæ™¯æœ‰ï¼š

*   **åŸ‹ç‚¹ç»Ÿè®¡ï¼š** åœ¨é¡µé¢å±•ç°å’Œé€€å‡ºç­‰ç”Ÿå‘½å‘¨æœŸä¸­æ’å…¥åŸ‹ç‚¹ç»Ÿè®¡ä»£ç ï¼Œä»¥ç»Ÿè®¡é¡µé¢å±•ç°æ•°æ®ï¼›
*   **è€—æ—¶ç›‘æ§ï¼š** åœ¨æŒ‡å®šæ–¹æ³•çš„å‰åæ’å…¥è€—æ—¶è®¡ç®—ï¼Œä»¥è§‚å¯Ÿæ–¹æ³•æ‰§è¡Œæ—¶é—´ï¼›
*   **æ–¹æ³•æ›¿æ¢ï¼š** å°†æ–¹æ³•è°ƒç”¨æ›¿æ¢ä¸ºè°ƒç”¨å¦ä¸€ä¸ªæ–¹æ³•ã€‚

![](https://img2022.cnblogs.com/blog/2839502/202205/2839502-20220518135350261-807097058.png)

### 1.2 Transform çš„åŸºæœ¬åŸç†

å…ˆå¤§æ¦‚äº†è§£ä¸‹ Transform çš„å·¥ä½œæœºåˆ¶ï¼š

*   **1ã€å·¥ä½œæ—¶æœºï¼š** Transform å·¥ä½œåœ¨ Android æ„å»ºä¸­ç”± Class â†’ Dex çš„èŠ‚ç‚¹ï¼›
*   **2ã€å¤„ç†å¯¹è±¡ï¼š** å¤„ç†å¯¹è±¡åŒ…æ‹¬ Javac ç¼–è¯‘åçš„ Class æ–‡ä»¶ã€Java æ ‡å‡† resource èµ„æºã€æœ¬åœ°ä¾èµ–å’Œè¿œç¨‹ä¾èµ–çš„ JAR/AARã€‚Android èµ„æºæ–‡ä»¶ä¸å±äº Transform çš„æ“ä½œèŒƒå›´ï¼Œå› ä¸ºå®ƒä»¬ä¸æ˜¯å­—èŠ‚ç ï¼›
*   **3ã€Transform Taskï¼š** æ¯ä¸ª Transform éƒ½å¯¹åº”ä¸€ä¸ª Taskï¼ŒTransform çš„è¾“å…¥å’Œè¾“å‡ºå¯ä»¥ç†è§£ä¸ºå¯¹åº” Transform Task çš„è¾“å…¥è¾“å‡ºã€‚æ¯ä¸ª TransformTask çš„è¾“å‡ºéƒ½åˆ†åˆ«å­˜å‚¨åœ¨ `app/build/intermediates/transform/[Transform Name]/[Variant]` æ–‡ä»¶å¤¹ä¸­ï¼›
*   **4ã€Transform é“¾ï¼š** TaskManager ä¼šå°†æ¯ä¸ª TransformTask ä¸²è”èµ·æ¥ï¼Œå‰ä¸€ä¸ª Transform çš„è¾“å‡ºä¼šä½œä¸ºä¸‹ä¸€ä¸ª Transform çš„è¾“å…¥ã€‚

### 1.3 **Transform API**

äº†è§£ Transform çš„åŸºæœ¬å·¥ä½œæœºåˆ¶åï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ Transform çš„æ ¸å¿ƒ APIã€‚è¿™é‡Œä»…åˆ—ä¸¾å‡º Transform æŠ½è±¡ç±»ä¸­æœ€æ ¸å¿ƒçš„æ–¹æ³•ï¼Œæœ‰å‡ ä¸ªæ¬¡è¦çš„æ–¹æ³•åé¢å†è¯´ã€‚

`com.android.build.api.transform.java`

    public abstract class Transform {
    
        // æŒ‡å®š Transform çš„åç§°ï¼Œè¯¥åç§°è¿˜ä¼šç”¨äºç»„æˆ Task çš„åç§°
        // æ ¼å¼ä¸º transform[InputTypes]With[name]For[Configuration]
        public abstract String getName();
    
        // ï¼ˆå­µåŒ–ä¸­ï¼‰ç”¨äºè¿‡æ»¤ Variantï¼Œè¿”å› false è¡¨ç¤ºè¯¥ Variant ä¸æ‰§è¡Œ Transform
        public boolean applyToVariant(VariantInfo variant) {
            return true;
        }
    
        // æŒ‡å®šè¾“å…¥å†…å®¹ç±»å‹
        public abstract Set<ContentType> getInputTypes();
    
        // æŒ‡å®šè¾“å‡ºå†…å®¹ç±»å‹ï¼Œé»˜è®¤å– getInputTypes() çš„å€¼
        public Set<ContentType> getOutputTypes() {
            return getInputTypes();
        }
    
        // æŒ‡å®šæ¶ˆè´¹å‹è¾“å…¥å†…å®¹èŒƒç•´
        public abstract Set<? super Scope> getScopes();
    
        // æŒ‡å®šå¼•ç”¨å‹è¾“å…¥å†…å®¹èŒƒç•´
        public Set<? super Scope> getReferencedScopes() {
            return ImmutableSet.of();
        }
    
        // æŒ‡å®šæ˜¯å¦æ”¯æŒå¢é‡ç¼–è¯‘
        public abstract boolean isIncremental();
    
        // æ ¸å¿ƒ API
        public void transform(TransformInvocation transformInvocation)
                throws TransformException, InterruptedException, IOException {
            // åˆ†å‘åˆ°è¿‡æ—¶ APIï¼Œä»¥å…¼å®¹æ—§ç‰ˆæœ¬çš„ Transform
            //noinspection deprecation
            transform(transformInvocation.getContext(), transformInvocation.getInputs(),
                    transformInvocation.getReferencedInputs(),
                    transformInvocation.getOutputProvider(),
                    transformInvocation.isIncremental());
        }
    
        // æŒ‡å®šæ˜¯å¦æ”¯æŒç¼“å­˜
        public boolean isCacheable() {
            return false;
        }
    }
    

### 1.4 ContentType å†…å®¹ç±»å‹

ContentType æ˜¯ä¸€ä¸ªæšä¸¾ç±»æ¥å£ï¼Œè¡¨ç¤ºè¾“å…¥æˆ–è¾“å‡ºå†…å®¹çš„ç±»å‹ï¼Œåœ¨ AGP ä¸­å®šä¹‰äº† `DefaultContentType` å’Œ `ExtendedContentType` ä¸¤ä¸ªæšä¸¾ç±»ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬åœ¨è‡ªå®šä¹‰ Transform æ—¶åªèƒ½ä½¿ç”¨ DefaultContentType ä¸­å®šä¹‰çš„æšä¸¾ï¼Œå³ `CLASSES` å’Œ `RESOURCES` ä¸¤ç§ç±»å‹ï¼Œå…¶å®ƒç±»å‹ä»…ä¾› AGP å†…ç½®çš„ Transform ä½¿ç”¨ã€‚

è‡ªå®šä¹‰ Transform éœ€è¦åœ¨ä¸¤ä¸ªä½ç½®å®šä¹‰å†…å®¹ç±»å‹ï¼š

*   **1ã€Set getInputTypes()ï¼š** æŒ‡å®šè¾“å…¥å†…å®¹ç±»å‹ï¼Œå…è®¸é€šè¿‡ Set é›†åˆè®¾ç½®è¾“å…¥å¤šç§ç±»å‹ï¼›
*   **2ã€Set getOutputTypes()ï¼š** æŒ‡å®šè¾“å‡ºå†…å®¹ç±»å‹ï¼Œé»˜è®¤å– getInputTypes() çš„å€¼ï¼Œå…è®¸é€šè¿‡ Set é›†åˆè®¾ç½®è¾“å‡ºå¤šç§ç±»å‹ã€‚

`ExtendedContentType.java`

    // åŠ å¼ºç±»å‹ï¼Œè‡ªå®šä¹‰ Transform æ— æ³•ä½¿ç”¨
    public enum ExtendedContentType implements ContentType {
    
        // DEX æ–‡ä»¶
        DEX(0x1000),
    
        // Native åº“
        NATIVE_LIBS(0x2000),
    
        // Instant Run åŠ å¼ºç±»
        CLASSES_ENHANCED(0x4000),
    
        // Data Binding ä¸­é—´äº§ç‰©
        DATA_BINDING(0x10000),
    
        // Dex Archive
        DEX_ARCHIVE(0x40000),
        ;
    }
    

`QualifiedContent.java`

    enum DefaultContentType implements ContentType {
    
        // Java å­—èŠ‚ç ï¼ŒåŒ…æ‹¬ Jar æ–‡ä»¶å’Œç”±æºç ç¼–è¯‘äº§ç”Ÿçš„
        CLASSES(0x01),
    
        // Java èµ„æº
        RESOURCES(0x02);
    }
    

åœ¨ TransformManager ä¸­ï¼Œé¢„å®šä¹‰äº†ä¸€éƒ¨åˆ†å†…å®¹ç±»å‹é›†åˆï¼Œå¸¸ç”¨çš„æ˜¯ CONTENT\_CLASS æ“ä½œ Classã€‚

`TransformManager.java`

    public static final Set<ContentType> CONTENT_CLASS = ImmutableSet.of(CLASSES);
    public static final Set<ContentType> CONTENT_JARS = ImmutableSet.of(CLASSES, RESOURCES);
    public static final Set<ContentType> CONTENT_RESOURCES = ImmutableSet.of(RESOURCES);
    

### 1.5 ScopeType ä½œç”¨åŸŸ

ScopeType ä¹Ÿæ˜¯ä¸€ä¸ªæšä¸¾ç±»æ¥å£ï¼Œè¡¨ç¤ºè¾“å…¥å†…å®¹çš„èŒƒç•´ã€‚åœ¨ AGP ä¸­å®šä¹‰äº† `InternalScope` å’Œ `Scope` ä¸¤ä¸ªæšä¸¾ç±»ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬åœ¨è‡ªå®šä¹‰ Transform åªèƒ½ä½¿ç”¨ Scope ä¸­å®šä¹‰çš„æšä¸¾ï¼Œå…¶å®ƒç±»å‹ä»…ä¾› AGP å†…ç½®çš„ Transform ä½¿ç”¨ã€‚

Transform éœ€è¦åœ¨ä¸¤ä¸ªä½ç½®å®šä¹‰è¾“å…¥å†…å®¹èŒƒå›´ï¼š

*   **1ã€Set getScopes() æ¶ˆè´¹å‹è¾“å…¥å†…å®¹èŒƒç•´ï¼š** æ­¤èŒƒå›´çš„å†…å®¹ä¼šè¢«æ¶ˆè´¹ï¼Œå› æ­¤å½“å‰ Transform å¿…é¡»å°†ä¿®æ”¹åçš„å†…å®¹å¤åˆ¶åˆ° Transform çš„ä¸­é—´ç›®å½•ä¸­ï¼Œå¦åˆ™æ— æ³•å°†å†…å®¹ä¼ é€’åˆ°ä¸‹ä¸€ä¸ª Transform å¤„ç†ï¼›
*   **2ã€Set getReferencedScopes() æŒ‡å®šå¼•ç”¨å‹è¾“å…¥å†…å®¹èŒƒç•´ï¼š** é»˜è®¤æ˜¯ç©ºé›†åˆï¼Œæ­¤èŒƒå›´çš„å†…å®¹ä¸ä¼šè¢«æ¶ˆè´¹ï¼Œå› æ­¤ä¸éœ€è¦å¤åˆ¶ä¼ é€’åˆ°ä¸‹ä¸€ä¸ª Transformï¼Œä¹Ÿä¸å…è®¸ä¿®æ”¹ã€‚

`InternalScope.java`

    // å†…éƒ¨ä½¿ç”¨çš„ä½œç”¨åŸŸï¼Œè‡ªå®šä¹‰ Transform æ— æ³•ä½¿ç”¨
    public enum InternalScope implements QualifiedContent.ScopeType {
    
        MAIN_SPLIT(0x10000),
    
        LOCAL_DEPS(0x20000),
    
        FEATURES(0x40000),
        ;
    }
    

`QualifiedContent.java`

    enum Scope implements ScopeType {
    
        // å½“å‰æ¨¡å—
        PROJECT(0x01),
        // å­æ¨¡å—
        SUB_PROJECTS(0x04),
        // å¤–éƒ¨ä¾èµ–ï¼ŒåŒ…æ‹¬å½“å‰æ¨¡å—å’Œå­æ¨¡å—æœ¬åœ°ä¾èµ–å’Œè¿œç¨‹ä¾èµ–çš„ JAR/AAR
        EXTERNAL_LIBRARIES(0x10),
        // å½“å‰å˜ä½“æ‰€æµ‹è¯•çš„ä»£ç ï¼ˆåŒ…æ‹¬ä¾èµ–é¡¹ï¼‰
        TESTED_CODE(0x20),
        // æœ¬åœ°ä¾èµ–å’Œè¿œç¨‹ä¾èµ–çš„ JAR/AARï¼ˆprovided-onlyï¼‰
        PROVIDED_ONLY(0x40),
    }
    

åœ¨ TransformManager ä¸­ï¼Œé¢„å®šä¹‰äº†ä¸€éƒ¨åˆ†ä½œç”¨åŸŸé›†åˆï¼Œå¸¸ç”¨çš„æ˜¯ SCOPE\_FULL\_PROJECT æ‰€æœ‰æ¨¡å—ã€‚**éœ€è¦æ³¨æ„ï¼ŒLibrary æ¨¡å—æ³¨å†Œçš„ Transform åªèƒ½ä½¿ç”¨ Scope.PROJECTã€‚**

`TransformManager.java`

    public static final Set<ScopeType> PROJECT_ONLY = ImmutableSet.of(Scope.PROJECT);
    public static final Set<ScopeType> SCOPE_FULL_PROJECT = ImmutableSet.of(Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES);
    

### 1.6 transform æ–¹æ³•

transform() æ˜¯å®ç° Transform çš„æ ¸å¿ƒæ–¹æ³•ï¼Œæ–¹æ³•çš„å‚æ•°æ˜¯ TransformInvocationï¼Œå®ƒæä¾›äº†æ‰€æœ‰ä¸è¾“å…¥è¾“å‡ºç›¸å…³çš„ä¿¡æ¯ï¼š

    public interface TransformInvocation {
    
        Context getContext();
    
        // æ¶ˆè´¹å‹è¾“å…¥å†…å®¹
        Collection<TransformInput> getInputs();
    
        // å¼•ç”¨å‹è¾“å…¥å†…å®¹
        Collection<TransformInput> getReferencedInputs();
    
        // é¢å¤–è¾“å…¥å†…å®¹
        Collection<SecondaryInput> getSecondaryInputs();
    
        // è¾“å‡ºä¿¡æ¯
        TransformOutputProvider getOutputProvider();
    
        // æ˜¯å¦å¢é‡æ„å»º
        boolean isIncremental();
    }
    

*   **isIncremental()ï¼š** å½“å‰ Transform ä»»åŠ¡æ˜¯å¦å¢é‡æ„å»ºï¼›
*   **getInputs()ï¼š** è·å– TransformInput å¯¹è±¡ï¼Œå®ƒæ˜¯æ¶ˆè´¹å‹è¾“å…¥å†…å®¹ï¼Œå¯¹åº”äº Transform#getScopes() å®šä¹‰çš„èŒƒå›´ï¼›
*   **getReferencedInputs()ï¼š** è·å– TransformInput å¯¹è±¡ï¼Œå®ƒæ˜¯å¼•ç”¨å‹è¾“å…¥å†…å®¹ï¼Œå¯¹åº”äº Transform#getReferenceScope() å®šä¹‰çš„å†…å®¹èŒƒå›´ï¼›
*   **getOutPutProvider()ï¼š** TransformOutputProvider æ˜¯å¯¹è¾“å‡ºæ–‡ä»¶çš„æŠ½è±¡ã€‚

è¾“å…¥å†…å®¹ TransformInput ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼š

*   **DirectoryInput é›†åˆï¼š** ä»¥æºç æ–¹å¼å‚ä¸æ„å»ºçš„è¾“å…¥æ–‡ä»¶ï¼ŒåŒ…æ‹¬å®Œæ•´çš„æºç ç›®å½•ç»“æ„åŠå…¶ä¸­çš„æºç æ–‡ä»¶ï¼›
*   **JarInput é›†åˆï¼š** ä»¥ Jar å’Œ aar ä¾èµ–æ–¹å¼å‚ä¸æ„å»ºçš„è¾“å…¥æ–‡ä»¶ï¼ŒåŒ…å«æœ¬åœ°ä¾èµ–å’Œè¿œç¨‹ä¾èµ–ã€‚

è¾“å…¥å†…å®¹ä¿¡æ¯ TransformOutputProvider æœ‰ä¸¤ä¸ªåŠŸèƒ½ï¼š

*   **deleteAll()ï¼š** å½“ Transform è¿è¡Œåœ¨éå¢é‡æ„å»ºæ¨¡å¼æ—¶ï¼Œéœ€è¦åˆ é™¤ä¸Šä¸€æ¬¡æ„å»ºäº§ç”Ÿçš„æ‰€æœ‰ä¸­é—´æ–‡ä»¶ï¼Œå¯ä»¥ç›´æ¥è°ƒç”¨ deleteAll() å®Œæˆï¼›
*   **getContentLocation()ï¼š** è·å¾—æŒ‡å®šèŒƒå›´+ç±»å‹çš„è¾“å‡ºç›®æ ‡è·¯å¾„ã€‚

`TransformOutputProvider.java`

    public interface TransformOutputProvider {
    
        // åˆ é™¤æ‰€æœ‰ä¸­é—´æ–‡ä»¶
        void deleteAll()
    
        // è·å–æŒ‡å®šèŒƒå›´+ç±»å‹çš„ç›®æ ‡è·¯å¾„
        File getContentLocation(String name,
        Set<QualifiedContent.ContentType> types,
        Set<? super QualifiedContent.Scope> scopes,
        Format format);
    }
    

è·å–è¾“å…¥å†…å®¹å¯¹åº”çš„è¾“å‡ºè·¯å¾„ï¼š

    for (input in transformInvocation.inputs) {
        for (jarInput in input.jarInputs) {
            // è¾“å‡ºè·¯å¾„
            val outputJar = outputProvider.getContentLocation(
                jarInput.name,
                jarInput.contentTypes,
                jarInput.scopes,
                Format.JAR
            )
        }
    }
    

### 1.7 Transform å¢é‡æ¨¡å¼

ä»»ä½•æ„å»ºç³»ç»Ÿéƒ½ä¼šå°½é‡é¿å…é‡å¤æ‰§è¡Œç›¸åŒå·¥ä½œï¼ŒTransform ä¹Ÿä¸ä¾‹å¤–ã€‚è™½ç„¶å¢é‡æ„å»ºå¹¶ä¸æ˜¯å¿…é¡»çš„ï¼Œä½†ä½œä¸ºä¸€ä¸ªåˆæ ¼çš„ Transform å®ç°åº”è¯¥å…·å¤‡å¢é‡èƒ½åŠ›ã€‚

**1ã€å¢é‡æ¨¡å¼æ ‡è®°ä½ï¼š** Transform API æœ‰ä¸¤ä¸ªå¢é‡æ ‡å¿—ä½ï¼Œä¸è¦æ··æ·†ï¼š

*   **Transform#isIncremental()ï¼š** Transform å¢é‡æ„å»ºçš„ä½¿èƒ½å¼€å…³ï¼Œè¿”å› true æ‰æœ‰å¯èƒ½è§¦å‘å¢é‡æ„å»ºï¼›
*   **TransformInvocation#isIncremental()ï¼š** å½“æ¬¡ TransformTask æ˜¯å¦å¢é‡æ‰§è¡Œï¼Œè¿”å› true è¡¨ç¤ºæ­£åœ¨å¢é‡æ¨¡å¼ã€‚

**2ã€Task å¢é‡æ¨¡å¼ä¸ Transform å¢é‡æ¨¡å¼çš„åŒºåˆ«ï¼š** Task å¢é‡æ¨¡å¼ä¸ Transform å¢é‡æ¨¡å¼çš„åŒºåˆ«åœ¨äºï¼ŒTask å¢é‡æ‰§è¡Œæ—¶ä¼šè·³è¿‡æ•´ä¸ª Task çš„åŠ¨ä½œåˆ—è¡¨ï¼Œè€Œ Transform å¢é‡æ‰§è¡Œä¾ç„¶ä¼šæ‰§è¡Œ TransformTaskï¼Œä½†è¾“å…¥å†…å®¹ä¼šå¢åŠ å˜æ›´å†…å®¹ä¿¡æ¯ã€‚

**3ã€å¢é‡æ¨¡å¼çš„è¾“å…¥ï¼š** å¢é‡æ¨¡å¼ä¸‹çš„æ‰€æœ‰è¾“å…¥éƒ½æ˜¯å¸¦çŠ¶æ€çš„ï¼Œéœ€è¦æ ¹æ®è¿™äº›çŠ¶æ€æ¥åšä¸åŒçš„å¤„ç†ï¼Œä¸éœ€è¦æ¯æ¬¡æ‰€æœ‰æµç¨‹éƒ½é‡æ–°æ¥ä¸€éã€‚æ¯”å¦‚æ–°å¢çš„è¾“å…¥å°±éœ€è¦å¤„ç†ï¼Œè€Œæœªä¿®æ”¹çš„è¾“å…¥å°±ä¸éœ€è¦å¤„ç†ã€‚Transform å®šä¹‰äº†å››ä¸ªè¾“å…¥æ–‡ä»¶çŠ¶æ€ï¼š

`com.android.build.api.transform.Status.java`

    public enum Status {
    
        // æœªä¿®æ”¹ï¼Œä¸éœ€è¦å¤„ç†ï¼Œä¹Ÿä¸éœ€è¦å¤åˆ¶æ“ä½œ
        NOTCHANGED,
        
        // æ–°å¢ï¼Œæ­£å¸¸å¤„ç†å¹¶å¤åˆ¶ç»™ä¸‹ä¸€ä¸ªä»»åŠ¡
        ADDED,
        
        // å·²ä¿®æ”¹ï¼Œæ­£å¸¸å¤„ç†å¹¶å¤åˆ¶ç»™ä¸‹ä¸€ä¸ªä»»åŠ¡
        CHANGED,
    		
        // å·²åˆ é™¤ï¼Œéœ€åŒæ­¥ç§»é™¤ OutputProvider æŒ‡å®šçš„ç›®æ ‡æ–‡ä»¶
        REMOVED;
    }
    

### 1.8 æ³¨å†Œ Transform

åœ¨ BaseExtension ä¸­ç»´æŠ¤äº†ä¸€ä¸ª Transform åˆ—è¡¨ï¼Œè‡ªå®šä¹‰ Transform éœ€è¦æ³¨å†Œæ‰èƒ½ç”Ÿæ•ˆï¼Œè€Œä¸”è¿˜æ”¯æŒé¢å¤–è®¾ç½® TransformTask çš„ä¾èµ–ã€‚

`BaseExtension.kt`

    abstract class BaseExtension {
        private val _transforms: MutableList<Transform> = mutableListOf()
        private val _transformDependencies: MutableList<List<Any>> = mutableListOf()
        ...
    
        fun registerTransform(transform: Transform, vararg dependencies: Any) {
            _transforms.add(transform)
            _transformDependencies.add(listOf(dependencies))
        }
    }
    

æ³¨å†Œ Transformï¼š

    // è·å– Android æ‰©å±•
    val androidExtension = project.extensions.getByType(BaseExtension::class.java)
    // æ³¨å†Œ Transformï¼Œæ”¯æŒé¢å¤–å¢åŠ ä¾èµ–
    androidExtension.registerTransform(ToastTransform(project)/* æ”¯æŒå¢åŠ ä¾èµ–*/)
    

> **æç¤ºï¼š** ä¸ºäº†æé«˜ç¼–è¯‘æ•ˆç‡ï¼Œå¯ä»¥åˆ¤æ–­ Variant ä¸º release ç±»å‹æ‰æ³¨å†Œ Transformï¼Œä¹Ÿå¯ä»¥é€šè¿‡é‡å†™ Transform#applyToVariant() æ¥å†³å®šæ˜¯å¦æ‰§è¡Œ Transformã€‚

* * *

2\. Transform æ ¸å¿ƒæºç åˆ†æ
--------------------

è¿™ä¸€èŠ‚æˆ‘ä»¬æ¥åˆ†æ Transform ç›¸å…³æ ¸å¿ƒæºç ï¼Œè¿™é‡Œæˆ‘ä»¬å¼•ç”¨çš„æ˜¯ Android Gradle Plugin 7.1.0 ç‰ˆæœ¬çš„æºç ã€‚

### 2.1 Transform ä¸ Task çš„å…³ç³»

Project çš„æ„å»ºé€»è¾‘ç”±ä¸€ç³»åˆ— Task çš„ç»„æˆï¼Œæ¯ä¸ª Task è´Ÿè´£å®Œæˆä¸€ä¸ªåŸºæœ¬çš„å·¥ä½œï¼Œä¾‹å¦‚ Javac ç¼–è¯‘ Taskã€‚Transform ä¹Ÿæ˜¯ä¾é  Task æ‰§è¡Œçš„ï¼Œåœ¨é…ç½®é˜¶æ®µï¼ŒGradle ä¼šä¸ºæ³¨å†Œçš„ Transform åˆ›å»ºå¯¹åº”çš„ Taskã€‚

> **æç¤ºï¼š** è¯´ â€œåˆ›å»ºâ€ å¯èƒ½ä¸å¤ªä¸¥è°¨ï¼ŒTransformManager ä½¿ç”¨ register æ‡’åˆ›å»ºçš„æ–¹å¼æ³¨å†Œ Taskï¼Œå…¶å®è¿˜æ²¡æœ‰åˆ›å»º Task å®ä¾‹ã€‚æˆ‘ä»¬ä¸è¦å¤æ‚åŒ–äº†ï¼Œå°±è¯´åˆ›å»ºå§ã€‚

è€Œ Task çš„ä¾èµ–å…³ç³»æ˜¯é€šè¿‡ TransformTask çš„è¾“å…¥è¾“å‡ºå…³ç³»éšå¼ç¡®å®šçš„ï¼ŒTransformManager é€šè¿‡ TransformStream é“¾æ¥å„ä¸ª TransformTask çš„è¾“å…¥è¾“å‡ºï¼Œè¿›è€Œæ§åˆ¶ Transform çš„ä¾èµ–å…³ç³»é¡ºåºã€‚

`LibraryTaskManager.java`

    @Override
    protected void doCreateTasksForVariant(ComponentInfo<LibraryVariantBuilderImpl, LibraryVariantImpl> variantInfo) {
        ...
        // ----- External Transforms -----
        // apply all the external transforms.
        List<Transform> customTransforms = extension.getTransforms();
        List<List<Object>> customTransformsDependencies = extension.getTransformsDependencies();
    
        final IssueReporter issueReporter = libraryVariant.getServices().getIssueReporter();
    
        for (int i = 0, count = customTransforms.size(); i < count; i++) {
            Transform transform = customTransforms.get(i);
    
            // Check the transform only applies to supported scopes for libraries:
            // We cannot transform scopes that are not packaged in the library
            // itself.
            Sets.SetView<? super Scope> difference = Sets.difference(transform.getScopes(), TransformManager.PROJECT_ONLY);
            if (!difference.isEmpty()) {
                String scopes = difference.toString();
                issueReporter.reportError(
                        Type.GENERIC,
                        String.format(
                                "Transforms with scopes '%s' cannot be applied to library projects.",
                                scopes));
            }
    
            List<Object> deps = customTransformsDependencies.get(i);
            transformManager.addTransform(
                    taskFactory,
                    libraryVariant,
                    transform,
                    null,
                    task -> {
                        // ï¼ˆ3.2èŠ‚æåˆ°çš„é¢å¤–ä¾èµ–ï¼‰
                        // åœ¨æ³¨å†Œ Transform æ—¶ï¼Œå¯ä»¥é¢å¤–å¢åŠ ä¾èµ–
                        if (!deps.isEmpty()) {
                            task.dependsOn(deps);
                        }
                    },
                    taskProvider -> {
                        // if the task is a no-op then we make assemble task
                        // depend on it.
                        if (transform.getScopes().isEmpty()) {
                            TaskFactoryUtils.dependsOn(
                                    libraryVariant.getTaskContainer().getAssembleTask(),
                                    taskProvider);
                        }
                    });
        }
    
        // Create jar with library classes used for publishing to runtime elements.
        taskFactory.register(new BundleLibraryClassesJar.CreationAction(
                libraryVariant, AndroidArtifacts.PublishedConfigType.RUNTIME_ELEMENTS));
        ...
    }
    

ç½‘ä¸Šå¾ˆå¤šæœ‹å‹æåˆ° â€œè‡ªå®šä¹‰ Transform çš„æ‰§è¡Œæ—¶æœºæ—©äºç³»ç»Ÿå†…ç½® Transformâ€ï¼Œä½†ä» AGP 7.1.0 æºç çœ‹ï¼Œå¹¶ä¸å­˜åœ¨ç³»ç»Ÿ Transformã€‚çŒœæµ‹æ˜¯æ–°ç‰ˆæœ¬ AGP å°†è¿™éƒ¨åˆ† â€œç³»ç»Ÿå†…ç½® Transformâ€ ä¿®æ”¹ä¸ºç”± Task ç›´æ¥å®ç°ï¼Œæ¯•ç«Ÿ ä» AGP 7.0 å¼€å§‹ Transform æ ‡è®°ä¸ºè¿‡æ—¶äº†ã€‚

### 2.2 Transform çš„åˆ›å»ºè¿‡ç¨‹

*   **1ã€æ³¨å†Œ Transformï¼š** æ³¨å†Œ Transform ä»…æ˜¯å°†å¯¹è±¡æ³¨å†Œåˆ° BaseExtension ä¸­çš„åˆ—è¡¨ä¸­ã€‚TransformManager ä¼šé€šè¿‡ Task çš„è¾“å…¥è¾“å‡ºéšå¼å»ºç«‹ Transform çš„ä¾èµ–é¡ºåºï¼Œå¦å¤–è¿˜æ”¯æŒåœ¨æ³¨å†Œæ—¶æ·»åŠ é¢å¤–çš„ä¾èµ–ã€‚

`BaseExtension.kt`

    abstract class BaseExtension {
        private val _transforms: MutableList<Transform> = mutableListOf()
        private val _transformDependencies: MutableList<List<Any>> = mutableListOf()
        ...
    
        fun registerTransform(transform: Transform, vararg dependencies: Any) {
            _transforms.add(transform)
            _transformDependencies.add(listOf(dependencies))
        }
    }
    

*   **2ã€åˆ›å»º TransformTask çš„æ‰§è¡Œé“¾ï¼š** TransformTask å±äº Android æ„å»ºæ„æˆçš„ä¸€éƒ¨åˆ†ï¼Œæ‰€æœ‰ Android Task çš„åˆ›å»ºå…¥å£éƒ½ä» BasePlugin#createAndroidTasks() å¼€å§‹ã€‚å…¶ä¸­ä¼šä¸ºæ‰€æœ‰ Variant å˜ä½“åˆ›å»ºç›¸å…³çš„ Taskï¼Œç»è¿‡ä¸€ç³»åˆ—è°ƒç”¨åï¼Œä¼šé€šè¿‡æŠ½è±¡æ–¹æ³• TaskManager#doCreateTaskForVariant() åˆ†æ´¾åˆ° ApplicationTaskManager å’Œ LibraryTaskManager ä¸¤ä¸ªå­ç±»ä¸­ï¼Œä»¥åŒºåˆ† App æ¨¡å—å’Œ Library æ¨¡å—ã€‚

è°ƒç”¨é“¾æ¦‚è¦ï¼š

    BasePlugin#createAndroidTasks()
    -> TaskManager#createTasks()->éå†æ‰€æœ‰å˜ä½“
    -> for {
        TaskManager#createTasksForVariant(variant)
        -> abstract TaskManager#doCreateTasksForVariant(variant)
        // App
        -> ApplicationTaskManager#doCreateTasksForVariant(variant)
        -> ApplicationTaskManager#createCommonTask(variant)
        -> ApplicationTaskManager#createCompileTask(variant)
        -> TaskManager#createPostCompilationTasks(config)
        -> for { Transform#addTransform(transform) }
        // Library
        -> LibraryTaskManager#doCreateTasksForVariant(variant)
        -> for { Transform#addTransform(transform) }
    }
    

### 2.3 TransformTask çš„å‘½åæ ¼å¼

Transform#getName() ä¼šç”¨äºæ„é€  Task Nameï¼Œå‘½åæ ¼å¼ä¸º `transform[InputTypes]With[name]For[Configuration]`ï¼Œä¾‹å¦‚ transformClassedã€‚è¿™å—æºç ä½“ç°åœ¨ TransformManager ä¸­åˆ›å»º Task çš„ä½ç½®ï¼š

`TransformManager.java`

    // åˆ›å»º Transform Task
    public <T extends Transform> Optional<TaskProvider<TransformTask>> addTransform(...) {
        ...
        // TaskName = å‰ç¼€ + Configuration
        String taskName = creationConfig.computeTaskName(getTaskNamePrefix(transform), "");
        ...
    }
    
    // TaskName å‰ç¼€
    static String getTaskNamePrefix(Transform transform) {
        StringBuilder sb = new StringBuilder(100);
        sb.append("transform");
        sb.append(transform
            .getInputTypes()
            .stream()
            .map(inputType -> CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, inputType.name()))
            .sorted() // Keep the order stable.
            .collect(Collectors.joining("And")));
        sb.append("With");
        StringHelper.appendCapitalized(sb, transform.getName());
        sb.append("For");
    
        return sb.toString();
    }
    

### 2.4 TransformTask çš„è¾“å…¥è¾“å‡º

TransformTask é€šè¿‡ @Input å’Œ @OutputDirectory ç­‰æ³¨è§£ï¼Œå°† Transform API å…³è”åˆ° Task çš„è¾“å…¥è¾“å‡ºä¸Šï¼š

`TransformTask.java`

    public abstract class TransformTask extends StreamBasedTask {
    		
        ...
    		
        @Input
        public Set<QualifiedContent.ContentType> getInputTypes() {
            return transform.getInputTypes();
        }
    
        @OutputDirectory
        @Optional
        public abstract DirectoryProperty getOutputDirectory();
    }
    

### 2.5 æ‰§è¡Œ transform() æ–¹æ³•

æ¯ä¸ª Task å†…éƒ¨éƒ½ä¿æŒäº†ä¸€ä¸ª Action åˆ—è¡¨ `actions`ï¼Œæ‰§è¡Œ Task å°±æ˜¯æŒ‰é¡ºåºæ‰§è¡Œè¿™ä¸ªåˆ—è¡¨ï¼Œå¯¹äºè‡ªå®šä¹‰ Taskï¼Œå¯ä»¥é€šè¿‡ `@TaskAction` æ³¨è§£æ·»åŠ é»˜è®¤ Actionã€‚

`TransformTask.java`

    @TaskAction
    void transform(final IncrementalTaskInputs incrementalTaskInputs) {
        ...
        transform.transform(new TransformInvocationBuilder(context)
          .addInputs(consumedInputs.getValue())
          .addReferencedInputs(referencedInputs.getValue())
          .addSecondaryInputs(changedSecondaryInputs.getValue())
          .addOutputProvider(outputStream != null
              ? outputStream.asOutput()
              : null)
          .setIncrementalMode(isIncremental.getValue())
          .build());
        ...
    }
    

### 2.6 Library æ¨¡å—é™åˆ¶

Library æ¨¡å—ä»…åªæ”¯æŒä½¿ç”¨ Scope.PROJECT ä½œç”¨åŸŸï¼š

`LibraryTaskManager.java`

    // Check the transform only applies to supported scopes for libraries:
    // We cannot transform scopes that are not packaged in the library
    // itself.
    Sets.SetView<? super Scope> difference = Sets.difference(transform.getScopes(), TransformManager.PROJECT_ONLY);
    if (!difference.isEmpty()) {
        String scopes = difference.toString();
        issueReporter.reportError(Type.GENERIC, String.format("Transforms with scopes '%s' cannot be applied to library projects.",scopes));
    }
    

* * *

3\. è‡ªå®šä¹‰ Transform æ¨¡æ¿
--------------------

ä¸Šä¸€èŠ‚æˆ‘ä»¬æ¢è®¨äº† Transform çš„åŸºæœ¬å·¥ä½œæœºåˆ¶ï¼Œç¬¬ 3 èŠ‚å’Œç¬¬ 4 èŠ‚æˆ‘ä»¬æ¥å®ç°ä¸€ä¸ª Transform Demoã€‚Transform çš„æ ¸å¿ƒä»£ç åœ¨ transform() æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬è¦åšçš„å°±æ˜¯éå†è¾“å…¥æ–‡ä»¶ï¼Œå†æŠŠä¿®æ”¹åçš„æ–‡ä»¶å¤åˆ¶åˆ°ç›®æ ‡è·¯å¾„ä¸­ï¼Œå¯¹äº JarInputs è¿˜æœ‰ä¸€æ¬¡è§£å‹å’Œå‹ç¼©ã€‚æ›´è¿›ä¸€æ­¥ï¼Œå†è€ƒè™‘å¢é‡ç¼–è¯‘çš„æƒ…å†µã€‚

å› æ­¤ï¼Œæ•´ä¸ª Transform çš„æ ¸å¿ƒè¿‡ç¨‹æ˜¯æœ‰å›ºå®šå¥—è·¯ï¼Œæ¨¡æ¿æµç¨‹å›¾å¦‚ä¸‹ï¼š

![](https://img2022.cnblogs.com/blog/2839502/202205/2839502-20220518135417993-1738217786.png)

â€”â€” å›¾ç‰‡å¼•ç”¨è‡ª [https://rebooters.github.io/2020/01/04/Gradle-Transform-ASM-æ¢ç´¢/](https://rebooters.github.io/2020/01/04/Gradle-Transform-ASM-%E6%8E%A2%E7%B4%A2/)

æˆ‘ä»¬æŠŠæ•´ä¸ªæµç¨‹å›¾åšæˆä¸€ä¸ªæŠ½è±¡æ¨¡æ¿ç±»ï¼Œå­ç±»éœ€è¦é‡å†™ `provideFunction()` æ–¹æ³•ï¼Œä»è¾“å…¥æµè¯»å– Class æ–‡ä»¶ï¼Œä¿®æ”¹å®Œå­—èŠ‚ç åå†å†™å…¥åˆ°è¾“å‡ºæµã€‚ç”šè‡³ä¸éœ€è¦è€ƒè™‘ Trasform çš„è¾“å…¥æ–‡ä»¶éå†ã€åŠ è§£å‹ã€å¢é‡ç­‰ï¼Œèˆ’æœï¼

`BaseCustomTransform.kt`

    abstract class BaseCustomTransform(private val debug: Boolean) : Transform() {
    
        abstract fun provideFunction(): ((InputStream, OutputStream) -> Unit)?
    
        open fun classFilter(className: String) = className.endsWith(SdkConstants.DOT_CLASS)
    
        override fun isIncremental() = true
    
        override fun transform(transformInvocation: TransformInvocation) {
            super.transform(transformInvocation)
    
            log("Transform start, isIncremental = ${transformInvocation.isIncremental}.")
    
            val inputProvider = transformInvocation.inputs
            val referenceProvider = transformInvocation.referencedInputs
            val outputProvider = transformInvocation.outputProvider
    
            // 1. Transform logic implemented by subclasses.
            val function = provideFunction()
    
            // 2. Delete all transform tmp files when not in incremental build.
            if (!transformInvocation.isIncremental) {
                log("All File deleted.")
                outputProvider.deleteAll()
            }
    
            for (input in inputProvider) {
                // 3. Transform jar input.
                log("Transform jarInputs start.")
                for (jarInput in input.jarInputs) {
                    val inputJar = jarInput.file
                    val outputJar = outputProvider.getContentLocation(jarInput.name, jarInput.contentTypes, jarInput.scopes, Format.JAR)
                    if (transformInvocation.isIncremental) {
                        // 3.1 Transform jar input in incremental build.
                        when (jarInput.status ?: Status.NOTCHANGED) {
                            Status.NOTCHANGED -> {
                                // Do nothing.
                            }
                            Status.ADDED, Status.CHANGED -> {
                                // Do transform.
                                transformJar(inputJar, outputJar, function)
                            }
                            Status.REMOVED -> {
                                // Delete.
                                FileUtils.delete(outputJar)
                            }
                        }
                    } else {
                        // 3.2 Transform jar input in full build.
                        transformJar(inputJar, outputJar, function)
                    }
                }
                // 4. Transform dir input.
                log("Transform dirInput start.")
                for (dirInput in input.directoryInputs) {
                    val inputDir = dirInput.file
                    val outputDir = outputProvider.getContentLocation(dirInput.name, dirInput.contentTypes, dirInput.scopes, Format.DIRECTORY)
                    if (transformInvocation.isIncremental) {
                        // 4.1 Transform dir input in incremental build.
                        for ((inputFile, status) in dirInput.changedFiles) {
                            val outputFile = concatOutputFilePath(outputDir, inputFile)
                            when (status ?: Status.NOTCHANGED) {
                                Status.NOTCHANGED -> {
                                    // Do nothing.
                                }
                                Status.ADDED, Status.CHANGED -> {
                                    // Do transform.
                                    doTransformFile(inputFile, outputFile, function)
                                }
                                Status.REMOVED -> {
                                    // Delete
                                    FileUtils.delete(outputFile)
                                }
                            }
                        }
                    } else {
                        // 4.2 Transform dir input in full build.
                        for (inputFile in FileUtils.getAllFiles(inputDir)) {
                            // Traversal fileTree (depthFirstPreOrder).
                            if (classFilter(inputFile.name)) {
                                val outputFile = concatOutputFilePath(outputDir, inputFile)
                                doTransformFile(inputFile, outputFile, function)
                            }
                        }
                    }
                }
            }
            log("Transform end.")
        }
    
        /**
         * Do transform Jar.
         */
        private fun transformJar(inputJar: File, outputJar: File, function: ((InputStream, OutputStream) -> Unit)?) {
            // Create parent directories to hold outputJar file.
            Files.createParentDirs(outputJar)
            // Unzip.
            FileInputStream(inputJar).use { fis ->
                ZipInputStream(fis).use { zis ->
                    // Zip.
                    FileOutputStream(outputJar).use { fos ->
                        ZipOutputStream(fos).use { zos ->
                            var entry = zis.nextEntry
                            while (entry != null && isValidZipEntryName(entry)) {
                                if (!entry.isDirectory && classFilter(entry.name)) {
                                    zos.putNextEntry(ZipEntry(entry.name))
                                    // Apply transform function.
                                    applyFunction(zis, zos, function)
                                }
                                entry = zis.nextEntry
                            }
                        }
                    }
                }
            }
        }
    
        /**
         * Do transform file.
         */
        private fun doTransformFile(inputFile: File, outputFile: File, function: ((InputStream, OutputStream) -> Unit)?) {
            // Create parent directories to hold outputFile file.
            Files.createParentDirs(outputFile)
            FileInputStream(inputFile).use { fis ->
                FileOutputStream(outputFile).use { fos ->
                    // Apply transform function.
                    applyFunction(fis, fos, function)
                }
            }
        }
    
        private fun concatOutputFilePath(outputDir: File, inputFile: File) = File(outputDir, inputFile.name)
    
        private fun applyFunction(input: InputStream, output: OutputStream, function: ((InputStream, OutputStream) -> Unit)?) {
            try {
                if (null != function) {
                    function.invoke(input, output)
                } else {
                    // Copy
                    input.copyTo(output)
                }
            } catch (e: UncheckedIOException) {
                throw e.cause!!
            }
        }
    
        private fun log(logStr: String) {
            if (debug) {
                println("$name - $logStr")
            }
        }
    }
    

* * *

4\. Hello Transform ç¤ºä¾‹
----------------------

ç°åœ¨ï¼Œæˆ‘æ‰‹æŠŠæ‰‹å¸¦ä½ åŸºäº BaseCustomTransform å®ç°ä¸€ä¸ª Transform Demoã€‚ç¤ºä¾‹ä»£ç æˆ‘å·²ç»ä¸Šä¼ åˆ° [Github Â· DemoHall Â· HelloTransform](https://github.com/pengxurui/DemoHall)ã€‚æœ‰ç”¨è¯·ç»™ä¸ªå…è´¹çš„ Star æ”¯æŒä¸‹ã€‚

Demo æ•ˆæœå¾ˆç®€å•ï¼š

*   å®ç°ä¸€ä¸ª Transformï¼Œåœ¨ç¼–è¯‘æ—¶åœ¨ Activity#onCreate() æ–¹æ³•æœ«å°¾ç»‡å…¥ä¸€ä¸ª Toast è¯­å¥ï¼›
*   ä»…é€šè¿‡è‡ªå®šä¹‰æ³¨è§£ @Hello ä¿®é¥°çš„ Activity#onCreate() æ–¹æ³•ä¼šç”Ÿæ•ˆã€‚

### 4.1 æ­¥éª¤ 1ï¼šåˆå§‹åŒ–ä»£ç æ¡†æ¶

é¦–å…ˆï¼Œæˆ‘ä»¬å…ˆæ­å»ºå·¥ç¨‹çš„æ•´ä½“æ¡†æ¶ï¼Œå†æ¥ç¼–å†™æ ¸å¿ƒçš„ Transform é€»è¾‘ã€‚æˆ‘ä»¬é€‰æ‹©è‡ªå®šä¹‰ Gradle æ’ä»¶æ¥æ‰¿è½½ Transform çš„é€»è¾‘ï¼Œå¯ç»´æŠ¤æ€§æ›´å¥½ã€‚å…³äºè‡ªå®šä¹‰ Gradle æ’ä»¶çš„æ­¥éª¤å…·ä½“è§ä¸Šä¸€ç¯‡æ–‡ç« [ã€Šæ‰‹æŠŠæ‰‹å¸¦ä½ è‡ªå®šä¹‰ Gradle æ’ä»¶ã€‹](https://juejin.cn/post/7098383560746696718)ï¼Œæ­¤å¤„ä¸å±•å¼€ã€‚

> **æç¤ºï¼š** æé†’ä¸€ä¸‹ï¼Œå¹¶ä¸æ˜¯è¯´ä¸€å®šè¦ç”± Gradle æ’ä»¶æ¥æ‰¿è½½ï¼Œä½ ç›´æ¥åœ¨ .gradle æ–‡ä»¶ä¸­å®ç°ä¹Ÿæ˜¯ OK çš„ã€‚

æ’ä»¶å®ç°ç±»å¦‚ä¸‹ï¼š

`ToastPlugin.kt`

    class ToastPlugin : Plugin<Project> {
        override fun apply(project: Project) {
            // è·å– Android æ‰©å±•
            val androidExtension = project.extensions.getByType(BaseExtension::class.java)
            // æ³¨å†Œ Transformï¼Œæ”¯æŒé¢å¤–å¢åŠ ä¾èµ–
            androidExtension.registerTransform(ToastTransform(project)/* æ”¯æŒå¢åŠ ä¾èµ–*/)
        }
    }
    

### 4.2 æ­¥éª¤ 2ï¼šæ‹·è´ Transform æ¨¡æ¿ç±»

å°†æˆ‘ä»¬å®ç°çš„ BaseCustomTransform æ¨¡æ¿ç±»å¤åˆ¶åˆ°å·¥ç¨‹ä¸‹ï¼Œå†å®ç°ä¸€ä¸ªå­ç±»ï¼š

`ToastTransform.kt`

    internal class ToastTransform(val project: Project) : BaseCustomTransform(true) {
    
        // Transform å
        override fun getName() = "ToastTransform"
    
        // æ˜¯å¦æ”¯æŒå¢é‡æ„å»º
        override fun isIncremental() = true
    
        /**
         * ç”¨äºè¿‡æ»¤ Variantï¼Œè¿”å› false è¡¨ç¤ºè¯¥ Variant ä¸æ‰§è¡Œ Transform
         */
        @Incubating
        override fun applyToVariant(variant: VariantInfo?): Boolean {
            return "debug" == variant?.buildTypeName
        }
    
        // æŒ‡å®šè¾“å…¥å†…å®¹ç±»å‹
        override fun getInputTypes() = TransformManager.CONTENT_CLASS
    
        // æŒ‡å®šæ¶ˆè´¹å‹è¾“å…¥å†…å®¹èŒƒç•´
        override fun getScopes() = TransformManager.SCOPE_FULL_PROJECT
    
        // è½¬æ¢æ–¹æ³•
        override fun provideFunction() = { ios: InputStream, zos: OutputStream ->
            input.copyTo(output)
        }
    }
    

**å…¶ä¸­ï¼ŒprovideFunction() æ˜¯æ¨¡æ¿ä»£ç ï¼Œå‚æ•°åˆ†åˆ«è¡¨ç¤ºæº Class æ–‡ä»¶çš„è¾“å…¥æµå’Œç›®æ ‡ Class æ–‡ä»¶è¾“å‡ºæµã€‚å­ç±»è¦åšçš„äº‹ï¼Œå°±æ˜¯ä»è¾“å…¥æµè¯»å– Class ä¿¡æ¯ï¼Œä¿®æ”¹åå†™å…¥åˆ°è¾“å‡ºæµã€‚**

### 4.3 æ­¥éª¤ 3ï¼šä½¿ç”¨ Javassist ä¿®æ”¹å­—èŠ‚ç 

ä½¿ç”¨ Javassist API ä»è¾“å…¥æµåŠ è½½æ•°æ®ï¼Œåœ¨åŒ¹é…åˆ° onCreate() æ–¹æ³•åæ£€æŸ¥æ˜¯å¦å£°æ˜ @Hello æ³¨è§£ã€‚æ˜¯åˆ™åœ¨è¯¥æ–¹æ³•æœ«å°¾ç»‡å…¥ä¸€å¥ Toastï¼šHello Transformã€‚æœ¬æ–‡é‡ç‚¹ä¸æ˜¯ Javassistï¼Œæ­¤å¤„å°±ä¸å±•å¼€äº†ã€‚

    override fun provideFunction() = { ios: InputStream, zos: OutputStream ->
        val classPool = ClassPool.getDefault()
        // åŠ å…¥android.jar
        classPool.appendClassPath((project.extensions.getByName("android") as BaseExtension).bootClasspath[0].toString())
        classPool.importPackage("android.os.Bundle")
        // Input
        val ctClass = classPool.makeClass(ios)
        try {
            ctClass.getDeclaredMethod("onCreate").also {
                println("onCreate found in ${ctClass.simpleName}")
                val attribute = it.methodInfo.getAttribute(AnnotationsAttribute.invisibleTag) as? AnnotationsAttribute
                if (null != attribute?.getAnnotation("com.pengxr.hellotransform.Hello")) {
                    println("Insert toast in ${ctClass.simpleName}")
                    it.insertAfter(
                        """android.widget.Toast.makeText(this,"Hello Transform!",android.widget.Toast.LENGTH_SHORT).show();  
                                      """
                    )
                }
            }
        } catch (e: NotFoundException) {
            // ignore
        }
        // Output
        zos.write(ctClass.toBytecode())
        ctClass.detach()
    }
    

### 4.4 æ­¥éª¤ 4ï¼šåº”ç”¨æ’ä»¶

`sample æ¨¡å— build.gradle`

    apply plugin: 'com.pengxr.toastplugin'
    

### 4.5 æ­¥éª¤ 5ï¼šå£°æ˜ @Hello æ³¨è§£

`HelloActivity.kt`

    class HelloActivity : AppCompatActivity() {
    
        @Hello
        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContentView(R.layout.activity_hello)
        }
    }
    

### 4.6 æ­¥éª¤ 6ï¼šè¿è¡Œ

å®Œæˆä»¥ä¸Šæ­¥éª¤åï¼Œç¼–è¯‘è¿è¡Œç¨‹åºã€‚å¯ä»¥åœ¨ Build Output çœ‹åˆ°ä»¥ä¸‹è¾“å‡ºï¼ŒHelloActivity å¯åŠ¨æ—¶ä¼šå¼¹å‡º Toast HelloTransformï¼Œè¯´æ˜ç»‡å…¥æˆåŠŸã€‚

    ...
    Task :sample:mergeDebugJavaResource
    
    > Task :sample:transformClassesWithToastTransformForDebug
    ...
    onCreate found in HelloActivity
    Insert toast in HelloActivity
    ToastTransform - Transform end.
    
    > Task :sample:dexBuilderDebug
    > Task :sample:mergeExtDexDebug
    > Task :sample:mergeDexDebug
    > Task :sample:packageDebug
    > Task :sample:createDebugApkListingFileRedirect
    > Task :sample:assembleDebug
    
    BUILD SUCCESSFUL in 3m 18s
    33 actionable tasks: 33 executed
    
    Build Analyzer results available
    

* * *

5\. Transform çš„æœªæ¥
-----------------

ä» AGP 7.0 å¼€å§‹ï¼ŒTransform API å·²ç»è¢«åºŸå¼ƒäº†ã€‚æ˜¯çš„ï¼Œå°±æ˜¯å·ï¼Œè€Œä¸”è¿™æ¬¡ç›´æ¥æ˜¯é™ç»´æ‰“å‡»ã€‚ä»¥å‰ Transform æ˜¯ AGP çš„ç‰¹æ€§ï¼Œç°åœ¨ Gradle ä¹Ÿæ¥æ•´ Transformï¼Œä¸è¿‡æ¢äº†ä¸ªåå­—ï¼Œå« â€”â€” [TransformAction](https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.transform.TransformAction.html)ã€‚

é‚£ä¹ˆï¼Œæˆ‘ä»¬è¿˜æœ‰å¿…è¦å­¦ AGP Transform API å—ï¼Ÿå¦‚æœä½ ç°åœ¨æ¶‰è¶³å­—èŠ‚ç æ’æ¡©è¿™å—ï¼Œä½ å»ºè®®ä½ è¿˜æ˜¯å­¦ä»¥ä¸‹ï¼š

*   **1ã€ç¤¾åŒºæ²‰æ·€ï¼š** AGP Transform API å‘å±•å¤šå¹´ï¼Œç›®å‰ç¤¾åŒºä¸­å·²ç»æ²‰æ·€ä¸‹éå¸¸å¤šä¼˜ç§€çš„å¼€æºç»„ä»¶å’Œåšå®¢ï¼Œè¿™äº›èµ„æºå¯¹ä½ éå¸¸æœ‰å¸®åŠ©ã€‚è€Œ TransformAction çš„ç¤¾åŒºæ²‰æ·€è¿˜éå¸¸å•è–„ï¼›
*   **2ã€æŠ€æœ¯æ€ç»´ï¼š** è™½ç„¶æ¢äº†ä¸€å¥— APIï¼Œä½†èƒŒåçš„æ€è·¯ / å¥—è·¯æ˜¯ç›¸ä¼¼çš„ã€‚ç†è§£ AGP Transform çš„å·¥ä½œæœºåˆ¶ï¼Œå¯¹ä½ ç†è§£ Gradle TransformAction æœ‰äº‹åŠåŠŸå€çš„æ•ˆæœã€‚

ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯ [Gradle å®˜æ–¹æ–‡æ¡£](https://docs.gradle.org/current/userguide/artifact_transforms.html#implementing_incremental_artifact_transforms)çš„æ¼”ç¤ºä»£ç ï¼Œæ˜¯ä¸æ˜¯å¥—è·¯å·®ä¸å¤šï¼Ÿ

    abstract class CountLoc implements TransformAction<TransformParameters.None> {
    
        @Inject                                                             
        abstract InputChanges getInputChanges()
    
        @PathSensitive(PathSensitivity.RELATIVE)
        @InputArtifact
        abstract Provider<FileSystemLocation> getInput()
    
        @Override
        void transform(TransformOutputs outputs) {
            def outputDir = outputs.dir("${input.get().asFile.name}.loc")
            println("Running transform on ${input.get().asFile.name}, incremental: ${inputChanges.incremental}")
            inputChanges.getFileChanges(input).forEach { change ->          
                def changedFile = change.file
                if (change.fileType != FileType.FILE) {
                    return
                }
                def outputLocation = new File(outputDir, "${change.normalizedPath}.loc")
                switch (change.changeType) {
                    case ADDED:
                    case MODIFIED:
                        println("Processing file ${changedFile.name}")
                        outputLocation.parentFile.mkdirs()
    
                        outputLocation.text = changedFile.readLines().size()
    
                    case REMOVED:
                        println("Removing leftover output file ${outputLocation.name}")
                        outputLocation.delete()
    
                }
            }
        }
    }
    

6\. æ€»ç»“
------

æœ¬æ–‡çš„ç¤ºä¾‹ä»£ç å·²ä¸Šä¼ åˆ° [https://github.com/pengxurui/DemoHall](https://github.com/pengxurui/DemoHall)ï¼Œè¯· Star æ”¯æŒã€‚å…³æ³¨æˆ‘ï¼Œå¸¦ä½ äº†è§£æ›´å¤šï¼Œæˆ‘ä»¬ä¸‹æ¬¡è§ã€‚

### å‚è€ƒèµ„æ–™

*   [Gradle Transform + ASM æ¢ç´¢](https://rebooters.github.io/2020/01/04/Gradle-Transform-ASM-%E6%8E%A2%E7%B4%A2/) â€”â€” REBOOTERS è‘—
*   [æ·±å…¥ç†è§£ Transform](https://juejin.cn/post/6844903829671002126) â€”â€” toothpickTina è‘—
*   [ç°åœ¨å‡†å¤‡å¥½å‘Šåˆ« Transform äº†å—ï¼Ÿ](https://juejin.cn/post/7016147287889936397) â€”â€” ç©¶æé€®è™¾æˆ· è‘—
*   [AGP Transform API è¢«åºŸå¼ƒæ„å‘³ç€ä»€ä¹ˆï¼Ÿ](https://johnsonlee.io/2021/08/02/the-deprecation-of-agp-transform-api/) â€”â€” johnsonlee è‘—
*   [Transforming dependency artifacts on resolution](https://docs.gradle.org/current/userguide/artifact_transforms.html#implementing_incremental_artifact_transforms) â€”â€” Gradle å®˜æ–¹æ–‡æ¡£

> **ä½ çš„ç‚¹èµå¯¹æˆ‘æ„ä¹‰é‡å¤§ï¼å¾®ä¿¡æœç´¢å…¬ä¼—å· \[å½­æ—­é”\]ï¼Œå¸Œæœ›å¤§å®¶å¯ä»¥ä¸€èµ·è®¨è®ºæŠ€æœ¯ï¼Œæ‰¾åˆ°å¿—åŒé“åˆçš„æœ‹å‹ï¼Œæˆ‘ä»¬ä¸‹æ¬¡è§ï¼**