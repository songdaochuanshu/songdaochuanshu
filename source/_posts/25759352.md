---
layout: post
title: "MySQL 事务和锁"
date: "2022-04-30T09:17:42.224Z"
---
MySQL 事务和锁
==========

  

事务概述
----

当多个用户访问同一份数据时，一个用户在更改数据的过程中，可能有其他用户同时发起更改请求，为保证数据库记录的更新从一个一致性状态变为另外一个一致性状态，使用事务处理是非常必要的，事务具有以下四个特性：

1.  原子性（Atomicity）：事务中所有操作视为一个原子单位，即对事务所进行的数据修改等操作只能是完全回滚或完全提交
2.  一致性（Consistency）：事务在完成时，必须使用所有的数据从一种一致性变更为另一种一致性状态，所有的变更都必须应用于事务的修改，以确保数据的完整性。事务的一致性由原子性、持久性和隔离性一起实现
3.  隔离性（Isolation）：一个事务中的操作语句所做的修改必须与其他事务所做的修改相隔离。在进行事务查看数据时，数据所处的状态，要么是被另一个并发事务修改之前的状态，要么是被另一并发事务修改之后的状态，即当前事务不会查询由另一个并发事务正在修改的数据。隔离性由 MySQL 锁机制实现
4.  持久性（Durability）：事务完成之后，所做的修改对数据的影响是永久的，即使系统重启或者出现系统故障，数据仍可恢复

MySQL 提供了多种事务型存储引擎，如 InnoDB 和 BDB 等，而 MyISAM 不支持事务。为了支持事务，InnoDB 存储引擎引入了与事务处理相关的 REDO 日志和 UNDO 日志，同时事务依赖于 MySQL 提供的锁机制

#### 1\. REDO 日志

事务执行时需要将执行的事务日志写入日志文件，对应的文件为 REDO 日志。当每条 SQL 进行数据更新操作时，首先将 REDO 日志写进日志缓冲区。当客户端执行 COMMIT 命令提交时，日志缓冲区的内容将被刷新到磁盘，日志缓冲区的刷新方式或者时间间隔可以通过参数 innodb\_flush\_log\_at\_trx\_commit 控制

REDO 日志对应磁盘上的 ib\_logifleN 文件，该文件默认为 5MB，建议设置为 512MB，以便容纳较大的事务。MySQL 崩溃恢复时会重新执行 REDO 日志的记录，恢复最新数据，保证已提交事务的持久性

#### 2\. UNDO 日志

与 REDO 日志相反，UNDO 日志主要用于事务异常时的数据回滚，具体内容就是记录数据被修改前的信息到 UNDO 缓冲区，然后在合适的时间将内容刷新到磁盘

假如由于系统错误或者 rollback 操作而导致事务回滚，可以根据 undo 日志回滚到没修改前的状态，保证未提交事务的原子性

与 REDO 日志不同的是，磁盘上不存在单独的 UNDO 日志文件，所有的 UNDO 日志均存在表空间对应的 .ibd 数据文件中，即使 MySQL 服务启动了独立表空间

  

事务控制语句
------

在 MySQL 中，可以使用 BEGIN 开始事务，使用 COMMIT 结束事务，中间可以使用 ROLLBACK 回滚事务。MySQL 通过 SET AUTOCOMMIT、START TRANSACTION、COMMIT 和 ROLLBACK 等语句支持本地事务

    START TRANSACTION | BEGIN [WORK]
    COMMIT [WORK]
    ROLLBACK [WORK]
    SET AUTOCOMMIT = {0 | 1}
    

*   BEGIN | START TRANSACTION：开始事务
*   COMMIT：结束事务
*   ROLLBACK：回滚事务
*   WORK：SQL 语句
*   SET AUTOCOMMIT：是否自动提交，0 禁止，1 开启，默认为 1

  

事务隔离级别
------

MySQL 定义了四种隔离级别，指定事务中哪些数据改变其他事务可见、哪些数据该表其他事务不可见。低级别的隔离级别可以支持更高的并发处理，同时占用的系统资源更少

InnoDB 系统级事务隔离级别可以使用以下语句设置：

*   未提交读：`SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;`
*   提交读：`SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;`
*   可重复读：`SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;`
*   串行化：`SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;`

查看系统级事务隔离级别：

    SELECT @@global.tx_isolation;
    

InnoDB 会话级事务隔离级别可以使用以下语句设置：

*   未提交读：`SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;`
*   提交读：`SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;`
*   可重复读：`SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;`
*   串行化：`SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;`

查看会话级事务隔离级别：

    SELECT @@tx_isolation;
    

#### 1\. 读未提交

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。读取未提交的数据称为脏读（Dirty Read），即是：首先开启 A 和 B 两个事务，在 B 事务更新但未提交之前，A 事务读取到了更新后的数据，但由于 B 事务回滚，导致 A 事务出现了脏读现象

#### 2\. 读已提交

所有事务只能看见已经提交事务所做的改变，此级别可以解决脏读，但也会导致不可重复读（Nonrepeatable Read）：首先开启 A 和 B 两个事务，A事务读取了 B 事务的数据，在 B 事务更新并提交后，A 事务又读取到了更新后的数据，此时就出现了同一 A 事务中的查询出现了不同的查询结果

#### 3\. 可重复读

MySQL 默认的事务隔离级别，能确保同一事务的多个实例在并发读取数据时看到同样的数据行，理论上会导致一个问题，幻读（Phontom Read）。例如，第一个事务对一个表中的数据做了修改，这种修改会涉及表中的全部数据行，同时第二个事务也修改这个表中的数据，这次的修改是向表中插入一行新数据，此时就会发生操作第一个事务的用户发现表中还有没有修改的数据行

InnoDB 通过多版本并发控制机制（MVCC）解决了该问题：InnoDB 通过为每个数据行增加两个隐含值的方式来实现，这两个隐含值记录了行的创建时间、过期时间以及每一行存储时间发生时的系统版本号，每个查询根据事务的版本号来查询结果

#### 4\. 串行化

通过强制事务排序，使其不可能相互冲突，从而解决幻读问题。简而言之，就是在每个读的数据行上加上共享锁实现，这个级别会导致大量的超时现象和锁竞争，一般不推荐使用

  

InnoDB 锁机制
----------

为了解决数据库并发控制问题，如走到同一时刻客户端对同一张表做更新或者查询操作，需要对并发操作进行控制，因此产生了锁

#### 1\. 锁的类型

##### 1.1 共享锁

共享锁的粒度是行或者元组（多个行），一个事务获取了共享锁以后，可以对锁定范围内的数据执行读操作

##### 1.2 排他锁

排他锁的粒度与共享锁相同，一个事务获取排他锁以后，可以对锁定范围内的数据执行写操作

有两个事务 A 和 B，如果事务 A 获取了一个元组的共享锁，事务 B 还可以立即获取这个元组的共享锁，但不能获取这个元组的排他锁，必须等到事务 A 释放共享锁之后。如果事务 A 获取了一个元组的排他锁，事务 B 不能立即获取这个元组的共享锁，也不能立即获取这个元组的排他锁，必须等到 A 释放排他锁之后

##### 1.3 意向锁

意向锁是一种表锁，锁定的粒度是整张表，分为意向共享锁和意向排他锁。意向共享锁表示一个事务有意对数据上共享锁或者排他锁。有意表示事务想执行操作但还没真正执行

#### 2\. 锁的粒度

锁的粒度主要分为表锁和行锁

表锁的开销最小，同时允许的并发量也是最小。MyISAM 存储引擎使用该锁机制。当要写入数据时，整个表记录被锁，此时其他读/写动作一律等待。一些特定的动作，如 ALTER TABLE 执行时使用的也是表锁

行锁可以支持最大的并发，InnoDB 存储引擎使用该锁机制。如果要支持并发读/写，建议采用 InnoDB 存储引擎