---
layout: post
title: "操作系统知识点"
date: "2022-04-13T01:27:18.662Z"
---
操作系统知识点
=======

操作系统
====

内核态和用户态
-------

### 内核态和用户态的区别？

内核态与用户态是操作系统的两种运行级别，当程序运行在 3 级特权级上时，就可以称之为运行在用户态。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；当程序运行在 0 级特权级上时，就可以称之为运行在内核态。处于用户态执行时，进程所能访问的内存空间和对象受到限制，其占有的处理器是可被抢占的；处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。

### 导致用户态到内核态的切换场景

1.  系统调用。这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。
2.  异常。当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
3.  外围设备的中断。当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。

这 3 种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

进程与线程
-----

### 进程和线程的区别？

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。

1.  进程是操作系统资源分配的最小单位，线程是 CPU 任务调度的最小单位。一个进程可以包含多个线程。
2.  不同进程间数据很难共享，同一进程下不同线程间数据很易共享。
3.  每个进程都有独立的代码和数据空间，进程要比线程消耗更多的计算机资源，一个进程崩溃后，在保护模式下不会对其它进程产生影响。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

### 并行和并发

1.  并发：当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为并发(Concurrent)。
2.  并行：当系统有一个以上 CPU 时，一个 CPU 执行一个线程，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为并行(Parallel)。

### 进程之间的通信方式以及优缺点

*   管道（PIPE）
    *   有名管道：一种半双工的通信方式，可以实现任意关系的进程间的通信
        *   优点：可以实现任意关系的进程间的通信
        *   缺点：
            1.  长期存于系统中，使用不当容易出错
            2.  缓冲区有限
    *   无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
        *   优点：简单方便
        *   缺点：
            1.  局限于单向通信
            2.  只能在创建它的进程以及其有亲缘关系的进程之间通信
            3.  缓冲区有限
*   信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问
    *   优点：可以同步进程
    *   缺点：信号量有限
*   信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
*   消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识
    *   优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
    *   缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合
*   共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
    *   优点：无须复制，快捷，信息量大
    *   缺点：
        1.  通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此要考虑进程间的读写操作的同步问题
        2.  利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信
*   套接字（Socket）：可用于不同计算机间的进程通信
    *   优点：
        1.  传输数据为字节级，传输数据可自定义
        2.  传输数据时间短，性能高
        3.  适合于客户端和服务器端之间信息实时交互
        4.  可以加密,数据安全性强
    *   缺点：需对传输的数据进行解析，转化成应用级的数据。

### 线程之间的通信方式

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制

*   锁(lock)：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
    *   互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。
    *   读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。
    *   自旋锁（spin lock）：互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。
    *   条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
*   信号量(Semaphore)
*   信号(Signal)
*   屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。

### 多进程与多线程的优劣对比

优劣

多进程

多线程

优点

编程调试简单，可靠性较高

速度快，资源占用小

缺点

速度慢，资源占用大

编程、调试复杂，可靠性较差

### 互斥锁和自旋锁的应用场景？

线程的休眠和唤醒都是相当昂贵的操作，它们需要大量的 CPU 指令，因此需要花费一些时间，如果互斥量仅仅被锁住很短的一段时间，用来使线程休眠和唤醒线程的时间会比该线程睡眠的时间还长，甚至有可能比不断在自旋锁上轮训的时间还长，这时就应该用自旋锁。如果锁持有的时间过长，其它尝试获取自旋锁的线程会一直轮训自旋锁的状态，这将非常浪费 CPU 的执行时间，这时候使用互斥锁会是一个更好的选择。

死锁
--

### 原因？

1.  系统资源不足
2.  资源分配不当
3.  进程运行推进顺序不合适

### 死锁的 4 个必要条件

1.  互斥条件：一个资源每次只能被一个线程使用；
2.  请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；
3.  不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；
4.  循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

### 如何避免（预防）死锁

1.  破坏`请求和保持`条件：有两种方法：
    1.  让进程在申请资源时，一次性申请所有需要用到的资源，不要一次一次来申请，当申请的资源有一些没空，那就让线程等待。不过这个方法比较浪费资源，进程可能经常处于饥饿状态。
    2.  要求进程在申请资源前，释放已经获得的资源。
2.  破坏`不剥夺`条件：允许进程进行抢占，有两种方法：
    1.  如果去抢资源，被拒绝，就释放自己的资源。
    2.  只要优先级大，可以抢到。
3.  破坏`循环等待`条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序提出。

虚拟存储器
-----

### 程序访问的局限性原理？

程序访问的局部性原理：是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。局部性原理又表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。

### 虚拟存储？

根据程序执行的时间局部性和空间局部性，我们允许作业装入的时候只装入一部分，另一部分放在磁盘上，当需要的时候再装入主存。用户的逻辑地址空间可以比主存的绝对地址空间要大。之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。虚拟存储器的大小由计算机的地址结构决定，并非是内存和外存的简单相加。虚拟存储器有以下三个主要特征：

1.  多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。
2.  对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。
3.  虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。

虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或`永久`的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：

1.  请求分页存储管理。
2.  请求分段存储管理。
3.  请求段页式存储管理。

不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：

1.  一定容量的内存和外存。
2.  页表机制（或段表机制），作为主要的数据结构。
3.  中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。
4.  地址变换机构，逻辑地址到物理地址的变换。

### 页面置换算法

在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。

### cache 工作原理？

cache，高速缓冲存储器，是一种容量小而速度快的高度缓冲器，以 RAM 为材料制成。引入的原因主要有：

1.  I/O 设备向主存的访问级别高于 CPU，在 I/O 访存期间，CPU 将处于空闲状态。
2.  主存速度的提高始终跟不上 CPU 的发展，主存与 CPU 的速度明显不匹配。

Cache 直接做在 CPU 内，速度几乎与 CPU 一样快，任何时刻都有一些主存块处于缓存之中，因此，CPU 欲访问主存的时候，有两种可能：

1.  所需要的字已经在缓存中，于是 CPU 直接访问 Cache，简称 Cache 命中。
2.  所需要的字不在缓存中，那么此时需要将字所在的主存块整块一次调入 Cache 中，（即主存-Cache 之间以块为单位进行传送 ）。

通常用命中率来衡量 Cache 的效率 。 在一个程序执行期间，设总的命中次数为 Nc，访问主存的次数为 Nm，那么命中率为：$H=N\_c/(N\_c+N\_m)$

在 Cache 中，地址映射是指把主存地址空间映射到 Cache 地址空间，在将主存块复制到 Cache 中的时候遵循一定的映射规则，标志位为 1 时候，表示其 Cache 映射的主存块数据有效。 地址映射有三种方式：直接映射，全相联映射，组相联映射。

1.  直接映射
    
    这种方式主存块只能装入 Cache 的唯一位置，若该位置已有内容，则产生块冲突，原来在 Cache 中的块将无条件被替换出去，直接映射的关系可以定义为：$j=i\\ mod\\ 2^c$，其中，j 为 Cache 的块号或者行号。i 为主存块号，$2^c$为 Cache 的总块数。这种方式映射不够灵活。地址结构为：
    
    主存字块标记
    
    Cache 字块标记
    
    字块内地址
    
    CPU 的访存过程：首先根据地址中间的 Cache 字块地址，直接找到对应的 Cache 块号，若块号的有效位为 1，则表示命；，否则为不命中，此时从主存中读取该地址所在的主存块号，并将其内容送到对应的 Cache 块并将有效位置 1，同时将内容送到 CPU。
    
2.  全相联映射
    
    这种方式可以把主存数据块装入 Cache 的任意一块，方式可以从已占满的 Cache 存储块中，替换出任一旧块，显然这种方式灵活，命中率也高，与直接相联映射相比，其主存字块位数增加，使得 Cache 标记位增多地址变换速度慢。通常使用“按内容寻址的”相联存储器。其地址结构为：
    
    主存字块标记
    
    字块内地址
    
3.  组相联映射
    
    将 Cache 空间分成大小相同的组，主存的一个数据块可以装到组内的任一个位置，即组间采取直接映射，组内采取全相联映射。如果把 Cache 分成 Q 组，每组有 R 块，那么有： $i= j\\ mod\\ q$，其中 i 为缓存的组号，j 为主存块号主存地址分为三个字段：
    
    主存字块标记
    
    组地址
    
    字块内地址
    
    当组内有 k 块的时候，称为 k 路组相联映射。  
    CPU 访存过程：首先根据中间的组地址，找到对应的 Cache 组，若其标记位为 1，说明命中，此时根据块内地址，在对应得 Cache 行中，存取信息；若不命中，那么此时从主存中读出该地址所在的主存号块，送到对应的 Cache 组的任一行，有效位置 1，同时将内容送到 CPU 中。
    

### 1.进程和线程的区别

*   **进程**是系统进行资源分配和调度的基本单位；
*   **线程**是CPU调度和分派的基本单位。
    *   每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小；
    *   一个进程至少有一个线程，线程依赖于进程而存在；
    *   每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行；
    *   多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮。

### 2.协程

*   **协程**：协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

### 3.进程的状态

#### 三态模型

*   **运行**：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。
*   **就绪**：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I／O操作完成而进入就绪状态时，排入高优先级队列。
*   **阻塞**：一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。

![三态模型](https://i.loli.net/2021/03/25/fjOoY642rznWUGE.png)

#### 五态模型

*   **新建**：对应于进程被创建时的状态，尚未进入就绪队列。
*   **终止**：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。

![](https://i.loli.net/2021/03/25/B7Ee5j2XCrObMhw.png)

### 4.进程间通信方式

*   **匿名管道**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
    
*   **高级管道**：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程。
    
*   **有名管道**：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
    
*   **消息队列**：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    
*   **信号量**：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
    
*   **信号**： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
    
*   **共享内存**：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
    
*   **套接字**：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。
    

### 5.僵尸进程和孤儿进程

*   **僵尸进程**：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。
*   **孤儿进程**：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

### 6.死锁

*   **死锁**：死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。

#### 死锁产生的必要条件

*   **互斥条件**：一个资源每次只能被一个进程使用；
*   **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放；
*   **不剥夺条件**：进程已获得的资源，在未使用完之前，不能强行剥夺；
*   **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。

#### 死锁预防

*   破坏互斥条件：允许某些资源同时被多个进程访问，但是有些资源本身并不具有这种属性；
*   破坏请求与保持条件：
    *   实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；
    *   只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；
*   破坏不剥夺条件：允许进程强行抢占被其它进程占有的资源，这样做会降低系统性能；
*   破坏循环等待条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。

#### 死锁避免

> 银行家算法
> 
> 参考： [银行家算法](https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95)

### 7.页面置换算法

*   **最佳置换算法**（OPT）：选择以后永不使用的或者是在最长时间内不再被访问的页面；
    
*   **先进先出置换算法**（FIFO）：优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面；
    
*   **最近最久未使用置换算法**（LRU）：置换出未使用时间最长的页面；
    
*   **第二次机会算法**（SCR）：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；
    
*   **时钟算法**（CLOCK）：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销。
    
*   注：[LRU算法题](https://leetcode-cn.com/problems/lru-cache/)
    

### 8.分页和分段的区别

*   段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；
*   段的大小不固定，由它所完成的功能决定；页的大小固定，由系统决定；
*   段向用户提供二维地址空间；页向用户提供的是一维地址空间；
*   段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。

### 9.硬中断和软中断

​ **硬中断**是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的IRQ（中断请求）。

​ 处理中断的驱动是需要运行在CPU上的，因此，当中断产生的时候，CPU会中断当前正在运行的任务，来处理中断。在有多核心的系统上，一个中断通常只能中断一颗CPU（也有一种特殊的情况，就是在大型主机上是有硬件通道的，它可以在没有主CPU的支持下，可以同时处理多个中断）。

​ **硬中断**可以直接中断CPU。它会引起内核中相关的代码被触发。对于那些需要花费一些时间去处理的进程，中断代码本身也可以被其他的硬中断中断。

​ **软中断**的处理非常像硬中断。然而，它们仅仅是由当前正在运行的进程所产生的。通常，软中断是一些对I/O的请求。这些请求会调用内核中可以调度I/O发生的程序。对于某些设备，I/O请求需要被立即处理，而磁盘I/O请求通常可以排队并且可以稍后处理。根据I/O模型的不同，进程或许会被挂起直到I/O完成，此时内核调度器就会选择另一个进程去运行。I/O可以在进程之间产生并且调度过程通常和磁盘I/O的方式是相同。

​ **软中断**仅与**内核**相联系。而内核主要负责对需要运行的任何其他的进程进行调度。一些内核允许设备驱动的一些部分存在于用户空间，并且当需要的时候内核也会调度这个进程去运行。

​ **软中断**并不会直接中断CPU。也只有当前正在运行的代码（或进程）才会产生软中断。这种中断是一种需要内核为正在运行的进程去做一些事情（通常为I/O）的请求。有一个特殊的软中断是Yield调用，它的作用是请求内核调度器去查看是否有一些其他的进程可以运行。

### 10.IO模型

*   **阻塞式 I/O**：应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回；
    
*   **非阻塞式 I/O**：应用进程可以继续执行，但是需要不断地执行系统调用来获知 I/O 是否完成，这种方式称为轮询；
    
*   **I/O 复用**：单个进程具有处理多个 I/O 事件的能力；
    
    *   **select**：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，**开销大**），由内核根据就绪状态修改该集合的内容。（缺点2）**集合大小有限制**，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：**轮询的方式效率较低**），当文件描述符的数量增加时，效率会线性下降；
        
        默认单个进程打开的FD有限制是1024个，可修改宏定义，但是效率仍然慢。
        
    *   **poll**：基本原理与select一致，也是轮询+遍历；唯一的区别就是**poll**采用链表的方式存储，没有最大文件描述符限制。
        
    *   **epoll**：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll\_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。
        
*   **信号驱动式 I/O**：内核在数据到达时向应用进程发送 SIGIO 信号；
    
*   异步 I/O：内核完成所有操作后向应用进程发送信号。
    

局部性原理  
⾯试官 ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的局部性原理。另外，局部性原  
理既适⽤于程序结构，也适⽤于数据结构，是⾮常重要的⼀个概念。  
" 我 ：局部性原理是虚拟内存技术的基础，正是因为程序运⾏具有局部性原理，才可以只装⼊部分  
程序到内存就开始运⾏。  
以下内容摘⾃《计算机操作系统教程》 第 4 章存储器管理。  
早在 1968 年的时候，就有⼈指出我们的程序在执⾏的时候往往呈现局部性规律，也就是说在某个᫾短  
的时间段内，程序执⾏局限于某⼀⼩部分，程序访问的存储空间也局限于某个区域。  
局部性原理表现在以下两个⽅⾯：

1.  时间局部性 ：如果程序中的某条指令⼀旦执⾏，不久以后该指令可能再次执⾏；如果某数据被  
    访问过，不久以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在程序中存在着  
    ⼤量的循环操作。
2.  空间局部性 ：⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即  
    程序在⼀段时间内所访问的地址，可能集中在⼀定的范围之内，这是因为指令通常是顺序存放、  
    顺序执⾏的，数据也⼀般是以向量、数组、表等形式簇聚存储的。  
    时间局部性是通过将近来使⽤的指令和数据保存到⾼速缓存存储器中，并使⽤⾼速缓存的层次结构实  
    现。空间局部性通常是使⽤᫾⼤的⾼速缓存，并将预取机制集成到⾼速缓存控制逻辑中实现。虚拟内存  
    技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，利⽤局部性原理实现髙速缓存。