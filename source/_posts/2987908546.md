---
layout: post
title: "django框架(部分讲解)"
date: "2022-12-15T11:13:53.671Z"
---
django框架(部分讲解)
==============

ORM执行SQL语句
==========

**有时候ORM的操作效率可能偏低 我们是可以自己编写SQL的**  
  
方式1:  
**raw()方法执行原生sql语句**

    models.User.objects.raw('select * from app01_user;')
    

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215145636516-773534986.png)

方式2:  
**直接执行自定义原生sql（完全避开模型层，类似pymysql操作）**

    from django.db import connection
    cursor = connection.cursor()
    cursor.execute('select name from app01_user;')
    print(cursor.fetchall())
    

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215150213387-1958966325.png)

神奇的双下划线查询
=========

**只要还是queryset对象就可以无限制的点queryset对象的方法**

    queryset.filter().values().filter().values_list().filter()...
    

**查询年龄大于18的用户数据**

    res = models.User.objects.filter(age__gt=18)
    print(res)
    

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215151413761-1835613899.png)  
**查询年龄小于38的用户数据**

    res = models.User.objects.filter(age__lt=38)
    print(res)
    

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215151547013-1988188108.png)  
**大于等于 小于等于**

    res = models.User.objects.filter(age__gte=18)
    res = models.User.objects.filter(age__lte=38)
    

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215151933786-1602459765.png)  
**查询年龄是18或者28或者38的数据**

    res = models.User.objects.filter(age__in=(18, 28, 38))
    print(res)
    

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215152246730-202407263.png)

**查询年龄在18到38范围之内的数据**

    res = models.User.objects.filter(age__range=(18, 38))
    print(res)
    

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215152613755-701414293.png)  
**查询名字中含有字母j的数据**  
区分大小写

    res = models.User.objects.filter(name__contains='j')
    print(res)
    

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215152910338-1175982808.png)  
不区分大小写

    res = models.User.objects.filter(name__icontains='j')
    print(res)
    

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215153401100-1223832980.png)  
**查询注册年份是2022的数据**

    res = models.User.objects.filter(register_time__year=2022)
    print(res)
    

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215153643195-1615371288.png)  
**针对django框架的时区问题 是需要配置文件中修改的 后续bbs讲解**  

ORM外键字段的创建
==========

#### 复习MySQL外键关系

一对多  
外键字段建在多的一方  
多对多  
外键字段统一建在第三张关系表  
一对一  
建在任何一方都可以 但是建议建在查询频率较高的表中  
**总结:关系的判断可以采用换位思考原则**

#### ORM外键字段创建

**第一步:创建库修改配置文件连接数据库**  
![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215155118887-1913875845.png)  
**第二步:创建基础表(书籍表、出版社表、作者表、作者详情)**  
![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215162758157-932319721.png)  
**第三步:确定外键关系**  
![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215164605788-644311368.png)

一对多 ORM与MySQL一致 外键字段建在多的一方  
![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215163057048-1871580661.png)  
多对多 ORM比MySQL有更多变化

1.  外键字段可以直接建在某张表中(查询频率较高的)  
    内部会自动帮你创建第三张关系表
2.  自己创建第三张关系表并创建外键字段  
    一对一 ORM与MySQL一致 外键字段建在查询较高的一方  
    ![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215163457913-1759371024.png)  
    执行迁移命令连接数据库  
    ![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215164827202-190475430.png)  
    ![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215165047561-1497882431.png)

**第四步:ORM创建**  
针对一对多和一对一同步到表中之后会自动加\_id的后缀  
![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215165901538-947501459.png)

    publish = models.ForeignKey(to='Publish',on_delete=models.CASCADE)
    author_detail = models.OneToOneField(to='AuthorDetail', on_delete=models.CASCADE)
    

针对多对多 不会在表中有展示 而是创建第三张表

    authors = models.ManyToManyField(to='Author')
    

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215170213906-2031094630.png)

外键字段相关操作
========

**前期准备(给表录入一些数据)**  
![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215170732866-1684187970.png)

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215171041684-1335108040.png)

![image](https://img2023.cnblogs.com/blog/2987329/202212/2987329-20221215171129151-1496862730.png)  
针对一对多 插入数据可以直接填写表中的实际字段

    models.Book.objects.create(title='三国演义', price=888.88, publish_id=1)
    models.Book.objects.create(title='人性的弱点', price=777.55, publish_id=1)
    

针对一对多 插入数据也可以填写表中的类中字段名

    publish_obj = models.Publish.objects.filter(pk=1).first()
        # models.Book.objects.create(title='水浒传', price=555.66, publish=publish_obj)
    

**总结:一对一与一对多一致,既可以传数字也可以传对象**  
针对多对多关系绑定

    book_obj = models.Book.objects.filter(pk=1).first()
    book_obj.authors.add(1)  # 在第三张关系表中给当前书籍绑定作者
    book_obj.authors.add(2, 3)
    book_obj = models.Book.objects.filter(pk=4).first()
    author_obj1 = models.Author.objects.filter(pk=1).first()
    author_obj2 = models.Author.objects.filter(pk=2).first()
    book_obj.authors.add(author_obj1) book_obj.authors.add(author_obj1, author_obj2)
    book_obj = models.Book.objects.filter(pk=1).first()
    book_obj.authors.set((1, 3))  # 修改关系
    book_obj.authors.set([2, ])  # 修改关系
    author_obj1 = models.Author.objects.filter(pk=1).first()
    author_obj2 = models.Author.objects.filter(pk=2).first()
    book_obj.authors.set((author_obj1,)) book_obj.authors.set((author_obj1, author_obj2))
    book_obj.authors.remove(2)
    book_obj.authors.remove(1, 3) book_obj.authors.remove(author_obj1,) book_obj.authors.remove(author_obj1,author_obj2)
    book_obj.authors.clear()
    

ORM跨表查询
=======

**复习MySQL跨表查询的思路**

子查询

*   分步操作:将一条SQL语句用括号括起来当做另外一条SQL

> **语句的条件**

连表操作

*   先整合多张表之后基于单表查询即可

`inner join`内连接

`left join`左连接

`right join`右连接

`union`全连接

**正反向查询的概念(重要)**

正向查询

*   由外键字段所在的表数据查询关联的表数据是正向
    
*   或者说外键在自己手上则是正向查询
    

反向查询

*   没有外键字段的表数据查询关联的表数据是反向
    
*   或者说外键在别人手上则是反向查询
    

注意:正反向的核心就看外键字段在不在当前数据所在的表中

**ORM跨表查询的口诀(重要)**

*   正向查询按外键字段
    
*   反向查询按表名小写
    

基于对象的跨表查询
=========

        '''基于对象的跨表查询'''
        # 1.查询主键为1的书籍对应的出版社名称
        # 先根据条件获取数据对象
        book_obj = models.Book.objects.filter(pk=1).first()
        # 再判断正反向的概念  由书查出版社 外键字段在书所在的表中 所以是正向查询
        print(book_obj.publish.name)
    
        # 2.查询主键为4的书籍对应的作者姓名
        # 先根据条件获取数据对象
        book_obj = models.Book.objects.filter(pk=4).first()
        # 再判断正反向的概念  由书查作者 外键字段在书所在的表中 所以是正向查询
        print(book_obj.authors)  # app01.Author.None
        print(book_obj.authors.all())
        print(book_obj.authors.all().values('name'))
        
        # 3.查询jason的电话号码
        author_obj = models.Author.objects.filter(name='jason').first()
        print(author_obj.author_detail.phone)
    
        # 4.查询北方出版社出版过的书籍
        publish_obj = models.Publish.objects.filter(name='北方出版社').first()
        print(publish_obj.book_set)  # app01.Book.None
        print(publish_obj.book_set.all())
    
        # 5.查询jason写过的书籍
        author_obj = models.Author.objects.filter(name='jason').first()
        print(author_obj.book_set)  # app01.Book.None
        print(author_obj.book_set.all())
    
        # 6.查询电话号码是110的作者姓名
        author_detail_obj = models.AuthorDetail.objects.filter(phone=110).first()
        print(author_detail_obj.author)
        print(author_detail_obj.author.name)
    

基于双下划线的跨表查询
===========

        '''基于双下划线的跨表查询'''
        # 1.查询主键为1的书籍对应的出版社名称
        res = models.Book.objects.filter(pk=1).values('publish__name','title')
        print(res)
    
        # 2.查询主键为4的书籍对应的作者姓名
        res = models.Book.objects.filter(pk=4).values('title', 'authors__name')
        print(res)
    
        # 3.查询jason的电话号码
        res = models.Author.objects.filter(name='jason').values('author_detail__phone')
        print(res)
    
        # 4.查询北方出版社出版过的书籍名称和价格
        res = models.Publish.objects.filter(name='北方出版社').values('book__title','book__price','name')
        print(res)
    
        # 5.查询jason写过的书籍名称
        res = models.Author.objects.filter(name='jason').values('book__title', 'name')
        print(res)
    
        # 6.查询电话号码是110的作者姓名
        res = models.AuthorDetail.objects.filter(phone=110).values('phone', 'author__name')
        print(res)
    

进阶操作
====

        '''基于双下划线的跨表查询'''
        # 1.查询主键为1的书籍对应的出版社名称
        res = models.Book.objects.filter(pk=1).values('publish__name','title')
        print(res)
    
        # 2.查询主键为4的书籍对应的作者姓名
        res = models.Book.objects.filter(pk=4).values('title', 'authors__name')
        print(res)
    
        # 3.查询jason的电话号码
        res = models.Author.objects.filter(name='jason').values('author_detail__phone')
        print(res)
    
        # 4.查询北方出版社出版过的书籍名称和价格
        res = models.Publish.objects.filter(name='北方出版社').values('book__title','book__price','name')
        print(res)
    
        # 5.查询jason写过的书籍名称
        res = models.Author.objects.filter(name='jason').values('book__title', 'name')
        print(res)
    
        # 6.查询电话号码是110的作者姓名
        res = models.AuthorDetail.objects.filter(phone=110).values('phone', 'author__name')
        print(res)
    
        '''进阶操作'''
        # 1.查询主键为1的书籍对应的出版社名称
        res = models.Publish.objects.filter(book__pk=1).values('name')
        print(res)
    
        # 2.查询主键为4的书籍对应的作者姓名
        res = models.Author.objects.filter(book__pk=4).values('name','book__title')
        print(res)
    
        # 3.查询jason的电话号码
        res = models.AuthorDetail.objects.filter(author__name='jason').values('phone')
        print(res)
    
        # 4.查询北方出版社出版过的书籍名称和价格
        res = models.Book.objects.filter(publish__name='北方出版社').values('title','price')
        print(res)
    
        # 5.查询jason写过的书籍名称
        res = models.Book.objects.filter(authors__name='jason').values('title')
        print(res)
    
        # 6.查询电话号码是110的作者姓名
        res = models.Author.objects.filter(author_detail__phone=110).values('name')
        print(res)
    
        '''补充'''
        # 查询主键为4的书籍对应的作者的电话号码
        res = models.Book.objects.filter(pk=4).values('authors__author_detail__phone')
        print(res)
        res = models.AuthorDetail.objects.filter(author__book__pk=4).values('phone')
        print(res)
        res = models.Author.objects.filter(book__pk=4).values('author_detail__phone')
        print(res)