---
layout: post
title: "云环境下集合隐私计算-解读"
date: "2022-04-28T05:40:42.348Z"
---
云环境下集合隐私计算-解读
=============

> 读paper-"云环境下集合隐私计算"的笔记

基础
--

### 哥德尔编码

> 可以将非负整数序列（向量）与自然数建立起对应关系

具体来说，就是无穷序列\\((a\_1,x\_2,...,x\_m)\\)借助素数序列\\((p\_1,p\_2,...,p\_m)\\)，建立对应关系：  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426121853924-1432019790.png)

\\(\[a\_1,x\_2,...,x\_m\]\\)称作有穷序列\\((a\_1,x\_2,...,x\_m)\\)的哥德尔数。

#### 原理

根据算数基本定理，任何自然数可以唯一分解为多个素数的乘积，而构成哥德尔数的素数序列\\((p\_1,p\_2,...,p\_m)\\)是已知的，因此，由\\(\[a\_1,x\_2,...,x\_m\]\\)可以很容易得到序列\\((a\_1,x\_2,...,x\_m)\\)。

### 同态加密算法

该方案只用到了加法或者乘法同态性，下面分别介绍两种同态加密算法：

#### ElGamal

具有乘法同态性，相比于RSA，能抵抗重放攻击（加密时加入了随机数）  
1、加密结构：  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426123238698-867200734.png)  
2、乘法计算：  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426123436822-1290228160.png)

#### Paillier

具有加法同态性和一次"乘法"同态性，主要用到的还是加法同态  
1、加密结构  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426123600758-139277700.png)

2、加法计算  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426123617117-822089391.png)

保密计算求集合并集方案
-----------

### 原理

#### 1-r编码

![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426161252942-1084739706.png)  
假设有\\(n\\)个集合\\(X\_1,...,X\_n\\)，将每个集合\\(X\_i\\)借助1-r编码方法编码成向量\\(U\_i\\)，然后将各个向量对应分量相乘后得到新的向量\\(U'\\)：  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426161524522-1071088149.png)

如果向量\\(U'\\)中的某个分量\\(u\_j'\\neq 1\\)，说明这n个向量的第\\(j\\)个分量不全为1，即n个集合中至少有一个集合含有元素\\(u\_j\\)，根据集合\\(U;\\)中不为1的分量，可以得到并集\\(X\_1\\cup X\_2\\cup ...\\cup X\_n\\)，所以求集合的并集问题可以规约到计算向量\\(U'\\)

#### 举例

下面给出三个集合\\(X\_1,X\_2,X\_3\\in U\\)，保密的计算集合的并集：  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426162121655-331039060.png)  
最后$\\sigma $为集合的并集。

### 具体方案1

> 在云计算下，数据是需要加密来保证安全的，这里选用ElGamal加密算法。假设有\\(n\\)台服务器\\(P\_1,...,P\_n\\)，每台服务器中有一个集合\\(X\_i\\)，假设第\\(n\\)台服务器\\(P\_n\\)作为leader，生成加密的公私钥和参数，并将公钥和参数公开

（1）云服务器\\(P\_n\\)将自己的公钥\\(pk\\)与参数\\(params\\)公开，并保留私钥\\(sk\\)  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426181708937-1393459044.png)

（2）每个云服务器\\(P\_i(i=1,...,n)\\)计算：

*   将自己的秘密集合\\(X\_i\\)编码为向量\\(U\_i\\)  
    将\\(X\_i\\)使用**1-r编码**方法编码为向量\\(U\_i=(u\_{i,1},...,u\_{i,m})\\)
    
*   将\\(P\_n\\)的公钥\\(pk\\)与参数\\(params\\)加密\\(U\_i\\)为\\(E(U\_i)\\)  
    将向量\\(U\_i\\)中的每个分量分别加密，即\\(E(U\_i)=(E(u\_{i,1}),...,E(u\_{i,m}))\\)
    
*   将密文向量\\(E(U\_i)\\)随机分成\\(k\_i\\)份并发送给\\(n\\)个云服务器中的\\(k\_i\\)个  
    为了将数据混淆来保证\\(U\_i\\)的安全，每台服务器需要将\\(E(u\_{i,j}),j=1,...,m\\)分为\\(k\_i(k\_i \\leqslant n)\\)份\\(E(u\_{i,j})\_1,...,E(u\_{i,j})\_{k\_i}\\)，（\\(k\_i\\)其他服务器是不知道的），需要满足:\\(E(u\_{i,j})\_1...E(u\_{i,j})\_{k\_i}=E(u\_{i,j})\\)  
    \\(P\_i\\)每次从每个密文分量\\(E(u\_{i,j})\_1,...,E(u\_{i,j})\_{k\_i}\\)中选取一个，共选取\\(k\_i\\)次，构成\\(U\_i\\)的\\(k\_i\\)份密文\\(E(U\_i)\_1,...,E(U\_i)\_{k\_i}\\)，每份（向量）里面\\(m\\)个元素。  
    如果直接对\\(E(u\_{i,j}),j=1,...,m\\)进行分解因子，计算量大，所以这里使用**模运算**进行分解因子，具体如下：  
    选取\\(k\_i\\)个随机数\\(r\_{i,1},..,r\_{i,k\_i}\\in Z\_p^\*\\)，需要满足\\(r\_{i,1}....r\_{i,k\_i}=1 mod p\\)，从\\(k\_i\\)个随机数中随机选择一个，如\\(r\_{i,1}\\)，和\\(E(u\_{i,j})\\)相乘，即\\(E(u\_{i,j})\_1=E(u\_{i,j}).r\_{i,1}\\)，然后将\\(E(u\_{i,j})\_2,...,E(u\_{i,j})\_{k\_i}\\)用\\(r\_{i,2},...,r\_{i,k\_i}\\)表示，进而就能将\\(E(U\_i)\\)**"拆分"**为\\(k\_i\\)份，且满足：\\(E(u\_{i,j})\_1...E(u\_{i,j})\_{k\_i}=r\_{i,1}.E(u\_{i,j}).r\_{i,2}...r\_{i,k\_i}=E(u\_i,j)\\)  
    最后将这个\\(k\_i\\)个密文向量\\(E(U\_i)\_1,...,E(U\_i)\_{k\_i}\\)发送给k个云服务器（可以包括自己）。
    
*   把收到的所有密文向量对应的分量相乘得到新的密文向量\\(E(U\_i')\\)，并发送给\\(P\_n\\)  
    每个云服务器\\(P\_i\\)将密文发送后，也有可能收到其他云服务器发来的密文向量，\\(P\_i\\)将收到的密文向量的每个相应分量分别相乘，构成新的密文向量\\(E(U\_i^\*)=(E(u\_{i,1}'),...,E(u\_{i,m}^\*))\\)，并发送给leader云服务器\\(P\_n\\)，从而将发送的密文和自身密文混淆。  
    （3）云服务器\\(P\_n\\)计算：
    
*   所有收到的密文向量对应的分量相乘，得到\\(E(U')\\)  
    ![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426191847024-344006463.png)  
    由于每个服务器都是半诚实的，不会加入额外的信息，所以\\(P\_n\\)构造的密文向量\\(E(U')\\)是所有参与者密文向量各个分量的乘积，即:  
    ![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426192039983-6364001.png)
    
*   用自己的私钥\\(sk\\)解密\\(E(U')\\)得到\\(U'\\)
    

\\\[U'=(u\_1',...,u\_m') \\\]

*   根据\\(U'\\)中不为1的分量得到\\((\\sigma \_1,...,\\sigma \_h)\\)
*   公布\\((\\sigma \_1,...,\\sigma \_h)\\)

### 举例

> 现在要求四个云服务器中的秘密数据的并集，假设\\(P\_4\\)为leader服务器，\\(k\\)\=3

（1）每台服务器\\(P\_i\\)编码各自的集合数据\\(X\_i\\)为\\(U\_i\\)；然后再使用公钥\\(pk\\)加密，即\\(E(U\_1),E(U\_2),E(U\_3),E(U\_4)\\)；再将其拆分为\\(k\\)份，分别发送给其他两个服务器（自己留一份）  
（2）在发送完后，\\(P\_i\\)就有可能收到其他服务器发来的密文向量，然后将每份的密文向量对应的元素相乘得到\\(E(U\_i')\\)，发送给\\(P\_4\\)  
（3）\\(P\_4\\)得到：  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426193720545-1625881376.png)  
（4）\\(P\_4\\)将\\(E(U')\\)解密，根据\\(U'\\)中不为1的元素得到并集\\((\\sigma \_1 ,...,\\sigma \_h )\\)  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220426193910995-2114516315.png)

保密计算求集合并集优化方案
-------------

> 上面的方案计算复杂性和集合\\(U\\)中元素的个数\\(m\\)线性相关，若\\(m\\)较大，加密、解密的次数和通信量将会较大，不便于计算。若想要\\(m\\)不太大，可以在上面的基础上，利用哥德尔编码将向量对应成一个自然数的方法设计了一种高效的编码方法，使得协议的计算复杂性不再于集合的大小\\(m\\)相关，降低了计算复杂性。

### 基本思想

#### 0-r编码+哥德尔编码

（1）总集合\\(U=(u\_1,...,u\_m),(u\_1<....<u\_m)\\)对应集合\\(P=(p\_1,...,p\_m),(p\_1,...,p\_m)\\)是不等的互素数  
（2）对于集合\\(X\_i\\in U\\)，将其按照0-r编码方式编码为向量\\(U\_i=(u\_{i,1},...,u\_{i,m})\\)，具体是，若\\(u\_j\\in X\_i\\)，则\\(u\_{i,j}=r\_{i,j}\\)，其中\\(r\_{i,j}\\in \[1,m\]\\)是一个随机数且\\(r\_{i,j}\\neq 0\\)，否则\\(u\_{i,j}=0\\)，然后借助集合\\(P\\)利用哥德尔编码将\\(U\_i\\)编码为一个自然数\\(x\_i\\)，即：  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220428102619876-1966874506.png)

假设有\\(n\\)个集合\\(X\_1,...,X\_n \\in U\\)，将每个集合\\(X\_i\\)按照上面的编码方式编码为一个自然数\\(x\_i\\)，将这\\(n\\)个自然数相乘得到\\(x\\)，即：  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220428103006633-1832538793.png)  
然后根据算数基本定理将\\(x\\)展开，得到集合\\(U'={u\_1',...,u\_m'}\\)。若\\(u\_j'=u\_{1,j}+...+u\_{n,j}\\neq 0\\)，则说明\\(n\\)个集合中至少有一个集合中有\\(u\_j\\)。所以就可以根据向量\\(U'\\)中不为0的分量，得到并集。  
故计算并集的问题可以规约到计算\\(x\\)。

#### 举例

![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220428103513798-1655861395.png)

### 具体方案2

> \\(U\\)集合是公开的，或者是\\(P\_n\\)已知的；\\(P\_n\\)作为leader。

输入：\\(P\_1,...,P\_n\\)各自的秘密集合\\(X\_1,..,X\_n \\in U\\)  
输出：交集\\((\\sigma \_1,...,\\sigma \_h)\\)

（1）云服务器\\(P\_n\\)保留私钥\\(sk\\)，公布公钥\\(pk\\)和系统参数\\(params\\)  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220428103933355-2054412092.png)

（2）每个云服务器\\(P\_i\\)计算如下：

*   根据上面改造的编码方法将自己的秘密集合\\(X\_i\\)编码为自然数\\(x\_i\\)
    
*   用公钥\\(pk\\)加密\\(x\_i\\)为\\(E(x\_i)\\)  
    直接发送\\(E(x\_i)\\)是不安全的，因为\\(P\_n\\)可以直接解密，所以需要混淆密文与云服务器的对应关系！
    
*   将\\(E(x\_i)\\)随机分为\\(k\_i\\)份并发送给\\(k\_i\\)个服务器  
    ![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220428104557958-1379376306.png)
    
*   将收到的所有密文相乘得到新的密文\\(E(x\_i')\\)，并发送给\\(P\_n\\)  
    ![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220428111011825-1288268461.png)
    

（3）云服务器\\(P\_n\\)计算如下：

*   把所有收到的密文相乘，得到\\(E(x)\\)
*   用私钥\\(sk\\)解密\\(E(x)\\)得到\\(x\\)
*   将\\(x\\)用算术基本定理展开得到向量\\(U'\\)
*   根据\\(U'\\)中不为0的分量得到集合\\((\\sigma \_1,...,\\sigma \_h)\\)  
    ![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220428112004549-848990374.png)

### 云计算下的改造方案

![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220428112825323-1955129050.png)

（1）用户自己编码，然后拆分混淆，发给服务器  
（2）服务器计算（混淆后的明文），再加密，发送给leader服务器  
（3）leader服务器计算（密文），解密，得到并集，并分发

> 云服务器没有任何一个云用户秘密向量的全部信息，因此得到不到云用户的信息

### 方案分析

安全性证明

保密计算求集合交集方案
-----------

> 上面介绍的是求集合的并集，现在求交集，变动不大！

### 协议

![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220428115703088-710441561.png)  
![](https://img2022.cnblogs.com/blog/1928790/202204/1928790-20220428115720450-523259274.png)

### 举例

（1）集合\\(U=(101,102,103,104,105,106,107,108,109,110)\\)对应集合\\(P=(2,3,5,7,11,13,17,19,23,31)\\)，假设要计算3个集合\\(X\_1=(101,105,107),X\_2=(103,105,108),X\_3=(105,106,109)\\)的交集，根据0-r编码将其编码为向量\\(U\_1,U\_2,U\_3\\)，即：

\\\[U\_1=(0,1,2,3,0,4,0,5,6,7),U\_2=(1,2,0,4,0,5,6,0,7,8),U\_3=(1,2,3,4,0,0,7,8,0,9) \\\]

（2）将向量\\(U\_1,U\_2,U\_3\\)借助集合\\(P\\)利用哥德尔编码编码为自然数\\(x\_1,x\_2,x\_3\\)，即：

\\\[x\_1=\[0,1,2,3,0,4,0,5,6,7\]=3^1.5^2.7^3.13^4.19^5.23^6.31^7;x\_2=\[1,2,0,4,0,5,6,0,7,8\]=2^1.3^2.7^4.13^5.17^6.23^7.31^8;x\_3=\[1,2,3,4,0,0,7,8,0,9\]=2^1.3^2.5^3.7^4.17^7.19^8.31^9 \\\]

（3）将这三个自然数相乘得到：

\\\[x=x\_1.x\_2.x\_3=2^2.3^5.5^5.7^{11}.11^0.13^9.17^{13}.19^{13}.21^{13}.31^{24} \\\]

（4）即得到向量\\(U'=(2,5,5,11,0,9,13,13,13,24)\\)，根据向量\\(U'\\)中为0的分量得到交集：

\\\[X\_1 \\cap X\_2 \\cap X\_3=(105) \\\]

> 以上为了方便演示，省去了拆分的步骤。