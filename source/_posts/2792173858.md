---
layout: post
title: "Java反应式编程（1）"
date: "2022-11-14T04:38:42.610Z"
---
Java反应式编程（1）
============

您好，我是湘王，这是我的博客园，欢迎您来，欢迎您再来～

前面把Java函数式编程的由来和最主要的核心知识点讲完了。包括比较难懂的Lambda表达式是怎么演变而来的也全部都撸了一遍。Lambda表达式这种编程方式的确是让人不太习惯，尤其是之前那种纯面向对象编程的思维模式一旦建立起来之后，想要再接受这种比较奇怪的语法和编程模式，确实是非常困难。但Lambda表达式和流式编程的出现，又催生了另一门新的技术：反应式编程。

《三国演义》中说：“天下大势，分久必合，合久必分”。在科技领域也是一样。之前没有科学的时候，由占星术、炼金术、神学等催生出了一系列的自然科学，像什么物理、化学、数学等等。等到这些学科演变的差不多了之后，又开始了逐步的融合。

反应式编程就和这有点类似，它是融合了Lambda表达式、流式编程和观察者模式的一种新的编程范式。

就像很多反应式编程的技术书、官网和资料里面说的，“一切皆是流”，比如我们其实无时不刻都在呼吸对吧，而且吸入和呼出的都是空气，也就是气流，这个很好理解哈～然后我们的嘴巴会去吃东西，就是食物吧，它也会变成食物流，其他的也是一样，像我们看到的外部的风景啊、人物啊、抖音里面的视频啊，都是视觉流，还有我们和其他人之间的谈话、聊天什么的，都是语音流，而且这种视觉流和语音流很多都是持续的，源源不断的。就像这样：

![](https://img2022.cnblogs.com/blog/2983171/202211/2983171-20221113211924204-1596325439.png)

而且这些流就是我们生活中每天都需要面对的各种各样的事情，比如吃了东西，呼吸了新鲜空气，就会让我们获得能量，就不会觉得饿或者没力气了，或者看到外面漂亮的风景，小哥哥小姐姐，以及美食，或者说和朋友谈话、聊天之后就会觉得很愉快，就能引起心理和生理反应，或者说比如和谁一起吃工作餐谈话，谈的不愉快就直接结束，所以这里有个红叉叉，正常结束的话就是一个竖线，比如这段时间对吃的、帅哥美女、聊天或者抖音都没啥兴趣，走冷淡风，就不再对这些外部事件产生反应了，所谓的反应式编程里面所说的反应，其实就是一种对行为的响应。

如果把代码想象成一个人的话，那么那些外部的事情用计算机专业的话来说叫事件，比如用户点击页面按钮发送消息、键盘输入、物联网设备不断地发送信号等等，都是各种输入流，而且程序需要对这些各种事件都做出响应，或者反应，而且要及时。用以前的方式也是可以的，不过如果这种事件很多，涉及的线程、回调就会很多，所以就需要一种新的编程方式来处理这种叫做mashup的混合式Web应用开发。关于反应式编程的一种正式的描述可以看反应式编程官方的《反应式宣言》：

![](https://img2022.cnblogs.com/blog/2983171/202211/2983171-20221113211930333-1023316571.png)

刚才说的只是反应式编程一些概念性或者是感性的认识，真正要了解反应式编程，还是要看代码：

public static void main(String\[\] args) {

  Person person \= new Person("zhangsan", 18);

  // 数据怎么来就怎么处理，处理完后就结束
  Observable.just("1", 2, true, 0.618, person, new String("haha"))
    .subscribe(System.out::println);

}

运行后可以看到，不管是什么样的数据类型，都会被just给展示出来，这就是「流」的概念。而在以前的Java集合List中，肯定是不可能有这种骚操作的。

这种代码示例其实在Reactive的Github官网上面有很多，可以打开它的官网查看：

![](https://img2022.cnblogs.com/blog/2983171/202211/2983171-20221113211956131-1630042022.png)

刚才的代码里面有三个特点：

1、出现了Lambda表达式（System.out::println）；

2、出现了流（.just().subscribe()）；

3、出现了一个叫做Observable的类，而熟悉设计模式的都知道，它是观察者模式中特有的一个类。

下面是观察者模式的一个示意图：

![](https://img2022.cnblogs.com/blog/2983171/202211/2983171-20221113212004292-1803844397.png)

观察者模式也是回调实现的一种方式。观察者模式在开发里面还有另外一个「外号」：发布\-订阅模式。经典的观察者模式是像下面这样的：

![](https://img2022.cnblogs.com/blog/2983171/202211/2983171-20221113212010105-1641044545.png)

可以用代码来演示这种剧院和观众的观察者模式：

// 观众的行为（观察者-订阅者接口）
@FunctionalInterface
interface Viewer {
  public void watch();
}

// 具体订阅者
class ConcreteViewer implements Viewer {
  @Override
  public void watch() {
    System.out.println("正在看表演");
  }
}
// 演员（发布者）
class Actor {
  // 观众（订阅者）列表
  private List<Viewer> viewers = new ArrayList<Viewer>();
  // 买票（订阅）
  public void buyticket(Viewer viewer) {
    viewers.add(viewer);
  }
  // 退票（取消订阅）
  public void refund(Viewer viewer) {
    viewers.remove(viewer);
  }
  // 开始表演
  public void play() {
    for (Viewer viewer : viewers) {
      viewer.watch();
    }
  }
}

/\*\*
 \* 剧院
 \*
 \* @author 湘王
 \*/
public class Theater {
  public static void main(String\[\] args) {
    ConcreteViewer viewer1 \= new ConcreteViewer();
    ConcreteViewer viewer2 \= new ConcreteViewer();
    Actor actor \= new Actor();
    actor.buyticket(viewer1);
    actor.buyticket(viewer2);
    actor.buyticket(() \-> System.out.println("正在VIP包厢看表演"));
    actor.play();
  }
}

这也是反应式编程的门槛比较高的原因，对于一些没有学过设计模式的同学来说，反应式编程确实很不好理解。这也没办法，因为整个反应式编程的根基就是建立在观察者模式之上的，而且还结合Java9里面的Flow API做了一些改变，有兴趣的同学可以自己去了解一下，所以总结来说的话，反应式编程的特点就是这样的：

![](https://img2022.cnblogs.com/blog/2983171/202211/2983171-20221113212049700-2003863828.png)

用一句简单的话来概括反应式编程 = 函数式编程 + 流式计算 + 观察者模式。

* * *

感谢您的大驾光临！咨询技术、产品、运营和管理相关问题，请关注后留言。欢迎骚扰，不胜荣幸～