---
layout: post
title: "ä»£ç éšæƒ³å½• | äºŒå‰æ ‘çš„éå†"
date: "2022-10-10T02:10:38.447Z"
---
ä»£ç éšæƒ³å½• | äºŒå‰æ ‘çš„éå†
==============

äºŒå‰æ ‘çš„é€’å½’éå†
========

é€’å½’çš„ä¸‰è¦ç´ 
------

**1.é€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼**

**2.é€’å½’å‡ºå£**

**3.å•å±‚é€’å½’çš„é€»è¾‘**

[144\. äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
------------------------------------------------------------------------------

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ å‰åº éå†ã€‚

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public List<Integer> preorderTraversal(TreeNode root) {
            List<Integer> result = new ArrayList<>();
            preoder(root,result);
            return result;
        }
        public void preoder(TreeNode node,List<Integer> result){
            if (node==null){
                return;
            }
            result.add(node.val);//å‰åºéå†ï¼šä¸­ã€å·¦ã€å³
            preoder(node.left,result);
            preoder(node.right,result);
        }
    }
    

  
  

[94\. äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
----------------------------------------------------------------------------

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› å®ƒçš„ ä¸­åº éå† ã€‚

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public List<Integer> inorderTraversal(TreeNode root) {
            List<Integer> result = new ArrayList();
            inorder(root,result);
            return result;
        }
        public void inorder(TreeNode node, List<Integer> result){
            if(node==null){
                return;
            }
            inorder(node.left,result);//ä¸­åºéå†ï¼šå·¦ã€ä¸­ã€å³
            result.add(node.val);
            inorder(node.right,result);
        }
    }
    

  
  

[145\. äºŒå‰æ ‘çš„ååºéå†](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
-------------------------------------------------------------------------------

> ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ ååºéå† ã€‚

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public List<Integer> postorderTraversal(TreeNode root) {
            List<Integer> result = new ArrayList();
            postorder(root,result);
            return result;
        }
        public void postorder(TreeNode node,List<Integer> result){
            if(node==null){
                return;
            }
            postorder(node.left,result);//ååºéå†ï¼šå·¦ã€å³ã€ä¸­
            postorder(node.right,result);
            result.add(node.val);
        }
    }
    

  
  
  

äºŒå‰æ ‘çš„è¿­ä»£éå†
========

_ç”¨æ ˆæ“ä½œï¼Œé€’å½’ä¹Ÿæ˜¯ç”¨æ ˆå®ç°çš„å˜›ğŸ™‚_

[144\. äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
------------------------------------------------------------------------------

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ å‰åº éå†ã€‚

![](https://img2022.cnblogs.com/blog/2465988/202210/2465988-20221009104335997-1187683750.gif)

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public List<Integer> preorderTraversal(TreeNode root) {
             List<Integer> result = new ArrayList<>();//ç»“æœåˆ—è¡¨
            Stack<TreeNode> stack = new Stack<>();
            if(root==null){
                return result;
            }
            stack.push(root);//å…ˆæŠŠæ ¹èŠ‚ç‚¹åŠ åˆ°æ ˆä¸­å»
            while (!stack.empty()){
                TreeNode node = stack.pop();//ä»æ ˆä¸­å¼¹å‡ºä¸€ä¸ªç»“ç‚¹æ¥è¿›è¡Œæ“ä½œ
                result.add(node.val);//å¼¹å‡ºçš„å…ƒç´ åŠ åˆ°ç»“æœåˆ—è¡¨ä¸­
                if(node.right!=null){
                    stack.push(node.right);//å³å­©å­ä¸ç©ºå°±è¿›æ ˆ
                }
                if(node.left!=null){
                    stack.push(node.left);//å·¦å­©å­ä¸ç©ºå°±è¿›æ ˆ
                }
            }
            return result;
        }
    }
    

*   å¦™è›™ç§å­åƒäº†å¦™è„†è§’ï¼Œå¦™åˆ°å®¶å•¦  
      
      
    

[145\. äºŒå‰æ ‘çš„ååºéå†](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
-------------------------------------------------------------------------------

> ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ ååºéå† ã€‚

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public List<Integer> postorderTraversal(TreeNode root) {
            List<Integer> result = new ArrayList<>();//ç»“æœåˆ—è¡¨
            Stack<TreeNode> stack = new Stack<>();
            if(root==null){
                return result;
            }
            stack.push(root);//å…ˆæŠŠæ ¹èŠ‚ç‚¹åŠ åˆ°æ ˆä¸­å»
            while (!stack.empty()){
                TreeNode node = stack.pop();//ä»æ ˆä¸­å¼¹å‡ºä¸€ä¸ªç»“ç‚¹æ¥è¿›è¡Œæ“ä½œ
                result.add(node.val);//å¼¹å‡ºçš„å…ƒç´ åŠ åˆ°ç»“æœåˆ—è¡¨ä¸­
                if(node.left!=null){
                    stack.push(node.left);//å·¦å­©å­ä¸ç©ºå°±è¿›æ ˆ
                }
                if(node.right!=null){
                    stack.push(node.right);//å³å­©å­ä¸ç©ºå°±è¿›æ ˆ
                }
            }
           Collections.reverse(result);
            return result;
        }
    }
    

**Collections.reverse(result) é“¾è¡¨åè½¬**

*   è¿™é¢˜å’Œå‰åºéå†ååˆ†ç›¸ä¼¼ï¼Œå°±æ˜¯å…¥æ ˆé¡ºåºä¸ä¸€æ ·ï¼Œç”»å›¾æ‰¾ä¸€ä¸‹é¡ºåºï¼Œæ”¹å‰åºéå†çš„ä»£ç å°±å¯å•¦

  
  

[94\. äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
----------------------------------------------------------------------------

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› å®ƒçš„ ä¸­åº éå† ã€‚

*   ä¸­åºéå†å’Œå‰åºéå†ã€ååºéå†ä¸ä¸€æ ·çš„åœ°æ–¹æ˜¯ï¼Œå‰åºéå†ï¼ˆä¸­å·¦å³ï¼‰ã€ååºéå†ï¼ˆå·¦å³ä¸­ï¼‰ï¼Œä¸­ç»“ç‚¹åœ¨ä¸¤ç«¯ï¼Œå¤„ç†ç»“ç‚¹å°±æ˜¯å½“å‰éå†çš„ç»“ç‚¹ï¼ˆä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹å¤„ç†ï¼‰ã€‚è€Œä¸­åºéå†çš„éå†ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œè¦å¤„ç†çš„ç»“ç‚¹å´æ˜¯ä»æœ€å·¦ä¾§çš„ç»“ç‚¹å¼€å§‹ã€‚

![](https://img2022.cnblogs.com/blog/2465988/202210/2465988-20221009144603450-281386014.gif)

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public List<Integer> inorderTraversal(TreeNode root) {
            List<Integer> result = new ArrayList<>();//ç»“æœåˆ—è¡¨
            Stack<TreeNode> stack = new Stack<>();
            if(root==null){
                return result;
            }
            TreeNode cur = root;//å–åˆ°æ ¹ç»“ç‚¹
            while (cur != null || !stack.isEmpty()){
                if (cur != null){
                    stack.push(cur);//æ”¾å…¥æ ˆä¸­
                    cur = cur.left;//æŠŠå½“å‰ç»“ç‚¹çš„å·¦å­©å­èµ‹ç»™å½“å‰ç»“ç‚¹
                }else{
                    cur = stack.pop();//å¼¹å‡ºæ ˆä¸­çš„ç»“ç‚¹
                    result.add(cur.val);//æ”¾å…¥ç»“æœé›†ä¸­
                    cur = cur.right;//æŠŠå½“å‰ç»“ç‚¹çš„å³å­©å­èµ‹ç»™å½“å‰ç»“ç‚¹ï¼ˆå·¦è¾¹å·²ç»éå†å®Œäº†ï¼Œä¸Šä¸€æ­¥ä¹ŸæŠŠä¸­é—´æ”¾å…¥ç»“æœé›†ä¸­ï¼Œè¯¥å³è¾¹äº†ï¼‰
                }
            }
            return result;
        }
    }
    

  
  
  

äºŒå‰æ ‘çš„å±‚åºéå†
========

_ä¹Ÿå°±æ˜¯å¹¿åº¦ä¼˜å…ˆéå†å•¦_

[102.äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
-------------------------------------------------------------------------------

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ å±‚åºéå† ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

![](https://img2022.cnblogs.com/blog/2465988/202210/2465988-20221009160148915-1818922443.gif)

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public List<List<Integer>> levelOrder(TreeNode root) {
            List<List<Integer>> res = new ArrayList<>();//å¤–å±‚é“¾è¡¨
            Queue<TreeNode> que = new LinkedList<>();//æ–°å»ºä¸€ä¸ªé˜Ÿåˆ—
            if (root == null) {
                return res;
            }
            que.add(root);//æŠŠæ ¹èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—
            while (!que.isEmpty()){
                //å½“é˜Ÿåˆ—ä¸ä¸ºç©ºæ—¶
                ArrayList<Integer> item = new ArrayList<>();//å†…å±‚é“¾è¡¨
                int size = que.size();//é˜Ÿåˆ—çš„å¤§å°
                while (size>0){
                    TreeNode node = que.poll();//å¼¹å‡ºå½“å‰ç»“ç‚¹
                    if(node.left!=null){que.add(node.left);}//æŠŠå½“å‰ç»“ç‚¹çš„å·¦å­©å­åŠ è¿›å»ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                    if(node.right!=null){que.add(node.right);}//æŠŠå½“å‰ç»“ç‚¹çš„å³å­©å­åŠ è¿›å»ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                    item.add(node.val);//å½“å‰ç»“ç‚¹åŠ åˆ°é“¾è¡¨
                    size--;
                }
                res.add(item);//å†…å±‚é“¾è¡¨åŠ å…¥åˆ°å¤–å±‚é“¾è¡¨ä¸­
            }
            return res;
        }
    }
    

  
  

ä¸‹é¢æ˜¯ä¸€å †å±‚åºéå†çš„é¢˜
-----------

### [107\. äºŒå‰æ ‘çš„å±‚åºéå† II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

> ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼ è‡ªåº•å‘ä¸Šçš„å±‚åºéå† ã€‚ ï¼ˆå³æŒ‰ä»å¶å­èŠ‚ç‚¹æ‰€åœ¨å±‚åˆ°æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å±‚ï¼Œé€å±‚ä»å·¦å‘å³éå†ï¼‰

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public List<List<Integer>> levelOrderBottom(TreeNode root) {
            List<List<Integer>> res = new ArrayList<>();//å¤–å±‚é“¾è¡¨
            Queue<TreeNode> que = new LinkedList<TreeNode>();//é˜Ÿåˆ—
            if(root==null)return res;
            que.add(root);//æŠŠæ ¹ç»“ç‚¹æ”¾å…¥é˜Ÿåˆ—
            while (!que.isEmpty()){
                List<Integer> item = new ArrayList<>();
                int size = que.size();
                while (size > 0) {
                    TreeNode node = que.poll();//é˜Ÿåˆ—ä¸­å¼¹å‡ºä¸€ä¸ªç»“ç‚¹
                    item.add(node.val);
                    if(node.left!=null){que.add(node.left);}
                    if(node.right!=null){que.add(node.right);}
                    size--;
                }
                res.add(item);
            }
            Collections.reverse(res);
            return res;
        }
    }
    

  
  

### [199\. äºŒå‰æ ‘çš„å³è§†å›¾](https://leetcode.cn/problems/binary-tree-right-side-view/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ æ ¹èŠ‚ç‚¹ rootï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼ã€‚

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public List<Integer> rightSideView(TreeNode root) {
            List<Integer> res = new ArrayList<>();
            Queue<TreeNode> que = new LinkedList<>();
            if(root==null)return res;
            que.add(root);//æ ¹ç»“ç‚¹ä¸ä¸ºç©ºï¼Œæ”¾å…¥é˜Ÿåˆ—
            while (!que.isEmpty()){
                List<Integer> item = new ArrayList<>();
                int size = que.size();
                while (size>0){
                    TreeNode node = que.poll();
                    item.add(node.val);
                    if(node.left!=null){que.add(node.left);}
                    if(node.right!=null){que.add(node.right);}
                    size--;
                }
                Integer i = item.get(item.size() - 1);
                res.add(i);
            }
            return res;
        }
    }
    

  
  

### [637\. äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

> ç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root , ä»¥æ•°ç»„çš„å½¢å¼è¿”å›æ¯ä¸€å±‚èŠ‚ç‚¹çš„å¹³å‡å€¼ã€‚ä¸å®é™…ç­”æ¡ˆç›¸å·® 10-5 ä»¥å†…çš„ç­”æ¡ˆå¯ä»¥è¢«æ¥å—ã€‚

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public List<Double> averageOfLevels(TreeNode root) {
            List<Double> res = new ArrayList<>();
            Queue<TreeNode> que = new LinkedList<>();
            if(root==null)return res;
            que.add(root);
            while (!que.isEmpty()){
                int size = que.size();
                double x = 0;
                double sum = 0;
                int count = size;
                while (size>0){
                    TreeNode node = que.poll();
                    sum += node.val;
                    if(node.left!=null){que.add(node.left);}
                    if(node.right!=null){que.add(node.right);}
                    size--;
                }        
                x = sum/count;
                res.add(x);
            }
            return res;
        }
    }
    

  
  

### [429\. N å‰æ ‘çš„å±‚åºéå†](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

> ç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„å±‚åºéå†ã€‚ï¼ˆå³ä»å·¦åˆ°å³ï¼Œé€å±‚éå†ï¼‰ã€‚

    /*
    // Definition for a Node.
    class Node {
        public int val;
        public List<Node> children;
    
        public Node() {}
    
        public Node(int _val) {
            val = _val;
        }
    
        public Node(int _val, List<Node> _children) {
            val = _val;
            children = _children;
        }
    };
    */
    
    class Solution {
        public List<List<Integer>> levelOrder(Node root) {
            List<List<Integer>> res = new ArrayList<>();//å¤–å±‚é“¾è¡¨
            Queue<Node> que = new LinkedList<>();//æ–°å»ºä¸€ä¸ªé˜Ÿåˆ—
            if (root == null) {
                return res;
            }
            que.add(root);//æŠŠæ ¹èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—
            while (!que.isEmpty()){
                //å½“é˜Ÿåˆ—ä¸ä¸ºç©ºæ—¶
                ArrayList<Integer> item = new ArrayList<>();//å†…å±‚é“¾è¡¨
                int size = que.size();//é˜Ÿåˆ—çš„å¤§å°
                while (size>0){
                    Node node = que.poll();//å¼¹å‡ºå½“å‰ç»“ç‚¹
                    //å½“å‰ç»“ç‚¹åŠ åˆ°é“¾è¡¨
                    if(node.children!=null){
                        for (Node child : node.children) {
                            que.add(child);
                        }
                    }
                    item.add(node.val);
                    size--;
                }
                res.add(item);//å†…å±‚é“¾è¡¨åŠ å…¥åˆ°å¤–å±‚é“¾è¡¨ä¸­
            }
            return res;
        }
    }
    

*   æ·»åŠ å­ç»“ç‚¹åˆ°é˜Ÿåˆ—çš„æ“ä½œæœ‰ç‚¹ä¸ä¸€æ ·

  
  

### [515\. åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

> ç»™å®šä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¯·æ‰¾å‡ºè¯¥äºŒå‰æ ‘ä¸­æ¯ä¸€å±‚çš„æœ€å¤§å€¼ã€‚

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public List<Integer> largestValues(TreeNode root) {
            List<Integer> res = new ArrayList<>();
            Queue<TreeNode> que = new LinkedList<>();
            if(root==null){
                return res;
            }
            que.add(root);
            while(!que.isEmpty()){
                int size = que.size();
                int x = Integer.MIN_VALUE;
                while(size>0){
                    TreeNode node = que.poll();
                    x = node.val>x ? node.val : x;
                    if(node.left!=null){que.add(node.left);}
                    if(node.right!=null){que.add(node.right);}
                    size--;
                }
                res.add(x);
            }
            return res;
        }
    }
    

  
  

### [116\. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

> ç»™å®šä¸€ä¸ªÂ å®Œç¾äºŒå‰æ ‘Â ï¼Œå…¶æ‰€æœ‰å¶å­èŠ‚ç‚¹éƒ½åœ¨åŒä¸€å±‚ï¼Œæ¯ä¸ªçˆ¶èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚äºŒå‰æ ‘å®šä¹‰å¦‚ä¸‹ï¼š  
> struct Node {  
> int val;  
> Node \*left;  
> Node \*right;  
> Node \*next;  
> }  
> å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULLã€‚  
> åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰Â next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚

    /*
    // Definition for a Node.
    class Node {
        public int val;
        public Node left;
        public Node right;
        public Node next;
    
        public Node() {}
        
        public Node(int _val) {
            val = _val;
        }
    
        public Node(int _val, Node _left, Node _right, Node _next) {
            val = _val;
            left = _left;
            right = _right;
            next = _next;
        }
    };
    */
    
    class Solution {
        public Node connect(Node root) {
            Queue<Node> que = new LinkedList<>();
            if (root == null) {
                return root;
            }
            que.add(root);
            while (que.size() > 0) {
                int size = que.size();
                Node node = que.poll();
                if (node.left != null) {que.add(node.left);}
                if (node.right != null) {que.add(node.right);}
                for (int i = 1; i < size; i++) {
                    Node next = que.poll();//å¼¹å‡ºè¯¥å±‚å‰©ä½™å…ƒç´ 
                    if (next.left != null) que.add(next.left);
                    if (next.right != null) que.add(next.right);
    
                    node.next = next;
                    node = next;
                }
    
            }
            return root;
        }
    }
    

  
  

### [117\. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘  
> struct Node {  
> int val;  
> Node \*left;  
> Node \*right;  
> Node \*next;  
> }  
> å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULLã€‚  
> åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰Â next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚

    /*
    // Definition for a Node.
    class Node {
        public int val;
        public Node left;
        public Node right;
        public Node next;
    
        public Node() {}
        
        public Node(int _val) {
            val = _val;
        }
    
        public Node(int _val, Node _left, Node _right, Node _next) {
            val = _val;
            left = _left;
            right = _right;
            next = _next;
        }
    };
    */
    
    class Solution {
        public Node connect(Node root) {
            Queue<Node> que = new LinkedList<>();
            if (root == null) {
                return root;
            }
            que.add(root);
            while (que.size() > 0) {
                int size = que.size();
                Node node = que.poll();
                if (node.left != null) {que.add(node.left);}
                if (node.right != null) {que.add(node.right);}
                for (int i = 1; i < size; i++) {
                    Node next = que.poll();//å¼¹å‡ºè¯¥å±‚å‰©ä½™å…ƒç´ 
                    if (next.left != null) que.add(next.left);
                    if (next.right != null) que.add(next.right);
    
                    node.next = next;
                    node = next;
                }
    
            }
            return root;
        }
    }
    

*   ç¦»å¤§è°±ï¼Œè¿™é¢˜ä»£ç è·Ÿä¸Šé¢˜ä¸€æ ·ï¼Œä¸€æ¨¡ä¸€æ ·

  
  

### [104\. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦ã€‚  
> äºŒå‰æ ‘çš„æ·±åº¦ä¸ºæ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public int maxDepth(TreeNode root) {
            Queue<TreeNode> que = new LinkedList<>();//æ–°å»ºä¸€ä¸ªé˜Ÿåˆ—
            if (root == null) {
                return 0;
            }
            que.add(root);//æŠŠæ ¹èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—
            int count = 0;
            while (!que.isEmpty()) {
                //å½“é˜Ÿåˆ—ä¸ä¸ºç©ºæ—¶
                count++;
                ArrayList<Integer> item = new ArrayList<>();//å†…å±‚é“¾è¡¨
                int size = que.size();//é˜Ÿåˆ—çš„å¤§å°
                while (size > 0) {
                    TreeNode node = que.poll();//å¼¹å‡ºå½“å‰ç»“ç‚¹
                    if (node.left != null) {
                        que.add(node.left);
                    }//æŠŠå½“å‰ç»“ç‚¹çš„å·¦å­©å­åŠ è¿›å»ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                    if (node.right != null) {
                        que.add(node.right);
                    }//æŠŠå½“å‰ç»“ç‚¹çš„å³å­©å­åŠ è¿›å»ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                    size--;
                }
            }
            return count;
        }
    }
    

  
  

### [111\. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚  
> æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        public int minDepth(TreeNode root) {
            Queue<TreeNode> que = new LinkedList<>();//æ–°å»ºä¸€ä¸ªé˜Ÿåˆ—
            if (root == null) {
                return 0;
            }
            que.add(root);//æŠŠæ ¹èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—
            int count = 0;
            while (!que.isEmpty()) {
                //å½“é˜Ÿåˆ—ä¸ä¸ºç©ºæ—¶
                count++;
                ArrayList<Integer> item = new ArrayList<>();//å†…å±‚é“¾è¡¨
                int size = que.size();//é˜Ÿåˆ—çš„å¤§å°
                while (size > 0) {
                    TreeNode node = que.poll();//å¼¹å‡ºå½“å‰ç»“ç‚¹
                    if (node.left != null) {
                        que.add(node.left);
                    }//æŠŠå½“å‰ç»“ç‚¹çš„å·¦å­©å­åŠ è¿›å»ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                    if (node.right != null) {
                        que.add(node.right);
                    }//æŠŠå½“å‰ç»“ç‚¹çš„å³å­©å­åŠ è¿›å»ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                    if(node.left==null&&node.right==null){
                        return count;
                    }
                    size--;
                }
    
            }
            return count;
        }
    }
    

  
  

æ€»ç»“
==

*   é€šè¿‡ä»Šå¤©çš„é¢˜ç›®å¤§è‡´æŒæ¡äºŒå‰æ ‘çš„ç»“æ„ã€‚æ·±åº¦ä¼˜å…ˆéå†æ–¹é¢æŒæ¡å‰åºã€ä¸­åºã€åç»­çš„é€’å½’å®ç°å’Œè¿­ä»£å®ç°ã€‚æŒæ¡å¹¿åº¦ä¼˜å…ˆéå†çš„æ¨¡æ¿ï¼ˆå†™äº†åé“å±‚åºéå†çš„é¢˜ç›®ï¼Œå°±ç®—æ˜¯å°çŒªä¹Ÿä¼šäº†ğŸ˜
    
*   ä»Šå¤©çš„é¢˜ç›®è‡ªå·±å†™å‡ºæ¥çš„ä¸å¤šï¼Œé™¤äº†æœ€åå‡ é“æ”¹æ¨¡æ¿çš„é¢˜ï¼Œä¸çŸ¥é“æ˜¯å› ä¸ºå¤©å¤ªå†·è¿˜æ˜¯å¤´ä¸Šæˆ´çš„è´è¶ç»“å°å°äº†æˆ‘çš„æ™ºæ…§çš„ğŸ™ƒ