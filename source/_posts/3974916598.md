---
layout: post
title: "ARC145~152 题解"
date: "2022-12-08T05:15:55.225Z"
---
ARC145~152 题解
=============

123

比赛标号从大到小排列 .

因为博主比较菜所以没有题解的题都是博主不会做的 /youl

ARC144 以前的比赛懒得写了 .

目录

*   [AtCoder Regular Contest 152](#atcoder-regular-contest-152)
    *   [B. Pass on Path](#b-pass-on-path)
    *   [C. Pivot](#c-pivot)
    *   [D. Halftree](#d-halftree)
*   [AtCoder Regular Contest 151](#atcoder-regular-contest-151)
    *   [A. Equal Hamming Distances](#a-equal-hamming-distances)
    *   [B. A < AP](#b-a--ap)
    *   [C. 01 Game](#c-01-game)
    *   [D. Binary Representations and Queries](#d-binary-representations-and-queries)
    *   [E. Keep Being Substring](#e-keep-being-substring)
*   [AtCoder Regular Contest 150](#atcoder-regular-contest-150)
    *   [A. Continuous 1](#a-continuous-1)
    *   [B. Make Divisible](#b-make-divisible)
    *   [C. Path and Subsequence](#c-path-and-subsequence)
    *   [D. Removing Gacha](#d-removing-gacha)
*   [AtCoder Regular Contest 149](#atcoder-regular-contest-149)
    *   [A. Repdigit Number](#a-repdigit-number)
    *   [B. Two LIS Sum](#b-two-lis-sum)
    *   [C. Avoid Prime Sum](#c-avoid-prime-sum)
    *   [D. Simultaneous Sugoroku](#d-simultaneous-sugoroku)
    *   [E. Sliding Window Sort](#e-sliding-window-sort)
*   [AtCoder Regular Contest 148](#atcoder-regular-contest-148)
    *   [A. mod M](#a-mod-m)
    *   [B. dp](#b-dp)
    *   [C. Lights Out on Tree](#c-lights-out-on-tree)
    *   [D. mod M Game](#d-mod-m-game)
    *   [E. ≥ K](#e--k)
    *   [F. 998244353 → 1000000007](#f-998244353--1000000007)
*   [AtCoder Regular Contest 147](#atcoder-regular-contest-147)
    *   [A. Max Mod Min](#a-max-mod-min)
    *   [B. Swap to Sort](#b-swap-to-sort)
    *   [C. Min Diff Sum](#c-min-diff-sum)
    *   [D. Sets Scores](#d-sets-scores)
    *   [E. Examination](#e-examination)
*   [AtCoder Regular Contest 146](#atcoder-regular-contest-146)
    *   [A. Three Cards](#a-three-cards)
    *   [B. Plus and AND](#b-plus-and-and)
    *   [C. Even XOR](#c-even-xor)
    *   [D. >=<](#d-)
*   [AtCoder Regular Contest 145](#atcoder-regular-contest-145)
    *   [A. AB Palindrome](#a-ab-palindrome)
    *   [B. AB Game](#b-ab-game)
    *   [C. Split and Maximize](#c-split-and-maximize)
    *   [D. Non Arithmetic Progression Set](#d-non-arithmetic-progression-set)

AtCoder Regular Contest 152
---------------------------

### B. Pass on Path

> 长 \\(L\\) 的道路，\\(n\\) 个中转站，两个人每人初始选一个中转站并以至多 \\(1\\) 的速度行走，两人欲访问道路左右端点 .
> 
> 两人只能在中转站处相遇，问两人都访问过左右端点后回到她们的初始中转站所需的最少时间 .
> 
> \\(1\\le n\\le 2\\times 10^5\\)，\\(1\\le L\\le 10^9\\) .

### C. Pivot

> 给一个序列 \\(\\{a\_n\\}\\)，每次可以选一个数 \\(a\_x\\) 然后让所有 \\(1\\le i\\le n\\) 都 \\(a\_i\\gets 2a\_x-a\_i\\)（\\(a\_x\\) 最后改）.
> 
> 最小化序列最大值 .
> 
> \\(2\\le n\\le 2\\times 10^5\\) .

开局就想错了 /hsh

看到这种诡异操作肯定是想找不变量，观察可以发现序列极差是不变的，令其为 \\(d\\)，于是可以转成最小化序列最小值 .

考虑选最值操作时最小值变化 \\(d\\)，则考虑最小化最小值模 \\(d\\) .

令最小值为 \\(m\\)，则如果不操作最值，一次对 \\(a\_x\\) 的操作将给 \\(m\\) 带来 \\(2(a\_x-m)\\) 的增量，然后操作一次最大值，这个操作还能继续进行，因为最大值 \\(m'\\) 也被带来 \\(2(a\_x-m')\\) 的增量 .

然后即可得到 \\(m\\bmod d\\) 的最小值就是 \\(m\\bmod\\gcd(d,\\gcd\\limits\_i\\{2(a\_i-m)\\})\\)，所以原题答案就是 \\(m\\bmod\\gcd(d,\\gcd\\limits\_i\\{2(a\_i-m)\\})\\)，直接 \\(\\Theta(n(\\log n+\\log V))\\) 计算即可，\\(V\\) 是值域 .

### D. Halftree

> \\(n\\) 个点 \\(0\\dots n-1\\) 和一个数 \\(k\\)，选若干个点对 \\((u,v)\\)，连边 \\((u,v)\\) 和 \\(((u+k)\\bmod n,(v+k)\\bmod n)\\)，要求最后构成一棵树，构造一组方案，无解输出 `-1` .
> 
> \\(2\\le n\\le 2\\times 10^5\\) .

首先 \\(n\\) 是偶数显然无解，下面说明 \\(n\\) 是奇数必然有解 .

直接构造，对于每个数 \\(x\\) 连边 \\(x\\to(x+k)\\bmod n\\) 形成 \\(d=\\gcd(n,k)\\) 个置换环，将每个置换环中最小的一个放到最前面，这样就可以排成一个 \\(d\\times\\dfrac nd\\) 矩阵 \\(\\{\\{a\\}\\}\\) .

考虑最后一列单独处理一下，就先连前 \\(\\dfrac nd-1\\) 列，只需要连 \\((a\_{1,i},a\_{2,i}),(a\_{2,i},a\_{3,i}),\\cdots,(a\_{d-1,i},a\_{d,i})\\) 即可，其中 \\(i\\) 是小于 \\(\\dfrac nd\\) 的奇数 .

这样就整出来 \\(\\dfrac nd-1\\) 条链，考虑把这些链连起来，连 \\((a\_{1,1},a\_{1,2}),(a\_{1,3},a\_{1,4}),\\cdots,(a\_{1,n/d-2},a\_{1,n/d-1})\\) 即可 . 注意这时候我们顺便把最后一列的第一个元素也连了 .

现在最后一列的奇偶性实际上被修正了，这样就可以直接连了，具体构造方案是 \\((a\_{2,n/d},a\_{3,n/d-1}),(a\_{4,n/d},a\_{5,n/d-1}),\\cdots,(a\_{d-1,n/d},a\_{d,n/d-1})\\) .

手玩一个矩阵出来看这个构造方案其实挺直观的，要看图可以去 Official Editorial .

构造的时间复杂度为 \\(\\Theta(n)\\)（也就是不算求 GCD 的时间复杂度）.

AtCoder Regular Contest 151
---------------------------

### A. Equal Hamming Distances

> 给两个 01 串 \\(s,t\\)，求字典序最小的串 \\(u\\)，使得 \\(\\operatorname{dist}(s,u)=\\operatorname{dist}(u,t)\\)，不存在输出 `-1` .
> 
> \\(\\operatorname{dist}(s,t)\\) 为 Hamming Distances，定义为
> 
> \\\[\\operatorname{dist}(s,t)=\\sum\_i\[s\_i\\neq t\_i\] \\\]
> 
> \\(1\\le |s|,|t|\\le 2\\times10^5\\) .

贪心即可，对于 \\(s\_i=0,t\_i=1\\) 和 \\(s\_i=1,t\_i=0\\) 的情况限制每种最多选 \\(\\dfrac{\\operatorname{dist}(s,t)}2\\) 个 \\(1\\)，显然这种做法是最优方案且符合题意 .

唯一可能产生 `-1` 的就是 \\(\\operatorname{dist}(s,t)\\) 是奇数，判一下就好了 .

时间复杂度 \\(\\Theta(|s|+|t|)\\) .

### B. A < AP

> 给一个 \\(1\\) 到 \\(n\\) 的排列 \\(\\pi\\)，问有多少个序列 \\(\\{a\_n\\}\\) 满足值在 \\(\[1,m\]\\) 之间且 \\(a<a\\circ \\pi\\)，其中小于号比较字典序，答案对 \\(998244353\\) 取模.
> 
> \\(1\\le n\\le 2\\times 10^5\\)，\\(1\\le m\\le 10^9\\) .

注意到字典序，于是枚举 LCP 算贡献 .

枚举一个 \\(i\\)，然后考虑计算对于所有 \\(1\\le j<i\\) 都有 \\(j=p\_j\\)，且 \\(i<p\_i\\) 时的答案 . 相等可以用一个并查集动态维护，然后并查集的时候维护一下连通块大小即可计算贡献 .

时间复杂度 \\(\\Theta(n\\log n)\\)，如果使用光速幂代替快速幂即可得到 \\(\\Theta(n\\alpha(n))\\) 的时间复杂度 .

### C. 01 Game

> 一个长度为 \\(n\\) 的序列，每个元素是 \\(0,1\\) 或者空，有值的点只有 \\(m\\) 个 .
> 
> Alice 和 Bob 玩一个游戏，每个人每次选一个空点然后染成 \\(0\\) 或 \\(1\\)，前提是这个点左右点如果有值则值不能相同 .
> 
> 谁不能行动谁输，问最后谁会赢 .
> 
> \\(1\\le n\\le 10^{18}\\)，\\(0\\le m\\le \\min\\{n,2\\times 10^5\\}\\)，初始相邻两元素值总不相同 .

注意到原游戏为公平组合游戏 / ICG，考虑构建有向图游戏 .

注意到每个极长空连续段即可作为有向图的每个弱连通块，于是根据 SG 定理，算出每个极长空连续段的答案异或起来即可得到整个游戏的 SG 值，于是即可得解 .

断言：

*   若连续段左右两侧都有数，令左右两侧的数分别为 \\(a,b\\)，则当前 SG 值为 \\(\[a=b\]\\) .
*   若连续段有且仅有一侧有数，则当前 SG 值为连续段长度 .
*   若连续段两侧都没有数，则当前 SG 值为连续段长度模 \\(2\\) .

证明考虑数学归纳法即可（其实只有单侧有数需要数学归纳法，，）

然后直接扫一遍处理一下即可，时间复杂度 \\(\\Theta(m)\\) .

### D. Binary Representations and Queries

> 维护一个序列 \\(\\{a\_{2^n}\\}\\)，\\(q\\) 次操作，每次给一个 \\(x,y\\)，对于所有第 \\(x\\) 位是 \\(y\\) 的 \\(0\\le i<2^n\\)，将 \\(a\_{i\\oplus 2^x}\\gets a\_{i\\oplus 2^x}+a\_i\\)，操作完后输出整个序列，对 \\(998244353\\) 取模 .
> 
> \\(1\\le n\\le 18\\)，\\(1\\le q\\le 2\\times 10^5\\) .

首先对于每个 \\(x\\) 其贡献是独立的，于是可以离线下来对于每个不同的 \\(x\\) 分别处理对 \\(\\{a\\}\\) 的贡献 .

不妨令 \\(x\\) 都等于 \\(0\\)，并且目前的询问次数是 \\(q\\)，其他值类似 .

令 \\(\\{a\\}\\) 经过 \\(i\\) 次操作后变成了 \\(A^{(i)}\\)，考虑用矩阵表出转移 .

令 \\(\\mathbf M\_0=\\begin{bmatrix}1&0\\\\1&1\\end{bmatrix}\\)，\\(\\mathbf M\_1=\\begin{bmatrix}1&1\\\\0&1\\end{bmatrix}\\)，于是就有

\\\[\\begin{bmatrix}A^{(i)}\_{2k}\\\\A^{(i)}\_{2k+1}\\end{bmatrix}=\\mathbf M\_{y\_i}\\begin{bmatrix}A^{(i-1)}\_{2k}\\\\A^{(i-1)}\_{2k+1}\\end{bmatrix} \\\]

其中 \\(y\_i\\) 是第 \\(i\\) 次操作的 \\(y\\) 值 .

展开即得

\\\[\\begin{bmatrix}A^{(q)}\_{2k}\\\\A^{(q)}\_{2k+1}\\end{bmatrix}=\\prod\_{i=q\\text{ downto }1}\\mathbf M\_{y\_i}\\begin{bmatrix}a\_{2k}\\\\a\_{2k+1}\\end{bmatrix} \\\]

这样就可以每个均摊 \\(\\Theta(1)\\) 的算出每个元素最后的值了 .

总时间复杂度 \\(\\Theta(q)\\)，至少带 \\(2^3\\) 的常数，[Code](https://atcoder.jp/contests/arc151/submissions/36194066) .

注：

一般形式应该是

\\\[\\begin{bmatrix}A^{(q)}\_{k\\oplus 2^x}\\\\A^{(q)}\_{k}\\end{bmatrix}=\\prod\_{\\substack{i=q\\text{ downto }1\\cr x\_i=x}}\\mathbf M\_{y\_i}\\begin{bmatrix}a\_{k\\oplus 2^x}\\\\a\_{k}\\end{bmatrix} \\\]

其中 \\(k\\) 的第 \\(x\\) 位是 \\(1\\) .

### E. Keep Being Substring

> 给一个序列 \\(\\{a\_n\\}\\) 的两个子序列 \\(\\{x\_p\\},\\{y\_q\\}\\) .
> 
> 每次可以将 \\(\\{x\\}\\) 的开头或末尾插入或删除一个数，但是每一时刻要保证 \\(\\{x\\}\\) 非空且是 \\(\\{a\\}\\) 的子序列 .
> 
> 问让 \\(x=y\\) 至少需要多少步 .
> 
> \\(1\\le n\\le 2\\times 10^5\\) .

找到 \\(\\{x\\}\\) 和 \\(\\{y\\}\\) 的最长公共子串 \\(\\{S\\}\\)，若 \\(\\{S\\}\\) 非空那么答案显然就是 \\(p+q-2|S|\\)，就是将 \\(\\{x\\}\\) 先删到 \\(\\{S\\}\\) 再加回来 .

若 \\(\\{S\\}\\) 为空，贪心地考虑，则一定是把 \\(\\{x\\}\\) 删成只剩一个数然后用一些操作让它变成 \\(\\{y\\}\\) 的子串然后加回去 .

考虑对于所有 \\(i\\)，连边 \\(a\_i\\leftrightarrow a\_{i+1}\\)，则问题变成 在 \\(\\{x\\}\\) 和 \\(\\{y\\}\\) 中分别选两个点 \\(u,v\\)，使它们之间的最短路最小 .

这个多源汇 BFS 即可，于是问题已经被解决了 .

复杂度瓶颈在求最长公共子串上，如果使用高级做法可以做到 \\(\\Theta(n)\\) .

如果只用简单字符串算法可以用二分长度 Hash 判定，可以做到 \\(\\Theta(n\\log n)\\)，足够通过本题了 . 还有这题卡单 Hash，必须双 Hash 才能过，[Code](https://atcoder.jp/contests/arc151/submissions/36199618) .

AtCoder Regular Contest 150
---------------------------

### A. Continuous 1

> 给一个只含 \\(\\verb!01?!\\) 的字符串 \\(s\\)，问是否存在唯一的方案将 \\(\\verb!?!\\) 换成 \\(\\verb!0!\\) 或 \\(\\verb!1!\\)，使得 \\(s\\) 中有且仅有 \\(k\\) 个 \\(1\\) 并且它们连续 .
> 
> 最多 \\(10^5\\) 组询问，\\(\\displaystyle\\sum|s|\\le 2\\times 10^5\\) .

扫一遍，枚举每个长度为 \\(k\\) 的子串依次判断一下能否成为变完后最终的连续 \\(1\\) 段即可 .

时间复杂度单次 \\(\\Theta(|s|)\\) .

### B. Make Divisible

> 给两个正整数 \\(a,b\\)，有一个非负整数对 \\((x,y)\\) 使得 \\(a+x\\mid b+y\\)，问 \\(x+y\\) 最小是多少 .
> 
> 最多 \\(100\\) 组询问，\\(1\\le a,b\\le 10^9\\) .

令 \\(b+y=k(a+x)\\)，则 \\(x+y=ka+(k+1)x-b\\) .

于是 \\(x+y\\) 仅和 \\(x\\) 相关，只需要最小化 \\(x\\) .

观察可得 \\(x\\) 的最小值为 \\(x = \\max\\left\\{0,\\left\\lfloor\\dfrac {b-1}k\\right\\rfloor+1-a\\right\\}\\) .

显然对 \\(k\\) 整除分块即可 . 时间复杂度 \\(\\Theta(T\\sqrt b)\\) .

* * *

或者考虑根号分治，首先编两个暴力（不妨令 \\(a\\ge b\\)）：

1.  直接暴力枚举 \\(x\\)，时间复杂度 \\(\\Theta(a)\\) .
2.  从 \\(1\\) 到 \\(\\left\\lfloor\\dfrac ba\\right\\rfloor+1\\) 枚举 \\(k=\\dfrac{b+y}{a+x}\\)，时间复杂度 \\(\\Theta\\left(\\dfrac ba\\right)\\) .

那么把两个暴力拼起来，显而易见 \\(\\min\\left\\{a,\\dfrac ba\\right\\}\\le \\sqrt b\\)，当 \\(a=\\sqrt b\\) 时取到，于是时间复杂度也是 \\(\\Theta(\\sqrt b)\\) .

### C. Path and Subsequence

> 有一个 \\(n\\) 个点 \\(m\\) 条边的无向连通图 \\(G\\)，还有两个序列 \\(\\{a\_n\\},\\{b\_k\\}\\) .
> 
> 问是否对于 \\(G\\) 中每一条简单路径 \\((v\_1,v\_2,\\cdots,v\_e)\\)，都有 \\(\\{b\\}\\) 是 \\(\\{a\_{v\_1},a\_{v\_2},\\cdots,a\_{v\_e}\\}\\) 的子序列 .
> 
> \\(2\\le n\\le 10^5\\)，\\(n-1\\le m\\le 2\\times 10^5\\) .

考虑 DP，令 \\(dp\_i\\) 表示到从点 \\(1\\) 到点 \\(i\\) 的所有路径至少匹配 \\(\\{b\\}\\) 多少位，则

\\\[dp\_v=\\min\_{u\\to v}\\{dp\_u+\[dp\_u<k\]\[a\_v=a\_{b\_u}+1\]\\} \\\]

注意到这个转移的形式类似最短路且边权仅为 0, 1，于是使用 01 BFS 即可做到 \\(\\Theta(n+m)\\) .

    deque<int> q; q.push_back(1);
    while (!q.empty())
    {
    	int u = q.front(); q.pop_front();
    	for (int v : g[u])
    	{
    		bool trans = (dp[u] != k) && (a[v] == b[dp[u] + 1]);
    		if (dp[v] > dp[u] + trans){dp[v] = dp[u] + trans; if (trans) q.push_back(v); else q.push_front(v);}
    	}
    }
    

### D. Removing Gacha

> 一棵 \\(n\\) 个点的树，初始所有点都是白的 .
> 
> 每次随机选一个满足它到根的路径上有至少一个白点的点，然后把它染黑 .
> 
> 问期望操作多少次让整棵树变成黑的，对 \\(998244353\\) 取模 .
> 
> \\(2\\le n\\le 2\\times10^5\\) .

首先，根据期望线性性可以得到答案就是 \\(\\displaystyle\_i\\mathbb E\[x\_i\]\\)，其中 \\(\\mathbb E\[x\_i\]\\) 为第 \\(i\\) 个嗲被染黑的期望次数 .

然后问题就变成如何求 \\(\\mathbb E\[x\_i\]\\) 了，大概有两种做法：

首先第一种是对于每个点 \\(u\\)，\\(\\mathbb E\[x\_u\]\\) 只会被 \\(1\\rightsquigarrow u\\) 这条链上的元素贡献到，于是单独提出链来考虑 . 根据 joke3579 大定理我们知道从 \\(n\\) 个元素的箱子里随机有放回地抽取元素的期望等于从取出第一个元素开始到取出所有元素至少一次时期望抽取次数 .

于是就是经典问题「赠券收集问题」了，抽出一个元素的期望次数即为调和级数 \\(H\_n\\)，然后即可轻易做到 \\(\\Theta(n)\\) .

这是一个非常精美的构造法 .

第二种方法的话大概就是考虑一个随机过程的期望其实就是任何一个合法的过程前缀 \\(S\_i\\) 下，元素被选中的概率之和 .

于是令

\\\[\\mathbb E\[x\_i\]=\\sum\_{k=0}^m\\mathbb P(S\_k(k)=u) \\\]

注意到如果如果 \\(u\\) 能被染，则要么 \\(u\\) 的父亲能被染，要么 \\(u\\) 的父亲不能被染但是在前缀中还没有出现过 .

令 \\(u\\) 父亲的深度为 \\(d\\)，于是答案是 \\(\\dfrac 1n(P\_1+P\_2)\\)，其中

\\\[\\begin{aligned}P\_1&=\\sum\_{k=1}^d(-1)^{k-1}\\binom{d}{k}\\frac{n}{k}\\\\P\_2&=\\sum\_{k=0}^d(-1)^k\\binom{d}{k}\\frac{n}{k+1}\\end{aligned} \\\]

注意到 \\(\\dfrac{1}{k+1}=\\left.(\\mathsf E^kx^{\\underline{-1}})\\right|\_{x=0}\\)，来个 \\(d\\) 阶差分把组合数干掉即可得到

\\\[\\begin{aligned}P\_2&=(-1)^dn\\left.\\left(\\Delta^dx^{\\underline {-1}}\\right)\\right|\_{x=0}\\\\&=\\frac{nd!}{(d+1)!}\\\\&=\\frac{n}{d+1}\\end{aligned} \\\]

\\(P\_1\\) 相对就有点麻烦，因为不能补上 \\(k=0\\) 项，考虑用恒等式 \\(\\displaystyle \\binom{d}{k}=\\sum\_{r=k-1}^{d-1}\\binom{r}{k-1}\\) 降下指标以规约到 \\(P\_2\\)，则

\\\[\\begin{aligned}P\_1&=\\sum\_{k=1}^d(-1)^{k-1}\\sum\_{r=k-1}^{d-1}\\binom{r}{k-1}\\frac{n}{k}\\\\&=\\sum\_{k=0}^{d-1}\\sum\_{r=k}^{d-1}(-1)^k\\dbinom rk\\dfrac n{k+1}\\\\&=\\sum\_{r=0}^{d-1}\\sum\_{k=0}^r(-1)^k\\dbinom rk\\dfrac n{k+1}\\\\&=\\sum\_{r=0}^{d-1}\\dfrac n{r+1}\\\\&=nH\_d\\end{aligned} \\\]

其中 \\(H\\) 是调和级数 . 倒数第二个等号是用的 \\(P\_2\\) 的表达式 .

最后深度为 \\(d\\) 的点的答案就是 \\(\\dfrac 1n(P\_1+P\_2)=H\_d\\)，殊途同归 .

AtCoder Regular Contest 149
---------------------------

### A. Repdigit Number

> 给两个正整数 \\(n,m\\)，求一个最大的 \\(x\\) 使得：
> 
> *   \\(m\\mid x\\) 且 \\(m<10^n\\) .
> *   \\(m\\) 在十进制下所有数码均相同 .
> 
> \\(1\\le n\\le 10^5\\)，\\(1\\le m\\le 10^9\\) .

真带劲，我连这种 naive 题都不会做了……

答案最多有 \\(9n\\) 种，暴力即可 .

### B. Two LIS Sum

> 给两个排列 \\(\\{a\_n\\}\\)，\\(\\{b\_n\\}\\)，求置换 \\(\\pi\\) 使得 \\(f(\\pi)=\\operatorname{LIS}(a\\circ \\pi)+\\operatorname{LIS}(b\\circ \\pi)\\) 最大，只需输出最大的 \\(f(\\pi)\\) .
> 
> \\(2\\le n\\le 3\\times 10^5\\) .

断言：\\(\\{a\\}\\) 单调递增时 \\(f(\\pi)\\) 最大 .

考虑 \\(\\{a\\}\\) 单调增时进行一次交换，这样 \\(\\{a\\}\\) 的 LIS 必减少 \\(1\\)，\\(\\{b\\}\\) 的 LIS 至多增加 \\(1\\)，于是新的 \\(f(\\pi)\\) 必然不优于原来的 \\(f(\\pi)\\) .

显然 \\(\\{a\\}\\) 中被拆的递增段不会再拼起来，否则这些操作都是冗余的，于是上面的思路可以延续下去，即得 \\(\\{a\\}\\) 单调递增时 \\(f(\\pi)\\) 最大 .

于是 \\(\\Theta(n\\log n)\\) 求一下 \\(\\operatorname{LIS}(a\\circ b)\\) 即为答案 .

### C. Avoid Prime Sum

> 给一个正整数 \\(n\\)，构造一个 \\(n\\times n\\) 方阵，满足：
> 
> *   每个数都是 \\(\[1,n^2\]\\) 中互不相同的整数 .
> *   任意相邻两数之和不为素数 .
> 
> \\(3\\le n\\le 10^3\\) .

不为素数看成为素数了 /qd 结果 ARC C 化身世纪难题 /youl

比较平凡的构造题 .

首先按奇偶考虑，同奇偶的数相加必然是偶数，偶数中只有 \\(2\\) 是素数，然而两个不同正整数相加不可能等于 \\(2\\)，这样方格上半部分填奇数，下半部分填偶数就大体解决了 .

然后考虑边界处可能出现有和为素数的情况 . 奇偶显然没得分，于是考虑把所有 \\(3\\) 的倍数都放到边界，这样所有边界处的和都是 \\(3\\) 的倍数，不可能是素数 .

这样就做完了 . 不过 \\(3\\) 的倍数数量足够当且仅当 \\(\\dfrac{n^2}2\\ge 3n\\) 也就是 \\(n\\ge 6\\)，于是 \\(n\\le 5\\) 的情况特判一波即可 .

[Code](https://atcoder.jp/contests/arc149/submissions/36393727)，\\(n\\le 5\\) 的情况我是直接贺的 Official Editorial .

### D. Simultaneous Sugoroku

> 给一组点 \\(\\{x\_n\\}\\) 和一个序列 \\(\\{d\_m\\}\\) .
> 
> 对于每个时刻 \\(t\\in\[1,m\]\\)，对每个 \\(i\\in\[1,n\]\\)，将 \\(x\_i\\gets x\_i-\\operatorname{sgn}(x\_i)d\_t\\) .
> 
> \\(m\\) 次操作后，对于每个点 \\(x\_i\\)：
> 
> *   若 \\(x\_i=0\\)，输出 `Yes` 以及它是第几次操作时第一次变成 \\(0\\) 的 .
> *   若 \\(x\_i\\neq 0\\)，输出 `No` 以及当前的 \\(x\_i\\) .
> 
> \\(1\\le n,m\\le 3\\times 10^5\\)，\\(1\\le x\_i,d\_i\\le 10^6\\) .

这个难度跨度也太大了吧……Difficulty 是 C 的两倍多 /youl

有一个相对无脑的做法，大概就是考虑维护置换 .

注意到任何数到 \\(0\\) 直接就寄了，考虑维护目前还没寄的区间，每次操作至多把一个区间分裂成两个所以区间数量不超过 \\(m\\) .

值域并不大，一开始维护两个区间 \\(\[-10^6,-1\]\\) 和 \\(\[1,10^6\]\\)，每次操作把正的往左移负的往右移，重叠的用并查集合起来，然后把过 \\(0\\) 的区间分裂开即可 .

最后对于 \\(n\\) 个询问看看最初始的 \\(x\_i\\) 在并查集上的祖先就能得到答案了，时间复杂度大概是 \\(\\Theta(n+V\\alpha(V))\\)，其中 \\(\\displaystyle V=\\max\_i\\{x\_i\\}\\) 是值域 .

代码难度有点高 /hsh 详见 [Code](https://atcoder.jp/contests/arc149/submissions/35369546)，我那份代码调到一半没备份结果电脑关机没磁盘保护导致代码没掉心态崩了决定不再做这个破题 .

官方题解的思路似乎很优美，不过我没看懂 .

### E. Sliding Window Sort

> 对于一个下标从 0 开始的序列 \\(\\{a\_n\\}\\)，对于 \\(p\\in\[0,k)\\)，将 \\(a\_{p\\bmod n},a\_{(p+1)\\bmod n},\\cdots,a\_{(p+m-1)\\bmod n}\\) 升序排序 .
> 
> 最后得到的序列即称作 \\(\\{a\\}\\) 的生成序列 .
> 
> 现在给一个排列 \\(\\{b\_n\\}\\)，问有多少序列 \\(\\{a\\}\\) 的生成序列是 \\(\\{b\\}\\)，对 \\(998244353\\) 取模 .
> 
> \\(2\\le m\\le n\\le 3\\times 10^5\\)，\\(1\\le k\\le 10^9\\) .

好神啊 /bx

进行一下基本的题意转化：

> 对于一个序列 \\(\\{a\_n\\}\\)，进行以下操作 \\(k\\) 次：
> 
> *   将 \\(a\_{0\\dots m-1}\\) 从小到大排序 .
> *   将序列 \\(\\{a\\}\\) 向左循环移一位 .
> 
> 最后得到的序列即称作 \\(\\{a\\}\\) 的生成序列 .

然后把 \\(\\{b\\}\\) 向左循环移 \\(k\\bmod n\\) 位即可 .

问题变成循环移位之后就可以转化成加一个数删一个数这种东西了 .

令序列左边 \\(m-1\\) 项为左部 \\(L\\)，剩下的为右部 \\(R\\)，为了方便令 \\(l=|L|\\)，\\(r=|R|\\) .

则一次操作就是每次把右部最前面的数加进左部，左部再把最小的数加到右部的末尾（左部经过至少一次操作后必然升序排列） .

观察到：

*   若 \\(r>k\\)，则显然右边的 \\(r-k\\) 个右部元素不会动所以可以直接删了 .
*   若 \\(r<k\\)，则 \\(r\\) 次操作之后 \\(R\\) 必然就是最大的 \\(r\\) 个数，这样后面的操作就是左部没有变，右部每次向左循环移一位，可以直接批量做了 .

所以所有情况都可以转化到 \\(r=k\\) 的情况 .

于是只需要考虑 \\(r=k\\) 的情况，注意到这种情况最后的 \\(L\\) 必然是所有数最大的 \\(l\\) 个升序排列，于是如果 \\(\\{b\\}\\) 最左边的数不是所有数中最大的或者不是升序的，那么方案数为 \\(0\\) .

令 \\(k\\) 轮操作后右部为 \\(R'=\\{x\_r\\}\\)，初始左部是 \\(L=\\{u\_l\\}\\)，右部是 \\(R=\\{v\_r\\}\\) .

如果存在 \\(i\\) 使得 \\(x\_{i-1}>x\_i\\)，那么必然有 \\(b\_i=x\_i\\)（因为 \\(x\_i\\) 必然是第 \\(i\\) 次操作的时候刚进左部就出去了）于是可以删掉这样的 \\(x,b\\) 去除影响 .

于是现在的 \\(\\{x\\}\\) 必然升序排列，则限制可以简单写为 \\(a\_{1\\dots l},b\_{1\\dots i}\\) 中的一个等于 \\(x\_i\\) .

显而易见对于每个 \\(i\\) 都有 \\(l+1\\) 种选法，则根据乘法原理答案就是 \\((l+1)^t\\)，其中 \\(t\\) 是最后 \\(\\{x\\}\\) 的长度 .

另外这个算的左部是有序的，要把它变成无序的，于是答案还得乘一个 \\(l!\\) .

这样整个问题终于被解决了，时间复杂度 \\(\\Theta(n)\\) .

附：循环移位有一个叫 `std :: rotate` 的函数 /hq

AtCoder Regular Contest 148
---------------------------

你题目名还真简洁啊？

### A. mod M

> 给一个序列 \\(\\{a\_n\\}\\)，你可以选一个整数 \\(m\\ge 2\\)，将 \\(\\{a\\}\\) 的所有元素 \\(a\_i\\gets a\_i\\bmod m\\) .
> 
> 问操作完后 \\(\\{a\\}\\) 最少有多少个不同元素 .
> 
> \\(2\\le n\\le 2\\times 10^5\\)，\\(0\\le a\_i\\le 10^9\\) .

普及题啊 .

首先取 \\(m=2\\) 可以得到答案不超过 \\(2\\) .

答案等于 \\(1\\) 的时候当且仅当排好序的 \\(\\{a\\}\\) 差分后的 GCD 不等于 \\(1\\) .

然后就 \\(\\Theta(n\\log n)\\) 了，要是用飞快的排序和[飞快的 GCD](https://www.luogu.com.cn/problem/P5435) 可以优化一下不过没啥用 .

### B. dp

> 以下所有字符串的字符集都是 \\(\\{\\tt d,p\\}\\) .
> 
> 对于串 \\(S\\)，令 \\(f(S)\\) 为其翻转 \\(180^{\\circ}\\) 后的串，或者说先翻转，然后每个字符 \\(\\tt d,p\\) 反转 .
> 
> 现在有一个长度为 \\(n\\) 的字符串 \\(S\\)，进行至多一次操作：选一个子串 \\(s\\) 然后把它变成 \\(f(s)\\) .
> 
> 问最后字典序最小的 \\(S\\) 是啥 .
> 
> \\(1\\le n\\le 5000\\) .

也是普及题 .

数据范围就是明示平方复杂度 .

首先根据字典序定义左端点必然是最左的 \\(\\tt p\\)，这样翻转过去之后如果右边有 \\(\\tt p\\) 这个就可以变成 \\(\\tt d\\)，否则必然不优 .

于是枚举右端点暴力判即可，时间复杂度 \\(\\Theta(n^2\\log n)\\)，用基数排序可以优化到 \\(\\Theta(n^2)\\) .

_不要尝试线性找右端点，会变得不幸_

### C. Lights Out on Tree

> 给一棵 \\(n\\) 个点的有根树，根是 \\(1\\) . 每个节点是黑色或白色，初始都是白色 .
> 
> 对点 \\(u\\) 进行一次操作可以将点 \\(u\\) 的子树（包含自身）全部颜色反转 .
> 
> \\(q\\) 次询问，每次询问给一个点集 \\(S\\)，把点集中的点全部染成黑色，问至少多少次操作可以把整棵树染白 .
> 
> \\(n,q,\\sum|S|\\le 2\\times 10^5\\) .

注意到一个节点最终状态就是它的初始状态异或它到根的路径上被操作节点数量奇偶性 .

于是就是：

*   根如果初始是黑则要操作一次 .
*   如果一对父子初始状态不同，那么下面那个一定要操作一次 .

如果一对父子初始状态同为黑则可以留到父亲的地方操作于是不产生贡献 .

这样直接维护即可，时间复杂度 \\(\\Theta(n+\\sum|S|)\\) .

### D. mod M Game

> 给你 \\(2n\\) 个整数 \\(\\{a\_{2n}\\}\\)，Alice 和 Bob 轮流取数，Alice 先手，如果最终 Alice 取出数的和和 Bob 取出来数的和在模 \\(m\\) 意义下同余，则 Bob 获胜，否则 Alice 获胜，问谁必胜 .
> 
> \\(1\\le n\\le 2\\times 10^5\\)，\\(2\\le m\\le 10^9\\) .

过程倒不难，不过这玩意到底咋想出来的啊？？

首先如果序列里有两个数相同，则选的时候必然是一起选的要不然显然不优，于是可以先把问题转化成元素互不相同的情况 .

从最终状态还剩两个数 \\(u,v\\) 开始考虑 .

令两人当前取数之差为 \\(d\\)，则 Bob 必胜当且仅当 \\(d+u\\equiv v\\pmod m\\) 且 \\(d+v\\equiv u\\pmod m\\) .

也就是 \\(u-v\\equiv v-u\\equiv d\\pmod m\\)，移项变成 \\(2(u-v)\\equiv 0\\pmod m\\) .

这里可以自然的想到讨论 \\(m\\) 的奇偶性，当 \\(m\\) 是奇数是意味着 \\(u=v\\)，这显然不存在，于是 Alice 必胜 .

只需要讨论 \\(m\\) 为偶数的情况 . 此时就是 \\(2(u-v)\\equiv m\\pmod m\\) 也就是 \\(u-v\\equiv\\dfrac m2\\pmod m\\) .

这样的二元组 \\((u,v)\\) 每出现一个则 \\(d\\) 增大 \\(\\dfrac m2\\)，于是这样的组的数量必然是偶数 .

则可以猜想：Bob 必胜当且仅当剩下的数之和为 \\(4\\) 的倍数且可以通过以上配对规则两两配对 .

证明就考虑构造一个方案，具体见 Official Editorial .

时间复杂度 \\(\\Theta(n)\\) 或 \\(\\Theta(n\\log n)\\)，瓶颈在去重 .

### E. ≥ K

> 给一个序列 \\(\\{a\_n\\}\\)，求它有多少种不同的排列满足对于所有 \\(i\\in\[1,n\]\\) 有 \\(a\_i+a\_{i+1}\\ge k\\) .
> 
> \\(2\\le n\\le 2\\times 10^5\\) .

[回收](https://www.cnblogs.com/CDOI-24374/p/16792927.html#g-increasing-k-times)

预设型 DP .

必然先排序，然后从小到大加入 . 考虑一个数前，先把与它满足条件的点都加入，这样就可以快速计算那些地方能放数了 .

具体的，维护当前的闲置区间 \\(\[l,r\]\\)，那么可以发现如果 \\(a\_l+a\_r\\ge k\\) 就插入 \\(l\\)，否则插入 \\(r\\)，则对于 \\(\[r+1,n\]\\) 这些数的旁边都可以放，别的都不行，这样就可以直接算了 .

时间复杂度 \\(\\Theta(n\\log n)\\)，瓶颈在排序 .

### F. 998244353 → 1000000007

> 有 \\(26\\) 个变量 \\(\\tt A\\dots Z\\)，最多 \\(100\\) 次操作：
> 
> *   `add x y z`，\\(x\\gets (y+z)\\bmod 2^{64}\\) .
> *   `mul x y z`，\\(x\\gets yz\\bmod 2^{64}\\) .
> *   `rem x y`，\\(x\\gets y\\bmod 998244353\\) .
> 
> 现在 \\(\\tt A,B\\) 处给你存了两个数 \\(a,b\\)，其他地方都是 \\(0\\) . 你的任务是在 \\(\\verb!C!\\) 处算出 \\(ab\\bmod(10^9+7)\\) .
> 
> \\(a,b\\in\[0,2^{64})\\) .

造计算机 + 科技题 .

使用 Montgomery Multiplication 算法解决，具体看官方题解 .

一个方案（贺的）：

    26
    mul C A B
    rem D C
    mul D D 4915446
    rem D D
    mul D D 1000000007
    add D C D
    mul C D 996491785301655553
    mul C C 343639189
    rem D C
    mul D D 4915446
    rem D D
    mul D D 1000000007
    add D C D
    mul C D 996491785301655553
    rem D C
    mul D D 4915446
    rem D D
    mul D D 1000000007
    add D C D
    mul C D 996491785301655553
    rem D C
    mul D D 4915446
    rem D D
    mul D D 1000000007
    add D C D
    mul C D 996491785301655553
    

AtCoder Regular Contest 147
---------------------------

### A. Max Mod Min

> 一个序列 \\(\\{a\_n\\}\\)，每次把最大值模上最小值，然后删掉序列里所有 \\(0\\) .
> 
> 问多少轮后序列只剩一个元素 .
> 
> \\(2\\le n\\le 2\\times 10^5\\)，\\(1\\le a\_i\\le 10^9\\) .

根据辗转相除法的经典结论暴力即可 . 时间复杂度其实能分析小点，大概和下面那个做法的分析差不多吧 .

题解做法好牛逼啊，注意到最大值模最小值一定是新最小值，于是双端队列维护，时间复杂度 \\(\\Theta(n(\\log n+\\log V))\\)，\\(V\\) 是值域 .

### B. Swap to Sort

> 给一个排列 \\(\\{a\_n\\}\\) .
> 
> 操作：
> 
> *   A：选一个整数 \\(i\\in\[1,n-1\]\\)，然后交换 \\(a\_i,a\_{i+1}\\) .
> *   B：选一个整数 \\(i\\in\[1,n-1\]\\)，然后交换 \\(a\_i,a\_{i+2}\\) .
> 
> 进行不超过 \\(10^5\\) 次操作将序列排序，要求 A 操作数量最小，构造一组方案 .
> 
> \\(2\\le n\\le 400\\) .

咋感觉是 CF 原题 .

挺水的，B 操作只会影响下标奇偶性相同的数 .

于是排名和下标奇偶性相同的就可以直接用 B 换过去，如果不然则用一个 A 换即可，注意这个 A 要求是排名和下标奇偶性不同，这样可以省次数 .

时间复杂度 \\(\\Theta(n^2)\\)，总操作次数的一个松上界是 \\(\\dfrac{n(n-1)}2\\) 次，算出来是 \\(79800\\)，小于 \\(10^5\\)，可以通过 .

### C. Min Diff Sum

> 给 \\(n\\) 个区间 \\(\[l\_i,r\_i\]\\)，每个区间选一个点 \\(x\_i\\)，最小化
> 
> \\\[\\sum\_{i = 1}^{n-1}\\sum\_{j = i + 1} ^ n |x\_i - x\_j| \\\]
> 
> \\(2\\le n\\le 3\\times 10^5\\) .

一个歪解：考虑选出一个点，之后令所选的点尽可能靠近所选点，这样答案是单峰的，不过可能有几段的值都是相等的，不能三分，需要模拟退火，不过一轮模拟大概是 \\(\\Theta(n)\\) 到 \\(\\Theta(n\\log n)\\)，这样模拟退火复杂度不对，谁有基于这个的更高明的做法可以评论区发一下来教育博主 :<

正解还挺牛逼的：

令 \\(\\displaystyle L=\\max\_i\\{l\_i\\},R=\\min\_i\\{r\_i\\}\\)，则如果 \\(L\\ge R\\) 那么直接对于每个 \\(i\\) 选一个 \\(x\_i\\in\[R,L\]\\) 即可 .

若不然，则令 \\(p=\\underset{i}{\\arg\\max}\\{l\_i\\},q=\\underset{i}{\\arg\\min}\\{r\_i\\}\\) .

根据观察可以得到对于所有 \\(i\\) 都有 \\(x\_i\\in\[x\_q,x\_p\]\\)，否则可以调整得到更优的解 .

于是

\\\[\\sum\_{i = 1}^{n-1}\\sum\_{j = i+1}^n|x\_i - x\_j|=\\sum\_{i\\neq j\\neq l,r}|x\_i - x\_j|+\\sum\_{j = i+1}^n|x\_i - x\_j|+|x\_p-x\_q|+\\sum\_{i\\neq l,r}|x\_i - x\_q| + \\sum\_{i\\neq l,r}|x\_p-x\_i| \\\]

其中 \\(i\\neq j\\neq l,r\\) 的意思是 \\(i\\neq j\\land i\\neq l\\land i\\neq r\\land j\\neq l\\land j\\neq r\\) .

于是问题变成求解 \\(\\displaystyle \\sum\_{i\\neq j\\neq l,r}|x\_i - x\_j|\\) 这个子问题了，于是分治即可 .

将 \\(\\{l\\},\\{r\\}\\) 作为两维独立考虑，则 \\(\\{l\\}\\) 降序排序，\\(\\{r\\}\\) 升序排序后，答案就是

\\\[\\sum\_{i = 1}^n \\max\\{0,l\_i - r\_i\\}\\cdot (n - 2i + 1) \\\]

直接算即可，时间复杂度 \\(\\Theta(n)\\) .

### D. Sets Scores

> 有 \\(n\\) 个集合，\\(\\{s\_n\\}\\)，每个集合 \\(s\_i\\) 要求：
> 
> *   每个元素是不大于 \\(m\\) 的正整数 .
> *   相邻两个集合之中，有且仅有一个不同的数 .
> 
> 定义 \\(\\{s\_n\\}\\) 的分数为 \\(\\displaystyle\\prod\_{i=1}^m\\min\\{1,\\operatorname{cnt}(i)\\}\\) 其中 \\(\\operatorname{cnt}(i)\\) 为 \\(i\\) 在 \\(s\_{1\\dots n}\\) 中出现的次数之和 .
> 
> 问所有满足条件的 \\(\\{s\\}\\) 的分数和，对 \\(998244353\\) 取模 .
> 
> \\(1\\le n,m\\le 2\\times 10^5\\) .

好强……

令 \\(x\_i\\) 表示 \\(s\_i\\) 和 \\(s\_{i+1}\\) 相差的那个不同的数，则如果确定了 \\(s\_1\\) 和 \\(\\{x\\}\\) 即可确定全部的 \\(\\{s\\}\\) .

令 \\(a\_x\\)​ 表示对于所有 \\(i\\)，\\(x\\in s\_i\\) 的个数，\\(b\_x\\) 表示 \\(s\\notin s\_1\\)，对于 \\(i>1\\)，\\(x\\in s\_i\\) 的个数，那么选择 \\(s\_1\\) 的方案数就是 \\(\\displaystyle\\prod\_{i=1}^m(a\_i+b\_i)\\) .

观察可见 \\(a\_i+b\_i=n\\)，于是方案其实就是 \\(n^m\\) .

然后 \\(\\{x\\}\\) 显然就只有 \\(m^{n-1}\\) 种选法，于是乘起来就得到答案是 \\(n^mm^{n-1}\\)，快速幂解决，时间复杂度 \\(\\Theta(\\log n + \\log m)\\) .

### E. Examination

> 有 \\(n\\) 个学生，第 \\(i\\) 个人需要得到至少 \\(b\_i\\) 分，但是目前只有 \\(a\_i\\) 分 .
> 
> 你可以任意地交换两个学生的分数，以使得所有学生都能得到她需要的分数 .
> 
> 求最多能在多少学生不与别人交换分数的情况下，使得所有学生都能得到她需要的分数。无解输出 `-1` .
> 
> \\(2\\le n\\le 3\\times 10^5\\) .

令 \\(A\_x\\) 表示有多少个 \\(i\\) 满足 \\(a\_i\\le x\\)，类似的，\\(B\_x\\) 表示有多少个 \\(i\\) 满足 \\(b\_i\\le x\\) .

令 \\(C\_x=B\_x-A\_x\\)，则若 \\(C\_x<0\\) 就不合法 .

然后贪心换即可，不太想写，具体细节见 Official Editorial . 时间复杂度 \\(\\Theta(n\\log n)\\) .

AtCoder Regular Contest 146
---------------------------

### A. Three Cards

> \\(n\\) 个正整数，找三个数拼起来让数最大 .
> 
> \\(3\\le n\\le 2\\times 10^5\\)，每个数小于 \\(10^6\\) .

普及贪心题 .

### B. Plus and AND

> 给一个序列 \\(\\{a\_n\\}\\)，选不超过 \\(m\\) 个元素给它加一，最后选 \\(k\\) 个数，问 AND 最大是多少 .
> 
> \\(1\\le k\\le n\\le 2\\times 10^5\\)，\\(0\\le m,a\_i<2^{30}\\) .

原来是弱智贪心题，原来我是弱智 .

由贪心可知 AND 为 1 的位肯定越高越好，所以从高到低扫一遍算一下将其变为 1 所需要的最小次数大概就这样即可，其实等价于一个 binary-search .

然后算完之后排个序取最大的 \\(k\\) 个即可 . 时间复杂度大概是 \\(\\Theta(n\\log n\\log V)\\)，\\(V\\) 是值域 .

### C. Even XOR

> 问有多少集合 \\(S\\subseteq\\{0,1,2,3,\\cdots,2^n-1\\}\\) 满足其所有偶数大小非空子集的异或和不为 \\(0\\)，答案对 \\(998244353\\) 取模 .
> 
> \\(1\\le n\\le 2\\times 10^5\\) .

发现 APJ 发题解了，那么引个流 [APJ 题解](https://www.luogu.com.cn/blog/APJifengc/solution-at-arc146-c)，写的比我好建议看 APJ 的题解 .

APJifengc 第一小定理：

> 满足其所有非空子集的异或和不为 \\(0\\) 的集合 \\(S\\subseteq\\{0,1,2,3,\\cdots,2^n-1\\}\\) 的数量为
> 
> \\\[\\sum\_{i=0}^n\\dfrac1{i!}\\prod\_{j=1}^i(2^n-2^{j-1}) \\\]

证明：见 [各种小定理](https://www.cnblogs.com/CDOI-24374/p/16531615.html#apjifengc-%E7%AC%AC%E4%B8%80%E5%B0%8F%E5%AE%9A%E7%90%86) .

这样就解决了没有奇数限制的问题 .

有限制的也差不多，注意到如果两个大小为奇数的集合 \\(A,B\\) 异或和相等，则 \\(A\\oplus B\\) 是一个大小为偶数的异或和为 \\(0\\) 的集合，不符题意，于是所有大小为奇数的集合异或和均不同 .

于是根据 APJifengc 第一小定理的类似推导即可得到答案就是

\\\[\\sum\_{i=0}^n\\dfrac1{i!}\\prod\_{j=1}^i(2^n-2^{j-2}) \\\]

corner case 省略 .

APJ 的另一个推法是考虑对于序列 \\(\\{a\\}\\) 构造基底 \\(a\_1\\oplus a\_2,a\_1\\oplus a\_3,a\_1\\oplus a\_4,\\cdots\\)，这样显然是一组合法解 .

于是第 \\(i\\) 步的时候有 \\(i-1\\) 个数，也就有 \\(i-2\\) 个基底，这样就表明把 APJifengc 第一小定理的 \\(2^n-2^{j-1}\\) 改成 \\(2^n-2^{j-2}\\) 即可，完整式子同上 .

Classical 做法见 Official Editorial .

### D. >=<

> 构造一个长度为 \\(n\\) 每个数在 \\(\[1,m\]\\) 之间的整数序列 \\(\\{a\\}\\)，最小化其中所有数之和 . 不存在输出 `-1` .
> 
> 序列 \\(\\{a\\}\\) 有 \\(k\\) 个约束，每个约束形如一个四元组 \\((p\_i,q\_i,x\_i,y\_i)\\)，限制着序列 \\(\\{a\\}\\) 必须满足下面三者之一：
> 
> *   \\(a\_{p\_i}<x\_i\\) 且 \\(a\_{q\_i}<y\_i\\) .
> *   \\(a\_{p\_i}=x\_i\\) 且 \\(a\_{q\_i}=y\_i\\) .
> *   \\(a\_{p\_i}>x\_i\\) 且 \\(a\_{q\_i}>y\_i\\) .
> 
> \\(1\\le n,m,k\\le 2\\times 10^5\\) .

？？？

原限制等价于 \\((\[a\_{p\_i}<x\_i\]=\[a\_{q\_i}<y\_i\])\\land(\[a\_{p\_i}<x\_i+1\]=\[a\_{q\_i}<y\_i+1\])\\) .

每个限制挂点上，然后排个序按 BFS 序 chkmax 更新即可 .

时间复杂度大概是 \\(\\Theta(n+k)\\) .

AtCoder Regular Contest 145
---------------------------

### A. AB Palindrome

> 给一个长度为 \\(n\\) 仅含 \\(\\tt A,B\\) 的字符串，每次可以把一个长度为 \\(2\\) 的子串改成 \\(\\tt AB\\)，问能否把它改成回文串 .
> 
> \\(1\\le n\\le 2\\times 10^5\\) .

修改出来肯定是形如 \\(\\tt AAA\\cdots B\\) 或者 \\(\\tt ABB\\cdots BA\\)，观察可知，串串的开头是 \\(\\tt B\\) 或者末尾是 \\(\\tt A\\) 即可，一个特殊情况 \\(\\tt BA\\) 特判一下就可以了 .

### B. AB Game

> Alice 和 Bob 在取石子，总共 \\(k\\) 个石子，Alice 每次取 \\(a\\) 的倍数个，Bob 每次取 \\(b\\) 的倍数个，去不了的输 .
> 
> 给 \\(n,a,b\\)，问对于 \\(k\\in\[1,n\]\\)，有多少个情况 Alice 必胜 .
> 
> \\(1\\le n,a,b\\le 10^{18}\\) .

观察可知 Alice 取的越多越好，于是 Alice 必胜当且仅当 \\(k\\ge a\\) 且 \\(k\\bmod a<b\\) .

计数的话首先用一个前缀和拆了 \\(k\\ge a\\) 这个限制，然后 \\(k\\bmod a<b\\) 这个就随便做了 .

算出来 \\(k\\le n\\) 的答案是 \\(\\left\\lfloor\\dfrac na\\right\\rfloor\\min\\{a,b\\}+\\min\\{n\\bmod a,b-1\\}\\)，直接算时间复杂度 \\(\\Theta(1)\\) .

### C. Split and Maximize

> 一个排列 \\(\\{p\_{2n}\\}\\) 两个不交子序列 \\((a\_n,b\_n)\\) 的得分为 \\(\\displaystyle\\sum\_{i=1}^na\_ib\_i\\)，排列得分为其所有划分得分之最大值 .
> 
> 对所有排列 \\(\\{p\\}\\)，求得分取到最大值的排列数量 .

观察样例可以发现，划分 \\(a=(1,3,5,\\cdots,2n-1),b=(2,4,6,\\cdots,2n)\\) 这种配对方式一定取到最大的 \\(m\\) . 证明就打乱两项试试，或者直接用排序不等式的结论 .

对于每个排列要保证子序列的顺序，则配对方案是 Catalan 数 \\(C(n)\\)，决定划分的顺序方案数是 \\(2^n\\)，而总共有 \\(n!\\) 种初始排列，则答案为 \\(2^nn!C(n)=\\dfrac{2^n(2n)!}{(n+1)!}\\) .

可以 \\(\\Theta(n)\\) 或 \\(\\Theta(\\sqrt n\\log n)\\) 计算 .

### D. Non Arithmetic Progression Set

> 构造一个大小为 \\(n\\) 的集合，使得集合内元素之和为 \\(m\\)，且任意三项不构成等差数列 . 集合元素的值域限制为 \\(\[-10^7,10^7\]\\cap\\mathbb Z\\) .
> 
> \\(1\\le n\\le 10^4\\)，\\(|m|\\le 10^6n\\) .

其实不构成等差数列就是任意 \\(x,y,z\\) 满足 \\(x+y\\neq 2z\\) .

根据观察只需要构造 \\(x,y,z\\) 在三进制下仅含 \\(0,1\\) .

这样贪一下即可，为了省值域可以全局平移一下 .

* * *

#### 以下是博客签名，正文无关

本文来自博客园，作者：[Jijidawang](https://www.cnblogs.com/CDOI-24374/)，转载请注明原文链接：[https://www.cnblogs.com/CDOI-24374/p/16965800.html](https://www.cnblogs.com/CDOI-24374/p/16965800.html)

版权声明：本作品采用[「署名-非商业性使用-相同方式共享 4.0 国际」许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)（CC BY-NC-SA 4.0）进行许可。  
**如果文章有事实错误 / typo 请指出 QwQ**  
看完觉得有用请点个赞吧，求求了，这对我真的很重要 ![](http://tb2.bdstatic.com/tb/editor/images/qpx_n/b32.gif?t=20140803)