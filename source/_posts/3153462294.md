---
layout: post
title: "Android 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - GraphicBufferåŒæ­¥æœºåˆ¶ - Fence"
date: "2022-05-20T11:17:01.750Z"
---
Android 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - GraphicBufferåŒæ­¥æœºåˆ¶ - Fence
================================================

* * *

**å¿…è¯»ï¼š**

#### **Android 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - å¼€ç¯‡**

* * *

ä¸€ã€å‰è¨€
----

å‰é¢çš„æ–‡ç« ä¸­è®²è§£Android BufferQueueçš„æœºåˆ¶æ—¶ï¼Œæœ‰é‡åˆ°è¿‡Fenceï¼Œä½†æ²¡æœ‰å…·ä½“è®²è§£ã€‚è¿™ç¯‡æ–‡ç« ï¼Œå°±é’ˆå¯¹Fenceè¿™ç§åŒæ­¥æœºåˆ¶ï¼Œåšä¸€äº›ä»‹ç»ã€‚

Fenceåœ¨Androidå›¾åƒæ˜¾ç¤ºç³»ç»Ÿä¸­ç”¨äºGraphicBufferçš„åŒæ­¥ã€‚æˆ‘ä»¬ä¸ç¦æœ‰ç–‘é—®ï¼šé‚£å®ƒå’Œå…¶å®ƒçš„åŒæ­¥æœºåˆ¶ç›¸æ¯”æœ‰ä»€ä¹ˆç‰¹ç‚¹å‘¢ï¼Ÿ

Fenceä¸»è¦è¢«ç”¨æ¥å¤„ç†è·¨ç¡¬ä»¶çš„æƒ…å†µï¼Œåœ¨æˆ‘ä»¬å…³æ³¨çš„Androidå›¾åƒæ˜¾ç¤ºç³»ç»Ÿä¸­å³å¤„ç†CPUï¼ŒGPUå’ŒHWCä¹‹é—´çš„æ•°æ®åŒæ­¥ã€‚

äºŒã€Fenceçš„åŸºæœ¬ä½œç”¨
------------

åœ¨Android BufferQueueçš„æœºåˆ¶ä¸­ï¼ŒGraphicBufferåœ¨ç”Ÿäº§è€…--å›¾å½¢ç¼“å†²é˜Ÿåˆ—--æ¶ˆè´¹è€…ä¹‹é—´æµè½¬ã€‚æ¯ä¸€ä¸ªGraphicBufferéƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„BufferStateæ ‡è®°å…¶çŠ¶æ€ï¼Œè¯¦ç»†å¯ä»¥å‚è€ƒï¼šAndroid 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - BufferQueueçš„å·¥ä½œæµç¨‹ï¼ˆå…«ï¼‰

![](https://img2022.cnblogs.com/blog/979092/202205/979092-20220515124053104-1540070313.png)

æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-05-20å‘å¸ƒäºåšå®¢å›­

é€šå¸¸è¿™é‡Œçš„BufferStateä»£è¡¨çš„ä»…ä»…æ˜¯GraphicBufferçš„**æ‰€æœ‰æƒ**ï¼Œå³æ­¤åˆ»å®ƒå½’è°æ‰€æ‹¥æœ‰ï¼›ä½†è¿™å—ç¼“å­˜æ˜¯å¦å¯ä»¥è¢«æ‰€æœ‰è€…ä½¿ç”¨è¿˜éœ€è¦ç­‰å¾…åŒæ­¥ä¿¡å·åˆ°æ¥ï¼Œå³**ä½¿ç”¨æƒ**è¦ç­‰åˆ°ç›¸å…³çš„Fenceä¿¡å·å‘å‡ºæ‰å¯è·å¾—ã€‚

åœ¨BufferStateçš„å„ç§çŠ¶æ€çš„å®šä¹‰çš„è§£é‡Šä¸­å¯ä»¥çœ‹åˆ°ï¼š

    [/frameworks/native/libs/gui/include/gui/BufferSlot.h]
    // DEQUEUED indicates that the buffer has been dequeued by the producer, but
    // has not yet been queued or canceled. The producer may modify the
    // buffer's contents as soon as the associated release fence is signaled.
    // The slot is "owned" by the producer. 
    
    // QUEUED indicates that the buffer has been filled by the producer and
    // queued for use by the consumer. The buffer contents may continue to be
    // modified for a finite time, so the contents must not be accessed until
    // the associated fence is signaled. The slot is "owned" by BufferQueue.
    
    // ACQUIRED indicates that the buffer has been acquired by the consumer. As
    // with QUEUED, the contents must not be accessed by the consumer until the
    // acquire fence is signaled. The slot is "owned" by the consumer. 

ğŸ¥³ DEQUEUEDçŠ¶æ€æ—¶ï¼Œè™½ç„¶GraphicBufferè¢«ç”Ÿäº§è€…æ‹¥æœ‰ï¼Œä½†ç›´åˆ°å’Œè¿™å—ç¼“å­˜ç›¸å…³çš„release fenceåŒæ­¥ä¿¡å·å‘å‡ºåï¼Œç”Ÿäº§è€…æ‰èƒ½ä¿®æ”¹GraphicBufferçš„å†…å®¹ï¼›

ğŸ¤¡ QUEUEDçŠ¶æ€æ—¶ï¼Œè™½ç„¶GraphicBufferå·²ç»å…¥é˜Ÿåˆ—è¢«BufferQueueæŒæœ‰ï¼Œä½†ç›´åˆ°å’Œè¿™å—ç¼“å­˜ç›¸å…³çš„fenceåŒæ­¥ä¿¡å·å‘å‡ºå‰ï¼Œç”Ÿäº§è€…ä»å¯èƒ½ä¿®æ”¹GraphicBufferçš„å†…å®¹ï¼Œä¹Ÿå³fenceåŒæ­¥ä¿¡å·å‘å‡ºåï¼Œæ‰èƒ½å»è®¿é—®å…¶å†…å®¹ï¼›

ğŸ¤‘ ACQUIREDçŠ¶æ€æ—¶ï¼Œè™½ç„¶GraphicBufferè¢«ç”Ÿäº§è€…æ‹¥æœ‰ï¼Œä½†æ˜¯ç›´åˆ°acquire fenceåŒæ­¥ä¿¡å·å‘å‡ºåï¼Œæ¶ˆè´¹è€…æ‰å¯å»æ¶ˆè´¹ç¼“å­˜ä¸­çš„æ•°æ®ï¼›

* * *

**ä¸ºä»€ä¹ˆè¦æŠŠæ‰€æœ‰æƒå’Œä½¿ç”¨æƒåˆ†å¼€å‘¢ï¼Ÿ**

ä¸»è¦è¿˜æ˜¯CPUã€GPUè¿™ç§è·¨ç¡¬ä»¶ç¼–ç¨‹åŒæ­¥å¤„ç†çš„éœ€è¦ã€‚GPUç¼–ç¨‹å’Œçº¯CPUç¼–ç¨‹æœ‰ä¸€ä¸ªå¾ˆå¤§çš„ä¸åŒå°±æ˜¯å®ƒæ˜¯å¼‚æ­¥çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å½“æˆ‘ä»¬è°ƒç”¨GL commandè¿”å›æ—¶è¿™æ¡å‘½ä»¤å¹¶ä¸ä¸€å®šçœŸæ­£æ‰§è¡Œå®Œæˆäº†ï¼Œåªæ˜¯æŠŠè¿™ä¸ªå‘½ä»¤æ”¾åœ¨æœ¬åœ°çš„command bufferé‡Œã€‚å…·ä½“ä»€ä¹ˆæ—¶å€™è¿™æ¡GL commandè¢«çœŸæ­£æ‰§è¡Œå®Œæ¯•CPUæ˜¯ä¸çŸ¥é“çš„ï¼Œé™¤éCPUä½¿ç”¨glFinish()ç­‰å¾…è¿™äº›å‘½ä»¤æ‰§è¡Œå®Œï¼Œå¦å¤–ä¸€ç§æ–¹æ³•å°±æ˜¯åŸºäºåŒæ­¥å¯¹è±¡çš„Fenceæœºåˆ¶ã€‚  

è€Œå’ŒGraphicBufferç›¸å¯¹åº”çš„BufferStateçŠ¶æ€ä¸€å®šç¨‹åº¦ä¸Šè¯´æ˜äº†è¯¥GraphicBufferçš„å½’å±ï¼Œä½†åªæŒ‡ç¤ºäº†CPUé‡Œçš„çŠ¶æ€ï¼Œè€ŒGraphicBufferçš„çœŸæ­£ä½¿ç”¨è€…ä¸€èˆ¬æ˜¯GPUã€‚æ¯”å¦‚å½“ç”Ÿäº§è€…æŠŠä¸€ä¸ªGraphicBufferæ”¾å…¥BufferQueueæ—¶ï¼Œåªæ˜¯åœ¨CPUå±‚é¢å®Œæˆäº†å½’å±çš„è½¬ç§»ã€‚ä½†GPUè¯´ä¸å®šè¿˜åœ¨ç”¨ï¼Œå¦‚æœè¿˜åœ¨ç”¨çš„è¯æ¶ˆè´¹è€…æ˜¯ä¸èƒ½æ‹¿å»åˆæˆçš„ã€‚è¿™æ—¶å€™GraphicBufferå’Œç”Ÿäº§æ¶ˆè´¹è€…çš„å…³ç³»å°±æ¯”è¾ƒæš§æ˜§äº†ï¼Œæ¶ˆè´¹è€…å¯¹GraphicBufferå…·æœ‰æ‹¥æœ‰æƒï¼Œä½†æ— ä½¿ç”¨æƒï¼Œå®ƒéœ€è¦ç­‰ä¸€ä¸ªä¿¡å·ï¼Œå‘Šè¯‰å®ƒGPUç”¨å®Œäº†ï¼Œæ¶ˆè´¹è€…æ‰çœŸæ­£æ‹¥æœ‰ä½¿ç”¨æƒã€‚

* * *

ä¸€ä¸ªç®€åŒ–çš„æ¨¡å‹å¦‚ä¸‹ï¼š  
![](https://img2022.cnblogs.com/blog/979092/202205/979092-20220515150704439-523175202.png)

GraphicBufferç”±ä¸€ä¸ªä½¿ç”¨è€…ä¼ é€’åˆ°ä¸‹ä¸€ä¸ªä½¿ç”¨è€…ï¼Œå¹¶é€šè¿‡Fenceä¿¡å·å‘ŠçŸ¥æ–°çš„ä½¿ç”¨è€…ä»€ä¹ˆæ—¶å€™å¯ä»¥å¼€å§‹ä½¿ç”¨å®ƒã€‚Fenceçš„å­˜åœ¨éå¸¸å•çº¯ï¼Œä»è¯ç”Ÿå¼€å§‹å°±æ˜¯ä¸ºäº†åœ¨åˆé€‚çš„æ—¶é—´å‘å‡ºä¸€ä¸ªä¿¡å·ã€‚

å¦ä¸€ä¸ªè§’åº¦æ¥è¯´ï¼Œä¸ºä»€ä¹ˆä¸åœ¨ç”Ÿäº§è€…æŠŠGraphicBufferäº¤ç»™æ¶ˆè´¹è€…æ—¶å°±è°ƒç”¨glFinish()ç­‰GPUå®Œæˆå‘¢ï¼Ÿè¿™æ ·æ‹¥æœ‰æƒå’Œä½¿ç”¨æƒå°±ä¸€å¹¶ä¼ é€’äº†ï¼Œæ— éœ€Fenceã€‚å°±åŠŸèƒ½ä¸Šè¿™æ ·åšæ˜¯å¯ä»¥çš„ï¼Œä½†æ€§èƒ½ä¼šæœ‰å½±å“ï¼Œå› ä¸ºglFinish()æ˜¯é˜»å¡çš„ï¼Œè¿™æ—¶CPUä¸ºäº†ç­‰GPUè‡ªå·±ä¹Ÿä¸èƒ½å·¥ä½œäº†ã€‚å¦‚æœç”¨Fenceçš„è¯å°±å¯ä»¥ç­‰è¿™ä¸ªGraphicBufferçœŸæ­£è¦è¢«æ¶ˆè´¹è€…ç”¨åˆ°æ—¶å†é˜»å¡ï¼Œè€Œé‚£ä¹‹å‰CPUå’ŒGPUæ˜¯å¯ä»¥å¹¶è¡Œå·¥ä½œçš„ã€‚è¿™æ ·ç›¸å½“äºå®ç°äº†ä¸´ç•Œèµ„æºçš„lazy passingã€‚  

æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-05-20å‘å¸ƒäºåšå®¢å›­

ä¸‰ã€ç®€å•ä»‹ç»Fenceçš„å®ç°
--------------

Fenceï¼Œé¡¾åæ€ä¹‰å°±æ˜¯æŠŠå…ˆåˆ°çš„æ‹¦ä½ï¼Œç­‰åæ¥çš„ï¼Œä¸¤è€…æ­¥è°ƒä¸€è‡´äº†å†å¾€å‰èµ°ã€‚æŠ½è±¡åœ°è¯´ï¼ŒFenceåŒ…å«äº†åŒä¸€æˆ–ä¸åŒæ—¶é—´è½´ä¸Šçš„å¤šä¸ªæ—¶é—´ç‚¹ï¼Œåªæœ‰å½“è¿™äº›ç‚¹åŒæ—¶åˆ°è¾¾æ—¶Fenceæ‰ä¼šè¢«è§¦å‘ã€‚

æ›´è¯¦ç»†çš„ä»‹ç»å¯ä»¥å‚è€ƒè¿™ç¯‡æ–‡ç« [Android Synchronization Fences â€“ An Introduction](http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html)

Fenceå¯ä»¥ç”±ç¡¬ä»¶å®ç°(Graphic driver)ï¼Œä¹Ÿå¯ä»¥ç”±è½¯ä»¶å®ç°(Android kernelä¸­çš„sw\_sync)ã€‚EGLä¸­æä¾›äº†åŒæ­¥å¯¹è±¡çš„æ‰©å±•[KHR\_fence\_sync](https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_fence_sync.txt)ã€‚å…¶ä¸­æä¾›äº†eglCreateSyncKHR ()ï¼ŒeglDestroySyncKHR()äº§ç”Ÿå’Œé”€æ¯åŒæ­¥å¯¹è±¡ã€‚è¿™ä¸ªåŒæ­¥å¯¹è±¡æ˜¯å¾€GL commandé˜Ÿåˆ—ä¸­æ’å…¥çš„ä¸€ä¸ªç‰¹æ®Šæ“ä½œï¼Œå½“æ‰§è¡Œåˆ°å®ƒæ—¶ï¼Œä¼šå‘å‡ºä¿¡å·æŒ‡ç¤ºé˜Ÿåˆ—å‰é¢çš„å‘½ä»¤å·²å…¨éƒ¨æ‰§è¡Œå®Œæ¯•ã€‚å‡½æ•°eglClientWaitSyncKHR()å¯è®©è°ƒç”¨è€…é˜»å¡ç­‰å¾…ä¿¡å·å‘ç”Ÿã€‚

åœ¨æ­¤åŸºç¡€ä¹‹ä¸Šï¼ŒAndroidå¯¹å…¶è¿›è¡Œäº†æ‰©å±• --- [ANDROID\_native\_fence\_sync](https://www.khronos.org/registry/EGL/extensions/ANDROID/EGL_ANDROID_native_fence_sync.txt) ï¼Œæ–°åŠ äº†æ¥å£eglDupNativeFenceFDANDROID()ã€‚å®ƒå¯ä»¥æŠŠä¸€ä¸ªåŒæ­¥å¯¹è±¡è½¬åŒ–ä¸ºä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼ˆåè¿‡æ¥ï¼ŒeglCreateSyncKHR()å¯ä»¥æŠŠæ–‡ä»¶æè¿°ç¬¦è½¬æˆåŒæ­¥å¯¹è±¡)ã€‚è¿™ä¸ªæ‰©å±•ç›¸å½“äºè®©CPUä¸­æœ‰äº†GPUä¸­åŒæ­¥å¯¹è±¡çš„å¥æŸ„ï¼Œæ–‡ä»¶æè¿°ç¬¦å¯ä»¥åœ¨è¿›ç¨‹é—´ä¼ é€’(é€šè¿‡Binderç­‰IPCæœºåˆ¶)ï¼Œè¿™å°±ä¸ºå¤šè¿›ç¨‹é—´çš„åŒæ­¥æä¾›äº†åŸºç¡€ã€‚æˆ‘ä»¬çŸ¥é“Unixç³»ç»Ÿä¸€åˆ‡çš†æ–‡ä»¶ï¼Œå› æ­¤ï¼Œæœ‰ä¸ªè¿™ä¸ªæ‰©å±•ä»¥åFenceçš„é€šç”¨æ€§å¤§å¤§å¢å¼ºäº†ã€‚

Androidè¿˜è¿›ä¸€æ­¥ä¸°å¯Œäº†Fenceçš„software stackã€‚ä¸»è¦åˆ†å¸ƒåœ¨ä¸‰éƒ¨åˆ†ï¼š

*   C++ Fenceç±»ä½äº/frameworks/native/libs/ui/Fence.cpp;
*   Cçš„libsyncåº“ä½äº/system/core/libsync/sync.c;
*   Kernel driveréƒ¨åˆ†

æ€»å¾—æ¥è¯´ï¼Œkernel driveréƒ¨åˆ†æ˜¯åŒæ­¥çš„ä¸»è¦å®ç°ï¼Œlibsyncæ˜¯å¯¹driveræ¥å£çš„å°è£…ï¼ŒFenceæ˜¯å¯¹libsyncçš„è¿›ä¸€æ­¥çš„C++å°è£…ã€‚Fenceä¼šè¢«ä½œä¸ºGraphicBufferçš„é™„å±éšç€GraphicBufferåœ¨ç”Ÿäº§è€…å’Œæ¶ˆè´¹é—´ä¼ è¾“ã€‚å¦å¤–Fenceçš„è½¯ä»¶å®ç°ä½äº/drivers/base/sw\_sync.cã€‚SyncFeaturesç”¨ä»¥æŸ¥è¯¢ç³»ç»Ÿæ”¯æŒçš„åŒæ­¥æœºåˆ¶ï¼š/frameworks/native/libs/gui/SyncFeatures.cppã€‚

å››ã€Fenceåœ¨Androidå›¾åƒæ˜¾ç¤ºç³»ç»Ÿçš„å…·ä½“ç”¨æ³•
--------------------------

Fenceçš„ä¸»è¦ä½œç”¨å°±æ˜¯ä¿è¯GraphicBufferåœ¨App, GPUå’ŒHWCä¸‰è€…é—´æµè½¬æ—¶çš„æ•°æ®è¯»å†™åŒæ­¥ï¼ˆä¸åŒè¿›ç¨‹ or ä¸åŒç¡¬ä»¶é—´çš„åŒæ­¥ï¼‰ã€‚

æ¦‚è¿°ä¸‹ä»APPæ¸²æŸ“å›¾åƒå†™å…¥GraphicBufferç»SurfaceFlingerå¤„ç†æœ€ç»ˆå‘ˆç°åˆ°Displayçš„æ—…ç¨‹ï¼š

1\. GraphicBufferå…ˆç”±Appç«¯ä½œä¸ºç”Ÿäº§è€…è¿›è¡Œç»˜åˆ¶ï¼Œç„¶åæ”¾å…¥åˆ°BufferQueueï¼Œç­‰å¾…æ¶ˆè´¹è€…å–å‡ºä½œä¸‹ä¸€æ­¥çš„æ¸²æŸ“åˆæˆï¼›

2\. SurfaceFlingeræ˜¯Layerçš„ç®¡ç†è€…ä¹Ÿæ˜¯GraphicBufferçš„æ¶ˆè´¹è€…ï¼Œç”»é¢æ›´æ–°æ—¶ï¼ŒSurfaceFlingerä¼šæ”¶é›†æ‰€æœ‰å¯è§çš„å›¾å±‚å¹¶è¯¢é—®HWCå„ä¸ªå›¾å±‚é‡‡ç”¨çš„åˆæˆæ–¹å¼ï¼›

3\. å¯¹äºé‡‡ç”¨Deviceåˆæˆæ–¹å¼çš„å›¾å±‚ï¼ŒSurfaceFlingerä¼šç›´æ¥æŠŠè¯¥å›¾å±‚å¯¹åº”çš„GraphicBufferçš„buffer handleé€šè¿‡è°ƒç”¨setLayerBufferæ”¾å…¥HWCçš„Layer listï¼›

4\. å¯¹äºé‡‡ç”¨Clientåˆæˆæ–¹å¼çš„å›¾å±‚ï¼Œå³éœ€è¦GPUç»˜åˆ¶çš„å±‚ï¼ˆè¶…å‡ºHWCå¤„ç†å±‚æ•°æˆ–è€…æœ‰å¤æ‚å˜æ¢çš„ï¼‰ï¼ŒSurfaceFlingerä¼šå°†æ‰€æœ‰å¾…åˆæˆçš„å›¾å±‚é€šè¿‡renderengineç»˜åˆ¶åˆ°ä¸€å—client target bufferä¸­ï¼Œç„¶åé€šè¿‡è°ƒç”¨setClientTargetä¼ é€’ç»™HWCï¼Œæ­¤æ—¶SFå¯¹äºAPPæ¥è¯´æ˜¯æ¶ˆè´¹è€…ï¼Œå®ƒæ¶ˆè´¹APPç”Ÿæˆçš„å›¾å±‚æ•°æ®ï¼Œå¯¹äºHWCæ¥è¯´SFæ˜¯ç”Ÿäº§è€…ï¼Œå®ƒç”Ÿäº§target bufferç»™HWCæ¶ˆè´¹ï¼›

å‚è€ƒï¼šAndroid 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - SurfaceFlinger GPUåˆæˆ/CLIENTåˆæˆæ–¹å¼ - éšç¬”1

5\. HWCæœ€åå åŠ æ‰€æœ‰å›¾å±‚å†å¾€Displayå‘ˆç°å‡ºæ¥ï¼Œè¿™æ—¶HWCæ˜¯æ¶ˆè´¹è€…ã€‚æ•´ä¸ªå¤§è‡´æµç¨‹å¦‚å›¾ï¼š

  
![](https://img2022.cnblogs.com/blog/979092/202205/979092-20220518111819370-687490840.jpg)

    [/hardware/interfaces/graphics/composer/2.1/IComposerClient.hal]
    /** Possible composition types for a given layer. */
        enum Composition : int32_t {
            INVALID = 0,
            CLIENT = 1, 
            DEVICE = 2,
            SOLID_COLOR = 3,
            CURSOR = 4,
            SIDEBAND = 5,
        };

å¯ä»¥çœ‹åˆ°ï¼Œå¯¹äºåˆæˆæ–¹å¼æ˜¯CLIENTçš„å›¾å±‚æ¥è¯´ï¼Œå…¶GraphicBufferå…ˆåç»è¿‡ä¸¤ä¸ªç”Ÿäº§æ¶ˆè´¹è€…æ¨¡å‹ï¼š

âš½ åº”ç”¨æ¸²æŸ“æ—¶ == ç”Ÿäº§è€…/æ¶ˆè´¹è€…æ¨¡å‹

âš½ SurfaceFlingerçš„GPUåˆæˆæ—¶ == ç”Ÿäº§è€…/æ¶ˆè´¹è€…æ¨¡å‹Â 

æˆ‘ä»¬çŸ¥é“GraphicBufferæ ¸å¿ƒåŒ…å«çš„æ˜¯buffer\_handle\_tç»“æ„ï¼Œå®ƒæŒ‡å‘çš„native\_handle\_tåŒ…å«äº†Grallocä¸­ç”³è¯·å‡ºæ¥çš„å›¾å½¢ç¼“å†²åŒºçš„æ–‡ä»¶æè¿°ç¬¦å’Œå…¶å®ƒåŸºæœ¬å±æ€§ï¼Œè¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦ä¼šè¢«åŒæ—¶æ˜ å°„åˆ°å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ï¼Œä½œä¸ºå…±äº«å†…å­˜ï¼ˆè·¨è¿›ç¨‹çš„å…±äº«ï¼‰ã€‚  
![](https://img2022.cnblogs.com/blog/979092/202205/979092-20220518131844277-1722316713.png)

ç”±äºæœåŠ¡ç«¯è¿›ç¨‹å’Œå®¢æˆ·ç«¯è¿›ç¨‹éƒ½å¯ä»¥è®¿é—®åŒä¸€ç‰©ç†å†…å­˜ï¼Œå› æ­¤ä¸åŠ åŒæ­¥çš„è¯ä¼šå¼•èµ·é”™è¯¯ï¼ˆè¯»å†™å†²çª/æ··ä¹±ï¼‰ã€‚ä¸ºäº†åè°ƒå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä¸åŒè¿›ç¨‹ä¸‹å¯¹åŒä¸€å…±äº«å†…å­˜çš„è®¿é—®ï¼Œåœ¨ä¼ è¾“GraphicBufferæ—¶ï¼Œè¿˜å¸¦æœ‰Fenceï¼Œæ ‡å¿—äº†å®ƒæ˜¯å¦è¢«ä¸Šä¸€ä¸ªä½¿ç”¨è€…ä½¿ç”¨å®Œæ¯•ã€‚

FenceæŒ‰ä½œç”¨å¤§ä½“åˆ†ä¸¤ç§ï¼šacquireFenceå’ŒreleaseFenceã€‚å‰è€…ç”¨äºç”Ÿäº§è€…é€šçŸ¥æ¶ˆè´¹è€…ç”Ÿäº§å·²å®Œæˆï¼Œåè€…ç”¨äºæ¶ˆè´¹è€…é€šçŸ¥ç”Ÿäº§è€…æ¶ˆè´¹å·²å®Œæˆã€‚ä¸‹é¢åˆ†åˆ«çœ‹ä¸€ä¸‹è¿™ä¸¤ç§Fenceçš„äº§ç”Ÿå’Œä½¿ç”¨è¿‡ç¨‹ã€‚é¦–å…ˆæ˜¯acquireFenceçš„ä½¿ç”¨æµç¨‹ï¼š  
![](https://img2022.cnblogs.com/blog/979092/202205/979092-20220519162144869-2019738534.jpg)

å½“Appç«¯é€šè¿‡queueBuffer()å‘BufferQueueæ’å…¥GraphicBufferæ—¶ï¼Œä¼šé¡ºå¸¦ä¸€ä¸ªFenceï¼Œè¿™ä¸ªFenceæŒ‡ç¤ºè¿™ä¸ªGraphicBufferæ˜¯å¦å·²è¢«ç”Ÿäº§è€…ç”¨å¥½ã€‚ä¹‹åè¯¥GraphicBufferè¢«æ¶ˆè´¹è€…é€šè¿‡acquireBuffer()æ‹¿èµ°ï¼ŒåŒæ—¶ä¹Ÿä¼šå–å‡ºè¿™ä¸ªacquireFenceã€‚ä¹‹åæ¶ˆè´¹è€…ï¼ˆä¹Ÿå°±æ˜¯SurfaceFlingerï¼‰è¦æŠŠå®ƒæ‹¿æ¥æ¸²æŸ“æ—¶ï¼Œéœ€è¦ç­‰å¾…Fenceè¢«è§¦å‘ï¼Œä¹‹åæ‰å¯ä»¥å¤„ç†è¿™å—ç¼“å­˜ä¸­çš„æ•°æ®ã€‚

æˆ‘ä»¬çœ‹ä¸€ä¸‹ç›¸å…³æµç¨‹ä¸­çš„å…³é”®ä»£ç ç‰‡æ®µï¼š

#### ç”Ÿäº§ç«¯åœ¨queueBufferæ—¶ï¼Œä¼ é€’è¿›æ¥Fence

    [ /frameworks/native/libs/gui/Surface.cpp ]
    int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) {
        ... // fenceFdå³ä¸ºç”Ÿäº§è€…ä¼ é€’è¿›æ¥çš„ï¼Œè¿›ä¸€æ­¥å°è£…ä¸ºFence Object,è¿åŒGraphicBufferä¸€å—å…¥é˜Ÿåˆ—
        getQueueBufferInputLocked(buffer, fenceFd, mTimestamp, &input);
        status_t err = mGraphicBufferProducer->queueBuffer(i, input, &output);
        ...
    }

#### æ¶ˆè´¹ç«¯åœ¨acquireBufferæ—¶ï¼ŒåŒæ—¶å–å¾—acquireFenceï¼Œä¼ é€’ç»™æœ€ç»ˆçš„æ¶ˆè´¹è€…SurfaceFlinger

    [ /frameworks/native/libs/gui/BLASTBufferQueue.cpp ]
    void BLASTBufferQueue::processNextBufferLocked(bool useNextTransaction) {
        ...
        BufferItem bufferItem;
        status_t status =
        mBufferItemConsumer->acquireBuffer(&bufferItem, 0 /* expectedPresent */, false); //è¯·æ±‚å¯ç”¨çš„buffer
        ...
        auto buffer = bufferItem.mGraphicBuffer;
        ...
        t->setBuffer(mSurfaceControl, buffer, releaseCallbackId, releaseBufferCallback); // ä¼ é€’Bufferç»™SurfaceFlinger
        t->setDataspace(mSurfaceControl, static_cast<ui::Dataspace>(bufferItem.mDataSpace));
        t->setHdrMetadata(mSurfaceControl, bufferItem.mHdrMetadata);
        t->setSurfaceDamageRegion(mSurfaceControl, bufferItem.mSurfaceDamage);
        t->setAcquireFence(mSurfaceControl, // ä¼ é€’fenceç»™SurfaceFlinger
                           bufferItem.mFence ? new Fence(bufferItem.mFence->dup()) : Fence::NO_FENCE);
        ...
    }

#### SurfaceFlingeræ¥å—bufferä¸fenceå¹¶è®¾ç½®åˆ°å¯¹åº”çš„Layer

    [/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp]
    uint32_t SurfaceFlinger::setClientStateLocked() {
        ...
        if (what & layer_state_t::eAcquireFenceChanged) {
            if (layer->setAcquireFence(s.acquireFence)) flags |= eTraversalNeeded; // ä¼ é€’ç»™Layer
        }
        ...
            if (layer->setBuffer(buffer, s.acquireFence, postTime, desiredPresentTime, isAutoTimestamp, // ä¼ é€’ç»™Layer
                                 s.cachedBuffer, frameNumber, dequeueBufferTimestamp, frameTimelineInfo,
                                 s.releaseBufferListener)) {
                flags |= eTraversalNeeded;
            }
        ...
    }

#### LayeræŠŠä¿¡æ¯ Buffer &Â acquireFenceä¿å­˜åˆ°mDrawingState

    mDrawingState.buffer = buffer;
    mDrawingState.acquireFence = fence;

#### åˆæˆé˜¶æ®µç­‰å¾…acquireFenceè§¦å‘åå†å»å¤„ç†æ•°æ®

SurfaceFlingeråœ¨å¯¹Layerè¿›è¡Œé‡æ–°ç»˜åˆ¶æ—¶ï¼Œ`**BufferLayer::latchBuffer**`ä¸­ä¼šå…ˆå»åˆ¤æ–­mDrawingStateè®°å½•çš„æœ€æ–°è®¾ç½®ä¸‹æ¥çš„GraphicBufferçš„acquire fenceæ˜¯å¦å·²ç»signaledï¼Œæ²¡æœ‰çš„è¯ä¼šå†ç»§ç»­`**SurfaceFlinger::signalLayerUpdate ==> invalidate**`å°è¯•ï¼Œç›´åˆ°acquire fenceè¢«è§¦å‘ï¼Œå†å»ç»§ç»­æ‰§è¡Œ`**updateTexImage==>updateActiveBuffer**`ç­‰åˆæˆå‰çš„å‡†å¤‡å·¥ä½œã€‚

    // invalidate
    SurfaceFlinger::handleMessageInvalidate()
    // pageflip
    SurfaceFlinger::handlePageFlip()
    // ç„¶åè°ƒç”¨åˆ°latchBuffer
    BufferLayer::latchBuffer() {
        ...
        // If the head buffer's acquire fence hasn't signaled yet, return and
        // try again later
        if (!fenceHasSignaled()) { // ç­‰å¾…acquire fenceçš„é€»è¾‘
            ATRACE_NAME("!fenceHasSignaled()");
            mFlinger->signalLayerUpdate(); // ä¼šå†æ¬¡è§¦å‘invalidate
            return false;
        }
        ...
    }

æ³¨ï¼šä¸Šé¢çš„ç†è§£ï¼Œæˆ‘ä¹Ÿåªæ˜¯æ ¹æ®ä»£ç æ¥åˆ¤æ–­çš„ï¼Œæ²¡æœ‰å®é™…éªŒè¯è¿‡ï¼Œç†è§£ä¹Ÿè®¸æœ‰é”™ï¼Œä»…ä¾›å‚è€ƒï¼

æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-05-20å‘å¸ƒäºåšå®¢å›­

å¦‚æœå›¾å±‚æ˜¯DEVICEåˆæˆæ–¹å¼æ¸²æŸ“ï¼Œé‚£ä¹ˆä¸éœ€è¦ç»è¿‡GPUï¼Œé‚£å°±éœ€è¦æŠŠè¿™äº›å±‚å¯¹åº”çš„acquireFenceä¼ åˆ°HWCä¸­ã€‚è¿™æ ·ï¼ŒHWCåœ¨åˆæˆå‰å°±èƒ½ç¡®è®¤è¿™ä¸ªbufferæ˜¯å¦å·²è¢«ç”Ÿäº§è€…ä½¿ç”¨å®Œï¼Œå› æ­¤ä¸€ä¸ªæ­£å¸¸ç‚¹çš„HWCéœ€è¦ç­‰è¿™äº›ä¸ªacquireFenceå…¨è¢«è§¦å‘æ‰èƒ½å»ç»˜åˆ¶ã€‚æ‰€ä»¥åœ¨å‘HWCè®¾ç½®setLayerBufferæ—¶ï¼Œä¹Ÿä¼šæŠŠä¼ é€’acquireFence

    [/frameworks/native/services/surfaceflinger/DisplayHardware/ComposerHal.cpp]
    Error Composer::setLayerBuffer(Display display, Layer layer,
            uint32_t slot, const sp<GraphicBuffer>& buffer, int acquireFence)
    {
        mWriter.selectDisplay(display);
        mWriter.selectLayer(layer);
    
        const native_handle_t* handle = nullptr;
        if (buffer.get()) {
            handle = buffer->getNativeBuffer()->handle;
        }
    
        mWriter.setLayerBuffer(slot, handle, acquireFence);
        return Error::NONE;
    }

æˆ‘è¿™é‡Œæœ‰ä¸€ä¸ªç–‘é—®ï¼šå¦‚æœä¸Šé¢`**BufferLayer::latchBuffer**`ä¸­åˆ†æçš„ç­‰å¾…acquireFenceçš„é€»è¾‘æ˜¯æ­£ç¡®çš„ï¼Œé‚£è¿™ä¸ªç­‰å¾…çš„é€»è¾‘çœ‹èµ·æ¥æ˜¯ç›´æ¥ä¼ é€’ç»™HWCåˆæˆçš„bufferä¹Ÿä¼šç»è¿‡è¿™é‡Œï¼Œé‚£æ˜¯ä¸æ˜¯setLayerBufferå†ä¼ é€’acquireFenceç»™HWCï¼Œå…¶å®HWCå°±æ— éœ€å†åˆ¤æ–­acquireFenceæ˜¯å¦è¢«è§¦å‘äº†å‘¢ï¼Ÿå› ä¸ºlatchBufferä¸­çš„é€»è¾‘ä¿è¯äº†ä¼ é€’ç»™HWCçš„bufferè‚¯å®šæ˜¯å¯ä»¥ç›´æ¥æ“ä½œçš„äº†

å¯¹äºCLIENTåˆæˆæ–¹å¼çš„å›¾å±‚ï¼Œå› ä¸ºHWCä¸éœ€è¦ç›´æ¥è¿™äº›å±‚åŒæ­¥ï¼Œå®ƒåªè¦å’Œè¿™äº›CLIENTå›¾å±‚åˆæˆçš„ç»“æœFramebufferTargetåŒæ­¥å°±å¯ä»¥äº†ã€‚

GPUè¿›ç¨‹åˆæˆCLIENTå›¾å±‚å‰ï¼Œä¼šå»RenderSurface::dequeueBufferè·å–ä¸€å—GraphicBufferç”¨æ¥å­˜å‚¨åˆæˆçš„ç»“æœï¼Œç„¶åä½¿ç”¨SkiaGLRenderEngine::drawLayerså»æŠŠæ‰€æœ‰CLIENTå›¾å±‚ç”»åˆ°è¿™å—å›¾å½¢ç¼“å­˜ä¸­ã€‚

    [/frameworks/native/libs/renderengine/skia/SkiaGLRenderEngine.cpp]
    status_t SkiaGLRenderEngine::drawLayers(const DisplaySettings& display,
                                            const std::vector<const LayerSettings*>& layers,
                                            const std::shared_ptr<ExternalTexture>& buffer,
                                            const bool /*useFramebufferCache*/,
                                            base::unique_fd&& bufferFence, base::unique_fd* drawFence) {
        ...
        // wait on the buffer to be ready to use prior to using it
        waitFence(bufferFence); // ç­‰å¾…bufferå¯ç”¨ï¼Œè¿™å—bufferå°±æ˜¯é€šè¿‡RenderSurface::dequeueBufferè·å–çš„
        ...
        if (drawFence != nullptr) {
            *drawFence = flush(); // è¿™ä¸ªdrawFenceç”¨ä½œåŒæ­¥HWCï¼Œå‘Šè¯‰HWC: æˆ‘GPUç”»å®Œäº†ï¼Œä½ HWCæ¶ˆè´¹å§
        }
    }

GPUåˆæˆå®ŒCLIENTå›¾å±‚åï¼Œé€šè¿‡RenderSurface::queueBuffer()å°†GraphicBufferæ”¾å…¥å¯¹åº”çš„BufferQueueï¼ŒåŒ…æ‹¬å¯¹åº”çš„Fence == SkiaGLRenderEngine::drawLayersæ—¶äº§ç”Ÿçš„ï¼›ç„¶åæ¶ˆè´¹ç«¯FramebufferSurfaceé€šè¿‡advanceFrame() --> nextBuffer() -> acquireBufferLocked()ä»BufferQueueä¸­æ‹¿ä¸€ä¸ªGraphicBufferï¼Œé™„å¸¦æ‹¿åˆ°å®ƒçš„acquireFenceã€‚æ¥ç€è°ƒç”¨

    [/frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp]
    status_t FramebufferSurface::nextBuffer(uint32_t& outSlot,
            sp<GraphicBuffer>& outBuffer, sp<Fence>& outFence,
            Dataspace& outDataspace) {
        ...
        status_t result = mHwc.setClientTarget(mDisplayId, outSlot, outFence, outBuffer, outDataspace);
        ...
    }

å…¶ä¸­ä¼šæŠŠåˆšæ‰acquireçš„GraphicBufferè¿å¸¦acquireFenceé€šè¿‡è°ƒç”¨setClientTargetè®¾åˆ°HWCçš„ClientTarget Layerã€‚

ç»¼ä¸Šï¼ŒHWCè¿›è¡Œæœ€ååˆæˆå¤„ç†çš„å‰ææ˜¯CLIENTå›¾å±‚å±‚çš„acquireFenceåŠFramebufferTargetçš„acquireFenceéƒ½è¢«è§¦å‘ã€‚

çœ‹å®ŒacquireFenceï¼Œå†çœ‹çœ‹releaseFenceçš„ä½¿ç”¨æµç¨‹ï¼š

![](https://img2022.cnblogs.com/blog/979092/202205/979092-20220520141227653-264464529.jpg)

åˆæˆè¿‡ç¨‹ä¸­ï¼Œå…ˆæ˜¯GPUå·¥ä½œï¼Œåœ¨`**Output::composeSurfaces()**`å‡½æ•°ä¸­å¯¹CLIENTåˆæˆæ–¹å¼çš„å›¾å±‚è¿›è¡Œåˆæˆï¼Œç»“æœæ”¾åœ¨framebufferä¸­ï¼ˆå³RenderSurface::dequeueBufferè·å¾—çš„GraphicBufferï¼‰ã€‚ç„¶åSurfaceFlingerä¼šè°ƒç”¨`**Output::postFramebuffer()**`è®©HWCå¼€å§‹å·¥ä½œã€‚`**postFramebuffer()**`ä¸­æœ€ä¸»è¦æ˜¯è°ƒç”¨`**Display::presentAndGetFrameFences()**`æœ€ç»ˆä¼šè°ƒç”¨åˆ°HWCçš„æ–¹æ³•`**present**`å’Œ`**getReleaseFences**`é€šçŸ¥HWCåˆæˆæ˜¾ç¤ºå¹¶è¿”å›å¾—åˆ°releaseFenceã€‚

HWCä¸­äº§ç”Ÿçš„releaseFenceä¸»è¦æ˜¯ï¼šåŒæ­¥DEVICEåˆæˆæ–¹å¼çš„Layerçš„GraphicBufferçš„é‡Šæ”¾ï¼›

    [/frameworks/native/services/surfaceflinger/CompositionEngine/src/Output.cpp]
    void Output::postFramebuffer() {
        ...
        auto& outputState = editState();
        outputState.dirtyRegion.clear();
        mRenderSurface->flip();
    
        auto frame = presentAndGetFrameFences(); // é€šçŸ¥HWCåˆæˆæ˜¾ç¤ºå¹¶è·å–åˆ°releaseFence
    
        mRenderSurface->onPresentDisplayCompleted(); // é€šçŸ¥FramebufferSurfaceè¿›è¡Œrelease buffer ==>èµ°åˆ°FramebufferSurface::onFrameCommitted()
    
        for (auto* layer : getOutputLayersOrderedByZ()) {
            // The layer buffer from the previous frame (if any) is released
            // by HWC only when the release fence from this frame (if any) is
            // signaled.  Always get the release fence from HWC first.
            sp<Fence> releaseFence = Fence::NO_FENCE;
    
            if (auto hwcLayer = layer->getHwcLayer()) { // è·å–Layerå¯¹åº”çš„releaseFence
                if (auto f = frame.layerFences.find(hwcLayer); f != frame.layerFences.end()) {
                    releaseFence = f->second;
                }
            }
    
            // If the layer was client composited in the previous frame, we
            // need to merge with the previous client target acquire fence.
            // Since we do not track that, always merge with the current
            // client target acquire fence when it is available, even though
            // this is suboptimal.
            // TODO(b/121291683): Track previous frame client target acquire fence.
            if (outputState.usesClientComposition) {
                // å¦‚æœæœ‰GPUåˆæˆLayerï¼ˆClientåˆæˆæ–¹å¼ï¼‰ï¼ŒåšFence::merge
                // releaseFence -- HWCç”Ÿæˆçš„
                // clientTargetAcquireFence -- æœ¬è´¨æ˜¯ RenderSurface::queueBufferä¼ å…¥çš„ acquire fenceï¼Œæ˜¯åœ¨SkiaGLRenderEngine::drawLayersä¸­ç”Ÿæˆçš„
                releaseFence =
                        Fence::merge("LayerRelease", releaseFence, frame.clientTargetAcquireFence);
            }
    
            layer->getLayerFE().onLayerDisplayed(releaseFence); // æŠŠreleaseFenceåŒæ­¥åˆ°å„ä¸ªLayer
        }
        ...
    }

å¯¹äºDEVICEåˆæˆçš„Layerï¼Œå› ä¸ºæ˜¯HWCæ¶ˆè´¹è¿™äº›å›¾å±‚çš„GraphicBufferæ•°æ®ã€‚æ‰€ä»¥HWCäº§ç”Ÿçš„release fenceæ¥åŒæ­¥è¿™äº›å›¾å½¢ç¼“å­˜çš„é‡Šæ”¾ï¼›

å¯¹äºCLIENTåˆæˆçš„Layerï¼Œå› ä¸ºæ˜¯GPUæ¶ˆè´¹è¿™äº›å›¾å±‚çš„GraphicBufferæ•°æ®å¹¶åˆæˆåˆ°client targetä¸­ã€‚æ‰€ä»¥å½“GPUå®Œæˆåˆæˆæ—¶å°±æ„å‘³ç€è¿™äº›å›¾å±‚çš„ç¼“å­˜æ•°æ®å°±ä¸å†è¢«ä½¿ç”¨äº†ï¼Œå› æ­¤client target acquire fenceä½œä¸ºrelease fenceæ¥åŒæ­¥è¿™äº›å›¾å½¢ç¼“å­˜çš„é‡Šæ”¾ï¼›

client target acquire fenceå³è¡¨ç¤ºGPUåˆæˆå®Œäº†ï¼ŒHWCå¯ä»¥æ¶ˆè´¹äº†ï¼Œä¹Ÿæ„å‘³ç€ç›¸å…³Layerçš„å›¾åƒç¼“å­˜å¯ä»¥é‡Šæ”¾äº†ã€‚

release fenceéœ€è¦åŒæ­¥åˆ°Layerã€‚å®ç°ä½äºLayerçš„onLayerDisplayed()å‡½æ•°ä¸­ï¼š

    [/frameworks/native/services/surfaceflinger/BufferStateLayer.cpp]
    void BufferStateLayer::onLayerDisplayed(const sp<Fence>& releaseFence) {
        ...
        sp<CallbackHandle> ch;
        for (auto& handle : mDrawingState.callbackHandles) {
            if (handle->releasePreviousBuffer) {
                ch = handle;
                break;
            }
        }
        auto status = addReleaseFence(ch, releaseFence);
        if (status != OK) {
            ALOGE("Failed to add release fence for layer %s", getName().c_str());
        }
    
        mPreviousReleaseFence = releaseFence;
    }

ä¸­é—´è¿˜ä¼šæœ‰ä¸€äº›è¿‡ç¨‹ï¼Œç„¶åç»è¿‡Binder å›è°ƒï¼Œä¼šé€šçŸ¥åˆ°BLASTBufferQueueï¼Œæˆ‘ä»¬åœ¨setBufferæ—¶ï¼Œæœ‰è®¾ç½®ä¸€ä¸ª`**releaseBufferCallback**`,è¿™ä¸ªå›è°ƒä¸­ä¼šæ”¶åˆ°release fenceï¼Œæœ€ç»ˆä¼šè°ƒåˆ° releaseBuffer è¿åŒfenceä¸€å—å½’è¿˜åˆ°ç¼“å­˜é˜Ÿåˆ—ä¸­ï¼Œä¹‹åç”Ÿäº§è€…å°±å¯ä»¥dequeueBufferæ—¶å–åˆ°è¿™å—ç¼“å­˜äº†

    [/frameworks/native/libs/gui/BLASTBufferQueue.cpp]
    void BLASTBufferQueue::processNextBufferLocked(bool useNextTransaction) {
    
        auto releaseBufferCallback =
                std::bind(releaseBufferCallbackThunk, wp<BLASTBufferQueue>(this) /* callbackContext */,
                          std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
                          std::placeholders::_4);
        t->setBuffer(mSurfaceControl, buffer, releaseCallbackId, releaseBufferCallback); // è®¾ç½®äº†releaseBufferCallback
        
    }

  
é‚£å¯¹äºå­˜å‚¨GPUç»˜åˆ¶ç»“æœçš„é‚£ä¸€å±‚å‘¢ï¼Ÿ

Output::postFramebuffer() ==> RenderSurface::onPresentDisplayCompleted() ==>FramebufferSurface::onFrameCommitted()

    [/frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp]
    void FramebufferSurface::onFrameCommitted() {
        if (mHasPendingRelease) {
            sp<Fence> fence = mHwc.getPresentFence(mDisplayId); // è·å–release fence
            if (fence->isValid()) {
                status_t result = addReleaseFence(mPreviousBufferSlot,
                        mPreviousBuffer, fence);
                ALOGE_IF(result != NO_ERROR, "onFrameCommitted: failed to add the"
                        " fence: %s (%d)", strerror(-result), result);
            }
            status_t result = releaseBufferLocked(mPreviousBufferSlot, mPreviousBuffer); // release buffer
            ALOGE_IF(result != NO_ERROR, "onFrameCommitted: error releasing buffer:"
                    " %s (%d)", strerror(-result), result);
    
            mPreviousBuffer.clear();
            mHasPendingRelease = false;
        }
    }

  
æ­¤å¤„æ‹¿åˆ°HWCç”Ÿæˆçš„FramebufferTargetçš„releaseFenceï¼Œè®¾åˆ°FramebufferSurfaceä¸­ç›¸åº”çš„GraphicBuffer Slotä¸­ã€‚è¿™æ ·FramebufferSurfaceå¯¹åº”çš„GraphicBufferä¹Ÿå¯ä»¥è¢«é‡Šæ”¾å›BufferQueueäº†ã€‚å½“å°†æ¥EGLä»ä¸­æ‹¿åˆ°è¿™ä¸ªbufferæ—¶ï¼Œç…§ä¾‹ä¹Ÿè¦å…ˆç­‰å¾…è¿™ä¸ªreleaseFenceè§¦å‘æ‰èƒ½ä½¿ç”¨ã€‚

è®²åˆ°è¿™é‡Œï¼Œfenceçš„å†…å®¹å°±å·®ä¸å¤šäº†ã€‚ä¸è¿‡å¥½å¤šç»†èŠ‚çš„ä¸œè¥¿éƒ½æ²¡åˆ†æï¼Œä¹Ÿè®¸è¿˜æœ‰ç†è§£é”™è¯¯ã€‚

æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-05-20å‘å¸ƒäºåšå®¢å›­

* * *

Fenceåœ¨å›¾å½¢æ˜¾ç¤ºç³»ç»Ÿä¸­ï¼Œæˆ‘è§‰å¾—ç®€å•ç‚¹è®²ï¼Œåº”è¯¥å°±æ¦‚æ‹¬ä¸º2ä¸ªä½œç”¨ï¼š

1\. ç”Ÿäº§è€…å¡«å……æ•°æ®åˆ°GraphicBufferï¼Œå¹¶é™„å¸¦äº§ç”Ÿä¸€ä¸ªacquire fenceï¼Œè¿™å—bufferè¿åŒfenceä¸€å—è¿”å›åˆ°BufferQueueï¼ŒacquireBufferåè¢«æ¶ˆè´¹è€…å–èµ° Â --> æ­¤æ—¶acquire fenceçš„ä½œç”¨

    // æ¶ˆè´¹è€…ç„¦æ€¥çš„ç­‰å¾…....
    
    ç”Ÿäº§è€…ï¼šHi, æ¶ˆè´¹è€…ï¼Œæˆ‘æŠŠæ•°æ®éƒ½å†™åˆ°bufferäº†ï¼Œä½ å‡†å¤‡å°½æƒ…æ¶ˆè´¹å§ï¼
    æ¶ˆè´¹è€…ï¼šæ”¶åˆ°ï¼Œé‚£æˆ‘å¼€å§‹æ¶ˆè´¹äº†å“¦ï¼

2\. æ¶ˆè´¹è€…ä½¿ç”¨å®ŒGraphicBufferä¸­çš„æ•°æ®ï¼Œå¹¶é™„å¸¦äº§ç”Ÿä¸€ä¸ªrelease fenceï¼Œè¿™å—bufferè¿åŒfenceä¸€å—è¿”å›åˆ°BufferQueueï¼ŒdequeueBufferåè¢«ç”Ÿäº§è€…å–èµ°Â  --> æ­¤æ—¶release fenceçš„ä½œç”¨

    // ç”Ÿäº§è€…ç„¦æ€¥çš„ç­‰å¾…....
    
    æ¶ˆè´¹è€…ï¼šHiï¼Œç”Ÿäº§è€…ï¼Œè¿™å—bufferä¸­çš„æ•°æ®æˆ‘æ¶ˆè´¹å®Œäº†ï¼Œä¸å†ä½¿ç”¨äº†å“¦ï¼
    ç”Ÿäº§è€…ï¼šæ”¶åˆ°ï¼Œé‚£æˆ‘å°±å‘è¿™å—bufferä¸­å¡«å……æ–°çš„æ•°æ®äº†

â€ƒâ€ƒä¹Ÿè®¸ç†è§£ä¸æ­£ç¡®ï¼Œè°¨æ…é˜…è¯»ï¼Œå°±å…ˆè¿™æ ·å§ğŸ˜º

* * *

\----

æœ¬æ–‡å‚è€ƒäº†å¾ˆå¤šæœ‰ä»·å€¼çš„æ–‡ç« ï¼Œå¹¶æ®æ­¤ä¿®æ”¹æ¥ç†è§£Android 12 ä¸­çš„é€»è¾‘ï¼Œç«™åœ¨å·¨äººçš„è‚©è†€ä¸Šå¯ä»¥çœ‹çš„æ›´è¿œã€‚æœ¬ç¯‡ä»…ä¾›å­¦ä¹ å‚è€ƒï¼Œç†è§£ä¸Šéš¾å…æœ‰é”™è¯¯ï¼

[https://blog.csdn.net/jinzhuojun/article/details/39698317](https://blog.csdn.net/jinzhuojun/article/details/39698317)Â 

[https://zhuanlan.zhihu.com/p/68782630](https://zhuanlan.zhihu.com/p/68782630)

[https://www.jianshu.com/p/3c61375cc15b](https://www.jianshu.com/p/3c61375cc15b)

å¿ƒæœ‰çŒ›è™ï¼Œç»†å—…è”·è–‡ï¼Œç”Ÿæ´»å°±è¯¥æ— æƒ§æ— æ‚”

* * *

![](https://img2022.cnblogs.com/blog/979092/202203/979092-20220322104528841-687741034.jpg)

ä½œè€…ï¼š[](https://www.cnblogs.com/roger-yu)[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)

å‡ºå¤„ï¼š[](https://www.cnblogs.com/roger-yu)[https://www.cnblogs.com/roger-yu/p/16270090.html](https://www.cnblogs.com/roger-yu/p/16270090.html)

æœ¬æ–‡ç‰ˆæƒå½’ä½œè€…å’Œåšå®¢å›­å…±æœ‰ï¼Œè½¬è½½å¿…é¡»ç»™å‡ºåŸæ–‡é“¾æ¥ï¼Œå¹¶ä¿ç•™æ­¤æ®µå£°æ˜ï¼Œå¦åˆ™ä¿ç•™è¿½ç©¶æ³•å¾‹è´£ä»»çš„æƒåˆ©