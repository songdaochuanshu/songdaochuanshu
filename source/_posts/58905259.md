---
layout: post
title: "C#é«˜æ€§èƒ½æ•°ç»„æ‹·è´å®éªŒ"
date: "2023-01-30T07:15:03.159Z"
---
C#é«˜æ€§èƒ½æ•°ç»„æ‹·è´å®éªŒ
===========

å‰è¨€
--

æ˜¨å¤© wc(Wyu\_Cnk) æäº†ä¸ªé—®é¢˜

> C# é‡Œå¤šç»´æ•°ç»„æ‹·è´æœ‰æ²¡æœ‰ä»€ä¹ˆæ¯”è¾ƒä¼˜é›…çš„å†™æ³•ï¼Ÿ

è¿™ä¸æ˜¯é—®å¯¹äººäº†å—ï¼Ÿæ­£å¥½æˆ‘æœ€è¿‘åœ¨æå›¾åƒå¤„ç†ï¼Œè¦å’Œå†…å­˜æ‰“äº¤é“ï¼Œæˆ‘ä¸€ä¸‹å°±æƒ³åˆ°äº†åœ¨C#é‡Œé¢ç›´æ¥åƒC/C++ä¸€æ ·åšå†…å­˜æ‹·è´ã€‚

ä¼˜é›…ï¼Ÿnoï¼Œè¦çš„å°±æ˜¯è£…é€¼ï¼Œè€Œä¸”æ€§èƒ½è¿˜è¦å¼ºğŸ•¶

æ¦‚å¿µ
--

é¦–å…ˆæ¾„æ¸…ä¸€ä¸‹

C# é‡Œçš„å¤šç»´æ•°ç»„ (Multi-dimensional Array) æ˜¯è¿™æ ·çš„

    byte[,] arr = new byte[10, 10];
    

ä¸‹é¢è¿™ç§å†™æ³•æ˜¯äº¤é”™æ•°ç»„ (Jagged Array)ï¼Œå°±æ˜¯æ•°ç»„é‡Œé¢å¥—ç€æ•°ç»„

    byte[][] arr = new byte[10][];
    

å…·ä½“åŒºåˆ«è¯·çœ‹æ–‡æœ«çš„å‚è€ƒèµ„æ–™~

å¼€å§‹
--

æ¥ä¸‹æ¥ä»‹ç»å‡ ç§æ‹·è´æ•°ç»„çš„æ–¹æ³•ï¼Œç„¶åå†æ¯”è¾ƒä¸€ä¸‹ä¸åŒå®ç°çš„æ€§èƒ½

å®šä¹‰ä¸€ä¸‹å¸¸é‡ï¼Œ`SIZE` è¡¨ç¤ºæ•°ç»„å¤§å°ï¼Œ`COUNT` è¡¨ç¤ºç­‰ä¼šè¦åšæ‹·è´æµ‹è¯•çš„å¾ªç¯æ¬¡æ•°

    const int COUNT = 32, SIZE = 32 << 20;
    

è¿™é‡Œç”¨äº†ç§»ä½æ“ä½œï¼Œ32å·¦ç§»20ä½å°±æ˜¯åœ¨32çš„äºŒè¿›åˆ¶æ•°åé¢è¡¥20ä¸ª0ï¼Œç›¸å½“äº `32*2^20`ï¼Œåªæ˜¯ç”¨æ¥å®šä¹‰ä¸€ä¸ªæ¯”è¾ƒå¤§çš„æ•°ï¼Œç°åœ¨çš„ç”µè„‘æ€§èƒ½å¤ªå¼ºäº†ï¼Œå°ä¸€ç‚¹çš„æ•°ç»„å¤åˆ¶èµ·æ¥å¤ªå¿«äº†ï¼Œçœ‹ä¸å‡ºåŒºåˆ«ã€‚

æ¥ç€å®šä¹‰å‡ ä¸ªæ•°ç»„ï¼Œè¿™é‡Œå†™äº†äº”ç»„ä¸€ç»´æ•°ç»„ï¼Œæ¯ä¸ªä¸åŒçš„æ•°ç»„æ‹·è´æ–¹æ³•æµ‹è¯•ç”¨ä¸åŒçš„æ•°ç»„ï¼Œè¿™æ ·å¯ä»¥é¿å…CPUç¼“å­˜ã€‚

    private static byte[]
        aSource = new byte[SIZE],
        aTarget = new byte[SIZE],
        bSource = new byte[SIZE],
        bTarget = new byte[SIZE],
        cSource = new byte[SIZE],
        cTarget = new byte[SIZE],
        dSource = new byte[SIZE],
        dTarget = new byte[SIZE],
        eSource = new byte[SIZE],
        eTarget = new byte[SIZE];
    

ç„¶åæŠŠè¿™å‡ ä¸ªæ•°ç»„æ‹·è´æ–¹æ³•éƒ½æµ‹è¯•ä¸€ä¸‹

*   Cloneæ–¹å¼: `array.Clone()`
*   Linq: `array.Select(x=>x).ToArray()`
*   `Array.Copy()`
*   `Buffer.BlockCopy()`
*   `Buffer.MemoryCopy()`

Clone æ–¹å¼
--------

åœ¨C#ä¸­ï¼Œåªè¦å®ç°äº† `ICloneable` æ¥å£çš„å¯¹è±¡ï¼Œå°±æœ‰ `Clone` æ–¹æ³•

æ‰€ä»¥æ•°ç»„ä¹Ÿå¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼æ¥å®ç°æ‹·è´

å¾ˆç®€å•ï¼Œç›´æ¥ `var newArray = (byte[])array.Clone()` å°±è¡Œäº†

ä»£ç å¦‚ä¸‹

    static void TestArrayClone() {
        var sw = Stopwatch.StartNew();
        sw.Start();
        for (var i = 0; i < COUNT; i++) {
            dTarget = (byte[])dSource.Clone();
        }
    
        sw.Stop();
        Console.WriteLine("Array.Clone: {0:N0} ticks, {1} ms", sw.ElapsedTicks, sw.ElapsedMilliseconds);
    }
    

è¿™é‡Œç”¨äº† `Stopwatch` æ¥è®°å½•æ‰§è¡Œæ—¶é—´ï¼Œåé¢çš„å…¶ä»–æ‹·è´æ–¹æ³•é‡Œé¢ä¹Ÿæœ‰ï¼Œç­‰ä¼šç”¨è¿™ä¸ªè®¡ç®—å‡ºæ¥çš„ `ticks` å’Œæ¯«ç§’ï¼Œå¯ä»¥æ¯”è¾ƒä¸åŒå®ç°çš„æ€§èƒ½å·®è·ã€‚

Linqæ–¹å¼
------

å…¶å®ä¸ç”¨æµ‹è¯•ä¹ŸçŸ¥é“è¿™ä¸ªæ–¹å¼æ˜¯æœ€æ…¢çš„

å°±æ˜¯ä¸€ä¸ªä¸ªå…ƒç´ éå†ï¼Œå†é‡æ–°æ„é€ ä¸ªæ–°çš„æ•°ç»„

ä»£ç å¦‚ä¸‹

    eTarget = eSource.Select(x => x).ToArray();
    

`Array.Copy()`
--------------

ä½¿ç”¨é™æ€æ–¹æ³• `Array.Copy()` æ¥å®ç°æ•°ç»„å¤åˆ¶

> æç¤ºï¼šæ€§èƒ½æ˜¯ä¸é”™çš„ï¼Œä½¿ç”¨ä¹Ÿæ–¹ä¾¿

ä»£ç å¦‚ä¸‹ï¼Œåªéœ€è¦æŒ‡å®šé•¿åº¦å³å¯

    Array.Copy(cSource, cTarget, SIZE);
    
    

æˆ–è€…ç”¨å¦ä¸€ä¸ªé‡è½½ï¼Œå¯ä»¥åˆ†åˆ«æŒ‡å®šä¸¤ä¸ªæ•°ç»„çš„åç§»å€¼

    Array.Copy(cSource, 0, cTarget, 0, SIZE);
    

`Buffer.BlockCopy()`
--------------------

`Buffer` ç±»æ˜¯ç”¨æ¥æ“ä½œåŸºæœ¬ç±»å‹æ•°ç»„çš„

> Manipulates arrays of primitive types.

ä»£ç å¦‚ä¸‹

    Buffer.BlockCopy(bSource, 0, bTarget, 0, SIZE);
    

è·Ÿä¸Šé¢çš„ `Array.Copy` ç¬¬äºŒä¸ªé‡è½½ä¸€æ ·ï¼Œéœ€è¦åˆ†åˆ«æŒ‡å®šä¸¤ä¸ªæ•°ç»„çš„åç§»å€¼

`Buffer.MemoryCopy()`
---------------------

è¿™ä¸ªæ˜¯ unsafe æ–¹æ³•ï¼Œéœ€è¦ç”¨åˆ°æŒ‡é’ˆ ğŸ˜€ ç†è®ºä¸Šæ˜¯æ€§èƒ½æœ€å¥½çš„

æˆ‘æœ€å–œæ¬¢çš„å°±æ˜¯è¿™ä¸ªæ–¹æ³•ï¼ˆé€¼æ ¼é«˜ï¼‰

ä½¿ç”¨ unsafe ä»£ç ï¼Œè¯·å…ˆåœ¨ç¼–è¯‘é€‰é¡¹é‡Œé¢å¼€å¯ allow unsafe code é€‰é¡¹ã€‚

è¿™ä¸ª `MemoryCopy` æ–¹æ³•çš„å‡½æ•°ç­¾åæ˜¯è¿™æ ·çš„

    static unsafe void MemoryCopy(void* source, void* destination, long destinationSizeInBytes, long sourceBytesToCopy)
    

å‰ä¸¤ä¸ªå‚æ•°æ˜¯æŒ‡é’ˆç±»å‹ï¼Œåä¿©ä¸ªæ˜¯é•¿åº¦ï¼Œæ³¨æ„æ˜¯byteså­—èŠ‚æ•°ï¼Œä¸æ˜¯æ•°ç»„çš„å…ƒç´ ä¸ªæ•°

C#ä¸­çš„byteå 8bitï¼Œåˆšå¥½æ˜¯ä¸€ä¸ªbyteï¼Œæ‰€ä»¥ç›´æ¥ç”¨å…ƒç´ ä¸ªæ•°å°±è¡Œï¼Œå¦‚æœæ˜¯å…¶ä»–ç±»å‹çš„æ•°ç»„ï¼Œå¾—æ ¹æ®ç±»å‹é•¿åº¦è®¡ç®—å­—èŠ‚æ•°ï¼Œç„¶åå†ä¼ è¿›å»ã€‚

ä»£ç å¦‚ä¸‹ï¼Œåœ¨å‡½æ•°å®šä¹‰é‡Œé¢åŠ ä¸Šunsafeå…³é”®å­—ä»¥ä½¿ç”¨ `fixed` å—å’ŒæŒ‡é’ˆ

    static unsafe void TestBufferMemoryCopy() {
        var sw = Stopwatch.StartNew();
        fixed (byte* pSrc = fSource, pDest = fTarget) {
            for (int i = 0; i < COUNT; i++) {
                Buffer.MemoryCopy(pSrc, pDest, SIZE, SIZE);
            }
        }
    
        Console.WriteLine("Buffer.MemoryCopy (2d): {0:N0} ticks, {1} ms", sw.ElapsedTicks, sw.ElapsedMilliseconds);
    }
    

ç„¶å

æˆ‘åœ¨æœç´¢èµ„æ–™çš„è¿‡ç¨‹ä¸­è¿˜å‘ç°äº†æœ‰äººç”¨äº† `Buffer.Memcpy` è¿™ä¸ªæ–¹æ³•ï¼Œä½†è¿™ä¸ªæ˜¯ internal æ–¹æ³•ï¼Œæ²¡æœ‰å¼€æ”¾ï¼Œå¾—ç”¨é»‘ç§‘æŠ€å»è°ƒç”¨

æˆ‘æŠ˜è…¾äº†å¾ˆä¹…ï¼Œç»ˆäºæå‡ºäº†è°ƒç”¨éå…¬å¼€æ–¹æ³•çš„ä»£ç 

    unsafe delegate void Memcpy(byte* src, byte* dest, int len);
    
    internal class Program {
        private static Memcpy memcpy;
        static Program() {
            var methodInfo = typeof(Buffer).GetMethod(
                "Memcpy",
                BindingFlags.Static | BindingFlags.NonPublic,
                null,
                new Type[] { typeof(byte*), typeof(byte*), typeof(int) },
                null
            );
            if (methodInfo == null) {
                Console.WriteLine("init failed! method is not found.");
                return;
            }
    
            memcpy = (Memcpy)Delegate.CreateDelegate(typeof(Memcpy), methodInfo);
        }
    }
    

å®é™…æµ‹è¯•è¿™ä¸ª `Memcpy` å’Œ `MemoryCopy` çš„æ€§èƒ½æ˜¯å·®ä¸å¤šçš„

çœ‹äº†ä¸€ä¸‹.NetCoreçš„æºç 

æœç„¶ï¼Œè¿™ä¿©ä¸ªçš„å®ç°åŸºæœ¬æ˜¯ä¸€æ ·çš„

    // Used by ilmarshalers.cpp
    internal static unsafe void Memcpy(byte* dest, byte* src, int len)
    {
        Debug.Assert(len >= 0, "Negative length in memcpy!");
        Memmove(ref *dest, ref *src, (nuint)(uint)len /* force zero-extension */);
    }
    

å¦ä¸€ä¸ª

    public static unsafe void MemoryCopy(void* source, void* destination, long destinationSizeInBytes, long sourceBytesToCopy)
    {
        if (sourceBytesToCopy > destinationSizeInBytes) { ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.sourceBytesToCopy);
        }
        Memmove(ref *(byte*)destination, ref *(byte*)source, checked((nuint)sourceBytesToCopy));
    }
    

è¿™ä¿©æœ€ç»ˆéƒ½æ˜¯è°ƒç”¨çš„ `Memmove` è¿™ä¸ªæ–¹æ³•

åŒºåˆ«å°±æ˜¯è¿™ä¿©æ–¹æ³•çš„å‚æ•°ä¸ä¸€æ ·äº†ã€‚

benchmark
---------

æ€§èƒ½æµ‹è¯•ç»“æœ

    Array.Copy: 49,923,612 ticks, 49 ms
    Buffer.BlockCopy: 52,497,377 ticks, 52 ms
    Buffer.Memcpy: 49,067,555 ticks, 49 ms
    Buffer.MemoryCopy (2d): 48,982,014 ticks, 48 ms
    Array.Clone: 360,640,218 ticks, 360 ms
    Linq: 1,988,890,052 ticks, 1988 ms
    
    Array.Copy: 48,653,699 ticks, 48 ms
    Buffer.BlockCopy: 48,040,093 ticks, 48 ms
    Buffer.Memcpy: 47,818,057 ticks, 47 ms
    Buffer.MemoryCopy (2d): 49,084,413 ticks, 49 ms
    Array.Clone: 406,848,666 ticks, 406 ms
    Linq: 1,943,498,307 ticks, 1943 ms
    
    Array.Copy: 48,943,429 ticks, 48 ms
    Buffer.BlockCopy: 47,989,824 ticks, 47 ms
    Buffer.Memcpy: 48,053,817 ticks, 48 ms
    Buffer.MemoryCopy (2d): 49,065,368 ticks, 49 ms
    Array.Clone: 364,339,126 ticks, 364 ms
    Linq: 1,999,189,800 ticks, 1999 ms
    
    Array.Copy: 49,679,913 ticks, 49 ms
    Buffer.BlockCopy: 48,651,877 ticks, 48 ms
    Buffer.Memcpy: 48,262,443 ticks, 48 ms
    Buffer.MemoryCopy (2d): 49,683,361 ticks, 49 ms
    Array.Clone: 429,384,291 ticks, 429 ms
    Linq: 1,932,109,712 ticks, 1932 ms
    

è¯¥ç”¨å“ªä¸ªæ–¹æ³•æ¥æ‹·è´æ•°ç»„ï¼Œä¸€ç›®äº†ç„¶äº†å§~ ğŸ˜ƒ

å‚è€ƒèµ„æ–™
----

*   Multi-dimensional and Jagged Arrays - [https://www.pluralsight.com/guides/multidimensional-arrays-csharp](https://www.pluralsight.com/guides/multidimensional-arrays-csharp)
*   Any faster way of copying arrays in C#? - [https://stackoverflow.com/questions/5099604/any-faster-way-of-copying-arrays-in-c](https://stackoverflow.com/questions/5099604/any-faster-way-of-copying-arrays-in-c)

å¾®ä¿¡å…¬ä¼—å·ï¼šã€Œç¨‹åºè®¾è®¡å®éªŒå®¤ã€ ä¸“æ³¨äºäº’è”ç½‘çƒ­é—¨æ–°æŠ€æœ¯æ¢ç´¢ä¸å›¢é˜Ÿæ•æ·å¼€å‘å®è·µï¼ŒåŒ…æ‹¬æ¶æ„è®¾è®¡ã€æœºå™¨å­¦ä¹ ä¸æ•°æ®åˆ†æç®—æ³•ã€ç§»åŠ¨ç«¯å¼€å‘ã€Linuxã€Webå‰åç«¯å¼€å‘ç­‰ï¼Œæ¬¢è¿ä¸€èµ·æ¢è®¨æŠ€æœ¯ï¼Œåˆ†äº«å­¦ä¹ å®è·µç»éªŒã€‚