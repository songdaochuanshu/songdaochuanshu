---
layout: post
title: "[论文阅读] 颜色迁移-Correlated Color Space"
date: "2022-12-03T23:16:00.999Z"
---
\[论文阅读\] 颜色迁移-Correlated Color Space
====================================

本文算法比较简单, 其原理是把原始图像本身的空间分布进行归一化, 然后通过旋转平移缩放等变换, 变换到目标图像的空间分布

\[论文阅读\] 颜色迁移-Correlated Color Space
------------------------------------

文章: [Color transfer in correlated color space](http://portal.acm.org/citation.cfm?doid=1128923.1128974), \[[paper](https://dl.acm.org/doi/10.1145/1128923.1128974)\], \[[matlab code](https://github.com/hangong/Xiao06_color_transfer)\], \[[opencv code](https://github.com/ZZPot/Xiao-transfer)\]

### 1-算法原理

本文算法比较简单, 其原理是把原始图像本身的空间分布进行归一化, 然后通过旋转平移缩放等变换, 变换到目标图像的空间分布, 如下所示:

\\\[I = T\_t \\cdot R\_t \\cdot S\_t \\cdot S\_t \\cdot S\_s \\cdot R\_s \\cdot T\_s \\cdot I\_s \\tag{1} \\\]

T表示平移, R表示旋转, S表示缩放. 下标t表示目标图像, 下标s表示原始图像, 文中的原始公式存在问题, 我这里进行了调整.

因而本文就是寻找这个变换矩阵, 使用的方法是使用SVD分解(关于SVD算法, 可以戳这里: [奇异值分解（SVD） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/448767610).)

\\\[Cov = U \\cdot \\Lambda \\cdot V^T \\\]

具体地, 本文算法步骤为:

1.  计算图像每个颜色通道的均值, 及图像的协方差矩阵
2.  对协方差矩阵进行SVD分解
3.  构建变换需要的矩阵
4.  使用公式对图像进行颜色迁移

### 2-算法核心

对于n维颜色空间, 为了方便处理, 可以调整为n+1维的齐次坐标标示. 对于本文, 使用的是RGB 3维颜色空间, 齐次坐标维4维的.

对于上述几个变换矩阵, 平移矩阵T很容易想到, 可以使用各颜色通道的均值来表示. 但对于旋转矩阵R和缩放矩阵S就需要用到SVD分解矩阵的性质了: \\(U\\) 表示旋转, \\(\\Lambda\\) 表示缩放拉伸.

因而所需变换矩阵如下:

\\\[\\Lambda = diag(\\lambda^{c1}, \\lambda^{c2}, \\lambda^{c3}) \\\]

\\\[T\_s = \\begin{pmatrix} 1 & 0 & 0 & -m\_s^{c1} \\\\ 0 & 1 & 0 & -m\_s^{c2} \\\\ 0 & 0 & 1 & -m\_s^{c3} \\\\ 0 & 0 & 0 &1 \\end{pmatrix} , T\_t = \\begin{pmatrix} 1 & 0 & 0 & m\_t^{c1} \\\\ 0 & 1 & 0 & m\_t^{c2} \\\\ 0 & 0 & 1 & m\_t^{c3} \\\\ 0 & 0 & 0 &1 \\end{pmatrix} \\\]

\\\[R\_s = U\_s^{-1}, R\_t = U\_t \\\]

\\\[S\_s = \\begin{pmatrix} 1/s\_s^{c1} & 0 & 0 & 0 \\\\ 0 & 1/s\_s^{c2} & 0 & 0 \\\\ 0 & 0 & 1/s\_s^{c3} & 0 \\\\ 0 & 0 & 0 &1 \\end{pmatrix} , S\_t = \\begin{pmatrix} s\_t^{c1} & 0 & 0 & 0 \\\\ 0 & s\_t^{c2} & 0 & 0 \\\\ 0 & 0 & s\_t^{c3} & 0 \\\\ 0 & 0 & 0 &1 \\end{pmatrix} , \\\]

式中, ci表示颜色通道, \\(s^{ci}=\\sqrt{\\lambda^{ci}}\\). 这里取了根号, 如果不取根号是不是也可以???

本文算法是对3个通道一起处理, 如果每个通道单独处理, 上述公式可以等效为:

\\\[C^i = \\frac{\\sigma\_t^{i}}{\\sigma\_s^{i}}(C\_s^{i} - \\mu\_s^{i}) + \\mu\_t^{i} \\\]

式中, i表示通道.

### 3-算法效果

如下所示为文中给出的一组结果:

![迁移结果示例](https://img-blog.csdnimg.cn/d2161a1c20b6447cbe58274783893a1f.png)

### 4-补充说明

作者在自己给出的matlab代码中指出了本文算法存在的一个问题, 我们先来看看实际的情况, 如下所示为一组图像的测试结果.

![异常结果](https://img-blog.csdnimg.cn/8229dc1ee8164cefa1417c227fa2b4ce.png)

可以看到, 结果出现了异常. 作者给出的分析是:

*   SVD生成的\\(\\Lambda\\) 矩阵中对角线上的值, 是由特征值从大到小排列的, 源图像和目标图像的这个排列可能不匹配
*   如源图像排列为c1, c2, c3, 目标图像排列为c2, c1, c3
*   即使排列相同, 它们的方向可能相反, 如目标图像排列为c1, -c2, c3

针对这个问题, 作者代码实现中给出了解决方案, 进行列匹配(matchColumns):

1.  对旋转矩阵\\(U\_t\\) 的所有列进行排列组合, 与\\(U\_s\\) 对应的列求点积和
2.  找到和最大的一个组合为最优匹配
3.  根据组合中坐标轴的顺序, 对\\(\\Lambda\_t\\) 的顺序进行调整, 同时调整方向

下面是调整后的结果:

![调整后结果](https://img-blog.csdnimg.cn/424f620a99ed4a5580c8912bee880e38.png)