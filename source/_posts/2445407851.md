---
layout: post
title: "用户态和内核态"
date: "2022-11-25T19:13:37.775Z"
---
用户态和内核态
=======

### 内核态和用户态

我们开发的服务代码，都是基于操作系统抽象提供的功能接口，进而操作相应的硬件资源。而硬件资源对于安全性要求非常高，所以对于安全性和系统稳定性而言，需要划定不同的应用程序运行级别。

Intel对于CPU的权限划分了四个等级0 ~ 3，linux采用了其中的0和2这两个等级。运行在0级别的程序时操作系统的内核程序，运行在2级别的程序是用户程序。我们平时写的程序都是用户程序。

以32位操作系统而言，他可以映射的内存大小为4G，操作系统启动时，会占用前1G的内存作为内核态的内存，在做CPU、硬盘的读写时，不能给用户态的应用程序直接操作的权限，在正常的用户态操作时，不需要切换。

我们实际运行的代码（java、go写成的web服务、纯后端服务），依托于jvm，实际都运行在操作系统之上，整个调用链为：java服务（编译后是二进制文件） -> （jvm）-> （linux操作系统）-> （硬件接口）。

### 面试题：讲解一下内核态和用户态

#### 总体概述：

操作系统为了保护安全硬件资源而定义的两种运行级别，两种级别拥有的权限不同。  
不同程序需要有划分行的访问能力，防止他们可以获取别的程序的内存数据，调用网络接口，执行CPU指令导致系统崩溃。  
我们的运行一个程序时，大部门时间都是运行在用户态下的，在需要操作系统帮忙某些没有权利完成的工作（**c语言的malloc()、net.read()**）时就需要切换到内核态。

![](https://img2022.cnblogs.com/blog/1461498/202211/1461498-20221125232156366-1654899509.png)

#### 两种状态的转换

*   系统调用：用户进程主动要求切换到内核态的一种方式，用户进程通过systmem call申请操作系统提供的服务程序完成工作
*   异常：当CPU仔执行运行的用户态的程序时，发生了一些不可知的异常，切换到对应处理异常的内核程序
*   外围设备中断：
    *   硬盘读写操作完成，系统会切换到硬盘读写的中断处理陈谷种执行后续操作。

### 总结

级别

运行地址

级别

执行内容

用户态

较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间

3级

可以执行的操作和可以访问的资源都会受到很多限制

内核态

最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间

0级

运行在内核态的进程可以执行任何操作并且在资源的使用上没有限制

### 链接

*   [https://www.bilibili.com/read/cv14492908](https://www.bilibili.com/read/cv14492908)
*   [https://strikefreedom.top/archives/linux-io-and-zero-copy](https://strikefreedom.top/archives/linux-io-and-zero-copy)