---
layout: post
title: "Python 中 is 和 == 的区别"
date: "2023-03-29T01:14:58.215Z"
---
Python 中 is 和 == 的区别
====================

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084221750-569130258.png)

 **is 和 == 的区别**
================

相信学过 Python 小伙伴们都知道 is 和 == 都是用来比较 Python 对象的，但是区别就是

*   is 比较需要对象的值和内存地址都相等
*   \== 比较只需要对象的值相等就行了
    

我们来看一个例子

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084244813-483778537.png)

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084249258-1643461913.png)

我们可以看到，time 模块的 time() 方法用于获取当前时间，所以 t1 和 t2 的值都是一样的

\== 用来判断 t1 和 t2 的值是否相等，所以返回 True

虽然 t1 和 t2 的值相等，但它们是两个不同的对象（每次调用 time() 都返回不同的对象），所以`t1 is t2`返回 False

**那么，如何判断两个对象是否相同呢？**

答：判断两个对象的内存地址。如果内存地址相同，说明两个对象使用的是同一块内存，当然就是同一个对象了

我们来看下 t1 和 t2 的内存地址

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084343949-863099978.png)

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084347073-1512636276.png)

可以看到它们两个的内存地址是不一样的

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084356731-725722776.png)

**小整数池&缓存机制**
=============

 但是有小伙伴可能会遇到下面的这种情况

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084413619-2051126282.png)

咦？怎么 a is b 结果是 True？这应该是两个不同的对象啊

这其实是因为小整数池

**python 中经常使用的一些数值定义为小整数池，小整数池的范围是\[-5,256\]**

python 对这些数值已经提前创建好了内存空间，即使多次重新定义也不会再重新开辟新的空间，但是小整数池外的数值在重新定义时都会再次开辟新的空间

所以对于小整数池中的数，内存地址一定是相同的，小整数池中外的数，内存地址是不同的

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084423184-163022327.png)

好，那这次我用小整数池之外的数

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084431242-1647941508.png)

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084438253-1197228891.png)

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084440466-1492498069.png)

？玩我是吧，说好的小整数池中外的数，内存地址是不同的，那上面的代码结果怎么跟说的不一样

上面的代码我是在 IDE 环境下面敲的，我们试着在交互模式下敲

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084511613-1934315888.png)

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084515412-71408219.png)

可以看到，在交互模式下，小整数池外的数内存地址不相同，这是为什么呢？

先说结论：**这是因为 Python 的缓存机制，所以在 IDE 环境或者脚本模式下同一个整数被多个变量引用不会开辟新的内存空间**

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084532328-873040859.png)

**Python 缓存机制**

*   Python 解释器启动时会先从内存空间中开辟出来一小部分，用于存储高频使用的数据（不可变数据类型），这样可以大大减少高频使用的数据对象创建时申请内存和销毁时撤销内存的开销
    
*   在同一代码块下，不可变数据类型的对象（数字，字符串，元祖）被多个变量引用，不会重复开辟内存空间
    

由上面得知，只有不可变的数据类型（字符串、元祖、基础数据类型）如果被多个变量引用，是不会重复开辟内存空间，但可变数据类型（列表、字典、集合）就除外

*   可变数据类型
    

我们来看看

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084559538-1246432965.png)

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084606105-190353692.png)

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084609241-2091553009.png)

在交互模式下结果也是如此

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084618040-1579453954.png)

*   不可变数据类型
    

1、小整数池里的数

我们来看下交互模式下的不可变数据类型的缓存机制

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084633558-661682592.png)

可以看到，Python 中整数范围 \[-5, 256\] 中的数为固定缓存，只要是使用到该范围内的数字，不管是直接赋值还是表达式计算得到的，都会使用固定缓存中的数据

2、非小整数池里的数

对于非小整数池里的数，在 IDE 环境下会使用到缓存，即多个变量引用同一个数据，不会开辟新的内存空间

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084646926-415968126.png)

对于非小整数池里的数，在交互模式下，除非**同时赋值**或者**在同一个局域代码块里面赋值**，否则不会使用缓存机制

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084700251-243664843.png)

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084704972-1383842727.png)

**intern 机制**
=============

我们知道，由于 Python 的缓存机制：

*   不可变的数据类型（字符串、元祖、基础数据类型）如果被多个变量引用，是不会重复开辟内存空间
    
*   但可变数据类型（列表、字典、集合）被多个变量引用就会开辟新的内存空间
    
*   对于小整数池里的整数，被多个变量引用，不会重复开辟内存空间
    

但是到目前为止我们知道：**在交互模式下，除了特殊情况（同时赋值、同一局域代码块内赋值）以及小整数池之外，所有数据在被多个变量引用时都会开辟新的内存空间**

其实还有一种特殊情况，我们来看这么一个例子

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084730051-1275406141.png)

看着输出的结果，再跟刚刚所学到的知识做一下对比，是不是发现有不对劲的地方

交互模式下，多个变量引用字符串（不可变数据类型）应该是开辟新的内存空间啊，为啥上面的例子没有开辟

**intern机制**

字符串类型作为Python中最常用的数据类型之一，Python 为了提高字符串使用的效率和使用性能，使用了 intern（字符串驻留）的技术来提高字符串效率

即值**同样的字符串对象仅仅会保存一份，放在一个字符串储蓄池中，是共用的**，有新的变量引用同样的字符串的时候，不会开辟新的内存空间，而是引用这个共用的字符串

*   原理
    

实现 Intern 机制的方式非常简单，就是通过维护一个字符串储蓄池，这个池子是一个字典结构，如果字符串已经存在于池子中就不再去创建新的字符串，直接返回之前创建好的字符串对象，如果之前还没有加入到该池子中，则先构造一个字符串对象，并把这个对象加入到池子中去，方便下一次获取

下面是伪代码

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084747714-1641748081.png)

1、在交互模式下，只包含字母数字下划线的字符串才会触发 intern 机制

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084758757-212096263.png)

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084802207-170779290.png)

2、在 IDE 环境或者脚本模式下，只要长度不超过20（长度限制），即使使用特殊字符也会触发 intern 机制

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084818126-1801103242.png)

 ![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084821646-1796046375.png)

PS：我在写这篇文章的时候用的是 python 3.9，发现没有长度限制了，都会触发 intern 机制

![](https://img2023.cnblogs.com/blog/2958925/202303/2958925-20230329084831151-1113101319.png)

* * *

**感谢阅读，****喜欢作者就动动小手****\[****一键三连\]**，这是我写作最大的动力