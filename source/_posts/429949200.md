---
layout: post
title: "在PE文件中简单注入代码，实现在启动前弹窗"
date: "2022-10-07T17:38:26.664Z"
---
在PE文件中简单注入代码，实现在启动前弹窗
=====================

##### 获得的新知识：

1、kernel32.dll，user32.dll，ntdll.dll等一些dll在**同一个PC**环境下的映射到虚拟内存基址是一样的。  
2、在win8以上系统上，更改PE文件的入口点要大于SizeOfHeaders(在可选文件头中)，否则会报错无法运行。

![](https://img2022.cnblogs.com/blog/2757375/202210/2757375-20221007174451940-1725002577.png)

1、实现原理
------

PE可选文件头有一个AddressOfEntryPoint，更改这个值指向自己代码，执行完自己代码再跳转到原来入口点。

2、实验过程
------

1、字节的代码  
shellcode: `6A 00 6A 00 6A 00 E8 __ __ __ __ E9 __ __ __ ___`  
调用messagebox过程，压栈调用  
![](https://img2022.cnblogs.com/blog/2757375/202210/2757375-20221007180433196-1459223251.png)

这里用了IAT表，为了简单起见直接使用user32.dll中messagebox的地址  
e8指令是call指令，后面要补充相对messagbox的地址，e9是jmp指令，要补充相对入口点地址。

![](https://img2022.cnblogs.com/blog/2757375/202210/2757375-20221007181313274-373547401.png)  
将代码注入这个程序

用x32dbg查messagebox地址是0x**76D160660**。程序入口点为0x**00401140**。shellcode入口点设置为0x**00401030**  
![](https://img2022.cnblogs.com/blog/2757375/202210/2757375-20221007181835906-1034187160.png)

![](https://img2022.cnblogs.com/blog/2757375/202210/2757375-20221007182200484-565600208.png)

![](https://img2022.cnblogs.com/blog/2757375/202210/2757375-20221007183802740-1355858162.png)

### 用wenhex写入shellcode

![](https://img2022.cnblogs.com/blog/2757375/202210/2757375-20221007184140629-471088746.png)

再把程序入口点修改了  
![](https://img2022.cnblogs.com/blog/2757375/202210/2757375-20221007184228781-283496966.png)

最后，完美运行  
![](https://img2022.cnblogs.com/blog/2757375/202210/2757375-20221007184313663-840506979.png)