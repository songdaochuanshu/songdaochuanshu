---
layout: post
title: "AcWing 1222. 密码脱落 "
date: "2022-04-03T10:19:34.076Z"
---
AcWing 1222. 密码脱落
=================

[题目链接](https://www.acwing.com/problem/content/1224/)

* * *

题目描述：  
X星球的考古学家发现了一批古代留下来的密码。  
这些密码是由A、B、C、D 四种植物的种子串成的序列。  
仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。  
由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。  
你的任务是：  
给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。

* * *

题目大意：给定一个串，求至少增加其中几个字符，才可使其成为回文串。  
等价于：给定一个串，求至少删除其中几个字符，才可使其成为回文串。  
而删除的数量=串的长度-最大回文串长度。  
于是该题为求一个串的最大回文串长度。  
解决方法：DP  
集合：所有S\[L，R\]之间的回文子序列的集合  
集合划分：  
![](https://img2022.cnblogs.com/blog/2301831/202204/2301831-20220403171343876-454327342.png)

    #include <cstdio>
    #include <string.h>
    
    const int N = 1010;
    
    char s[N];
    int f[N][N];
    
    int main()
    {
        scanf("%s", s);
        int n = strlen(s);
    
        for (int len = 1; len <= n; len ++ )  //区间DP枚举长度（因为常规方法第一维要用l+1更新l对应的值）
            for (int l = 0; l + len - 1 < n; l ++ )
            {
                int r = l + len - 1;
                if (len == 1) f[l][r] = 1;
                else
                {
                    if (s[l] == s[r]) f[l][r] = f[l + 1][r - 1] + 2;
                    if (f[l][r - 1] > f[l][r]) f[l][r] = f[l][r - 1];
                    if (f[l + 1][r] > f[l][r]) f[l][r] = f[l + 1][r];
                }
            }
    
        printf("%d\n", n - f[0][n - 1]);
    
        return 0;
    }