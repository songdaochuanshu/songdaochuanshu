---
layout: post
title: "计算机网络（Learning Records）"
date: "2022-10-13T16:34:30.229Z"
---
计算机网络（Learning Records）
=======================

![计算机网络（Learning Records）](https://img2022.cnblogs.com/blog/2489686/202210/2489686-20221013214627363-223313087.png) 学习记录

> 背景：没想到本专业并不开设这门课程，感觉过于逆天，之前开发的时候了解过相关知识  
> 但是从来没有系统地学过，就自己看了书，总结一下  
> 参考：《TCP/IP详解 卷1：协议》

概述
==

大多数网络应用程序被设计成客户——服务器的模式  
![img](https://img2022.cnblogs.com/blog/2489686/202210/2489686-20221013212542692-2132820501.png)  
域名系统（DNS）是一个分布数据库，它可以提供IP地址和主机名的映射  
当应用程序通过TCP传入数据时，数据通过协议栈封装（TCP首部，IP首部，以太网首部和尾部）  
分用：![img](https://img2022.cnblogs.com/blog/2489686/202210/2489686-20221013212623656-480148609.png)  
TCP服务器是并发型的，UDP服务器是重复型（非并发）

ARP
===

又被称为地址解析协议，它为IP地址到对应的硬件地址之间提供动态映射  
首先它会发送一份“广播”（以太数据帧）给以太网上的每个主机  
数据帧中包含目标主机的地址，如果是目标主机，则会回答硬件地址  
那么使用ARP进行请求-回答交换的IP数据现在就可以传送了

**注明：点对点链路不使用ARP**

ARP高速缓存能有效提高ARP的效率  
RARP功能与ARP相反，请求以广播的形式发送，应答以单播的形式发送

ICMP
====

ICMP经常被认为是IP层的一个组成部分，它传输报错的信息和其他需要注意的信息  
ICMP报文通常被IP层或更高协议层调用  
ICMP时间戳可以用于计算应答的时间

IP
==

提供不可靠，无连接的数据报传送服务  
不可靠指的是他不能保证IP数据成功到达目的地，只提供最好的传输服务  
无连接指的是他不处理后续数据报的状态信息，每个数据报的处理是相互独立的  
同时也是不按顺序处理数据报的

IP路由选择
------

IP从TCP或ICMP或网络接口等接受到数据报之后，其在内存中有一个内存表  
当来自网络接口时，会首先检查是否是本机的IP地址之一或广播地址  
路由表中包含

1.  目的IP地址
2.  下一站路由器的IP地址，或者直接相连的网络IP地址
3.  标志 指明IP地址是网络地址还是主机地址
4.  为数据报的传输指定一个网络接口  
    **所有的IP路由选择只为数据报传输指明下一个路由的IP地址**

ping
====

主要是为了测试一台主机是否可达，具有时间戳

Traceroute
==========

可以看到IP数据报从一个主机传到另一个主机所经过的路由  
用Traceroute的理由（为什么不用（RR）IP记录路由）

1.  IP留给首部的空间有限，不能存放大多数的路径
2.  并不是所有的路由器都支持记录路由选项
3.  记录路由一般是单向的选项

主要利用的是ICMP和IP首部中的TTL字段  
TTL作为一个跳站的计数器，所经过的每个路由都将其值-1  
TTL也可以防止数据无休止地流动，当TTL为0或1时，会丢弃该数据，并给信源发送一份ICMP超时信息  
Traceroute的关键在于包含这份ICMP报文的信息里也有该路由的信息  
所以其工作原理是：**先发送一份TTL为1的报文从而得到第一个路由的地址，然后发送TTL为2的报文，这样持续到主机**

IP选路
====

IP层工作流程如图所示：  
IP层进行选路只是决定把哪些路由放进路由表的规则。  
IP执行选路机制，而路由守护程序一般提供选路策略  
IP搜索路由表时先搜索匹配项，再搜索默认项  
如果要到达不直接相连的主机或网络必须用某种方式添加到路由表中

比如：

1.  在系统引导时显式的在初始化文件中运行route命令
2.  运行路由守护程序  
    如果既没找到匹配项，又没找到默认项  
    结果取决于该IP数据报是由主机产生还是转发的

*   主机产生——返回报错信息给主机
    
*   转发产生——向原始发送端发送ICMP不可达报错信息
    
*   ICMP重定向差错  
    当发现IP数据报应该传送给另一个路由时，收到数据报的路由器会向数据报的发送端发送ICMP重定向差错  
    重定向操作一般用来帮助主机建立完善的路由表  
    刚开始路由表有一个默认表项，一旦默认路由发生差错，默认路由器将通知其进行重定向，并允许主机对对应的路由表进行改动  
    需要注意的是
    
*   重定向报文只能由路由器生成，而不能由主机生成
    
*   重定向报文是为主机而不是路由器使用的  
    路由器发送的应该是对主机的重定向，而不是对网络的重定向
    

动态选路
====

动态选路并不改变内核在IP层的运行方式  
路由器之间采用通信协议交互，而路由守护程序运行通信协议  
仅仅是放置在路由表中的信息改变了——当路由随时间变化时  
路由是由路由守护动态增加或删除，而不是来源于程序文件中的route命令  
具体协议有：

*   RIP协议（距离向量）
*   OSPF协议（直接使用IP）
*   BGP协议（距离向量——TCP）
*   CIDR协议

UDP：用户数据报协议
===========

UDP并不可靠，它把应用程序传给IP层的数据发送出去，但是并不保证能到达目的地

广播和多播
=====

广播是将数据发送到网络中的所有主机（一般指的是本地相连的网络），多播是发送到主机组  
**广播和多播都仅用于UDP**  
使用广播的问题主要是会增加对该数据报不感兴趣的主机的负荷  
子网：网络小岛

IGMP
====

多播的基础是一个进程的概念，而多播组中的成员是动态的  
多播路由器用IGMP来记录与该路由器相连的网络中组成成员的变化情况

使用规则：

*   当第一个进程进入一个组时，发送一个IGMP报告。如果一个主机的多个进程加入同一组，只发送一个报告
*   当进程出组时，主机不发送IGMP报告
*   多播路由器会定时发送IGMP报文来查询是否还有任何主机有属于多播组的进程
*   主机通过发送IGMP报告来响应IGMP查询

使用这些报文，多播路由器对每个接口保持一个表，表上记录至少一个包含主机的多播组  
路由器只将报文转发到还拥有属于那个组主机的接口上

DNS域名系统
=======

DNS主要提供IP地址与主机名之间的转换以及电子邮件的选路信息

名字服务器
-----

一般用来查询域名信息等  
主名字服务器-------从磁盘文件调度信息  
辅名字服务器-------从主名字服务器调入信息  
**主，辅名字服务器之间是独立的**  
应用程序通过名字解析器将主机名转化为IP地址，也可以将IP地址转化为主机名  
名字解析器将向名字服务器发送查询请求  
所有的DNS查询都有相同的报文形式，它包含查询请求和可能的回答资源记录，授权资源和附加资源记录

TFTP
====

TFTP使用不可靠的UDP，安全性没有保证  
TFTP使用停止等待协议，数据发送方在发送下一个数据块之前需要等待对方的接收和确认

TCP
===

指的是传输控制协议，它是一种可靠的，面向连接的字节流服务  
可靠性体现在：

*   应用数据会被分成TCP认为最合适发送的数据块。这和UDP不同（UDP应用程序产生的数据块长度不变）
*   超时重传
*   需要确认
*   会保持首部和数据的检验和
*   数据后重新排序
*   丢弃重复
*   流量控制

每个TCP段包含源端和目的端端口号，它和IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接  
TCP为应用层提供双工服务，说明数据能在两个方向上独立地进行运输

TCP连接的建立和终止
-----------

建立一个连接需要3次握手，而终止一个连接需要4次握手  
SYN：同步序列编号，它是TCP/IP建立连接时使用的握手信号，SYN=1，ACK=0时表示这是一个连接请求报文段  
若对方同意连接，则响应报文段中SYN=1，ACK=1  
ACK：确认号字段，TCP规定在连接建立后的所有传送报文段中ACK都置为1  
FIN：FIN为1时表示该报文段的发送方已经结束向对方发送数据，并要求断开连接  
ISN：初始序列号  
一个TCP连接由一个四元组构成  
分别是发送端的IP地址和端口号，接收端的IP地址和端口号  
![img](https://img2022.cnblogs.com/blog/2489686/202210/2489686-20221013213549237-525245697.png)

一个TCP的建立需要以下步骤

*   客户端发送一个SYN报文段，并且指明想要的接收端端口和自己的ISN1
*   服务器也发送自己的SYN报文段进行响应，并且包含自己的ISN2，同时为了确认客户端的SYN，将ACK置为ISN1+1  
    所以每次发送一个报文段，ISN都会+1，这样可以防止丢失的情况
*   同样为了确认服务端的ISN，客户端会将ACK置为ISN2+1  
    所以可以发现，TCP的这三次握手主要目的在于交换连接双方的初始序列号ISN

终止需要4次挥手

*   连接的主动关闭者发送一个FIN段指明接收者，同时发送自己的序列号ISN1
*   被动关闭者将ACK置为ISN1+1。此时，上层的程序会被告知连接的另一端已经发出了关闭请求。
*   然后被动关闭者变为主动关闭者，并发送自己的FIN
*   为了完成连接的关闭，最后一个报文还包含一个ACK用于确认上一个FIN，防止FIN丢失

TCP的成块数据流
---------

TCP使用的被称为滑动窗口协议的另一种流量控制方法  
该协议允许发送方在停止并等待确认前可以连续发送多少个分组  
**由于发送方不必每发送一个数据就等待确认，所以这可以加速数据的传输**  
用三个术语来描述窗口左右两边的运动

*   窗口合拢：左边沿向右收缩，一般发生在数据被发送和确认时
*   窗口张开：右边向右移动，一般发生在另一端的接收进程读取已经确认的的数据并释放了TCP的接收缓存时
*   窗口收缩：右边沿向左移动  
    如图所示：  
    ![img](https://img2022.cnblogs.com/blog/2489686/202210/2489686-20221013213755663-846813116.png)  
    （字丑还请见谅doge  
    由接收方提供的滑动窗口进程通常可以由接受进程控制，同时也会影响到TCP的性能  
    \----------慢启动  
    TCP支持一种叫慢启动的算法，它保证了新分组进入网络的速率和另一端确认的速率相同  
    它为发送方提供了一种窗口：拥塞窗口  
    在工作时，发送方取拥塞窗口和通告窗口中的最小值作为发送上限。  
    **拥塞窗口是发送方的流量限制，通告窗口是接收方的流量限制**

TCP的超时和重传
---------

超时重传是TCP保证安全的一个重要的机制  
原理是在发送一个数据过后就开启一个定时器，如果在一定的时间内没有接收到ACK报文，那么就重新发送数据，直到发送成功为止  
重传超时时间（RTO）：RTO的设定会影响到超时传输协议的效率，其值的设定是一个关键的参数  
传输往返时间（RTT）：固定的超时值  
一般会认为RTO的取值会略大于RTT  
使用低通过滤器来更新一个被平滑的RTT估计器  
新的SRTT=α×（旧的SRTT）+（1-α）×（新的RTT样本）  
Karn算法：在一个超时和重传发生时，在重传数据到达确认前，不能更新RTT估计器，因为不知道ACK对应哪次传输  
有关算法还有拥塞避免算法，快速重传和快速回复算法等等

TCP的坚持定时器
---------

如果一个确认丢失了，那么发送方和接收方之间可能会因为持续等待而发生死锁  
为了防止死锁的产生，所以有了坚持定时器。以周期性地向接收方查询

TCP的保活定时器
---------

如果TCP连接的双方都没有向对方发送数据，则在两个TCP模块之间不交换任何信息  
如果一个给定的TCP连接在两个小时都没有任何动作，则服务器向客户发送一个探查报文片段  
则客户主机必须处于以下4种情况之一

*   客户主机依然正常运行，并且从服务器可达
*   客户主机崩溃，并且关闭或者重新启动
*   客户主机崩溃并已经重新启动
*   客户主机正常运行，但是从服务器不可达  
    第一种情况客户主机并不会发现保活探查的发生，整个过程对TCP层是透明的  
    只有第2，3，4种情况时TCP会发送差错报告

HTTP协议
======

包括4个请求：

*   get：请求读取URL所标志的信息
*   post：给服务器添加信息
*   put：在给定url下储存文档
*   delete：删除给定url所标志的资源

get和post区别：

*   get是从服务器上获取数据，post是向服务器发送数据
*   get会把参数数据队列添加到url中，值和表单内各个字段一一对应
*   get传输的数据量小，不超过2KB,post传输的数据量大，默认不限制
*   根据HTTP规范，GET用于信息获取，是安全和幂等的

安全：仅用于获取信息而不是修改信息  
幂等：对同一URL的多个请求应返回相同的结果

在浏览器中输入 [http://www.baidu.com/](http://www.baidu.com/) 所执行的全过程  
Baidu.com是我们想要访问的服务器，执行以下操作

*   客户端浏览器通过DNS解析http://www.baidu.com/的IP地址到220.181.27.48，通过此IP地址找到客户端到服务端的路径，客户端向该IP发起一个HTTP会话，然后通过TCP封装数据包，输出到网络层，建立TCP连接
*   在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如果服务器使用80端口监听请求，客户端随机选择一个端口，和服务器进行交换，服务器把相应的请求返回给客户端的端口（服务器处理请求）
*   客户端的网络层主要做的就是通过路由表查询如何到达服务器
*   包通过链路层发送到路由器

状态码（开发常用）
---------

200：请求成功，一般用于get和post  
500：服务器内部错误，无法完成请求  
401：请求需要用户身份验证  
403：服务器拒绝请求  
404：服务器无法根据客户端请求找到网页资源

cookie
======

HTTP协议本身是无状态的——指无法辨认用户的身份  
cookie实际上是一小段文本消息  
客户端向服务器发起请求，如果服务器需要记录该用户状态，就需要向客户浏览器发一个cookie。  
而客户端浏览器会把cookie保存起来。当浏览器再次请求时，会把cookie一起提交给服务器，服务器会检查该用户的状态