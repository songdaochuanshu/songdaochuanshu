---
layout: post
title: "Dubbo-聊聊通信模块设计"
date: "2022-11-07T07:18:43.918Z"
---
Dubbo-聊聊通信模块设计
==============

### 前言

Dubbo源码阅读分享系列文章，欢迎大家关注点赞

#### SPI实现部分

1.  [Dubbo-SPI机制](https://mp.weixin.qq.com/s?__biz=MzU0NDc4NjA0MQ==&mid=2247486229&idx=1&sn=d25be996fe2b231ffb08a6ea7dd439cd&chksm=fb779803cc00111523ce949f6d5800c4fc946128ee89a7fa2d7375e43dcca404d1fdb87e7999&token=1411247643&lang=zh_CN#rd)
    
2.  [Dubbo-Adaptive实现原理](https://mp.weixin.qq.com/s?__biz=MzU0NDc4NjA0MQ==&mid=2247486253&idx=1&sn=38b3e7ea44a468f91b1fa05a38fe7da9&chksm=fb77983bcc00112dd0d2d50a0cb08edb77ea345ab7fe98afd938cdde5ce87719a720c02a1414&token=1411247643&lang=zh_CN#rd)
    
3.  [Dubbo-Activate实现原理](https://mp.weixin.qq.com/s?__biz=MzU0NDc4NjA0MQ==&mid=2247486267&idx=1&sn=dc85d2eb5df0201b6943671db013d6bf&chksm=fb77982dcc00113b2f40f71179b8f16a820fbf88f21b48bacc6ded8efb2fdf8282561d148b32&token=1411247643&lang=zh_CN#rd)
    
4.  [Dubbo SPI-Wrapper](https://mp.weixin.qq.com/s?__biz=MzU0NDc4NjA0MQ==&mid=2247486282&idx=1&sn=27a730c5599b713b9b31516f181f6868&chksm=fb77985ccc00114abea1c6280939b2714e5e2340acf8412d61d8522d0d567ca15058e91e6877&token=1411247643&lang=zh_CN#rd)
    

#### 注册中心

5.  [Dubbo-聊聊注册中心的设计](https://mp.weixin.qq.com/s?__biz=MzU0NDc4NjA0MQ==&mid=2247486325&idx=1&sn=3deafd8344d1e2142dbef60101d82a0a&chksm=fb779863cc0011754d1ff51c2de25c3da388b7e94e3ff66cb0a93cc84f9172dad30bf0710d67&token=641254188&lang=zh_CN#rd)
    

### 通信模块介绍

Dubbo通信模块主要的目的就是解决客户端以服务端通信的问题，核心代码都在dubbo-remoting模块，该模块提供了多种客户端和服务端通信的功能。Dubbo的通信主要包括是三部分:Exchange、Transport和Serialize，对于序列化部分的设计在单独的模块中，我们再单独聊，这篇文章主要聊Exchange、Transport设计。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666656589351-71e1a2ab-2030-4141-b711-d6d6da6bec01.png#averageHue=%23d3eabb&clientId=u57ab6744-17e9-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=515&id=u2bff7eea&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1030&originWidth=1522&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1840307&status=error&style=none&taskId=u28f72235-ab5f-4580-8ef7-5e1c506d45b&title=&width=761) 对于Dubbo来说没有自己的网络框架，使用现有第三方类库，因此需要设计一套标准API来兼容多种不同的通信框架，dubbo-remoting 模块的结构就是目前Dubbo兼容的所有的通信框架。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666698820823-b69a59ee-6445-42d8-99e5-d0ab5ce2d1ce.png#averageHue=%23e7e7e7&clientId=uacb3b859-527f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=245&id=uf540878a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=490&originWidth=650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66905&status=done&style=none&taskId=u20e6ed08-8e17-436f-9b55-258e4d3a772&title=&width=325) 在整体模块设计上，dubbo-remoting-api是其他模块上层抽象，其他子模块都是依赖第三方NIO库实现 dubbo-remoting-api模块的。因此我们想要了解清楚dubbo-remoting设计必须要理解dubbo-remoting-api的设计。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666700261714-0d9753cb-b3a4-4116-b640-4929afd79e5d.png#averageHue=%23fbfbfb&clientId=uacb3b859-527f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=354&id=ud6b7a11f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=736&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49926&status=done&style=none&taskId=u5c9ec4e1-a1f2-4f53-8b79-22421b14846&title=&width=368) 对于dubbo-remoting-api大致可以分为四类，

1.  核心API设计，主要是包括端口、编码、解码等等核心接口的抽象；
    
2.  buffer，主要是定义缓冲区相关的接口、抽象类以及实现类；
    
3.  exchange，抽Request和Response概念抽象以及扩展；
    
4.  transport，网络传输层的抽象，但它只负责消息的传输；
    

### 源码分析

#### 核心API设计

###### Endpoint

Endpoint被翻译端点，这里可以理解为通信中对IP和Port的抽象，Client和Server端共同的抽象，两个端通过Endpoint建立TCP连接，进行通信。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666701229115-14a25bcb-6785-4491-ad64-0332a6d24fdc.png#averageHue=%23edece8&clientId=uacb3b859-527f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=253&id=ud9a9aa95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=506&originWidth=570&originalType=binary&ratio=1&rotation=0&showTitle=false&size=64437&status=done&style=none&taskId=ue4bb2f35-c684-49eb-99f2-39e327155ae&title=&width=285) 对于该Endpoint接口定义了三类方法:

1.  get类方法，主要获取Endpoint的本地地址、关联的URL信息以及底层Channel关联的ChannelHandle，也就是获取建立连接需要的属性；
    
2.  send方法主要负责发送数据；
    
3.  close类方法，主要是用来关闭连接；
    

###### Channel

Channel可以理解为Client和Server端连接的通道，是NIO框架设计中不可缺少的概念，Channel继承Endpoint，因此拥有Endpoint的能力，对于Channel来说，可以给自身设计一些额外属性。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666701894525-afe3b65a-db04-449f-8a33-dccd7090f04d.png#averageHue=%23ecebe9&clientId=uacb3b859-527f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=472&id=u588abea1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=944&originWidth=584&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118147&status=done&style=none&taskId=u620ce01a-83f8-4916-94e9-dddcaf37aa4&title=&width=292)

###### ChannelHandler

ChannelHandler可以理解为Channel的处理器，ChannelHandler 可以处理Channel的连接建立以及连接断开事件，还可以处理读取到的数据、发送的数据以及捕获到的异常。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666703273867-b80c4248-cfa0-42be-8e41-5c9f35d57ca3.png#averageHue=%23e3e3e3&clientId=uacb3b859-527f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=157&id=u89026d21&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45761&status=done&style=none&taskId=uc4ae2ad6-b978-4711-9af1-d385eb22dc6&title=&width=250)

###### Codec2

Codec2实现编码和解码，实现字节与消息体之间的转换，类似Netty中编码和解码。此外，Codec2接口被@SPI 接口修饰了，说明该接口是一个扩展接口，同时encode方法和 decode方法都被@Adaptive注解修饰，因此也会生成适配器类，可以根据URL中的codec值确定具体的扩展实现类，这里就体现SPI和URL灵活配置的特性。

`@SPI   public interface Codec2 {          @Adaptive({Constants.CODEC_KEY})       void encode(Channel channel, ChannelBuffer buffer, Object message) throws IOException;          @Adaptive({Constants.CODEC_KEY})       Object decode(Channel channel, ChannelBuffer buffer) throws IOException;             enum DecodeResult {           NEED_MORE_INPUT, SKIP_SOME_INPUT       }      }   `

此外还存在DecodeResult的枚举，该枚举是处理粘包和拆包使用的。

###### Client

Client继承了Endpoint、Channel等相关的接口，因此对于Client也具备收发消息能力，Client只可以关联一个 Channel。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666705770613-89abf8e7-4925-4c31-a644-54ce60b15c15.png#averageHue=%23f6f6f6&clientId=uacb3b859-527f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=608&id=u02e161c7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1216&originWidth=1456&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188692&status=done&style=none&taskId=u4f3e45c1-465d-4891-88f5-f4839d1392e&title=&width=728)

###### RemotingServer

Server与Client不太一样地方就是可以接收多个Client发起的Channel连接，因此RemotingServer接口中存在获取多个Channel列表的接口。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666706176352-c3c812b2-6d0a-4fd0-9154-51b84c838007.png#averageHue=%23f3f3f3&clientId=uacb3b859-527f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=427&id=u80b3f44d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=854&originWidth=1288&originalType=binary&ratio=1&rotation=0&showTitle=false&size=137252&status=done&style=none&taskId=u283364ad-4fd4-4c4f-aa76-8284d68968d&title=&width=644)

###### Transporter

Transporter接口是Dubbo在Client和Server上又封装的一层，我们可以看到改接口被@SPI以及@Adaptive注解修饰，因此这个是个可扩展的接口，默认使用Netty的扩展，@Adaptive表示可以动态生成该适配的类，根据设置的值确定具体实现的类。

`@SPI("netty")   public interface Transporter {          @Adaptive({Constants.SERVER_KEY, Constants.TRANSPORTER_KEY})       RemotingServer bind(URL url, ChannelHandler handler) throws RemotingException;          @Adaptive({Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY})       Client connect(URL url, ChannelHandler handler) throws RemotingException;      }   `

Transporter的实现类有主要有以下几种，每个对应的具体的NIO的实现都在其各自的包中，这样可以通过灵活配置来进行切换不同的实现。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666824983743-c735cebd-bfd3-4243-b7c7-44ed42b791f8.png#averageHue=%23f6f6f6&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=214&id=u65118c5a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=428&originWidth=1650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47956&status=done&style=none&taskId=ucb184698-653a-4bb6-8469-9b71eb3447c&title=&width=825) 为了验证是否正确，我们简单再来看一下RemotingServer的实现，RemotingServer的实现中，包含每个具体NIO框架的实现，因此这里更加印证Transporter的的抽象，让我们可以通过Dubbo SPI修改具体Transporter扩展实现，从而切换到不同的Client和 RemotingServer实现，从而达到NIO库切换，这里我们无需修改任何代码，真正的做到开放-闭合的原则。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666825689906-3729845c-b8a9-4095-b4a4-caa3fe20f121.png#averageHue=%23f5eceb&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=396&id=u090c3e67&margin=%5Bobject%20Object%5D&name=image.png&originHeight=792&originWidth=1976&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108213&status=done&style=none&taskId=uae3b0d17-e932-4083-bc69-666a789489a&title=&width=988)

###### Transporters

Transporters该类是一种门面模式的设计，主要是解决和多个不同子模块直接进行交互的问题，通过该类设计，将公共的行为Transporter对象的创建以及ChannelHandler的处理，大家可以直接依赖Transporters类，这部分调用是在Dubbo协议初始化时候发起的，这部分我们到时候在细讲，这个章节暂时先不讲解。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666826838987-c3ba33db-71ff-415c-a31f-c7c170318e88.png#averageHue=%23e4e4e4&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=161&id=u58b48281&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=672&originalType=binary&ratio=1&rotation=0&showTitle=false&size=54279&status=done&style=none&taskId=u2cf71ff4-8293-4bfe-95c3-a9fea40cab5&title=&width=336) 但是这里需要在这个看一下关于ChannelHandler的处理，此处传入了多个ChannelHandler，将多个ChannelHandler包装成为ChannelHandlerDispatcher，ChannelHandlerDispatcher实现ChannelHandler，内部维护了一个 CopyOnWriteArraySet，对外提供操作ChannelHandler方法，此处主要是为了引出后续Handler的处理流程，后续一层处理模型的源头都在这里。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667699495248-234c2a58-8bf7-4bc2-b207-ebb727350aef.png#averageHue=%23f8f8f7&clientId=u60bbab0e-9ee0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=371&id=u161f89be&margin=%5Bobject%20Object%5D&name=image.png&originHeight=742&originWidth=2014&originalType=binary&ratio=1&rotation=0&showTitle=false&size=160402&status=done&style=none&taskId=u7e8a9dba-9a3b-4d15-b81c-8e5f86e4f07&title=&width=1007) ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667699469300-4ae97ec1-35be-4227-9369-4a705ce6552d.png#averageHue=%23f8f8f7&clientId=u60bbab0e-9ee0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=547&id=ub6c27be5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1094&originWidth=2022&originalType=binary&ratio=1&rotation=0&showTitle=false&size=226984&status=done&style=none&taskId=u4c3ac8e7-b8cd-435e-a4e8-7e00274bcf9&title=&width=1011)

到这里我们大概对Dubbo的通讯模型有了一个轮廓，我们来进行一个简单的总结，可以参考下图: ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1666876970899-6391ab78-2bf6-4d41-8726-fec59eb4bce7.png#averageHue=%23fcecdc&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=370&id=u86fae8cf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=740&originWidth=1456&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83348&status=done&style=none&taskId=u8f20c039-4e8b-46c3-b868-c3beb0b1717&title=&width=728)

1.  上层通过会Transporters获取到具体的Transporter扩展实现，然后通过Transporter获取Client和 RemotingServer实现；
    
2.  Client与RemotingServer都是通过Channel进行交互，Channel使用ChannelHandler进行数据传输，此外通过Codec2进行编解码；
    

##### Buffer设计

![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667047687635-176a22b7-0335-4d09-8a70-6a4af80c975b.png#averageHue=%23f5f5f5&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=240&id=u7201e06b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=480&originWidth=1298&originalType=binary&ratio=1&rotation=0&showTitle=false&size=51244&status=done&style=none&taskId=u417ef7e4-e52b-47da-ac8a-9a491305235&title=&width=649)

image.png

###### 接口设计

ChannelBuffer的设计类似于Netty的Buffer的设计，大致可以分为五类，对于具体的实现我们在后面AbstractChannelBuffer等实现类里面进行讲解。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667049504181-b9c14a4c-42e1-44bb-b2e2-c1be2a019120.png#averageHue=%23f9f9f9&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=339&id=u8e67f011&margin=%5Bobject%20Object%5D&name=image.png&originHeight=678&originWidth=732&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60356&status=done&style=none&taskId=u45aaef78-d031-4f19-9ce5-1a1c37ecb55&title=&width=366) 接下来我们来看一下ChannelBufferFactory，该接口都是用来创建ChannelBuffer的，并且每个具体的实现都是单例的，可以理解为一个简单工厂的设计，可以有不同类型的ChannelBuffer的实现。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667049755667-6aebfe0a-d5e7-4358-8bc7-6877be5f22b0.png#averageHue=%23efefef&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=89&id=u1a663678&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28692&status=done&style=none&taskId=ud3b85d44-0594-4420-b0aa-87cdffbce09&title=&width=583)

###### AbstractChannelBuffer

AbstractChannelBuffer维护两类索引，一类用于读写，另外一类用于读写标记； ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667051821093-9ca811a4-ac44-4227-a0fc-ecb04ee7cda1.png#averageHue=%23fcfcfc&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=255&id=u672a3956&margin=%5Bobject%20Object%5D&name=image.png&originHeight=510&originWidth=682&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59072&status=done&style=none&taskId=u5fe915d6-d025-4581-ba83-4c6cea79760&title=&width=341) 关于读写类索引就是记录当前读到什么位置以及写到什么位置了，标记类索引就是为了做数据备份和回滚使用，为了对缓冲区重复利用。该类的方法都主要是利用四个属性来操作，用来检测是否有数据可读或者还是否有空间可写等方法，做一些前置条件的校验以及索引的设置，具体的实现都是需要子类来实现。

    `@Override       public void readBytes(byte[] dst, int dstIndex, int length) {           //检查位置是否足够           checkReadableBytes(length);           //此处可以理解为将readerIndex后移length个字节读取到dst数组中           //也就是数组dst的dstIndex~dstIndex+length位置           getBytes(readerIndex, dst, dstIndex, length);           //readerIndex后移length个字节           readerIndex += length;       }       @Override       public void readBytes(byte[] dst, int dstIndex, int length) {           //检查位置是否足够           checkReadableBytes(length);           //此处可以理解为将readerIndex后移length个字节读取到dst数组中           //也就是数组dst的dstIndex~dstIndex+length位置           getBytes(readerIndex, dst, dstIndex, length);           //readerIndex后移length个字节           readerIndex += length;       }       @Override       public void writeBytes(byte[] src, int srcIndex, int length) {           //将src数组中srcIndex~srcIndex+length位置的数据写到当前的buffer中           setBytes(writerIndex, src, srcIndex, length);           //将当前的writerIndex后移length           writerIndex += length;       }`

###### HeapChannelBuffer

HeapChannelBuffer是ChannelBuffer的一种具体的实现，该类是基于字节数组的ChannelBuffer实现，通过byte\[\]数组来进行数据的存储，setBytes和getBytes通过System.arraycopy来进行对数组的操作。

    `//此缓冲区包装的基础堆字节数组       protected final byte[] array;              @Override       public void getBytes(int index, byte[] dst, int dstIndex, int length) {           System.arraycopy(array, index, dst, dstIndex, length);       }          @Override       public void setBytes(int index, byte[] src, int srcIndex, int length) {           System.arraycopy(src, srcIndex, array, index, length);       }`

对于HeapChannelBuffer的具体的工厂的实现是HeapChannelBufferFactory，该工厂是一个单例模式，HeapChannelBufferFactory通过ChannelBuffers工具类创建固定容量的HeapChannelBuffer，此外也可以通过拷贝的形式创建HeapChannelBuffer。

    `@Override       public ChannelBufferFactory factory() {           return HeapChannelBufferFactory.getInstance();       }`

![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667094349145-8f15b9fb-190a-48ac-82c2-36e8c3dbb9fb.png#averageHue=%23f7f7f5&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=240&id=u862fb2f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=480&originWidth=1452&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93427&status=done&style=none&taskId=ua880db99-a596-4ba1-ae30-078769e7afe&title=&width=726) ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667094333853-cb2956ab-06ef-43b0-aaf8-1c0ba1fae087.png#averageHue=%23f6f6f4&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=193&id=u271d963a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=1692&originalType=binary&ratio=1&rotation=0&showTitle=false&size=99795&status=done&style=none&taskId=u7b3f85ad-9371-421a-babc-b300abd63b2&title=&width=846)

###### DynamicChannelBuffer

DynamicChannelBuffer可以理解为一个扩展类，也就是对装饰者模式，就是对ChannelBuffer的增加强，增加动态扩容的能力，关于该类默认的实现HeapChannelBufferFactory，我可以通过指定HeapChannelBufferFactory为对应的实现添加动态扩容的能力。

    `//具体的ChannelBufferFactory的实现       private final ChannelBufferFactory factory;          //需要扩容的buffer       private ChannelBuffer buffer;          public DynamicChannelBuffer(int estimatedLength) {           //默认实现           this(estimatedLength, HeapChannelBufferFactory.getInstance());       }          //指定具体的实现       public DynamicChannelBuffer(int estimatedLength, ChannelBufferFactory factory) {           if (estimatedLength < 0) {               throw new IllegalArgumentException("estimatedLength: " + estimatedLength);           }           if (factory == null) {               throw new NullPointerException("factory");           }           this.factory = factory;           buffer = factory.getBuffer(estimatedLength);       }`

关于如何实现ChannelBuffer的动态扩容，看懂Java ArryList扩容的，我相信一定能理解，也就是我们要控制写入时候的判断写入的空间是否足够就可以了。DynamicChannelBuffer通过ensureWritableBytes方法来实现扩容，我们来看下他是如何做的:

    `@Override       public void ensureWritableBytes(int minWritableBytes) {           //如果写入字节数小于等于可写的字节数           if (minWritableBytes <= writableBytes()) {               return;           }           //新增容量           int newCapacity;           //缓存区字节数为0           if (capacity() == 0) {               //设置为1               newCapacity = 1;           } else {               //新增容量为缓冲区字节数               newCapacity = capacity();           }           //最小新增容量 = 当前写入字节数的索引+最小写入的字节数           int minNewCapacity = writerIndex() + minWritableBytes;           //如果新增容量小于最小新增容量           while (newCapacity < minNewCapacity) {               //新增容量左移1位，加倍               newCapacity <<= 1;           }           //通过工厂类创建该容量           ChannelBuffer newBuffer = factory().getBuffer(newCapacity);           //从buffer中读取数据到newBuffer中           newBuffer.writeBytes(buffer, 0, writerIndex());           //替换原来的缓存区           buffer = newBuffer;       }`

###### ByteBufferBackedChannelBuffer

ByteBufferBackedChannelBuffer该类是基于Java NIO的ByteBuffer实现的ChannelBuffer，都是通过操作ByteBuffer的API进行实现，这里我们就不展开了。

    `//NIO ByteBuffer       private final ByteBuffer buffer;          //初始化容量       private final int capacity;          public ByteBufferBackedChannelBuffer(ByteBuffer buffer) {           if (buffer == null) {               throw new NullPointerException("buffer");           }              this.buffer = buffer.slice();           capacity = buffer.remaining();           writerIndex(capacity);       }          public ByteBufferBackedChannelBuffer(ByteBufferBackedChannelBuffer buffer) {           this.buffer = buffer.buffer;           capacity = buffer.capacity;           setIndex(buffer.readerIndex(), buffer.writerIndex());       }`

###### ChannelBufferInputStream

![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667098886162-8a817997-ab5b-4284-895b-c7300f2d9d81.png#averageHue=%23efefef&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=282&id=u4395f677&margin=%5Bobject%20Object%5D&name=image.png&originHeight=564&originWidth=502&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31640&status=done&style=none&taskId=ucdf08b74-567f-4695-b54d-453e51c1794&title=&width=251) ChannelBufferInputStream该类实现InputStream输入流的的方法，内部维护了ChannelBuffer、startIndex以及endIndex，该方法内部都是读取ChannelBuffer中的数据，startIndex和endIndex控制读取数据位置，这样就完成 InputStream的扩展实现。

    `//ChannelBuffer       private final ChannelBuffer buffer;       //开始位置       private final int startIndex;       //结束位置       private final int endIndex;          @Override       public int read() throws IOException {           if (!buffer.readable()) {               return -1;           }           return buffer.readByte() & 0xff;       }`

###### ChannelBufferOutputStream

![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667098836002-5a551ab1-fc39-4dac-8c22-1549731cac21.png#averageHue=%23efefef&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=282&id=ua77378da&margin=%5Bobject%20Object%5D&name=image.png&originHeight=564&originWidth=618&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41132&status=done&style=none&taskId=u82a5c83a-7c58-490d-93b0-f7e6a089e93&title=&width=309) ChannelBufferOutputStream该类实现OutputStream输出流，内部维护了ChannelBuffer、startIndex，该方法内部都是写入到ChannelBuffer中，startIndex是标记开始写入位置。 Buffer的整体的设计到此就介绍完成，通过ChannelBufferOutputStream、ChannelBufferInputStream控制数据的输入输出，内部通过ChannelBuffer存储数据，ChannelBuffer可以根据需要进行不同的实现。

##### Transport设计

Transport在核心API中介绍上层访问都是通过该接口访问的，接下来我们就来探秘下Transport层都做了哪些事情。

###### AbstractPeer

![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667112636703-8863c84b-c0c1-4c9a-9268-93c68e458ca2.png#averageHue=%23f3f3f2&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=310&id=u1f1fb8e6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=634&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47351&status=done&style=none&taskId=u97ef1b91-4218-4fdb-9745-314f91b5c58&title=&width=317) AbstractPeer该抽象类可以理解为服务器概念，继承了Endpoint、ChannelHandler接口，内部有四个核心的属性，URL代表自身服务的地址，closing、closed表示当前服务器状态，handler就是ChannelHandler，AbstractPeer内部实现了都是委托给ChannelHandler，这是一种典型的装饰器设计模式。

    `//ChannelHandler       private final ChannelHandler handler;          //自身地址       private volatile URL url;          //服务器状态       private volatile boolean closing;          private volatile boolean closed;          public AbstractPeer(URL url, ChannelHandler handler) {           if (url == null) {               throw new IllegalArgumentException("url == null");           }           if (handler == null) {               throw new IllegalArgumentException("handler == null");           }           this.url = url;           this.handler = handler;       }`

###### AbstractEndpoint

![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667116115315-1eabb2f1-9a38-4afd-85fd-c1b19ae1577a.png#averageHue=%23f4f4f4&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=294&id=u3c28158a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=588&originWidth=788&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41238&status=done&style=none&taskId=ue488e007-3107-42c5-b24b-3e52aa38b36&title=&width=394) AbstractEndpoint继承AbstractPeer，可以理解为端口的抽象，内部增加Codec2和connectTimeout两个属性，在AbstractEndpoint在初始化的时候会将这两个字段初始化。

    `private Codec2 codec;          private int connectTimeout;          public AbstractEndpoint(URL url, ChannelHandler handler) {           //调用父类           super(url, handler);           //根据URL中的codec参数值，确定此处具体的Codec2实现类           this.codec = getChannelCodec(url);           //设置connectTimeout           this.connectTimeout = url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT);       }       protected static Codec2 getChannelCodec(URL url) {           //获取URL协议           String codecName = url.getProtocol();           //判断有没有该扩展名           if (ExtensionLoader.getExtensionLoader(Codec2.class).hasExtension(codecName)) {               //通过ExtensionLoader加载具体实现类               return ExtensionLoader.getExtensionLoader(Codec2.class).getExtension(codecName);           } else {               //没有匹配到从扩展类进行加载               return new CodecAdapter(ExtensionLoader.getExtensionLoader(Codec.class)                       .getExtension(codecName));           }       }`

此外该接口实现Resetable接口，该接口内部只有一个reset方法，该方法通过获取URL参数信息，重置了connectTimeout的信息以及Codec2的信息。

###### AbstractServer

![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667117984341-1b7e8b6f-159f-479a-995f-ce119806b8ef.png#averageHue=%23f4f4f4&clientId=uea9856c2-56e1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=370&id=ua8f33a06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=740&originWidth=976&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69860&status=done&style=none&taskId=u14e3040b-1120-44e8-b490-62fac60e799&title=&width=488) AbstractServer是对服务端的抽象，该抽象类实现AbstractEndpoint和RemotingServer，该抽象类内部有五个核心属性，localAddress、bindAddress这两个属性都是在URL参数中获取，表示Server本地的地址以及绑定的地址，默认两个值是一致的，accepts表示是Server最大的连接次数，默认是0，表述没有限制，executorRepository、executor线程池相关的属性，executorRepository负责管理线程池，executor表示当前服务管理的线程池。

    `//当前服务关联的线程池       ExecutorService executor;       //本机地址       private InetSocketAddress localAddress;       //绑定地址       private InetSocketAddress bindAddress;       //最大连接数       private int accepts;       //管理线程池       private ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();`

AbstractServer初始化也就是在构造函数中完成初始化的，然后通过调用其抽象方法doOpen实现启动服务器。

    `public AbstractServer(URL url, ChannelHandler handler) throws RemotingException {           //调用父类           super(url, handler);           //从URL获取本地地址           localAddress = getUrl().toInetSocketAddress();              String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());           int bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());           if (url.getParameter(ANYHOST_KEY, false) || NetUtils.isInvalidLocalHost(bindIp)) {               bindIp = ANYHOST_VALUE;           }           //绑定地址           bindAddress = new InetSocketAddress(bindIp, bindPort);           //连接数           this.accepts = url.getParameter(ACCEPTS_KEY, DEFAULT_ACCEPTS);           try {               //调用该抽象方法启动服务               doOpen();               if (logger.isInfoEnabled()) {                   logger.info("Start " + getClass().getSimpleName() + " bind " + getBindAddress() + ", export " + getLocalAddress());               }           } catch (Throwable t) {               throw new RemotingException(url.toInetSocketAddress(), null, "Failed to bind " + getClass().getSimpleName()                       + " on " + getLocalAddress() + ", cause: " + t.getMessage(), t);           }           //创建该服务对应的线程池           executor = executorRepository.createExecutorIfAbsent(url);       }`

###### AbstractClient

AbstractClient是对客户端的抽象，同样它的继承和AbstractServer也一样，只是在实现不同而已，接下来我们来看看AbstractClient的实现，该类内部有4个关键的字段，对于executor和executorRepository这两个字段与AbstractServer功能类似，这里重点来介绍connectLock和needReconnect，connectLock是当客户端进行连接、断开、重连等操作时，需要获取该锁进行同步操作，needReconnect 在客户端发送数据之前，会检查客户端的连接是否断开，如果断开了，则会根据needReconnect字段，决定是否重连。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667517417113-996f6503-2614-4e84-9bfc-b55417542986.png#averageHue=%23f8f7f5&clientId=u710e5d91-1111-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=207&id=ucda1c1ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=414&originWidth=2304&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136277&status=done&style=none&taskId=ue7b0e9cf-c7ed-49d3-8e34-fabf1c82110&title=&width=1152) AbstractClient整体的初始化是在构造函数实现的，我们可以看到AbstractClient 定义了 doOpen、doClose、doConnect和doDisConnect四个抽象方法给子类实现，整体的设计与AbstractServer类似。

    `public AbstractClient(URL url, ChannelHandler handler) throws RemotingException {           //调用父类构造方法           super(url, handler);           //从URL获取是否重连字段 默认是           needReconnect = url.getParameter(Constants.SEND_RECONNECT_KEY, true);           //初始化Executor           initExecutor(url);              try {               //初始化具体的底层实现client               doOpen();           } catch (Throwable t) {               //关闭               close();               throw new RemotingException(url.toInetSocketAddress(), null,                       "Failed to start " + getClass().getSimpleName() + " " + NetUtils.getLocalAddress()                               + " connect to the server " + getRemoteAddress() + ", cause: " + t.getMessage(), t);           }              try {               //创建连接               connect();               if (logger.isInfoEnabled()) {                   logger.info("Start " + getClass().getSimpleName() + " " + NetUtils.getLocalAddress() + " connect to the server " + getRemoteAddress());               }           } catch (RemotingException t) {               if (url.getParameter(Constants.CHECK_KEY, true)) {                   close();                   throw t;               } else {                   logger.warn("Failed to start " + getClass().getSimpleName() + " " + NetUtils.getLocalAddress()                           + " connect to the server " + getRemoteAddress() + " (check == false, ignore and retry later!), cause: " + t.getMessage(), t);               }           } catch (Throwable t) {               close();               throw new RemotingException(url.toInetSocketAddress(), null,                       "Failed to start " + getClass().getSimpleName() + " " + NetUtils.getLocalAddress()                               + " connect to the server " + getRemoteAddress() + ", cause: " + t.getMessage(), t);           }       }`

###### AbstractChannel

![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667520179230-82dedce7-f82d-4cb9-9b19-e7c5713e3bb1.png#averageHue=%23f6f6f6&clientId=udf119a5e-ed40-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=337&id=u70ad1f0d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=674&originWidth=1260&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67890&status=done&style=none&taskId=u0ddd5738-70ec-4948-825b-c01a89d0c03&title=&width=630) AbstractChannel的设计也是类似模板类的设计，对于不同的NIO框架来说有不同的Channel的实现，因此对于Dubbo来说也必须去抽象该实现，具体的不同交由子类进行实现，子类做映射。该类内部只有有一个Send方法，为了判断当前的连接是否还在，没有实现具体的发送消息。

##### Netty4

###### NettyTransporter

NettyTransporter实现Transporter，当SPI机制触发的时候会自动加载实现NettyServer、NettyClient初始化创建。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667699542976-bdbac7b2-3268-4dda-842b-e0fec95f5592.png#averageHue=%23f9f8f8&clientId=u60bbab0e-9ee0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=383&id=uae0fdb45&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=139150&status=done&style=none&taskId=uce0831d9-804e-4481-81cc-0c2436ccd90&title=&width=909)

###### NettyServer![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667697879647-fb03baf2-810b-4d7e-8951-3f70578429b4.png#averageHue=%23f6f6f6&clientId=u60bbab0e-9ee0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=447&id=u9e37f54c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=894&originWidth=1384&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91856&status=done&style=none&taskId=u30407ed4-93c9-4c2b-82da-6efdce7cdfb&title=&width=692)

接下来我们来看下Netty4中关于doOpen方法的实现，此处就是Netty Server启动的核心，也是Dubbo网络通信的服务端能力的提供者，就是Dubbo和Netty结合的核心。

    `protected void doOpen() throws Throwable {           //创建ServerBootstrap           bootstrap = new ServerBootstrap();              //创建boss EventLoopGroup           bossGroup = NettyEventLoopFactory.eventLoopGroup(1, "NettyServerBoss");           //创建worker EventLoopGroup           workerGroup = NettyEventLoopFactory.eventLoopGroup(                   getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),                   "NettyServerWorker");           //创建一个Netty的ChannelHandler           final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this);           //此处的Channel是Dubbo的Channel           channels = nettyServerHandler.getChannels();           //会话保持           boolean keepalive = getUrl().getParameter(KEEP_ALIVE_KEY, Boolean.FALSE);              bootstrap.group(bossGroup, workerGroup)                   .channel(NettyEventLoopFactory.serverSocketChannelClass())                   .option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)                   .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)                   .childOption(ChannelOption.SO_KEEPALIVE, keepalive)                   .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)                   .childHandler(new ChannelInitializer<SocketChannel>() {                       @Override                       protected void initChannel(SocketChannel ch) throws Exception {                           // FIXME: should we use getTimeout()?                           //连接空闲超时时间                           int idleTimeout = UrlUtils.getIdleTimeout(getUrl());                           //创建Netty实现的decoder和encoder                           NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);                           if (getUrl().getParameter(SSL_ENABLED_KEY, false)) {                               //如果配置HTTPS 要实现SslHandler                               ch.pipeline().addLast("negotiation",                                       SslHandlerInitializer.sslServerHandler(getUrl(), nettyServerHandler));                           }                           ch.pipeline()                                   .addLast("decoder", adapter.getDecoder())                                   .addLast("encoder", adapter.getEncoder())                                   //心跳检查                                   .addLast("server-idle-handler", new IdleStateHandler(0, 0, idleTimeout, MILLISECONDS))                                   //注册nettyServerHandler                                   .addLast("handler", nettyServerHandler);                       }                   });           // bind           ChannelFuture channelFuture = bootstrap.bind(getBindAddress());           //等待绑定完成           channelFuture.syncUninterruptibly();           channel = channelFuture.channel();          }`

此处与Netty启动不同的地方在于替换了Channel的实现为Dubbo实现，然后通过doOpen完成Server启动，大家也可以借助下图来进行理解: ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667175618885-e35fb4f0-a8ab-4e89-8853-4d6242ad3b28.png#averageHue=%23f9e2ca&clientId=ua4051311-ce5b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=347&id=u63915ec1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=694&originWidth=1686&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82330&status=done&style=none&taskId=u40468abc-4c5a-444c-9c7d-d292e014aaf&title=&width=843)

###### NettyCodecAdapter

NettyCodecAdapter该类是对编解码的实现，主要是将Netty规则替换为为Dubbo的规则，该类内部有5个核心的属性，其中encoder和decoder是NettyCodecAdapter内部类，

    `//Netty Channel 编码       private final ChannelHandler encoder = new InternalEncoder();          //Netty Channel 解码       private final ChannelHandler decoder = new InternalDecoder();          //Dubbo 的编解码       private final Codec2 codec;          //URL参数       private final URL url;          //Dubbo ChannelHandler       private final org.apache.dubbo.remoting.ChannelHandler handler;`

encoder和decoder是对Netty中的ByteToMessageDecoder和MessageToByteEncoder的实现，也正是此处的实现将真正的编码委托给Codec2进行实现，

    `private class InternalEncoder extends MessageToByteEncoder {              @Override           protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception {               //Netty对ChannelBuffer的实现 操作字节数组               //将Netty  ByteBuf 包装为 Dubbo  ChannelBuffer               ChannelBuffer buffer = new NettyBackedChannelBuffer(out);               //获取关联的Channel               Channel ch = ctx.channel();               NettyChannel channel = NettyChannel.getOrAddChannel(ch, url, handler);               //codec进行编码               codec.encode(channel, buffer, msg);           }       }          private class InternalDecoder extends ByteToMessageDecoder {              @Override           protected void decode(ChannelHandlerContext ctx, ByteBuf input, List<Object> out) throws Exception {               //将Netty  ByteBuf 包装为 Dubbo  ChannelBuffer               ChannelBuffer message = new NettyBackedChannelBuffer(input);               //获取关联的Channel               NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);                  // decode object.               do {                   //记录当前读到的位置                   int saveReaderIndex = message.readerIndex();                   //codec进行解码                   Object msg = codec.decode(channel, message);                   //判断消息长度是否足够                   if (msg == Codec2.DecodeResult.NEED_MORE_INPUT) {                       //重置读取的位置                       message.readerIndex(saveReaderIndex);                       break;                   } else {                       //边界值判断                       if (saveReaderIndex == message.readerIndex()) {                           throw new IOException("Decode without read data.");                       }                       //将消息传递给其他Handler                       if (msg != null) {                           out.add(msg);                       }                   }               } while (message.readable());           }       }`

###### NettyServerHandler

NettyServerHandler该类继承了Netty的ChannelDuplexHandler，该类具备同时处理Inbound和Outbound的能力，我们来看下整体的继承结构，整体的继承结构确实也是一样的。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667391471804-a334a763-b4cb-4c4a-b6c6-cdee16f50a4c.png#averageHue=%23f5f5f5&clientId=u710e5d91-1111-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=370&id=u4e5cb6b9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=740&originWidth=1492&originalType=binary&ratio=1&rotation=0&showTitle=false&size=79836&status=done&style=none&taskId=u29f0d2fd-7573-40cf-b49a-7931c9ae87e&title=&width=746) 该类内部主要有3个核心字段，这里相对比较重要的是channels和handler， ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667392897199-df1a0b64-9df6-4ac3-b5c5-6d99d95b6d55.png#averageHue=%23f8f5f1&clientId=u710e5d91-1111-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=146&id=ud7908aa9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=292&originWidth=1890&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77784&status=done&style=none&taskId=ub7439751-0d37-4d16-ac0a-9cf208a99cf&title=&width=945) channels字段缓存当前所有Server创建的Channel，所有的创建、断开连接的时候都会操作channels该对象，handler在内部所有的实现都是通过Dubbo ChannelHandler,这样就完成对Netty的替换；代码如下:

    `@Override       public void channelActive(ChannelHandlerContext ctx) throws Exception {           NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);           if (channel != null) {               //新建的链接 增加缓存               channels.put(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()), channel);           }           //使用Dubbo ChannelHandler建立连接           handler.connected(channel);              if (logger.isInfoEnabled()) {               logger.info("The connection of " + channel.getRemoteAddress() + " -> " + channel.getLocalAddress() + " is established.");           }       }          @Override       public void channelInactive(ChannelHandlerContext ctx) throws Exception {           NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);           try {               //关闭连接 移除缓存               channels.remove(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()));               //关闭释放Dubbo ChannelHandler               handler.disconnected(channel);           } finally {               //NettyChannel也同时移除               NettyChannel.removeChannel(ctx.channel());           }              if (logger.isInfoEnabled()) {               logger.info("The connection of " + channel.getRemoteAddress() + " -> " + channel.getLocalAddress() + " is disconnected.");           }       }`

在NettyServer创建的时候，有下图代码，这里的this指的就是NettyServer，在NettyServerHandler里面第二个参数是ChannelHandler，同时NettyServer又继承了实现ChannelHandler的AbstractPeer，因此NettyServerHandler在创建的时候就会将所有数据委托给ChannelHandler进行处理，此处体现多态的魅力。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667393781353-2560f04e-a480-49a5-91b8-6276592d6793.png#averageHue=%23f4f3ef&clientId=u710e5d91-1111-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=126&id=u67617d39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=252&originWidth=1858&originalType=binary&ratio=1&rotation=0&showTitle=false&size=87023&status=done&style=none&taskId=u134ef00b-8cca-4dd4-b2bb-9a8235d2340&title=&width=929) ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667393981128-21bb209e-9c30-4d00-8465-3b6d24d0e51b.png#averageHue=%23f8f5f4&clientId=u710e5d91-1111-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=502&id=u468e9aaa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1004&originWidth=1114&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90615&status=done&style=none&taskId=ue14ab7db-5a3d-403b-922c-07926989eb7&title=&width=557) 到此相信你也对Netty Server以及Dubbo Server设计有了一个深入的了解，可以参考下图，上层是对Client、Channel等能力的抽象，这些抽象能力抽象接口实现，这样子该抽象方法子类又可以有不同的实现，这样子就完成上层能力的建设，下层又可以根据自身特点完成自己编解码以及服务的实现，做到了灵活多变，自由扩展。 ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667395015953-dc31203a-e4ae-4923-87d4-54c2131bab79.png#averageHue=%23f8eee9&clientId=u710e5d91-1111-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=314&id=u7e1a20a2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=628&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83373&status=done&style=none&taskId=u2383d9c8-61ba-4b2d-8173-3345ae5011d&title=&width=462)

###### NettyClient

![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667697908306-c362236b-6036-4907-abc0-535db47df498.png#averageHue=%23f6f6f6&clientId=u60bbab0e-9ee0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=481&id=u7e455c3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=962&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90609&status=done&style=none&taskId=u9fbe7fda-edb8-4a8b-88a3-25db7da3a66&title=&width=610) NettyClient实现与NettyServer类似，都是初始化自身服务，这里我们来看下实现；

  `@Override       protected void doOpen() throws Throwable {           //创建NettyClientHandler 做法与Server类似           final NettyClientHandler nettyClientHandler = new NettyClientHandler(getUrl(), this);           bootstrap = new Bootstrap();           bootstrap.group(EVENT_LOOP_GROUP)                   .option(ChannelOption.SO_KEEPALIVE, true)                   .option(ChannelOption.TCP_NODELAY, true)                   .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)                   //.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout())                   .channel(socketChannelClass());           //设置超时时间           bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.max(DEFAULT_CONNECT_TIMEOUT, getConnectTimeout()));           bootstrap.handler(new ChannelInitializer<SocketChannel>() {                  @Override               protected void initChannel(SocketChannel ch) throws Exception {                   //设置心跳的间隔                   int heartbeatInterval = UrlUtils.getHeartbeat(getUrl());                      if (getUrl().getParameter(SSL_ENABLED_KEY, false)) {                       ch.pipeline().addLast("negotiation", SslHandlerInitializer.sslClientHandler(getUrl(), nettyClientHandler));                   }                      NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this);                   ch.pipeline()//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug                           //解密编码                           .addLast("decoder", adapter.getDecoder())                           .addLast("encoder", adapter.getEncoder())                           //设置心跳                           .addLast("client-idle-handler", new IdleStateHandler(heartbeatInterval, 0, 0, MILLISECONDS))                           //注册nettyClientHandler                           .addLast("handler", nettyClientHandler);                   //如果需要Socks5Proxy，需要添加Socks5ProxyHandler(略                   String socksProxyHost = ConfigUtils.getProperty(SOCKS_PROXY_HOST);                   if(socksProxyHost != null) {                       int socksProxyPort = Integer.parseInt(ConfigUtils.getProperty(SOCKS_PROXY_PORT, DEFAULT_SOCKS_PROXY_PORT));                       Socks5ProxyHandler socks5ProxyHandler = new Socks5ProxyHandler(new InetSocketAddress(socksProxyHost, socksProxyPort));                       ch.pipeline().addFirst(socks5ProxyHandler);                   }               }           });       }`

形成通信的通道的图也是类似: ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667518965373-7611659f-12e3-49bb-b7a1-b5a379774e0d.png#averageHue=%23f9e1ca&clientId=u710e5d91-1111-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=347&id=uc4c98f9e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=694&originWidth=1676&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82151&status=done&style=none&taskId=u12230e5f-dc93-48da-8fb0-39f4f02ee6f&title=&width=838) 对于NettyClientHandler实现整体上与NettyServerHandler的设计思路类似，这里就不进行介绍了， ![image.png](https://cdn.nlark.com/yuque/0/2022/png/452225/1667519305543-ef2de847-4bcc-403f-b1db-02d829d47736.png#averageHue=%23f5f5f5&clientId=u710e5d91-1111-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=359&id=u6b3882a7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=718&originWidth=1472&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83680&status=done&style=none&taskId=ud226f51a-1ddc-4976-9a88-56ae4cd26ee&title=&width=736)

###### NettyChannel

NettyChannel是对AbstractChannel一种实现，有四个字段，

    `//缓存Netty Channel 和 Dubbo Channel的对应关系       private static final ConcurrentMap<Channel, NettyChannel> CHANNEL_MAP = new ConcurrentHashMap<Channel, NettyChannel>();       //Netty Channel       private final Channel channel;       //Channnel附加的属性缓存       private final Map<String, Object> attributes = new ConcurrentHashMap<String, Object>();       //标识当前channel是否可用       private final AtomicBoolean active = new AtomicBoolean(false);       //炒作Channel也会操作缓存的内容       static NettyChannel getOrAddChannel(Channel ch, URL url, ChannelHandler handler) {           if (ch == null) {               return null;           }           NettyChannel ret = CHANNEL_MAP.get(ch);           if (ret == null) {               NettyChannel nettyChannel = new NettyChannel(ch, url, handler);               if (ch.isActive()) {                   nettyChannel.markActive(true);                   ret = CHANNEL_MAP.putIfAbsent(ch, nettyChannel);               }               if (ret == null) {                   ret = nettyChannel;               }           }           return ret;       }          /**        * Remove the inactive channel.        *        * @param ch netty channel        */       static void removeChannelIfDisconnected(Channel ch) {           if (ch != null && !ch.isActive()) {               NettyChannel nettyChannel = CHANNEL_MAP.remove(ch);               if (nettyChannel != null) {                   nettyChannel.markActive(false);               }           }       }`

接下来就是核心send方法的实现，此处会关联Netty Channel，将数据发送出去，此处就是子类具体的实现。

    `public void send(Object message, boolean sent) throws RemotingException {           //调用父类 判断连接是否可用           super.send(message, sent);              boolean success = true;           int timeout = 0;           try {               //netty channel 发送数据               ChannelFuture future = channel.writeAndFlush(message);               if (sent) {                   //等待发送结束                   timeout = getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);                   success = future.await(timeout);               }               //判断是否异常               Throwable cause = future.cause();               if (cause != null) {                   throw cause;               }           } catch (Throwable e) {               //异常断开netty连接 移除缓存关系               removeChannelIfDisconnected(channel);               throw new RemotingException(this, "Failed to send message " + PayloadDropper.getRequestWithoutData(message) + " to " + getRemoteAddress() + ", cause: " + e.getMessage(), e);           }           if (!success) {               throw new RemotingException(this, "Failed to send message " + PayloadDropper.getRequestWithoutData(message) + " to " + getRemoteAddress()                       + "in timeout(" + timeout + "ms) limit");           }       }`

### 未完待续

欢迎大家点点关注，点点赞! ![](https://img2018.cnblogs.com/blog/1005447/201906/1005447-20190620221533393-1847070636.png)