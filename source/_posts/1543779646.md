---
layout: post
title: ".Net Coreåç«¯æ¶æ„å®æˆ˜ã€2-å®ç°åŠ¨æ€è·¯ç”±ä¸Dynamic APIã€‘"
date: "2023-04-09T01:07:03.137Z"
---
.Net Coreåç«¯æ¶æ„å®æˆ˜ã€2-å®ç°åŠ¨æ€è·¯ç”±ä¸Dynamic APIã€‘
=====================================

> æ‘˜è¦ï¼šåŸºäº.NET Core 7.0WebApiåç«¯æ¶æ„å®æˆ˜ã€2-å®ç°åŠ¨æ€è·¯ç”±ä¸Dynamic APIã€‘Â Â 2023/02/22, ASP.NET Core 7.0, VS2022

å¼•è¨€
--

    ä½¿ç”¨è¿‡ABP vNextå’ŒFurionæ¡†æ¶çš„å¯èƒ½éƒ½ä¼šå¯¹å®ƒä»¬çš„åŠ¨æ€APIæ„Ÿåˆ°å¥½å¥‡ï¼Œä¸ç”¨æ‰‹åŠ¨çš„å»å®šä¹‰ï¼Œå®ƒä¼šåŠ¨æ€çš„å»åˆ›å»ºAPIæ§åˆ¶å™¨ã€‚åç«¯ä»£ç   
æ¶æ„çš„å¤æ‚åœ¨æ ¸å¿ƒä»£ç ï¼Œå¦‚æœè¿™äº›èƒ½å°è£…çš„å¥½æå‡çš„æ˜¯å°ç»„æ•´ä½“çš„ç”Ÿäº§åŠ›ã€‚çµå›¾å›¾ä¹¦çš„æ‰‰é¡µéƒ½ä¼šæœ‰è¿™æ ·ä¸€å¥è¯ï¼š"ç«™åœ¨å·¨äººçš„è‚©è†€ä¸Š"ã€‚æˆ‘åœ¨  
è¿™é‡Œå¤§è¨€ä¸æƒ­çš„è¯´ä¸Šä¸€å¥æˆ‘å¸Œæœ›æˆ‘ä¹Ÿèƒ½æˆä¸º"å·¨äºº"ï¼

åŠ¨æ€è·¯ç”±
----

> åœ¨.Net Core WebAPIç¨‹åºä¸­é€šè¿‡å¯å…¨å±€æˆ–å±€éƒ¨ä¿®æ”¹çš„è‡ªå®šä¹‰Routeå±æ€§å’ŒURLæ˜ å°„ç»„ä»¶åŒ¹é…ä¼ å…¥çš„HTTPè¯·æ±‚æ›¿ä»£é»˜è®¤è·¯ç”±å³ä¸ºåŠ¨æ€è·¯ç”±

### WebApplicationBuilder

åœ¨3.1ä»¥åŠ5.0çš„ç‰ˆæœ¬ä¸­ï¼ŒConfigureæ–¹æ³•ä¸­ä¼šè‡ªåŠ¨æ·»åŠ UseRouting()ä¸UseEndpoints()æ–¹æ³•ï¼Œä½†æ˜¯åœ¨6.0ä»¥ä¸Šç‰ˆæœ¬å·²ç»æ²¡æœ‰äº†ã€‚å…¶å®åœ¨åˆ›å»ºWebApplicationBuilderå®ä¾‹çš„æ—¶å€™é»˜è®¤å·²ç»æ·»åŠ è¿›å»äº†ã€‚è¯·çœ‹æºç ï¼š

    var builder = WebApplication.CreateBuilder(args);

WebApplication.csæ–‡ä»¶ä¸­

    /// <summary>
    /// Initializes a new instance of the class with preconfigured defaults.
    /// </summary>
    /// <param name="args">Command line arguments</param>
    /// <returns>The <see cref="WebApplicationBuilder"/>.</returns>
    public static WebApplicationBuilder CreateBuilder(string[] args) =>
        new(new WebApplicationOptions() { Args = args });

WebApplicationBuilder.csæ–‡ä»¶ä¸­ï¼ŒwebHostBuilder.Configure(ConfigureApplication)è¿™å¥ä»£ç ä»–å°†åŒ…å«æ³¨å†Œè·¯ç”±ä¸ç»ˆç»“ç‚¹çš„æ–¹æ³•æ·»åŠ åˆ°äº†å®¿ä¸»ç¨‹åºå¯åŠ¨çš„é…ç½®å½“ä¸­ã€‚

    internal WebApplicationBuilder(WebApplicationOptions options, Action? configureDefaults = null)
    {
        Services = _services;
        var args = options.Args;
        // Run methods to configure both generic and web host defaults early to populate config from appsettings.json
        // environment variables (both DOTNET_ and ASPNETCORE_ prefixed) and other possible default sources to prepopulate
        // the correct defaults.
        _bootstrapHostBuilder = new BootstrapHostBuilder(Services, _hostBuilder.Properties);
        // Don't specify the args here since we want to apply them later so that args
        // can override the defaults specified by ConfigureWebHostDefaults
        _bootstrapHostBuilder.ConfigureDefaults(args: null);
        // This is for testing purposes
        configureDefaults?.Invoke(_bootstrapHostBuilder);
        // We specify the command line here last since we skipped the one in the call to ConfigureDefaults.
        // The args can contain both host and application settings so we want to make sure
        // we order those configuration providers appropriately without duplicating them
        if (args is { Length: > 0 })
        {
            _bootstrapHostBuilder.ConfigureAppConfiguration(config =>
            {
                config.AddCommandLine(args);
            });
        }
        _bootstrapHostBuilder.ConfigureWebHostDefaults(webHostBuilder =>
        {
            // Runs inline.        //çœ‹è¿™é‡Œ
            webHostBuilder.Configure(ConfigureApplication);
            // Attempt to set the application name from options
            options.ApplyApplicationName(webHostBuilder);
        });
        // Apply the args to host configuration last since ConfigureWebHostDefaults overrides a host specific setting (the application n
        _bootstrapHostBuilder.ConfigureHostConfiguration(config =>
        {
            if (args is { Length: > 0 })
            {
                config.AddCommandLine(args);
            }
            // Apply the options after the args
            options.ApplyHostConfiguration(config);
        });
        Configuration = new();
        // This is chained as the first configuration source in Configuration so host config can be added later without overriding app c
        Configuration.AddConfiguration(_hostConfigurationManager);
        // Collect the hosted services separately since we want those to run after the user's hosted services
        _services.TrackHostedServices = true;
        // This is the application configuration
        var (hostContext, hostConfiguration) = _bootstrapHostBuilder.RunDefaultCallbacks(Configuration, _hostBuilder);
        // Stop tracking here
        _services.TrackHostedServices = false;
        // Capture the host configuration values here. We capture the values so that
        // changes to the host configuration have no effect on the final application. The
        // host configuration is immutable at this point.
        _hostConfigurationValues = new(hostConfiguration.AsEnumerable());
        // Grab the WebHostBuilderContext from the property bag to use in the ConfigureWebHostBuilder
        var webHostContext = (WebHostBuilderContext)hostContext.Properties[typeof(WebHostBuilderContext)];
        // Grab the IWebHostEnvironment from the webHostContext. This also matches the instance in the IServiceCollection.
        Environment = webHostContext.HostingEnvironment;
        Logging = new LoggingBuilder(Services);
        Host = new ConfigureHostBuilder(hostContext, Configuration, Services);
        WebHost = new ConfigureWebHostBuilder(webHostContext, Configuration, Services);
        Services.AddSingleton(_ => Configuration);
    }

    private void ConfigureApplication(WebHostBuilderContext context, IApplicationBuilder app)
    {
        Debug.Assert(_builtApplication is not null);
        // UseRouting called before WebApplication such as in a StartupFilter
        // lets remove the property and reset it at the end so we don't mess with the routes in the filter
        if (app.Properties.TryGetValue(EndpointRouteBuilderKey, out var priorRouteBuilder))
        {
            app.Properties.Remove(EndpointRouteBuilderKey);
        }
        if (context.HostingEnvironment.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        // Wrap the entire destination pipeline in UseRouting() and UseEndpoints(), essentially:
        // destination.UseRouting()
        // destination.Run(source)
        // destination.UseEndpoints()
        // Set the route builder so that UseRouting will use the WebApplication as the IEndpointRouteBuilder for route matching
        app.Properties.Add(WebApplication.GlobalEndpointRouteBuilderKey, _builtApplication);
        // Only call UseRouting() if there are endpoints configured and UseRouting() wasn't called on the global route builder already
        if (_builtApplication.DataSources.Count > 0)
        {
            // If this is set, someone called UseRouting() when a global route builder was already set
            if (!_builtApplication.Properties.TryGetValue(EndpointRouteBuilderKey, out var localRouteBuilder))
            {            //æ·»åŠ è·¯ç”±ä¸­é—´ä»¶
                app.UseRouting();
            }
            else
            {
                // UseEndpoints will be looking for the RouteBuilder so make sure it's set
                app.Properties[EndpointRouteBuilderKey] = localRouteBuilder;
            }
        }
        // Wire the source pipeline to run in the destination pipeline
        app.Use(next =>
        {
            _builtApplication.Run(next);
            return _builtApplication.BuildRequestDelegate();
        });
        if (_builtApplication.DataSources.Count > 0)
        {
            // We don't know if user code called UseEndpoints(), so we will call it just in case, UseEndpoints() will ignore duplicate DataSources        //æ·»åŠ ç»ˆç»“ç‚¹ä¸­é—´ä»¶
            app.UseEndpoints(_ => { });
        }
        // Copy the properties to the destination app builder
        foreach (var item in _builtApplication.Properties)
        {
            app.Properties[item.Key] = item.Value;
        }
        // Remove the route builder to clean up the properties, we're done adding routes to the pipeline
        app.Properties.Remove(WebApplication.GlobalEndpointRouteBuilderKey);
        // reset route builder if it existed, this is needed for StartupFilters
        if (priorRouteBuilder is not null)
        {
            app.Properties[EndpointRouteBuilderKey] = priorRouteBuilder;
        }
    }

WebHostBuilderExtensions.csæ–‡ä»¶ä¸­ï¼ŒConfigureæ–¹æ³•ç”¨äºåŠ å…¥é…ç½®é¡¹ï¼ŒGetWebHostBuilderContextæ–¹æ³•ç”¨äºè·å–å®¿ä¸»æœºæ„å»ºçš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå³å·²é…ç½®çš„ä¸»æœºä¿¡æ¯ã€‚

    public IWebHostBuilder Configure(Action<WebHostBuilderContext, IApplicationBuilder> configure)
    {
        var startupAssemblyName = configure.GetMethodInfo().DeclaringType!.Assembly.GetName().Name!;
        UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
        // Clear the startup type
        _startupObject = configure;
        _builder.ConfigureServices((context, services) =>
        {
            if (object.ReferenceEquals(_startupObject, configure))
            {
                services.Configure(options =>
                {
                    var webhostBuilderContext = GetWebHostBuilderContext(context);
                    options.ConfigureApplication = app => configure(webhostBuilderContext, app);
                });
            }
        });
        return this;
    }
    private static WebHostBuilderContext GetWebHostBuilderContext(HostBuilderContext context)
    {
        if (!context.Properties.TryGetValue(typeof(WebHostBuilderContext), out var contextVal))
        {
            var options = new WebHostOptions(context.Configuration, Assembly.GetEntryAssembly()?.GetName().Name ?? string.Empty);
            var webHostBuilderContext = new WebHostBuilderContext
            {
                Configuration = context.Configuration,
                HostingEnvironment = new HostingEnvironment(),
            };
            webHostBuilderContext.HostingEnvironment.Initialize(context.HostingEnvironment.ContentRootPath, options);
            context.Properties[typeof(WebHostBuilderContext)] = webHostBuilderContext;
            context.Properties[typeof(WebHostOptions)] = options;
            return webHostBuilderContext;
        }
        // Refresh config, it's periodically updated/replaced
        var webHostContext = (WebHostBuilderContext)contextVal;
        webHostContext.Configuration = context.Configuration;
        return webHostContext;
    }

### UseRouting

æºç å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![](https://img2023.cnblogs.com/blog/1677460/202302/1677460-20230226161354275-1190990747.png)

â‘ `erifyRoutingServicesAreRegistered`ç”¨äºéªŒè¯è·¯ç”±æœåŠ¡æ˜¯å¦å·²æ³¨å†Œåˆ°å®¹å™¨å†…éƒ¨

â‘¡åˆ¤æ–­åœ¨è¯·æ±‚ç®¡é“çš„å…±äº«æ•°æ®å­—å…¸çš„Propertiesä¸­æ˜¯å¦æœ‰`GlobalEndpointRouteBuilderKey`çš„é”®ï¼Œå¦‚æœæ²¡æœ‰åˆ™Newä¸€ä¸ªæ–°çš„ç»ˆç»“ç‚¹è·¯ç”±æ„å»ºè€…å¯¹è±¡ï¼Œå¹¶å°†`EndpointRouteBuilder`æ·»åŠ åˆ°å…±äº«å­—å…¸ä¸­ã€‚åé¢`UseEndpoints(Action<IEndpointRouteBuilder> configure)`æ‰§è¡Œæ—¶ï¼Œä¼šå°†å‰é¢Newçš„`DefaultEndpointRouteBuilder` å®ä¾‹å–å‡ºï¼Œå¹¶è¿›ä¸€æ­¥é…ç½®å®ƒï¼š `configure(EndpointRouteBuilderå®ä¾‹)`

â‘¢å°†`EndpointRoutingMiddleware`ä¸­é—´ä»¶æ³¨å†Œåˆ°ç®¡é“ä¸­ï¼Œè¯¥ä¸­é—´ä»¶æ ¹æ®è¯·æ±‚å’ŒUrlåŒ¹é…æœ€ä½³çš„Endpoint,ç„¶åå°†è¯¥ç»ˆç»“ç‚¹äº¤ç”±EndpointMiddleware å¤„ç†ã€‚

### UseEndpoints

æºç å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![](https://img2023.cnblogs.com/blog/1677460/202302/1677460-20230226171041740-96340366.png)

Â â‘ `VerifyEndpointRoutingMiddlewareIsRegistered`æ–¹æ³•å°†`EndpointRouteBuilder`ä»è¯·æ±‚ç®¡é“çš„å…±äº«å­—å…¸ä¸­å–å‡ºï¼Œå¦‚æœæ²¡æœ‰åˆ™è¯´æ˜ä¹‹å‰æ²¡æœ‰è°ƒç”¨`UseRouting()`ï¼Œæ‰€ä»¥è°ƒç”¨`UseEndpoints()`ä¹‹å‰è¦å…ˆè°ƒç”¨`UseRouting()`ï¼Œ`VerifyEndpointRoutingMiddlewareIsRegistered`æ–¹æ³•å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![](https://img2023.cnblogs.com/blog/1677460/202302/1677460-20230226172406893-1450022518.png)

â‘¡`EndpointMiddleware`ä¸»è¦æ˜¯åœ¨`EndpointRoutingMiddleware`ç­›é€‰å‡º`endpoint`ä¹‹åï¼Œè°ƒç”¨è¯¥`endpoint`çš„`endpoint.RequestDelegate(httpContext)`è¿›è¡Œè¯·æ±‚å¤„ç†ã€‚å¹¶ä¸”è¿™ä¸ªä¸­é—´ä»¶ä¼šæœ€ç»ˆæ‰§è¡ŒRequestDelegateå§”æ‰˜æ¥å¤„ç†è¯·æ±‚ã€‚è¯·æ±‚çš„å¤„ç†å¤§éƒ¨åˆ†åŠŸèƒ½åœ¨ä¸­é—´ä»¶`EndpointRoutingMiddleware`ä¸­ï¼Œå®ƒæœ‰ä¸ªé‡è¦çš„å±æ€§`_endpointDataSource`ä¿å­˜äº†ä¸Šæ–‡ä¸­åˆå§‹åŒ–é˜¶æ®µç”Ÿæˆçš„`MvcEndpointDataSource`ï¼Œè€Œä¸­é—´ä»¶`EndpointMiddleware`çš„åŠŸèƒ½æ¯”è¾ƒç®€å•ï¼Œä¸»è¦æ˜¯åœ¨`EndpointRoutingMiddleware`ç­›é€‰å‡º`endpoint`ä¹‹åï¼Œè°ƒç”¨è¯¥`endpoint.RequestDelegate(httpContext)`æ–¹æ³•è¿›è¡Œè¯·æ±‚å¤„ç†ã€‚

çœ‹ä¸€ä¸‹Endpointç±»æºç ï¼ŒEndpointå°±æ˜¯å®šä¹‰è°(Action)æ¥æ‰§è¡Œè¯·æ±‚çš„å¯¹è±¡

    public class Endpoint
    {
        ///<summary>
        /// Creates a new instance of.
        ///</summary>
        ///<param name="requestDelegate">The delegate used to process requests for the endpoint.</param>
        ///<param name="metadata">
        /// The endpoint <see cref="EndpointMetadataCollection"/>. May be null.
        ///</param>
        ///<param name="displayName">
        /// The informational display name of the endpoint. May be null.    /// </param>
        public Endpoint(
            RequestDelegate? requestDelegate,
            EndpointMetadataCollection? metadata,
            string? displayName)
        {
            // All are allowed to be null
            RequestDelegate = requestDelegate;
            Metadata = metadata ?? EndpointMetadataCollection.Empty;
            DisplayName = displayName;
        }
        /// <summary>
        /// Gets the informational display name of this endpoint.
        /// </summary>
        public string? DisplayName { get; }
        /// <summary>
        /// Gets the collection of metadata associated with this endpoint.
        /// 
        public EndpointMetadataCollection Metadata { get; }
        /// <summary>
        /// Gets the delegate used to process requests for the endpoint.
        /// </summary>
        public RequestDelegate? RequestDelegate { get; }
        /// <summary>
        /// Returns a string representation of the endpoint.
        /// </summary>
        public override string? ToString() => DisplayName ?? base.ToString();
    }
    

`Metadata`éå¸¸é‡è¦ï¼Œæ˜¯å­˜æ”¾æ§åˆ¶å™¨è¿˜æœ‰Actionçš„å…ƒæ•°æ®ï¼Œåœ¨åº”ç”¨ç¨‹åºå¯åŠ¨çš„æ—¶å€™å°±å°†æ§åˆ¶å™¨å’ŒActionçš„å…³é”®ä¿¡æ¯ç»™å­˜å…¥ï¼Œä¾‹å¦‚è·¯ç”±ã€ç‰¹æ€§ã€HttpMethodç­‰

`RequestDelegate`Â ç”¨äºå°†è¯·æ±‚(HttpContext)äº¤ç»™èµ„æº(Action)æ‰§è¡Œ

### AddControllers

æˆ‘ä»¬æ¥çœ‹ä¸‹`AddControllers()`å’Œ`AddMvcCore()`åŠç›¸å…³è”çš„æºç 

`MvcServiceCollectionExtensions`æ–‡ä»¶ä¸­ï¼Œ`AddControllersCore`æ–¹æ³•ç”¨äºæ·»åŠ æ§åˆ¶å™¨çš„æ ¸å¿ƒæœåŠ¡ï¼Œå®ƒæœ€ä¸»è¦çš„ä½œç”¨æ˜¯ä¸»è¦ä½œç”¨å°±æ˜¯æ‰«ææ‰€æœ‰çš„æœ‰å…³ç¨‹åºé›†å°è£…æˆApplicationPartã€‚

    public static class MvcServiceCollectionExtensions
    {
        /// <summary>
        /// Adds services for controllers to the specified. This method will not
        /// register services used for views or pages.
        /// </summary>
        ///<param name="services">The <see cref="IServiceCollection" /> to add services to.</param>
        /// <returns>An <see cref="IMvcBuilder"/> that can be used to further configure the MVC services.</returns>
        /// <remarks>
        /// <para>
        /// This method configures the MVC services for the commonly used features with controllers for an API. This
        /// combines the effects of <see cref="MvcCoreServiceCollectionExtensions.AddMvcCore(IServiceCollection)"/>,
        /// <see cref="MvcApiExplorerMvcCoreBuilderExtensions.AddApiExplorer(IMvcCoreBuilder)"/>,
        /// <see cref="MvcCoreMvcCoreBuilderExtensions.AddAuthorization(IMvcCoreBuilder)"/>,
        /// <see cref="MvcCorsMvcCoreBuilderExtensions.AddCors(IMvcCoreBuilder)"/>,
        /// <see cref="MvcDataAnnotationsMvcCoreBuilderExtensions.AddDataAnnotations(IMvcCoreBuilder)"/>,
        /// and <see cref="MvcCoreMvcCoreBuilderExtensions.AddFormatterMappings(IMvcCoreBuilder)"/>.    /// </para>
        /// <para>
        /// To add services for controllers with views call <see cref="AddControllersWithViews(IServiceCollection)"/>
        /// on the resulting builder.    /// </para>
        /// <para>
        /// To add services for pages call <see cref="AddRazorPages(IServiceCollection)"/>
        /// on the resulting builder.
        /// on the resulting builder.
        /// </remarks>
        public static IMvcBuilder AddControllers(this IServiceCollection services)
        {
            if (services == null)
            {
                throw new ArgumentNullException(nameof(services));
            }
    
            //æ·»åŠ Controllersæ ¸å¿ƒæœåŠ¡
            var builder = AddControllersCore(services);
            return new MvcBuilder(builder.Services, builder.PartManager);
        }
    
        private static IMvcCoreBuilder AddControllersCore(IServiceCollection services)
        {
            // This method excludes all of the view-related services by default.
            var builder = services
                .AddMvcCore()//è¿™ä¸ªæ˜¯æ ¸å¿ƒï¼Œè¿”å›IMvcCoreBuilderå¯¹è±¡ï¼Œå…¶åçš„æœåŠ¡å¼•å…¥éƒ½æ˜¯åŸºäºå®ƒçš„
                .AddApiExplorer()
                .AddAuthorization()
                .AddCors()
                .AddDataAnnotations()
                .AddFormatterMappings();
    
            if (MetadataUpdater.IsSupported)
            {
                services.TryAddEnumerable(
                    ServiceDescriptor.Singleton<IActionDescriptorChangeProvider, HotReloadService>());
            }
    
            return builder;
        }
    }
    
    

`AddMvcCore`æ–¹æ³•ç”¨äºæ·»åŠ MVCçš„æ ¸å¿ƒæœåŠ¡ï¼Œä¸‹é¢çš„GetApplicationPartManageræ–¹æ³•å…ˆè·å–ApplicationPartManagerå¯¹è±¡ï¼Œç„¶åå°†å½“å‰ç¨‹åºé›†å°è£…æˆäº†ApplicationPartæ”¾è¿›ApplicationPartsé›†åˆä¸­ã€‚  
`ConfigureDefaultFeatureProviders(partManager)`ä¸»è¦ä½œç”¨æ˜¯åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ControllerFeatureProviderå®ä¾‹æ”¾è¿›äº†partManagerçš„FeatureProviderså±æ€§ä¸­ï¼Œæ³¨æ„è¿™ä¸ªControllerFeatureProviderå¯¹è±¡åœ¨åé¢éå†ApplicationPartçš„æ—¶å€™è´Ÿè´£æ‰¾å‡ºé‡Œé¢çš„Controllerã€‚  
`AddMvcCore()`æ–¹æ³•å…¶åæ˜¯æ·»åŠ RoutingæœåŠ¡å†æ¥ç€æ·»åŠ Mvcæ ¸å¿ƒæœåŠ¡ç„¶åæ„å»ºä¸€ä¸ªMvcCoreBuilderå®ä¾‹å¹¶è¿”å›

    
    ///<summary>
    /// Extension methods for setting up essential MVC services in an.
    ///</summary>
    public static class MvcCoreServiceCollectionExtensions
    {
        ///<summary>
        /// Adds the minimum essential MVC services to the specified 
        /// <see cref="IServiceCollection" />. Additional services
        /// including MVC's support for authorization, formatters, and validation must be added separatelyÂ 
        /// using the <see cref="IMvcCoreBuilder"/> returned from this method.
        ///</summary>
        ///<param name="services">The <see cref="IServiceCollection" /> to add services to.</param>
        /// <returns>
        /// An <see cref="IMvcCoreBuilder"/> that can be used to further configure the MVC services.
        /// </returns>
        /// <remarks>
        /// The <see cref="MvcCoreServiceCollectionExtensions.AddMvcCore(IServiceCollection)"/>Â 
        /// approach for configuring
        /// MVC is provided for experienced MVC developers who wish to have full control over the 
        /// set of default services
        /// registered. <see cref="MvcCoreServiceCollectionExtensions.AddMvcCore(IServiceCollection)"/>Â 
        /// will register
        /// the minimum set of services necessary to route requests and invoke controllers. 
        /// It is not expected that any
        /// application will satisfy its requirements with just a call to
        /// <see cref="MvcCoreServiceCollectionExtensions.AddMvcCore(IServiceCollection)"/>
        /// . Additional configuration using the
        /// <see cref="IMvcCoreBuilder"/> will be required.
        /// </remarks>
        public static IMvcCoreBuilder AddMvcCore(this IServiceCollection services)
        {
            if (services == null)
            {
                throw new ArgumentNullException(nameof(services));
            }
            //è·å–æ³¨å…¥çš„IWebHostEnvironmentç¯å¢ƒå¯¹è±¡
            var environment = GetServiceFromCollection(services);
            //è·å–ç¨‹åºä¸­æ‰€æœ‰å…³è”çš„ç¨‹åºé›†çš„ApplicationPartManager
            var partManager = GetApplicationPartManager(services, environment);
            services.TryAddSingleton(partManager);
            //ç»™ApplicationPartManageræ·»åŠ ControllerFeature
            ConfigureDefaultFeatureProviders(partManager);
            //è°ƒç”¨services.AddRouting();
            ConfigureDefaultServices(services);
            //æ·»åŠ MVCç›¸å…³è”çš„æœåŠ¡è‡³IOCå®¹å™¨ä¸­
            AddMvcCoreServices(services);
            var builder = new MvcCoreBuilder(services, partManager);
            return builder;
    
        }
    
        private static ApplicationPartManager GetApplicationPartManager(IServiceCollection services, IWebHostEnvironment? environment)
        {
            var manager = GetServiceFromCollection(services);
            if (manager == null)
            {
                manager = new ApplicationPartManager();
                //è·å–å½“å‰ä¸»ç¨‹åºé›†çš„åç§°
                var entryAssemblyName = environment?.ApplicationName;
                if (string.IsNullOrEmpty(entryAssemblyName))
                {
                    return manager;
                }
                //æ‰¾å‡ºæ‰€æœ‰å¼•ç”¨çš„ç¨‹åºé›†å¹¶å°†ä»–ä»¬æ·»åŠ åˆ°ApplicationPartsä¸­
                manager.PopulateDefaultParts(entryAssemblyName);
            }
    
            return manager;
        }
    
        private static void ConfigureDefaultFeatureProviders(ApplicationPartManager manager)
        {
            if (!manager.FeatureProviders.OfType().Any())
            {
                manager.FeatureProviders.Add(new ControllerFeatureProvider());
            }
        }
    
        private static void ConfigureDefaultServices(IServiceCollection services)
        {
            services.AddRouting();
        }
    
        internal static void AddMvcCoreServices(IServiceCollection services)
        {
            //
            // Options
            //
            services.TryAddEnumerable(
                ServiceDescriptor.Transient<IConfigureOptions, MvcCoreMvcOptionsSetup>());
            services.TryAddEnumerable(
                ServiceDescriptor.Transient<IPostConfigureOptions, MvcCoreMvcOptionsSetup>());
            services.TryAddEnumerable(
                ServiceDescriptor.Transient<IConfigureOptions, ApiBehaviorOptionsSetup>());
            services.TryAddEnumerable(
                ServiceDescriptor.Transient<IConfigureOptions, MvcCoreRouteOptionsSetup>());
    
            //
            // Action Discovery
            //
            // These are consumed only when creating action descriptors, then they can be deallocated
            services.TryAddSingleton();
            services.TryAddEnumerable(
                ServiceDescriptor.Transient<IApplicationModelProvider, DefaultApplicationModelProvider>());
            services.TryAddEnumerable(
                ServiceDescriptor.Transient<IApplicationModelProvider, ApiBehaviorApplicationModelProvider>());
            services.TryAddEnumerable(
                ServiceDescriptor.Transient<IActionDescriptorProvider, ControllerActionDescriptorProvider>());
    
            services.TryAddSingleton<IActionDescriptorCollectionProvider, DefaultActionDescriptorCollectionProvider>();
    
            //
            // Action Selection
            //
            services.TryAddSingleton<IActionSelector, ActionSelector>();
            services.TryAddSingleton();
    
            // Will be cached by the DefaultActionSelector
            services.TryAddEnumerable(ServiceDescriptor.Transient<IActionConstraintProvider, DefaultActionConstraintProvider>());
    
            // Policies for Endpoints
            services.TryAddEnumerable(ServiceDescriptor.Singleton<MatcherPolicy, ActionConstraintMatcherPolicy>());
    
            //
            // Controller Factory
            //
            // This has a cache, so it needs to be a singleton
            services.TryAddSingleton<IControllerFactory, DefaultControllerFactory>();
    
            // Will be cached by the DefaultControllerFactory
            services.TryAddTransient<IControllerActivator, DefaultControllerActivator>();
    
            services.TryAddSingleton<IControllerFactoryProvider, ControllerFactoryProvider>();
            services.TryAddSingleton<IControllerActivatorProvider, ControllerActivatorProvider>();
            services.TryAddEnumerable(
                ServiceDescriptor.Transient<IControllerPropertyActivator, DefaultControllerPropertyActivator>());
    
            //
            // Action Invoker
            //
            // The IActionInvokerFactory is cachable
            services.TryAddSingleton<IActionInvokerFactory, ActionInvokerFactory>();
            services.TryAddEnumerable(
                ServiceDescriptor.Transient<IActionInvokerProvider, ControllerActionInvokerProvider>());
    
            // These are stateless
            services.TryAddSingleton();
            services.TryAddEnumerable(
                ServiceDescriptor.Singleton<IFilterProvider, DefaultFilterProvider>());
            services.TryAddSingleton<IActionResultTypeMapper, ActionResultTypeMapper>();
    
            //
            // Request body limit filters
            //
            services.TryAddTransient();
            services.TryAddTransient();
            services.TryAddTransient();
    
            //
            // ModelBinding, Validation
            //
            // The DefaultModelMetadataProvider does significant caching and should be a singleton.
            services.TryAddSingleton<IModelMetadataProvider, DefaultModelMetadataProvider>();
            services.TryAdd(ServiceDescriptor.Transient(s =>
            {
                var options = s.GetRequiredService<IOptions>().Value;
                return new DefaultCompositeMetadataDetailsProvider(options.ModelMetadataDetailsProviders);
            }));
            services.TryAddSingleton<IModelBinderFactory, ModelBinderFactory>();
            services.TryAddSingleton(s =>
            {
                var options = s.GetRequiredService<IOptions>().Value;
                var metadataProvider = s.GetRequiredService();
                return new DefaultObjectValidator(metadataProvider, options.ModelValidatorProviders, options);
            });
            services.TryAddSingleton();
            services.TryAddSingleton();
    
            //
            // Random Infrastructure
            //
            services.TryAddSingleton<MvcMarkerService, MvcMarkerService>();
            services.TryAddSingleton<ITypeActivatorCache, TypeActivatorCache>();
            services.TryAddSingleton<IUrlHelperFactory, UrlHelperFactory>();
            services.TryAddSingleton<IHttpRequestStreamReaderFactory, MemoryPoolHttpRequestStreamReaderFactory>();
            services.TryAddSingleton<IHttpResponseStreamWriterFactory, MemoryPoolHttpResponseStreamWriterFactory>();
            services.TryAddSingleton(ArrayPool.Shared);
            services.TryAddSingleton(ArrayPool.Shared);
            services.TryAddSingleton<OutputFormatterSelector, DefaultOutputFormatterSelector>();
            services.TryAddSingleton<IActionResultExecutor, ObjectResultExecutor>();
            services.TryAddSingleton<IActionResultExecutor, PhysicalFileResultExecutor>();
            services.TryAddSingleton<IActionResultExecutor, VirtualFileResultExecutor>();
            services.TryAddSingleton<IActionResultExecutor, FileStreamResultExecutor>();
            services.TryAddSingleton<IActionResultExecutor, FileContentResultExecutor>();
            services.TryAddSingleton<IActionResultExecutor, RedirectResultExecutor>();
            services.TryAddSingleton<IActionResultExecutor, LocalRedirectResultExecutor>();
            services.TryAddSingleton<IActionResultExecutor, RedirectToActionResultExecutor>();
            services.TryAddSingleton<IActionResultExecutor, RedirectToRouteResultExecutor>();
            services.TryAddSingleton<IActionResultExecutor, RedirectToPageResultExecutor>();
            services.TryAddSingleton<IActionResultExecutor, ContentResultExecutor>();
            services.TryAddSingleton<IActionResultExecutor, SystemTextJsonResultExecutor>();
            services.TryAddSingleton<IClientErrorFactory, ProblemDetailsClientErrorFactory>();
            services.TryAddSingleton<ProblemDetailsFactory, DefaultProblemDetailsFactory>();
    
            //
            // Route Handlers
            //
            services.TryAddSingleton(); // Only one per app
            services.TryAddTransient(); // Many per app
    
            //
            // Endpoint Routing / Endpoints
            //
            services.TryAddSingleton();
            services.TryAddSingleton();
            services.TryAddSingleton();
            services.TryAddSingleton();
            services.TryAddSingleton();
            services.TryAddEnumerable(ServiceDescriptor.Singleton<MatcherPolicy, DynamicControllerEndpointMatcherPolicy>());
            services.TryAddEnumerable(ServiceDescriptor.Singleton<IRequestDelegateFactory, ControllerRequestDelegateFactory>());
    
            //
            // Middleware pipeline filter related
            //
            services.TryAddSingleton();
            // This maintains a cache of middleware pipelines, so it needs to be a singleton
            services.TryAddSingleton();
            // Sets ApplicationBuilder on MiddlewareFilterBuilder
            services.TryAddEnumerable(ServiceDescriptor.Singleton<IStartupFilter, MiddlewareFilterBuilderStartupFilter>());
        }
    }

ä¸‹é¢çš„`PopulateDefaultParts()`æ–¹æ³•ä»å½“å‰ç¨‹åºé›†æ‰¾åˆ°æ‰€æœ‰å¼•ç”¨åˆ°äº†çš„ç¨‹åºé›†ï¼ˆåŒ…æ‹¬\[assembly:ApplicationPart(â€œdemoâ€)\]ä¸­æ ‡è®°çš„ï¼‰æŠŠä»–ä»¬å°è£…æˆApplciationPartï¼Œç„¶åæŠŠä»–ä»¬æ”¾åœ¨äº†ApplciationPartManagerçš„ApplicationPartså±æ€§ä¸­ï¼Œç”¨äºåé¢ç­›é€‰Controlleræä¾›æ•°æ®åŸºç¡€ã€‚

    
    namespace Microsoft.AspNetCore.Mvc.ApplicationParts
    {
        /// 
        /// Manages the parts and features of an MVC application.
        /// 
        public class ApplicationPartManager
        {
    
            /// 
            /// Gets the list of  instances.
            /// 
            /// Instances in this collection are stored in precedence order. An  that appears
            /// earlier in the list has a higher precedence.
            /// An  may choose to use this an interface as a way to resolve conflicts when
            /// multiple  instances resolve equivalent feature values.
            /// 
            /// 
            public IList ApplicationParts { get; } = new List();
    
            internal void PopulateDefaultParts(string entryAssemblyName)
            {
                //è·å–ç›¸å…³è”çš„ç¨‹åºé›†
                var assemblies = GetApplicationPartAssemblies(entryAssemblyName);
    
                var seenAssemblies = new HashSet();
    
                foreach (var assembly in assemblies)
                {
                    if (!seenAssemblies.Add(assembly))
                    {
                        // "assemblies" may contain duplicate values, but we want unique ApplicationPart instances.
                        // Note that we prefer using a HashSet over Distinct since the latter isn't
                        // guaranteed to preserve the original ordering.
                        continue;
                    }
    
                    var partFactory = ApplicationPartFactory.GetApplicationPartFactory(assembly);
                    foreach (var applicationPart in partFactory.GetApplicationParts(assembly))
                    {
                        ApplicationParts.Add(applicationPart);
                    }
                }
            }
    
            private static IEnumerable GetApplicationPartAssemblies(string entryAssemblyName)
            {
                //åŠ è½½å½“å‰ä¸»ç¨‹åºé›†
                var entryAssembly = Assembly.Load(new AssemblyName(entryAssemblyName));
    
                // Use ApplicationPartAttribute to get the closure of direct or transitive dependencies
                // that reference MVC.
                var assembliesFromAttributes = entryAssembly.GetCustomAttributes()
                    .Select(name => Assembly.Load(name.AssemblyName))
                    .OrderBy(assembly => assembly.FullName, StringComparer.Ordinal)
                    .SelectMany(GetAssemblyClosure);
    
                // The SDK will not include the entry assembly as an application part. We'll explicitly list it
                // and have it appear before all other assemblies \ ApplicationParts.
                return GetAssemblyClosure(entryAssembly)
                    .Concat(assembliesFromAttributes);
            }
    
            private static IEnumerable GetAssemblyClosure(Assembly assembly)
            {
                yield return assembly;
    
                var relatedAssemblies = RelatedAssemblyAttribute.GetRelatedAssemblies(assembly, throwOnError: false)
                    .OrderBy(assembly => assembly.FullName, StringComparer.Ordinal);
    
                foreach (var relatedAssembly in relatedAssemblies)
                {
                    yield return relatedAssembly;
                }
            }
        }
    }
    

### MapControllers

æˆ‘ä»¬æ¥ä¸‹æ¥çœ‹ä¸‹Controlleré‡Œçš„Actionæ˜¯æ€æ ·æ³¨å†Œåˆ°è·¯ç”±æ¨¡å—çš„ã€‚MapControllers()æ–¹æ³•æ‰§è¡Œæ—¶å°±ä¼šéå†éå†å·²ç»æ”¶é›†åˆ°çš„ApplicationPartè¿›è€Œå°†å…¶ä¸­Controlleré‡Œé¢çš„`Action`æ–¹æ³•è½¬æ¢å°è£…æˆä¸€ä¸ªä¸ªçš„EndPointæ”¾åˆ°è·¯ç”±ä¸­é—´ä»¶çš„é…ç½®å¯¹è±¡RouteOptionsä¸­ç„¶åäº¤ç»™Routingæ¨¡å—å¤„ç†ã€‚è¿˜æœ‰ä¸€ä¸ªé‡è¦ä½œç”¨æ˜¯å°†EndpointMiddlewareä¸­é—´ä»¶æ³¨å†Œåˆ°httpç®¡é“ä¸­ã€‚EndpointMiddlewareçš„ä¸€å¤§æ ¸å¿ƒä»£ç ä¸»è¦æ˜¯æ‰§è¡Œ`Endpoint`Â çš„`RequestDelegate`Â å§”æ‰˜ï¼Œä¹Ÿå³å¯¹`Controller`Â ä¸­çš„`Action`Â çš„æ‰§è¡Œã€‚æ‰€æœ‰çš„Httpè¯·æ±‚éƒ½ä¼šèµ°åˆ°EndpointMiddlewareä¸­é—´ä»¶ä¸­ï¼Œç„¶åå»æ‰§è¡Œå¯¹åº”çš„Actionã€‚åœ¨åº”ç”¨ç¨‹åºå¯åŠ¨çš„æ—¶å€™ä¼šæŠŠæˆ‘ä»¬çš„æ‰€æœ‰çš„è·¯ç”±ä¿¡æ¯æ·»åŠ åˆ°ä¸€ä¸ªEndpointSourceçš„é›†åˆä¸­å»çš„ï¼Œæ‰€ä»¥åœ¨MapControlleræ–¹æ³•ï¼Œå…¶å®å°±æ˜¯åœ¨æ„å»ºæˆ‘ä»¬æ‰€æœ‰çš„è·¯ç”±è¯·æ±‚çš„ä¸€ä¸ªRequestDelegateï¼Œç„¶ååœ¨æ¯æ¬¡è¯·æ±‚çš„æ—¶å€™ï¼Œåœ¨EndpointMiddleWareä¸­é—´ä»¶å»æ‰§è¡Œè¿™ä¸ªRequestDelegateï¼Œä»è€Œèµ°åˆ°æˆ‘ä»¬çš„æ¥å£ä¸­å»ã€‚ç®€è€Œè¨€ä¹‹ï¼Œè¿™ä¸ªæ–¹æ³•å°±æ˜¯å°†æˆ‘ä»¬çš„æ‰€æœ‰è·¯ç”±ä¿¡æ¯æ·»åŠ åˆ°ä¸€ä¸ªEndpointDataSourceçš„æŠ½è±¡ç±»çš„å®ç°ç±»ä¸­å»ï¼Œé»˜è®¤æ˜¯ControllerActionEndpointDataSourceè¿™ä¸ªç±»ï¼Œåœ¨è¿™ä¸ªç±»ä¸­æœ‰ä¸€ä¸ªåŸºç±»ActionEndpointDataSourceBaseï¼ŒControllerActionEndpointDataSourceåˆå§‹åŒ–çš„æ—¶å€™ä¼šè®¢é˜…æ‰€æœ‰çš„Endpointçš„é›†åˆçš„å˜åŒ–ï¼Œæ¯å˜åŒ–ä¸€æ¬¡ä¼šå‘EndpointSourceé›†åˆæ·»åŠ Endpointï¼Œä»è€Œåœ¨è¯·æ±‚çš„æ—¶å€™å¯ä»¥æ‰¾åˆ°è¿™ä¸ªç»ˆç»“ç‚¹å»è°ƒç”¨ã€‚

æˆ‘ä»¬æ¥çœ‹ä¸‹`MapControllers()`çš„æºç 

    public static class ControllerEndpointRouteBuilderExtensions
    {
        ///
        /// Adds endpoints for controller actions to the without specifying any routes.
        ///
        ///The .
        /// An  for endpoints associated with controller actions.
        public static ControllerActionEndpointConventionBuilder MapControllers(this IEndpointRouteBuilder endpoints)
        {
            if (endpoints == null)
            {
                throw new ArgumentNullException(nameof(endpoints));
            }
    
            EnsureControllerServices(endpoints);
    
            return GetOrCreateDataSource(endpoints).DefaultBuilder;
        }
    
        private static void EnsureControllerServices(IEndpointRouteBuilder endpoints)
        {
            var marker = endpoints.ServiceProvider.GetService();
            if (marker == null)
            {
                throw new InvalidOperationException(Resources.FormatUnableToFindServices(
                    nameof(IServiceCollection),
                    "AddControllers",
                    "ConfigureServices(...)"));
            }
        }
    
        private static ControllerActionEndpointDataSource GetOrCreateDataSource(IEndpointRouteBuilder endpoints)
        {
            var dataSource = endpoints.DataSources.OfType().FirstOrDefault();
            if (dataSource == null)
            {
                var orderProvider = endpoints.ServiceProvider.GetRequiredService();
                var factory = endpoints.ServiceProvider.GetRequiredService();
                dataSource = factory.Create(orderProvider.GetOrCreateOrderedEndpointsSequenceProvider(endpoints));
                endpoints.DataSources.Add(dataSource);
            }
    
            return dataSource;
        }
    }
    
    

é¦–å…ˆ`EnsureControllerServices`æ–¹æ³•æ£€æŸ¥mvcæœåŠ¡æ˜¯å¦æ³¨å…¥äº†ï¼Œ`GetOrCreateDataSource`æ–¹æ³•æ‰§è¡Œå®Œå°±è·å–åˆ°äº†dateSource,dateSourceä¸­å°±æ˜¯æ‰€æœ‰çš„Actionä¿¡æ¯ã€‚éœ€è¦æ³¨æ„çš„æ˜¯`ControllerActionEndpointDataSource`è¿™ä¸ªç±»ï¼Œå®ƒé‡Œé¢çš„æ–¹æ³•å¸®æˆ‘ä»¬åˆ›å»ºè·¯ç”±ç»ˆç»“ç‚¹ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å®ƒçš„å®šä¹‰ï¼š

    internal class ControllerActionEndpointDataSource : ActionEndpointDataSourceBase
    {
        private readonly ActionEndpointFactory _endpointFactory;
        private readonly OrderedEndpointsSequenceProvider _orderSequence;
        private readonly List _routes;
    
        public ControllerActionEndpointDataSource(
            ControllerActionEndpointDataSourceIdProvider dataSourceIdProvider,
            IActionDescriptorCollectionProvider actions,
            ActionEndpointFactory endpointFactory,
            OrderedEndpointsSequenceProvider orderSequence)
            : base(actions)
        {
            _endpointFactory = endpointFactory;
    
            DataSourceId = dataSourceIdProvider.CreateId();
            _orderSequence = orderSequence;
    
            _routes = new List();
    
            DefaultBuilder = new ControllerActionEndpointConventionBuilder(Lock, Conventions);
    
            // IMPORTANT: this needs to be the last thing we do in the constructor.
            // Change notifications can happen immediately!
            Subscribe();
        }
    
        public int DataSourceId { get; }
    
        public ControllerActionEndpointConventionBuilder DefaultBuilder { get; }
    
        // Used to control whether we create 'inert' (non-routable) endpoints for use in dynamic
        // selection. Set to true by builder methods that do dynamic/fallback selection.
        public bool CreateInertEndpoints { get; set; }
    
        public ControllerActionEndpointConventionBuilder AddRoute(
            string routeName,
            string pattern,
            RouteValueDictionary? defaults,
            IDictionary<string, object?>? constraints,
            RouteValueDictionary? dataTokens)
        {
            lock (Lock)
            {
                var conventions = new List<Action>();
                _routes.Add(new ConventionalRouteEntry(routeName, pattern, defaults, constraints, dataTokens, _orderSequence.GetNext(), conventions));
                return new ControllerActionEndpointConventionBuilder(Lock, conventions);
            }
        }
    
        protected override List CreateEndpoints(IReadOnlyList actions, IReadOnlyList<Action> conventions)
        {
            var endpoints = new List();
            var keys = new HashSet(StringComparer.OrdinalIgnoreCase);
    
            // MVC guarantees that when two of it's endpoints have the same route name they are equivalent.
            //
            // However, Endpoint Routing requires Endpoint Names to be unique.
            var routeNames = new HashSet(StringComparer.OrdinalIgnoreCase);
    
            // For each controller action - add the relevant endpoints.
            //
            // 1. If the action is attribute routed, we use that information verbatim
            // 2. If the action is conventional routed
            //      a. Create a *matching only* endpoint for each action X route (if possible)
            //      b. Ignore link generation for now
            for (var i = 0; i < actions.Count; i++)
            {
                if (actions[i] is ControllerActionDescriptor action)
                {
                    _endpointFactory.AddEndpoints(endpoints, routeNames, action, _routes, conventions, CreateInertEndpoints);
    
                    if (_routes.Count > 0)
                    {
                        // If we have conventional routes, keep track of the keys so we can create
                        // the link generation routes later.
                        foreach (var kvp in action.RouteValues)
                        {
                            keys.Add(kvp.Key);
                        }
                    }
                }
            }
    
            // Now create a *link generation only* endpoint for each route. This gives us a very
            // compatible experience to previous versions.
            for (var i = 0; i < _routes.Count; i++)
            {
                var route = _routes[i];
                _endpointFactory.AddConventionalLinkGenerationRoute(endpoints, routeNames, keys, route, conventions);
            }
    
            return endpoints;
        }
    
        internal void AddDynamicControllerEndpoint(IEndpointRouteBuilder endpoints, string pattern, Type transformerType, object? state, int? order = null)
        {
            CreateInertEndpoints = true;
            lock (Lock)
            {
                order ??= _orderSequence.GetNext();
    
                endpoints.Map(
                    pattern,
                    context =>
                    {
                        throw new InvalidOperationException("This endpoint is not expected to be executed directly.");
                    })
                    .Add(b =>
                    {
                        ((RouteEndpointBuilder)b).Order = order.Value;
                        b.Metadata.Add(new DynamicControllerRouteValueTransformerMetadata(transformerType, state));
                        b.Metadata.Add(new ControllerEndpointDataSourceIdMetadata(DataSourceId));
                    });
            }
        }
    }
    

åœ¨`CreateEndpoints`æ–¹æ³•ä¸­ä¼šéå†æ¯ä¸ª`ActionDescriptor`å¯¹è±¡ï¼Œ`ActionDescriptor`å¯¹è±¡é‡Œé¢å­˜å‚¨çš„æ˜¯Actionæ–¹æ³•çš„å…ƒæ•°æ®ã€‚ç„¶ååˆ›å»ºä¸€ä¸ªä¸ªçš„Endpointå®ä¾‹ï¼ŒEndpointå¯¹è±¡é‡Œé¢æœ‰ä¸€ä¸ªRequestDelegateå‚æ•°ï¼Œå½“è¯·æ±‚è¿›å…¥çš„æ—¶å€™ä¼šæ‰§è¡Œè¿™ä¸ªå§”æ‰˜è¿›å…¥å¯¹åº”çš„Actionã€‚å¦å¤–è¿™å…¶ä¸­è¿˜æœ‰ä¸€ä¸ªDefaultBuilderå±æ€§ï¼Œå¯ä»¥çœ‹åˆ°ä»–è¿”å›çš„æ˜¯`ControllerActionEndpointConventionBuilder`å¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡æ˜¯ç”¨æ¥æ„å»ºçº¦å®šè·¯ç”±çš„ã€‚`AddRoute`æ–¹æ³•ä¹Ÿæ˜¯ç”¨æ¥æ·»åŠ çº¦å®šè·¯ç”±çš„ã€‚æˆ‘ä»¬å†æ¥çœ‹ä¸‹æ„é€ å‡½æ•°ä¸­çš„`Subscribe()`æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯è°ƒç”¨çˆ¶ç±»`ActionEndpointDataSourceBase`ä¸­çš„ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è¿™ä¸ªç±»ï¼š

    internal abstract class ActionEndpointDataSourceBase : EndpointDataSource, IDisposable
    {
        private readonly IActionDescriptorCollectionProvider _actions;
    
        // The following are protected by this lock for WRITES only. This pattern is similar
        // to DefaultActionDescriptorChangeProvider - see comments there for details on
        // all of the threading behaviors.
        protected readonly object Lock = new object();
    
        // Protected for READS and WRITES.
        protected readonly List<Action> Conventions;
    
        private List? _endpoints;
        private CancellationTokenSource? _cancellationTokenSource;
        private IChangeToken? _changeToken;
        private IDisposable? _disposable;
    
        public ActionEndpointDataSourceBase(IActionDescriptorCollectionProvider actions)
        {
            _actions = actions;
    
            Conventions = new List<Action>();
        }
    
        public override IReadOnlyList Endpoints
        {
            get
            {
                Initialize();
                Debug.Assert(_changeToken != null);
                Debug.Assert(_endpoints != null);
                return _endpoints;
            }
        }
    
        // Will be called with the lock.
        protected abstract List CreateEndpoints(IReadOnlyList actions, IReadOnlyList<Action> conventions
    
        protected void Subscribe()
        {
            // IMPORTANT: this needs to be called by the derived class to avoid the fragile base class
            // problem. We can't call this in the base-class constuctor because it's too early.
            //
            // It's possible for someone to override the collection provider without providing
            // change notifications. If that's the case we won't process changes.
            if (_actions is ActionDescriptorCollectionProvider collectionProviderWithChangeToken)
            {
                _disposable = ChangeToken.OnChange(
                    () => collectionProviderWithChangeToken.GetChangeToken(),
                    UpdateEndpoints);
            }
        }
    
        public override IChangeToken GetChangeToken()
        {
            Initialize();
            Debug.Assert(_changeToken != null);
            Debug.Assert(_endpoints != null);
            return _changeToken;
        }
    
        public void Dispose()
        {
            // Once disposed we won't process updates anymore, but we still allow access to the endpoints.
            _disposable?.Dispose();
            _disposable = null;
        }
    
        private void Initialize()
        {
            if (_endpoints == null)
            {
                lock (Lock)
                {
                    if (_endpoints == null)
                    {
                        UpdateEndpoints();
                    }
                }
            }
        }
    
        private void UpdateEndpoints()
        {
            lock (Lock)
            {
                var endpoints = CreateEndpoints(_actions.ActionDescriptors.Items, Conventions);
    
                // See comments in DefaultActionDescriptorCollectionProvider. These steps are done
                // in a specific order to ensure callers always see a consistent state.
    
                // Step 1 - capture old token
                var oldCancellationTokenSource = _cancellationTokenSource;
    
                // Step 2 - update endpoints
                _endpoints = endpoints;
    
                // Step 3 - create new change token
                _cancellationTokenSource = new CancellationTokenSource();
                _changeToken = new CancellationChangeToken(_cancellationTokenSource.Token);
    
                // Step 4 - trigger old token
                oldCancellationTokenSource?.Cancel();
            }
        }
    }

`_actions`å±æ€§æ˜¯æ³¨å…¥è¿›æ¥çš„ï¼Œè¿™ä¸ªå¯¹è±¡æ˜¯æˆ‘ä»¬åœ¨`services.AddMvcCore()`ä¸­æ³¨å…¥è¿›æ¥çš„ï¼š`services.TryAddSingleton<IActionDescriptorCollectionProvider, DefaultActionDescriptorCollectionProvider>();`æˆ‘ä»¬æ¥è¯´ä¸‹`ChangeToken.OnChange()`æ–¹æ³•ï¼Œä»–é‡Œé¢æœ‰ä¸¤ä¸ªå§”æ‰˜ç±»å‹çš„å‚æ•°ï¼Œ`GetChangeToken()`å®ƒçš„ä½œç”¨æ˜¯ç”¨æ¥æ„ŸçŸ¥`ActionDescriptor`æ•°æ®æºçš„å˜åŒ–ï¼Œç„¶åæ‰§è¡Œ`UpdateEndpoints`æ–¹æ³•ä¸­çš„å…·ä½“çš„é€»è¾‘ï¼š

*   é¦–å…ˆæ›´æ–°ActionDescriptorså¯¹è±¡çš„å…·ä½“å…ƒæ•°æ®ä¿¡æ¯
*   è·å–æ—§çš„ä»¤ç‰Œ
*   æ›´æ–°ç»ˆç»“ç‚¹
*   åˆ›å»ºæ–°çš„ä»¤ç‰Œ
*   åºŸå¼ƒæ—§çš„ä»¤ç‰Œ

å¤§å®¶åšçš„é¡¹ç›®éƒ½æœ‰é‰´æƒã€æˆæƒçš„åŠŸèƒ½ã€‚è€Œæ¯ä¸€ä¸ªè§’è‰²å¯ä»¥è®¿é—®çš„èµ„æºæ˜¯ä¸ç›¸åŒçš„ï¼Œå› æ­¤ç­–ç•¥é‰´æƒæ˜¯éå¸¸å…³é”®çš„ä¸€æ­¥ï¼Œå®ƒå¯ä»¥é˜»æ­¢éæ­¤èœå•èµ„æºçš„è§’è‰²ç”¨æˆ·è®¿é—®æ­¤èœå•çš„æ¥å£ã€‚ä¸€èˆ¬æ¥è¯´æœ‰ä¸€ä¸ªæ¥å£è¡¨(Module)ã€ä¸€ä¸ªèœå•è¡¨(Permission)ã€ä¸€ä¸ªæ¥å£èœå•å…³ç³»è¡¨(ModulePermission)ï¼Œæ¥å£éœ€è¦æŒ‚åœ¨èœå•ä¸‹é¢ï¼Œå‡å¦‚ä¸€ä¸ªé¡¹ç›®å‡ ç™¾ä¸ªæ¥å£ï¼Œé‚£å½•èµ·æ¥å¯å°±éº»çƒ¦äº†ã€‚æŒ‰ç…§æˆ‘ä»¬ä¸Šé¢è¯´çš„ï¼Œåœ¨ç®¡é“æ„å»ºæ—¶ï¼Œç¨‹åºå°±ä¼šæ‰«ææ‰€æœ‰ç›¸å…³ç¨‹åºé›†ä¸­Controllerçš„Actionç„¶åäº¤ç»™â€œè·¯ç”±â€æ¨¡å—å»ç®¡ç†ã€‚Actionçš„è¿™äº›å…ƒæ•°æ®ä¿¡æ¯ä¼šå­˜åœ¨æˆ‘ä»¬ä¸Šé¢è¯´çš„IActionDescriptorCollectionProviderä¸­çš„ActionDescriptorCollectionå¯¹è±¡çš„ActionDescriptoré›†åˆä¸­ï¼Œè¿™æ ·åœ¨httpè¯·æ±‚åˆ°æ¥æ—¶â€œè·¯ç”±â€æ¨¡å—æ‰èƒ½å¯»æ‰¾åˆ°æ­£ç¡®çš„Endpointï¼Œè¿›è€Œæ‰¾åˆ°Actionå¹¶è°ƒç”¨æ‰§è¡Œã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥è¯»åˆ°é¡¹ç›®ä¸­æ‰€æœ‰æ³¨å†Œçš„è·¯ç”±ï¼Œç„¶åå¯¼å…¥åˆ°æ•°æ®åº“è¡¨ä¸­ğŸ˜Š

    private readonly IActionDescriptorCollectionProvider _actionDescriptorCollectionProvider;
    
    public RouteController(IActionDescriptorCollectionProvider actionDescriptorCollectionProvider)
    {
        _actionDescriptorCollectionProvider = actionDescriptorCollectionProvider;
    }
    /// <summary>
    /// è·å–è·¯ç”±
    /// </summary>
    /// <returns></returns>
    [HttpGet]
    public IActionResult Get()
    {
        var routes = _actionDescriptorCollectionProvider.ActionDescriptors.Items.Select(x => new
        {
            Action = x.RouteValues["Action"],
            Controller = x.RouteValues["Controller"],
            Name = x.AttributeRouteInfo.Name,
            Method = x.ActionConstraints?.OfType<HttpMethodActionConstraint>().FirstOrDefault()?.HttpMethods.First(),
            Template = x.AttributeRouteInfo.Template
        }).ToList();
        return Ok(routes);
    }

ä¸Šé¢æˆ‘ä»¬èŠäº†ä¸€äº›æºç ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹ä¸‹å¦‚ä½•å®ç°åŠ¨æ€è·¯ç”±

### MvcOptions

å…ˆè¯´ä¸€ä¸‹MvcOptionsç±»ï¼Œå®ƒä¸º.Net Core æ•´ä¸ªæ¡†æ¶æä¾›åŸºç¡€é…ç½®ã€‚è¿™æ ·è¯´ä¼°è®¡å¤ªæŠ½è±¡äº†ï¼Œæˆ‘ä¸¾ä¾‹ä¸€ä¸‹å“ˆã€‚ä¾‹å¦‚ActionåŠ ä¸Š\[FromBody\]ï¼Œå®¢æˆ·ç«¯ä¼ å…¥çš„Bodyä¸ºnullçš„è¯ï¼Œæ¥å£ä¼šæŠ¥400é”™è¯¯ï¼šA non-empty request body is requiredã€‚å¯ä»¥ä½¿ç”¨æ¨¡å‹éªŒè¯`AllowEmptyInputInBodyModelBinding`å‚æ•°é…ç½®nullå€¼å¯ä¼ å…¥ï¼ˆ.Net5ä¹‹åå¯ä»¥æ ¹æ®éœ€è¦æŒ‰è¯·æ±‚è¿›è¡Œé…ç½®ï¼‰ã€‚è¿˜æœ‰`FilterCollection`é›†åˆè¿™ä¸ªå‚æ•°ï¼Œä»MVCæ—¶ä»£æ²¿ç”¨åˆ°ç°åœ¨çš„äº”ç§èµ„æºè¿‡æ»¤å™¨ï¼Œå…¶å®ä»–ä»¬éƒ½é»˜è®¤ç»§æ‰¿è‡ª`IFilterMetadata`ç©ºæ¥å£ï¼Œè€Œ`FilterCollection`é›†åˆå°±æ˜¯æ‰¿è½½è¿™äº›Filterçš„å®¹å™¨ä¸”ç»§æ‰¿è‡ª`Collection<IFilterMetadata>`ï¼Œå…³äº`AOP`å’Œ`ç®¡é“ä¸­é—´ä»¶`è¿™äº›æˆ‘åé¢ä¼šå•ç‹¬æŠ½æºç æ¥è®²ã€‚å¥½äº†æˆ‘ä»¬è¿™ç¯‡ä¸»è¦è¦è¯´ä¸€ä¸‹å®ƒé‡Œé¢çš„`IList<IApplicationModelConvention>`å‚æ•°ã€‚

#### IApplicationModelConvention

æˆ‘ä»¬å…ˆçœ‹ä¸‹å®ƒçš„æºç ï¼š

![](https://img2023.cnblogs.com/blog/1677460/202303/1677460-20230301205943853-1299522969.png)

æˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªç±»ç»§æ‰¿å®ƒï¼Œå®ç°å®ƒçš„Applyæ–¹æ³•ï¼Œä¿®æ”¹.Net Coreç¨‹åºå†…éƒ¨å¯¹è·¯ç”±ã€æ§åˆ¶å™¨çš„é»˜è®¤ç”Ÿæˆè¡Œä¸ºï¼Œç„¶åå°†å®ƒæ·»åŠ åˆ°`Convention`é›†åˆä¸­ğŸ˜Š

é€šè¿‡`Apply`æ–¹æ³•æ¥è¿›è¡Œè‡ªå®šä¹‰ï¼Œå¯ä»¥ä¿®æ”¹çš„å†…å®¹ç”±`ApplicationModel`å¯¹è±¡æä¾›ã€‚ç‰¹åˆ«æ˜¯å®ƒé‡Œé¢çš„`ControllerModel`å¯¹è±¡ï¼Œæœ‰äº†å®ƒæˆ‘ä»¬å¯ä»¥ç›´æ¥å¯¹æ§åˆ¶å™¨è¿›è¡Œå„ç§é…ç½®å’Œæ“ä½œã€‚

çœ‹ä¸€ä¸‹`ApplicationModel`å¯¹è±¡çš„å®šä¹‰ï¼š

    /// <summary>
    /// A model for configuring controllers in an MVC application.
    /// </summary>
    [DebuggerDisplay("ApplicationModel: Controllers: {Controllers.Count}, Filters: {Filters.Count}")]
    public class ApplicationModel : IPropertyModel, IFilterModel, IApiExplorerModel
    {
        /// <summary>
        /// Initializes a new instance of <see cref="ApplicationModel"/>.
        /// </summary>
        public ApplicationModel()
        {
            ApiExplorer = new ApiExplorerModel();
            Controllers = new List<ControllerModel>();
            Filters = new List<IFilterMetadata>();
            Properties = new Dictionary<object, object?>();
        }
        /// <summary>
        /// Gets or sets the <see cref="ApiExplorerModel"/> for the application.
        /// </summary>
        /// <remarks>
        /// <see cref="ApplicationModel.ApiExplorer"/> allows configuration of default settings
        /// for ApiExplorer that apply to all actions unless overridden by
        /// <see cref="ControllerModel.ApiExplorer"/> or <see cref="ActionModel.ApiExplorer"/>.
        ///
        /// If using <see cref="ApplicationModel.ApiExplorer"/> to set <see cref="ApiExplorerModel.IsVisible"/> to
        /// <c>true</c>, this setting will only be honored for actions which use attribute routing.
        /// </remarks>
        public ApiExplorerModel ApiExplorer { get; set; }
        /// <summary>
        /// Gets the <see cref="ControllerModel"/> instances.
        /// </summary>
        public IList<ControllerModel> Controllers { get; }
        /// <summary>
        /// Gets the global <see cref="IFilterMetadata"/> instances.
        /// </summary>
        public IList<IFilterMetadata> Filters { get; }
        /// <summary>
        /// Gets a set of properties associated with all actions.
        /// These properties will be copied to <see cref="Abstractions.ActionDescriptor.Properties"/>.
        /// </summary>
        public IDictionary<object, object?> Properties { get; }
    }

â‘ `ApiExplorer`å¯ä»¥ç”¨æ¥é…ç½®æ§åˆ¶å™¨çš„ç»„ä¿¡æ¯è¿˜æœ‰å¯è§æ€§

â‘¡`Controllers`å¯ä»¥è·å–Controllerçš„ç›¸å…³ä¿¡æ¯ï¼Œå†å€ŸåŠ©`IControllerModelConvention`å¯¹å…¶è¿›è¡Œå®šåˆ¶æ‰©å±•

â‘¢`Filters`å­˜æ”¾çš„éƒ½æ˜¯ç©ºæ¥å£ï¼Œèµ·åˆ°æ ‡è®°ä½œç”¨ï¼Œæ¢å¥è¯è¯´å°±æ˜¯åœ¨è¯·æ±‚ç®¡é“æ„å»ºçš„æ—¶å€™ç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºFilterç±»

â‘£`Properties`å±äºå…±äº«å­—å…¸

ç»™è·¯ç”±æ·»åŠ å…¨å±€é…ç½®

    services.AddControllers(options =>
    {
        options.UseCentralRoutePrefix(new RouteAttribute("core/v1/api/[controller]/[action]"));
    });

æ·»åŠ æˆ‘ä»¬è‡ªå®šä¹‰æ‰©å±•æ–¹æ³•

    public static class MvcOptionsExtensions
    {
        /// <summary>
        /// æ‰©å±•æ–¹æ³•
        /// </summary>
        /// <param name="opts"></param>
        /// <param name="routeAttribute"></param>
        public static void UseCentralRoutePrefix(this MvcOptions opts, IRouteTemplateProvider routeAttribute)
        {        //æ·»åŠ æˆ‘ä»¬è‡ªå®šä¹‰å®ç°
            opts.Conventions.Insert(0, new RouteConvention(routeAttribute));
        }
    }

Â å…·ä½“çš„å®ç°ç±»

    /// <summary>
    /// å…¨å±€è·¯ç”±å‰ç¼€é…ç½®
    /// </summary>
    public class RouteConvention : IApplicationModelConvention
    {
        /// <summary>
        /// å®šä¹‰ä¸€ä¸ªè·¯ç”±å‰ç¼€å˜é‡
        /// </summary>
        private readonly AttributeRouteModel _centralPrefix;
        /// <summary>
        /// è°ƒç”¨æ—¶ä¼ å…¥æŒ‡å®šçš„è·¯ç”±å‰ç¼€
        /// </summary>
        /// <param name="routeTemplateProvider"></param>
        public RouteConvention(IRouteTemplateProvider routeTemplateProvider)
        {
            _centralPrefix = new AttributeRouteModel(routeTemplateProvider);
        }
    
        //å®ç°Applyæ–¹æ³•
        public void Apply(ApplicationModel application)
        {        //éå†æ‰€æœ‰çš„ Controller
            foreach (var controller in application.Controllers)
            {ã€€ã€€ã€€ã€€ã€€ã€€ã€€
                var matchedSelectors = controller.Selectors.Where(x => x.AttributeRouteModel != null).ToList();
                if (matchedSelectors.Any())//è¯¥Controllerå·²ç»æ ‡è®°äº†RouteAttribute
                {
                    foreach (var selectorModel in matchedSelectors)
                    {
                        // åœ¨å½“å‰è·¯ç”±ä¸Šå†æ·»åŠ ä¸€ä¸ª è·¯ç”±å‰ç¼€
                        selectorModel.AttributeRouteModel = AttributeRouteModel.CombineAttributeRouteModel(_centralPrefix,
                            selectorModel.AttributeRouteModel);
                    }
                }
    
                var unmatchedSelectors = controller.Selectors.Where(x => x.AttributeRouteModel == null).ToList();
                if (unmatchedSelectors.Any())//è¯¥Controlleræ²¡æœ‰æ ‡è®°RouteAttribute
                {
                    foreach (var selectorModel in unmatchedSelectors)
                    {
                        // æ·»åŠ ä¸€ä¸ªè·¯ç”±å‰ç¼€
                        selectorModel.AttributeRouteModel = _centralPrefix;
                    }
                }
            }
        }
    }

POCOæ§åˆ¶å™¨
-------

åœ¨Javaä¸­æœ‰ä¸€ä¸ªå«`POJO`çš„åè¯ï¼Œå³"Plain Old Java Object"ï¼Œç›´è¯‘å°±æ˜¯ç®€å•çš„Javaå¯¹è±¡ï¼Œå…¶å®å®ƒè¡¨ç¤ºçš„æ˜¯æ²¡æœ‰ç»§æ‰¿ä»»ä½•ç±»ï¼Œä¹Ÿæ²¡æœ‰å®ç°ä»»ä½•æ¥å£çš„å¯¹è±¡ã€‚åœ¨C#ä¸­ä¹Ÿæœ‰ä¸€ä¸ªç›¸åŒå«ä¹‰çš„åè¯å«`POCO`ï¼ˆPlain Old C# Objectï¼‰,ä¸¤è€…è¡¨ç¤ºçš„å«ä¹‰æ˜¯ä¸€æ ·çš„ã€‚åœ¨.Net Coreä¸­æœ‰ä¸€ä¸ª`POCO Controller`çš„ç‰¹æ€§ï¼Œå®ƒä¸ç”¨ç»§æ‰¿Controlleræˆ–ControllerBaseï¼Œåªéœ€è¦åœ¨ç±»åååŠ ä¸ŠControllerçš„åç¼€æˆ–æ ‡è®°\[Controller\]ç‰¹æ€§ä¹Ÿèƒ½æ‹¥æœ‰Controllerçš„åŠŸèƒ½ã€‚

ä¸‹é¢ç®€å•æ¼”ç¤ºä¸€ä¸‹ï¼š

    public class TestController
    {
    
        [HttpGet]
        public async Task<IEnumerable<int>> Get()
        {
            Func<int, int> triple = m => m * 3;
            var range = Enumerable.Range(1, 3);
            return range.Select(triple);
        }
    }
    
    [Controller]
    public class TestOnce
    {
        [HttpGet]
        public async Task<IEnumerable<dynamic>> Index()
        => Enumerable.Range(1, 100).Select(triple => new { triple });
    
    }

Â ä¸Šé¢ä¸¤ä¸ªç±»ä¸­çš„Actionä¼šè¢«æ­£ç¡®æ‰«æå¹¶æ·»åŠ åˆ°ç»ˆç»“ç‚¹ä¸­ï¼š

![](https://img2023.cnblogs.com/blog/1677460/202303/1677460-20230307205806955-85405814.png)

ä¸€ä¸ª(æ§åˆ¶å™¨)ç±»å¦‚æœåŠ ä¸Š`[NonController]`å°±ä¸ä¼šè¢«æ³¨å†Œåˆ°è·¯ç”±ä¸­ğŸ˜‹ã€‚æˆ‘ä»¬æ¥ä¸‹æ¥è¿˜æ˜¯çœ‹ä¸‹æºç ï¼š

    // Licensed to the .NET Foundation under one or more agreements.
    // The .NET Foundation licenses this file to you under the MIT license.
    
    using System.Linq;
    using System.Reflection;
    using Microsoft.AspNetCore.Mvc.ApplicationParts;
    
    namespace Microsoft.AspNetCore.Mvc.Controllers;
    
    /// <summary>
    /// Discovers controllers from a list of <see cref="ApplicationPart"/> instances.
    /// </summary>
    public class ControllerFeatureProvider : IApplicationFeatureProvider<ControllerFeature>
    {
        private const string ControllerTypeNameSuffix = "Controller";
    
        /// <inheritdoc />
        public void PopulateFeature(
            IEnumerable<ApplicationPart> parts,
            ControllerFeature feature)
        {
            foreach (var part in parts.OfType<IApplicationPartTypeProvider>())
            {
                foreach (var type in part.Types)
                {
                    if (IsController(type) && !feature.Controllers.Contains(type))
                    {
                        feature.Controllers.Add(type);
                    }
                }
            }
        }
    
        /// <summary>
        /// Determines if a given <paramref name="typeInfo"/> is a controller.
        /// </summary>
        /// <param name="typeInfo">The <see cref="TypeInfo"/> candidate.</param>
        /// <returns><see langword="true" /> if the type is a controller; otherwise <see langword="false" />.</returns>
        protected virtual bool IsController(TypeInfo typeInfo)
        {
            if (!typeInfo.IsClass)
            {
                return false;
            }
    
            if (typeInfo.IsAbstract)
            {
                return false;
            }
    
            // We only consider public top-level classes as controllers. IsPublic returns false for nested
            // classes, regardless of visibility modifiers
            if (!typeInfo.IsPublic)
            {
                return false;
            }
    
            if (typeInfo.ContainsGenericParameters)
            {
                return false;
            }
    
            if (typeInfo.IsDefined(typeof(NonControllerAttribute)))
            {
                return false;
            }
    
            if (!typeInfo.Name.EndsWith(ControllerTypeNameSuffix, StringComparison.OrdinalIgnoreCase) &&
                !typeInfo.IsDefined(typeof(ControllerAttribute)))
            {
                return false;
            }
    
            return true;
        }
    }

å…¶å®POCOæ§åˆ¶å™¨çš„æ ¸å¿ƒå°±åœ¨äº`IApplicationFeatureProvider<ControllerFeature>`è¿™ä¸ªæ¥å£ï¼Œ`ControllerFeatureProvider`æ˜¯å…¶é»˜è®¤çš„å®ç°ç±»ã€‚

æˆ‘ä»¬é‡æ–°å†™ä¸€ä¸ªç±»ç»§æ‰¿è‡ª`ControllerFeatureProvider`ï¼ŒæŠŠ`IsController`æ–¹æ³•è¿›è¡Œé‡å†™åŠ å…¥æˆ‘ä»¬çš„åˆ¤æ–­é€»è¾‘ï¼Œå…¶å®ƒæˆ‘å°±ä¸å•°å—¦äº†ï¼Œä¸Šé¢çš„ä»£ç å¾ˆæ¸…æ¥šç™½äº†äº†ğŸ˜†

### è‡ªå®šä¹‰æ§åˆ¶å™¨è§„åˆ™

å®šä¹‰ä¸€ä¸ªæ¥å£å’Œä¸€ä¸ªç‰¹æ€§ä½¿ä¹‹æˆä¸ºæˆ‘ä»¬çš„è§„åˆ™

    public interface ICoreDynamicController { }
    
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    public class CoreDynamicControllerAttribute : Attribute { }

ç»§æ‰¿`ControllerFeatureProvider`ç±»å¹¶ä¸”å®ç°`IsController`æ–¹æ³•ï¼š

    public class CoreDynamicExtendControlleFeatureProvider : ControllerFeatureProvider
    {
        protected override bool IsController(TypeInfo typeInfo)
        {
            var type = typeInfo.AsType();
            if ((typeof(ICoreDynamicController).IsAssignableFrom(type) || //åˆ¤æ–­æ˜¯å¦ç»§æ‰¿ICoreDynamicControlleræ¥å£
                type.IsDefined(typeof(CoreDynamicControllerAttribute), true) || // åˆ¤æ–­æ˜¯å¦æ ‡è®°äº†ICoreDynamicControllerç‰¹æ€§
                type.BaseType == typeof(Microsoft.AspNetCore.Mvc.Controller)) && //åˆ¤æ–­åŸºç±»å‹æ˜¯å¦æ˜¯Controller
                (typeInfo.IsPublic && !typeInfo.IsAbstract && !typeInfo.IsGenericType && !typeInfo.IsInterface)) //å¿…é¡»æ˜¯Publicã€ä¸èƒ½æ˜¯æŠ½è±¡ç±»ã€å¿…é¡»æ˜¯éæ³›å‹çš„
            {          return true;
            }
            return false;
        }
    }

Â ç°åœ¨æ–¹æ³•å·²ç»å†™å¥½äº†ï¼Œä½†æ˜¯æˆ‘ä»¬è¦æŠŠå®ƒé…ç½®åˆ°Mvcä¸­æ‰è¡Œã€‚è¿™é‡Œè¦è¯´ä¸€ä¸‹`MvcCoreMvcBuilderExtensions`ç±»çš„`IMvcBuilder`çš„`ConfigureApplicationPartManager`æ–¹æ³•ï¼Œå®ƒçš„å‚æ•°æ˜¯ä¸€ä¸ªå§”æ‰˜ï¼Œå§”æ‰˜ä¸­çš„å‚æ•°æ˜¯`ApplicationPartManager`ï¼Œ `ApplicationPartManager`ä¸­æœ‰ä¸€ä¸ª`FeatureProviders`çš„å±æ€§ï¼Œå®ƒé‡Œé¢å…¨æ˜¯`IApplicationFeatureProvider`çš„å®ä¾‹ã€‚ç¨‹åºå¯åŠ¨çš„æ—¶å€™ä¼šå¾ªç¯è¿™äº›å®ä¾‹ï¼Œæˆ‘ä»¬æŠŠè‡ªå·±çš„è‡ªå®šä¹‰å®ç°ç±»æ·»åŠ è¿›æ¥ï¼Œè¿™æ ·Coreç¨‹åºå°±èƒ½è¯†åˆ«æˆ‘ä»¬çš„æ§åˆ¶å™¨ï¼Œå¹¶ä¸”èµ‹äºˆå…¶æ§åˆ¶å™¨æ‰€æœ‰çš„åŠŸèƒ½ã€‚æ— å›¾æ— çœŸç›¸ï¼Œè¯·çœ‹æºç ï¼š

![](https://img2023.cnblogs.com/blog/1677460/202303/1677460-20230331205942212-1977031987.jpg)

Â æ‰€ä»¥æŠŠæˆ‘ä»¬è‡ªå®šä¹‰çš„è¯†åˆ«ç±»æ·»åŠ è¿›æ¥å³å¯

    services.AddControllers().ConfigureApplicationPartManager
    (t => t.FeatureProviders.Add(new CoreDynamicExtendControlleFeatureProvider()));

Â å¦‚ä¸‹ç¤ºä¾‹ï¼š

    public class Test : ICoreDynamicController
    {
    
        [HttpGet]
        public IEnumerable<int> Get(int value)
        {
            yield return value;
        }
    }

![](https://img2023.cnblogs.com/blog/1677460/202303/1677460-20230312172059038-1529924036.png)

Dynamic Api
-----------

ä½¿ç”¨è¿‡ABP vNextæ¡†æ¶çš„å°ä¼™ä¼´éƒ½åº”è¯¥çŸ¥é“ï¼Œå¦‚æœä¸€ä¸ªç±»å®ç°äº†`IRemoteService`æˆ–`IApplicationService`æ¥å£ï¼Œé‚£ä¹ˆå®ƒä¼šè¢«è‡ªåŠ¨é€‰æ‹©ä¸ºAPIæ§åˆ¶å™¨ã€‚ABPÂ vNextæ¡†æ¶åœ¨åŠ¨æ€APIåŠŸèƒ½ä¸­éµä»çº¦å®šå¤§äºé…ç½®çš„åŸåˆ™ï¼Œä¾‹å¦‚æ–¹æ³•åç§°ä»¥`GetList`,`GetAll`æˆ–`Get`å¼€å¤´åˆ™è¯·æ±‚çš„`HttpMethod`éƒ½ä¸º`HttpGet`

> ABPÂ vNextå®˜æ–¹æ–‡æ¡£ï¼š[API/Auto API Controllers | Documentation Center | ABP.IO](https://docs.abp.io/zh-Hans/abp/latest/API/Auto-API-Controllers)

æˆ‘ä»¬å€ŸåŠ©å®ƒçš„æ€æƒ³æ¥å®ç°æˆ‘ä»¬çš„åŠ¨æ€API

### å®ç°Applyæ–¹æ³•

åœ¨AspNetCoreæ¡†æ¶ä¸­ç»™å‡ºäº†ä¸‰ä¸ªé…ç½®æ§åˆ¶å™¨ã€æ–¹æ³•å’Œå‚æ•°çš„é…ç½®æ¥å£ï¼Œåˆ†åˆ«æ˜¯`IControllerModelConvention`ã€`IActionModelConventionå’Œ``IParameterModelConvention`ã€‚åœ¨å®ƒä»¬çš„`Apply`æ–¹æ³•ä¸­ï¼Œä¼ å…¥äº†ä¸€ä¸ª MVC å¯åŠ¨é˜¶æ®µæ‰«æåˆ°çš„ç±»å‹ï¼Œå¯¹åº”çš„åˆ†åˆ«æ˜¯`ControllerModel`ã€`ActionModel`å’Œ`ParameterModel`æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ä¸‰ä¸ªModelåŠ å…¥æˆ‘ä»¬çš„è‡ªå®šä¹‰é…ç½®ã€‚è¿˜æ˜¯ä¸€æ ·æˆ‘ä»¬è¦ç»§æ‰¿`IApplicationModelConvention`æ¥å£ç­›é€‰å‡ºç¬¦åˆæ¡ä»¶çš„æ§åˆ¶å™¨ï¼Œç„¶åéå†å…¶ä¸­çš„`Action`ç»™å…¶æ·»åŠ è·¯ç”±ä¸`HttpMethos`ï¼ˆè¦æ ¹æ®Actionçš„å‰ç¼€è¿›è¡Œåˆ¤æ–­ï¼‰ã€‚æœ¬é¡¹ç›®æ˜¯æ ¹æ®ä¸‹é¢åˆ—ä¸¾çš„æ¡ä»¶è¿›è¡Œåˆ¤æ–­çš„ï¼ˆæ³¨æ„ï¼šå¾—åˆ°ActionMethodNameçš„æ—¶å€™è¦ToUpperæˆ–ToLowerè¿™æ ·æ–¹ä¾¿åˆ¤æ–­ï¼‰ï¼š

*   Getï¼šå¦‚æœæ–¹æ³•ä»¥`GET`ã€`QUERY`å¼€å¤´
*   Postï¼šå¦‚æœæ–¹æ³•ä»¥`CREATE`ã€`SAVE`ã€`INSERT`ã€`ADD`å¼€å¤´
*   Putï¼šå¦‚æœæ–¹æ³•ä»¥`UPDATE`ã€`EDIT`å¼€å¤´
*   Deleteï¼šå¦‚æœæ–¹æ³•ä»¥`Delete`ã€`REMOVE`å¼€å¤´

    "HttpMethodInfo": [
      {
        "MethodKey": "Get",
        "MethodVal": [ "GET", "QUERY" ]
      },
      {
        "MethodKey": "Post",
        "MethodVal": [ "CREATE", "SAVE", "INSERT", "ADD" ]
      },
      {
        "MethodKey": "Put",
        "MethodVal": [ "UPDATE", "EDIT" ]
      },
      {
        "MethodKey": "Delete",
        "MethodVal": [ "Delete", "REMOVE" ]
      }
    ]

    public class CoreDynamicControllerConvention : IApplicationModelConvention
    {
        private IConfiguration _configuration;
        private List<HttpMethodConfigure> httpMethods = new();
        public CoreDynamicControllerConvention(IConfiguration configuration)
        {
            _configuration = configuration;
            httpMethods = (List<HttpMethodConfigure>)_configuration.GetSection("HttpMethodInfo").Get(typeof(List<HttpMethodConfigure>));
        }
        public void Apply(ApplicationModel application)
        {
            //å¾ªç¯æ¯ä¸€ä¸ªæ§åˆ¶å™¨ä¿¡æ¯
            foreach (var controller in application.Controllers)
            {
                var controllerType = controller.ControllerType.AsType();
                //æ˜¯å¦ç»§æ‰¿ICoreDynamicControlleræ¥å£
                if (typeof(ICoreDynamicController).IsAssignableFrom(controllerType))
                {
                    foreach (var item in controller.Actions)
                    {
                        ConfigureSelector(controller.ControllerName, item);
                    }
                }
            }
        }
    
        private void ConfigureSelector(string controllerName, ActionModel action)
        {
            for (int i = 0; i < action.Selectors.Count; i++)
            {
                if (action.Selectors[i].AttributeRouteModel is null)
                    action.Selectors.Remove(action.Selectors[i]);
            }
    
            if (action.Selectors.Any())
            {
                foreach (var item in action.Selectors)
                {
                    var routePath = string.Concat("api/", controllerName, action.ActionName).Replace("//", "/");
                    var routeModel = new AttributeRouteModel(new RouteAttribute(routePath));
                    //å¦‚æœæ²¡æœ‰è·¯ç”±å±æ€§
                    if (item.AttributeRouteModel == null) item.AttributeRouteModel = routeModel;
                }
            }
            else
            {
                action.Selectors.Add(CreateActionSelector(controllerName, action));
            }
        }
    
        private SelectorModel CreateActionSelector(string controllerName, ActionModel action)
        {
            var selectorModel = new SelectorModel();
            var actionName = action.ActionName;
            string httpMethod = string.Empty;
            //æ˜¯å¦æœ‰HttpMethodAttribute
            var routeAttributes = action.ActionMethod.GetCustomAttributes(typeof(HttpMethodAttribute), false);
            //å¦‚æœæ ‡è®°äº†HttpMethodAttribute
            if (routeAttributes != null && routeAttributes.Any())
            {
                httpMethod = routeAttributes.SelectMany(m => (m as HttpMethodAttribute).HttpMethods).ToList().Distinct().FirstOrDefault();
            }
            else
            {
                var methodName = action.ActionMethod.Name.ToUpper();
    
                foreach (var item in httpMethods)
                {
                    if (item.MethodVal.Contains(methodName))
                    {
                        httpMethod = item.MethodKey;
                        break;
                    }
                }
            }
            return ConfigureSelectorModel(selectorModel, action, controllerName, httpMethod);
        }
    
        public SelectorModel ConfigureSelectorModel(SelectorModel selectorModel, ActionModel action, string controllerName, string httpMethod)
        {
            var routePath = string.Concat("api/", controllerName, action.ActionName).Replace("//", "/");
            //ç»™æ­¤Actionæ·»åŠ è·¯ç”±
            selectorModel.AttributeRouteModel = new AttributeRouteModel(new RouteAttribute(routePath));
            //æ·»åŠ HttpMethod
            selectorModel.ActionConstraints.Add(new HttpMethodActionConstraint(new[] { httpMethod }));
            return selectorModel;
        }
    }

æ§åˆ¶å™¨ä¸­å°±å¾ˆç®€å•äº†ï¼š

public class Test : IDynamicController
{
    private readonly IHttpContextAccessor \_httpAccessor;
    public Test(IHttpContextAccessor httpAccessor) => \_httpAccessor = httpAccessor;

    public async Task SaveData()
    \=> \_httpAccessor.HttpContext.Response.WriteAsJsonAsync(new { \_ = this.GetType() });

    public async Task DeleteData()
    \=> \_httpAccessor.HttpContext.Response.WriteAsJsonAsync(new { \_ = this.GetType() });

    public async Task QueryData()
    \=> \_httpAccessor.HttpContext.Response.WriteAsJsonAsync(new { \_ = this.GetType() });

    public async Task UpdateData()
    \=> \_httpAccessor.HttpContext.Response.WriteAsJsonAsync(new { \_ = this.GetType() });
}

![](https://img2023.cnblogs.com/blog/1677460/202304/1677460-20230408170052113-1938748579.jpg)

åªè¦ä½ æŠŠåŸºæœ¬çš„åŸç†å¼„æ‡‚äº†ï¼Œå…¶å®å°±æ˜¯æœºæ¢°å¼çš„ç¼–ç äº†ğŸ˜Š