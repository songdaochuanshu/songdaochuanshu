---
layout: post
title: "YACS-2022.4-银组"
date: "2022-04-03T03:27:49.105Z"
---
YACS-2022.4-银组
==============

[https://www.iai.sh.cn/contest](https://www.iai.sh.cn/contest) 2022.04 银组，理论上 \\(100+100+30+100\\)。

T1 上锁的抽屉
--------

### 题目描述

有一个抽屉柜里竖排了 \\(n\\) 只抽屉。每个抽屉有一把锁。若要把一只抽屉『锁死』，就必须锁上它自己，而且要把它的上一层抽屉也锁上。请问有多少种上锁的方法，可以恰好『锁死』 \\(m\\) 只抽屉？

由于答案可能很大，输出方案数模 \\(10^9+7\\) 的余数。

### 大体思路

计数类问题显然想到动态规划。

一般地，设 \\(f\[i,j\]\\) 表示前 \\(i\\) 个抽屉『锁死』\\(j\\) 个的方案数。这样，我们只需要对第 \\(i\\) 个抽屉上锁是否影响『锁死』的个数即可。

此时我们发现，这还取决于第 \\(i-1\\) 个抽屉是否上锁。因此，我们规定 \\(f\[i,j,0\]\\) 表示前 \\(i\\) 个抽屉『锁死』\\(j\\) 个，且第 \\(i\\) 个抽屉不上锁的方案数，\\(f\[i,j,1\]\\) 表示前 \\(i\\) 个抽屉『锁死』\\(j\\) 个，且第 \\(i\\) 个抽屉上锁的方案数。

当第 \\(i\\) 个抽屉上锁时，我们可以借助第 \\(i-1\\) 个抽屉上锁，则之前『锁死』的个数为 \\(j-1\\) 个；也可能第 \\(i-1\\) 个抽屉不上锁，则前 \\(i-1\\) 个需要『锁死』\\(j\\) 个。第 \\(i\\) 个抽屉不上锁时，必然完全依靠前 \\(i-1\\) 个抽屉『锁死』\\(j\\) 个，由此可得状态转移方程：

\\\[f\[i,j,0\]=f\[i-1,j,1\]+f\[i-1,j,0\]\\\\ f\[i,j,1\]=f\[i-1,j-1,1\]+f\[i-1,j,0\]\\\]

其边界条件为 \\(f\[1,1,1\]=f\[1,0,0\]=1\\)，答案为 \\(f\[n,m,1\]+f\[n,m,0\]\\)，注意取模。

这样，时空复杂度为 \\(O(nm)\\)。注意到 \\(i\\) 的决策只与 \\(i-1\\) 相关，可以使用滚动数组使得空间复杂度降至 \\(O(m)\\)。

    ll n, m, f[2][maxn][2];
    /*
    f[i, j, 0] 表示前i个抽屉锁死j个，i不锁死
    f[i, j, 1] ......................i锁死
    
    f[1,0,0]=f[1,1,1]=1
    f[i,j,0]=f[i-1,j,1]+f[i-1,j,0]
    f[i,j,1]=f[i-1,j-1,1]+f[i-1,j,0]
    (j > 0)
    */
    int main () {
    	read(n); read(m);
    	f[1][0][0] = f[1][1][1] = 1;
    	rep(i, 2, n) {
    		rep(j, 0, i) {
    			f[i&1][j][0] = (f[(i-1)&1][j][1] + f[(i-1)&1][j][0]) % mod;
    			f[i&1][j][1] = f[(i-1)&1][j][0];
    			if(j > 0) (f[i&1][j][1] += f[(i-1)&1][j - 1][1]) %= mod;
    		}
    	}
    	writeln((f[n&1][m][0] + f[n&1][m][1]) % mod);
    	return 0;
    }
    

T2 匹配括号（二）
----------

### 题目描述

给定一个仅由 `(` 、`)`、`[` 与 `]` 构成的字符串，若它不是匹配的，请求出最少删去多少括号可以使它变成匹配的。匹配定义如下：

*   空字符串是匹配的；
*   如果字符串 \\(s\\) 是匹配的，那么 \\((s)\\) 与 \\(\[s\]\\) 也是匹配的；
*   如果字符串 \\(s\\) 与 \\(t\\) 都是匹配的，那么 \\(st\\) 也是匹配的。

### 大体思路

原题链接 [https://loj.ac/p/10150](https://loj.ac/p/10150) 。

由于匹配的括号串每一个子串都匹配，考虑区间 DP。设 \\(f\[i,j\]\\) 表示区间 \\(\[i,j\]\\) 最少删去的括号个数。边界 \\(f\[i,i\]=1\\)。

括号匹配是经典的讨论边界的区间 DP。如果 \\(s\_i,s\_j\\) 互相匹配，则有初始值 \\(f\[i,j\]=f\[i+1,j-1\]\\)，否则初始为 \\(\\infty\\)。然后枚举分割点 \\(k\\in \[i,j)\\)，\\(f\[i,j\]=\\min\\{f\[i,k\]+f\[k+1,j\]\\}\\)。最终答案即为 \\(f\[1,n\]\\)，时间复杂度 \\(O(n^3)\\)。

T3 末日生存
-------

### 题目描述

小爱正在参加一个末日生存比赛，每过一天要消耗一个单位的物资，最后一天到来之前，如果她没有物资，就输了。游戏一共要持续 \\(d\\) 天，出发前，小爱有 \\(c\\) 个单位的物资。

游戏过程中有 \\(n\\) 次补给机会，第 \\(i\\) 次补给机会在第 \\(x\_i\\) 天 ，当天可以补给 \\(a\_i\\) 个单位的物资。

请设计一个方案，使得小爱能够坚持到最后一天，且补给的次数最小。如果无论如何都到不了终点，输出 `Impossible`。

### 大体思路

考场上没有思路，感觉和之前某个旅行商问题很像，但显然不一样。于是直接使用 \\(dfs\\)，记 \\(dfs(N,C)\\) 表示到达第 \\(N\\) 个补给站时还有 \\(C\\) 的物资的次数，然后对第 \\(N\\) 个补给站是否补充物资进行讨论，时间复杂度 \\(O(2^n)\\)，期望得分 \\(30\\)。

T4 狼人游戏
-------

### 题目描述

有 \\(n\\) 个人在一起玩狼人游戏，游戏中有一些玩家的身份是狼人，剩下玩家的身份是平民。狼人知道彼此之间的身份，而平民对其他人的身份信息一无所知。

天亮时，每名玩家要指证另一名玩家是狼人。狼人一定会做伪证，指证某个平民为狼人，而平民可能指证某个狼人，也可能指证另一个平民。

给定每名玩家的指证对象，请分析场面上最多可能有多少名狼人？注意游戏规定至少需要有一名平民。

### 大体思路

原题 \[COCI2014-2015#1\] MAFIJA，正好做到过。

将指认关系进行连边，\\(n\\) 个节点 \\(n\\) 条边形成基环树（基环森林）。

用并查集维护环，对于每一个环，将其断开后变为一棵树，然后将这两个节点 \\(u,v\\) 分别作为根跑树形 DP 即可，答案累加 \\(\\max(f\[u,0\],f\[v,0\])\\)。动态规划的复杂度为 \\(O(n)\\)，总复杂度为 \\(O(n\\log n)\\)，瓶颈在于并查集。

此题由于所有点权均为 \\(1\\)，还有 \\(O(n)\\) 的贪心做法，但由于推广性不强，在此不介绍。

    /*
    f[u][0]+=max(f[v][0], f[v][1])
    f[u][1] = 1 + f[v][0]
    max f[u][0], f[v][0]
    */
    int n, id[maxn], f[maxn][2], ans;
    int tot = 1, hd[maxn], ver[maxn * 2], nxt[maxn * 2];
    inline void add(int u, int v) {
    	ver[++tot] = v; nxt[tot] = hd[u]; hd[u] = tot;
    	ver[++tot] = u; nxt[tot] = hd[v]; hd[v] = tot;
    }
    PII p[maxn]; // cir
    bool vis[maxn * 2];
    inline void dfs(int u, int fa) {
    	f[u][0] = 0, f[u][1] = 1;
    	for(int i = hd[u]; i; i = nxt[i]) {
    		int v = ver[i];
    		if(vis[i] || vis[i ^ 1] || v == fa) continue;
    		dfs(v, u);
    		f[u][0] += max(f[v][0], f[v][1]);
    		f[u][1] += f[v][0];
    	}
    }
    int fa[maxn];
    inline int find(int k) {
    	return (k == fa[k] ? k : fa[k] = find(fa[k]));
    }
    int main () {
    	read(n);
    	rep(i, 1, n) fa[i] = i;
    	rep(u, 1, n) {
    		int v; read(v);
    		add(u, v);
    		int f1 = find(u), f2 = find(v);
    		if(f1 != f2) fa[f1] = f2;
    		else {
    			id[++id[0]] = tot;
    			p[id[0]] = {u, v};
    		}
    	}
    	rep(i, 1, id[0]) {
    		int u = p[i].first, v = p[i].second;
    		vis[id[i]] = vis[id[i] ^ 1] = 1;
    		dfs(u, 0);
    		int tmp = f[u][0];
    		dfs(v, 0);
    		ans += max(tmp, f[v][0]);
    		vis[id[i]] = vis[id[i] ^ 1] = 0;
    	}
    	writeln(ans);
    	return 0;
    }