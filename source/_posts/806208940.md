---
layout: post
title: "Android 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - SurfaceFlingerä¹‹VSync-ä¸Šç¯‡ï¼ˆåå…­ï¼‰"
date: "2022-04-19T15:19:58.489Z"
---
Android 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - SurfaceFlingerä¹‹VSync-ä¸Šç¯‡ï¼ˆåå…­ï¼‰
==================================================

Vsyncä½œä¸ºé©±åŠ¨SFåˆæˆä¸Šå±å’Œappæ¸²æŸ“çš„ä¸»è¦æœºåˆ¶ï¼Œè¿™ç¯‡æ–‡ç« ï¼Œä¸»è¦åˆ†æäº†VSyncç›¸å…³çš„ä¸€äº›åˆå§‹åŒ–çš„è¿‡ç¨‹ï¼ŒåŒ…æ‹¬å’Œ vsync eventçš„äº§ç”Ÿå’Œåˆ†å‘ç›¸å…³çš„ç»„ä»¶åŠäº‹ä»¶å›è°ƒçš„æµç¨‹ã€‚

#### **å¿…è¯»ï¼š**

#### **Android 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - å¼€ç¯‡**

* * *

ä¸€ã€å‰è¨€
----

* * *

ä¸ºäº†æé«˜Androidç³»ç»Ÿçš„UIäº¤äº’é€Ÿåº¦å’Œæ“ä½œçš„æµç•…åº¦ï¼Œåœ¨Android 4.1ä¸­ï¼Œå¼•å…¥äº†Project Butterï¼Œå³â€œé»„æ²¹è®¡åˆ’â€ã€‚å°±åƒè¯¥è®¡åˆ’çš„åå­—é‚£æ ·ï¼ŒGoogleæœŸæœ›é€šè¿‡è¿™ä¸€æ–°çš„æœºåˆ¶å¯ä»¥è®©Androidç³»ç»Ÿæ‘†è„±UIäº¤äº’æ—¶ç»™ç”¨æˆ·å¸¦æ¥çš„æ»åæ„Ÿï¼Œä»è€Œåƒé»„æ²¹ä¸€æ ·é¡ºæ»‘ã€‚

å½“ç„¶ä¼˜åŒ–æ˜¯æ— æ­¢å¢ƒçš„ï¼ŒProject Butteråªæ˜¯è¿ˆå‡ºäº†é‡è¦çš„ç¬¬ä¸€æ­¥ï¼Œåç»­çš„Androidç‰ˆæœ¬ä¸­é™†ç»­ä¹Ÿæœ‰å¼•å…¥ä¸€äº›å…¶å®ƒçš„ä¼˜åŒ–æœºåˆ¶ï¼Œä¿ƒè¿›UIæ¸²æŸ“æ€§èƒ½çš„ä¸æ–­æå‡ã€‚

Project Butterå¯¹Android Displayç³»ç»Ÿè¿›è¡Œäº†é‡æ„ï¼Œå¼•å…¥äº†ä¸‰ä¸ªæ ¸å¿ƒå…ƒç´ ï¼š`**VSync**`ã€`**Triple Buffer**`å’Œ`**Choreographer**`ã€‚ä»è¿™ç¯‡æ–‡ç« å¼€å§‹ï¼Œæˆ‘ä»¬å°±æ¥çœ‹ä¸€çœ‹`VSync`çš„å®ç°æœºåˆ¶ã€‚

å…³äºå±å¹•åˆ·æ–°æœºåˆ¶ï¼Œæœ‰ä¸€å¼ å¾ˆç»å…¸çš„å›¾ç‰‡ï¼š

![](https://img2022.cnblogs.com/blog/979092/202204/979092-20220419093503734-1365434375.jpg)

æ•´ä¸ªæ˜¾ç¤ºè¿‡ç¨‹å°±æ˜¯ï¼š

*   `CPU`è®¡ç®—å±å¹•éœ€è¦çš„æ•°æ®ï¼Œç„¶åäº¤ç»™GPUã€‚
    
*   `GPU`å¯¹å›¾åƒè¿›è¡Œå¤„ç†ç»˜åˆ¶ï¼Œç„¶åå­˜åˆ°ç¼“å­˜åŒºã€‚
    
*   `display`å†ä»è¿™ä¸ªç¼“å­˜åŒºè¯»å–æ•°æ®ï¼Œæ˜¾ç¤ºå‡ºæ¥ã€‚
    

å¦‚æœå±å¹•çš„åˆ·æ–°ç‡æ˜¯60Hzï¼Œæ¯ä¸€å¸§éƒ½æ˜¯é‡å¤è¿™ä¸ªå·¥ä½œï¼Œä¹Ÿå°±æ˜¯1ç§’ä¸­éœ€è¦60æ¬¡è¿™æ ·å¾ªç¯æ“ä½œï¼Œæ¯æ¬¡æ“ä½œéœ€è¦çš„æ—¶é—´å°±çº¦ç­‰äº`16.6ms`ã€‚ä¹Ÿå°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„Androidç³»ç»Ÿä¸­ï¼Œä¼šæ¯éš”16.6msåˆ·æ–°ä¸€æ¬¡å±å¹•ã€‚

å¯ä»¥çœ‹åˆ°ï¼Œ16.6msä¸€åˆ°ï¼Œç³»ç»Ÿå°±å‘é€äº†`VSync`ä¿¡å·ï¼Œç„¶åå±å¹•ä¼šä»ç¼“å­˜åŒºè·å–äº†æ–°çš„ä¸€å¸§å›¾åƒå¹¶æ˜¾ç¤ºå‡ºæ¥ï¼Œä¸æ­¤åŒæ—¶ï¼ŒCPUä¹Ÿå¼€å§‹äº†ä¸‹ä¸€å¸§æ•°æ®çš„è®¡ç®—ï¼Œç„¶åè®¡ç®—å¥½äº¤ç»™GPUï¼Œæœ€åæ”¾åˆ°ç¼“å­˜åŒºï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡`VSync`ä¿¡å·ã€‚

åœ¨é˜…è¯»è¿™ç¯‡æ–‡ç« å‰ï¼Œæ¨èé˜…è¯»ä¸€ç¯‡æˆ‘è½¬è½½çš„æ–‡ç« ï¼š[èŠèŠAndroidå±å¹•åˆ·æ–°æœºåˆ¶ - Vsync / Double Buffer / Triple Buffer / æ‰å¸§ / æ’•è£‚](https://www.cnblogs.com/roger-yu/p/16162940.html)

äºŒã€VSYNCä¿¡å·çš„äº§ç”Ÿ
------------

* * *

### 2.1 VSyncä¿¡å·æœºåˆ¶çš„é€»è¾‘æ˜¯ä»å“ªé‡Œå¼€å§‹åˆå§‹åŒ–çš„å‘¢ï¼Ÿ

åœ¨å‰é¢çš„æ–‡ç«  Android 12(S) å›¾åƒæ˜¾ç¤ºç³»ç»Ÿ - SurfaceFlingerçš„å¯åŠ¨å’Œæ¶ˆæ¯é˜Ÿåˆ—å¤„ç†æœºåˆ¶ï¼ˆå››ï¼‰ä¸­æˆ‘ä»¬åœ¨è®²è§£`SurfaceFlinger::init`æ–¹æ³•æ—¶ï¼Œ`init`ä¼šå»åˆå§‹åŒ–HWComposerå¹¶æ³¨å†Œå›è°ƒå‡½æ•°ï¼Œå¦‚ä¸‹æ‘˜å½•çš„ä»£ç ï¼š

    [/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp]
    void SurfaceFlinger::init() {
        // åˆ›å»ºHWComposerå¯¹è±¡å¹¶ä¼ å…¥ä¸€ä¸ªnameå±æ€§ï¼Œå†é€šè¿‡mCompositionEngine->setHwComposerè®¾ç½®å¯¹è±¡å±æ€§ã€‚
        mCompositionEngine->setTimeStats(mTimeStats);
        mCompositionEngine->setHwComposer(getFactory().createHWComposer(mHwcServiceName));
        mCompositionEngine->getHwComposer().setCallback(this); // è¿™é‡Œçš„thiså°±æ˜¯SurfaceFlingerå¯¹è±¡æœ¬èº«ï¼Œå› ä¸ºå®ƒå®ç°äº†HWC2::ComposerCallbackå›è°ƒæ¥å£
    }

HWC2::ComposerCallbackä¸­å®šä¹‰äº† VSYNCä¿¡å·ã€æ’æ‹”æ˜¾ç¤ºå™¨ç­‰çš„å›è°ƒäº‹ä»¶æ–¹æ³•ï¼Œå¦‚ä¸‹ï¼š

    [/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.h]
    struct ComposerCallback {
        virtual void onComposerHalHotplug(hal::HWDisplayId, hal::Connection) = 0; // çƒ­æ’æ‹”äº‹ä»¶
        virtual void onComposerHalRefresh(hal::HWDisplayId) = 0; // refresh åˆ·æ–°äº‹ä»¶
        virtual void onComposerHalVsync(hal::HWDisplayId, int64_t timestamp, // VSYNCä¿¡å·äº‹ä»¶
                                        std::optional<hal::VsyncPeriodNanos>) = 0;
        ...
    };

æ ¹æ®HWC2::ComposerCallbackçš„è®¾è®¡é€»è¾‘ï¼ŒSurfaceFlinger::initæ–¹æ³•ä¸­è®¾ç½®å®ŒHWCçš„å›è°ƒåï¼Œä¼šç«‹å³æ”¶åˆ°ä¸€ä¸ªHotplugäº‹ä»¶ï¼Œå¹¶åœ¨SurfaceFlinger::onComposerHalHotplugä¸­å»å¤„ç†ï¼Œå› æ­¤æµç¨‹å°±èµ°åˆ°äº†ï¼š

    [/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp]
    void SurfaceFlinger::onComposerHalHotplug(hal::HWDisplayId hwcDisplayId,
                                              hal::Connection connection) {
        ...
        if (std::this_thread::get_id() == mMainThreadId) {
            // Process all pending hot plug events immediately if we are on the main thread.
            processDisplayHotplugEventsLocked(); // ä¸»çº¿ç¨‹ä¸­å»å¤„ç† hot plug evnets
        }
    }

å†çœ‹`processDisplayHotplugEventsLocked`çš„ä»£ç ï¼š

    [/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp]
    void SurfaceFlinger::processDisplayHotplugEventsLocked() {
            if (event.connection == hal::Connection::CONNECTED) {
                    if (event.hwcDisplayId == getHwComposer().getInternalHwcDisplayId()) {
                        initScheduler(state); // åˆå§‹åŒ–Scheduler
                    }
                    .....
    }

ä¸Šè¿°ä»£ç æˆ‘ä»¬åªå…³å¿ƒå’Œ`VSync`ä¿¡åç›¸å…³çš„é€»è¾‘ï¼Œé‚£å°±æ˜¯è°ƒç”¨äº†`initShceduler`

    [/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp]
    void SurfaceFlinger::initScheduler(const DisplayDeviceState& displayState) {
        if (mScheduler) { // åˆ¤æ–­mScheduleræ˜¯å¦ä¸ºç©ºï¼Œé¿å…é‡å¤åˆå§‹åŒ–
            // In practice it's not allowed to hotplug in/out the primary display once it's been
            // connected during startup, but some tests do it, so just warn and return.
            ALOGW("Can't re-init scheduler");
            return;
        }
        const auto displayId = displayState.physical->id;
        scheduler::RefreshRateConfigs::Config config =
                {.enableFrameRateOverride = android::sysprop::enable_frame_rate_override(false),
                 .frameRateMultipleThreshold =
                         base::GetIntProperty("debug.sf.frame_rate_multiple_threshold", 0)};
        // åˆ·æ–°ç‡çš„é…ç½®ä¿¡æ¯ï¼Œé‡Œé¢åŒ…å«äº†å½“å‰çš„å±å¹•åˆ·é¢‘ç‡ã€‚åˆ·æ–°å‘¨æœŸç­‰ä¿¡æ¯
        mRefreshRateConfigs =
                std::make_unique<scheduler::RefreshRateConfigs>(displayState.physical->supportedModes,
                                                                displayState.physical->activeMode
                                                                        ->getId(),
                                                                config);
        // currRefreshRateæ˜¯ä¸€ä¸ªFps Object,å…¶ä¸­å­˜å‚¨äº†åˆ·æ–°ç‡fpså’Œåˆ·æ–°å‘¨æœŸperiod
        const auto currRefreshRate = displayState.physical->activeMode->getFps();
        mRefreshRateStats = std::make_unique<scheduler::RefreshRateStats>(*mTimeStats, currRefreshRate,
                                                                          hal::PowerMode::OFF);
        // mVsyncConfiguration æ˜¯ä¸€ä¸ª VsyncConfiguration object
        // VsyncConfiguration ç±»ä¸­å°è£…äº†ä¸åŒåˆ·æ–°ç‡ä¸‹çš„VSYNCé…ç½®ä¿¡æ¯ã€‚app phase å°±æ˜¯vsyncSrcåç§»é‡ï¼Œsf phase æ˜¯sfVsyncSrcåç§»é‡ï¼Œ
        mVsyncConfiguration = getFactory().createVsyncConfiguration(currRefreshRate);
        // VsyncModulator object,VSYNCè°ƒåˆ¶å™¨ï¼Œæ ¹æ®äº‹åŠ¡è°ƒåº¦å’Œåˆ·æ–°ç‡çš„å˜åŒ–è°ƒæ•´VSYNCåç§»é‡ã€‚ 
        mVsyncModulator = sp<VsyncModulator>::make(mVsyncConfiguration->getCurrentConfigs());
    
        // åˆ›å»ºScheduler object
        mScheduler = getFactory().createScheduler(*mRefreshRateConfigs, *this);
        const auto configs = mVsyncConfiguration->getCurrentConfigs();
        const nsecs_t vsyncPeriod = currRefreshRate.getPeriodNsecs();
        // åˆ›å»ºä¸€ä¸ªConnection named "app"
        mAppConnectionHandle =
                mScheduler->createConnection("app", mFrameTimeline->getTokenManager(),
                                             /*workDuration=*/configs.late.appWorkDuration,
                                             /*readyDuration=*/configs.late.sfWorkDuration,
                                             impl::EventThread::InterceptVSyncsCallback());
        // åˆ›å»ºä¸€ä¸ªConnection named "appSf" 
        mSfConnectionHandle =
                mScheduler->createConnection("appSf", mFrameTimeline->getTokenManager(),
                                             /*workDuration=*/std::chrono::nanoseconds(vsyncPeriod),
                                             /*readyDuration=*/configs.late.sfWorkDuration,
                                             [this](nsecs_t timestamp) {
                                                 mInterceptor->saveVSyncEvent(timestamp);
                                             });
        //initVsyncä¸»è¦ä½œç”¨æ˜¯ç»‘å®šä¸€ä¸ªå›è°ƒå‡½æ•° MessageQueue::vsyncCallback åˆ°VSyncDispatchä¸Šï¼Œå›è°ƒåå­—"sf"
        mEventQueue->initVsync(mScheduler->getVsyncDispatch(), *mFrameTimeline->getTokenManager(),
                               configs.late.sfWorkDuration);
    
        mRegionSamplingThread =
                new RegionSamplingThread(*this, RegionSamplingThread::EnvironmentTimingTunables());
        mFpsReporter = new FpsReporter(*mFrameTimeline, *this);
    
        mScheduler->onPrimaryDisplayModeChanged(mAppConnectionHandle, displayId,
                                                displayState.physical->activeMode->getId(),
                                                vsyncPeriod);
        static auto ignorePresentFences =
                base::GetBoolProperty("debug.sf.vsync_reactor_ignore_present_fences"s, false);
        mScheduler->setIgnorePresentFences(
                ignorePresentFences ||
                getHwComposer().hasCapability(hal::Capability::PRESENT_FENCE_IS_NOT_RELIABLE));
    }

æˆ‘ä»¬å¯ä»¥`dumpsys SurfaceFlinger`çœ‹ä¸€çœ‹ï¼ŒVSyncDispatchä¸Šéƒ½ç»‘å®šäº†å“ªäº›Callbacksï¼Œå¦‚ä¸‹ä¿¡æ¯ï¼šæœ‰ä¸‰ä¸ª`â€œsfâ€,"appSf", "app"`æ˜¯ä¸æ˜¯å’Œæˆ‘ä»¬`initShceduler`

ä»£ç ä¸­çš„é€»è¾‘å†¥å†¥ä¹‹ä¸­æœ‰ç‚¹å‘¼åº”äº†...

    VSyncDispatch:
    	Timer:
    		DebugState: Waiting
    	mTimerSlack: 0.50ms mMinVsyncDistance: 3.00ms
    	mIntendedWakeupTime: 9223369916416.00ms from now
    	mLastTimerCallback: 4215.62ms ago mLastTimerSchedule: 4215.54ms ago
    	Callbacks:
    		sf:  
    			workDuration: 15.67ms readyDuration: 0.00ms earliestVsync: -11799.97ms relative to now
    			mLastDispatchTime: 4200.02ms ago
    		appSf:
    			workDuration: 16.67ms readyDuration: 15.67ms earliestVsync: -2153016.50ms relative to now
    			mLastDispatchTime: 2153016.50ms ago
    		app:  
    			workDuration: 16.67ms readyDuration: 15.67ms earliestVsync: -4183.37ms relative to now
    			mLastDispatchTime: 4183.37ms ago

å¯¹å‰é¢çš„æµç¨‹å°ç»“ä¸€ä¸‹ï¼Œå¤§æ¦‚å¦‚ä¸‹ï¼š

![](https://img2022.cnblogs.com/blog/979092/202204/979092-20220419104611189-732228162.png)

æ¥ä¸‹æ¥æˆ‘ä»¬æ·±å…¥`initShceduler`ç»†èŠ‚ï¼Œçœ‹çœ‹æ¯ä¸€æ­¥éª¤éƒ½å…·ä½“åšäº†ä»€ä¹ˆå·¥ä½œå‘¢ï¼Ÿ

### 2.2 åˆ›å»ºSchedulerå¯¹è±¡éƒ½åšäº†å•¥å­ï¼Ÿ

å¼€å¯åˆ›å»ºä¹‹æ—…....

    [/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp]
    void SurfaceFlinger::initScheduler(const DisplayDeviceState& displayState) {
        ...
        // start the EventThread
        mScheduler = getFactory().createScheduler(*mRefreshRateConfigs, *this); //åœ¨DefaultFactoryä¸­å»æ‰§è¡Œåˆ›å»ºæ“ä½œ
        ...
    }

DefaultFactoryä¸­ä¹Ÿå¾ˆç®€å•ï¼ŒSurfaceFlingeræœ‰å®ç°`ISchedulerCallback`å›è°ƒæ–¹æ³•ï¼Œå‚æ•°callbackæŒ‡å‘ä¸€ä¸ªSurfaceFlingerå¯¹è±¡ï¼Œå‚æ•°configsæ˜¯åˆ·æ–°ç‡çš„ä¿¡æ¯

    [ /frameworks/native/services/surfaceflinger/SurfaceFlingerDefaultFactory.cpp]
    std::unique_ptr<Scheduler> DefaultFactory::createScheduler(
            const scheduler::RefreshRateConfigs& configs, ISchedulerCallback& callback) {
        return std::make_unique<Scheduler>(configs, callback); // åˆ›å»ºSchedulerå¯¹è±¡ï¼ŒcallbackæŒ‡å‘ä¸€ä¸ªSurfaceFlinger Object
    }

è¿›åˆ°Schedulerçš„æ„é€ å‡½æ•°ï¼Œä¸‰ä¸ªæ„é€ å‡½æ•°ä¾æ¬¡è°ƒç”¨ï¼Œåˆå§‹åŒ–å¿…è¦æˆå‘˜å˜é‡ã€‚

    [/frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp]
    Scheduler::Scheduler(const scheduler::RefreshRateConfigs& configs, ISchedulerCallback& callback)
          : Scheduler(configs, callback,
                      {.supportKernelTimer = sysprop::support_kernel_idle_timer(false),
                       .useContentDetection = sysprop::use_content_detection_for_refresh_rate(false)}) {
    }
    
    Scheduler::Scheduler(const scheduler::RefreshRateConfigs& configs, ISchedulerCallback& callback,
                         Options options)
          : Scheduler(createVsyncSchedule(options.supportKernelTimer), configs, callback,//createVsyncScheduleæ˜¯ä¸»è¦çš„é€»è¾‘
                      createLayerHistory(configs), options) {
        ...
    }
    
    Scheduler::Scheduler(VsyncSchedule schedule, const scheduler::RefreshRateConfigs& configs,
                         ISchedulerCallback& schedulerCallback,
                         std::unique_ptr<LayerHistory> layerHistory, Options options)
          : mOptions(options),
            mVsyncSchedule(std::move(schedule)),
            mLayerHistory(std::move(layerHistory)),
            mSchedulerCallback(schedulerCallback),
            mRefreshRateConfigs(configs),
            mPredictedVsyncTracer(
                    base::GetBoolProperty("debug.sf.show_predicted_vsync", false)
                            ? std::make_unique<PredictedVsyncTracer>(*mVsyncSchedule.dispatch)
                            : nullptr) {
        mSchedulerCallback.setVsyncEnabled(false);// æ³¨æ„è¿™é‡Œï¼Œè®¾ç½®äº† VSync Enable Falseï¼Œå…³é—­äº†ç¡¬ä»¶VSync
    }

Scheduleræ„é€ å‡½æ•°ä¸­ï¼Œæœ€é‡è¦çš„ä¸€ä¸ªæ­¥éª¤å°±æ˜¯å»è°ƒç”¨äº†`createVsyncSchedule`æ–¹æ³•ï¼Œè¿™æ˜¯ä¸€ä¸ªæ ¸å¿ƒæ–¹æ³•ï¼Œåœ¨å…¶ä¸­åˆ›å»ºå’Œåˆå§‹åŒ–äº†å’ŒVSyncä¿¡å·äº§ç”Ÿã€åˆ†å‘ç›¸å…³çš„ç±»å¯¹è±¡å’Œè¿è¡Œé€»è¾‘ã€‚

æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-04-18 å‘å¸ƒäºåšå®¢å›­

    [/frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp]
    Scheduler::VsyncSchedule Scheduler::createVsyncSchedule(bool supportKernelTimer) {
        auto clock = std::make_unique<scheduler::SystemClock>();
        auto tracker = createVSyncTracker();  // åˆ›å»ºVSyncTrackerå¯¹è±¡
        auto dispatch = createVSyncDispatch(*tracker); // åˆ›å»ºVSyncDispatchå¯¹è±¡
    
        // TODO(b/144707443): Tune constants.
        constexpr size_t pendingFenceLimit = 20;
        auto controller =                   // åˆ›å»ºVSyncReactorå¯¹è±¡
                std::make_unique<scheduler::VSyncReactor>(std::move(clock), *tracker, pendingFenceLimit,
                                                          supportKernelTimer); 
        return {std::move(controller), std::move(tracker), std::move(dispatch)}; // æŠŠtracker,dispatch,controllerå°è£…åœ¨ä¸€ä¸ªVsyncSchedule strcutä¸­
    }

`createVsyncSchedule`æ–¹æ³•æœ€ç»ˆè¿”å›äº†ä¸€ä¸ª`VsyncSchedule`ç»“æ„ä½“å¯¹è±¡ã€‚`VsyncSchedule`æ˜¯ä¸€ä¸ªç»“æ„ä½“ç±»å‹ï¼Œå«æœ‰ä¸‰ä¸ªæˆå‘˜å˜é‡ï¼š`controllerã€trackerã€dispatch`ï¼Œè¿™ä¸‰ä¸ªæˆå‘˜åœ¨ VSyncæœºåˆ¶ä¸­åˆ†åˆ«å‘æŒ¥ä¸åŒä½œç”¨ï¼Œç­‰åˆ°ä¸‹é¢å†åˆ†æã€‚

    [/frameworks/native/services/surfaceflinger/Scheduler/Scheduler.h]
    struct VsyncSchedule {
        std::unique_ptr<scheduler::VsyncController> controller;
        std::unique_ptr<scheduler::VSyncTracker> tracker;
        std::unique_ptr<scheduler::VSyncDispatch> dispatch;
    };

**2.2.1 å…ˆçœ‹åˆ›å»º`VSyncTracker`åšäº†å•¥ï¼Ÿ**

    [/frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp]
    std::unique_ptr<scheduler::VSyncTracker> createVSyncTracker() {
        // TODO(b/144707443): Tune constants.
        constexpr int kDefaultRate = 60;
        constexpr auto initialPeriod = std::chrono::duration<nsecs_t, std::ratio<1, kDefaultRate>>(1);
        constexpr nsecs_t idealPeriod =
                std::chrono::duration_cast<std::chrono::nanoseconds>(initialPeriod).count();
        constexpr size_t vsyncTimestampHistorySize = 20;
        constexpr size_t minimumSamplesForPrediction = 6; // ä¸ºäº†é¢„æµ‹ã€æ¨¡æ‹ŸVSyncæœ€å°‘éœ€è¦é‡‡æ ·çš„ä¸ªæ•°
        constexpr uint32_t discardOutlierPercent = 20;
        return std::make_unique<scheduler::VSyncPredictor>(idealPeriod, vsyncTimestampHistorySize,
                                                           minimumSamplesForPrediction,
                                                           discardOutlierPercent);
    }

å®é™…åˆ›å»ºçš„æ˜¯ä¸€ä¸ªå®ç°ç±»`VsyncPredictor`å¯¹è±¡ï¼Œ`VSyncTracker`æ˜¯ä¸€ä¸ªåŸºäºå†å²Vsyncæ—¶é—´æ•°æ®æä¾›æœªæ¥Vsyncä¿¡å·æ—¶é—´ä¼°è®¡çš„æ¥å£ï¼Œ`VsyncPredictor`å®ç°äº†`VSyncTracker`ä¸­çš„æ–¹æ³•ã€‚

    [/frameworks/native/services/surfaceflinger/Scheduler/VSyncTracker.h]
    class VSyncTracker { //è™šåŸºç±»ï¼Œæ¥å£ç±»ï¼ŒVSyncTrackeræ˜¯ä¸€ä¸ªåŸºäºå†å²Vsyncæ—¶é—´æ•°æ®æä¾›æœªæ¥Vsyncä¿¡å·æ—¶é—´ä¼°è®¡çš„æ¥å£ã€‚
    
    [ /frameworks/native/services/surfaceflinger/Scheduler/VSyncPredictor.h]
    class VSyncPredictor : public VSyncTracker { //å®ç°VSyncTrackerçš„æ–¹æ³•

å…¶ä¸­æœ‰2ä¸ªæ–¹æ³•ï¼Œæ·»åŠ  é‡‡æ ·çš„vsync æ—¶é—´æˆ³ï¼Œä¸€èˆ¬æ¥è‡ªHWVsyncï¼ŒåŸºäºè¿™äº›Vsyncæ—¶é—´æ•°æ®æ¥è®­ç»ƒä¸€ä¸ªæ¨¡æ‹Ÿçš„VSyncæ¨¡å‹ï¼Œä»è€Œè¾¾åˆ°é¢„æµ‹æœªæ¥VSyncæ—¶é—´çš„ç›®çš„ã€‚

        /*
         * Adds a known timestamp from a vsync timing source (HWVsync signal, present fence)
         * to the model.
         */
        virtual bool addVsyncTimestamp(nsecs_t timestamp) = 0;
    
        /*
         * Access the next anticipated vsync time such that the anticipated time >= timePoint.
         * This will always give the best accurate at the time of calling; multiple
         * calls with the same timePoint might give differing values if the internal model
         * is updated.
         */
        virtual nsecs_t nextAnticipatedVSyncTimeFrom(nsecs_t timePoint) const = 0;

è‡³äºå¦‚ä½•è®¡ç®—ã€é¢„æµ‹çš„ï¼Œæœ¬æ–‡ä¸åšè®²è§£ã€‚

* * *

æˆ‘çš„ç†è§£æ˜¯ï¼šVSyncä¿¡å·æ˜¯ç”±HWCç¡¬ä»¶æ¨¡å—æ ¹æ®å±å¹•åˆ·æ–°ç‡äº§ç”Ÿã€‚`VSyncTracker`ã€`VsyncPredictor`æ ¹æ®HWCäº§ç”Ÿçš„ç¡¬ä»¶VSyncä¿¡å·ï¼Œè®­ç»ƒäº†ä¸€ä¸ªæ¨¡æ‹Ÿçš„VSyncäº‹ä»¶æºï¼Œå¯ä»¥é¢„æµ‹vsyncäº‹ä»¶çš„æ—¶é—´ç‚¹ã€‚

* * *

**2.2.2 åˆ›å»ºVSyncDispatchåšäº†å•¥å­å‘¢ï¼Ÿ**

å…ˆç…ç…ä»£ç å§ï¼Œå¾ˆç®€å•åˆ›å»ºäº†ä¸€ä¸ª`VSyncDispatchTimerQueue`å¯¹è±¡ï¼Œè¿™åˆæ˜¯ä¸ªä»€ä¹ˆé¬¼ï¼Ÿ

    [/frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp]
    std::unique_ptr<scheduler::VSyncDispatch> createVSyncDispatch(scheduler::VSyncTracker& tracker) {
        // TODO(b/144707443): Tune constants.
        constexpr std::chrono::nanoseconds vsyncMoveThreshold = 3ms;
        constexpr std::chrono::nanoseconds timerSlack = 500us;
        return std::make_unique<
                scheduler::VSyncDispatchTimerQueue>(std::make_unique<scheduler::Timer>(), tracker,
                                                    timerSlack.count(), vsyncMoveThreshold.count());
    }

å…ˆçœ‹çœ‹å®šä¹‰å§

    [/frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatch.h]
    class VSyncDispatch { // ç”¨äºåˆ†å‘å’Œç³»ç»ŸVSyncäº‹ä»¶ç›¸å…³çš„å›è°ƒäº‹ä»¶
    
    [/frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp]
    // VSyncDispatchTimerQueueæ˜¯ä¸€ä¸ªç±»ï¼Œå®ƒå°†ä½¿ç”¨å•ä¸ªè®¡æ—¶å™¨é˜Ÿåˆ—æŒ‰ç…§VSyncDispatchæ¥å£è°ƒåº¦å›è°ƒã€‚
    class VSyncDispatchTimerQueue : public VSyncDispatch { 

æ ¹æ®ä»£ç æ³¨é‡Šå’ŒåŸºæœ¬çš„é€»è¾‘ï¼Œæˆ‘å¤§æ¦‚ç†è§£çš„æ˜¯ï¼š

`VSyncDispatchTimerQueue(VSyncDispatch)`è´Ÿè´£åˆ†å‘VSyncå›è°ƒäº‹ä»¶ï¼Œéœ€è¦æ¥æ”¶VSyncäº‹ä»¶çš„æ¨¡å—å¯ä»¥é€šè¿‡registerCallbackå‘å…¶ä¸­æ³¨å†Œå›è°ƒå‡½æ•°ï¼Œæ‰€æœ‰çš„å›è°ƒéƒ½ä¿å­˜åœ¨äº†`CallbackMap mCallbacks`ï¼Œå½“åˆ°äº†VSyncå‘ç”Ÿçš„æ—¶é—´å°±ä¼šéå†æ³¨å†Œçš„å›è°ƒï¼ŒæŠŠVSyncäº‹ä»¶åˆ†å‘å‡ºå»ã€‚

**2.2.3 è¿˜åˆ›å»ºäº†ä¸€ä¸ªVsyncControllerå¯¹è±¡**

        auto controller =
                std::make_unique<scheduler::VSyncReactor>(std::move(clock), *tracker, pendingFenceLimit,
                                                          supportKernelTimer);

VSyncReactorç»§æ‰¿äº†VsyncControllerå¹¶å®ç°å…¶ä¸­çš„æ–¹æ³•ï¼ŒVSyncReactorä¸­å«æœ‰ä¸€ä¸ªVSyncTrackeræˆå‘˜ã€‚çœ‹å®ƒçš„ä»£ç ï¼ŒVSyncReactorå¯¹å¤–æä¾›`addPresentFence``addHwVsyncTimestamp`æ–¹æ³•ï¼ŒæŠŠHWVsync signal, present fenceçš„vsync timing sourceä¼ é€’ç»™VSyncTrackerç”¨äºVSync modelçš„è®­ç»ƒã€‚

**è¿™ä¸€å—çš„é€»è¾‘ï¼Œæ¶‰åŠåˆ°å„ç§ç±»ï¼Œçœ‹èµ·æ¥å¾ˆæ˜¯çº·ç¹å¤æ‚ï¼Œæˆ‘è‡ªå·±éƒ½ç»•æ¥ç»•å»çœ‹æ™•äº†ï¼Œå¯¹äºå¤§å¤šæ•°äººæ¥è¯´ï¼Œè¿™å—çš„é€»è¾‘æ˜¯ä¸ä¼šå»ä¿®æ”¹çš„ï¼Œé‚£æˆ‘ä¹Ÿå°±ç®€å•çœ‹çœ‹å§ã€‚**

**æœ¬æ–‡ä¸­å¾ˆå¤šæµç¨‹ä¹Ÿæ˜¯è‡ªå·±çŒœæµ‹çš„ï¼Œå¤§æ¦‚ä¹Ÿä¸æ­£ç¡®å§**

ç®€å•æ€»ç»“ä¸‹ä¸Šé¢çš„å„ç§ç±»çš„ä½œç”¨ï¼š

**æ¥å£ç±»**

**å®ç°ç±»**

**ä½œç”¨**

VSyncTracker

VSyncPredictor

æ ¹æ®é‡‡æ ·çš„ç¡¬ä»¶VSyncï¼Œå»ºç«‹ä¸€ä¸ªæ¨¡æ‹Ÿçš„VSyncæ¨¡å‹ï¼ŒåŸºäºå†å²Vsyncæ—¶é—´æ•°æ®æ¥é¢„æµ‹æœªæ¥Vsyncä¿¡å·å‘ç”Ÿçš„æ—¶é—´ç‚¹

VSyncDispatch

VSyncDispatchTimerQueue

åˆ†å‘VSyncå›è°ƒäº‹ä»¶

VsyncController

VSyncReactor

é…åˆVSyncTrackerè¿›è¡Œç¡¬ä»¶VSyncçš„é‡‡æ ·

æœ¬æ–‡ä½œè€…@[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)Â  2022-04-18 å‘å¸ƒäºåšå®¢å›­

**çœ‹åˆ°è¿™é‡Œæœ‰ä¸ªç–‘é—®ï¼šVSyncäº‹ä»¶å…·ä½“æ˜¯ä»å“ªé‡Œåˆ†å‘å‡ºå»çš„å‘¢ï¼Ÿ**

å½“æŸä¸€äº›é€»è¾‘éœ€è¦ä½¿ç”¨VSyncäº‹ä»¶é©±åŠ¨æ—¶ï¼Œä¸€èˆ¬ä¼šå»è°ƒç”¨ï¼š

`VSyncDispatchTimerQueue::schedule` ==> `VSyncDispatchTimerQueue::rearmTimerSkippingUpdateFor`\==> `VSyncDispatchTimerQueue::setTimer`

æ¯”å¦‚ä¸‹é¢å°±æ˜¯invalidateçš„è°ƒç”¨æ ˆä¿¡æ¯

    11-13 01:15:27.751   225   624 E SurfaceFlinger: stackdump:#00 pc 000c405f  /system/bin/surfaceflinger (android::scheduler::VSyncDispatchTimerQueue::rearmTimerSkippingUpdateFor(long long, std::__1::__hash_map_iterator<std::__1::__hash_iterator<std::__1::__hash_node<std::__1::__hash_value_type<android::StrongTyping<unsigned int, android::scheduler::CallbackTokenTag, android::Compare, android::Hash>, std::__1::shared_ptr<android::scheduler::VSyncDispatchTimerQueueEntry> >, void*>*> > const&)+686)
    11-13 01:15:27.751   225   624 E SurfaceFlinger: stackdump:#01 pc 000c4a99  /system/bin/surfaceflinger (android::scheduler::VSyncDispatchTimerQueue::schedule(android::StrongTyping<unsigned int, android::scheduler::CallbackTokenTag, android::Compare, android::Hash>, android::scheduler::VSyncDispatch::ScheduleTiming)+728)
    11-13 01:15:27.751   225   624 E SurfaceFlinger: stackdump:#02 pc 000c5057  /system/bin/surfaceflinger (android::scheduler::VSyncCallbackRegistration::schedule(android::scheduler::VSyncDispatch::ScheduleTiming)+40)
    11-13 01:15:27.751   225   624 E SurfaceFlinger: stackdump:#03 pc 000b9beb  /system/bin/surfaceflinger (android::impl::MessageQueue::invalidate()+90)

setTimerä¸­ä¼šå»è®¾ç½®ä¸€ä¸ªå®šæ—¶å™¨ï¼Œå®šæ—¶æ—¶é—´åˆ°æ¥æ—¶ï¼Œå°±ä¼šå›è°ƒ `VSyncDispatchTimerQueue::timerCallback`ï¼Œåœ¨è¿™ä¸ªå‡½æ•°ä¸­éå†æ‰€æœ‰çš„callbacksï¼Œè¿›è¡ŒVSyncäº‹ä»¶åˆ†å‘ã€‚

**é‚£è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼šéƒ½æœ‰å“ªäº›æ¨¡å—æˆ–é€»è¾‘ä½¿ç”¨`VSyncDispatchTimerQueue::registerCallback`æ³¨å†Œäº†å›è°ƒæ¥ç›‘å¬VSyncäº‹ä»¶å‘¢ï¼Ÿ**

æˆ‘ä»¬å†å›åˆ°SurfaceFlingerä¸­çš„initScheduleræ–¹æ³•ï¼Œç»§ç»­ä¹‹å‰çš„åˆ†æ

### 2.3 createConnectionæ˜¯ä½•æ–¹ç¥åœ£ï¼Ÿ

    mAppConnectionHandle =
                mScheduler->createConnection("app", mFrameTimeline->getTokenManager(),
                                             /*workDuration=*/configs.late.appWorkDuration,
                                             /*readyDuration=*/configs.late.sfWorkDuration,
                                             impl::EventThread::InterceptVSyncsCallback());

å…ˆçœ‹çœ‹ä»£ç å§

    Scheduler::ConnectionHandle Scheduler::createConnection(
            const char* connectionName, frametimeline::TokenManager* tokenManager,
            std::chrono::nanoseconds workDuration, std::chrono::nanoseconds readyDuration,
            impl::EventThread::InterceptVSyncsCallback interceptCallback) {
        auto vsyncSource = makePrimaryDispSyncSource(connectionName, workDuration, readyDuration); //åˆ›å»ºäº†ä¸€ä¸ªDispSyncSourceå¯¹è±¡
        auto throttleVsync = makeThrottleVsyncCallback();
        auto getVsyncPeriod = makeGetVsyncPeriodFunction();
        auto eventThread = std::make_unique<impl::EventThread>(std::move(vsyncSource), tokenManager, // åˆ›å»ºäº†ä¸€ä¸ªEventThreadå¯¹è±¡
                                                               std::move(interceptCallback),
                                                               std::move(throttleVsync),
                                                               std::move(getVsyncPeriod));
        return createConnection(std::move(eventThread));
    }

ä¸Šé¢çš„æ–¹æ³•ä¸­å¹²äº†ä¸¤ä»¶å¤§äº‹ï¼šåˆ›å»ºDispSyncSourceå¯¹è±¡å’ŒEventThreadå¯¹è±¡

**åˆ›å»ºDispSyncSourceå¯¹è±¡åšäº†å•¥ï¼Ÿ**

    std::unique_ptr<VSyncSource> Scheduler::makePrimaryDispSyncSource(
            const char* name, std::chrono::nanoseconds workDuration,
            std::chrono::nanoseconds readyDuration, bool traceVsync) {
        // mVsyncSchedule.dispatch å°±æ˜¯åœ¨Scheduleråˆ›å»ºæ—¶ï¼Œåˆ›å»ºçš„VSyncDispatchTimerQueueå¯¹è±¡
        return std::make_unique<scheduler::DispSyncSource>(*mVsyncSchedule.dispatch, workDuration,
                                                           readyDuration, traceVsync, name);
    }

å†çœ‹DispSyncSourceçš„æ„é€ å‡½æ•°ï¼š

    DispSyncSource::DispSyncSource(scheduler::VSyncDispatch& vSyncDispatch,
                                   std::chrono::nanoseconds workDuration,
                                   std::chrono::nanoseconds readyDuration, bool traceVsync,
                                   const char* name)
          : mName(name),
            mValue(base::StringPrintf("VSYNC-%s", name), 0),
            mTraceVsync(traceVsync),
            mVsyncOnLabel(base::StringPrintf("VsyncOn-%s", name)),
            mWorkDuration(base::StringPrintf("VsyncWorkDuration-%s", name), workDuration),
            mReadyDuration(readyDuration) {
        mCallbackRepeater =
                std::make_unique<CallbackRepeater>(vSyncDispatch,
                                                   std::bind(&DispSyncSource::onVsyncCallback, this,
                                                             std::placeholders::_1,
                                                             std::placeholders::_2,
                                                             std::placeholders::_3),
                                                   name, workDuration, readyDuration,
                                                   std::chrono::steady_clock::now().time_since_epoch());
    }

DispSyncSourceä¸­åˆå§‹åŒ–äº†ä¸€äº›æˆå‘˜å˜é‡ï¼Œåˆ›å»ºäº†ä¸€ä¸ª å¯¹è±¡

    CallbackRepeater(VSyncDispatch& dispatch, VSyncDispatch::Callback cb, const char* name,
                         std::chrono::nanoseconds workDuration, std::chrono::nanoseconds readyDuration,
                         std::chrono::nanoseconds notBefore)
              : mName(name),
                mCallback(cb), // å­˜å‚¨å›è°ƒå‡½æ•°ï¼ŒæŒ‡å‘ DispSyncSource::onVsyncCallback
                mRegistration(dispatch,  //   mRegistrationæ˜¯ä¸€ä¸ªVSyncCallbackRegistrationå¯¹è±¡ï¼Œç»‘å®šäº†å›è°ƒåˆ°CallbackRepeater::callbackå‡½æ•°
                              std::bind(&CallbackRepeater::callback, this, std::placeholders::_1,
                                        std::placeholders::_2, std::placeholders::_3),
                              mName),
                mStarted(false),
                mWorkDuration(workDuration),
                mReadyDuration(readyDuration),
                mLastCallTime(notBefore) {}

VSyncCallbackRegistrationæ„é€ å‡½æ•°ï¼Œ

    VSyncCallbackRegistration::VSyncCallbackRegistration(VSyncDispatch& dispatch,
                                                         VSyncDispatch::Callback const& callbackFn,
                                                         std::string const& callbackName)
          : mDispatch(dispatch),
            mToken(dispatch.registerCallback(callbackFn, callbackName)), // æ³¨å†Œäº†å›è°ƒï¼ŒcallbackFnæŒ‡å‘CallbackRepeater::callback
            mValidToken(true) {}

ä¸Šé¢çš„æµç¨‹å°±å¯ä»¥çœ‹åˆ°ï¼šæœ€ç»ˆè°ƒç”¨äº† VSyncDispatchTimerQueue::registerCallback å‡½æ•°ï¼Œå¹¶ä¸”è¿™ä¸ªå›è°ƒå‡½æ•°ç»‘å®šçš„æ˜¯ CallbackRepeater::callback

    void callback(nsecs_t vsyncTime, nsecs_t wakeupTime, nsecs_t readyTime) {
            ...
            mCallback(vsyncTime, wakeupTime, readyTime); // mCallback æŒ‡å‘ DispSyncSource::onVsyncCallback
           ...
        }

DispSyncSource::onVsyncCallbackç»§ç»­åˆ†å‘

    [/frameworks/native/services/surfaceflinger/Scheduler/DispSyncSource.cpp]
    void DispSyncSource::onVsyncCallback(nsecs_t vsyncTime, nsecs_t targetWakeupTime,
                                         nsecs_t readyTime) {
        VSyncSource::Callback* callback;
        {
            std::lock_guard lock(mCallbackMutex);
            callback = mCallback;
        }
        ....
        if (callback != nullptr) {
            callback->onVSyncEvent(targetWakeupTime, vsyncTime, readyTime);
        }
    }

**DispSyncSourceä¸­mCallbackæ˜¯è°è®¾ç½®çš„å‘¢ï¼ŸæŒ‡å‘å“ªé‡Œï¼Ÿ ç­”æ¡ˆæ˜¯ EventThread ï¼Œç¨åæˆ‘ä»¬æ¥çœ‹**  

Scheduler::createConnectionåˆ›å»ºå®ŒDispSyncSourceåï¼Œé©¬ä¸Šå»åˆ›å»ºäº†ä¸€ä¸ªEventThreadå¯¹è±¡ï¼Œå¹¶ä¸”æŠŠDispSyncSourceå¯¹è±¡ä½œä¸ºå‚æ•°ä¼ é€’è¿‡å»äº†

çœ‹çœ‹EventThreadçš„æ„é€ å‡½æ•°

    [/frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp]
    EventThread::EventThread(std::unique_ptr<VSyncSource> vsyncSource,
                             android::frametimeline::TokenManager* tokenManager,
                             InterceptVSyncsCallback interceptVSyncsCallback,
                             ThrottleVsyncCallback throttleVsyncCallback,
                             GetVsyncPeriodFunction getVsyncPeriodFunction)
          : mVSyncSource(std::move(vsyncSource)), // ä¿å­˜ DispVSyncSource å¯¹è±¡
            mTokenManager(tokenManager),
            mInterceptVSyncsCallback(std::move(interceptVSyncsCallback)),
            mThrottleVsyncCallback(std::move(throttleVsyncCallback)),
            mGetVsyncPeriodFunction(std::move(getVsyncPeriodFunction)),
            mThreadName(mVSyncSource->getName()) {
    
        LOG_ALWAYS_FATAL_IF(getVsyncPeriodFunction == nullptr,
                "getVsyncPeriodFunction must not be null");
    
        mVSyncSource->setCallback(this); // ä¸º DispVSyncSource è®¾ç½®å›è°ƒ
        // å¼€å¯æ–°çº¿ç¨‹ï¼Œæ‰§è¡ŒthreadMain
        mThread = std::thread([this]() NO_THREAD_SAFETY_ANALYSIS {
            std::unique_lock<std::mutex> lock(mMutex);
            threadMain(lock);
        });
        ...
    }

æ‰€ä»¥æœ€ç»ˆVSyncäº‹ä»¶ä¼šæ¥åˆ° EventThread::onVSyncEvent ä¸­ï¼Œè¯¥æ–¹æ³•ä¼šæŠŠäº‹ä»¶å°è£…åå­˜åˆ° mPendingEvents å¹¶å”¤é†’ EventThread::threadMain åšè¿›ä¸€æ­¥çš„åç»­å¤„ç†ã€‚

ç®€å•æ€»ç»“ä¸‹æ•´ä¸ª VSyncäº‹ä»¶ å›è°ƒçš„æµç¨‹ï¼š

![](https://img2022.cnblogs.com/blog/979092/202204/979092-20220419162030046-1934720951.png)

å®é™…éªŒè¯ä¸€ä¸‹ï¼Œæ‰“å°è°ƒç”¨æ ˆä¿¡æ¯ï¼šæ˜¯ä¸æ˜¯ä¸ªä¸Šé¢çš„æµç¨‹å›¾ä¸€è‡´ ğŸ¤¡

    11-13 01:15:27.168   223   464 E EventThread: stackdump:#00 pc 000b49e9  /system/bin/surfaceflinger (android::impl::EventThread::onVSyncEvent(long long, long long, long long)+88)
    11-13 01:15:27.168   223   464 E EventThread: stackdump:#01 pc 000b3267  /system/bin/surfaceflinger (android::scheduler::DispSyncSource::onVsyncCallback(long long, long long, long long)+122)
    11-13 01:15:27.168   223   464 E EventThread: stackdump:#02 pc 000b381b  /system/bin/surfaceflinger (std::__1::__function::__func<std::__1::__bind<void (android::scheduler::DispSyncSource::*)(long long, long long, long long), android::scheduler::DispSyncSource*, std::__1::placeholders::__ph<1> const&, std::__1::placeholders::__ph<2> const&, std::__1::placeholders::__ph<3> const&>, std::__1::allocator<std::__1::__bind<void (android::scheduler::DispSyncSource::*)(long long, long long, long long), android::scheduler::DispSyncSource*, std::__1::placeholders::__ph<1> const&, std::__1::placeholders::__ph<2> const&, std::__1::placeholders::__ph<3> const&> >, void (long long, long long, long long)>::operator()(long long&&, long long&&, long long&&)+52)
    11-13 01:15:27.168   223   464 E EventThread: stackdump:#03 pc 000b387b  /system/bin/surfaceflinger (android::scheduler::CallbackRepeater::callback(long long, long long, long long)+86)
    11-13 01:15:27.168   223   464 E EventThread: stackdump:#04 pc 000b396f  /system/bin/surfaceflinger (std::__1::__function::__func<std::__1::__bind<void (android::scheduler::CallbackRepeater::*)(long long, long long, long long), android::scheduler::CallbackRepeater*, std::__1::placeholders::__ph<1> const&, std::__1::placeholders::__ph<2> const&, std::__1::placeholders::__ph<3> const&>, std::__1::allocator<std::__1::__bind<void (android::scheduler::CallbackRepeater::*)(long long, long long, long long), android::scheduler::CallbackRepeater*, std::__1::placeholders::__ph<1> const&, std::__1::placeholders::__ph<2> const&, std::__1::placeholders::__ph<3> const&> >, void (long long, long long, long long)>::operator()(long long&&, long long&&, long long&&)+52)
    11-13 01:15:27.168   223   464 E EventThread: stackdump:#05 pc 000c3d57  /system/bin/surfaceflinger (android::scheduler::VSyncDispatchTimerQueue::timerCallback()+738)
    11-13 01:15:27.168   223   464 E EventThread: stackdump:#06 pc 000c3675  /system/bin/surfaceflinger (android::scheduler::Timer::dispatch()+580)

è¿™æ ·é€šè¿‡å‰é¢çš„ä¸€ç³»åˆ—æµç¨‹çš„è·Ÿè¸ªï¼Œå¤§ä½“ç†æ¸…æ¥šäº† VSync Eventé€šè¿‡å±‚å±‚callbackï¼Œæœ€ç»ˆæ¥åˆ°äº†EventThread::onVSyncEvent ä¸­è¿›è¡Œå¤„ç†ã€‚å½“ç„¶åé¢å¦‚ä½•é€šçŸ¥åˆ° SF & APPä¹‹åå†æ…¢æ…¢åˆ†æã€‚

æˆ‘ä»¬å†å›åˆ°SurfaceFlingerä¸­çš„initScheduleræ–¹æ³•ï¼Œç»§ç»­ä¹‹å‰çš„åˆ†æ

SurfaceFlinger::initScheduleræ–¹æ³•ä¸­ï¼Œè¿ç»­åˆ›å»ºäº†2ä¸ª Connection ï¼Œä¸€ä¸ªåå­—æ˜¯â€œappâ€,ä¸€ä¸ªåå­—æ˜¯â€œappSfâ€ï¼Œæ¯ä¸ªConnectionéƒ½æœ‰å„è‡ªå¯¹åº”ä¸€ä¸ªEventThreadã€‚  

### 2.4 mEventQueue->initVsync è¿™åˆåšäº†å•¥

    mEventQueue->initVsync(mScheduler->getVsyncDispatch(), *mFrameTimeline->getTokenManager(),
                               configs.late.sfWorkDuration);

çœ‹çœ‹initVsyncçš„å®šä¹‰å§

    [/frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp]
    void MessageQueue::initVsync(scheduler::VSyncDispatch& dispatch,
                                 frametimeline::TokenManager& tokenManager,
                                 std::chrono::nanoseconds workDuration) {
        setDuration(workDuration);// mVsync.scheduledåˆå§‹ä¸ºfalse, setDurationä¸­åªæ˜¯ä¿å­˜mVsync.workDuration = workDuration;
        mVsync.tokenManager = &tokenManager;
        mVsync.registration = std::make_unique<
                scheduler::VSyncCallbackRegistration>(dispatch, // å‘ VSyncDispatch ä¸­æ³¨å†Œå›è°ƒï¼Œç»‘å®šåˆ° MessageQueue::vsyncCallback 
                                                      std::bind(&MessageQueue::vsyncCallback, this,
                                                                std::placeholders::_1,
                                                                std::placeholders::_2,
                                                                std::placeholders::_3),
                                                      "sf");
    }

æ˜¯ä¸æ˜¯å’Œå‰é¢è®²çš„CallbackRepeaterçš„å¾ˆç›¸ä¼¼çš„å¤„ç†é€»è¾‘ï¼Œé€šè¿‡æ„å»ºVSyncCallbackRegistrationå¯¹è±¡ï¼Œå‘VsyncDispatchä¸­æ³¨å†Œäº†å›è°ƒï¼Œè€Œä¸”åå­—æ˜¯â€œsfâ€,è¿™æ ·MessageQueue::vsyncCallbackä¸­å°±å¯ä»¥æ”¶åˆ° vsync eventäº†

å®é™…éªŒè¯ä¸€ä¸‹ï¼Œæ‰“å°è°ƒç”¨æ ˆä¿¡æ¯ï¼šæ˜¯ä¸æ˜¯å’Œåˆ†æä¸€è‡´ ğŸ¤¡

    11-13 01:15:43.899   224   529 E SurfaceFlinger: stackdump:#00 pc 000b9837  /system/bin/surfaceflinger (android::impl::MessageQueue::vsyncCallback(long long, long long, long long)+134)
    11-13 01:15:43.899   224   529 E SurfaceFlinger: stackdump:#01 pc 000b9f63  /system/bin/surfaceflinger (std::__1::__function::__func<std::__1::__bind<void (android::impl::MessageQueue::*)(long long, long long, long long), android::impl::MessageQueue*, std::__1::placeholders::__ph<1> const&, std::__1::placeholders::__ph<2> const&, std::__1::placeholders::__ph<3> const&>, std::__1::allocator<std::__1::__bind<void (android::impl::MessageQueue::*)(long long, long long, long long), android::impl::MessageQueue*, std::__1::placeholders::__ph<1> const&, std::__1::placeholders::__ph<2> const&, std::__1::placeholders::__ph<3> const&> >, void (long long, long long, long long)>::operator()(long long&&, long long&&, long long&&)+52)
    11-13 01:15:43.900   224   529 E SurfaceFlinger: stackdump:#02 pc 000c3ccf  /system/bin/surfaceflinger (android::scheduler::VSyncDispatchTimerQueue::timerCallback()+714)
    11-13 01:15:43.900   224   529 E SurfaceFlinger: stackdump:#03 pc 000c3605  /system/bin/surfaceflinger (android::scheduler::Timer::dispatch()+580)

çœ‹åˆ°è¿™é‡Œï¼Œæ˜¯ä¸æ˜¯å°±æ¸…æ¥šäº†ï¼Œæ–‡ç« å¼€å¤´ï¼Œdumpsys SurfaceFlinger çœ‹åˆ°çš„ VSyncDispatch ä¸­çš„ä¸‰ä¸ªå›è°ƒï¼ˆsf, appSf, appï¼‰æ˜¯æ€ä¹ˆæ¥çš„äº†

    VSyncDispatch:
    	Timer:
    		DebugState: Waiting
    	mTimerSlack: 0.50ms mMinVsyncDistance: 3.00ms
    	mIntendedWakeupTime: 9223369916416.00ms from now
    	mLastTimerCallback: 4215.62ms ago mLastTimerSchedule: 4215.54ms ago
    	Callbacks: ä¸‰ä¸ªå›è°ƒ
    		sf:  
    			workDuration: 15.67ms readyDuration: 0.00ms earliestVsync: -11799.97ms relative to now
    			mLastDispatchTime: 4200.02ms ago
    		appSf:
    			workDuration: 16.67ms readyDuration: 15.67ms earliestVsync: -2153016.50ms relative to now
    			mLastDispatchTime: 2153016.50ms ago
    		app:  
    			workDuration: 16.67ms readyDuration: 15.67ms earliestVsync: -4183.37ms relative to now

### **æ€»ç»“é‡ç‚¹**

**æ”¶åˆ°vsync eventsçš„æ±‡é›†åˆ°äº†ä¸¤ä¸ªåœ°æ–¹ï¼š**

**1\. MessageQueue::vsyncCallbackÂ  ==> VSYNC-sf**

**2\. EventThread::onVSyncEventÂ  ==> VSYNC-appÂ  & VSYNC-appSf**

**æœ‰ä¸ªç–‘é—®ï¼šVSyncDispatch ä¸­çš„ä¸‰ä¸ªå›è°ƒï¼ˆsf, appSf, appï¼‰ï¼Œä»–ä»¬çš„ç”¨é€”åˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæˆ–è€…è¯´ä»–ä»¬äº§ç”Ÿçš„å›è°ƒç”¨æ¥é©±åŠ¨å»åšä»€ä¹ˆäº‹æƒ…å‘¢ï¼Ÿ**

ä¸‰ã€å°ç»“
----

è¿™ç¯‡æ–‡ç« ï¼Œä¸»è¦åˆ†æäº†VSyncç›¸å…³çš„ä¸€äº›åˆå§‹åŒ–çš„è¿‡ç¨‹ï¼ŒåŒ…æ‹¬å’Œ vsync eventçš„äº§ç”Ÿå’Œåˆ†å‘ç›¸å…³çš„ç»„ä»¶åŠäº‹ä»¶å›è°ƒçš„æµç¨‹ã€‚

å½“ç„¶ï¼Œå…³äºvsyncçš„å¾ˆå¤šç»†èŠ‚è¿˜æ˜¯æ²¡åˆ†ææ¸…æ¥šï¼Œä¹Ÿæœ‰å¾ˆå¤šç–‘é—®æ²¡è§£å†³ã€‚å†æ¥ä¸‹æ¥çš„æ–‡ç« ä¸­ä¼šå†ç»§ç»­ç ”ç©¶ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½å¾—åˆ°æ›´å¤šçš„å¯å‘ä¸ç†è§£ã€‚

å‚è€ƒï¼š

https://juejin.cn/post/6844904013914374152

https://juejin.cn/post/7045996528942448648

https://blog.csdn.net/houliang120/article/details/50908098

å¿ƒæœ‰çŒ›è™ï¼Œç»†å—…è”·è–‡ï¼Œç”Ÿæ´»å°±è¯¥æ— æƒ§æ— æ‚”

* * *

![](https://img2022.cnblogs.com/blog/979092/202203/979092-20220322104528841-687741034.jpg)

ä½œè€…ï¼š[](https://www.cnblogs.com/roger-yu)[äºŒçš„æ¬¡æ–¹](https://www.cnblogs.com/roger-yu/)

å‡ºå¤„ï¼š[](https://www.cnblogs.com/roger-yu)[https://www.cnblogs.com/roger-yu/p/16075956.html](https://www.cnblogs.com/roger-yu/p/16075956.html)

æœ¬æ–‡ç‰ˆæƒå½’ä½œè€…å’Œåšå®¢å›­å…±æœ‰ï¼Œè½¬è½½å¿…é¡»ç»™å‡ºåŸæ–‡é“¾æ¥ï¼Œå¹¶ä¿ç•™æ­¤æ®µå£°æ˜ï¼Œå¦åˆ™ä¿ç•™è¿½ç©¶æ³•å¾‹è´£ä»»çš„æƒåˆ©