---
layout: post
title: "Docker详解（上）"
date: "2022-07-17T21:16:12.177Z"
---
Docker详解（上）
===========

> Docker 学习

*   Docker概述
*   Docker安装
*   Docker命令
    *   镜像命令
    *   容器命令
    *   操作命令
    *   ...
*   Docker镜像
*   容器数据卷
*   DockerFile
*   Docker网络原理
*   IDEA整合Docker
*   Docker Compose
*   Docker Swarm
*   CI/CD Jenkins

Docker概述
--------

### Docker为什么出现？

一款产品：开发 --> 上线 两套环境！应用环境，应用配置！

开发 --> 运维 问题：我在我的电脑上可以运行！版本更新，导致服务不可用！对于运维来说，考验就十分大！

环境配置是十分的麻烦，每一个机器都要部署环境（集群Redis、ES、Hadoop......）！费时费力。

发布一个项目（jar + （Redis MySQL jdk ES）），项目能不能都带上环境安装打包！

之前在服务器配置一个应用环境 Redis MySQL jdk ES Hadoop，配置十分麻烦，不能够跨平台。

Windows，最后发布到Linux！

传统：开发 jar，运维来做！

现在：开发打包部署上线，一套流程做完！

Java --> apk --> 发布（应用商店） --> 张三使用apk --> 安装即可用！

Java --> jar（环境） --> 打包项目带上环境（镜像） --> （Docker仓库：商店） --> 下载我们发布的镜像 --> 直接运行即可！

Docker给以上的问题，提出了解决方案！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195551411-1343844960.png)

Docker的思想就来自于集装箱！

JRE --> 多个应用（端口冲突） --> 原来都是交叉的！

隔离：Docker核心思想：打包装箱！每个箱子是互相隔离的。

水果 生化武器

Docker 通过隔离机制，可以将服务器利用到极致！

本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！

### Docker的历史

2010年，几个搞IT的年轻人，就在美国成立了一家`dotCloud`

做一些`pass`的云计算服务！LXC 有关的容器技术！

他们将自己的技术（容器化技术）命名 就是 Docker！

Docker 刚刚诞生的时候，没有引起行业的注意！dotCloud，就活不下去！

`开源`

开放源代码！

2013年，Docker开源！

Docker越来越多的人发现了Docker的优点！火了，Docker 每个月都会更新一个版本！

2014年4月9日，Docker1.0发布！

Docker为什么这么火？十分的轻巧！

在容器技术出来之前，我们都是使用虚拟机技术！

虚拟机：在Windows中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！十分笨重！

虚拟机也是属于虚拟化技术，Docker 容器技术，也是一种 虚拟化技术！

    vm : linux centos原生镜像（一个电脑！） 隔离，需要开启多个虚拟机！ 几个G 几分钟
    docker : 隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M KB 秒级启动！
    

到现在，所有开发人员都必须要会Docker！

> 聊聊Docker

Docker基于Go语言开发的！开源项目！

官网：[https://www.docker.com/](https://www.docker.com/)

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195608250-1824884690.png)

文档地址：[https://docs.docker.com/](https://docs.docker.com/) Docker的文档是超级详细的！

仓库地址：[https://hub.docker.com/](https://hub.docker.com/)

### Docker能干嘛

> 之前的虚拟机技术！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195620378-1394022918.png)

虚拟机技术缺点：

1.  资源占用十分多
    
2.  冗余步骤多
    
3.  启动很慢！
    

> 容器化技术

容器化技术不是模拟的一个完整的操作系统

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195629475-2012496813.png)

比较Docker 和 虚拟机技术的不同：

*   传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件
*   容器内的应用直接运行在宿主机的内核，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了
*   每个容器间是互相隔离的，每个容器内都有一个属于自己的文件系统，互不影响。

> DevOps（开发、运维）

**应用更快速的交付和部署**

传统：一堆帮助文档，安装程序

Docker：打包镜像，发布测试，一键运行

**更便捷的升级和扩缩容**

使用了Docker之后，我们部署应用就和搭积木一样！

项目打包为一个镜像，扩展 服务器A！服务器B

**更简单的系统运维**

在容器化之后，我们的开发、测试环境都是高度一致的。

**更高效的计算资源利用**

Docker 是内核级别的虚拟化，可以在物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。

Docker 安装
---------

### Docker的基本组成

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195645537-34364940.png)

**镜像（image）：**

docker镜像就像一个模板，可以通过这个模板来创建服务，tomcat镜像 ==> run ==> tomcat01容器（提供服务），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。

**容器（container）：**

Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。

启动，停止，删除，基本命令！

目前可以把这个容器理解为就是一个简易的linux系统

**仓库（repository）：**

仓库就是存放镜像的地方！

仓库分为公有仓库和私有仓库！

Docker Hub（默认是国外的）

阿里云...都有容器服务器（配置镜像加速！）

### 安装Docker

> 环境准备

1.  需要会一点点的Linux基础
2.  CentOS 7
3.  我们使用Xshell连接远程服务器进行操作！

> 环境查看

    # 系统内核是 3.10 以上的
    # 系统版本
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195655401-638745023.png)

> 安装

帮助文档：

    # 1、卸载旧的版本
    sudo apt-get remove docker docker-engine docker.io containerd runc
    
    # 2、需要的安装包
    yum install -y yum-utils
    
    # 3、设置镜像的仓库
    yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 阿里云
    
    # 更新yum软件包索引
    yum makecache fast
    
    # 4、安装docker  docker-ce 社区版  ee 企业版
    yum install docker-ce docker-ce-cli containerd.io
    
    # 5、启动docker
    systemctl start docker
    
    # 6、使用docker version 查看是否安装成功
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195706262-1467887592.png)

    # 7、hello-world
    docker run hello-world
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195714104-1367749975.png)

    # 8、查看一下下载的这个 hello-world 镜像
    [root@ls-Cwj2oH9C /]# docker images
    REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
    hello-world   latest    feb5d9fea6a5   9 months ago   13.3kB
    

了解：卸载docker

    # 1、卸载依赖
    yum remove docker-ce docker-ce-cli containerd.io
    
    # 2、删除资源
    rm -rf /var/lib/docker
    
    # /var/lib/docker  docker的默认工作路径！
    

### 阿里云镜像加速

1.  登录阿里云找到容器服务
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195727584-287390126.png)
    
2.  找到镜像加速的地址
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195736274-942232942.png)
    
3.  配置使用
    
        sudo mkdir -p /etc/docker
        
        sudo tee /etc/docker/daemon.json <<-'EOF'
        {
          "registry-mirrors": ["https://veotnqhz.mirror.aliyuncs.com"]
        }
        EOF
        
        sudo systemctl daemon-reload
        
        sudo systemctl restart docker
        
    

### 回顾HelloWorld流程

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195746367-8173640.png)

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195753990-588113450.png)

### 底层原理

**Docker是怎么工作的？**

Docker是一个Client - Server 结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！

DockerServer接收到 Docker - Client 的指令，就会执行这个命令！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195803003-1052794475.png)

**Docker 为什么比 VM 快？**

1.  Docker有着比虚拟机更少的抽象层
    
2.  Docker利用的是宿主机的内核，vm需要的是Guest OS。
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195812758-619917463.png)
    
    所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导操作。虚拟机是加载Guest OS，分钟级别的，而docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195821530-801757624.png)
    

之后学习完毕所有的命令，再回过头来看这段理论，就会很清晰！

Docker的常用命令
-----------

### 帮助命令

    docker version     # 显示docker的版本信息
    docker info        # 显示docker的系统信息，包括镜像和容器的数量
    docker 命令 --help  # 帮助命令
    

帮助文档的地址：[https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)

### 镜像命令

**docker images** 查看所有本地的主机上的镜像

    [root@ls-Cwj2oH9C /]# docker images
    REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
    hello-world   latest    feb5d9fea6a5   9 months ago   13.3kB
    
    # 解释
    REPOSITORY  镜像的仓库源
    TAG         镜像的标签
    IMAGE ID    镜像的id
    CREATED     镜像的创建时间
    SIZE        镜像的大小
    
    # 可选项
      -a，--all          # 列出所有镜像
      -q，--quiet        # 只显示镜像的id
    

**docker search** 搜索镜像

    [root@ls-Cwj2oH9C /]# docker search mysql
    NAME                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
    mysql                          MySQL is a widely used, open-source relation…   12821     [OK]       
    mariadb                        MariaDB Server is a high performing open sou…   4918      [OK]       
    percona                        Percona Server is a fork of the MySQL relati…   580       [OK]       
    phpmyadmin                     phpMyAdmin - A web interface for MySQL and M…   564       [OK]      
    
    # 可选项，通过搜索来过滤
      --filter=STARS=3000  # 搜索出来的镜像就是STARS大于3000的
    [root@ls-Cwj2oH9C ~]# docker search mysql --filter=STARS=3000
    NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
    mysql     MySQL is a widely used, open-source relation…   12821     [OK]       
    mariadb   MariaDB Server is a high performing open sou…   4918      [OK]       
    [root@ls-Cwj2oH9C ~]# docker search mysql --filter=STARS=5000
    NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
    mysql     MySQL is a widely used, open-source relation…   12821     [OK]         
    

**docker pull** 下载镜像

    # 下载镜像 docker pull 镜像名[:tag]
    [root@ls-Cwj2oH9C /]# docker pull mysql
    Using default tag: latest    # 如果不写 tag，默认就是latest
    latest: Pulling from library/mysql
    72a69066d2fe: Pull complete  # 分层下载，docker image的核心 联合文件系统
    93619dbc5b36: Pull complete 
    99da31dd6142: Pull complete 
    626033c43d70: Pull complete 
    37d5d7efb64e: Pull complete 
    ac563158d721: Pull complete 
    d2ba16033dad: Pull complete 
    688ba7d5c01a: Pull complete 
    00e060b6d11d: Pull complete 
    1c04857f594f: Pull complete 
    4d7cfa90e6ea: Pull complete 
    e0431212d27d: Pull complete 
    Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709  # 签名
    Status: Downloaded newer image for mysql:latest
    docker.io/library/mysql:latest  # 真实地址
    
    # 等价于它
    docker pull mysql
    docker pull docker.io/library/mysql:latest
    
    # 指定版本下载
    [root@ls-Cwj2oH9C /]# docker pull mysql:5.7
    5.7: Pulling from library/mysql
    72a69066d2fe: Already exists 
    93619dbc5b36: Already exists 
    99da31dd6142: Already exists 
    626033c43d70: Already exists 
    37d5d7efb64e: Already exists 
    ac563158d721: Already exists 
    d2ba16033dad: Already exists 
    0ceb82207cd7: Pull complete 
    37f2405cae96: Pull complete 
    e2482e017e53: Pull complete 
    70deed891d42: Pull complete 
    Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94
    Status: Downloaded newer image for mysql:5.7
    docker.io/library/mysql:5.7
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195838222-679884555.png)

**docker rmi** 删除镜像！

    [root@ls-Cwj2oH9C /]# docker rmi -f 镜像id  # 删除指定的镜像
    [root@ls-Cwj2oH9C /]# docker rmi -f 镜像id 镜像id 镜像id 镜像id  # 删除多个镜像
    [root@ls-Cwj2oH9C /]# docker rmi -f $(docker images -aq)  # 删除全部的镜像
    

### 容器命令

**说明：我们有了镜像才可以创建容器，linux，下载一个 centos 镜像来测试学习**

    docker pull centos
    

**新建容器并启动**

    docker run [可选参数] image
    
    # 参数说明
    --name="Name"    容器名字  tomcat01  tomcat02，用来区分容器
    -d               后台方式运行
    -it              使用交互方式运行，进入容器查看内容
    -p               指定容器的端口  -p  8080:8080
        -p ip:主机端口:容器端口
        -p 主机端口:容器端口 (常用)
        -p 容器端口
        容器端口
    -p                随机指定端口
    
    # 测试，启动并进入容器
    [root@ls-Cwj2oH9C ~]# docker run -it centos /bin/bash
    [root@26c5b40b2e60 /]# ls  # 查看容器内的centos，基础版本，很多命令都是不完善的！
    bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var
    dev  home  lib64  media       opt  root  sbin  sys  usr
    
    # 从容器中退回主机
    [root@c103dbc1d4d4 /]# exit
    exit
    [root@ls-Cwj2oH9C ~]# cd /
    [root@ls-Cwj2oH9C /]# ls
    bin   dev  home  lib64       media  opt   root  sbin  sys  usr
    boot  etc  lib   lost+found  mnt    proc  run   srv   tmp  var
    

**列出所有的运行的容器**

    # docker ps 命令
        # 列出当前正在运行的容器
    -a  # 列出当前正在运行的容器+带出历史运行过的容器
    -n=?  # 显示最近创建的容器
    
    [root@ls-Cwj2oH9C /]# docker ps
    CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
    [root@ls-Cwj2oH9C /]# docker ps -a
    CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                          PORTS     NAMES
    c103dbc1d4d4   centos         "/bin/bash"   57 seconds ago   Exited (0) 50 seconds ago                 busy_ramanujan
    26c5b40b2e60   centos         "/bin/bash"   11 minutes ago   Exited (0) About a minute ago             thirsty_brahmagupta
    1aba774b8be5   feb5d9fea6a5   "/hello"      4 hours ago      Exited (0) 4 hours ago                    quizzical_turing
    [root@ls-Cwj2oH9C /]# docker ps -aq
    c103dbc1d4d4
    26c5b40b2e60
    1aba774b8be5
    
    

**退出容器**

    exit    # 直接容器停止并退出
    Ctrl + P + Q    # 容器不停止退出
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717195851553-789366231.png)

**删除容器**

    docker rm 容器id                 # 删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -f
    docker rm -f $(docker ps -aq)    # 删除所有的容器
    docker ps -a -q|xargs docker rm  # 删除所有的容器
    

**启动和停止容器的操作**

    docker start 容器id    # 启动容器
    docker restart 容器id  # 重启容器
    docker stop 容器id     # 停止当前正在运行的容器
    docker kill 容器id     # 强制停止当前容器
    

### 常用其他命令

**后台启动容器**

    # 命令 docker run -d 镜像名！
    [root@ls-Cwj2oH9C /]# docker run -d centos
    d3ebfe17b9c02d91f4f45bc9405b6713b7098e9c2f1229cd6523b46f85531c03
    
    # 问题docker ps，发现 centos 停止了
    
    # 常见的坑：docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止
    # nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了
    

**查看日志**

    docker logs -f -t --tail 10 容器  没有日志
    
    # 自己编写一段shell脚本
    [root@ls-Cwj2oH9C /]# docker run -d centos /bin/sh -c "while true;do echo kuangshen;sleep 1;done"
    be09e0fd41c70e5d114b5c2534acba6ae97a3a12e1b4d0d603077b83c76697de
    
    # [root@ls-Cwj2oH9C /]# docker ps
    CONTAINER ID   IMAGE
    be09e0fd41c7   centos
    d2ae011f21b8   centos
    
    # 显示日志
     -tf            # 显示日志
     --tail number  # 要显示的日志条数
    [root@ls-Cwj2oH9C /]# docker logs -tf --tail 10 be09e0fd41c7
    

**查看容器中进程信息** ps

    # 命令 docker top 容器id
    [root@ls-Cwj2oH9C /]# docker top be09e0fd41c7
    UID                 PID                 PPID                C                   STIME     
    root                23558               23538               0                   15:53     
    root                25465               23558               0                   16:09     
    
    

**查看镜像的元数据**

    # 命令
    docker inspect 容器id
    
    # 测试
    [root@ls-Cwj2oH9C /]# docker inspect be09e0fd41c7
    [
        {
            "Id": "be09e0fd41c70e5d114b5c2534acba6ae97a3a12e1b4d0d603077b83c76697de",
            "Created": "2022-07-05T07:53:54.627754682Z",
            "Path": "/bin/sh",
            "Args": [
                "-c",
                "while true;do echo kuangshen;sleep 1;done"
            ],
            "State": {
                "Status": "running",
                "Running": true,
                "Paused": false,
                "Restarting": false,
                "OOMKilled": false,
                "Dead": false,
                "Pid": 23558,
                "ExitCode": 0,
                "Error": "",
                "StartedAt": "2022-07-05T07:53:54.913270812Z",
                "FinishedAt": "0001-01-01T00:00:00Z"
            },
            "Image": "sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6",
            "ResolvConfPath": "/var/lib/docker/containers/be09e0fd41c70e5d114b5c2534acba6ae97a3a12e1b4d0d603077b83c76697de/resolv.conf",
            "HostnamePath": "/var/lib/docker/containers/be09e0fd41c70e5d114b5c2534acba6ae97a3a12e1b4d0d603077b83c76697de/hostname",
            "HostsPath": "/var/lib/docker/containers/be09e0fd41c70e5d114b5c2534acba6ae97a3a12e1b4d0d603077b83c76697de/hosts",
            "LogPath": "/var/lib/docker/containers/be09e0fd41c70e5d114b5c2534acba6ae97a3a12e1b4d0d603077b83c76697de/be09e0fd41c70e5d114b5c2534acba6ae97a3a12e1b4d0d603077b83c76697de-json.log",
            "Name": "/vigilant_tu",
            "RestartCount": 0,
            "Driver": "overlay2",
            "Platform": "linux",
            "MountLabel": "",
            "ProcessLabel": "",
            "AppArmorProfile": "",
            "ExecIDs": null,
            "HostConfig": {
                "Binds": null,
                "ContainerIDFile": "",
                "LogConfig": {
                    "Type": "json-file",
                    "Config": {}
                },
                "NetworkMode": "default",
                "PortBindings": {},
                "RestartPolicy": {
                    "Name": "no",
                    "MaximumRetryCount": 0
                },
                "AutoRemove": false,
                "VolumeDriver": "",
                "VolumesFrom": null,
                "CapAdd": null,
                "CapDrop": null,
                "CgroupnsMode": "host",
                "Dns": [],
                "DnsOptions": [],
                "DnsSearch": [],
                "ExtraHosts": null,
                "GroupAdd": null,
                "IpcMode": "private",
                "Cgroup": "",
                "Links": null,
                "OomScoreAdj": 0,
                "PidMode": "",
                "Privileged": false,
                "PublishAllPorts": false,
                "ReadonlyRootfs": false,
                "SecurityOpt": null,
                "UTSMode": "",
                "UsernsMode": "",
                "ShmSize": 67108864,
                "Runtime": "runc",
                "ConsoleSize": [
                    0,
                    0
                ],
                "Isolation": "",
                "CpuShares": 0,
                "Memory": 0,
                "NanoCpus": 0,
                "CgroupParent": "",
                "BlkioWeight": 0,
                "BlkioWeightDevice": [],
                "BlkioDeviceReadBps": null,
                "BlkioDeviceWriteBps": null,
                "BlkioDeviceReadIOps": null,
                "BlkioDeviceWriteIOps": null,
                "CpuPeriod": 0,
                "CpuQuota": 0,
                "CpuRealtimePeriod": 0,
                "CpuRealtimeRuntime": 0,
                "CpusetCpus": "",
                "CpusetMems": "",
                "Devices": [],
                "DeviceCgroupRules": null,
                "DeviceRequests": null,
                "KernelMemory": 0,
                "KernelMemoryTCP": 0,
                "MemoryReservation": 0,
                "MemorySwap": 0,
                "MemorySwappiness": null,
                "OomKillDisable": false,
                "PidsLimit": null,
                "Ulimits": null,
                "CpuCount": 0,
                "CpuPercent": 0,
                "IOMaximumIOps": 0,
                "IOMaximumBandwidth": 0,
                "MaskedPaths": [
                    "/proc/asound",
                    "/proc/acpi",
                    "/proc/kcore",
                    "/proc/keys",
                    "/proc/latency_stats",
                    "/proc/timer_list",
                    "/proc/timer_stats",
                    "/proc/sched_debug",
                    "/proc/scsi",
                    "/sys/firmware"
                ],
                "ReadonlyPaths": [
                    "/proc/bus",
                    "/proc/fs",
                    "/proc/irq",
                    "/proc/sys",
                    "/proc/sysrq-trigger"
                ]
            },
            "GraphDriver": {
                "Data": {
                    "LowerDir": "/var/lib/docker/overlay2/1a375808cf6a2eff0ce527432ddf9fd9b2c5519b1a71b9c6a5931104f24e55ed-init/diff:/var/lib/docker/overlay2/652792c86aac30ea5e1860169ae46b72da12c74efde67ea5aaba90a396e5989f/diff",
                    "MergedDir": "/var/lib/docker/overlay2/1a375808cf6a2eff0ce527432ddf9fd9b2c5519b1a71b9c6a5931104f24e55ed/merged",
                    "UpperDir": "/var/lib/docker/overlay2/1a375808cf6a2eff0ce527432ddf9fd9b2c5519b1a71b9c6a5931104f24e55ed/diff",
                    "WorkDir": "/var/lib/docker/overlay2/1a375808cf6a2eff0ce527432ddf9fd9b2c5519b1a71b9c6a5931104f24e55ed/work"
                },
                "Name": "overlay2"
            },
            "Mounts": [],
            "Config": {
                "Hostname": "be09e0fd41c7",
                "Domainname": "",
                "User": "",
                "AttachStdin": false,
                "AttachStdout": false,
                "AttachStderr": false,
                "Tty": false,
                "OpenStdin": false,
                "StdinOnce": false,
                "Env": [
                    "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
                ],
                "Cmd": [
                    "/bin/sh",
                    "-c",
                    "while true;do echo kuangshen;sleep 1;done"
                ],
                "Image": "centos",
                "Volumes": null,
                "WorkingDir": "",
                "Entrypoint": null,
                "OnBuild": null,
                "Labels": {
                    "org.label-schema.build-date": "20210915",
                    "org.label-schema.license": "GPLv2",
                    "org.label-schema.name": "CentOS Base Image",
                    "org.label-schema.schema-version": "1.0",
                    "org.label-schema.vendor": "CentOS"
                }
            },
            "NetworkSettings": {
                "Bridge": "",
                "SandboxID": "4b2ab1f2e949baa34edcfd36e72e6ed4a80c5f5381f6183b30ee6d9e73e39e44",
                "HairpinMode": false,
                "LinkLocalIPv6Address": "",
                "LinkLocalIPv6PrefixLen": 0,
                "Ports": {},
                "SandboxKey": "/var/run/docker/netns/4b2ab1f2e949",
                "SecondaryIPAddresses": null,
                "SecondaryIPv6Addresses": null,
                "EndpointID": "83295610dca0bd58cf285f6e7238eaae06749bf30433a75ee9d126dd6f92c25f",
                "Gateway": "172.17.0.1",
                "GlobalIPv6Address": "",
                "GlobalIPv6PrefixLen": 0,
                "IPAddress": "172.17.0.3",
                "IPPrefixLen": 16,
                "IPv6Gateway": "",
                "MacAddress": "02:42:ac:11:00:03",
                "Networks": {
                    "bridge": {
                        "IPAMConfig": null,
                        "Links": null,
                        "Aliases": null,
                        "NetworkID": "4181a198dd37ad281366217d8321f1ca65fd69f9139e73c0a7fc460afc58fa28",
                        "EndpointID": "83295610dca0bd58cf285f6e7238eaae06749bf30433a75ee9d126dd6f92c25f",
                        "Gateway": "172.17.0.1",
                        "IPAddress": "172.17.0.3",
                        "IPPrefixLen": 16,
                        "IPv6Gateway": "",
                        "GlobalIPv6Address": "",
                        "GlobalIPv6PrefixLen": 0,
                        "MacAddress": "02:42:ac:11:00:03",
                        "DriverOpts": null
                    }
                }
            }
        }
    ]
    

**进入当前正在运行的容器**

    # 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置
    
    # 命令
    docker exec -it 容器id bashShell
    
    # 测试
    [root@ls-Cwj2oH9C /]# docker ps
    CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES
    be09e0fd41c7   centos    "/bin/sh -c 'while t…"   32 minutes ago   Up 32 minutes             vigilant_tu
    d2ae011f21b8   centos    "/bin/bash"              45 minutes ago   Up 45 minutes             mystifying_tereshkova
    [root@ls-Cwj2oH9C /]# docker exec -it be09e0fd41c7 /bin/bash
    [root@be09e0fd41c7 /]# ls
    bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var
    dev  home  lib64  media       opt  root  sbin  sys  usr
    [root@be09e0fd41c7 /]# ps -ef
    UID        PID  PPID  C STIME TTY          TIME CMD
    root         1     0  0 07:53 ?        00:00:01 /bin/sh -c while true;do echo kuangshen;sleep 1;don
    root      4191     0  0 09:03 pts/0    00:00:00 /bin/bash
    root      4214     1  0 09:03 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /
    root      4215  4191  0 09:03 pts/0    00:00:00 ps -ef
    
    # 方式二
    docker attach 容器id
    # 测试
    [root@ls-Cwj2oH9C /]# docker attach be09e0fd41c7
    正在执行当前的代码...
    
    # docker exec      # 进入容器后开启一个新的终端，可以在里面操作（常用）
    # docker attach    # 进入容器正在执行的终端，不会启动新的进程！
    

**从容器内拷贝文件到主机上**

    docker cp 容器id:容器内路径  目的主机路径
    
    # 查看当前主机目录下
    [root@ls-Cwj2oH9C home]# ls
    kuangshen.java
    [root@ls-Cwj2oH9C home]# docker ps
    CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES
    17c1f83eeda6   centos    "/bin/bash"              32 seconds ago   Up 31 seconds             relaxed_spence
    be09e0fd41c7   centos    "/bin/sh -c 'while t…"   2 hours ago      Up 2 hours                vigilant_tu
    d2ae011f21b8   centos    "/bin/bash"              2 hours ago      Up 2 hours                mystifying_tereshkova
    
    # 进入docker容器内部
    [root@ls-Cwj2oH9C home]# docker attach 17c1f83eeda6
    [root@17c1f83eeda6 /]# cd /home
    [root@17c1f83eeda6 home]# ls
    # 在容器内新建一个文件
    [root@17c1f83eeda6 home]# touch test.java
    [root@17c1f83eeda6 home]# exit
    exit
    [root@ls-Cwj2oH9C home]# docker ps
    CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS     NAMES
    be09e0fd41c7   centos    "/bin/sh -c 'while t…"   2 hours ago   Up 2 hours             vigilant_tu
    d2ae011f21b8   centos    "/bin/bash"              2 hours ago   Up 2 hours             mystifying_tereshkova
    [root@ls-Cwj2oH9C home]# docker ps -a
    CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS                     PORTS     NAMES
    17c1f83eeda6   centos    "/bin/bash"              2 minutes ago   Exited (0) 7 seconds ago             relaxed_spence
    be09e0fd41c7   centos    "/bin/sh -c 'while t…"   2 hours ago     Up 2 hours                           vigilant_tu
    d2ae011f21b8   centos    "/bin/bash"              2 hours ago     Up 2 hours                           mystifying_tereshkova
    d3ebfe17b9c0   centos    "/bin/bash"              3 hours ago     Exited (0) 3 hours ago               gifted_joliot
    
    # 将这个文件拷贝出来到主机上
    [root@ls-Cwj2oH9C home]# docker cp 17c1f83eeda6:/home/test.java /home
    [root@ls-Cwj2oH9C home]# ls
    kuangshen.java  test.java
    [root@ls-Cwj2oH9C home]# 
    
    # 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现，自动同步
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200032763-103520975.png)

### 小结

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200042596-1095579550.png)

    attach :                  	##进入指定运行对象
    	[root@VM-0-9-centos ~]# docker attach 96763bc9ea4e 
    build : 					##通过Dockerfile定制镜像
    commit : 					##提交当前容器为新的镜像
    cp : 						##拷贝指定文件或目录到主机
    	[root@VM-0-9-centos ~]# docker cp 96763bc9ea4e:/home/test.java /home/test_docker_cp/
    create :					##创建新的容器，类似于run，但是不启动容器
    	[root@VM-0-9-centos ~]# docker create centos /bin/bash 
    diff:						##查看docker容器变化
    events:						##从docker获取实时容器事件
    exec: 						##进入已经启动的容器运行指令
    	[root@VM-0-9-centos ~]# docker exec -it f170a9b28775 /bin/bash
    export: 					##到处容器的内容归为一个tar文档
    history:					##展示一个镜像形成历史
    images:						##列出系统当前镜像
    	[root@VM-0-9-centos ~]# docker images -a
    import:						## 从tar包中内容中创建一个新的文件系统
    info:						## 查看系统详细信息
    	[root@VM-0-9-centos ~]# docker info
    inspect:					## 查看容器详细信息
    	[root@VM-0-9-centos ~]# docker inspect f170a9b28775
    kill: 						## 强制结束指定容器
    load:						## 从一个tar包中加载一个镜像
    login:						## 注册或者登录一个docker源服务器
    logout:						## 登出
    logs:  						## 输出当前容器日志信息
    	docker logs -tf 容器id 			 
    	docker logs --tail number 容器id #num为要显示的日志条数
    
    port:						## 查看映射端口对应容器内部的源端口
    pasue: 						## 暂停容器
    ps:							## 列出容器列表
    	docker ps     #运行中列表  
    	docker ps -a  #所有容器列表
    pull: 						## 从docker源镜像拉取指定镜像
    	docker pull mysql	#默认拉取最新版本mysql
    push:						## 推送指定镜像或库镜像至docker源服务器
    restart: 					## 重启正在运行的容器
    rm: 						## 移除一个或者多个容器
    	docker rm -f $(docker ps -aq)	#移除所有容器
    rmi:						## 移除一个或者多个镜像
    run:						## 创建一个容器并运行内容
    	docker run -it centos /bin/bash
    save: 						## 保存一个镜像为一个tar包
    search: 					## 在docker	hub中搜索镜像
    	docker search mysql						#搜索所有mysql镜像
    	docker search mysql --filter=STARS=3000 #搜索收藏数大于3000的镜像
    start:						## 启动容器
    	docker start [id]
    stop:						## 停止容器
    	docker stop [id]
    tag:						## 给源服务器中镜像设置标签
    top:						## 查看容器中运行的进程信息
    unpause:					## 取消暂停容器
    version:  					## 查看docker版本号
    	docker version
    wait:						## 截取容器停止时的退出状态值
    

docker的命令十分多，上面我们学习的那些都是最常用的容器和镜像的命令，之后我们还会学习很多命令！

### 作业练习

> Docker 安装 Nginx

    # 1、搜索镜像  search  建议大家去docker hub搜索，可以看到帮助文档
    # 2、下载镜像  pull
    # 3、运行测试
    [root@ls-Cwj2oH9C home]# docker images
    REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
    nginx        latest    605c77e624dd   6 months ago   141MB
    centos       latest    5d0da3dc9764   9 months ago   231MB
    
    # -d 后台运行
    # --name 给容器命名
    # -p 宿主机端口：容器内部端口
    [root@ls-Cwj2oH9C home]# docker run -d --name nginx01 -p 3344:80 nginx
    fb127ee2c6ba61f9e42c8664673494314122e48017df0875342fbeed80b81e60
    [root@ls-Cwj2oH9C home]# docker ps
    CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                   NAMES
    fb127ee2c6ba   nginx     "/docker-entrypoint.…"   4 seconds ago   Up 4 seconds   0.0.0.0:3344->80/tcp, :::3344->80/tcp   nginx01
    be09e0fd41c7   centos    "/bin/sh -c 'while t…"   3 hours ago     Up 3 hours                                             vigilant_tu
    d2ae011f21b8   centos    "/bin/bash"              3 hours ago     Up 3 hours                                             mystifying_tereshkova
    [root@ls-Cwj2oH9C home]# curl localhost:3344
    
    # 进入容器
    [root@ls-Cwj2oH9C home]# docker exec -it nginx01 /bin/bash
    root@fb127ee2c6ba:/# whereis nginx
    nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
    root@fb127ee2c6ba:/# cd /etc/nginx
    root@fb127ee2c6ba:/etc/nginx# ls
    conf.d	fastcgi_params	mime.types  modules  nginx.conf  scgi_params  uwsgi_params
    root@fb127ee2c6ba:/etc/nginx# 
    

端口暴露的概念

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200103091-2132183120.png)

思考问题：我们每次改动nginx配置文件，都需要进入容器内部，十分的麻烦，我们要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改 -v 数据卷！

> 作业：docker来装一个tomcat

    # 官方的使用
    docker run -it --rm tomcat:9.0
    
    # 我们之前的启动都是后台，停止了容器之后，容器还是可以查到  docker run -it --rm，一般用来测试，用完就删除
    
    # 下载再启动
    docker pull tomcat
    
    # 启动运行
    docker run -d -p 3355:8080 --name tomcat01 tomcat
    
    # 测试访问没有问题
    
    # 进入容器
    [root@ls-Cwj2oH9C /]# docker exec -it tomcat01 /bin/bash
    
    # 发现问题：1、linux命令少了  2、没有webapps  默认是最小的镜像，所有不必要的都剔除掉。
    # 保证最小可运行的环境
    

思考问题：我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？我们要是可以在容器外部提供一个映射路径，webapps，我们在外部放置项目，就自动同步到内部就好了！

> 作业：部署 es + kibana

    # es 暴露的端口很多！
    # es 十分的耗内存
    # es 的数据一般需要放置到安全目录！挂载
    # --net somenetwork ？ 网络配置
    
    # 启动 elasticsearch
    docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:latest
    
    # 启动了 linux就卡住了  docker stats 查看cpu的状态
    
    # es 是十分耗内存的 2.182GiB  1核2G根本跑不动，会卡死，2核4G起步可以运行！
    
    # 查看 docker stats
    
    # 测试一下es是否成功了
    [root@ls-Cwj2oH9C /]# curl localhost:9200
    {
      "name" : "7QxbBIY",
      "cluster_name" : "elasticsearch",
      "cluster_uuid" : "wUTOoYcpSZaSKV4VALlxeQ",
      "version" : {
        "number" : "5.6.8",
        "build_hash" : "688ecce",
        "build_date" : "2018-02-16T16:46:30.010Z",
        "build_snapshot" : false,
        "lucene_version" : "6.6.1"
      },
      "tagline" : "You Know, for Search"
    }
    
    # 赶紧关闭，增加内存的限制！
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200121087-1232782153.png)

    # 关闭es，增加内存的限制，修改配置文件  -e  环境配置修改
    docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:latest
    
    # 查看 docker stats
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200131308-1883608927.png)

    [root@ls-Cwj2oH9C /]# curl localhost:9200
    {
      "name" : "FnQQV4P",
      "cluster_name" : "elasticsearch",
      "cluster_uuid" : "-M8PzTiLTVCNeZ2AZND1Ig",
      "version" : {
        "number" : "5.6.8",
        "build_hash" : "688ecce",
        "build_date" : "2018-02-16T16:46:30.010Z",
        "build_snapshot" : false,
        "lucene_version" : "6.6.1"
      },
      "tagline" : "You Know, for Search"
    }
    

作业：使用kibana连接elasticsearch？思考网络如何才能连接过去！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200142504-1155762778.png)

### 可视化

*   portainer（先用这个）
    
*   Rancher（CI/CD(Continuous Intergration/Continuous Delpoy)持续集成/持续部署再用）
    

**什么是portainer？**

Docker图形化界面管理工具！提供一个后台面板供我们操作！

    docker run -d -p 8088:9000 \
    --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
    

访问测试：[http://182.61.20.38:8088/](http://182.61.20.38:8088/)

通过它来访问了：

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200153000-766659849.png)

管理员登录后选择Local Docker后的主界面，注意：管理员只有一个

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200203558-1229083400.png)

点击local docker进入后的面板，可以查看容器、镜像、卷、网络等的详细信息

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200215020-1367453252.png)

可视化面板平时不会使用，测试使用即可！

Docker镜像详解
----------

### 镜像是什么

镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。

所有的应用，直接打包docker镜像，就可以直接跑起来！

如何得到镜像：

*   从远程仓库下载
*   朋友拷贝给你
*   自己制作一个镜像 DockerFile

### Docker镜像加载原理

> UnionFS（联合文件系统）

我们下载的时候看到的一层层就是这个！

UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union文件系统时Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。

特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统 ，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。

> Docker镜像加载原理

docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。

bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。

rootfs（root file system），在bootfs之上。包含的就是典型Linux系统中的/dev，/proc，/bin，/etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200231522-965797985.png)

平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200240878-262315659.png)

对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了，由此可见对于不同的linux发行版，rootfs会有差别，因此不同的发行版可以公用bootfs。

虚拟机是分钟级别，容器是秒级！

### 分层理解

> 分层的镜像

我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的在下载！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200253103-557013881.png)

思考：为什么Docker镜像要采用这种分层的结构呢？

最大的好处，莫过于是资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被分享。

查看镜像分层的方式可以通过 docker image inspect 命令！

    [root@ls-Cwj2oH9C ~]# docker image inspect redis:latest
    [
        // ......
            "RootFS": {
                "Type": "layers",
                "Layers": [
                    "sha256:08249ce7456a1c0613eafe868aed936a284ed9f1d6144f7d2d08c514974a2af9",
                    "sha256:5659b3a1146e8bdda814e4ad825e107088057e8578c83b758ad6aab93700d067",
                    "sha256:cf3ae502d7faa4e90c159cc42b63b46a6be04864fe9d04fb0939e2b0c8b1f7c7",
                    "sha256:4ca33072d02630d1d55ada52c3bde95a1ffe02ae60da9ef147c836db444f7a0f",
                    "sha256:58bcc523fc9281a3a7033280804e841d1fcec71cbd6359c643c7e06a90efb34c",
                    "sha256:be56018ff4790f7f1d96f500e9757c27979c37e476e21a2932746b4654955806"
                ]
            },
            "Metadata": {
                "LastTagTime": "0001-01-01T00:00:00Z"
            }
        }
    ]
    

**理解：**

所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。

举一个简单的例子，假如基于Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。

该镜像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200306465-1652295464.png)

在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图举了一个简单的例子，每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件。

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200317986-1562475535.png)

上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。

下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件7是文件5的一个更新版本。

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200325974-1947582017.png)

这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。

Docker通过存储引擎（新版本采用快照机制）的方式实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。

Linux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。

Docker在Windows上仅支持windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW。下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200336468-783530460.png)

> 特点

Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！

这一层就是我们通常说的容器层，容器之下的都叫镜像层！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200345007-464400938.png)

如何提交一个自己的镜像

### commit镜像

    docker commit 提交容器成为一个新的副本
    
    # 命令和git原理类似
    docker commit -m="提交的描述信息" -a="作者" 容器id 目标镜像名：[TAG]
    

实战测试

    # 启动一个默认的tomcat
    
    # 发现这个默认的tomcat 是没有webapps应用，镜像的原因，官方的镜像默认 webapps下面是没有文件的！
    
    # 我自己拷贝进去了基本的文件
    [root@ls-Cwj2oH9C ~]# docker exec -it 11cdc75c9c6e /bin/bash
    root@11cdc75c9c6e:/usr/local/tomcat# ls
    BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
    CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work
    root@11cdc75c9c6e:/usr/local/tomcat# cp -r webapps.dist/* webapps
    
    # 将我们操作过的容器通过commit提交为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200356340-1249799362.png)

学习方式：理解概念，进行实践，最后实践和理论相结合！

    如果想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像
    就像我们之前学习的VM快照功能！
    

到了这里才算是入门Docker！

容器数据卷
-----

### 什么是容器数据卷

**docker理念回顾**

将应用和环境打包成一个镜像！

数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！ 需求：数据可以持久化

MySQL，容器删了，删库跑路！ 需求：MySQL数据可以存储在本地！

容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！

这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200408043-1735554658.png)

**总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！**

### 使用数据卷

> 方式一：直接使用命令来挂载 -v

    docker run -it -v 主机目录：容器内目录
    
    # 测试
    [root@ls-Cwj2oH9C ~]# docker run -it -v /home/ceshi:/home centos /bin/bash
    
    # 启动起来之后，我们可以通过 docker inspect 容器id
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200417942-1499517887.png)

测试文件的同步

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200429341-1971479889.png)

再来测试：

1.  停止容器
2.  宿主机上修改文件
3.  启动容器
4.  容器内的数据依旧是同步的

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200437126-1737317637.png)

好处：我们以后修改只需要在本地修改即可，容器内会自动同步！

### 实战：安装MySQL

思考：MySQL的数据持久化的问题！

    # 获取镜像
    [root@ls-Cwj2oH9C ~]# docker pull mysql:5.7
    
    # 运行容器，需要做数据挂载！  # 安装启动mysql，需要配置密码，这是要注意的点！
    # 官方测试： docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag
    
    # 启动我们的mysql
     -d 后台运行
     -p 端口映射
     -v 数据卷挂载
     -e 环境配置
     --name 容器名字
    [root@ls-Cwj2oH9C ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7
    
    # 启动成功之后，我们在本地使用Navicat来连接测试一下（sqlyog反复尝试都连不上，Navicat一次成功！）
    # Navicat 连接到服务器的3310 --- 3310和容器内的3306映射，这个时候我们就可以连接上了！
    
    # 在本地测试创建一个数据库test，查看一下我们映射的路径是否ok！
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200448903-1883627218.png)

    # 假如我们将容器删除
    [root@ls-Cwj2oH9C ~]# docker rm -f mysql01
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200457578-1148629697.png)

发现，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能！

### 具名和匿名挂载

    # 匿名挂载
    -v 容器内路径！
    docker run -d -P --name nginx01 -v /etc/nginx nginx
    
    # 查看所有的volume的情况
    [root@ls-Cwj2oH9C ~]# docker volume ls
    DRIVER    VOLUME NAME
    local     33a9eda0390dd6b15259dbf0fb1b5828f19bfb8f7e09c5467863862b839f1879
    local     b3e57bea4d55bfb0f3cb6640ec6f6518f424218e204826c14a220c910def5a31
    local     dd326255ea9dfbf32350012c3d61ec0991a1f0c52f694bab76b2c322c0f60f62
    local     f8f8c5df2175bf49695d6799c38b64b8843dce08889bdc0fc869749ac239bee4
    local     f57aac3e8dc17710ab8a1151ea48ff97354849624a9478ea4fa7a58e1fd3dec2
    
    # 这里发现，这种就是匿名挂载，我们在 -v 只写了容器内的路径，没有写容器外的路径！
    
    # 具名挂载
    [root@ls-Cwj2oH9C home]# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx
    a2a98f1b0f43c47c44ee4d2f6b5047d9ffa1c182e674b8238ad377af13ee188b
    [root@ls-Cwj2oH9C home]# docker volume ls
    DRIVER    VOLUME NAME
    local     33a9eda0390dd6b15259dbf0fb1b5828f19bfb8f7e09c5467863862b839f1879
    local     b3e57bea4d55bfb0f3cb6640ec6f6518f424218e204826c14a220c910def5a31
    local     dd326255ea9dfbf32350012c3d61ec0991a1f0c52f694bab76b2c322c0f60f62
    local     f8f8c5df2175bf49695d6799c38b64b8843dce08889bdc0fc869749ac239bee4
    local     f57aac3e8dc17710ab8a1151ea48ff97354849624a9478ea4fa7a58e1fd3dec2
    local     juming-nginx
    
    # 通过 -v 卷名:容器内路径
    # 查看一下这个卷
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200509565-89614140.png)

所有的docker容器内的卷，没有指定目录的情况下都是在`/var/lib/docker/volumes/xxxx/_data`

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200518211-849801490.png)

我们通过具名挂载可以方便的找到我们的一个卷，大多数情况下都在使用`具名挂载`

    # 如何确定是具名挂载还是匿名挂载，还是指定路径挂载！
    -v 容器内路径  # 匿名挂载
    -v 卷名:容器内路径  # 具名挂载
    -v /宿主机路径:容器内路径  # 指定路径挂载！
    

拓展：

    # pwd 显示当前文件路径
    # 通过 -v 容器内路径:ro rw 改变读写权限
    ro  readonly  # 只读
    rw  readwrite  # 可读可写
    
    # 一旦设定了这个容器权限，容器对我们挂载出来的内容就有限定了！
    docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx
    docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx
    
    # ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作的！
    

### 初始DockerFile

DockerFile就是用来构建docker镜像的构建文件！命令脚本！先体验一下！

通过这个脚本可以生成镜像，镜像是一层一层的，脚本就是一个个的命令，每个命令都是一层！

    # 创建一个dockerfile文件，名字可以随机 建议 Dockerfile
    # 文件中的内容 指令（大写） 参数
    FROM centos
    
    VOLUME ["volume01","volume02"]    # 匿名挂载
    
    CMD echo "----end----"
    CMD /bin/bash
    
    # 这里的每个命令，就是镜像的一层！
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200529162-460384722.png)

    # 启动自己写的容器
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200539178-1014757367.png)

这个卷和外部一定有一个同步的目录！匿名挂载，只写了容器内的目录！

查看一下卷挂载的路径

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200550299-504514846.png)

测试一下刚才的文件是否同步出去了！

这种方式我们未来使用的十分多，因为我们通常会构建自己的镜像！

假设构建镜像的时候没有挂载卷，要手动镜像挂载 -v 卷名 : 容器内路径！

### 数据卷容器

多个mysql同步数据！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200559488-1850076797.png)

    # 启动3个容器，通过我们刚才自己的镜像启动
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200608503-591152182.png)

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200617573-641576276.png)

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200628612-1095248737.png)

    # 测试，可以删除docker01，查看一下docker02和docker03是否还可以访问这个文件
    # 测试依旧可以访问
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200637994-2050120472.png)

多个mysql实现数据共享

    [root@ls-Cwj2oH9C ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7
    [root@ls-Cwj2oH9C ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7
    

**结论：**

容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。

但是一旦持久化到了本地，这个时候，本地的数据是不会删除的！

DockerFile
----------

### DockerFile介绍

DockerFile是用来构建docker镜像的文件！命令参数脚本！

构建步骤：

1.  编写一个dockerfile文件
2.  docker build 构建成为一个镜像
3.  docker run 运行镜像
4.  docker push 发布镜像（DockerHub、阿里云镜像仓库！）

查看一下官方是怎么做的？

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200650228-31253698.png)

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200701135-254867879.png)

发现官方的镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！

官方既然可以制作镜像，那么我们也可以！

### DockerFile构建过程

**基础知识：**

1.  每个保留关键字（指令）都是必须是大写字母
2.  执行从上到下顺序执行
3.  `#` 表示注释
4.  每一个指令都会创建提交一个新的镜像层，并提交！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200712963-339903673.png)

DockerFile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！

Docker镜像逐渐成为企业交付的标准，必须要掌握！

步骤：开发，部署，运维。。。缺一不可！

DockerFile：构建文件，定义了一切的步骤，源代码

DockerImages：通过DockerFile构建生成的镜像，最终发布和运行的产品！

Docker容器：容器就是镜像运行起来提供服务的

### DockerFile的指令

以前的话我们就是使用别人的，现在我们知道了这些指令后，我们来练习自己写一个镜像！

    FROM        # 基础镜像，一切从这里开始构建
    MAINTAINER  # 镜像是谁写的，姓名+邮箱
    RUN         # 镜像构建的时候需要运行的命令
    ADD         # 步骤，tomcat镜像，这个tomcat压缩包！添加内容
    WORKDIR     # 镜像的工作目录
    VOLUME      # 挂载的目录
    EXPOSE      # 暴露端口配置
    CMD         # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代
    ENTRYPOINT  # 指定这个容器启动的时候要运行的命令，可以追加命令
    ONBUILD     # 当构建一个被继承的 DockerFile 这个时候就会运行 ONBUILD 的指令，触发指令
    COPY        # 类似ADD，将我们的文件拷贝到镜像中
    ENV         # 构建的时候设置环境变量！
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200726765-1555801663.png)

### 实战测试

Docker Hub中99%镜像都是从这个基础镜像过来的 FROM scratch，然后配置需要的软件和配置来进行构建

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200740547-476477558.png)

> 创建一个自己的centos

**创建出错可以查看我的博客中`遇到的错误`一栏中的相关内容进行解决！**

    # 1 编写Dockerfile的文件
    [root@ls-Cwj2oH9C dockerfile]# cat mydockerfile-centos
    FROM centos:7.9.2009
    MAINTAINER wydilearn<406623380@qq.com>
    
    ENV MYPATH /usr/local
    WORKDIR $MYPATH
    
    RUN yum install vim
    RUN yum install net-tools
    
    EXPOSE 80
    
    CMD echo $MYPATH
    CMD echo "----end----"
    CMD /bin/bash
    
    # 2 通过这个文件构建镜像
    # 命令 docker build -f dockerfile文件路径 -t 镜像名:[tag]
    Successfully built 4ca77dadd64f
    Successfully tagged mycentos:7.9.2009
    
    # 3 测试运行
    

对比：之前的原生centos

**工作目录默认是根目录，没有vim、ifconfig等命令**

我们增加之后的镜像：

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200753442-1812839984.png)

我们可以列出本地镜像的变更历史

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200803638-1442122927.png)

我们平时拿到一个镜像，可以研究一下它是怎么做的了！

> CMD 和 ENTRYPOINT 区别

    CMD            # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代
    ENTRYPOINT     # 指定这个容器启动的时候要运行的命令，可以追加命令
    

测试cmd

    # 编写 dockerfile 文件
    [root@ls-Cwj2oH9C dockerfile]# vim dockerfile-cmd-test
    FROM centos
    CMD ["ls","-a"]
    
    # 构建镜像
    [root@ls-Cwj2oH9C dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest .
    
    # run运行，发现我们的ls -a 命令生效
    [root@ls-Cwj2oH9C dockerfile]# docker run 08f5a6379ff7
    .
    ..
    .dockerenv
    anaconda-post.log
    bin
    dev
    etc
    home
    lib
    lib64
    
    # 想追加一个命令 -l  ls -al
    [root@ls-Cwj2oH9C dockerfile]# docker run 08f5a6379ff7 -l
    docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: "-l": executable file not found in $PATH: unknown.
    ERRO[0000] error waiting for container: context canceled 
    
    # CMD的情况下 -l 替换了CMD ["ls","-a"]命令，-l 不是命令所以报错！
    

测试 ENTRYPOINT

    [root@ls-Cwj2oH9C dockerfile]# vim dockerfile-cmd-entrypoint
    FROM centos:7.9.2009
    ENTRYPOINT ["ls","-a"]
    
    [root@ls-Cwj2oH9C dockerfile]# docker build -f dockerfile-cmd-entrypoint -t entrypoint-test .
    Sending build context to Docker daemon  4.096kB
    Step 1/2 : FROM centos:7.9.2009
     ---> eeb6ee3f44bd
    Step 2/2 : ENTRYPOINT ["ls","-a"]
     ---> Running in a11a899f08f4
    Removing intermediate container a11a899f08f4
     ---> db46b6b11456
    Successfully built db46b6b11456
    Successfully tagged entrypoint-test:latest
    [root@ls-Cwj2oH9C dockerfile]# docker run d74cdaf8abb6
    .
    ..
    .dockerenv
    anaconda-post.log
    bin
    dev
    etc
    home
    lib
    lib64
    media
    mnt
    opt
    proc
    root
    run
    sbin
    srv
    sys
    tmp
    usr
    var
    
    # 我们的追加命令，是直接拼接在我们的 ENTRYPOINT 命令的后面！
    [root@ls-Cwj2oH9C dockerfile]# docker run d74cdaf8abb6 -l
    total 64
    drwxr-xr-x   1 root root  4096 Jul 12 08:56 .
    drwxr-xr-x   1 root root  4096 Jul 12 08:56 ..
    -rwxr-xr-x   1 root root     0 Jul 12 08:56 .dockerenv
    -rw-r--r--   1 root root 12114 Nov 13  2020 anaconda-post.log
    lrwxrwxrwx   1 root root     7 Nov 13  2020 bin -> usr/bin
    drwxr-xr-x   5 root root   340 Jul 12 08:56 dev
    drwxr-xr-x   1 root root  4096 Jul 12 08:56 etc
    drwxr-xr-x   2 root root  4096 Apr 11  2018 home
    lrwxrwxrwx   1 root root     7 Nov 13  2020 lib -> usr/lib
    lrwxrwxrwx   1 root root     9 Nov 13  2020 lib64 -> usr/lib64
    drwxr-xr-x   2 root root  4096 Apr 11  2018 media
    drwxr-xr-x   2 root root  4096 Apr 11  2018 mnt
    drwxr-xr-x   2 root root  4096 Apr 11  2018 opt
    dr-xr-xr-x 173 root root     0 Jul 12 08:56 proc
    dr-xr-x---   2 root root  4096 Nov 13  2020 root
    drwxr-xr-x  11 root root  4096 Nov 13  2020 run
    lrwxrwxrwx   1 root root     8 Nov 13  2020 sbin -> usr/sbin
    drwxr-xr-x   2 root root  4096 Apr 11  2018 srv
    dr-xr-xr-x  13 root root     0 Jul  9 02:03 sys
    drwxrwxrwt   7 root root  4096 Nov 13  2020 tmp
    drwxr-xr-x  13 root root  4096 Nov 13  2020 usr
    drwxr-xr-x  18 root root  4096 Nov 13  2020 var
    

Dockerfile中很多命令都十分的相似，我们需要了解它们的区别，我们最好的学习就是对比他们然后测试效果！

### 实战：Tomcat镜像

1.  准备镜像文件 tomcat 压缩包，jdk的压缩包！
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200823119-2048197239.png)
    
2.  编写dockerfile文件，官方命名 `Dockerfile` ，build 会自动寻找这个文件，就不需要 -f 指定了！
    
        FROM centos:7.9.2009
        MAINTAINER wydilearn<406623380@qq.com>
        
        COPY readme.txt /usr/local/readme.txt
        
        ADD jdk-8u333-linux-x64.tar /usr/local/
        ADD apache-tomcat-10.0.22.tar.gz /usr/local/
        
        RUN yum -y install vim
        
        ENV MYPATH /usr/local
        WORKDIR $MYPATH
        
        ENV JAVA_HOME /usr/local/jdk1.8.0_333
        ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
        ENV CATALINA_HOME /usr/local/apache-tomcat-10.0.22
        ENV CATALINA_BASE /usr/local/apache-tomcat-10.0.22
        ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin
        
        EXPOSE 8080
        
        CMD /usr/local/apache-tomcat-10.0.22/bin/startup.sh && tail -F /usr/local/apache-tomcat-10.0.22/bin
        /logs/catalina.out
        
    
3.  构建镜像
    
        # docker build -t diytomcat .
        
    
4.  启动镜像
    
5.  访问测试
    
6.  发布项目（由于做了卷挂载，我们直接在本地编写项目就可以发布了！）
    
        <?xml version="1.0" encoding="UTF-8"?>
        <web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xmlns="http://java.sun.com/xml/ns/javaee"
                 xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
                 xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                                     http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
                 id="WebApp_ID" version="2.5">
        
        </web-app>
        
    
        <%@ page language="java" contentType="text/html; charset=UTF-8"
            pageEncoding="UTF-8"%>
        <!DOCTYPE html>
        <html>
        <head>
        <meta charset="utf-8">
        <title>hello,kuangshen</title>
        </head>
        <body>
        Hello World!<br/>
        <%
        System.out.println("----my test web logs----");
        %>
        </body>
        </html>
        
    

发现：项目部署成功，可以直接访问ok！

我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！

### 发布自己的镜像

> DockerHub

1.  地址 [https://hub.docker.com/](https://hub.docker.com/) 注册自己的账号！
    
2.  确定这个账号可以登录
    
3.  在我们的服务器上提交自己的镜像
    
        [root@ls-Cwj2oH9C tomcatlogs]# docker login --help
        
        Usage:  docker login [OPTIONS] [SERVER]
        
        Log in to a Docker registry.
        If no server is specified, the default is defined by the daemon.
        
        Options:
          -p, --password string   Password
              --password-stdin    Take the password from stdin
          -u, --username string   Username
        
    
4.  登录完毕后就可以提交镜像了，就是一步 docker push
    
        # 给自己要发布的镜像增加一个 tag
        [root@ls-Cwj2oH9C tomcat]# docker tag 52f83276fc08 wydilearn/diytomcat:1.0
        
        # docker push上去即可！自己发布的镜像尽量带上版本号
        [root@ls-Cwj2oH9C tomcat]# docker push wydilearn/diytomcat:1.0
        The push refers to repository [docker.io/wydilearn/diytomcat]
        3c40fff9f2ee: Pushed 
        fc3bd8b32ed0: Pushed 
        f8c82bfdcfb9: Pushed 
        a5760cf5dc3b: Pushed 
        174f56854903: Mounted from library/centos 
        1.0: digest: sha256:e0fae8f6383fdbf05a1fc89676fd7696949fc16d378f698a60918cb16a0fabb9 size: 1373
        
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200840705-1182635883.png)
    
    提交的时候也是按照镜像的层级来进行提交的。
    

> 发布到阿里云镜像服务上

1.  登录阿里云
    
2.  找到容器镜像服务
    
3.  创建命名空间
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200852139-1885823286.png)
    
4.  创建容器镜像
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200859952-1014170904.png)
    
5.  浏览阿里云
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200908554-357076064.png)
    

阿里云容器镜像就参考官方地址！

### 小结

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200919494-248337339.png)

Docker 网络
---------

### 理解Docker0

清空所有环境

> 测试

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200928908-902100752.png)

三个网络

    # 问题：docker 是如何处理容器网络访问的？
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200938364-673278475.png)

    [root@ls-Cwj2oH9C /]# docker run -d -P --name tomcat01 tomcat
    
    # 查看容器的内部网络地址 ip addr，发现容器启动的时候会得到一个 eth0@if2763 IP地址，docker分配的！
    [root@ls-Cwj2oH9C /]# docker exec -it 232419b4b0ff /bin/bash  # 进入容器安装两个命令
    root@232419b4b0ff:/usr/local/tomcat# apt update && apt install -y iproute2
    root@232419b4b0ff:/usr/local/tomcat# apt install iputils-ping
    root@232419b4b0ff:/usr/local/tomcat# ip addr
    1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
        inet 127.0.0.1/8 scope host lo
           valid_lft forever preferred_lft forever
    2762: eth0@if2763: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
        link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
        inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
           valid_lft forever preferred_lft forever
    
    # 思考：linux能不能ping通容器内部！
    [root@ls-Cwj2oH9C /]# ping 172.17.0.2
    PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
    64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.047 ms
    64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.044 ms
    
    # linux可以ping通容器内部
    

> 原理

1.  我们每启动一个docker容器，docker就会给docker容器分配一个IP，我们只要安装了docker，就会有一个网卡 docker0
    
    桥接模式，使用的技术是 evth-pair 技术！
    
    再次测试ip addr
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717200952302-1446152282.png)
    
2.  再启动一个容器测试，发现又多了一对网卡！
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201003984-1213930436.png)
    
        # 我们发现这个容器带来网卡，都是一对一对的
        # evth-pair 就是一堆的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连
        # 正因为有这个特性，evth-pair充当一个桥梁，连接各种虚拟网络设备
        # OpenStac，Docker容器之间的连接，OVS的连接，都是使用evth-pair技术
        
    
3.  我们来测试下tomcat01和tomcat02是否可以ping通！
    
        # 进入tomcat02
        [root@ls-Cwj2oH9C /]# docker exec -it tomcat02 /bin/bash
        root@fde1226260aa:/usr/local/tomcat# apt update && apt install -y iproute2
        root@fde1226260aa:/usr/local/tomcat# apt install iputils-ping
        root@fde1226260aa:/usr/local/tomcat# ping 172.17.0.2
        PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
        64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.087 ms
        64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.071 ms
        
    
    结论：容器和容器之间是可以互相ping通的！
    

**绘制一个网络模型图：**

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201014047-167591703.png)

结论：tomcat01 和 tomcat02 是共用的一个路由器，docker0。

所有的容器不指定网络的情况下，都是 docker0 路由的，docker会给我们的容器分配一个默认的可用IP

> 小结

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201025167-810062731.png)

Docker中的所有网络接口都是虚拟的。虚拟的转发效率高！

只要容器删除，对应的一对网桥就没了！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201033415-1210505915.png)

### \--link

> 思考一个场景，我们编写了一个微服务，database url=ip：，项目不重启数据库ip换掉了，我们希望可以处理这个问题，可以通过名字来进行访问容器？

    [root@ls-Cwj2oH9C ~]# docker exec -it tomcat02 ping tomcat01
    ping: tomcat01: Name or service not known
    
    # 如何可以解决呢？
    # 通过--link 就可以解决网络连通问题
    [root@ls-Cwj2oH9C ~]# docker run -it -d -P --name tomcat03 --link tomcat02 tomcat
    371f584079471c6b8934c5ee961d741dba06884e0e85135bd0d224f685f0d6ca
    [root@ls-Cwj2oH9C ~]# docker exec -it tomcat03 /bin/bash
    root@371f58407947:/usr/local/tomcat# apt update && apt install -y iproute2
    root@371f58407947:/usr/local/tomcat# apt install iputils-ping
    root@371f58407947:/usr/local/tomcat# ping tomcat02
    PING tomcat02 (172.17.0.3) 56(84) bytes of data.
    64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.111 ms
    64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.062 ms
    64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.061 ms
    

探究：inspect！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201046155-978328603.png)

其实这个tomcat03就是在本地配置了tomcat02配置

    # 查看 hosts 配置，在这里原理发现！
    [root@ls-Cwj2oH9C ~]# docker exec -it tomcat03 /bin/bash
    root@371f58407947:/usr/local/tomcat# cat /etc/hosts
    127.0.0.1	localhost
    ::1	localhost ip6-localhost ip6-loopback
    fe00::0	ip6-localnet
    ff00::0	ip6-mcastprefix
    ff02::1	ip6-allnodes
    ff02::2	ip6-allrouters
    172.17.0.3	tomcat02 fde1226260aa
    172.17.0.4	371f58407947
    

本质探究：--link 就是在hosts配置中增加了一个 172.17.0.3 tomcat02 fde1226260aa

我们现在用Docker，已经不建议使用 --link 了！

自定义网络！不使用docker0！

docker0的问题：它不支持容器名连接访问！

### 自定义网络

> 查看所有的docker网络

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201057140-757584188.png)

**网络模式**

bridge：桥接模式 docker（默认，自己创建也使用 bridge 桥接模式）

none：不配置网络

host：和宿主机共享网络

container：容器内网络连通！（用的较少！局限很大）

**三种常见网络模式（补充）**

bridged（桥接模式）

虚拟机和宿主计算机处于同等地位，虚拟机就像是一台真实主机一样存在于局域网中

NAT（网络地址转换模式）

宿主计算机相当于一台开启了DHCP功能的路由器，而虚拟机则是内网中的一台真实主机

host-only（仅主机模式）

相当于虚拟机通过双绞线和宿主计算机直连，而宿主计算机不提供任何路由服务。因此在Host-only模式下，虚拟机可以和宿主计算机互相访问，但是虚拟机无法访问外部网络。

**测试**

    # 我们直接启动的命令 --net bridge，而这个就是我们的docker0
    [root@ls-Cwj2oH9C /]# docker run -d -P --name tomcat01 tomcat
    [root@ls-Cwj2oH9C /]# docker run -d -P --name tomcat01 --net bridge tomcat
    
    # docker0特点，默认，域名不能访问，--link可以打通连接！
    
    # 我们可以自定义一个网络！
    # --driver bridge
    # --subnet 192.168.0.0/16  192.168.0.2 192.168.255.255
    # --gateway 192.168.0.1
    [root@ls-Cwj2oH9C /]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
    c82c2708387b95f0d932ae395fe0dc1d3182d38a47b820584c66e39219541eb4
    [root@ls-Cwj2oH9C /]# docker network ls
    NETWORK ID     NAME      DRIVER    SCOPE
    1340a553ba22   bridge    bridge    local
    6f12b7793243   host      host      local
    c82c2708387b   mynet     bridge    local
    2581ba94b5d9   none      null      local
    
    

我们自己的网络就创建好了！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201114320-1738303374.png)

    [root@ls-Cwj2oH9C /]# docker run -d -P --name tomcat-net-01 --net mynet tomcat
    e1d698bdf7bd90daf158e00e7f3c69785590198b477e1b45ef0fb2f6d2dd8ed6
    [root@ls-Cwj2oH9C /]# docker run -d -P --name tomcat-net-02 --net mynet tomcat
    685b7164f606200c809c81858a291374171ed2ddf77e30e24f94fbbbbcdbe2e1
    [root@ls-Cwj2oH9C /]# docker network inspect mynet
    [
        {
            "Name": "mynet",
            "Id": "c82c2708387b95f0d932ae395fe0dc1d3182d38a47b820584c66e39219541eb4",
            "Created": "2022-07-16T17:38:25.818266785+08:00",
            "Scope": "local",
            "Driver": "bridge",
            "EnableIPv6": false,
            "IPAM": {
                "Driver": "default",
                "Options": {},
                "Config": [
                    {
                        "Subnet": "192.168.0.0/16",
                        "Gateway": "192.168.0.1"
                    }
                ]
            },
            "Internal": false,
            "Attachable": false,
            "Ingress": false,
            "ConfigFrom": {
                "Network": ""
            },
            "ConfigOnly": false,
            "Containers": {
                "685b7164f606200c809c81858a291374171ed2ddf77e30e24f94fbbbbcdbe2e1": {
                    "Name": "tomcat-net-02",
                    "EndpointID": "7a3ac62a87388c10907bee1b83800d28968caf47160bec9999c3921a3e5183ff",
                    "MacAddress": "02:42:c0:a8:00:03",
                    "IPv4Address": "192.168.0.3/16",
                    "IPv6Address": ""
                },
                "e1d698bdf7bd90daf158e00e7f3c69785590198b477e1b45ef0fb2f6d2dd8ed6": {
                    "Name": "tomcat-net-01",
                    "EndpointID": "ea12cb9879b8d6801eabd3510e67e3a546888723ea743eedaec5274cca080ff0",
                    "MacAddress": "02:42:c0:a8:00:02",
                    "IPv4Address": "192.168.0.2/16",
                    "IPv6Address": ""
                }
            },
            "Options": {},
            "Labels": {}
        }
    ]
    
    # 再次测试ping连接
    [root@ls-Cwj2oH9C ~]# docker exec -it tomcat-net-01 ping 192.168.0.3
    PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.
    64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.085 ms
    64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.070 ms
    
    # 现在不使用--link也可以ping名字了！
    [root@ls-Cwj2oH9C ~]# docker exec -it tomcat-net-01 ping tomcat-net-02
    PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.
    64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.055 ms
    64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.063 ms
    

我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络！

好处：

redis - 不同的集群使用不同的网络，保证集群是安全和健康的

mysql - 不同的集群使用不同的网络，保证集群是安全和健康的

### 网络连通

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201138215-1791737233.png)

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201146901-210840781.png)

    # 测试打通 tomcat01 - mynet
    
    # 连通之后就是将 tomcat01 放到了 mynet 网络下
    
    # 一个容器两个ip地址!
    
    # 阿里云服务：公网ip  私网ip
    

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201155745-122180006.png)

    # 01 连通ok
    [root@ls-Cwj2oH9C ~]# docker exec -it tomcat01 ping tomcat-net-01
    PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.
    64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.072 ms
    64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.070 ms
    
    # 02 是依旧打不通的
    [root@ls-Cwj2oH9C ~]# docker exec -it tomcat02 ping tomcat-net-01
    ping: tomcat-net-01: Name or service not known
    

结论：假设要跨网络操作别人，就需要使用 docker network connect 连通！

### 实战：部署Redis集群

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201205849-1296117224.png)

shell脚本

    # 创建网卡
    [root@ls-Cwj2oH9C /]# docker network create redis --subnet 172.38.0.0/16
    
    # 通过脚本创建六个redis配置
    [root@ls-Cwj2oH9C /]# for port in $(seq 1 6); \
    > do \
    > mkdir -p /mydata/redis/node-${port}/conf
    > touch /mydata/redis/node-${port}/conf/redis.conf
    > cat << EOF >/mydata/redis/node-${port}/conf/redis.conf
    > port 6379
    > bind 0.0.0.0
    > cluster-enabled yes
    > cluster-config-file nodes.conf
    > cluster-node-timeout 5000
    > cluster-announce-ip 172.38.0.1${port}
    > cluster-announce-port 6379
    > cluster-announce-bus-port 16379
    > appendonly yes
    > EOF
    > done
    
    [root@ls-Cwj2oH9C conf]# docker run -p 6371:6379 -p 16371:16379 --name redis-1 \
    > -v /mydata/redis/node-1/data:/data \
    > -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \
    > -d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
    
    [root@ls-Cwj2oH9C conf]# docker run -p 6372:6379 -p 16372:16379 --name redis-2 \
    > -v /mydata/redis/node-2/data:/data \
    > -v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \
    > -d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
    
    [root@ls-Cwj2oH9C conf]# docker run -p 6373:6379 -p 16373:16379 --name redis-3 \
    > -v /mydata/redis/node-3/data:/data \
    > -v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \
    > -d --net redis --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
    
    [root@ls-Cwj2oH9C conf]# docker run -p 6374:6379 -p 16374:16379 --name redis-4 \
    > -v /mydata/redis/node-4/data:/data \
    > -v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \
    > -d --net redis --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
    
    [root@ls-Cwj2oH9C conf]# docker run -p 6375:6379 -p 16375:16379 --name redis-5 \
    > -v /mydata/redis/node-5/data:/data \
    > -v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \
    > -d --net redis --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
    
    [root@ls-Cwj2oH9C conf]# docker run -p 6376:6379 -p 16376:16379 --name redis-6 \
    > -v /mydata/redis/node-6/data:/data \
    > -v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \
    > -d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
    
    # 任意进入一个reids容器，注意使用 /bin/sh 而不是 /bin/bash
    [root@ls-Cwj2oH9C conf]# docker exec -it redis-1 /bin/sh
    
    # 创建集群
    /data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6
    379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1
    >>> Performing hash slots allocation on 6 nodes...
    Master[0] -> Slots 0 - 5460
    Master[1] -> Slots 5461 - 10922
    Master[2] -> Slots 10923 - 16383
    Adding replica 172.38.0.15:6379 to 172.38.0.11:6379
    Adding replica 172.38.0.16:6379 to 172.38.0.12:6379
    Adding replica 172.38.0.14:6379 to 172.38.0.13:6379
    M: f142bdcc5c5d7ac81eb70d91da9987b71a79d2e2 172.38.0.11:6379
       slots:[0-5460] (5461 slots) master
    M: 3ab93307a4de5df775702779665ca4583abe5210 172.38.0.12:6379
       slots:[5461-10922] (5462 slots) master
    M: abe4ba6a98b5fe967d952ffc06060d7c07474821 172.38.0.13:6379
       slots:[10923-16383] (5461 slots) master
    S: ca57da80daea08a065f5add0a607edde9d11e7eb 172.38.0.14:6379
       replicates abe4ba6a98b5fe967d952ffc06060d7c07474821
    S: e9664d81440a18689a1d8cd00f7a191f78f0979c 172.38.0.15:6379
       replicates f142bdcc5c5d7ac81eb70d91da9987b71a79d2e2
    S: f972b8b774941d383a26ab31cc337c5017657ba0 172.38.0.16:6379
       replicates 3ab93307a4de5df775702779665ca4583abe5210
    Can I set the above configuration? (type 'yes' to accept): yes
    >>> Nodes configuration updated
    >>> Assign a different config epoch to each node
    >>> Sending CLUSTER MEET messages to join the cluster
    Waiting for the cluster to join
    ...
    >>> Performing Cluster Check (using node 172.38.0.11:6379)
    M: f142bdcc5c5d7ac81eb70d91da9987b71a79d2e2 172.38.0.11:6379
       slots:[0-5460] (5461 slots) master
       1 additional replica(s)
    M: abe4ba6a98b5fe967d952ffc06060d7c07474821 172.38.0.13:6379
       slots:[10923-16383] (5461 slots) master
       1 additional replica(s)
    S: ca57da80daea08a065f5add0a607edde9d11e7eb 172.38.0.14:6379
       slots: (0 slots) slave
       replicates abe4ba6a98b5fe967d952ffc06060d7c07474821
    S: f972b8b774941d383a26ab31cc337c5017657ba0 172.38.0.16:6379
       slots: (0 slots) slave
       replicates 3ab93307a4de5df775702779665ca4583abe5210
    S: e9664d81440a18689a1d8cd00f7a191f78f0979c 172.38.0.15:6379
       slots: (0 slots) slave
       replicates f142bdcc5c5d7ac81eb70d91da9987b71a79d2e2
    M: 3ab93307a4de5df775702779665ca4583abe5210 172.38.0.12:6379
       slots:[5461-10922] (5462 slots) master
       1 additional replica(s)
    [OK] All nodes agree about slots configuration.
    >>> Check for open slots...
    >>> Check slots coverage...
    [OK] All 16384 slots covered.
    
    /data # redis-cli -c
    127.0.0.1:6379> cluster info
    127.0.0.1:6379> cluster nodes
    127.0.0.1:6379> set a b
    
    [root@ls-Cwj2oH9C ~]# docker stop redis-3
    redis-3
    
    127.0.0.1:6379> get a
    -> Redirected to slot [15495] located at 172.38.0.14:6379
    "b"
    

docker搭建redis集群完成！

![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201221321-1525321238.png)

我们使用了docker之后，所有的技术都会慢慢的变得简单起来！

### SpringBoot微服务打包Docker镜像

1.  构建springboot项目
    
        @RestController
        public class HelloController {
        
            @RequestMapping("/hello")
            public String hello(){
                return "hello,wydilearn";
            }
        }
        
    
2.  打包应用
    
    ![](https://img2022.cnblogs.com/blog/2504313/202207/2504313-20220717201232011-2063681639.png)
    
3.  编写dockerfile
    
        FROM java:8
        
        COPY *.jar /app.jar
        
        CMD ["--server.port=8080"]
        
        EXPOSE 8080
        
        ENTRYPOINT ["java","-jar","/app.jar"]
        
    
4.  构建镜像
    
        [root@ls-Cwj2oH9C home]# mkdir idea
        [root@ls-Cwj2oH9C home]# cd idea
        [root@ls-Cwj2oH9C idea]# ls
        demo1-0.0.1-SNAPSHOT.jar  Dockerfile
        [root@ls-Cwj2oH9C idea]# docker build -t wydilearn .
        
    
5.  发布运行！
    
        [root@ls-Cwj2oH9C idea]# docker run -d -P --name wydilearn-springboot-web wydilearn
        cd4d8f37d9e980af091eceac6ef30f51b9291fc415c53457285353881e19f84b
        [root@ls-Cwj2oH9C idea]# docker ps
        CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS          PORTS                                         NAMES
        cd4d8f37d9e9   wydilearn   "java -jar /app.jar …"   37 seconds ago   Up 36 seconds   0.0.0.0:49163->8080/tcp, :::49163->8080/tcp   wydilearn-springboot-web
        [root@ls-Cwj2oH9C idea]# curl localhost:49163
        {"timestamp":"2022-07-17T04:04:03.880+00:00","status":404,"error":"Not Found","path":"/"}
        [root@ls-Cwj2oH9C idea]# curl localhost:49163/hello
        
    

以后我们使用了Docker之后，给别人交付的就是一个镜像即可！

到了这里我们已经完全够用了Docker！

未完待续。。。

作者：[wangyudong](https://www.cnblogs.com/wydilearn)

出处：[https://www.cnblogs.com/wydilearn](https://www.cnblogs.com/wydilearn)

本文版权归作者和博客园共有，欢迎转载，但必须给出原文链接，并保留此段声明，否则保留追究法律责任的权利。