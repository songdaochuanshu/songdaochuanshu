---
layout: post
title: "BatteryStatsHelper.javaæºç åˆ†æ"
date: "2023-01-14T15:15:00.687Z"
---
BatteryStatsHelper.javaæºç åˆ†æ
===========================

åœ¨åˆ†æ`PowerUsageSummary`çš„æ—¶å€™ï¼Œå…¶å®å¯ä»¥å‘ç°ä¸»è¦è·å–åº”ç”¨å’ŒæœåŠ¡ç”µé‡ä½¿ç”¨æƒ…å†µçš„å®ç°æ˜¯åœ¨`BatteryStatsHelper.java`ä¸­

è¿˜æ˜¯åœ¨çº¿ç½‘ç«™http://androidxref.com/ä¸Šå¯¹Androidç‰ˆæœ¬6.0.1\_r10æºç è¿›è¡Œåˆ†æ

å…·ä½“ä½ç½®åœ¨ /frameworks/base/core/java/com/android/internal/os/BatteryStatsHelper.java

createæ–¹æ³•
--------

æŸ¥çœ‹æ„é€ æ–¹æ³•

    public BatteryStatsHelper(Context context) {
        this(context, true);
    }
    
    public BatteryStatsHelper(Context context, boolean collectBatteryBroadcast) {
        this(context, collectBatteryBroadcast, checkWifiOnly(context));
    }
    
    public BatteryStatsHelper(Context context, boolean collectBatteryBroadcast, boolean wifiOnly) {
        mContext = context;
        mCollectBatteryBroadcast = collectBatteryBroadcast;
        mWifiOnly = wifiOnly;
    }
    

è®¾ç½®æ˜¯å¦éœ€è¦æ³¨å†Œ`BATTERY_CHANGED`é©»ç•™å¹¿æ’­ï¼Œè¯¥å¹¿æ’­ç›‘å¬ç³»ç»Ÿç”µæ± ç”µé‡å’Œå……ç”µçŠ¶æ€

    mCollectBatteryBroadcast = collectBatteryBroadcast;
    

è®¾å¤‡æ˜¯å¦åªæœ‰wifiï¼Œæ— ç§»åŠ¨ç½‘ç»œï¼Œæ¯”å¦‚è¯´å¹³æ¿æˆ–è€…è½¦æœºï¼Œæœ‰çš„å°±æ˜¯ä¸èƒ½æ’SIMå¡çš„

    mWifiOnly = wifiOnly;
    

æŸ¥çœ‹createæ–¹æ³•

    public void create(BatteryStats stats) {
        mPowerProfile = new PowerProfile(mContext);
        mStats = stats;
    }
    
    public void create(Bundle icicle) {
        if (icicle != null) {
            mStats = sStatsXfer;
            mBatteryBroadcast = sBatteryBroadcastXfer;
        }
        mBatteryInfo = IBatteryStats.Stub.asInterface(
            ServiceManager.getService(BatteryStats.SERVICE_NAME));
        mPowerProfile = new PowerProfile(mContext);
    }
    

å…¶ä¸­éƒ½è·å–äº†PowerProfileå¯¹è±¡

    mPowerProfile = new PowerProfile(mContext);
    

PowerProfileåˆ›å»º
--------------

æŒç»­è·Ÿè¿›

    public PowerProfile(Context context) {
        // Read the XML file for the given profile (normally only one per
        // device)
        if (sPowerMap.size() == 0) {
            readPowerValuesFromXml(context);
        }
        initCpuClusters();
    }
    

å¯ä»¥çœ‹åˆ°è¿™é‡Œæœ‰ä¸€æ®µæ³¨é‡Šï¼š Read the XML file for the given profile (normally only one perdevice

è·Ÿè¿›`readPowerValuesFromXml`æ–¹æ³•ï¼Œå…¶å®è¿™ä¸ªæ–¹æ³•å°±æ˜¯ç”¨æ¥è§£æ`power_profile.xml`æ–‡ä»¶çš„ï¼Œè¯¥æ–‡ä»¶åœ¨æºç ä¸­çš„ä½ç½®ä¸º `/frameworks/base/core/res/res/xml/power_profile.xml`ï¼Œ`power_profile.xml`æ˜¯ä¸€ä¸ªå¯é…ç½®çš„åŠŸè€—æ•°æ®æ–‡ä»¶

    private void readPowerValuesFromXml(Context context) {
        int id = com.android.internal.R.xml.power_profile;
        final Resources resources = context.getResources();
        XmlResourceParser parser = resources.getXml(id);
        boolean parsingArray = false;
        ArrayList<Double> array = new ArrayList<Double>();
        String arrayName = null;
    
        try {
            // ....
    

![](https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20230114143529.png)

åœ¨è¿™é‡Œéœ€è¦æä¸€ä¸‹Androidä¸­å¯¹äºåº”ç”¨å’Œç¡¬ä»¶çš„è€—ç”µé‡è®¡ç®—æ–¹å¼ï¼š

æœ‰ä¸€å¼ â€œä»·æ ¼è¡¨â€ï¼Œè®°å½•æ¯ç§ç¡¬ä»¶1ç§’é’Ÿè€—å¤šå°‘ç”µã€‚æœ‰ä¸€å¼ â€œè´­ç‰©æ¸…å•â€ï¼Œè®°å½•apkä½¿ç”¨äº†å“ªå‡ ç§ç¡¬ä»¶ï¼Œæ¯ç§ç¡¬ä»¶ç”¨äº†å¤šé•¿æ—¶é—´ã€‚å‡è®¾æŸä¸ªåº”ç”¨ç´¯è®¡ä½¿ç”¨äº†60ç§’çš„cpuï¼Œcpu1ç§’é’Ÿè€—1mAhï¼Œé‚£è¿™ä¸ªåº”ç”¨å°±æ¶ˆè€—äº†60mAhçš„ç”µ

è¿™é‡Œçš„ä»·æ ¼è¡¨å°±æ˜¯æˆ‘ä»¬æ‰¾åˆ°çš„`power_profile.xml`æ–‡ä»¶ï¼Œæ‰‹æœºçš„ç¡¬ä»¶æ˜¯å„ä¸ç›¸åŒçš„ï¼Œæ‰€ä»¥æ¯ä¸€æ¬¾æ‰‹æœºéƒ½ä¼šæœ‰ä¸€å¼ è‡ªå·±çš„"ä»·æ ¼è¡¨"ï¼Œè¿™å¼ è¡¨çš„å‡†ç¡®æ€§ç”±æ‰‹æœºå‚å•†è´Ÿè´£ã€‚

è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬ç¢°åˆ°è¯»å–xmlæ–‡ä»¶çš„æ—¶å€™æ³¨é‡Šé‡Œé¢ä¼šæœ‰`normally only one perdevice`

å¦‚æœæˆ‘ä»¬æƒ³è¦çœ‹è‡ªå·±æ‰‹æœºçš„power\_profile.xmlæ–‡ä»¶å’‹åŠï¼Œå®ƒä¼šå­˜å‚¨åœ¨æ‰‹æœºçš„`/system/framework/framework-res.apk`è·¯å¾„ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒpullå‡ºæ¥ï¼Œé€šè¿‡åç¼–è¯‘çš„æ‰‹æ³•è·å¾—`power_profile.xml`æ–‡ä»¶

refreshStatsæ–¹æ³•
--------------

æ¥ç€å¯ä»¥çœ‹åˆ°é‡è½½çš„`refreshStats`

    /**
     * Refreshes the power usage list.
     */
    public void refreshStats(int statsType, int asUser) {
        SparseArray<UserHandle> users = new SparseArray<>(1);
        users.put(asUser, new UserHandle(asUser));
        refreshStats(statsType, users);
    }
    
    /**
     * Refreshes the power usage list.
     */
    public void refreshStats(int statsType, List<UserHandle> asUsers) {
        final int n = asUsers.size();
        SparseArray<UserHandle> users = new SparseArray<>(n);
        for (int i = 0; i < n; ++i) {
            UserHandle userHandle = asUsers.get(i);
            users.put(userHandle.getIdentifier(), userHandle);
        }
        refreshStats(statsType, users);
    }
    
    /**
     * Refreshes the power usage list.
     */
    public void refreshStats(int statsType, SparseArray<UserHandle> asUsers) {
        refreshStats(statsType, asUsers, SystemClock.elapsedRealtime() * 1000,
                     SystemClock.uptimeMillis() * 1000);
    }
    

`refreshStats`æ˜¯åˆ·æ–°ç”µæ± ä½¿ç”¨æ•°æ®çš„æ¥å£ï¼Œå‘ä¸Šæä¾›æ•°æ®ï¼Œå…¶ä¸­çš„å…·ä½“å®ç°åœ¨

    public void refreshStats(int statsType, SparseArray<UserHandle> asUsers, long rawRealtimeUs,
                long rawUptimeUs) {
        // Initialize mStats if necessary.
        getStats();
    
        mMaxPower = 0;
        mMaxRealPower = 0;
        mComputedPower = 0;
        mTotalPower = 0;
    
        mUsageList.clear();
        mWifiSippers.clear();
        mBluetoothSippers.clear();
        mUserSippers.clear();
        mMobilemsppList.clear();
    
        if (mStats == null) {
            return;
        }
    
        if (mCpuPowerCalculator == null) {
            mCpuPowerCalculator = new CpuPowerCalculator(mPowerProfile);
        }
        mCpuPowerCalculator.reset();
    
        if (mWakelockPowerCalculator == null) {
            mWakelockPowerCalculator = new WakelockPowerCalculator(mPowerProfile);
        }
        mWakelockPowerCalculator.reset();
    
        if (mMobileRadioPowerCalculator == null) {
            mMobileRadioPowerCalculator = new MobileRadioPowerCalculator(mPowerProfile, mStats);
        }
        mMobileRadioPowerCalculator.reset(mStats);
    
        // checkHasWifiPowerReporting can change if we get energy data at a later point, so
        // always check this field.
        final boolean hasWifiPowerReporting = checkHasWifiPowerReporting(mStats, mPowerProfile);
        if (mWifiPowerCalculator == null || hasWifiPowerReporting != mHasWifiPowerReporting) {
            mWifiPowerCalculator = hasWifiPowerReporting ?
                new WifiPowerCalculator(mPowerProfile) :
            new WifiPowerEstimator(mPowerProfile);
            mHasWifiPowerReporting = hasWifiPowerReporting;
        }
        mWifiPowerCalculator.reset();
    
        final boolean hasBluetoothPowerReporting = checkHasBluetoothPowerReporting(mStats,
                                                                                   mPowerProfile);
        if (mBluetoothPowerCalculator == null ||
            hasBluetoothPowerReporting != mHasBluetoothPowerReporting) {
            mBluetoothPowerCalculator = new BluetoothPowerCalculator(mPowerProfile);
            mHasBluetoothPowerReporting = hasBluetoothPowerReporting;
        }
        mBluetoothPowerCalculator.reset();
    
        if (mSensorPowerCalculator == null) {
            mSensorPowerCalculator = new SensorPowerCalculator(mPowerProfile,
                                                               (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE));
        }
        mSensorPowerCalculator.reset();
    
        if (mCameraPowerCalculator == null) {
            mCameraPowerCalculator = new CameraPowerCalculator(mPowerProfile);
        }
        mCameraPowerCalculator.reset();
    
        if (mFlashlightPowerCalculator == null) {
            mFlashlightPowerCalculator = new FlashlightPowerCalculator(mPowerProfile);
        }
        mFlashlightPowerCalculator.reset();
    
        mStatsType = statsType;
        mRawUptime = rawUptimeUs;
        mRawRealtime = rawRealtimeUs;
        mBatteryUptime = mStats.getBatteryUptime(rawUptimeUs);
        mBatteryRealtime = mStats.getBatteryRealtime(rawRealtimeUs);
        mTypeBatteryUptime = mStats.computeBatteryUptime(rawUptimeUs, mStatsType);
        mTypeBatteryRealtime = mStats.computeBatteryRealtime(rawRealtimeUs, mStatsType);
        mBatteryTimeRemaining = mStats.computeBatteryTimeRemaining(rawRealtimeUs);
        mChargeTimeRemaining = mStats.computeChargeTimeRemaining(rawRealtimeUs);
    
        if (DEBUG) {
            Log.d(TAG, "Raw time: realtime=" + (rawRealtimeUs/1000) + " uptime="
                  + (rawUptimeUs/1000));
            Log.d(TAG, "Battery time: realtime=" + (mBatteryRealtime/1000) + " uptime="
                  + (mBatteryUptime/1000));
            Log.d(TAG, "Battery type time: realtime=" + (mTypeBatteryRealtime/1000) + " uptime="
                  + (mTypeBatteryUptime/1000));
        }
        mMinDrainedPower = (mStats.getLowDischargeAmountSinceCharge()
                            * mPowerProfile.getBatteryCapacity()) / 100;
        mMaxDrainedPower = (mStats.getHighDischargeAmountSinceCharge()
                            * mPowerProfile.getBatteryCapacity()) / 100;
    
        processAppUsage(asUsers);
    
        // Before aggregating apps in to users, collect all apps to sort by their ms per packet.
        for (int i=0; i<mUsageList.size(); i++) {
            BatterySipper bs = mUsageList.get(i);
            bs.computeMobilemspp();
            if (bs.mobilemspp != 0) {
                mMobilemsppList.add(bs);
            }
        }
    
        for (int i=0; i<mUserSippers.size(); i++) {
            List<BatterySipper> user = mUserSippers.valueAt(i);
            for (int j=0; j<user.size(); j++) {
                BatterySipper bs = user.get(j);
                bs.computeMobilemspp();
                if (bs.mobilemspp != 0) {
                    mMobilemsppList.add(bs);
                }
            }
        }
        Collections.sort(mMobilemsppList, new Comparator<BatterySipper>() {
            @Override
            public int compare(BatterySipper lhs, BatterySipper rhs) {
                return Double.compare(rhs.mobilemspp, lhs.mobilemspp);
            }
        });
    
        processMiscUsage();
    
        Collections.sort(mUsageList);
    
        // At this point, we've sorted the list so we are guaranteed the max values are at the top.
        // We have only added real powers so far.
        if (!mUsageList.isEmpty()) {
            mMaxRealPower = mMaxPower = mUsageList.get(0).totalPowerMah;
            final int usageListCount = mUsageList.size();
            for (int i = 0; i < usageListCount; i++) {
                mComputedPower += mUsageList.get(i).totalPowerMah;
            }
        }
    
        if (DEBUG) {
            Log.d(TAG, "Accuracy: total computed=" + makemAh(mComputedPower) + ", min discharge="
                  + makemAh(mMinDrainedPower) + ", max discharge=" + makemAh(mMaxDrainedPower));
        }
    
        mTotalPower = mComputedPower;
        if (mStats.getLowDischargeAmountSinceCharge() > 1) {
            if (mMinDrainedPower > mComputedPower) {
                double amount = mMinDrainedPower - mComputedPower;
                mTotalPower = mMinDrainedPower;
                BatterySipper bs = new BatterySipper(DrainType.UNACCOUNTED, null, amount);
    
                // Insert the BatterySipper in its sorted position.
                int index = Collections.binarySearch(mUsageList, bs);
                if (index < 0) {
                    index = -(index + 1);
                }
                mUsageList.add(index, bs);
                mMaxPower = Math.max(mMaxPower, amount);
            } else if (mMaxDrainedPower < mComputedPower) {
                double amount = mComputedPower - mMaxDrainedPower;
    
                // Insert the BatterySipper in its sorted position.
                BatterySipper bs = new BatterySipper(DrainType.OVERCOUNTED, null, amount);
                int index = Collections.binarySearch(mUsageList, bs);
                if (index < 0) {
                    index = -(index + 1);
                }
                mUsageList.add(index, bs);
                mMaxPower = Math.max(mMaxPower, amount);
            }
        }
    }
    

æˆ‘ä»¬ä¾æ¬¡åˆ†æ

*   `SparseArray<UserHandle> asUsers` UserHanlerä»£è¡¨è®¾å¤‡ä¸Šçš„ä¸€ä¸ªç”¨æˆ·
*   `long rawRealtimeUs` ç³»ç»Ÿå¼€æœºåçš„è¿è¡Œæ—¶é—´
*   `long rawUptimeUs` ç³»ç»Ÿä¸åŒ…æ‹¬ä¼‘çœ çš„è¿è¡Œæ—¶é—´

    public void refreshStats(int statsType, SparseArray<UserHandle> asUsers, long rawRealtimeUs,
                long rawUptimeUs) {
    

åˆå§‹åŒ–Statsæ“ä½œ

    getStats()
    

å¦‚æœmStatsä¸ºç©ºï¼Œåˆ™åˆå§‹åŒ–

    public BatteryStats getStats() {
        if (mStats == null) {
            load();
        }
        return mStats;
    }
    mMaxPower = 0; // æœ€å¤§è€—ç”µé‡
    mMaxRealPower = 0; // æœ€å¤§çœŸå®è€—ç”µé‡
    mComputedPower = 0; // é€šè¿‡è€—ç”µè®¡ç®—å™¨è®¡ç®—çš„è€—ç”µé‡æ€»å’Œ
    mTotalPower = 0; // æ€»çš„è€—ç”µé‡
    

åˆ·æ–°è€—ç”µé‡ä¹‹å‰éœ€è¦å…ˆæ¸…ç©ºä¹‹å‰çš„æ•°æ®ï¼Œclearéƒ½æ˜¯æ¸…ç©ºæ“ä½œ

    mUsageList.clear(); // å­˜å‚¨äº†BatterySipperåˆ—è¡¨ï¼Œå„ç±»è€—ç”µé‡éƒ½å­˜å‚¨åœ¨BatterySipperä¸­ï¼ŒBatterySipperå­˜å‚¨åœ¨mUsageListä¸­
    mWifiSippers.clear(); // åœ¨ç»Ÿè®¡è½¯ä»¶è€—ç”µè¿‡ç¨‹ä¸­ä½¿ç”¨åˆ°WIFIçš„åº”ç”¨ï¼Œå…¶å¯¹åº”çš„BatterySipperåˆ—è¡¨
    mBluetoothSippers.clear(); // åœ¨ç»Ÿè®¡è½¯ä»¶è€—ç”µè¿‡ç¨‹ä¸­ä½¿ç”¨åˆ°BlueToothçš„åº”ç”¨ï¼Œå…¶å¯¹åº”çš„BatterySipperåˆ—è¡¨
    mUserSippers.clear(); // è®¾å¤‡ä¸Šæœ‰å¤šä¸ªç”¨æˆ·æ—¶ï¼Œå­˜å‚¨äº†å…¶ä»–ç”¨æˆ·çš„è€—ç”µä¿¡æ¯çš„SparseArrayæ•°æ®ï¼Œé”®ä¸ºuserIdï¼Œå€¼ä¸ºå¯¹åº”çš„List<BatterySipper>
    mMobilemsppList.clear(); // å­˜å‚¨æœ‰æ•°æ®æ¥æ”¶å’Œå‘é€çš„BatterySipperå¯¹è±¡çš„åˆ—è¡¨
    

åˆå§‹åŒ–å…«å¤§æ¨¡å—çš„è€—ç”µè®¡ç®—å™¨ï¼Œéƒ½ç»§æ‰¿äº`PowerCalculator`æŠ½è±¡ç±»ï¼Œå…«å¤§æ¨¡å—åœ¨`processAppUsage`æ–¹æ³•ä¸­è¿›è¡Œåˆ†æï¼Œè¿™é‡Œåªéœ€è¦çŸ¥é“æœ‰å“ªå…«ä¸ªä»¥åŠè¿›è¡Œçš„æ“ä½œæ˜¯åˆå§‹åŒ–å³å¯

è®¡ç®—é¡¹

Classæ–‡ä»¶

CPUåŠŸè€—

mCpuPowerCalculator.java

WakelockåŠŸè€—

mWakelockPowerCalculator.java

æ— çº¿ç”µåŠŸè€—

mMobileRadioPowerCalculator.java

WIFIåŠŸè€—

mWifiPowerCalculator.java

è“ç‰™åŠŸè€—

mBluetoothPowerCalculator.java

SensoråŠŸè€—

mSensorPowerCalculator.java

ç›¸æœºåŠŸè€—

mCameraPowerCalculator.java

é—ªå…‰ç¯åŠŸè€—

mFlashlightPowerCalculator.java

    if (mCpuPowerCalculator == null) {
        mCpuPowerCalculator = new CpuPowerCalculator(mPowerProfile);
    }
    mCpuPowerCalculator.reset();
    
    if (mWakelockPowerCalculator == null) {
        mWakelockPowerCalculator = new WakelockPowerCalculator(mPowerProfile);
    }
    mWakelockPowerCalculator.reset();
    
    if (mMobileRadioPowerCalculator == null) {
        mMobileRadioPowerCalculator = new MobileRadioPowerCalculator(mPowerProfile, mStats);
    }
    mMobileRadioPowerCalculator.reset(mStats);
    
    // checkHasWifiPowerReporting can change if we get energy data at a later point, so
    // always check this field.
    final boolean hasWifiPowerReporting = checkHasWifiPowerReporting(mStats, mPowerProfile);
    if (mWifiPowerCalculator == null || hasWifiPowerReporting != mHasWifiPowerReporting) {
        mWifiPowerCalculator = hasWifiPowerReporting ?
            new WifiPowerCalculator(mPowerProfile) :
        new WifiPowerEstimator(mPowerProfile);
        mHasWifiPowerReporting = hasWifiPowerReporting;
    }
    mWifiPowerCalculator.reset();
    
    final boolean hasBluetoothPowerReporting = checkHasBluetoothPowerReporting(mStats,
                                                                               mPowerProfile);
    if (mBluetoothPowerCalculator == null ||
        hasBluetoothPowerReporting != mHasBluetoothPowerReporting) {
        mBluetoothPowerCalculator = new BluetoothPowerCalculator(mPowerProfile);
        mHasBluetoothPowerReporting = hasBluetoothPowerReporting;
    }
    mBluetoothPowerCalculator.reset();
    
    if (mSensorPowerCalculator == null) {
        mSensorPowerCalculator = new SensorPowerCalculator(mPowerProfile,
                                                           (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE));
    }
    mSensorPowerCalculator.reset();
    
    if (mCameraPowerCalculator == null) {
        mCameraPowerCalculator = new CameraPowerCalculator(mPowerProfile);
    }
    mCameraPowerCalculator.reset();
    
    if (mFlashlightPowerCalculator == null) {
        mFlashlightPowerCalculator = new FlashlightPowerCalculator(mPowerProfile);
    }
    mFlashlightPowerCalculator.reset();
    

ç”µé‡ç»Ÿè®¡éœ€è¦å…ˆè®¾ç½®ç»Ÿè®¡æ—¶é—´æ®µï¼Œé€šè¿‡è®¾ç½®ç»Ÿè®¡ç±»å‹mStatsTypeå˜é‡æ¥è¡¨ç¤º

    mStatsType = statsType;
    

æœ‰ä¸‰ç§å¯é€‰å€¼

      // ç»Ÿè®¡ä»ä¸Šä¸€æ¬¡å……ç”µä»¥æ¥è‡³ç°åœ¨çš„è€—ç”µé‡
      public static final int STATS_SINCE_CHARGED = 0;
    
      // ç»Ÿè®¡ç³»ç»Ÿå¯åŠ¨ä»¥æ¥åˆ°ç°åœ¨çš„è€—ç”µé‡
      public static final int STATS_CURRENT = 1;
    
      // ç»Ÿè®¡ä»ä¸Šä¸€æ¬¡æ‹”æ‰USBçº¿ä»¥æ¥åˆ°ç°åœ¨çš„è€—ç”µé‡
      public static final int STATS_SINCE_UNPLUGGED = 2;
    

å½“å‰ç³»ç»Ÿçš„è¿è¡Œæ—¶é—´

    mRawUptimeUs = rawUptimeUs;
    

å½“å‰ç³»ç»Ÿçš„çœŸå®è¿è¡Œæ—¶é—´ï¼ŒåŒ…æ‹¬ä¼‘çœ æ—¶é—´

    mRawRealtimeUs = rawRealtimeUs;
    

å‰©ä¸‹çš„ä¹Ÿæ˜¯ä¸€å †æ—¶é—´

    mBatteryUptime = mStats.getBatteryUptime(rawUptimeUs); // ç”µæ± æ”¾ç”µè¿è¡Œæ—¶é—´
    mBatteryRealtime = mStats.getBatteryRealtime(rawRealtimeUs); // ç”µæ± çœŸå®æ”¾ç”µè¿è¡Œæ—¶é—´ï¼ŒåŒ…å«ä¼‘çœ æ—¶é—´
    mTypeBatteryUptime = mStats.computeBatteryUptime(rawUptimeUs, mStatsType); // å¯¹åº”ç±»å‹çš„ç”µæ± æ”¾ç”µè¿è¡Œæ—¶é—´ï¼Œå¦‚ä¸Šæ¬¡å……æ»¡ç”µåçš„ç”µæ± è¿è¡Œæ—¶é—´
    mTypeBatteryRealtime = mStats.computeBatteryRealtime(rawRealtimeUs, mStatsType); // å¯¹åº”ç±»å‹çš„ç”µæ± æ”¾ç”µè¿è¡Œæ—¶é—´,åŒ…æ‹¬ä¼‘çœ æ—¶é—´
    mBatteryTimeRemaining = mStats.computeBatteryTimeRemaining(rawRealtimeUs); // ç”µæ± é¢„è®¡ä½¿ç”¨æ—¶é•¿
    mChargeTimeRemaining = mStats.computeChargeTimeRemaining(rawRealtimeUs); // ç”µæ± é¢„è®¡å¤šä¹…å……æ»¡æ—¶é•¿
    

DEBUGæ¨¡å¼ä¸‹ä¼šè¾“å‡ºæ—¶é—´æ—¥å¿—ï¼Œè¿™ä¸é‡è¦

    if (DEBUG) {
        Log.d(TAG, "Raw time: realtime=" + (rawRealtimeUs/1000) + " uptime="
              + (rawUptimeUs/1000));
        Log.d(TAG, "Battery time: realtime=" + (mBatteryRealtime/1000) + " uptime="
              + (mBatteryUptime/1000));
        Log.d(TAG, "Battery type time: realtime=" + (mTypeBatteryRealtime/1000) + " uptime="
              + (mTypeBatteryUptime/1000));
    }
    

è®¡ç®—æœ€ä½å’Œæœ€é«˜çš„ç”µé‡è¿‘ä¼¼å€¼

è¯¥æ–¹æ³•å¾…ä¼šè¯¦ç»†è¯´æ˜ï¼Œç°åœ¨æˆ‘ä»¬åªéœ€è¦çŸ¥é“å®ƒä¸»è¦è¿›è¡Œç»Ÿè®¡APPè½¯ä»¶çš„è€—ç”µé‡æ“ä½œï¼Œç»Ÿè®¡ä¹‹åä¼šå°†æ¯ç§ç±»å‹ï¼Œæ¯ä¸ªUIDçš„è€—ç”µå€¼å­˜å‚¨åœ¨å¯¹åº”çš„`BatterySipper`ä¸­

    processAppUsage(asUsers);
    

å¯¹æ¯ä¸ªåº”ç”¨ç¨‹åºçš„æ¯æ¯«ç§’msæ¥æ”¶å’Œå‘é€çš„æ•°æ®åŒ…`mobilemspp`è¿›è¡Œæ’åº

    for (int i=0; i<mUsageList.size(); i++) {
        BatterySipper bs = mUsageList.get(i);
        bs.computeMobilemspp();
        if (bs.mobilemspp != 0) {
            mMobilemsppList.add(bs);
        }
    }
    // éå†å…¶ä»–ç”¨æˆ·çš„è€—ç”µæƒ…å†µ
    for (int i=0; i<mUserSippers.size(); i++) {
        List<BatterySipper> user = mUserSippers.valueAt(i);
        for (int j=0; j<user.size(); j++) {
            BatterySipper bs = user.get(j);
            bs.computeMobilemspp();
            if (bs.mobilemspp != 0) {
                mMobilemsppList.add(bs);
            }
        }
    }
    

å¯¹`mMobilemsppList`è¿›è¡Œæ’åº

    Collections.sort(mMobilemsppList, new Comparator<BatterySipper>() {
        @Override
        public int compare(BatterySipper lhs, BatterySipper rhs) {
            return Double.compare(rhs.mobilemspp, lhs.mobilemspp);
        }
    });
    

è®¡ç®—ç¡¬ä»¶çš„è€—ç”µé‡ï¼Œè·Ÿå‰é¢çš„`processAppUsage(asUsers);`å¯¹åº”ï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•æˆ‘ä»¬éƒ½åé¢å†è¯´

    processMiscUsage();
    

å¯¹è½¯ç¡¬ä»¶è€—ç”µé‡ç»“æœè¿›è¡Œé™åºæ’åº

    Collections.sort(mUsageList);
    

è·å–æœ€å¤§è€—ç”µé‡

å› ä¸ºæˆ‘ä»¬åˆšæ‰è¿›è¡Œäº†æ’åºï¼Œæ‰€ä»¥è€—ç”µæœ€å¤šçš„ç¡¬ä»¶/è½¯ä»¶æ­£ä½äºé¡¶éƒ¨ï¼Œèµ‹å€¼`mMaxRealPower`æœ€å¤§çœŸå®è€—ç”µé‡

éå†`usageList`è®¡ç®—å¾—åˆ°`mComputedPower`è€—ç”µé‡æ€»å’Œ

    if (!mUsageList.isEmpty()) {
        mMaxRealPower = mMaxPower = mUsageList.get(0).totalPowerMah;
        final int usageListCount = mUsageList.size();
        for (int i = 0; i < usageListCount; i++) {
            mComputedPower += mUsageList.get(i).totalPowerMah;
        }
    }
    

å¦‚æœå­˜åœ¨æœªè®¡ç®—åˆ°çš„è€—ç”µé‡ï¼Œå®ä¾‹åŒ–ä¸€ä¸ª`DrainType.UNACCOUNTED`ç±»å‹çš„`BatterySipper`è¿›è¡Œå­˜å‚¨ï¼Œå¹¶æ·»åŠ åˆ°`mUsageList`ä¸­

    mTotalPower = mComputedPower;
    if (mStats.getLowDischargeAmountSinceCharge() > 1) {
        // å¦‚æœæœ€ä½æ”¾ç”µé‡ > è®¡ç®—çš„æ€»è€—ç”µé‡ï¼Œè¯´æ˜è¿˜æœ‰æœªè®¡ç®—çš„
        if (mMinDrainedPower > mComputedPower) {
            double amount = mMinDrainedPower - mComputedPower;
            mTotalPower = mMinDrainedPower;
            // å®ä¾‹åŒ–ä¸€ä¸ªDrainType.UNACCOUNTEDç±»å‹çš„BatterySipperï¼Œç”¨æ¥å­˜å‚¨æœªè®¡ç®—çš„è€—ç”µé‡
            BatterySipper bs = new BatterySipper(DrainType.UNACCOUNTED, null, amount);
    
            // Insert the BatterySipper in its sorted position.
            int index = Collections.binarySearch(mUsageList, bs);
            if (index < 0) {
                index = -(index + 1);
            }
            mUsageList.add(index, bs);
            mMaxPower = Math.max(mMaxPower, amount);
        }
    

å¦‚æœå­˜åœ¨è®¡ç®—å¤šäº†çš„è€—ç”µé‡ï¼Œå®ä¾‹åŒ–ä¸€ä¸ª`DrainType.OVERCOUNTED`ç±»å‹çš„`BatterySipper`è¿›è¡Œå­˜å‚¨ï¼Œå¹¶æ·»åŠ åˆ°`mUsageList`ä¸­

    // å¦‚æœæœ€é«˜æ”¾ç”µé‡ < è®¡ç®—çš„æ€»è€—ç”µé‡ï¼Œè¯´æ˜å¤šç®—äº†è€—ç”µé‡
    else if (mMaxDrainedPower < mComputedPower) {
            double amount = mComputedPower - mMaxDrainedPower;
        
            // Insert the BatterySipper in its sorted position.
            BatterySipper bs = new BatterySipper(DrainType.OVERCOUNTED, null, amount);
            int index = Collections.binarySearch(mUsageList, bs);
            if (index < 0) {
                index = -(index + 1);
            }
            mUsageList.add(index, bs);
            mMaxPower = Math.max(mMaxPower, amount);
        }
    }
    

è¿™ç¯‡å·²ç»å¤ªé•¿äº†ï¼Œå…³äºè½¯ç¡¬ä»¶çš„è€—ç”µé‡è®¡ç®—å°±åœ¨å¦å¤–ä¸€ç¯‡é‡Œé¢å†™å§

å‚è€ƒé“¾æ¥
----

*   [https://blog.csdn.net/FightFightFight/article/details/82694381](https://blog.csdn.net/FightFightFight/article/details/82694381)
*   [http://gityuan.com/2016/01/10/power\_rank/](http://gityuan.com/2016/01/10/power_rank/)
*   [https://duanqz.github.io/2015-07-21-batterystats-part1](https://duanqz.github.io/2015-07-21-batterystats-part1)
*   [http://androidxref.com/6.0.1\_r10/xref//frameworks/base/core/java/com/android/internal/os/BatteryStatsHelper.java](http://androidxref.com/6.0.1_r10/xref//frameworks/base/core/java/com/android/internal/os/BatteryStatsHelper.java)

END
---

å»ºäº†ä¸€ä¸ªå¾®ä¿¡çš„å®‰å…¨äº¤æµç¾¤ï¼Œæ¬¢è¿æ·»åŠ æˆ‘å¾®ä¿¡å¤‡æ³¨`è¿›ç¾¤`ï¼Œä¸€èµ·æ¥èŠå¤©å¹æ°´å“‡ï¼Œä»¥åŠä¸€ä¸ªä¼šå‘å¸ƒå®‰å…¨ç›¸å…³å†…å®¹çš„å…¬ä¼—å·ï¼Œæ¬¢è¿å…³æ³¨ ğŸ˜ƒ

![GIF](https://springbird.oss-cn-beijing.aliyuncs.com/img/mmqrcode1632325540724.png) ![GIF](https://springbird.oss-cn-beijing.aliyuncs.com/img/qrcode_for_gh_cead8e1080d6_344.jpg)