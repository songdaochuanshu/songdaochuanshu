---
layout: post
title: "ç™¾è¡Œä»£ç å®ç°åŸºäºRedisçš„å¯é å»¶è¿Ÿé˜Ÿåˆ—"
date: "2022-06-22T08:28:29.024Z"
---
ç™¾è¡Œä»£ç å®ç°åŸºäºRedisçš„å¯é å»¶è¿Ÿé˜Ÿåˆ—
====================

åŸºäº redis çš„æœ‰åºé›†åˆç»“æ„å®ç°å¯é çš„ã€æ”¯æŒACKå’Œé‡è¯•æœºåˆ¶çš„å»¶è¿Ÿæ¶ˆæ¯é˜Ÿåˆ—ä¸­é—´ä»¶ã€‚æ¶ˆè´¹è€…å®ä¾‹å®šæ—¶æ‰§è¡Œ lua è„šæœ¬é©±åŠ¨æ¶ˆæ¯åœ¨é˜Ÿåˆ—ä¸­çš„æµè½¬ï¼Œå¼€ç®±å³ç”¨æ— éœ€éƒ¨ç½²é¢å¤–ç»„ä»¶ã€‚

åœ¨ä¹‹å‰æ¢è®¨å»¶æ—¶é˜Ÿåˆ—çš„æ–‡ç« ä¸­æˆ‘ä»¬æåˆ°äº† redisson delayqueue ä½¿ç”¨ redis çš„æœ‰åºé›†åˆç»“æ„å®ç°å»¶æ—¶é˜Ÿåˆ—ï¼Œé—æ†¾çš„æ˜¯ go è¯­è¨€ç¤¾åŒºä¸­å¹¶æ— ç±»ä¼¼çš„åº“ã€‚ä¸è¿‡é—®é¢˜ä¸å¤§ï¼Œæ²¡æœ‰è½®å­æˆ‘ä»¬è‡ªå·±é€ ğŸ˜ã€‚

æœ¬æ–‡çš„å®Œæ•´ä»£ç å®ç°åœ¨[hdt3213/delayqueue](https://github.com/HDT3213/delayqueue)ï¼Œå¯ä»¥ç›´æ¥ go get å®‰è£…ä½¿ç”¨ã€‚

ä½¿ç”¨æœ‰åºé›†åˆç»“æ„å®ç°å»¶æ—¶é˜Ÿåˆ—çš„æ–¹æ³•å·²ç»å¹¿ä¸ºäººçŸ¥ï¼Œæ— éæ˜¯å°†æ¶ˆæ¯ä½œä¸ºæœ‰åºé›†åˆçš„ member, æŠ•é€’æ—¶é—´æˆ³ä½œä¸º score ä½¿ç”¨ zrangebyscore å‘½ä»¤æœç´¢å·²åˆ°æŠ•é€’æ—¶é—´çš„æ¶ˆæ¯ç„¶åå°†å…¶å‘ç»™æ¶ˆè´¹è€…ã€‚

ç„¶è€Œæ¶ˆæ¯é˜Ÿåˆ—ä¸æ˜¯å°†æ¶ˆæ¯å‘ç»™æ¶ˆè´¹è€…å°±ä¸‡äº‹å¤§å‰ï¼Œå®ƒä»¬è¿˜æœ‰ä¸€ä¸ªé‡è¦èŒè´£æ˜¯ç¡®ä¿é€è¾¾å’Œæ¶ˆè´¹ã€‚é€šå¸¸çš„å®ç°æ–¹å¼æ˜¯å½“æ¶ˆè´¹è€…æ”¶åˆ°æ¶ˆæ¯åå‘æ¶ˆæ¯é˜Ÿåˆ—è¿”å›ç¡®è®¤(ack)ï¼Œè‹¥æ¶ˆè´¹è€…è¿”å›å¦å®šç¡®è®¤(nack)æˆ–è¶…æ—¶æœªè¿”å›ï¼Œæ¶ˆæ¯é˜Ÿåˆ—åˆ™ä¼šæŒ‰ç…§é¢„å®šè§„åˆ™é‡æ–°å‘é€ï¼Œç›´åˆ°åˆ°è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°ååœæ­¢ã€‚å¦‚ä½•å®ç° ack å’Œé‡è¯•æœºåˆ¶æ˜¯æˆ‘ä»¬è¦é‡ç‚¹è€ƒè™‘çš„é—®é¢˜ã€‚

æˆ‘ä»¬çš„æ¶ˆæ¯é˜Ÿåˆ—å…è®¸åˆ†å¸ƒå¼åœ°éƒ¨ç½²å¤šä¸ªç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ï¼Œæ¶ˆè´¹è€…å®ä¾‹å®šæ—¶æ‰§è¡Œ lua è„šæœ¬é©±åŠ¨æ¶ˆæ¯åœ¨é˜Ÿåˆ—ä¸­çš„æµè½¬æ— éœ€éƒ¨ç½²é¢å¤–ç»„ä»¶ã€‚ç”±äº Redis ä¿è¯äº† lua è„šæœ¬æ‰§è¡Œçš„åŸå­æ€§ï¼Œæ•´ä¸ªæµç¨‹æ— éœ€åŠ é”ã€‚

æ¶ˆè´¹è€…é‡‡ç”¨æ‹‰æ¨¡å¼è·å¾—æ¶ˆæ¯ï¼Œä¿è¯æ¯æ¡æ¶ˆæ¯è‡³å°‘æŠ•é€’ä¸€æ¬¡ï¼Œæ¶ˆæ¯é˜Ÿåˆ—ä¼šé‡è¯•è¶…æ—¶æˆ–è€…è¢«å¦å®šç¡®è®¤çš„æ¶ˆæ¯(nack) ç›´è‡³åˆ°è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°ã€‚ä¸€æ¡æ¶ˆæ¯æœ€å¤šæœ‰ä¸€ä¸ªæ¶ˆè´¹è€…æ­£åœ¨å¤„ç†ï¼Œå‡å°‘äº†è¦è€ƒè™‘çš„å¹¶å‘é—®é¢˜ã€‚

> è¯·æ³¨æ„ï¼šè‹¥æ¶ˆè´¹æ—¶é—´è¶…è¿‡äº† MaxConsumeDuration æ¶ˆæ¯é˜Ÿåˆ—ä¼šè®¤ä¸ºæ¶ˆè´¹è¶…æ—¶å¹¶é‡æ–°æŠ•é€’ï¼Œæ­¤æ—¶å¯èƒ½æœ‰å¤šä¸ªæ¶ˆè´¹è€…åŒæ—¶æ¶ˆè´¹ã€‚

å…·ä½“ä½¿ç”¨ä¹Ÿéå¸¸ç®€å•ï¼Œåªéœ€è¦æ³¨å†Œå¤„ç†æ¶ˆæ¯çš„å›è°ƒå‡½æ•°å¹¶è°ƒç”¨ start() å³å¯ï¼š

    package main
    
    import (
    	"github.com/go-redis/redis/v8"
    	"github.com/hdt3213/delayqueue"
    	"strconv"
    	"time"
    )
    
    func main() {
    	redisCli := redis.NewClient(&redis.Options{
    		Addr: "127.0.0.1:6379",
    	})
    	queue := delayqueue.NewQueue("example-queue", redisCli, func(payload string) bool {
    		// æ³¨å†Œå¤„ç†æ¶ˆæ¯çš„å›è°ƒå‡½æ•°
            // è¿”å› true è¡¨ç¤ºå·²æˆåŠŸæ¶ˆè´¹ï¼Œè¿”å› false æ¶ˆæ¯é˜Ÿåˆ—ä¼šé‡æ–°æŠ•é€’æ¬¡æ¶ˆæ¯
    		return true
    	})
    	// å‘é€å»¶æ—¶æ¶ˆæ¯
    	for i := 0; i < 10; i++ {
    		err := queue.SendDelayMsg(strconv.Itoa(i), time.Hour, delayqueue.WithRetryCount(3))
    		if err != nil {
    			panic(err)
    		}
    	}
    
    	// start consume
    	done := queue.StartConsume()
    	<-done
    }
    

ç”±äºæ•°æ®å­˜å‚¨åœ¨ redis ä¸­æ‰€ä»¥æˆ‘ä»¬æœ€å¤šèƒ½ä¿è¯åœ¨ redis æ— æ•…éšœä¸”æ¶ˆæ¯é˜Ÿåˆ—ç›¸å…³ key æœªè¢«å¤–éƒ¨ç¯¡æ”¹çš„æƒ…å†µä¸‹ä¸ä¼šä¸¢å¤±æ¶ˆæ¯ã€‚

åŸç†è¯¦è§£
====

æ¶ˆæ¯é˜Ÿåˆ—æ¶‰åŠå‡ ä¸ªå…³é”®çš„ redis æ•°æ®ç»“æ„ï¼š

*   msgKey: ä¸ºäº†é¿å…ä¸¤æ¡å†…å®¹å®Œå…¨ç›¸åŒçš„æ¶ˆæ¯é€ æˆæ„å¤–çš„å½±å“ï¼Œæˆ‘ä»¬å°†æ¯æ¡æ¶ˆæ¯æ”¾åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹çš„é”®ä¸­ï¼Œå¹¶åˆ†é…ä¸€ä¸ª UUID ä½œä¸ºå®ƒçš„å”¯ä¸€æ ‡è¯†ã€‚å…¶å®ƒæ•°æ®ç»“æ„ä¸­åªå­˜å‚¨ UUID è€Œä¸å­˜å‚¨å®Œæ•´çš„æ¶ˆæ¯å†…å®¹ã€‚æ¯ä¸ª msg æ‹¥æœ‰ä¸€ä¸ªç‹¬ç«‹çš„ key è€Œä¸æ˜¯å°†æ‰€æœ‰æ¶ˆæ¯æ”¾åˆ°ä¸€ä¸ªå“ˆå¸Œè¡¨æ˜¯ä¸ºäº†åˆ©ç”¨ TTL æœºåˆ¶é¿å…
*   pendingKey: æœ‰åºé›†åˆç±»å‹ï¼Œmember ä¸ºæ¶ˆæ¯ ID, score ä¸ºæŠ•é€’æ—¶é—´çš„ unix æ—¶é—´æˆ³ã€‚
*   readyKey: åˆ—è¡¨ç±»å‹ï¼Œéœ€è¦æŠ•é€’çš„æ¶ˆæ¯ IDã€‚
*   unAckKey: æœ‰åºé›†åˆç±»å‹ï¼Œmember ä¸ºæ¶ˆæ¯ ID, score ä¸ºé‡è¯•æ—¶é—´çš„ unix æ—¶é—´æˆ³ã€‚
*   retryKey: åˆ—è¡¨ç±»å‹ï¼Œå·²åˆ°é‡è¯•æ—¶é—´çš„æ¶ˆæ¯ ID
*   garbageKey: é›†åˆç±»å‹ï¼Œç”¨äºæš‚å­˜å·²è¾¾é‡è¯•ä¸Šçº¿çš„æ¶ˆæ¯ ID
*   retryCountKey: å“ˆå¸Œè¡¨ç±»å‹ï¼Œé”®ä¸ºæ¶ˆæ¯ ID, å€¼ä¸ºå‰©ä½™çš„é‡è¯•æ¬¡æ•°

æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![](https://s2.loli.net/2022/06/21/LHTMa7sRGuzhNyE.png)

ç”±äºæˆ‘ä»¬å…è®¸åˆ†å¸ƒå¼åœ°éƒ¨ç½²å¤šä¸ªæ¶ˆè´¹è€…ï¼Œæ¯ä¸ªæ¶ˆè´¹è€…éƒ½åœ¨å®šæ—¶æ‰§è¡Œ lua è„šæœ¬ï¼Œæ‰€ä»¥å¤šä¸ªæ¶ˆè´¹è€…å¯èƒ½å¤„äºä¸Šè¿°æµç¨‹ä¸­ä¸åŒçŠ¶æ€ï¼Œæˆ‘ä»¬æ— æ³•é¢„çŸ¥ï¼ˆæˆ–æ§åˆ¶ï¼‰ä¸Šå›¾ä¸­äº”ä¸ªæ“ä½œå‘ç”Ÿçš„å…ˆåé¡ºåºï¼Œä¹Ÿæ— æ³•æ§åˆ¶æœ‰å¤šå°‘å®ä¾‹æ­£åœ¨æ‰§è¡ŒåŒä¸€ä¸ªæ“ä½œã€‚

å› æ­¤æˆ‘ä»¬éœ€è¦ä¿è¯ä¸Šå›¾ä¸­äº”ä¸ªæ“ä½œæ»¡è¶³ä¸‰ä¸ªæ¡ä»¶ï¼š

1.  éƒ½æ˜¯åŸå­æ€§çš„
2.  ä¸ä¼šé‡å¤å¤„ç†åŒä¸€æ¡æ¶ˆæ¯
3.  æ“ä½œå‰åæ¶ˆæ¯é˜Ÿåˆ—å§‹ç»ˆå¤„äºæ­£ç¡®çš„çŠ¶æ€

åªè¦æ»¡è¶³è¿™ä¸‰ä¸ªæ¡ä»¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥éƒ¨ç½²å¤šä¸ªå®ä¾‹ä¸”ä¸éœ€è¦ä½¿ç”¨åˆ†å¸ƒå¼é”ç­‰æŠ€æœ¯æ¥è¿›è¡ŒçŠ¶æ€åŒæ­¥ã€‚

æ˜¯ä¸æ˜¯å¬èµ·æ¥æœ‰ç‚¹å“äººï¼ŸğŸ˜‚ å…¶å®ç®€å•çš„å¾ˆï¼Œè®©æˆ‘ä»¬ä¸€èµ·æ¥è¯¦ç»†çœ‹çœ‹å§~

pending2ReadyScript
-------------------

pending2ReadyScript ä½¿ç”¨ zrangebyscore æ‰«æå·²åˆ°æŠ•é€’æ—¶é—´çš„æ¶ˆæ¯IDå¹¶æŠŠå®ƒä»¬ç§»åŠ¨åˆ° ready ä¸­:

    -- keys: pendingKey, readyKey
    -- argv: currentTime
    local msgs = redis.call('ZRangeByScore', KEYS[1], '0', ARGV[1])  -- ä» pending key ä¸­æ‰¾å‡ºå·²åˆ°æŠ•é€’æ—¶é—´çš„æ¶ˆæ¯
    if (#msgs == 0) then return end
    local args2 = {'LPush', KEYS[2]} -- å°†ä»–ä»¬æ”¾å…¥ ready key ä¸­
    for _,v in ipairs(msgs) do
    	table.insert(args2, v) 
    end
    redis.call(unpack(args2))
    redis.call('ZRemRangeByScore', KEYS[1], '0', ARGV[1])  -- ä» pending key ä¸­åˆ é™¤å·²æŠ•é€’çš„æ¶ˆæ¯
    

ready2UnackScript
-----------------

ready2UnackScript ä» ready æˆ–è€… retry ä¸­å–å‡ºä¸€æ¡æ¶ˆæ¯å‘é€ç»™æ¶ˆè´¹è€…å¹¶æ”¾å…¥ unack ä¸­ï¼Œç±»ä¼¼äº RPopLPushï¼š

    -- keys: readyKey/retryKey, unackKey
    -- argv: retryTime
    local msg = redis.call('RPop', KEYS[1])
    if (not msg) then return end
    redis.call('ZAdd', KEYS[2], ARGV[1], msg)
    return msg
    

unack2RetryScript
-----------------

unack2RetryScript ä» retry ä¸­æ‰¾å‡ºæ‰€æœ‰å·²åˆ°é‡è¯•æ—¶é—´çš„æ¶ˆæ¯å¹¶æŠŠå®ƒä»¬ç§»åŠ¨åˆ° unack ä¸­ï¼š

    -- keys: unackKey, retryCountKey, retryKey, garbageKey
    -- argv: currentTime
    local msgs = redis.call('ZRangeByScore', KEYS[1], '0', ARGV[1])  -- æ‰¾åˆ°å·²åˆ°é‡è¯•æ—¶é—´çš„æ¶ˆæ¯
    if (#msgs == 0) then return end
    local retryCounts = redis.call('HMGet', KEYS[2], unpack(msgs)) -- æŸ¥è¯¢å‰©ä½™é‡è¯•æ¬¡æ•°
    for i,v in ipairs(retryCounts) do
    	local k = msgs[i]
    	if tonumber(v) > 0 then -- å‰©ä½™æ¬¡æ•°å¤§äº 0
    		redis.call("HIncrBy", KEYS[2], k, -1) -- å‡å°‘å‰©ä½™é‡è¯•æ¬¡æ•°
    		redis.call("LPush", KEYS[3], k) -- æ·»åŠ åˆ° retry key ä¸­
    	else -- å‰©ä½™é‡è¯•æ¬¡æ•°ä¸º 0
    		redis.call("HDel", KEYS[2], k) -- åˆ é™¤é‡è¯•æ¬¡æ•°è®°å½•
    		redis.call("SAdd", KEYS[4], k) -- æ·»åŠ åˆ°åƒåœ¾æ¡¶ï¼Œç­‰å¾…åç»­åˆ é™¤
    	end
    end
    redis.call('ZRemRangeByScore', KEYS[1], '0', ARGV[1])  -- å°†å·²å¤„ç†çš„æ¶ˆæ¯ä» unack key ä¸­åˆ é™¤
    

å› ä¸º redis è¦æ±‚ lua è„šæœ¬å¿…é¡»åœ¨æ‰§è¡Œå‰åœ¨ KEYS å‚æ•°ä¸­å£°æ˜è‡ªå·±è¦è®¿é—®çš„ key, è€Œæˆ‘ä»¬å°†æ¯ä¸ª msg æœ‰ä¸€ä¸ªç‹¬ç«‹çš„ keyï¼Œæˆ‘ä»¬åœ¨æ‰§è¡Œ unack2RetryScript ä¹‹å‰æ˜¯ä¸çŸ¥é“å“ªäº› msg key éœ€è¦è¢«åˆ é™¤ã€‚æ‰€ä»¥ lua è„šæœ¬åªå°†éœ€è¦åˆ é™¤çš„æ¶ˆæ¯è®°åœ¨ garbage key ä¸­ï¼Œè„šæœ¬æ‰§è¡Œå®Œåå†é€šè¿‡ del å‘½ä»¤å°†ä»–ä»¬åˆ é™¤:

    func (q *DelayQueue) garbageCollect() error {
    	ctx := context.Background()
    	msgIds, err := q.redisCli.SMembers(ctx, q.garbageKey).Result()
    	if err != nil {
    		return fmt.Errorf("smembers failed: %v", err)
    	}
    	if len(msgIds) == 0 {
    		return nil
    	}
    	// allow concurrent clean
    	msgKeys := make([]string, 0, len(msgIds))
    	for _, idStr := range msgIds {
    		msgKeys = append(msgKeys, q.genMsgKey(idStr))
    	}
    	err = q.redisCli.Del(ctx, msgKeys...).Err()
    	if err != nil && err != redis.Nil {
    		return fmt.Errorf("del msgs failed: %v", err)
    	}
    	err = q.redisCli.SRem(ctx, q.garbageKey, msgIds).Err()
    	if err != nil && err != redis.Nil {
    		return fmt.Errorf("remove from garbage key failed: %v", err)
    	}
    	return nil
    }
    

ä¹‹å‰æåˆ°çš„ lua è„šæœ¬éƒ½æ˜¯åŸå­æ€§æ‰§è¡Œçš„ï¼Œä¸ä¼šæœ‰å…¶å®ƒå‘½ä»¤æ’å…¥å…¶ä¸­ã€‚ gc å‡½æ•°ç”± 3 æ¡ redis å‘½ä»¤ç»„æˆï¼Œåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å¯èƒ½ä¼šæœ‰å…¶å®ƒå‘½ä»¤æ’å…¥æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œä¸è¿‡è€ƒè™‘åˆ°ä¸€æ¡æ¶ˆæ¯è¿›å…¥åƒåœ¾å›æ”¶æµç¨‹ä¹‹åä¸ä¼šå¤æ´»æ‰€ä»¥ä¸éœ€è¦ä¿è¯ 3 æ¡å‘½ä»¤åŸå­æ€§ã€‚

ack
---

ack åªéœ€è¦å°†æ¶ˆæ¯å½»åº•åˆ é™¤å³å¯:

    func (q *DelayQueue) ack(idStr string) error {
    	ctx := context.Background()
    	err := q.redisCli.ZRem(ctx, q.unAckKey, idStr).Err()
    	if err != nil {
    		return fmt.Errorf("remove from unack failed: %v", err)
    	}
    	// msg key has ttl, ignore result of delete
    	_ = q.redisCli.Del(ctx, q.genMsgKey(idStr)).Err()
    	q.redisCli.HDel(ctx, q.retryCountKey, idStr)
    	return nil
    }
    

å¦å®šç¡®è®¤åªéœ€è¦å°† unack key ä¸­æ¶ˆæ¯çš„é‡è¯•æ—¶é—´æ”¹ä¸ºç°åœ¨ï¼Œéšåæ‰§è¡Œçš„ unack2RetryScript ä¼šç«‹å³å°†å®ƒç§»åŠ¨åˆ° retry key

    func (q *DelayQueue) nack(idStr string) error {
    	ctx := context.Background()
    	// update retry time as now, unack2Retry will move it to retry immediately
    	err := q.redisCli.ZAdd(ctx, q.unAckKey, &redis.Z{
    		Member: idStr,
    		Score:  float64(time.Now().Unix()),
    	}).Err()
    	if err != nil {
    		return fmt.Errorf("negative ack failed: %v", err)
    	}
    	return nil
    }
    

consume
-------

æ¶ˆæ¯é˜Ÿåˆ—çš„æ ¸å¿ƒé€»è¾‘æ˜¯æ¯ç§’æ‰§è¡Œä¸€æ¬¡çš„ consume å‡½æ•°ï¼Œå®ƒè´Ÿè´£è°ƒç”¨ä¸Šè¿°è„šæœ¬å°†æ¶ˆæ¯è½¬ç§»åˆ°æ­£ç¡®çš„é›†åˆä¸­å¹¶å›è°ƒ consumer æ¥æ¶ˆè´¹æ¶ˆæ¯ï¼š

    func (q *DelayQueue) consume() error {
    	// æ‰§è¡Œ pending2readyï¼Œå°†å·²åˆ°æ—¶é—´çš„æ¶ˆæ¯è½¬ç§»åˆ° ready
    	err := q.pending2Ready()
    	if err != nil {
    		return err
    	}
    	// å¾ªç¯è°ƒç”¨ ready2Unack æ‹‰å–æ¶ˆæ¯è¿›è¡Œæ¶ˆè´¹
    	var fetchCount uint
    	for {
    		idStr, err := q.ready2Unack()
    		if err == redis.Nil { // consumed all
    			break
    		}
    		if err != nil {
    			return err
    		}
    		fetchCount++
    		ack, err := q.callback(idStr)
    		if err != nil {
    			return err
    		}
    		if ack {
    			err = q.ack(idStr)
    		} else {
    			err = q.nack(idStr)
    		}
    		if err != nil {
    			return err
    		}
    		if fetchCount >= q.fetchLimit {
    			break
    		}
    	}
    	// å°† nack æˆ–è¶…æ—¶çš„æ¶ˆæ¯æ”¾å…¥é‡è¯•é˜Ÿåˆ—
    	err = q.unack2Retry()
    	if err != nil {
    		return err
    	}
        // æ¸…ç†å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°çš„æ¶ˆæ¯
    	err = q.garbageCollect()
    	if err != nil {
    		return err
    	}
    	// æ¶ˆè´¹é‡è¯•é˜Ÿåˆ—
    	fetchCount = 0
    	for {
    		idStr, err := q.retry2Unack()
    		if err == redis.Nil { // consumed all
    			break
    		}
    		if err != nil {
    			return err
    		}
    		fetchCount++
    		ack, err := q.callback(idStr)
    		if err != nil {
    			return err
    		}
    		if ack {
    			err = q.ack(idStr)
    		} else {
    			err = q.nack(idStr)
    		}
    		if err != nil {
    			return err
    		}
    		if fetchCount >= q.fetchLimit {
    			break
    		}
    	}
    	return nil
    }
    

è‡³æ­¤ä¸€ä¸ªç®€å•å¯é çš„å»¶æ—¶é˜Ÿåˆ—å°±åšå¥½äº†ï¼Œä½•ä¸èµ¶ç´§å¼€å§‹è¯•ç”¨å‘¢ğŸ˜˜ğŸ˜‹ï¼Ÿ

Keep working, we will find a way out. This is Finley, welcome to join us.