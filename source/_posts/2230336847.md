---
layout: post
title: "面向对象进阶第三天"
date: "2023-02-27T01:14:38.913Z"
---
面向对象进阶第三天
=========

面向对象进阶第三天
=========

内部类
---

### 内部类是什么？

*   类的5大成分（成员变量、成员方法、构造器、代码块、内部类）之一
    
*   类中的类
    

### 使用场景

*   当一个事物的内部，还有一个部分需要一个完整的结构进行描述时。
    

### 内部类有几种

*   1、静态内部类
    
    *   是什么？有static修饰，属于外部类本身。
        
    *   特点：只是位置在类里面。类有的成分它都有。
        
    *   创建对象：
        
        外部类.内部类名  对象名  \= new 外部类名.内部类构造器;
        
    *   拓展
        
        1、静态内部类可以直接访问外部类的静态成员吗？ 可以的
        
        2、静态内部类中是否可以直接访问外部类的实例成员？ 不可以的
        
*   2、成员内部类（实例内部类）
    
    *   是什么？
        
        *   无static修饰，属于外部类的对象的。
            
    *   特点：JDK 16中类有的成分，它都有。
        
    *   创建对象 ：
        
        外部类.内部类  对象名   =  new 外部类构造器.new  内部类构造器;
        
    *   拓展
        
        1、成员内部类中是否可以直接访问外部类的静态成员？ 可以
        
        2、成员内部类的实例方法中是否可以直接访问外部类的实例成员？ 可以
        
*   3、局部内部类
    
    *   定义在方法，代码块，构造器中，执行代码处的类。鸡肋语法！
        
*   4、匿名内部类（重点）
    
    *   使用匿名内部类的好处：
        
        1.  方便构建子类对象，最终目的：简化代码
            
    *   格式：
        
        new  类名|接口|抽象类(){        
            方法重写;         
        }
        
    *   特点：
        
        1.  匿名内部类是一个没有名字的局部内部类，本身也是一个所谓的子类对象。
            
        2.  匿名内部类产生的对象类型，相当于是当前new的那个的类型的子类类型。
            

枚举
--

是什么？ 是一种特殊类型。 枚举的特征：

1.  枚举类都是继承了枚举类型：java.lang.Enum
    
2.  枚举都是最终类，不可以被继承。
    
3.  构造器都是私有的，枚举对外不能创建对象。
    
4.  枚举类的第一行默认都是罗列枚举对象的名称的。
    
5.  枚举类相当于是多例模式。
    

泛型
--

### 认识泛型

*   定义类、接口、方法时，同时声明了一个或者多个类型变量（如：<E>） ，称为泛型类、泛型接口，泛型方法、它们统称为泛型。
    
*   作用
    
    *   泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力！这样可以避免强制类型转换，及其可能出现的异常。
        

### 泛型类

*   定义类的同时定义了泛型的类就是泛型类
    
*   泛型类的格式
    
    修饰符 class 类名<类型变量，类型变量，…> {   
    }
    
*   作用
    
    *   在编译阶段可以指定能操作的数据的类型
        
*   原理
    
    *   把出现泛型变量的地方全部替换成传输的真实数据类型。
        

### 泛型接口

*   使用了泛型定义的接口就是泛型接口
    
*   格式
    
    修饰符 interface 接口名称<泛型变量> {  
    }
    
*   作用
    
    *   泛型接口可以让实现类选择当前功能需要操作的数据类型
        
*   原理
    
    *   实现类可以在实现接口的时候传入自己操作的数据类型，这样重写的方法都将是针对于该类型的操作。
        

### 泛型方法

*   定义方法时同时定义了泛型的方法就是泛型方法
    
*   格式
    
    修饰符 <类型变量，类型变量，…>  返回值类型 方法名(形参列表)  {   
    }
    
*   作用
    
    *   方法中可以使用泛型接收一切实际类型的参数，方法更具备通用性。
        
*   原理
    
    *   把出现泛型变量的地方全部替换成传输的真实数据类型。
        

### 泛型通配符、上下限

*   ? 可以在“使用泛型”的时候代表一切类型。
    
*   E T K V 是在定义泛型的时候使用的。
    
*   泛型的上下限
    
    *   ? extends Car: ?必须是Car或者其子类 泛型上限
        
    *   ? super Car ： ?必须是Car或者其父类 泛型下限
        

### 泛型的注意事项：擦除问题、基本数据类型问题

*   泛型是工作在编译阶段的，一旦程序编译成class文件，class文件中就不存在泛型了，这就是泛型擦除。
    
*   泛型不支持基本数据类型，只能支持对象类型（引用数据类型）。
    

java.lang包下常用API
----------------

### API概述

API全称是应用程序编程接口，是Java写好的程序，程序员可以直接调用。

### Object类：toString方法

Object是祖宗类，它里面的方法，一切子类对象都可以使用。

`public String toString()`

*   默认是返回当前对象的地址信息。
    

`Student s = new Student("张三",'女', 23);`

*   `System.out.println(s.toString());`
    
    *   返回对象地址
        
*   `System.out.println(s);`
    
    *   直接输出对象名，默认是调用toString方法的
        

**toString存在的意义：**

*   默认返回对象的地址其实是没有意义的
    
*   真实存在的意义是被子类重写，以便返回子类对象的内容。
    

### Object类：equals方法

`public boolean equals(Object o )`

*   默认是比较2个对象的地址是否一样，返回true 或者false
    

**equals存在的意义**

*   默认比较对象的地址其实是没有意义的，因为== 号可以更简单的完成
    
*   存在的的真实意义是被子类重写，以便比较对象的内容。
    

### Object类：clone方法

`protected Object clone()`

当某个对象调用这个方法时，这个方法会复制一个一模一样的新对象返回。

**分类：**

1.  浅克隆：拷贝出的新对象，与原对象中的数据一模一样（引用类型拷贝的只是地址）
    
2.  深克隆：
    
    对象中基本类型的数据直接拷贝。
    
    对象中的字符串数据拷贝的还是地址。
    
    对象中还包含的其他对象，不会拷贝地址，会创建新对象。
    

Objects
-------

Objects是一个工具类，提供了更安全的方式比较2个对象。

`Student s = null;`

*   s.equals(s2); 空指针异常
    
*   Objects.equals(s, s2); 返回false
    

**Objects常见方法：**

方法名

说明

public static boolean equals(Object a, Object b)

比较两个对象的，底层会先进行非空判断，从而可以避免空指针异常。再进行equals比较

public static boolean isNull(Object obj)

判断变量是否为null ,为null返回true ,反之返回false

包装类
---

其实就是8种基本数据类型对应的引用类型。

作用：实现一切皆对象

### 包装类的分类：

基本数据类型

引用数据类型

byte

Byte

short

Short

int

Integer

long

Long

char

Character

float

Float

double

Double

boolean

Boolean

包装类其实可以随便用的：int integer

*   自动装箱
    
    *   基本类型的数据可以赋值其给包装类
        
*   自动拆箱
    
    *   包装类的数据赋值给基本数据类型
        

### 包装类的特有功能：

1、基本类型变成字符串

// 1、调用包装类继承自Object的toString方法
String rs1 = it6.toString(); // "23"
System.out.println(rs1 + 1); // 231
​
// 2、调用静态方法: public static String toString(int i)
String rs2 = Integer.toString(it6);// "23"
System.out.println(rs2 + 1);
​
// 3、直接加 “”
String rs3 = it6 + ""; // "23"
System.out.println(rs3 + 1);

2、把字符串变成基本数据类型（**重点**）

String age = "23";
// int ageInt = Integer.parseInt(age);
int ageInt = Integer.valueOf(age);
System.out.println(ageInt \+ 1);
​
String price \= "98.5";
// double priceDb = Double.parseDouble(price);
double priceDb = Double.valueOf(price);
System.out.println(priceDb \+ 0.5);