---
layout: post
title: "一条Sql的执行过程"
date: "2022-05-11T22:18:14.885Z"
---
一条Sql的执行过程
==========

![一条Sql的执行过程](https://img2022.cnblogs.com/blog/1775279/202205/1775279-20220511224255883-597613497.png) MySQL实战45讲之sql的内部执行过程

一条sql内部是如何执行的：
==============

> 学习MySQL实战45专栏

sql中的内部执行图：

![](https://img2022.cnblogs.com/blog/1775279/202205/1775279-20220511223600994-1292852739.png)

可以分为两部分：server和存储引擎

**server层包含：**

> 连接器、分析器、优化器、执行器，涵盖了MySQL大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），相关功能：存储过程、触发器、视图都在这一层实现。

**存储引擎层：**

> 负责数据的存储和提取，存储引擎是可以多选的，支持 InnoDB MyISAM、  
> Memory 等，现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎

指定存储引擎：`engine=memory`不同存储引擎的表数据存取方式不同，支持的功能也不同.

    select * from T where ID=10；
    

连接器：
----

![](https://img2022.cnblogs.com/blog/1775279/202205/1775279-20220511223622434-2106166159.png)

查询缓存：
-----

连接建立后，就可以执行select语句，然后会进行查询缓存，  
MySQL收到查询请求后，会到查询缓存中查看，其中都是保存着以key-value形式的键值对，key为查询语句，value为查询结果，如果有缓存则直接返回value。  
不在查询缓存中，会执行后续过程，执行完成后会讲查询的结果保存到缓存中；但是**查询缓存的弊大于利；**

> 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空

按需设置：

1.  将参数 query\_cache\_type 设置成 DEMAND；所有的SQL都不会进行查询缓存
2.  通过关键字SQL\_CACHE 也可以显示指定

    mysql> select SQL_CACHE * from T where ID=10；
    

在MySQL8.0后取消了这个查询缓存的功能；

分析器：
----

然后对于sql语句进行分析，主要**词法分析和语法分析**

1.  把相关的关键字、表名、字段等分析出来
2.  根据词法分析的结果进行语法规则的判断，不会就会有错误提示`You have an error in your SQL syntax`，然后看`use near`后面的信息;

优化器：
----

通过分析器，MySQL知道了执行目的；主要是决定sql中执行的顺序，

> 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序

    select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
    --等价于
    select * from ti join t2 where t1.ID = t2.ID and ti.c = 10 and t2.d = 20;
    

不同的执行顺序，所执行的效率是不一样的；

*   既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
*   也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。

执行器：
----

MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句；

> 在工程实现上，如果命中查询缓存(mysql8已取消)，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限

![](https://img2022.cnblogs.com/blog/1775279/202205/1775279-20220511223826555-810585186.png)