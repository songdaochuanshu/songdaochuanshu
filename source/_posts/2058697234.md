---
layout: post
title: "Rabbit MQ 怎么保证可靠性、幂等性、消费顺序？"
date: "2022-03-30T12:33:06.919Z"
---
Rabbit MQ 怎么保证可靠性、幂等性、消费顺序？
===========================

RabbitMQ如何保证消息的可靠性
------------------

RabbitMQ消息丢失的三种情况  
![](https://img2022.cnblogs.com/blog/1464573/202203/1464573-20220330165855560-791243222.png)

### 生产者弄丢消息时的解决方法

*   方法一：生产者在发送数据之前开启RabbitMQ的事务(采用该种方法由于事务机制，会导致吞吐量下降，太消耗性能。)
*   方法二：开启confirm模式(使用springboot时在application.yml配置文件中做如下配置，实现confirm回调接口，生产者发送消息时设置confirm回调)
*   小结： 事务机制和 confirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm机制是异步的，你发送个消息之后就可以发送下一个消息，RabbitMQ 接收了之后会异步回调confirm接口通知你这个消息接收到了。一般在生产者这块避免数据丢失，建议使用用 confirm 机制。

### MQ自身弄丢消息时的解决方法

*   第一步： 创建queue时设置为持久化队列，这样可以保证RabbitMQ持久化queue的元数据，此时还是不会持久化queue里的数据。
*   第二步： 发送消息时将消息的deliveryMode设置为持久化，此时queue中的消息才会持久化到磁盘。
*   总结：同时设置queue和message持久化以后，RabbitMQ 挂了再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据，保证数据不会丢失。
*   但是：但是就算开启持久化机制，也有可能出现上面说的的消息落盘时服务挂掉的情况。这时可以考虑结合生产者的confirm机制来处理，持久化机制开启后消息只有成功落盘时才会通过confirm回调通知生产者，所以可以考虑生产者在生产消息时维护一个正在等待消息发送确认的队列，如果超过一定时间还没从confirm中收到对应消息的反馈，自动进行重发处理。

### 消费者自身弄丢消息时的解决方法

*   方法：关闭自动ACK，使用手动ACK。RabbitMQ中有一个ACK机制，默认情况下消费者接收到到消息，RabbitMQ会自动提交ACK，之后这条消息就不会再发送给消费者了。我们可以更改为手动ACK模式，每次处理完消息之后，再手动ack一下。不过这样可能会出现刚处理完还没手动ack确认，消费者挂了，导致消息重复消费，不过我们只需要保证幂等性就好了，重复消费也不会造成问题。
*   步骤一：在springboot中修改application.yml配置文件更改为手动ack模式
*   步骤二：手动实现ack的callback

### RabbitMQ保证消息可靠性总结

![RabbitMQ保证消息可靠性总结](https://img2022.cnblogs.com/blog/1464573/202203/1464573-20220330165653766-1249048141.png)

RabbitMQ如何保证消息的幂等性
------------------

### 如何保证消息队列消费的幂等性，这一块应该还是要结合业务来选择合适的方法，有以下几个方案：

*   消费数据为了单纯的写入数据库，可以先根据主键查询数据是否已经存在，如果已经存在了就没必要插入了。或者直接插入也没问题，因为可以利用主键的唯一性来保证数据不会重复插入，重复插入只会报错，但不会出现脏数据。
*   消费数据只是为了缓存到redis当中，这种情况就是直接往redis中set value了，天然的幂等性。
*   针对复杂的业务情况，可以在生产消息的时候给每个消息加一个全局唯一ID，消费者消费消息时根据这个ID去redis当中查询之前是否消费过。如果没有消费过，就进行消费并将这个消息的ID写入到redis当中。如果已经消费过了，就无需再次消费了。

RabbitMQ如何保证消息的顺序性
------------------

### 出现消费顺序错乱的情况

*   为了提高处理效率，一个queue存在多个consumer
*   一个queue只存在一个consumer，但是为了提高处理效率，consumer中使用了多线程进行处理

### 保证消息顺序性的方法

*   将原来的一个queue拆分成多个queue，每个queue都有一个自己的consumer。该种方案的核心是生产者在投递消息的时候根据业务数据关键值（例如订单ID哈希值对订单队列数取模）来将需要保证先后顺序的同一类数据（同一个订单的数据） 发送到同一个queue当中。
*   一个queue就一个consumer，在consumer中维护多个内存队列，根据业务数据关键值（例如订单ID哈希值对内存队列数取模）将消息加入到不同的内存队列中，然后多个真正负责处理消息的线程去各自对应的内存队列当中获取消息进行消费。

### RabbitMQ保证消息顺序性总结：

核心思路就是根据业务数据关键值划分成多个消息集合，而且每个消息集合中的消息数据都是有序的，每个消息集合有自己独立的一个consumer。多个消息集合的存在保证了消息消费的效率，每个有序的消息集合对应单个的consumer也保证了消息消费时的有序性。

什么时候开始都不晚——沃尔舅·硕德