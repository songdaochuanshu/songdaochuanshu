---
layout: post
title: " ElasticSearch分布式搜索引擎——从入门到精通"
date: "2023-02-05T14:13:41.036Z"
---
ElasticSearch分布式搜索引擎——从入门到精通
============================

![ ElasticSearch分布式搜索引擎——从入门到精通](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174728707-1508336195.png) Elasticsearch是位于 Elastic Stack 核心的分布式搜索和分析引擎。Elasticsearch 是索引、搜索和分析魔法发生的地方。lasticsearch 为所有类型的数据提供近乎实时的搜索和分析。无论您拥有结构化或非结构化文本、数字数据还是地理空间数据，Elasticsearch 都能以支持快速搜索的方式高效地存储和索引它。您可以超越简单的数据检索和聚合信息来发现数据中的趋势和模式。随着您的数据和查询量的增长，Elasticsearch 的分布式特性使您的部署能够随之无缝增长。

ES分布式搜索引擎
=========

> 注意： 在没有创建库的时候搜索，ES会创建一个库并自动创建该字段并且设置为String类型也就是text

什么是elasticsearch？

*   一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能

什么是elastic stack（ELK）？

*   是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch

什么是Lucene？

*   是Apache的开源搜索引擎类库，提供了搜索引擎的核心API

  
elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容

**ELK技术栈**

> 本文只使用了elasticsearch，以及kibana做可视化界面

elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171715684-1824564189.png)

而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171722024-1222796164.png)

初识elasticsearch
---------------

### 1\. elasticsearch背景介绍

elasticsearch底层是基于**lucene**来实现的。

**Lucene**是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：[https://lucene.apache.org/](https://lucene.apache.org/) 。

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171730614-533765512.png)

**elasticsearch**的发展历史：

*   2004年Shay Banon基于Lucene开发了Compass
*   2010年Shay Banon 重写了Compass，取名为Elasticsearch。

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171735479-91571788.png)

### 2\. 倒排索引

倒排索引的概念是基于MySQL这样的正向索引而言的。

#### 2.1 正向索引

> 设置了索引的话挺快的，但要是模糊查询则就很慢！

那么什么是正向索引呢？例如给下表（tb\_goods）中的id创建索引：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171741388-1990334679.png)

如果是根据id查询，那么直接走索引，查询速度非常快。

但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下：

1）用户搜索数据，条件是title符合`"%手机%"`

2）逐行获取数据，比如id为1的数据

3）判断数据中的title是否符合用户搜索条件

4）如果符合则放入结果集，不符合则丢弃。回到步骤1

逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。

#### 2.2 倒排索引

倒排索引中有两个非常重要的概念：

*   文档（`Document`）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息
*   词条（`Term`）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条

**创建倒排索引**是对正向索引的一种特殊处理，流程如下：

*   将每一个文档的数据利用算法分词，得到一个个词条
*   创建表，每行数据包括词条、词条所在文档id、位置等信息
*   因为词条唯一性，可以给词条创建索引，例如hash表结构索引

如图：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171751933-576636800.png)

倒排索引的**搜索流程**如下（以搜索"华为手机"为例）：

1）用户输入条件`"华为手机"`进行搜索。

2）对用户输入内容**分词**，得到词条：`华为`、`手机`。

3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。

4）拿着文档id到正向索引中查找具体文档。

如图：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171803916-704919285.png)

虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。

#### 2.3 正向和倒排对比

概念区别：

*   **正向索引**是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是**根据文档找词条的过程**。
    
*   而**倒排索引**则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是**根据词条找文档的过程**。
    

优缺点：

**正向索引**：

*   优点：
    *   可以给多个字段创建索引
    *   根据索引字段搜索、排序速度非常快
*   缺点：
    *   根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。

**倒排索引**：

*   优点：
    *   根据词条搜索、模糊搜索时，速度非常快
*   缺点：
    *   只能给词条创建索引，而不是字段
    *   无法根据字段做排序

### 3\. ES数据库基本概念

elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。

#### 3.1.文档和字段

> 一个文档就像数据库里的一条数据，字段就像数据库里的列

elasticsearch是面向**文档（Document）**存储的，可以是**数据库中的一条商品数据**，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171811564-2114810461.png)

而Json文档中往往包含很多的**字段（Field）**，类似于**mysql数据库中的列**。

#### 3.2.索引和映射

> 索引就像数据库里的表，映射就像数据库中定义的表结构

**索引（Index）**，就是相同类型的文档的集合【**类似mysql中的表**】

例如：

*   所有用户文档，就可以组织在一起，称为用户的索引；
*   所有商品的文档，可以组织在一起，称为商品的索引；
*   所有订单的文档，可以组织在一起，称为订单的索引；

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171817377-1198317744.png)

因此，我们可以把索引当做是数据库中的表。

数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有**映射（mapping）**，是索引中文档的字段约束信息，类似表的结构约束。

#### 3.3.mysql与elasticsearch

> 各自长处：
> 
> *   Mysql：擅长事务类型操作，可以确保数据的安全和一致性
>     
> *   Elasticsearch：擅长海量数据的搜索、分析、计算
>     

我们统一的把**mysql与elasticsearch的概念做一下对比**：

**MySQL**

**Elasticsearch**

**说明**

Table

Index

索引(index)，就是文档的集合，类似数据库的表(table)

Row

Document

文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式

Column

Field

字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）

Schema

Mapping

Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）

SQL

DSL

DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD

在企业中，往往是两者结合使用：

*   对安全性要求较高的写操作，使用mysql实现
*   对查询性能要求较高的搜索需求，使用elasticsearch实现
*   两者再基于某种方式，实现数据的同步，保证一致性

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171824403-1152991371.png)

### 4\. 安装es、kibana、分词器

> 分词器的作用是什么？
> 
> *   创建倒排索引时对文档分词
> *   用户搜索时，对输入的内容分词
> 
> IK分词器有几种模式？
> 
> *   ik\_smart：智能切分，粗粒度
> *   ik\_max\_word：最细切分，细粒度
> 
> IK分词器如何拓展词条？如何停用词条？
> 
> *   利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典
> *   在词典中添加拓展词条或者停用词条

#### 4.1 部署单点es

##### 4.1.1.创建网络

因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：

    docker network create es-net
    

##### 4.1.2.加载镜像

这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。

课前资料提供了镜像的tar包：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171831042-1395359270.png)

大家将其上传到虚拟机中，然后运行命令加载即可：

    # 导入数据
    docker load -i es.tar
    

**注意：同理还有`kibana`的tar包也需要这样做。**

##### 4.1.3.运行

运行docker命令，部署单点es：

    docker run -d \
    	--name es \
        -e "ES_JAVA_OPTS=-Xms512m -Xmx512m" \
        -e "discovery.type=single-node" \
        -v es-data:/usr/share/elasticsearch/data \
        -v es-plugins:/usr/share/elasticsearch/plugins \
        --privileged \
        --network es-net \
        -p 9200:9200 \
        -p 9300:9300 \
    elasticsearch:7.12.1
    

命令解释：

*   `-e "cluster.name=es-docker-cluster"`：设置集群名称
*   `-e "http.host=0.0.0.0"`：监听的地址，可以外网访问
*   `-e "ES_JAVA_OPTS=-Xms512m -Xmx512m"`：内存大小
*   `-e "discovery.type=single-node"`：非集群模式
*   `-v es-data:/usr/share/elasticsearch/data`：挂载逻辑卷，绑定es的数据目录
*   `-v es-logs:/usr/share/elasticsearch/logs`：挂载逻辑卷，绑定es的日志目录
*   `-v es-plugins:/usr/share/elasticsearch/plugins`：挂载逻辑卷，绑定es的插件目录
*   `--privileged`：授予逻辑卷访问权
*   `--network es-net` ：加入一个名为es-net的网络中
*   `-p 9200:9200`：端口映射配置

在浏览器中输入：[http://192.168.194.131/:9200](http://192.168.194.131/:9200) 即可看到elasticsearch的响应结果：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171842180-458017634.png)

#### 4.2.部署kibana

kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。

##### 4.2.1.部署

**创建网络后，导入kibana压缩包，然后创建并启动相应容器。【和前面部署单点es一样做法】**

再运行docker命令，部署kibana

    docker run -d \
    --name kibana \
    -e ELASTICSEARCH_HOSTS=http://es:9200 \
    --network=es-net \
    -p 5601:5601  \
    kibana:7.12.1
    

*   `--network es-net` ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中
*   `-e ELASTICSEARCH_HOSTS=http://es:9200"`：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch
*   `-p 5601:5601`：端口映射配置

kibana启动一般比较慢，需要多等待一会，可以通过命令：

    docker logs -f kibana
    

查看运行日志，当查看到下面的日志，说明成功：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171848067-1760891955.png)

此时，在浏览器输入地址访问：[http://192.168.194.131:5601](http://192.168.194.131:5601)，即可看到结果如下图：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171852468-457961443.png)

kibana左侧中提供了一个DevTools界面：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171858509-678638964.png)

这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。

#### 4.3.安装IK分词器

##### 4.3.1.在线安装ik插件（较慢）

    # 进入容器内部
    docker exec -it elasticsearch /bin/bash
    
    # 在线下载并安装
    ./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip
    
    #退出
    exit
    #重启容器
    docker restart elasticsearch
    

##### 4.3.2.离线安装ik插件（推荐）

**1）查看数据卷目录**

安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:

    docker volume inspect es-plugins
    

显示结果：

    [
        {
            "CreatedAt": "2022-05-06T10:06:34+08:00",
            "Driver": "local",
            "Labels": null,
            "Mountpoint": "/var/lib/docker/volumes/es-plugins/_data",
            "Name": "es-plugins",
            "Options": null,
            "Scope": "local"
        }
    ]
    

说明plugins目录被挂载到了：`/var/lib/docker/volumes/es-plugins/_data` 这个目录中。

**2）解压缩分词器安装包**

下面我们需要把课前资料中的ik分词器解压缩，重命名为ik

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171931639-1168552613.png)

**3）上传到es容器的插件数据卷中**

也就是`/var/lib/docker/volumes/es-plugins/_data` ：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171956796-973760726.png)

**4）重启容器**

    # 4、重启容器
    docker restart es
    

    # 查看es日志
    docker logs -f es
    

**5）测试：**

IK分词器包含两种模式：

*   `ik_smart`：最少切分
    
*   `ik_max_word`：最细切分
    

在kibana的Dev tools中输入以下代码：

> ”analyzer“ 就是选择分词器模式

    GET /_analyze
    {
      "analyzer": "ik_max_word",
      "text": "黑马程序员学习java太棒了"
    }
    

结果：

    {
      "tokens" : [
        {
          "token" : "黑马",
          "start_offset" : 0,
          "end_offset" : 2,
          "type" : "CN_WORD",
          "position" : 0
        },
        {
          "token" : "程序员",
          "start_offset" : 2,
          "end_offset" : 5,
          "type" : "CN_WORD",
          "position" : 1
        },
        {
          "token" : "程序",
          "start_offset" : 2,
          "end_offset" : 4,
          "type" : "CN_WORD",
          "position" : 2
        },
        {
          "token" : "员",
          "start_offset" : 4,
          "end_offset" : 5,
          "type" : "CN_CHAR",
          "position" : 3
        },
        {
          "token" : "学习",
          "start_offset" : 5,
          "end_offset" : 7,
          "type" : "CN_WORD",
          "position" : 4
        },
        {
          "token" : "java",
          "start_offset" : 7,
          "end_offset" : 11,
          "type" : "ENGLISH",
          "position" : 5
        },
        {
          "token" : "太棒了",
          "start_offset" : 11,
          "end_offset" : 14,
          "type" : "CN_WORD",
          "position" : 6
        },
        {
          "token" : "太棒",
          "start_offset" : 11,
          "end_offset" : 13,
          "type" : "CN_WORD",
          "position" : 7
        },
        {
          "token" : "了",
          "start_offset" : 13,
          "end_offset" : 14,
          "type" : "CN_CHAR",
          "position" : 8
        }
      ]
    }
    

##### 4.3.3 扩展词词典

随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“白嫖” 等。

所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。

1）打开IK分词器config目录：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172005673-1129389907.png)

2）在IKAnalyzer.cfg.xml配置文件内容添加：

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
    <properties>
            <comment>IK Analyzer 扩展配置</comment>
            <!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典-->
            <entry key="ext_dict">ext.dic</entry>
    </properties>
    

3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改

    白嫖
    奥力给
    

4）重启elasticsearch

    docker restart es
    
    # 查看 日志
    docker logs -f elasticsearch
    

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172011932-1622225700.png)

日志中已经成功加载ext.dic配置文件

5）测试效果：

    GET /_analyze
    {
      "analyzer": "ik_max_word",
      "text": "传智播客Java就业超过90%,奥力给！"
    }
    

> 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑

##### 4.3.4 停用词词典

在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。

IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。

1）IKAnalyzer.cfg.xml配置文件内容添加：

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
    <properties>
            <comment>IK Analyzer 扩展配置</comment>
            <!--用户可以在这里配置自己的扩展字典-->
            <entry key="ext_dict">ext.dic</entry>
             <!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典-->
            <entry key="ext_stopwords">stopword.dic</entry>
    </properties>
    

3）在 stopword.dic 添加停用词

    大帅逼
    

4）重启elasticsearch

    # 重启服务
    docker restart es
    docker restart kibana
    
    # 查看 日志
    docker logs -f elasticsearch
    

日志中已经成功加载stopword.dic配置文件

5）测试效果：

    GET /_analyze
    {
      "analyzer": "ik_max_word",
      "text": "我是真的会谢Java就业率超过95%,大帅逼都点赞白嫖,奥力给！"
    }
    

> 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑

索引库操作
-----

索引库就类似数据库表，mapping映射就类似表的结构。

我们要向es中存储数据，必须先创建“库”和“表”。

### 1\. Mapping映射属性

mapping是对索引库中文档的约束，常见的mapping属性包括：

*   type：字段数据类型，常见的简单类型有：
    
    *   字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）
        
        > **keyword类型只能整体搜索，不支持搜索部分内容**
        
    *   数值：long、integer、short、byte、double、float、
        
    *   布尔：boolean
        
    *   日期：date
        
    *   对象：object
        
*   index：是否创建索引，默认为true
    
*   analyzer：使用哪种分词器
    
*   properties：该字段的子字段
    

例如下面的json文档：

    {
        "age": 21,
        "weight": 52.1,
        "isMarried": false,
        "info": "真相只有一个！",
        "email": "zy@itcast.cn",
        "score": [99.1, 99.5, 98.9],
        "name": {
            "firstName": "柯",
            "lastName": "南"
        }
    }
    

对应的每个字段映射（mapping）：

*   age：类型为 integer；参与搜索，因此需要index为true；无需分词器
*   weight：类型为float；参与搜索，因此需要index为true；无需分词器
*   isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器
*   info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik\_smart
*   email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器
*   score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器
*   name：类型为object，需要定义多个子属性
    *   name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器
    *   name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器

### 2\. 索引库的CRUD

> CRUD简单描述：
> 
> *   创建索引库：PUT /索引库名
> *   查询索引库：GET /索引库名
> *   删除索引库：DELETE /索引库名
> *   修改索引库（添加字段）：PUT /索引库名/\_mapping

这里统一使用Kibana编写DSL的方式来演示。

#### 2.1 创建索引库和映射

**基本语法：**

*   请求方式：PUT
*   请求路径：/索引库名，可以自定义
*   请求参数：mapping映射

格式：

    PUT /索引库名称
    {
      "mappings": {
        "properties": {
          "字段名":{
            "type": "text",
            "analyzer": "ik_smart"
          },
          "字段名2":{
            "type": "keyword",
            "index": "false"
          },
          "字段名3":{
            "properties": {
              "子字段": {
                "type": "keyword"
              }
            }
          },
          // ...略
        }
      }
    }
    

**示例：**

    PUT /conan
    {
      "mappings": {
        "properties": {
          "column1":{
            "type": "text",
            "analyzer": "ik_smart"
          },
          "column2":{
            "type": "keyword",
            "index": "false"
          },
          "column3":{
            "properties": {
              "子字段1": {
                "type": "keyword"
              },
              "子字段2": {
                "type": "keyword"
              }
            }
          },
          // ...略
        }
      }
    }
    

#### 2.2 查询索引库

**基本语法**：

*   请求方式：GET
    
*   请求路径：/索引库名
    
*   请求参数：无
    

**格式**：

    GET /索引库名
    

**示例**：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172026788-713413668.png)

#### 2.3 修改索引库

> 这里的修改是只能增加新的字段到mapping中

倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库**一旦创建，无法修改mapping**。

虽然无法修改mapping中已有的字段，但是却**允许添加新的字段**到mapping中，因为不会对倒排索引产生影响。

**语法说明**：

    PUT /索引库名/_mapping
    {
      "properties": {
        "新字段名":{
          "type": "integer"
        }
      }
    }
    

**示例**：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172037719-1357645386.png)

#### 2.4 删除索引库

**语法：**

*   请求方式：DELETE
    
*   请求路径：/索引库名
    
*   请求参数：无
    

**格式：**

    DELETE /索引库名
    

在kibana中测试：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172043420-1340912851.png)

文档操作
----

> 文档操作有哪些？
> 
> *   创建文档：POST /{索引库名}/\_doc/文档id
> *   查询文档：GET /{索引库名}/\_doc/文档id
> *   删除文档：DELETE /{索引库名}/\_doc/文档id
> *   修改文档：
>     *   全量修改：PUT /{索引库名}/\_doc/文档id
>     *   增量修改：POST /{索引库名}/\_update/文档id { "doc": {字段}}

### 1\. 文档的CRUD

#### 1.1 新增文档

**语法：**

    POST /索引库名/_doc/文档id
    {
        "字段1": "值1",
        "字段2": "值2",
        "字段3": {
            "子属性1": "值3",
            "子属性2": "值4"
        },
        // ...
    }
    

**示例：**

    POST /heima/_doc/1
    {
        "info": "真相只有一个！",
        "email": "zy@itcast.cn",
        "name": {
            "firstName": "柯",
            "lastName": "南"
        }
    }
    

**响应：**

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172052120-910375955.png)

#### 1.2 查询文档

根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。

**语法：**

    GET /{索引库名称}/_doc/{id}
    //批量查询：查询该索引库下的全部文档
    GET /{索引库名称}/_search
    

**通过kibana查看数据：**

    GET /heima/_doc/1
    

**查看结果：**

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172058746-892146016.png)

#### 1.3 删除文档

删除使用DELETE请求，同样，需要根据id进行删除：

**语法：**

    DELETE /{索引库名}/_doc/id值
    

**示例：**

    # 根据id删除数据
    DELETE /heima/_doc/1
    

**结果：**

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172105015-1483849739.png)

#### 1.4 修改文档

修改有两种方式：

*   全量修改：直接覆盖原来的文档
*   增量修改：修改文档中的部分字段

##### 1.4.1 全量修改

全量修改是覆盖原来的文档，其本质是：

*   根据指定的id删除文档
*   新增一个相同id的文档

**注意**：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。

**语法：**

    PUT /{索引库名}/_doc/文档id
    {
        "字段1": "值1",
        "字段2": "值2",
        // ... 略
    }
    
    

**示例：**

    PUT /heima/_doc/1
    {
        "info": "黑马程序员高级Java讲师",
        "email": "zy@itcast.cn",
        "name": {
            "firstName": "云",
            "lastName": "赵"
        }
    }
    

##### 1.4.2 增量修改

增量修改是只修改指定id匹配的文档中的部分字段。

**语法：**

    POST /{索引库名}/_update/文档id
    {
        "doc": {
             "字段名": "新的值",
        }
    }
    

**示例：**

    POST /heima/_update/1
    {
      "doc": {
        "email": "ZhaoYun@itcast.cn"
      }
    }
    

RestAPI
-------

ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：[https://www.elastic.co/guide/en/elasticsearch/client/index.html](https://www.elastic.co/guide/en/elasticsearch/client/index.html)

其中的Java Rest Client又包括两种：

*   Java Low Level Rest Client
*   Java High Level Rest Client

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172112415-1704197079.png)

我们使用的是Java HighLevel Rest Client客户端API

### API操作索引库

> JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。
> 
> 索引库操作的基本步骤：【可以根据发送请求那步的第一个参数，发过来判断需要创建什么XXXXRequest】
> 
> *   初始化RestHighLevelClient
> *   创建XxxIndexRequest。XXX是Create、Get、Delete
> *   准备DSL（ Create时需要，其它是无参）
> *   发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete

#### 1\. mapping映射分析

> **根据MySQL数据库表结构（建表语句），去写索引库结构JSON。表和索引库一一对应**
> 
> **注意**：地理坐标、组合字段。索引库里的地理坐标是一个字段：`坐标：维度,精度` 。copy\_to组合字段作用是供用户查询（输入关键字可以查询多个字段）

创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：

*   字段名
*   字段数据类型
*   是否参与搜索
*   是否需要分词
*   如果分词，分词器是什么？

其中：

*   字段名、字段数据类型，可以参考数据表结构的名称和类型
*   是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索
*   是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词
*   分词器，我们可以统一使用ik\_max\_word

来看下酒店数据的索引库结构:

    PUT /hotel
    {
      "mappings": {
        "properties": {
          "id": {
            "type": "keyword"
          },
          "name":{
            "type": "text",
            "analyzer": "ik_max_word",
            "copy_to": "all"
          },
          "address":{
            "type": "keyword",
            "index": false
          },
          "price":{
            "type": "integer"
          },
          "score":{
            "type": "integer"
          },
          "brand":{
            "type": "keyword",
            "copy_to": "all"
          },
          "city":{
            "type": "keyword",
            "copy_to": "all"
          },
          "starName":{
            "type": "keyword"
          },
          "business":{
            "type": "keyword"
          },
          "location":{
            "type": "geo_point"
          },
          "pic":{
            "type": "keyword",
            "index": false
          },
          "all":{
            "type": "text",
            "analyzer": "ik_max_word"
          }
        }
      }
    }
    

几个特殊字段说明：

*   location：地理坐标，里面包含精度、纬度
*   all：一个组合字段，其目的是将多字段的值 利用copy\_to合并，提供给用户搜索

地理坐标说明：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172124085-626335563.png)

copy\_to说明：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172128097-289087887.png)

#### 2.初始化RestClient

在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。

分为三步：

1）引入es的RestHighLevelClient依赖：

    <dependency>
        <groupId>org.elasticsearch.client</groupId>
        <artifactId>elasticsearch-rest-high-level-client</artifactId>
    </dependency>
    

2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：

    <properties>
        <java.version>1.8</java.version>
        <elasticsearch.version>7.12.1</elasticsearch.version>
    </properties>
    

3）初始化RestHighLevelClient：这里一般在启动类或者配置类里注入该Bean，用于告诉Java 访问ES的ip地址

初始化的代码如下：

    @Bean
    public RestHighLevelClient client(){
        return new RestHighLevelClient(RestClient.builder(
            HttpHost.create("http://192.168.150.101:9200")
    	));
    }
    

这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中：

    package cn.itcast.hotel;
    
    import org.apache.http.HttpHost;
    import org.elasticsearch.client.RestHighLevelClient;
    import org.junit.jupiter.api.AfterEach;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.Test;
    
    import java.io.IOException;
    
    public class HotelIndexTest {
        private RestHighLevelClient client;
    
        @BeforeEach
        void setUp() {
            this.client = new RestHighLevelClient(RestClient.builder(
                    HttpHost.create("http://192.168.150.101:9200")
            ));
        }
    
        @AfterEach
        void tearDown() throws IOException {
            this.client.close();
        }
    }
    

#### 3\. 索引库CRUD

##### 3.1 创建索引库

> 代码分为三步：
> 
> *   1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。
> *   2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING\_TEMPLATE，让代码看起来更加优雅。
> *   3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。

创建索引库的API如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172138463-1252488196.png)

**代码：**

在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量：

    package cn.itcast.hotel.constants;
    
    public class HotelConstants {
        public static final String MAPPING_TEMPLATE = "{\n" +
                "  \"mappings\": {\n" +
                "    \"properties\": {\n" +
                "      \"id\": {\n" +
                "        \"type\": \"keyword\"\n" +
                "      },\n" +
                "      \"name\":{\n" +
                "        \"type\": \"text\",\n" +
                "        \"analyzer\": \"ik_max_word\",\n" +
                "        \"copy_to\": \"all\"\n" +
                "      },\n" +
                "      \"address\":{\n" +
                "        \"type\": \"keyword\",\n" +
                "        \"index\": false\n" +
                "      },\n" +
                "      \"price\":{\n" +
                "        \"type\": \"integer\"\n" +
                "      },\n" +
                "      \"score\":{\n" +
                "        \"type\": \"integer\"\n" +
                "      },\n" +
                "      \"brand\":{\n" +
                "        \"type\": \"keyword\",\n" +
                "        \"copy_to\": \"all\"\n" +
                "      },\n" +
                "      \"city\":{\n" +
                "        \"type\": \"keyword\",\n" +
                "        \"copy_to\": \"all\"\n" +
                "      },\n" +
                "      \"starName\":{\n" +
                "        \"type\": \"keyword\"\n" +
                "      },\n" +
                "      \"business\":{\n" +
                "        \"type\": \"keyword\"\n" +
                "      },\n" +
                "      \"location\":{\n" +
                "        \"type\": \"geo_point\"\n" +
                "      },\n" +
                "      \"pic\":{\n" +
                "        \"type\": \"keyword\",\n" +
                "        \"index\": false\n" +
                "      },\n" +
                "      \"all\":{\n" +
                "        \"type\": \"text\",\n" +
                "        \"analyzer\": \"ik_max_word\"\n" +
                "      }\n" +
                "    }\n" +
                "  }\n" +
                "}";
    }
    

在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引：

    @Test
    void createHotelIndex() throws IOException {
        // 1.创建Request对象
        CreateIndexRequest request = new CreateIndexRequest("hotel");
        // 2.准备请求的参数：DSL语句
        request.source(MAPPING_TEMPLATE, XContentType.JSON);
        // 3.发送请求
        client.indices().create(request, RequestOptions.DEFAULT);
    }
    

##### 3.2 删除索引库

> 三步走：
> 
> *   1）创建Request对象。这次是DeleteIndexRequest对象
> *   2）准备参数。这里是无参
> *   3）发送请求。改用delete方法

删除索引库的DSL语句非常简单：

    DELETE /hotel
    

在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引：

    @Test
    void testDeleteHotelIndex() throws IOException {
        // 1.创建Request对象
        DeleteIndexRequest request = new DeleteIndexRequest("hotel");
        // 2.发送请求
        client.indices().delete(request, RequestOptions.DEFAULT);
    }
    

##### 3.3 查询索引库

> 三步走：
> 
> *   1）创建Request对象。这次是GetIndexRequest对象
> *   2）准备参数。这里是无参
> *   3）发送请求。改用exists方法

判断索引库是否存在，本质就是查询，对应的DSL是：

    GET /hotel
    

    @Test
    void testExistsHotelIndex() throws IOException {
        // 1.创建Request对象
        GetIndexRequest request = new GetIndexRequest("hotel");
        // 2.发送请求
        boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);
        // 3.输出
        System.err.println(exists ? "索引库已经存在！" : "索引库不存在！");
    }
    

### API操作文档

> 这里更多的是先读取Mysql中的数据，然后再存进ES中。
> 
> 文档操作的基本步骤：【可以根据发送请求那步的第一个参数，发过来判断需要创建什么XXXXRequest】
> 
> *   初始化RestHighLevelClient
> *   创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk
> *   准备参数（Index、Update、Bulk时需要）
> *   发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk
> *   解析结果（Get时需要）

#### 1\. 初始化RestClient

在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。

分为三步：

1）引入es的RestHighLevelClient依赖：

    <dependency>
        <groupId>org.elasticsearch.client</groupId>
        <artifactId>elasticsearch-rest-high-level-client</artifactId>
    </dependency>
    

2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：

    <properties>
        <java.version>1.8</java.version>
        <elasticsearch.version>7.12.1</elasticsearch.version>
    </properties>
    

3）初始化RestHighLevelClient：这里一般写在最前面，用于告诉Java 访问ES的ip地址

初始化的代码如下：

    RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(
            HttpHost.create("http://192.168.150.101:9200")
    ));
    

这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中：

    package cn.itcast.hotel;
    
    import org.apache.http.HttpHost;
    import org.elasticsearch.client.RestHighLevelClient;
    import org.junit.jupiter.api.AfterEach;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.Test;
    
    import java.io.IOException;
    
    public class HotelIndexTest {
        private RestHighLevelClient client;
    
        @BeforeEach
        void setUp() {
            this.client = new RestHighLevelClient(RestClient.builder(
                    HttpHost.create("http://192.168.150.101:9200")
            ));
        }
    
        @AfterEach
        void tearDown() throws IOException {
            this.client.close();
        }
    }
    

#### 2\. 文档CRUD

##### 2.0 批量导入文档

> 三步走：
> 
> *   1）创建Request对象。这里是BulkRequest
> *   2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest
> *   3）发起请求。这里是批处理，调用的方法为client.bulk()方法

案例需求：利用BulkRequest批量将数据库数据导入到索引库中。

步骤如下：

*   利用mybatis-plus查询酒店数据
    
*   将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）
    
*   利用JavaRestClient中的BulkRequest批处理，实现批量新增文档
    

**语法说明：**

批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。

其中提供了一个add方法，用来添加其他请求：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172220573-1990074801.png)

可以看到，能添加的请求包括：

*   IndexRequest，也就是新增
*   UpdateRequest，也就是修改
*   DeleteRequest，也就是删除

因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172227358-759338253.png)

我们在导入酒店数据时，将上述代码改造成for循环处理即可。

在hotel-demo的HotelDocumentTest测试类中，编写单元测试：

    @Test
    void testBulkRequest() throws IOException {
        // 批量查询酒店数据
        List<Hotel> hotels = hotelService.list();
    
        // 1.创建Request
        BulkRequest request = new BulkRequest();
        // 2.准备参数，添加多个新增的Request
        for (Hotel hotel : hotels) {
            // 2.1.转换为文档类型HotelDoc
            HotelDoc hotelDoc = new HotelDoc(hotel);
            // 2.2.创建新增文档的Request对象
            request.add(new IndexRequest("hotel")
                        .id(hotelDoc.getId().toString())
                        .source(JSON.toJSONString(hotelDoc), XContentType.JSON));
        }
        // 3.发送请求
        client.bulk(request, RequestOptions.DEFAULT);
    }
    

##### 2.1 批量新增文档

> 四步走：
> 
> *   0）创建索引库实体类
> *   1）创建Request对象
> *   2）准备请求参数，也就是DSL中的JSON文档
> *   3）发送请求 （注意：这里直接使用client.xxx()的API，不再需要client.indices()了）

我们要将数据库的酒店数据查询出来，写入elasticsearch中。

**1）创建索引库实体类**

> 一般实体类里包含经纬度都需要创建一个新的实体类，将经纬度拼成一个字段

数据库查询后的结果是一个Hotel类型的对象。结构如下：

    @Data
    @TableName("tb_hotel")
    public class Hotel {
        @TableId(type = IdType.INPUT)
        private Long id;
        private String name;
        private String address;
        private Integer price;
        private Integer score;
        private String brand;
        private String city;
        private String starName;
        private String business;
        private String longitude;
        private String latitude;
        private String pic;
    }
    

与我们的索引库结构存在差异：

*   longitude和latitude需要合并为location

因此，我们需要定义一个新的类型，与索引库结构吻合：

    package cn.itcast.hotel.pojo;
    
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @NoArgsConstructor
    public class HotelDoc {
        private Long id;
        private String name;
        private String address;
        private Integer price;
        private Integer score;
        private String brand;
        private String city;
        private String starName;
        private String business;
        private String location;
        private String pic;
    
        public HotelDoc(Hotel hotel) {
            this.id = hotel.getId();
            this.name = hotel.getName();
            this.address = hotel.getAddress();
            this.price = hotel.getPrice();
            this.score = hotel.getScore();
            this.brand = hotel.getBrand();
            this.city = hotel.getCity();
            this.starName = hotel.getStarName();
            this.business = hotel.getBusiness();
            this.location = hotel.getLatitude() + ", " + hotel.getLongitude();
            this.pic = hotel.getPic();
        }
    }
    

**2）新增代码**

新增文档的DSL语句如下：

    POST /{索引库名}/_doc/1
    {
        "name": "Jack",
        "age": 21
    }
    

对应的java代码如图：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172259030-1988634807.png)

我们导入酒店数据，基本流程一致，但是需要考虑几点变化：

*   酒店数据来自于数据库，我们需要先查询出来，得到hotel对象
*   hotel对象需要转为HotelDoc对象
*   HotelDoc需要序列化为json格式

在hotel-demo的HotelDocumentTest测试类中，编写单元测试：

    @Test
    void testAddDocument() throws IOException {
        // 批量查询酒店数据
        List<Hotel> hotels = hotelService.list();
    
        // 1.创建Request
        BulkRequest request = new BulkRequest();
        // 2.准备参数，添加多个新增的Request
        for (Hotel hotel : hotels) {
            // 2.1.转换为文档类型HotelDoc
            HotelDoc hotelDoc = new HotelDoc(hotel);
            // 2.2.创建新增文档的Request对象
            request.add(new IndexRequest("hotel")
                        .id(hotelDoc.getId().toString())
                        .source(JSON.toJSONString(hotelDoc), XContentType.JSON));//实体类转JSON，指定JSON格式
            request.add(new IndexRequest("xxx")...)
        }
        // 3.发送请求
        client.bulk(request, RequestOptions.DEFAULT);
    }
    

##### 2.2 查询文档

> 查询文档是根据id查询的，所以没有批量查询
> 
> 三步走：
> 
> *   1）准备Request对象。这次是查询，所以是GetRequest
> *   2）发送请求，得到结果。因为是查询，这里调用client.get()方法
> *   3）解析结果，就是对JSON做反序列化

查询的DSL语句如下：

    GET /hotel/_doc/{id}
    

非常简单，因此代码大概分两步：

*   准备Request对象
*   发送请求

不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172309780-381577770.png)

可以看到，结果是一个JSON，其中文档放在一个`_source`属性中，因此解析就是拿到`_source`，使用工具反序列化为Java对象即可。

在hotel-demo的HotelDocumentTest测试类中，编写单元测试：

    @Test
    void testGetDocumentById() throws IOException {
        // 1.准备Request
        GetRequest request = new GetRequest("hotel", "61082");
        // 2.发送请求，得到响应
        GetResponse response = client.get(request, RequestOptions.DEFAULT);
        // 3.解析响应结果
        String json = response.getSourceAsString();
    
        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);
        System.out.println(hotelDoc);
    }
    

##### 2.3 批量删除文档

> 三步走：
> 
> *   1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id
> *   2）准备参数，无参
> *   3）发送请求。因为是删除，所以是client.delete()方法

删除的DSL为是这样的：

    DELETE /hotel/_doc/{id}
    

在hotel-demo的HotelDocumentTest测试类中，编写单元测试：

    @Test
    void testDeleteDocument() throws IOException {
        //0.查询数据库中的数据
        List<Hotel> list = hotelService.list();
        // 1.创建Request
        BulkRequest request = new BulkRequest();
        //2.批量转换实体类，顺便写入到ES中
        for (Hotel hotel : list) {
            //2.1转换实体类
            HotelDoc hotelDoc =new HotelDoc(hotel);
            //2.2写入ES
            request.add(new DeleteRequest("hotel")
                        .id(hotel.getId().toString()));
        }
        //3.发送请求
        client.bulk(request,RequestOptions.DEFAULT);
    }
    

##### 2.4 批量修改文档

> 三步走：
> 
> *   1）准备Request对象。这次是修改，所以是UpdateRequest
> *   2）准备参数。也就是JSON文档，里面包含要修改的字段
> *   3）更新文档。这里调用client.update()方法

修改有两种方式：

*   全量修改：本质是先根据id删除，再新增
*   增量修改：修改文档中的指定字段值

在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：

*   如果新增时，ID已经存在，则修改
*   如果新增时，ID不存在，则新增

**只演示增量修改：**

代码示例如图：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172320621-611636092.png)

在hotel-demo的HotelDocumentTest测试类中，编写单元测试：

    @Test
    void testUpdateDocument() throws IOException {
        //0.查询数据库中的数据
        List<Hotel> list = hotelService.list();
        // 1.创建Request
        BulkRequest request = new BulkRequest();
        //2.批量转换实体类，顺便写入到ES中
        for (Hotel hotel : list) {
            //2.1转换实体类
            HotelDoc hotelDoc =new HotelDoc(hotel);
            //2.2写入ES
            request.add(new UpdateRequest("hotel",hotel.getId().toString())
                        .doc(
                            "price", "952",
                            "starName", "四钻"
                        ));
        }
        //3.发送请求
        client.bulk(request,RequestOptions.DEFAULT);
    }
    

ES搜索引擎
------

elasticsearch的查询依然是基于JSON风格的DSL来实现的。

### 1\. DSL设置查询条件

#### 1.1 DSL查询分类

Elasticsearch提供了基于JSON的DSL（[Domain Specific Language](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html)）来定义查询。常见的查询类型包括：

*   **查询所有**：查询出所有数据，_一般测试用_。例如：match\_all
    
*   **全文检索（full text）查询**：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：
    
    *   match\_query
    *   multi\_match\_query
*   **精确查询**：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：
    
    *   ids
    *   range
    *   term
*   **地理（geo）查询**：根据经纬度查询。例如：
    
    *   geo\_distance
    *   geo\_bounding\_box
*   **复合（compound）查询**：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：
    
    *   bool
    *   function\_score

查询的语法基本一致：

    GET /indexName/_search
    {
      "query": {
        "查询类型": {
          "查询条件": "条件值"
        }
      }
    }
    

我们以查询所有为例，其中：

*   查询类型为match\_all
*   没有查询条件

    // 查询所有
    GET /indexName/_search
    {
      "query": {
        "match_all": {
        }
      }
    }
    

其它查询无非就是**查询类型**、**查询条件**的变化。

#### 1.2 全文检索查询

> match和multi\_match的区别是什么？
> 
> *   match：根据一个字段查询【推荐：使用copy\_to构造all字段】
> *   multi\_match：根据多个字段查询，参与查询字段越多，查询性能越差
> 
> **注：搜索字段越多，对查询性能影响越大，因此建议采用copy\_to，然后单字段查询的方式。**

##### 1.2.1 使用场景

全文检索查询的**基本流程**如下：

*   对用户搜索的内容做分词，得到词条
*   根据词条去倒排索引库中匹配，得到文档id
*   根据文档id找到文档，返回给用户

比较常用的**场景**包括：

*   商城的输入框搜索
*   百度输入框搜索

例如京东：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172332617-1391223216.png)

因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。

常见的全文检索查询包括：

*   match查询：单字段查询
*   multi\_match查询：多字段查询，任意一个字段符合条件就算符合查询条件

##### 1.2.2 match查询

match查询语法如下：

    GET /indexName/_search
    {
      "query": {
        "match": {
          "FIELD": "TEXT"
        }
      }
    }
    

match查询示例：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172338916-1567477721.png)

##### 1.2.3 mulit\_match查询

mulit\_match语法如下：

    GET /indexName/_search
    {
      "query": {
        "multi_match": {
          "query": "TEXT",
          "fields": ["FIELD1", " FIELD12"]
        }
      }
    }
    

multi\_match查询示例：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172344847-66722394.png)

#### 1.3 精准查询

> 精准查询类型：
> 
> *   term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段
> *   range查询：根据数值范围查询，可以是数值、日期的范围

精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以**不会**对搜索条件分词。常见的有：

*   **term：根据词条精确值查询**
*   **range：根据值的范围查询**

##### 1.3.1 term查询

因为精确查询的字段搜时不分词的字段，因此查询的条件也必须是**不分词**的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。

语法说明：

    // term查询
    GET /indexName/_search
    {
      "query": {
        "term": {
          "FIELD": {
            "value": "VALUE"
          }
        }
      }
    }
    

示例：

当我搜索的是精确词条时，能正确查询出结果：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172353868-723957119.png)

但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172404632-400137183.png)

##### 1.3.2 range查询

> 范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。

基本语法：

    // range查询
    GET /indexName/_search
    {
      "query": {
        "range": {
          "FIELD": {
            "gte": 10, // 这里的gte代表大于等于，gt则代表大于
            "lte": 20 // lte代表小于等于，lt则代表小于
          }
        }
      }
    }
    

示例：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172415197-322405876.png)

#### 1.4 地理坐标查询

所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：[https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html](https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html)

常见的使用场景包括：

*   携程：搜索我附近的酒店
*   滴滴：搜索我附近的出租车
*   微信：搜索我附近的人

附近的酒店：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172420925-939257883.png)

附近的车：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172429568-981337372.png)

##### 1.4.1 矩形范围查询

> 很少有业务有这种需求

矩形范围查询，也就是geo\_bounding\_box查询，查询坐标落在某个矩形范围的所有文档：  
![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172556695-448469947.gif)

查询时，需要指定矩形的**左上**、**右下**两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。

语法如下：

    // geo_bounding_box查询
    GET /indexName/_search
    {
      "query": {
        "geo_bounding_box": {
          "FIELD": {
            "top_left": { // 左上点
              "lat": 31.1,
              "lon": 121.5
            },
            "bottom_right": { // 右下点
              "lat": 30.9,
              "lon": 121.7
            }
          }
        }
      }
    }
    

##### 1.4.2 附近(圆形)查询

附近查询，也叫做距离查询（geo\_distance）：查询到指定中心点小于某个距离值的所有文档。

换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172657385-1268854128.gif)

语法说明：

    // geo_distance 查询
    GET /indexName/_search
    {
      "query": {
        "geo_distance": {
          "distance": "15km", // 半径
          "FIELD": "31.21,121.5" // 圆心
        }
      }
    }
    

示例：

我们先搜索陆家嘴附近15km的酒店：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172724869-1773754207.png)

发现共有47家酒店。

#### 1.5 复合查询

复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：

*   fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名
*   bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索

##### 1.5.0 复合查询归纳

    GET /hotel/_search
    {
      "query": {
        "function_score": {           
          "query": { // 原始查询，可以是任意条件
              "bool": {
                  "must": [
                      {"term": {"city": "上海" }}
                  ],
                  "should": [
                      {"term": {"brand": "皇冠假日" }},
                      {"term": {"brand": "华美达" }}
                  ],
                  "must_not": [
                      { "range": { "price": { "lte": 500 } }}
                  ],
                  "filter": [
                      { "range": {"score": { "gte": 45 } }}
                  ]
              }
          },
          "functions": [ // 算分函数
            {
              "filter": { // 满足的条件，品牌必须是如家【品牌是如家的才加分，这里是加分条件】
                "term": {
                  "brand": "如家"
                }
              },
              "weight": 2 // 算分权重为2
            }
          ],
          "boost_mode": "sum" // 加权模式，求和
        }
      }  
    }
    

##### 1.5.1 相关性算分

> elasticsearch会根据词条和文档的相关度做打分，算法由两种：
> 
> *   TF-IDF算法
> *   BM25算法，elasticsearch5.1版本后采用的算法

当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（\_score），返回结果时按照分值降序排列。

例如，我们搜索 "虹桥如家"，结果如下：

    [
      {
        "_score" : 17.850193,
        "_source" : {
          "name" : "虹桥如家酒店真不错",
        }
      },
      {
        "_score" : 12.259849,
        "_source" : {
          "name" : "外滩如家酒店真不错",
        }
      },
      {
        "_score" : 11.91091,
        "_source" : {
          "name" : "迪士尼如家酒店真不错",
        }
      }
    ]
    

在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173433826-368331600.png)

在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173438720-1124832591.png)

TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173443307-150506578.png)

##### 1.5.2 算分函数查询

> 在搜索出来的结果的分数基础上，再手动与指定的数字进行一定运算来改变算分，从而改变结果的排序。

> function score query定义的三要素是什么？
> 
> *   过滤条件：哪些文档要加分
> *   算分函数：如何计算function score
> *   加权方式：function score 与 query score如何运算

根据相关度打分是比较合理的需求，但**合理的不一定是产品经理需要**的。

以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173451256-1402835153.png)

要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。

###### function score 查询

**1）语法说明**

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173456315-243388005.png)

function score 查询中包含四部分内容：

*   **原始查询**条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，**原始算分**（query score)
*   **过滤条件**：filter部分，符合该条件的文档才会重新算分
*   **算分函数**：符合filter条件的文档要根据这个函数做运算，得到的**函数算分**（function score），有四种函数
    *   weight：函数结果是常量
    *   field\_value\_factor：以文档中的某个字段值作为函数结果
    *   random\_score：以随机数作为函数结果
    *   script\_score：自定义算分函数算法
*   **运算模式**：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：
    *   multiply：相乘
    *   replace：用function score替换query score
    *   其它，例如：sum、avg、max、min

function score的运行流程如下：

*   1）根据**原始条件**查询搜索文档，并且计算相关性算分，称为**原始算分**（query score）
*   2）根据**过滤条件**，过滤文档
*   3）符合**过滤条件**的文档，基于**算分函数**运算，得到**函数算分**（function score）
*   4）将**原始算分**（query score）和**函数算分**（function score）基于**运算模式**做运算，得到最终结果，作为相关性算分。

**2）举例**

需求：给“如家”这个品牌的酒店排名靠前一些

翻译一下这个需求，转换为之前说的四个要点：

*   原始条件：不确定，可以任意变化
*   过滤条件：brand = "如家"
*   算分函数：可以简单粗暴，直接给固定的算分结果，weight
*   运算模式：比如求和

因此最终的DSL语句如下：

    GET /hotel/_search
    {
      "query": {
        "function_score": {
          "query": {  .... }, // 原始查询，可以是任意条件
          "functions": [ // 算分函数
            {
              "filter": { // 满足的条件，品牌必须是如家【品牌是如家的才加分，这里是加分条件】
                "term": {
                  "brand": "如家"
                }
              },
              "weight": 2 // 算分权重为2
            }
          ],
          "boost_mode": "sum" // 加权模式，求和
        }
      }
    }
    

测试，在未添加算分函数时，如家得分如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173504670-1488473639.png)

添加了算分函数后，如家得分就提升了：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173509427-1841421871.png)

##### 1.5.3 布尔查询

> 布尔查询是一个或多个查询子句的组合，每一个子句就是一个**子查询**。子查询的组合方式有：
> 
> *   must：必须匹配每个子查询，类似“与”
> *   should：选择性匹配子查询，类似“或”
> *   must\_not：必须不匹配，**不参与算分**，类似“非”
> *   filter：必须匹配，**不参与算分**
> 
> 注意：尽量在筛选的时候多使用不参与算分的must\_not和filter，以保证性能良好

比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173518420-1928367735.png)

每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。

需要注意的是，搜索时，参与**打分的字段越多，查询的性能也越差**。因此这种多条件查询时，建议这样做：

*   搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分
*   其它过滤条件，采用filter查询。不参与算分

###### bool查询

1）语法

    GET /hotel/_search
    {
      "query": {
        "bool": {
          "must": [
            {"term": {"city": "上海" }}
          ],
          "should": [
            {"term": {"brand": "皇冠假日" }},
            {"term": {"brand": "华美达" }}
          ],
          "must_not": [
            { "range": { "price": { "lte": 500 } }}
          ],
          "filter": [
            { "range": {"score": { "gte": 45 } }}
          ]
        }
      }
    }
    

2）示例

需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。

分析：

*   名称搜索，属于全文检索查询，应该参与算分。放到must中
*   价格不高于400，用range查询，属于过滤条件，不参与算分。放到must\_not中
*   周围10km范围内，用geo\_distance查询，属于过滤条件，不参与算分。放到filter中

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173526171-218786081.png)

### 2\. 设置搜索结果

搜索的结果可以按照用户指定的方式去处理或展示。

#### 2.0 搜索结果种类

查询的DSL是一个大的JSON对象，包含下列属性：

*   query：查询条件
*   from和size：分页条件
*   sort：排序条件
*   highlight：高亮条件
*   aggs：定义聚合

示例：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173604304-279114726.png)

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173609914-830516280.png)

#### 2.1 排序

> 在使用排序后就不会进行算分了，根据排序设置的规则排列

> 普通字段是根据字典序排序
> 
> 地理坐标是根据举例远近排序

##### 2.1.1普通字段排序

keyword、数值、日期类型排序的排序语法基本一致。

**语法**：

**排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推**  
**（可以参考下面的图片案例）**

    GET /indexName/_search
    {
      "query": {
        "match_all": {}
      },
      "sort": [
        {
          "FIELD": "desc"  // 排序字段、排序方式ASC、DESC
        }
      ]
    }
    

**示例**：

需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173616661-1802336128.png)

##### 2.1.2 地理坐标排序

地理坐标排序略有不同。

**语法说明**：

    GET /indexName/_search
    {
      "query": {
        "match_all": {}
      },
      "sort": [
        {
          "_geo_distance" : {
              "FIELD" : "纬度，经度", // 文档中geo_point类型的字段名、目标坐标点
              "order" : "asc", // 排序方式
              "unit" : "km" // 排序的距离单位
          }
        }
      ]
    }
    

这个查询的含义是：

*   指定一个坐标，作为目标点
*   计算每一个文档中，指定字段（必须是geo\_point类型）的坐标 到目标点的距离是多少
*   根据距离排序

**示例：**

需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序

提示：获取你的位置的经纬度的方式：[https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/](https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/)

假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173623518-625657913.png)

#### 2.2 分页

> **elasticsearch会禁止from+ size 超过10000的请求**

elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果：

*   from：从第几个文档开始
*   size：总共查询几个文档

类似于mysql中的`limit ?, ?`

##### 2.2.1 基本分页

分页的基本语法如下：

    GET /hotel/_search
    {
      "query": {
        "match_all": {}
      },
      "from": 0, // 分页开始的位置，默认为0
      "size": 10, // 期望获取的文档总数
      "sort": [
        {"price": "asc"}
      ]
    }
    

##### 2.2.2 深度分页

> 原理：elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条

现在，我要查询990~1000的数据，查询逻辑要这么写：

    GET /hotel/_search
    {
      "query": {
        "match_all": {}
      },
      "from": 990, // 分页开始的位置，默认为0
      "size": 10, // 期望获取的文档总数
      "sort": [
        {"price": "asc"}
      ]
    }
    

这里是查询990开始的数据，也就是 第990~第1000条 数据。

**集群情况的深度分页**

> 针对深度分页，ES提供了两种解决方案，[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html)：
> 
> *   search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。【官方推荐】
> *   scroll：原理将排序后的文档id形成快照，保存在内存。

不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173634279-892410813.png)

查询TOP1000，如果es是单点模式，这并无太大影响。

但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。

因为节点A的TOP200，在另一个节点可能排到10000名以外了。

因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173640103-2006900274.png)

那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？

当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此**elasticsearch会禁止from+ size 超过10000的请求**。

#### 2.3 高亮

> **注意：**
> 
> *   高亮是对关键字高亮，因此**搜索条件必须带有关键字**，而不能是范围这样的查询。
> *   默认情况下，**高亮的字段，必须与搜索指定的字段一致**，否则无法高亮
> *   如果要对非搜索字段高亮，则需要添加一个属性：required\_field\_match=false

使用场景：在百度等搜索后，会对结果中出现搜索字段的部分进行高亮处理。

##### 高亮原理

高亮显示的实现分为两步：

*   1）给文档中的所有关键字都添加一个标签，例如`<em>`标签
*   2）页面给`<em>`标签编写CSS样式

##### 实现高亮

1）语法

    GET /hotel/_search
    {
      "query": {
        "match": {
          "FIELD": "TEXT" // 查询条件，高亮一定要使用全文检索查询
        }
      },
      "highlight": {
        "fields": { // 指定要高亮的字段
          "FIELD": { //【要和上面的查询字段FIELD一致】
            "pre_tags": "<em>",  // 用来标记高亮字段的前置标签
            "post_tags": "</em>" // 用来标记高亮字段的后置标签
          }
        }
      }
    }
    

2）示例：组合字段all的案例

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173651044-506239214.png)

#### 2.4 数据聚合

> 类似于mysql中的【**度量（Metric）**聚合】聚合语句实现AVG，MAX，MIN；以及【**桶（Bucket）**聚合】GroupBy实现分组

**[聚合（](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html)[aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html)[）](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html)**可以让我们极其方便的实现对数据的统计、分析、运算。例如：

*   什么品牌的手机最受欢迎？
*   这些手机的平均价格、最高价格、最低价格？
*   这些手机每月的销售情况如何？

实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。

aggs代表聚合，与query同级，此时query的作用是？

*   限定聚合的的文档范围

聚合必须的三要素：

*   聚合名称
*   聚合类型
*   聚合字段

聚合可配置属性有：

*   size：指定聚合结果数量
*   order：指定聚合结果排序方式
*   field：指定聚合字段

##### 2.4.1 聚合种类

> **注意：**参加聚合的字段必须是keyword、日期、数值、布尔类型

聚合常见的有三类：

*   **桶（Bucket）**聚合：用来对文档做分组
    
    *   TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组
    *   Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组
*   **度量（Metric）**聚合：用以计算一些值，比如：最大值、最小值、平均值等
    
    *   Avg：求平均值
    *   Max：求最大值
    *   Min：求最小值
    *   Stats：同时求max、min、avg、sum等
*   **管道（pipeline）**聚合：其它聚合的结果为基础做聚合
    
    > 如：用桶聚合实现种类排序，然后使用度量聚合实现各个桶的最大值、最小值、平均值等
    

##### 2.4.2 桶(Bucket)聚合

以统计酒店品牌种类，并对其进行数据分组

    GET /hotel/_search
    {
      "query": { //限定要聚合的文档范围，只要添加query条件【一般在没搜索关键字时不写query】
        "range": {
          "price": {
            "lte": 200 // 只对200元以下的文档聚合
          }
        }
      }, 
      "size": 0,  // 设置size为0，结果中不包含查询结果文档，只包含聚合结果
      "aggs": { // 定义聚合
        "brandAgg": { //给聚合起个名字
          "terms": { // 聚合的类型，按照品牌值聚合，所以选择term
            "field": "brand", // 参与聚合的字段
            "order": {
              "doc_count": "asc" // 对聚合结果按照doc_count升序排列
            },
            "size": 20 // 希望获取的聚合结果数量【设置多少就最多只显示多少】
          }
        }
      }
    }
    

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173742270-1590923564.png)

##### 2.4.3 度量(Metric) and 管道(pipeline)聚合

> 度量聚合很少单独使用，一般是和桶聚合一并结合使用

我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。

这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。

语法如下：

这次的score\_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。

    GET /hotel/_search
    {
      "size": 0, 
      "aggs": {
        "brandAgg": { 
          "terms": { 
            "field": "brand", 
            "order": {
              "scoreAgg.avg": "desc" // 对聚合结果按照指定字段降序排列
            },
            "size": 20
          },
          "aggs": { // 是brands聚合的子聚合，也就是分组后对每组分别计算
            "score_stats": { // 聚合名称
              "stats": { // 聚合类型，这里stats可以计算min、max、avg等
                "field": "score" // 聚合字段，这里是score
              }
            }
          }
        }
      }
    }
    

另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173748393-1737546340.png)

### 3\. RestClient查询文档

文档的查询同样适用昨天学习的 RestHighLevelClient对象，基本步骤包括：

*   1）准备Request对象
*   2）准备请求参数
*   3）发起请求
*   4）解析响应

#### 3.1 快速入门

> 查询的基本步骤是：
> 
> 1.  创建SearchRequest对象
>     
> 2.  准备Request.source()，也就是DSL。
>     
>     ① QueryBuilders来构建查询条件
>     
>     ② 传入Request.source() 的 query() 方法
>     
> 3.  发送请求，得到结果
>     
> 4.  解析结果（参考JSON结果，从外到内，逐层解析）
>     

##### 3.1.1 发送查询请求

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173800773-301602834.png)

代码解读：

*   第一步，创建`SearchRequest`对象，指定索引库名
    
*   第二步，利用`request.source()`构建DSL，DSL中可以包含查询、分页、排序、高亮等
    
    *   `query()`：代表查询条件，利用`QueryBuilders.matchAllQuery()`构建一个match\_all查询的DSL
*   第三步，利用client.search()发送请求，得到响应
    

这里关键的API有两个，一个是`request.source()`，其中包含了查询、排序、分页、高亮等所有功能：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173808406-253737161.png)

另一个是`QueryBuilders`，其中包含match、term、function\_score、bool等各种查询：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173813297-2072845032.png)

##### 3.1.2 解析响应结果

响应结果的解析：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173819239-1577366921.png)

elasticsearch返回的结果是一个JSON字符串，结构包含：

*   `hits`：命中的结果
    *   `total`：总条数，其中的value是具体的总条数值
    *   `max_score`：所有结果中得分最高的文档的相关性算分
    *   `hits`：搜索结果的文档数组，其中的每个文档都是一个json对象
        *   `_source`：文档中的原始数据，也是json对象

因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：

*   `SearchHits`：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果
    *   `SearchHits#getTotalHits().value`：获取总条数信息
    *   `SearchHits#getHits()`：获取SearchHit数组，也就是文档数组
        *   `SearchHit#getSourceAsString()`：获取文档结果中的\_source，也就是原始的json文档数据

##### 3.1.3 完整代码

完整代码如下：

    @Test
    void testMatchAll() throws IOException {
        // 1.准备Request
        SearchRequest request = new SearchRequest("hotel");
        // 2.准备DSL
        request.source()
            .query(QueryBuilders.matchAllQuery());
        // 3.发送请求
        SearchResponse response = client.search(request, RequestOptions.DEFAULT);
    
        // 4.解析响应
        handleResponse(response);
    }
    
    private void handleResponse(SearchResponse response) {
        // 4.解析响应
        SearchHits searchHits = response.getHits();
        // 4.1.获取总条数
        long total = searchHits.getTotalHits().value;
        System.out.println("共搜索到" + total + "条数据");
        // 4.2.文档数组
        SearchHit[] hits = searchHits.getHits();
        // 4.3.遍历
        for (SearchHit hit : hits) {
            // 获取文档source
            String json = hit.getSourceAsString();
            // 反序列化
            HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);
            System.out.println("hotelDoc = " + hotelDoc);
        }
    }
    

#### 3.2 设置查询条件

##### 3.2.1 全文检索查询

全文检索的match和multi\_match查询与match\_all的API基本一致。差别是查询条件，也就是query的部分。

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173828395-1519960077.png)

因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173832386-1173507626.png)

而结果解析代码则完全一致，可以抽取并共享。

完整代码如下：

    @Test
    void testMatch() throws IOException {
        // 1.准备Request
        SearchRequest request = new SearchRequest("hotel");
        // 2.准备DSL
        request.source()
            .query(QueryBuilders.matchQuery("all", "如家"));
        // 3.发送请求
        SearchResponse response = client.search(request, RequestOptions.DEFAULT);
        // 4.解析响应
        handleResponse(response);
    
    }
    

##### 3.2.2 精准查询

精确查询主要是两者：

*   term：词条精确匹配
*   range：范围查询

与之前的查询相比，差异同样在查询条件，其它都一样。

查询条件构造的API如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173839234-1487715770.png)

##### 3.2.3 地理查询

DSL格式

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173843949-30830550.png)

在`cn.itcast.hotel.service.impl`的`HotelService`的`search`方法中，添加一个排序功能：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173850338-1907101734.png)

完整代码：

    @Override
    public PageResult search(RequestParams params) {
        try {
            // 1.准备Request
            SearchRequest request = new SearchRequest("hotel");
            // 2.准备DSL
            // 2.1.query
            buildBasicQuery(params, request);
    
            // 2.2.分页
            int page = params.getPage();
            int size = params.getSize();
            request.source().from((page - 1) * size).size(size);
    
            // 2.3.排序
            String location = params.getLocation();
            if (location != null && !location.equals("")) {
                request.source().sort(SortBuilders
                                      .geoDistanceSort("location", new GeoPoint(location))
                                      .order(SortOrder.ASC)
                                      .unit(DistanceUnit.KILOMETERS)
                                     );
            }
    
            // 3.发送请求
            SearchResponse response = client.search(request, RequestOptions.DEFAULT);
            // 4.解析响应
            return handleResponse(response);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    

##### 3.2.4 布尔查询

布尔查询是用must、must\_not、filter等方式组合其它查询，代码示例如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173858188-382428581.png)

可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。

完整代码如下：

    @Test
    void testBool() throws IOException {
        // 1.准备Request
        SearchRequest request = new SearchRequest("hotel");
        // 2.准备DSL
        // 2.1.准备BooleanQuery
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        // 2.2.添加term
        boolQuery.must(QueryBuilders.termQuery("city", "杭州"));
        // 2.3.添加range
        boolQuery.filter(QueryBuilders.rangeQuery("price").lte(250));
    
        request.source().query(boolQuery);
        // 3.发送请求
        SearchResponse response = client.search(request, RequestOptions.DEFAULT);
        // 4.解析响应
        handleResponse(response);
    
    }
    

##### 3.2.5 算分函数查询

> java代码逻辑：添加一个isAD字段，在算分函数的filter中判断`isAD=ture`就进行重新算分

function\_score查询结构如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173906160-2115196651.png)

对应的JavaAPI如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173910417-2019314328.png)

我们可以将之前写的boolean查询作为**原始查询**条件放到query中，接下来就是添加**过滤条件**、**算分函数**、**加权模式**了。

    // 算分控制
    FunctionScoreQueryBuilder functionScoreQuery =
        QueryBuilders.functionScoreQuery(
        // 原始查询，相关性算分的查询
        boolQuery,
        // function score的数组
        new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{
            // 其中的一个function score 元素
            new FunctionScoreQueryBuilder.FilterFunctionBuilder(
                // 过滤条件
                QueryBuilders.termQuery("isAD", true),
                // 算分函数
                ScoreFunctionBuilders.weightFactorFunction(10)
            )
        });
    //将查询请求放入查询
    request.source().query(functionScoreQuery);
    

#### 3.3 设置搜索结果

##### 3.3.1 排序和分页

> 由于这两个比较简单，所以一起写了

搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。

对应的API如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173917719-252030384.png)

完整代码示例：

    @Test
    void testPageAndSort() throws IOException {
        // 页码，每页大小
        int page = 1, size = 5;
    
        // 1.准备Request
        SearchRequest request = new SearchRequest("hotel");
        // 2.准备DSL
        // 2.1.query
        request.source().query(QueryBuilders.matchAllQuery());
        // 2.2.排序 sort
        request.source().sort("price", SortOrder.ASC);
        // 2.3.分页 from、size
        request.source().from((page - 1) * size).size(5);
        // 3.发送请求
        SearchResponse response = client.search(request, RequestOptions.DEFAULT);
        // 4.解析响应
        handleResponse(response);
    
    }
    

##### 3.3.2 高亮

高亮的代码与之前代码差异较大，有两点：

*   查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。
*   结果解析：结果除了要解析\_source文档数据，还要解析高亮结果

**1）高亮请求构建**

高亮请求的构建API如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173927424-735344633.png)

上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。

完整代码如下：

    @Test
    void testHighlight() throws IOException {
        // 1.准备Request
        SearchRequest request = new SearchRequest("hotel");
        // 2.准备DSL
        // 2.1.query
        request.source().query(QueryBuilders.matchQuery("all", "如家"));
        // 2.2.高亮
        request.source().highlighter(new HighlightBuilder().field("name").requireFieldMatch(false));
        // 3.发送请求
        SearchResponse response = client.search(request, RequestOptions.DEFAULT);
        // 4.解析响应
        handleResponse(response);
    }
    

**2）高亮结果解析**

高亮的结果与查询的文档结果默认是分离的，并不在一起。

因此解析高亮的代码需要额外处理：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173934109-1738654654.png)

代码解读：

*   第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象
*   第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值
*   第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField
*   第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了
*   第五步：用高亮的结果替换HotelDoc中的非高亮结果

完整代码如下：

    private void handleResponse(SearchResponse response) {
        // 4.解析响应
        SearchHits searchHits = response.getHits();
        // 4.1.获取总条数
        long total = searchHits.getTotalHits().value;
        System.out.println("共搜索到" + total + "条数据");
        // 4.2.文档数组
        SearchHit[] hits = searchHits.getHits();
        // 4.3.遍历
        for (SearchHit hit : hits) {
            // 获取文档source
            String json = hit.getSourceAsString();
            // 反序列化
            HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);
            // 获取高亮结果
            Map<String, HighlightField> highlightFields = hit.getHighlightFields();
            if (!CollectionUtils.isEmpty(highlightFields)) {
                // 根据字段名获取高亮结果
                HighlightField highlightField = highlightFields.get("name");
                if (highlightField != null) {
                    // 获取高亮值
                    String name = highlightField.getFragments()[0].string();
                    // 覆盖非高亮结果
                    hotelDoc.setName(name);
                }
            }
            System.out.println("hotelDoc = " + hotelDoc);
        }
    }
    

##### 3.3.3 聚合

聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。

聚合条件的语法：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173941332-769786160.png)

聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173947241-344347749.png)

举例：业务代码

    @Override
    public Map<String, List<String>> filters(RequestParams params) {
        try {
            // 1.准备Request
            SearchRequest request = new SearchRequest("hotel");
            // 2.准备DSL
            // 2.1.query查询语句
            buildBasicQuery(params, request);
            // 2.2.设置size
            request.source().size(0);
            // 2.3.聚合
            buildAggregation(request);
            // 3.发出请求
            SearchResponse response = client.search(request, RequestOptions.DEFAULT);
            // 4.解析结果
            Map<String, List<String>> result = new HashMap<>();
            Aggregations aggregations = response.getAggregations();
            // 4.1.根据品牌名称，获取品牌结果
            List<String> brandList = getAggByName(aggregations, "brandAgg");
            result.put("品牌", brandList);
            // 4.2.根据品牌名称，获取品牌结果
            List<String> cityList = getAggByName(aggregations, "cityAgg");
            result.put("城市", cityList);
            // 4.3.根据品牌名称，获取品牌结果
            List<String> starList = getAggByName(aggregations, "starAgg");
            result.put("星级", starList);
    
            return result;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    private void buildAggregation(SearchRequest request) {
        request.source().aggregation(AggregationBuilders
                                     .terms("brandAgg")
                                     .field("brand")
                                     .size(100)
                                    );
        request.source().aggregation(AggregationBuilders
                                     .terms("cityAgg")
                                     .field("city")
                                     .size(100)
                                    );
        request.source().aggregation(AggregationBuilders
                                     .terms("starAgg")
                                     .field("starName")
                                     .size(100)
                                    );
    }
    
    private List<String> getAggByName(Aggregations aggregations, String aggName) {
        // 4.1.根据聚合名称获取聚合结果
        Terms brandTerms = aggregations.get(aggName);
        // 4.2.获取buckets
        List<? extends Terms.Bucket> buckets = brandTerms.getBuckets();
        // 4.3.遍历
        List<String> brandList = new ArrayList<>();
        for (Terms.Bucket bucket : buckets) {
            // 4.4.获取key
            String key = bucket.getKeyAsString();
            brandList.add(key);
        }
        return brandList;
    }
    

自动补全
----

> ① 设置创建索引库（设置一个自动补全字段，类型为：completion）
> 
> ② 重新插入数据
> 
> ③ 查询（查询时要设置这个自动补全操作的名称，并且指定那个类型为completion的字段）
> 
> ④ 分解结果（结果也需要根据之前设置这个自动查询操作的名称来取）

当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205173955366-662214896.png)

这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。

### 1\. 拼音分词器

> 下载拼音分词器记得版本要和ES对应，不对应会报错

要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：[https://github.com/medcl/elasticsearch-analysis-pinyin](https://github.com/medcl/elasticsearch-analysis-pinyin)

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174001307-1237866057.png)

课前资料中也提供了拼音分词器的安装包：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174006161-848439820.png)

安装方式与IK分词器一样，分三步：

​ ①解压

​ ②上传到虚拟机中，elasticsearch的plugin目录

​ ③重启elasticsearch

​ ④测试

详细安装步骤可以参考IK分词器的安装过程。

### 2\. 自定义拼音分词器

> 如何使用拼音分词器？
> 
> *   ①下载pinyin分词器
>     
> *   ②解压并放到elasticsearch的plugin目录
>     
> *   ③重启即可
>     
> 
> 如何自定义分词器？
> 
> *   ①创建索引库时，在settings中配置，可以包含三部分
>     
> *   ②character filter
>     
> *   ③tokenizer
>     
> *   ④filter
>     
> 
> 拼音分词器注意事项？
> 
> *   为了避免搜索到同音字，**搜索时不要使用拼音分词器**

默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。官网文档查询地址：[https://github.com/medcl/elasticsearch-analysis-pinyin](https://github.com/medcl/elasticsearch-analysis-pinyin)

elasticsearch中分词器（analyzer）的组成包含三部分：

*   character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符
*   tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik\_smart
*   tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等

文档分词时会依次由这三部分来处理文档：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174015343-1046847662.png)

声明自定义分词器的语法如下：

    PUT /test
    {
      "settings": {
        "analysis": {
          "analyzer": { // 自定义分词器
            "my_analyzer": {  // 分词器名称
              "tokenizer": "ik_max_word",
              "filter": "py"
            }
          },
          "filter": {   // 自定义tokenizer filter
            "py": {  // 过滤器名称
              "type": "pinyin", // 过滤器类型，这里是pinyin
    		  "keep_full_pinyin": false,
              "keep_joined_full_pinyin": true,
              "keep_original": true,
              "limit_first_letter_length": 16,
              "remove_duplicated_term": true,
              "none_chinese_pinyin_tokenize": false
            }
          }
        }
      },
      "mappings": {
        "properties": {
          "name": {
            "type": "text",
            "analyzer": "my_analyzer",
            "search_analyzer": "ik_smart"
          }
        }
      }
    }
    

测试：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174024486-1094893452.png)

### 3\. 自动补全查询

> 三步骤：
> 
> ① 创建索引库
> 
> ② 插入数据
> 
> ③ 查询的DSL语句

elasticsearch提供了[Completion Suggester](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html)查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：

*   参与补全查询的字段必须是completion类型。
    
*   字段的内容一般是用来补全的多个词条形成的数组。
    

比如，一个这样的索引库：

    // 创建索引库
    PUT test
    {
      "mappings": {
        "properties": {
          "title":{
            "type": "completion"
          }
        }
      }
    }
    

然后插入下面的数据：

    // 示例数据
    POST test/_doc
    {
      "title": ["Sony", "WH-1000XM3"]
    }
    POST test/_doc
    {
      "title": ["SK-II", "PITERA"]
    }
    POST test/_doc
    {
      "title": ["Nintendo", "switch"]
    }
    

查询的DSL语句如下：

    // 自动补全查询
    GET /test/_search
    {
      "suggest": {
        "title_suggest": {	//设置这个自动查询操作的名称
          "text": "s", // 关键字
          "completion": {
            "field": "title", // 补全查询的字段名
            "skip_duplicates": true, // 跳过重复的
            "size": 10 // 获取前10条结果
          }
        }
      }
    }
    

### 4\. 自动补全嵌入项目

#### 4.1 修改索引库映射结构

> 重点注意：
> 
> ① all、name字段等要 分词设置为自定义分词器("analyzer": "text\_anlyzer")（一般要分词，然后再对分词后的词语进行拼音处理），查询设置为最精简分词器("search\_analyzer": "ik\_smart")
> 
> ② 设置一个自动补全字段(如 suggestion) 类型必须为：completion，并且使用自定义分词器（一般不分词直接对整个词语进行拼音处理）

先删除之前的索引库，再设置如下：

    // 酒店数据索引库
    PUT /hotel
    {
      "settings": {
        "analysis": {
          "analyzer": {
            "text_anlyzer": {
              "tokenizer": "ik_max_word",
              "filter": "py"
            },
            "completion_analyzer": {
              "tokenizer": "keyword",
              "filter": "py"
            }
          },
          "filter": {
            "py": {
              "type": "pinyin",
              "keep_full_pinyin": false,
              "keep_joined_full_pinyin": true,
              "keep_original": true,
              "limit_first_letter_length": 16,
              "remove_duplicated_term": true,
              "none_chinese_pinyin_tokenize": false
            }
          }
        }
      },
      "mappings": {
        "properties": {
          "id":{
            "type": "keyword"
          },
          "name":{
            "type": "text",
            "analyzer": "text_anlyzer",
            "search_analyzer": "ik_smart",
            "copy_to": "all"
          },
          "address":{
            "type": "keyword",
            "index": false
          },
          "price":{
            "type": "integer"
          },
          "score":{
            "type": "integer"
          },
          "brand":{
            "type": "keyword",
            "copy_to": "all"
          },
          "city":{
            "type": "keyword"
          },
          "starName":{
            "type": "keyword"
          },
          "business":{
            "type": "keyword",
            "copy_to": "all"
          },
          "location":{
            "type": "geo_point"
          },
          "pic":{
            "type": "keyword",
            "index": false
          },
          "all":{
            "type": "text",
            "analyzer": "text_anlyzer",
            "search_analyzer": "ik_smart"
          },
          "suggestion":{
              "type": "completion",
              "analyzer": "completion_analyzer"
          }
        }
      }
    }
    

#### 4.2 修改实体类

> 类型为completion的字段需要在改造方法里做组装

HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。

因此我们在HotelDoc中添加一个suggestion字段，类型为`List<String>`，然后将brand、city、business等信息放到里面。

代码如下：

    package cn.itcast.hotel.pojo;
    
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Collections;
    import java.util.List;
    
    @Data
    @NoArgsConstructor
    public class HotelDoc {
        private Long id;
        private String name;
        private String address;
        private Integer price;
        private Integer score;
        private String brand;
        private String city;
        private String starName;
        private String business;
        private String location;
        private String pic;
        private Object distance;
        private Boolean isAD;
        private List<String> suggestion;
    
        public HotelDoc(Hotel hotel) {
            this.id = hotel.getId();
            this.name = hotel.getName();
            this.address = hotel.getAddress();
            this.price = hotel.getPrice();
            this.score = hotel.getScore();
            this.brand = hotel.getBrand();
            this.city = hotel.getCity();
            this.starName = hotel.getStarName();
            this.business = hotel.getBusiness();
            this.location = hotel.getLatitude() + ", " + hotel.getLongitude();
            this.pic = hotel.getPic();
            // 组装suggestion
            if(this.business.contains("/")){
                // business有多个值，需要切割
                String[] arr = this.business.split("/");
                // 添加元素
                this.suggestion = new ArrayList<>();
                this.suggestion.add(this.brand);
                Collections.addAll(this.suggestion, arr);
            }else {
                this.suggestion = Arrays.asList(this.brand, this.business);
            }
        }
    }
    

#### 4.3 重新导入数据

先删除数据，再重新执行之前编写的导入数据功能，可以看到新的酒店数据中包含了suggestion：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174055585-873118927.png)

#### 4.4 自动补全的JavaAPI

示例：（这两幅图有点乱，看不懂就忽略）

**查询代码如下：**

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174142619-1304761758.png)

**解析结果代码如下：**

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174149201-911882808.png)

1）在`cn.itcast.hotel.web`包下的`HotelController`中添加新接口，接收新的请求：

    @GetMapping("suggestion")
    public List<String> getSuggestions(@RequestParam("key") String prefix) {
        return hotelService.getSuggestions(prefix);
    }
    

2）在`cn.itcast.hotel.service`包下的`IhotelService`中添加方法：

    List<String> getSuggestions(String prefix);
    

3）在`cn.itcast.hotel.service.impl.HotelService`中实现该方法：

    @Override
    public List<String> getSuggestion(String prefix) {
        try {
            // 1.准备Request
            SearchRequest request = new SearchRequest("hotel");
            // 2.准备DSL
            request.source().suggest(new SuggestBuilder().addSuggestion(
                "hotelSuggestion",  //设置这个自动补全操作的名称
                SuggestBuilders.completionSuggestion("suggestion") //类型为completion的字段名
                .prefix(prefix)
                .skipDuplicates(true)
                .size(10)
            ));
            // 3.发起请求
            SearchResponse response = client.search(request, RequestOptions.DEFAULT);
            // 4.解析结果
            Suggest suggest = response.getSuggest();
            // 4.1.根据补全查询名称，获取补全结果(这里的参数是索引库里类型为completion的字段名）
            CompletionSuggestion suggestions = suggest.getSuggestion("hotelSuggestion");  //之前设置的这个自动查询操作的名称
            // 4.2.获取options
            List<CompletionSuggestion.Entry.Option> options = suggestions.getOptions();
            // 4.3.遍历
            List<String> list = new ArrayList<>(options.size());
            for (CompletionSuggestion.Entry.Option option : options) {
                String text = option.getText().toString();
                list.add(text);
            }
            return list;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    

ES与Mysql数据同步
------------

elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的**数据同步**。

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174157480-242761835.png)

### 1\. 三种方法

常见的数据同步方案有三种：

*   同步调用
*   异步通知
*   监听binlog

方式一：同步调用

*   优点：实现简单，粗暴
*   缺点：业务耦合度高

方式二：异步通知【常用】

*   优点：低耦合，实现难度一般
*   缺点：依赖mq的可靠性

方式三：监听binlog

*   优点：完全解除服务间耦合
*   缺点：开启binlog增加数据库负担、实现复杂度高

#### 1.1.同步调用

方案一：同步调用

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174204697-1782713458.png)

基本步骤如下：

*   hotel-demo对外提供接口，用来修改elasticsearch中的数据
*   酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口，

#### 1.2.异步通知

方案二：异步通知

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174208679-699617903.png)

流程如下：

*   hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息
*   hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改

#### 1.3.监听binlog

方案三：监听binlog

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174214464-753366960.png)

流程如下：

*   给mysql开启binlog功能
*   mysql完成增、删、改操作都会记录在binlog中
*   hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容

### 2\. 实现数据同步

当数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。

步骤：

*   单机部署并启动MQ（单机部署在MQ部分有讲）
*   接收者中声明exchange、queue、RoutingKey
*   在hotel-admin发送者中的增、删、改业务中完成消息发送
*   在hotel-demo接收者中完成消息监听，并更新elasticsearch中数据
*   启动并测试数据同步功能

#### 2.0 导入依赖和yaml

对**发送者**和**消费者**都添加依赖和yaml信息

##### 1）引入依赖

    <!--amqp-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-amqp</artifactId>
    </dependency>
    

##### 2）yaml

    spring:
      rabbitmq:	#MQ配置
        host: 192.168.194.131 # 主机名
        port: 5672 # 端口
        virtual-host: / # 虚拟主机
        username: itcast # 用户名
        password: 123321 # 密码
    

#### 2.1 声明交换机、队列

MQ结构如图：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174222118-844481945.png)

##### 1）声明队列交换机名称

在hotel-admin**发送者**和hotel-demo**消费者**中的`cn.itcast.hotel.constatnts`包下新建一个类`MqConstants`：

    package cn.itcast.hotel.constatnts;
    
    public class MqConstants {
        /**
         * 交换机
         */
        public final static String HOTEL_EXCHANGE = "hotel.topic";
        /**
         * 监听新增和修改的队列
         */
        public final static String HOTEL_INSERT_QUEUE = "hotel.insert.queue";
        /**
         * 监听删除的队列
         */
        public final static String HOTEL_DELETE_QUEUE = "hotel.delete.queue";
        /**
         * 新增或修改的RoutingKey
         */
        public final static String HOTEL_INSERT_KEY = "hotel.insert";
        /**
         * 删除的RoutingKey
         */
        public final static String HOTEL_DELETE_KEY = "hotel.delete";
    }
    

##### 2）声明队列交换机

在hotel-demo**消费者**中，定义配置类，声明队列、交换机：

    package cn.itcast.hotel.config;
    
    import cn.itcast.hotel.constants.MqConstants;
    import org.springframework.amqp.core.Binding;
    import org.springframework.amqp.core.BindingBuilder;
    import org.springframework.amqp.core.Queue;
    import org.springframework.amqp.core.TopicExchange;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    @Configuration
    public class MqConfig {
        @Bean
        public TopicExchange topicExchange(){
            return new TopicExchange(MqConstants.HOTEL_EXCHANGE, true, false);
        }
    
        @Bean
        public Queue insertQueue(){
            return new Queue(MqConstants.HOTEL_INSERT_QUEUE, true);
        }
    
        @Bean
        public Queue deleteQueue(){
            return new Queue(MqConstants.HOTEL_DELETE_QUEUE, true);
        }
    
        @Bean
        public Binding insertQueueBinding(){
            return BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);
        }
    
        @Bean
        public Binding deleteQueueBinding(){
            return BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);
        }
    }
    

#### 2.2 发送MQ消息

在hotel-admin发送者中的增、删、改业务中分别发送MQ消息：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174233487-324586391.png)

#### 2.3 接收MQ消息

hotel-demo接收到MQ消息要做的事情包括：

*   新增消息：根据传递的hotel的id查询hotel信息，然后新增一条数据到索引库
*   删除消息：根据传递的hotel的id删除索引库中的一条数据

##### 1）写SDL业务

首先在hotel-demo的`cn.itcast.hotel.service`包下的`IHotelService`中新增新增、删除业务

    void deleteById(Long id);
    
    void insertById(Long id);
    

给hotel-demo中的`cn.itcast.hotel.service.impl`包下的HotelService中实现业务：

    @Override
    public void deleteById(Long id) {
        try {
            // 1.准备Request
            DeleteRequest request = new DeleteRequest("hotel", id.toString());
            // 2.发送请求
            client.delete(request, RequestOptions.DEFAULT);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    @Override
    public void insertById(Long id) {
        try {
            // 0.根据id查询酒店数据
            Hotel hotel = getById(id);
            // 转换为文档类型
            HotelDoc hotelDoc = new HotelDoc(hotel);
    
            // 1.准备Request对象
            IndexRequest request = new IndexRequest("hotel").id(hotel.getId().toString());
            // 2.准备Json文档
            request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);
            // 3.发送请求
            client.index(request, RequestOptions.DEFAULT);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    

##### 2）编写监听器

在hotel-demo中的`cn.itcast.hotel.mq`包新增一个类：

    package cn.itcast.hotel.mq;
    
    import cn.itcast.hotel.constants.MqConstants;
    import cn.itcast.hotel.service.IHotelService;
    import org.springframework.amqp.rabbit.annotation.RabbitListener;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Component;
    
    @Component
    public class HotelListener {
    
        @Autowired
        private IHotelService hotelService;
    
        /**
         * 监听酒店新增或修改的业务
         * @param id 酒店id
         */
        @RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)
        public void listenHotelInsertOrUpdate(Long id){
            hotelService.insertById(id);
        }
    
        /**
         * 监听酒店删除的业务
         * @param id 酒店id
         */
        @RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)
        public void listenHotelDelete(Long id){
            hotelService.deleteById(id);
        }
    }
    

#### 2.4 测试

用postman调用增加/删除/修改mysql数据库的接口，然后去页面搜索看看删除的数据还是否能查到，或者修改/增加的数据能不能查出来

ES集群
----

### 1\. 搭建ES集群

#### 1.1 创建ES集群

部署es集群可以直接使用docker-compose来完成，不过要求你的Linux虚拟机至少有**4G**的内存空间

首先编写一个docker-compose文件，内容如下：

    version: '2.2'
    services:
      es01:
        image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1
        container_name: es01
        environment:
          - node.name=es01
          - cluster.name=es-docker-cluster
          - discovery.seed_hosts=es02,es03
          - cluster.initial_master_nodes=es01,es02,es03
          - bootstrap.memory_lock=true
          - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
        ulimits:
          memlock:
            soft: -1
            hard: -1
        volumes:
          - data01:/usr/share/elasticsearch/data
        ports:
          - 9200:9200
        networks:
          - elastic
      es02:
        image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1
        container_name: es02
        environment:
          - node.name=es02
          - cluster.name=es-docker-cluster
          - discovery.seed_hosts=es01,es03
          - cluster.initial_master_nodes=es01,es02,es03
          - bootstrap.memory_lock=true
          - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
        ulimits:
          memlock:
            soft: -1
            hard: -1
        volumes:
          - data02:/usr/share/elasticsearch/data
        networks:
          - elastic
      es03:
        image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1
        container_name: es03
        environment:
          - node.name=es03
          - cluster.name=es-docker-cluster
          - discovery.seed_hosts=es01,es02
          - cluster.initial_master_nodes=es01,es02,es03
          - bootstrap.memory_lock=true
          - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
        ulimits:
          memlock:
            soft: -1
            hard: -1
        volumes:
          - data03:/usr/share/elasticsearch/data
        networks:
          - elastic
    
    volumes:
      data01:
        driver: local
      data02:
        driver: local
      data03:
        driver: local
    
    networks:
      elastic:
        driver: bridge
    

es运行需要修改一些linux系统权限，修改`/etc/sysctl.conf`文件

    vi /etc/sysctl.conf
    

添加下面的内容：

    vm.max_map_count=262144
    

然后执行命令，让配置生效：

    sysctl -p
    

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174247955-1940107168.png)

通过docker-compose启动集群：

    docker-compose up -d
    

#### 1.2 集群状态监控

kibana可以监控es集群，不过新版本需要依赖es的x-pack 功能，配置比较复杂。

这里推荐使用cerebro来监控es集群状态，官方网址：[https://github.com/lmenezes/cerebro](https://github.com/lmenezes/cerebro)

课前资料已经提供了安装包：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174253608-697990984.png)

解压即可使用，非常方便。

解压好的目录如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174258478-68607455.png)

进入对应的bin目录：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174303403-1904751938.png)

双击其中的cerebro.bat文件即可启动服务。

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174308478-812530281.png)

访问http://localhost:9000 即可进入管理界面：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174337983-1157412120.png)

输入你的elasticsearch的任意节点的地址和端口，点击connect即可：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174403049-1249651006.png)

绿色的条，代表集群处于绿色（健康状态）。

#### 1.3创建索引库

> 创建索引库的时候需要设置分片数量（其他还有多少个ES服务在该集群）以及副本数量（本服务的数据拷贝几份）

##### 方法一：利用kibana的DevTools创建索引库

> 如果没有启动ES的可视化界面Kibana，那就用方法二

在DevTools中输入指令：

    PUT /itcast
    {
      "settings": {
        "number_of_shards": 3, // 分片数量
        "number_of_replicas": 1 // 副本数量
      },
      "mappings": {
        "properties": {
          // mapping映射定义 ...
        }
      }
    }
    

##### 方法二：利用cerebro创建索引库

利用cerebro还可以创建索引库：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174414485-1108138446.png)

填写索引库信息：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174418914-393171047.png)

点击右下角的create按钮：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174423389-1597328756.png)

##### 查看分片效果

回到首页，即可查看索引库分片效果：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174428188-794591883.png)

### 2.集群脑裂问题

> master eligible节点的作用是什么？
> 
> *   参与集群选主
> *   主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求
> 
> data节点的作用是什么？
> 
> *   数据的CRUD
> 
> coordinator节点的作用是什么？
> 
> *   路由请求到其它节点
>     
> *   合并查询到的结果，返回给用户
>     

#### 2.1.集群职责划分

> 通过改变配置文件中的 true——> false 来改变职责。如data数据职责节点就只保留data为true其他为false
> 
> 注意：每个节点都是路由，这样可以保证不管哪个节点接收到请求可以分给其他人已经从其他人那接收信息。

elasticsearch中集群节点有不同的职责划分：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174437248-89466588.png)

默认情况下，集群中的任何一个节点都同时具备上述四种角色。

但是真实的集群一定要将集群职责分离：（因为不同职责对CPU要求不同）

*   master节点：对CPU要求高，但是内存要求低
*   data节点：对CPU和内存要求都高
*   coordinating节点：对网络带宽、CPU要求高

职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。

一个典型的es集群职责划分如图：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174442439-1069765383.png)

#### 2.2.脑裂问题

> ES 7.0后默认配置了**( eligible节点数量 + 1 ）/ 2**来解决脑裂问题

脑裂是因为集群中的节点失联导致的。

例如一个集群中，主节点与其它节点失联：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174447612-1377452674.png)

此时，node2和node3认为node1宕机，就会重新选主：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174453080-1677763578.png)

当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。

当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174457820-447955706.png)

解决脑裂的方案是，要求选票超过 **( eligible节点数量 + 1 ）/ 2** 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum\_master\_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题

例如：3个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。

### 3.集群分布式存储

当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？

#### 3.1.分片存储测试

插入三条数据：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174505286-1396675284.png)

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174521870-302254487.png)

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174526716-644567480.png)

测试可以看到，三条数据分别在不同分片：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174534715-323138622.png)

结果：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174540673-592662626.png)

#### 3.2.分片存储原理

elasticsearch会通过hash算法来计算文档应该存储到哪个分片：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174546782-1705505226.png)

说明：

*   \_routing默认是文档的id
*   算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！

新增文档的流程如下：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174551794-1811444061.png)

解读：

*   1）新增一个id=1的文档
*   2）对id做hash运算，假如得到的是2，则应该存储到shard-2
*   3）shard-2的主分片在node3节点，将数据路由到node3
*   4）保存文档
*   5）同步给shard-2的副本replica-2，在node2节点
*   6）返回结果给coordinating-node节点

### 4\. 集群分布式查询

**原理：**

elasticsearch的查询分成两个阶段：

*   scatter phase：分散阶段，coordinating node会把请求分发到每一个分片
    
*   gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户
    

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174557427-1969761296.png)

### 5.集群故障转移

> ES本身已经配置好了有集群故障转移，不需要我们再去配置

集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。

1）例如一个集群结构如图：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174602086-492617752.png)

现在，node1是主节点，其它两个节点是从节点。

2）突然，node1发生了故障：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174607756-480992428.png)

宕机后的第一件事，需要重新选主，例如选中了node2：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174612261-197593780.png)

node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：

![image](https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205174617803-1364879576.png)