---
layout: post
title: "树状数组总结"
date: "2022-10-19T11:21:21.106Z"
---
树状数组总结
======

树状数组总结 （一）树状数组基础 （二）树状数组拓展

树状数组
====

（一）树状数组基础
---------

### 一、二进制拆分

我们知道，对于任意的非负整数 \\(n\\) ，可表示为：

\\\[n=2^{i\_1}+2^{i\_2}+\\cdots+2^{i\_m} \\\]

不妨设 \\(i\_1>i\_2>\\cdots >i\_m\\) ，进一步地，区间 \\(\[1,x\]\\) 可以分成 \\(O(log\_2x)\\) 个小区间：

1.  长度为 \\(2^{i\_1}\\) 的小区间 \\(\[1,2^{i\_1}\]\\)
    
2.  长度为 \\(2^{i\_2}\\) 的小区间 \\(\[2^{i\_1}+1,2^{i\_1}+2^{i\_2}\]\\)
    
3.  长度为 \\(2^{i\_3}\\) 的小区间 \\(\[2^{i\_1}+2^{i\_2}+1,2^{i\_1}+2^{i\_2}+2^{i\_3}\]\\)
    
    \\(\\cdots \\cdots\\)
    

m. $\\quad $ 长度为 \\(2^{i\_m}\\) 的小区间 \\(\[2^{i\_1}+2^{i\_2}+\\cdots +2^{i\_{m-1}}+1,2^{i\_1}+2^{i\_2}+2^{i\_3}+\\cdots +2^{i\_m}\]\\)

一个不难发现的规律是，若区间设为 \\(\[L,R\]\\) ，

那么区间长度等于 \\(R\\) 的 “二进制拆分” 结果的 \\(2^{i\_1}\\)，即 \\(lowbit( R )\\)。

如区间 \\(\[1,7\]\\) 可分成 \\(\[1,4\]\\) , \\(\[5,6\]\\) 和 \\(\[7,7\]\\) 三个小区间，

长度分别为 \\(lowbit(4)=4\\) ， \\(lowbit(6)=2\\) 和 \\(lowbit(7)=1\\) 。

### 二、树状数组

树状数组就是一种基于 “二进制拆分” 思想的数据结构，我们建立一个数组 \\(c\\) ，

其中 \\(c\_i\\) 保存要维护的原数组 \\(a\\) 的区间$ \[x−lowbit(x)+1,x\]$ 中所有数的和，

即 \\(\\displaystyle\\sum ^x \_{j=x−lowbit(x)+1}A\[i\]\\) 。

事实上，数组 \\(c\\) 可以看做如下图的一个树形结构，

最下面一行为 \\(N\\) 个叶节点，代表数值 \\(a\[i\\sim n\]\\) 。

![](https://pic1.imgdb.cn/item/634fd91a16f2c2beb1890f5a.png)

#### 性质：

1.  每个内部节点 \\(c\[x\]\\) 保存以它为根的子树中所有叶节点的和；
2.  每个内部节点 \\(c\[x\]\\) 的子节点个数等于 \\(lowbit(x)\\) 的位数；
3.  除树根外，每个内部节点 \\(c\[i\]\\) 的父节点是 \\(c\[x+lowbit(x)\]\\)；
4.  树的深度为 \\(O(log N)\\) 。

#### 查询前缀和 \\(O(logN)\\) ：

    int Find(int x)
    {
    	int ans=0;
    	while(x)
    	{
    		ans+=c[x];
    		x-=lowbit(x);
    	}
    	return ans;
    }
    

#### 单点增加 \\(O(logN)\\) ：

    void add(int x,int y)
    {
    	while(x<=n)
    	{
    		c[x]+=y;
    		x+=lowbit(x);
    	}
    }
    

#### 初始化：

##### 1\. 简便写法 \\(O(NlogN)\\)

    memset(c,0,sizeof(c));
    for(int i=1;i<=n;i++)
        add(i,a[i]);
    

##### 2\. 高效写法 \\(O(N)\\)

从小大依次考虑每个节点 \\(x\\) ，借助 \\(lowbit\\) 运算扫描它的子叶子并求和，**树形结构中的每条边只会被遍历一次**。

    for(int i=1;i<=n;i++)
    	s[i]=s[i-1]+a[i];
    for(int i=1;i<=n;i++)
    	c[i]=s[i]-s[i-lowbit(i)];
    

时间复杂度为：

\\\[O(\\sum^{\\log N}\_{k=1}k\\times \\frac N {2^k})=O(N) \\\]

#### _Example:_ 单点修改，区间查询

> 输入一个数列 \\(a\_1, a\_2, \\cdots , a\_n (1 \\leq n \\leq 100000)\\)，
> 
> 在数列上进行 \\(m(1 \\leq m \\leq 100000)\\) 次操作，操作有以下两种：
> 
> 1.  格式为 \\(C \\ I \\ X\\)，其中 \\(C\\) 为字符 "\\(C\\) "，\\(I\\) 和 \\(X(1 \\leq I \\leq n, |X| \\leq 10000)\\) 都是整数，表示把把 \\(a\[I\]\\) 改为 \\(X\\)
>     
> 2.  格式为 \\(Q \\ L \\ R\\)，其中 \\(Q\\) 为字符 "\\(Q\\) "，\\(L\\) 和 \\(R\\) 表示询问区间为 \\(\[L,R\] (1 \\leq L \\leq R \\leq n)\\)，表示询问 \\(A\[L\]+ \\cdots +A\[R\]\\) 的值。
>     

    for(int i=1;i<=n;i++)
    {
        int a;
        scanf("%d",&a);
        add(i,a);
    }
    for(int i=1;i<=m;i++)
    {
        char s;
        int b,d;
        scanf("\n%c %d%d",&s,&b,&d);
        if(s=='C') add(b,d-(Find(b)-Find(b-1)));
        else printf("%d\n",Find(d)-Find(b-1));
    }
    

（二）树状数组拓展
---------

### 一、树状数组与逆序对

任意给定一个集合 \\(a\\)，如果用 \\(t\[val\]\\) 存储 \\(val\\) 在集合 \\(a\\) 中出现的次数，

那么数组 \\(t\\) 在 \\(\[l,r\]\\) 上的区间和（即 \\(\\sum ^r \_{i=l} t\[i\]\\)）就表示集合 \\(a\\) 在 \\(\[l,r\]\\) 中的数有多少个。

因此，我们可以在集合 \\(a\\) 的**数值范围上**建立一个树状数组，维护 \\(t\\) 的前缀和。

这样就可以高效地统计在集合 \\(a\\) 中插入或删除一个数。

#### _Example1:_ [逆序对统计](https://www.luogu.com.cn/problem/P1908) Luogu P1908

> 给定一个整数序列 \\(a\_1,a\_2,\\cdots ,a\_n\\)，如果存在 \\(i< j\\) 并且 \\(a\_i>a\_j\\) ，那么我们称之为逆序对。
> 
> 求逆序对的数目。

利用上述思路，我们可以利用树状数组求出逆序对个数，解法如下：

1.  在序列 \\(a\\) 的**数值范围上**建立树状数组 \\(t\\)，初值为 \\(0\\)。
    
2.  倒序扫描序列 \\(a\\)，对于每个数 \\(a\[i\]\\)：
    
    (1) 在 \\(t\\) 中查询 \\(1 \\sim a\[i\]-1\\) 的前缀和，累加到 \\(ans\\) 中；
    
    (2) 把位置为 \\(a\[i\]\\) 的数加 \\(1\\)（即 \\(t\[a\[i\]\]+1\\)），表示数值 \\(a\[i\]\\) 又出现了一次。
    
3.  \\(ans\\) 即为所求。
    

    for(int i=n;i>=1;i--)
    {
        ans+=ask(a[i]-1);
        add(a[i],1);
    }
    printf("%lld\n",ans);
    

_**Tips:**_

因为倒序扫描，“已经出现过的数” 就是在 \\(a\[i\]\\) 后面的数。

这个数 \\(x \\in \[i,a\[i\]-1\]\\)（即比 \\(a\[i\]\\) 小），又在 \\(a\[i\]\\) 后面，满足逆序对定义。

#### _Example2:_ [楼兰图腾](https://www.acwing.com/problem/content/243/) AcWing241

> 平面上有 $N(N \\leq 10^5 ) $个点，每个点的横、纵坐标的范围都是 \\(1 \\sim N\\)，任意两个点的横、纵坐标都不相同。
> 
> 若三个点 \\((x1,y1),(x2,y2),(x3,y3)\\) 满足 \\(x1< x2< x3,y1> y2\\) 并且 \\(y3> y2\\)，则称这三个点构成 "\\(V\\)" 字图腾。
> 
> 若三个点 \\((x1,y1),(x2,y2),(x3,y3)\\) 满足 \\(x1< x2< x3,y1< y2\\) 并且 \\(y3< y2\\)，则称这三个点构成 "\\(A\\)" 字图腾。
> 
> 求平面上 "\\(V\\)" 和 "\\(A\\)" 字图腾的个数。

1.  将 \\(n\\) 个点排序，记序列为 \\(a\\)。
2.  倒序扫描 \\(a\\)，求 \\(a\[i\]\\) 后面有几个数比它大，记为 \\(ans1\[i\]\\)；
3.  正序扫描 \\(a\\)，求 \\(a\[i\]\\) 前面有几个数比它大，记为 \\(ans2\[i\]\\)；
4.  以 \\(i\\) 为中心的 “\\(V\\)” 字图腾的个数为 \\(ans1\[i\] \\times ans2\[i\]\\)，“\\(V\\)” 字图腾的总数则为：

\\\[sum1 = \\sum ^N \_{i=1} ans1\[i\] \\times ans2\[i\] \\\]

同理，可以统计出 “\\(A\\)” 字图腾的总数。

    for(int i=n;i>=1;i--)
    {
        ans3[i]=ask(a[i]-1);
        ans1[i]=ask(n)-ask(a[i]);
        add(a[i],1);
    }
    memset(c,0,sizeof(c));	
    for(int i=1;i<=n;i++)
    {
        ans4[i]=ask(a[i]-1);
        ans2[i]=ask(n)-ask(a[i]);
        add(a[i],1);
    }
    for(int i=1;i<=n;i++)
    {
        sum1+=ans1[i]*ans2[i];
        sum2+=ans3[i]*ans4[i];
    }
    printf("%lld %lld\n",sum2,sum1);
    

### 二、树状数组拓展

#### 1\. 区间修改和单点查询

*   **区间修改**

利用前缀和思想，对区间 \\(\[l, r\]\\) 中的每一个值增加 \\(k\\)

可以使 \\(a\[l\]+k, a\[r+1\]-k\\)，就可以达到区间修改的效果了

    int l,r,k;
    scanf("%d%d%d",&l,&r,&k);
    add(l,k);
    add(r+1,-k);
    

*   **单点查询**

利用前缀和思想，求出前 \\(x\\) 个数的前缀和

再加上第 \\(x\\) 个数的值 \\(a\[x\]\\)，就可以达到单点查询的效果了

    int x;
    scanf("%d",&x);
    printf("%lld\n",ask(x)+a[x]);
    

##### _Example:_ [区间修改单点查询](https://www.luogu.com.cn/problem/P3368) Luogu P3368

> 如题，已知一个数列，你需要进行下面两种操作：
> 
> 1.  将某区间每一个数加上 \\(x\\)；
> 2.  求出某一个数的值。

    for(int i=1;i<=m;i++)
    {
        int a1,x,y,k;
        scanf("%d",&a1);
        if(a1==1) 
        {
            scanf("%d%d%d",&x,&y,&k);
            add(x,k);
            add(y+1,-k);
        }
        else
        {
            scanf("%d",&x);
            printf("%lld\n",ask(x)+a[x]);
        }
    }
    

#### 2\. 区间修改和区间查询

我们已知单点查询求出前 \\(x\\) 个数的前缀和

那么对于区间查询，统计数每个数的前缀和即可，我们假设前缀和数组为 \\(b\\)

序列 \\(a\\) 的前缀和 \\(a\[1 \\sim x\]\\) 整体增加就是：\\(\\displaystyle \\sum \_{i=1} ^x \\sum \_{j=1} ^i b\[j\]\\)

上式可以改写为：

\\\[\\sum \_{i=1} ^x \\sum \_{j=1} ^i b\[j\] = \\sum \_{i=1} ^x (x-i+1) \\times b\[i\] = (x+1) \\sum \_{i=1} ^x b\[i\] - \\sum \_{i=1} ^x i\\times b\[i\] \\\]

因此，我们可以建立两个树状数组 \\(c\_0\\) 和 \\(c\_1\\)

\\(c\_0\\) 用来维护 \\(b\[i\]\\) 的前缀和，\\(c\_1\\) 用来维护 \\(i \\times b\[i\]\\) 的前缀和。

    void add(int k,int x,int y)
    {
    	while(x<=n)
    	{
    		c[k][x]+=y;
    		x+=lowbit(x);
    	}
    }
    

    LL ask(int k,int x)
    {
    	LL ans=0;
    	while(x>0)
    	{
    		ans+=c[k][x];
    		x-=lowbit(x);
    	}
    	return ans;
    }
    

*   **区间修改**

利用前缀和思想，进行如下操作：

1.  在树状数组 \\(c\_0\\) 中，把位置 \\(x\\) 上的数加 \\(k\\)
2.  在树状数组 \\(c\_0\\) 中，把位置 \\(y+1\\) 上的数减 \\(k\\)
3.  在树状数组 \\(c\_1\\) 中，把位置 \\(x\\) 上的数加 \\(x \\times k\\)
4.  在树状数组 \\(c\_1\\) 中，把位置 \\(y+1\\) 上的数减 \\((y+1) \\times k\\)

    int x,y,k;
    scanf("%d%d%d",&x,&y,&k);
    add(0,x,k);
    add(0,y+1,-k);
    add(1,x,x*k);
    add(1,y+1,-(y+1)*k);
    

*   **区间查询**

利用前缀和思想，我们可以将答案拆分成 \\(1 \\sim x-1\\) 和 \\(1 \\sim y\\) 两个部分

两者相减，即为区间和，式子如下：

\\\[(sum\[y\]+(y+1)\*ask(0,y)-ask(1,y)) - (sum\[x-1\]+x\*ask(0,x-1)-ask(1,x-1)) \\\]

    LL ans1,ans2;
    ans1=sum[x-1]+x*ask(0,x-1)-ask(1,x-1);
    ans2=sum[y]+(y+1)*ask(0,y)-ask(1,y);
    printf("%lld\n",ans2-ans1);
    

##### _Example 1:_ [A Simple Problem with Integers](https://www.acwing.com/problem/content/244/) AcWing243 一个简单的整数问题2

> 给定一个长度为 \\(N\\) 的数列 \\(A\\)，以及 \\(M\\) 条指令，每条指令可能是以下两种之一：
> 
> 1.  `C l r d`，表示把 \\(A\[l\],A\[l+1\],…,A\[r\]\\) 都加上 \\(d\\)。
> 2.  `Q l r`，表示询问数列中第 \\(l \\sim r\\) 个数的和。
> 
> 对于每个询问，输出一个整数表示答案。

    for(int i=1;i<=n;i++)
        sum[i]=sum[i-1]+a[i];
    for(int i=1;i<=q;i++)
    {
        char a1;
        int x,y,k;
        scanf("\n%c %d%d",&a1,&x,&y);
        if(a1=='C')
        {
            scanf("%d",&k);
            add(0,x,k);
            add(0,y+1,-k);
            add(1,x,x*k);
            add(1,y+1,-(y+1)*k);
        }
        else
        {
            LL ans1,ans2;
            ans1=sum[x-1]+x*ask(0,x-1)-ask(1,x-1);
            ans2=sum[y]+(y+1)*ask(0,y)-ask(1,y);
            printf("%lld\n",ans2-ans1);
        }
    }
    

##### _Example 2:_ [Lost Cows](https://www.acwing.com/problem/content/245/) AcWing244 谜一样的牛

##### _Exercise:_ [\[SHOI2007\]园丁的烦恼](https://www.luogu.com.cn/problem/P2163) Luogu P2163