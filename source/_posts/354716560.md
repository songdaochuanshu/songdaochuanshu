---
layout: post
title: "【面试普通人VS高手系列】死锁的发生原因和怎么避免"
date: "2022-04-26T11:16:49.765Z"
---
【面试普通人VS高手系列】死锁的发生原因和怎么避免
=========================

> 一个去阿里面试的小伙伴私信我说：今天被一个死锁的问题难到了。
> 
> 平常我都特意看了死锁这块的内容，但是回答的时候就想不起来。
> 
> 这里可能存在一个误区，认为技术是要靠记的。
> 
> 大家可以想想，平时写代码的时候，这些代码是背下来的吗？
> 
> 遇到一个需求的时候，能够立刻提供解决思路，这个也是记下来的吗？
> 
> 所有的技术问题，都可以用一个问题来解决： “如果让你遇到这个问题，你会怎么设计”
> 
> 当你大脑一篇空白时，说明你目前掌握的技术只能足够支撑你写CURD的能力。
> 
> 好了，下面来看看普通人和高手是如何回答这个问题的。

普通人：
----

嗯......…

高手：
---

死锁，简单来说就是两个或者两个以上的线程在执行的过程中，争夺同一个共享资源造成的相互等待的现象。

![image-20210612222402287](https://mic-blob-bucket.oss-cn-beijing.aliyuncs.com/image-20210612222402287.png)

如果没有外部干预，线程会一直阻塞无法往下执行，这些一直处于相互等待资源的线程就称为死锁线程。

导致死锁的条件有四个，也就是这四个条件同时满足就会产生死锁。

*   互斥条件，共享资源 X 和 Y 只能被一个线程占用；
*   请求和保持条件，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
*   不可抢占条件，其他线程不能强行抢占线程 T1 占有的资源；
*   循环等待条件，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

导致死锁之后，只能通过人工干预来解决，比如重启服务，或者杀掉某个线程。

所以，只能在写代码的时候，去规避可能出现的死锁问题。

按照死锁发生的四个条件，只需要破坏其中的任何一个，就可以解决，但是，互斥条件是没办法破坏的，因为这是互斥锁的基本约束，其他三方条件都有办法来破坏：

*   对于“请求和保持”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。
*   对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。
*   对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。

以上就是我对这个问题的理解。

总结
--

发现了吗？ 当大家理解了死锁发生的条件，那么对于这些条件的破坏，

是可以通过自己的技术积累，来设计解决方法的。

所有的技术思想和技术架构，都是由人来设计的，为什么别人能够设计？

本质上，还是技术积累后的结果！越是底层的设计，对于知识面的要求就越多。

好的，本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞收藏。

![file](http://mic-blob-bucket.oss-cn-beijing.aliyuncs.com/27872_6E991DCA37954E839F0FFEF36066304F)

> 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 `Mic带你学架构`！  
> 如果本篇文章对您有帮助，还请帮忙点个关注和赞，您的坚持是我不断创作的动力。欢迎关注「跟着Mic学架构」公众号公众号获取更多技术干货！

![](https://img2022.cnblogs.com/other/1666682/202204/1666682-20220426152546725-1442052970.png)