---
layout: post
title: "【面试普通人VS高手系列】lock和synchronized区别"
date: "2022-04-14T05:17:23.892Z"
---
【面试普通人VS高手系列】lock和synchronized区别
================================

> 一个小伙伴私信了一个小米的面试题，问题是： “线程池如何知道一个线程的任务已经执行完成”？
> 
> 说实话，这个问题确实很刁钻，毕竟像很多工作5年多的小伙伴，连线程池都没用过，怎么可能回答出来这个问题呢？
> 
> 下面我们来看看普通人和高手遇到这个问题的回答思路。

普通人：
====

嗯..

高手：
===

好的，我会从两个方面来回答。

1.  在线程池内部，当我们把一个任务丢给线程池去执行，线程池会调度工作线程来执行这个任务的run方法，run方法正常结束，也就意味着任务完成了。
    
    所以线程池中的工作线程是通过同步调用任务的`run()`方法并且等待`run`方法返回后，再去统计任务的完成数量。
    
2.  如果想在线程池外部去获得线程池内部任务的执行状态，有几种方法可以实现。
    
    1.  线程池提供了一个`isTerminated()`方法，可以判断线程池的运行状态，我们可以循环判断`isTerminated()`方法的返回结果来了解线程池的运行状态，一旦线程池的运行状态是`Terminated`，意味着线程池中的所有任务都已经执行完了。想要通过这个方法获取状态的前提是，程序中主动调用了线程池的`shutdown()`方法。在实际业务中，一般不会主动去关闭线程池，因此这个方法在实用性和灵活性方面都不是很好。
        
    2.  在线程池中，有一个`submit()`方法，它提供了一个Future的返回值，我们通过`Future.get()`方法来获得任务的执行结果，当线程池中的任务没执行完之前，`future.get()`方法会一直阻塞，直到任务执行结束。因此，只要`future.get()`方法正常返回，也就意味着传入到线程池中的任务已经执行完成了！
        
    3.  可以引入一个CountDownLatch计数器，它可以通过初始化指定一个计数器进行倒计时，其中有两个方法分别是`await()`阻塞线程，以及`countDown()`进行倒计时，一旦倒计时归零，所以被阻塞在`await()`方法的线程都会被释放。
        
        基于这样的原理，我们可以定义一个CountDownLatch对象并且计数器为1，接着在线程池代码块后面调用`await()`方法阻塞主线程，然后，当传入到线程池中的任务执行完成后，调用`countDown()`方法表示任务执行结束。
        
        最后，计数器归零0，唤醒阻塞在`await()`方法的线程。
        

![img](https://img-blog.csdnimg.cn/img_convert/63897e30c053cdab4116f0ada08eaaf6.png)

![点击并拖拽以移动](https://img2022.cnblogs.com/blog/1666682/202204/1666682-20220414120235342-77275194.gif)

基于这个问题，我简单总结一下，不管是线程池内部还是外部，要想知道线程是否执行结束，我们必须要获取线程执行结束后的状态，而线程本身没有返回值，所以只能通过阻塞-唤醒的方式来实现，future.get和CountDownLatch都是这样一个原理。

以上就是我对于这个问题的回答！

总结
==

大家可以站在面试官的角度来看高手的回答，

不难发现，高手对于技术基础的掌握程度，是非常深和全面的。这也是面试官考察这类问题的目的。

因此，Mic提醒大家，除了日常的CRUD以外，抽出部分时间去做技术深度和广度的学习是非常有必要的。

好的，本期的普通人VS高手面试系列就到这里结束了，喜欢的朋友记得点赞收藏。

我是Mic，一个工作了14年的Java程序员，咱们下篇文章再见。  
![img](https://oscimg.oschina.net/oscnet/up-9f4cbb5b2ef3bf80a133f4e2b831cabd5a8.jpg)