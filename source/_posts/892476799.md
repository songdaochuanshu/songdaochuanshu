---
layout: post
title: "【面试普通人VS高手系列】lock和synchronized区别"
date: "2022-04-13T07:18:09.154Z"
---
【面试普通人VS高手系列】lock和synchronized区别
================================

> 今天来分享一道阿里一面的面试题，“lock和synchronized的区别”。
> 
> 对于这个问题，看看普通人和高手的回答！

普通人：
====

嗯，lock是J.U.C包里面提供的锁，synchronized是Java中的同步关键字。

他们都可以实现多线程对共享资源访问的线程安全性。

高手：
===

下面我从4个方面来回答

1.  从功能角度来看，Lock和Synchronized都是Java中用来解决线程安全问题的工具。
    
2.  从特性来看
    
    1.  Synchronized是Java中的同步关键字，Lock是J.U.C包中提供的接口，这个接口有很多实现类，其中就包括ReentrantLock重入锁
        
    2.  Synchronized可以通过两种方式来控制锁的粒度
        
        ![img](https://img-blog.csdnimg.cn/img_convert/6e65786ecbcf54f86d22056c1f3359fa.png)
        
        ![点击并拖拽以移动](https://img2022.cnblogs.com/blog/1666682/202204/1666682-20220413140851508-1562579880.gif)
        
        一种是把synchronized关键字修饰在方法层面
        
        另一种是修饰在代码块上，并且我们可以通过Synchronized加锁对象的声明周期来控制锁的作用范围，比如锁对象是静态对象或者类对象，那么这个锁就是全局锁。
        
        如果锁对象是普通实例对象，那这个锁的范围取决于这个实例的声明周期。
        
        Lock锁的粒度是通过它里面提供的`lock()`和`unlock()`方法决定的
        
        ![img](https://img-blog.csdnimg.cn/img_convert/b3387bcf285327187626dede7419010a.png)
        
        ![点击并拖拽以移动](https://img2022.cnblogs.com/blog/1666682/202204/1666682-20220413140851508-1562579880.gif)
        
        包裹在这两个方法之间的代码能够保证线程安全性。而锁的作用域取决于Lock实例的生命周期。
        
    3.  Lock比Synchronized的灵活性更高，Lock可以自主决定什么时候加锁，什么时候释放锁，只需要调用`lock()`和`unlock()`这两个方法就行，同时Lock还提供了非阻塞的竞争锁方法`tryLock()`方法，这个方法通过返回true/false来告诉当前线程是否已经有其他线程正在使用锁。
        
        Synchronized由于是关键字，所以它无法实现非阻塞竞争锁的方法，另外，Synchronized锁的释放是被动的，就是当Synchronized同步代码块执行完以后或者代码出现异常时才会释放。
        
    4.  Lock提供了公平锁和非公平锁的机制，公平锁是指线程竞争锁资源时，如果已经有其他线程正在排队等待锁释放，那么当前竞争锁资源的线程无法插队。而非公平锁，就是不管是否有线程在排队等待锁，它都会尝试去竞争一次锁。 Synchronized只提供了一种非公平锁的实现。
        
3.  从性能方面来看，Synchronized和Lock在性能方面相差不大，在实现上会有一些区别，Synchronized引入了偏向锁、轻量级锁、重量级锁以及锁升级的方式来优化加锁的性能，而Lock中则用到了自旋锁的方式来实现性能优化。
    

以上就是我对于这个问题的理解。

总结
==

这个问题主要是考察求职责对并发基础能力的掌握。

在实际应用中，线程以及线程安全性是非常重要和常见的功能，对于这部分内容如果理解不够深刻，很容易造成生产级别的故障。

如果在面试过程中遇到了比较刁钻和奇葩的问题，欢迎私信或评论区给我留言！

我是Mic，一个工作了14年的Java程序员，咱们下篇文章再见。