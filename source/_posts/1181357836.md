---
layout: post
title: "访问者模式的结构"
date: "2022-05-04T09:20:12.133Z"
---
访问者模式的结构
========

1.访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。

2.数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。这样的过程叫做“双重分派”。节点调用访问者，将它自己传入，访问者则将某算法针对此节点执行。

访问者模式涉及到的角色如下：

　　●　　**抽象访问者(Visitor)角色：**声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。(抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是 visit 方法的参数定义哪些对象是可以被访问的)

　　![](https://img2022.cnblogs.com/blog/2620476/202205/2620476-20220504170220871-1183496341.png)

　　●　　**具体访问者(ConcreteVisitor)角色：**实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。(它影响访问者访问到一个类后该怎么干，要做什么事情。 )

![](https://img2022.cnblogs.com/blog/2620476/202205/2620476-20220504170233549-979284075.png)

　　●　　**抽象节点(Node)角色：**声明一个接受操作，接受一个访问者对象作为一个参数。(接口或者抽象类，声明接受哪一类访问者访问，程序上是通过 accept 方法中的参数来定义的)

![](https://img2022.cnblogs.com/blog/2620476/202205/2620476-20220504170247874-1745681902.png)

　　●　　**具体节点(ConcreteNode)角色：**实现了抽象节点所规定的接受操作。(实现 accept 方法，通常是 visitor.visit(this)，基本上都形成了一种模式了)

![](https://img2022.cnblogs.com/blog/2620476/202205/2620476-20220504170316173-1193024547.png)

![](https://img2022.cnblogs.com/blog/2620476/202205/2620476-20220504170324037-900926329.png)

　　●　　**结构对象(ObjectStructure)角色：**有如下的责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。(元素产生者，一般容纳在多个不同类、不同接口的容器，如 List、Set、Map 等，在项目中，一般很少抽象出这个角色。)

　　![](https://img2022.cnblogs.com/blog/2620476/202205/2620476-20220504170403285-1985629909.png)

3.使用场景：

● 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些

依赖于其具体类的操作，也就说是用迭代器模式已经不能胜任的情景。

● 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这

些操作“污染”这些对象的类

![](https://img2022.cnblogs.com/blog/2620476/202205/2620476-20220504170540299-785050014.png)

访问者模式的优点
========

　　●　　**好的扩展性**

　　能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。

　　●　　**好的复用性**

　　可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。

　　●　　**分离无关行为**

　　可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。

访问者模式的缺点
========

　　●　　**对象结构变化很困难**

　　不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。

　　●　　**破坏封装**

　　访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue，这破坏了对象的封装性。