---
layout: post
title: "Improved Security for a Ring-Based Fully Homomorphic Encryption Scheme-2013：解读"
date: "2022-06-14T08:24:21.431Z"
---
Improved Security for a Ring-Based Fully Homomorphic Encryption Scheme-2013：解读
==============================================================================

> 本文记录阅读此论文的笔记

摘要
--

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220605145436729-1797089712.png)

（1）1996年，HPS三人提出一个格上的高效加密方案，叫做**NTRUEncrypt**，但是没有安全性证明；之后2011年，SS等人修改此方案，将其安全规约到标准格上的困难问题；2012年，LTV等人基于修改的方案，提出一个FHE方案。

（2）non-standard assumption：非标准假设，是什么意思？

（3）本片论文是去除了non-standard assumption，通过使用\*\*技术，并且构建了一个新的FHE方案，基于标准格假设问题（比如，SVP，CVP等）和循环安全假设【circular security assumption】。

（4）scale-invariant：缩放比例不变？

（5）该方案不使用模切换【modulus switching】，且密文是一个环元素（在环上）；另外给出一个实用的变体方案，其具有强假设，并给出推荐的参数和性能提升后的结果。

（6）最后，给出了一种优化方法，可以扩展密文大小，利用CRT技术。

介绍
--

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220608170655628-1978215905.png)  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220608170708388-1323759538.png)  
（1）【On-the-fly multiparty compu- tation on the cloud via multikey fully homomorphic encryption-2012】提出一个多密钥的FHE方案，是基于【Making NTRU as secure as worst-case problems over ideal lattices-2011】--对【NTRU: A ring-based public key cryp- tosystem-1998】的安全性进行证明。但方案为了保证安全性，需要额外的假设（decisional small polynomial ratio (DSPR) ）。  
对应摘要中的（1）

（2）该方案去掉了这个额外的假设；原来的是基于理想格，该方案基于的是格上的标准问题；引入张量技术（tensoring technique）【Fully homomorphic encryption without modulus switching from clas- sical GapSVP】降低噪音

（3）该方案是scale-invariant，即可以不使用模交换技术；该方案中的密文是一个环元素，而一半基于(R)LWE的方案密文都是两个以上的环元素，这能降低密文大小；最后给出一种增加明文空间大小的技术，即通过使用CRT技术，将小的明文模数变为大的明文模数。

（4）参数变大，密文大小变大。

预备知识
----

### 环上的有界分布（B-bounded）

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220608175033155-1173444218.png)  
取自该分布中的元素是有界限的，即无穷范数是小于\\(B\\)的。

具体的分布：离散高斯分布（discrete Gaussian distribution）  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220608180630744-1316514325.png)  
\\(D\_{Z,\\sigma }\\)：均值为0，方差为\\(\\sigma\\)，采样概率为\\(exp(-\\pi |x|^2 / {\\sigma }^2)\\)。

通常在FHE中，噪音多项式需要采用该方式采样，选取的元素，值小且概率高。

通过拒绝采样法（rejecting samples），来保证该分布是有界的。

通常多项式的系数在环上，一个数\\(x\\)需要模\\(q\\)，有两种表示：\\(x\\in (-q/2,q/2)\\)或者\\(x\\in \[.\]\_q\\)；还有一种是\\(x\\in \[0,q)\\)，用\\(r\_q(x)\\)表示\\(x\\)模\\(q\\)。

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220610145800543-1533962733.png)

该方案中，使用两种模表示。方案中的\\(q\\)是密文多项式的系数模数，还有一个确定明文消息空间的明文模数\\(t<q\\)，满足：\\(q-r\_t(q)=\\Delta\*t\\)，其中\\(\\Delta=\\left \\lfloor q/t \\right \\rfloor\\)  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613000848814-615418319.png)  
下面讲解了BitDecomp和PowersOfTwo两个技术以及其性质：  
其中，\\(w\\)相当于是基，这里取\\(w=2\\)。  
（1）BitDecomp  
当\\(w=2\\)时，给出一个环上的元素（整数多项式，可以看成一个整数向量（多项式系数））\\(x\\in R\\)，变为二进制表示的向量。

例如：\\(q=5\\)，即\\(l\_{w,q}=4\\)，\\((1,2)\\)变为\\((\[1,0,0,0\],\[0,1,0,0\])\\)

（2）PowersOfTwo  
当\\(w=2\\)时，给出一个环上的元素（整数多项式，可以看成一个整数向量（多项式系数））\\(x\\in R\\)，变为元素乘以\\(w\\)的倍数。  
例如：\\(q=5\\)，即\\(l\_{w,q}=4\\)，\\((1,2)\\)变为\\((\[1,2,4,3\],\[2,4,3,1\])\\)

（3）性质  
\\(<BitDecomp(x),PowersOfTwo(y)>=xy(mod q)\\)  
例如：\\(<(\[1,0,0,0\],\[0,1,0,0\]),(\[1,2,4,3\],\[2,4,3,1\])>=1\*1+2\*2(mod 5)=5\\)  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613003850044-225682197.png)  
将环上的元素扩展为多个，进行BitDecomp和PowersOfTwo计算，并且介绍了张量乘（tensor product）。  
（1）BitDecomp  
当\\(w=2\\)时，给出多个环上的元素（整数多项式，每一个可以看成一个整数向量（多项式系数））\\(x\\in R^l\\)，变为二进制表示的向量。

例如：\\(q=5,l=2\\)，即\\(l\_{w,q}=4\\)，\\((\[1,2\],\[0,1\])\\)变为\\((\[1,0,0,0\],\[0,1,0,0\],\[0,0,0,0\],\[1,0,0,0\])\\)

（2）PowersOfTwo  
当\\(w=2\\)时，给出多个环上的元素（整数多项式，每个可以看成一个整数向量（多项式系数））\\(x\\in R^l\\)，变为元素乘以\\(w\\)的倍数。  
例如：\\(q=5,l=2\\)，即\\(l\_{w,q}=4\\)，\\((\[1,2\],\[0,1\])\\)变为\\((\[1,2,4,3\],\[2,4,3,1\],\[0,0,0,0\],\[1,2,4,3\])\\)

（3）张量乘  
\\((a\_1,1\_2)\\bigotimes (b\_1,b\_2)=(a\_1\*b,a\_2\*b)=(a\_1\*b\_1,a\_1\*b\_2,a\_2\*b\_1,a\_2\*b\_2)\\)  
例如：\\((\[1,0,0,0,0,1,0,0\],\[0,0,0,0,1,0,0,0\])\\bigotimes (\[1,2,4,3,2,4,3,1\],\[0,0,0,0,1,2,4,3\])=(\[1,0,0,0,0,4,0,0\],\[0,0,0,0,0,2,0,0\],\[0,0,0,0,0,0,0,0\],\[0,0,0,0,1,0,0,0\])\\)

最后说到，在方案计算中，会出现有理数计算（小数），所以最后需要摄入操作化为整数，这里的舍入用的是“四舍五入”。

### RLWE问题

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613111756781-734236181.png)

RLWE问题来自【On ideal lattices and learning with errors over rings】。  
这里给出的是D-RLWR问题，困难性可以“量子规约”到格理想上的SVP问题

### DSPR问题

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613113046887-1243988482.png)  
DSPR问题：区分\\(h\\)和一个随机采样值是难以区分的。

基础方案
----

这部分介绍一个公钥加密方案，基于Regev框架，是下面同态加密方案的基础。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613114453783-1848688908.png)

密文模数\\(q\\)，明文模数\\(t\\in (1,q)\\)，密文空间为\\(R\_q=Z\_q\[x\]/\\Phi(x)\\)，明文空间为\\(R\_t=Z\_t\[x\]/\\Phi(x)\\)，密钥和误差取自不同的分布。\\(\[m\]\_t\\)表示m mod t。  
正确性性：  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613131411468-465168753.png)  
如果满足以上定理，则可以正确解密。  
\\(fc=(tf'+1)(q/t.m+e+hs)=(tf'+1)q/t.m+(tf'+1)(e+hs) (mod q)=q/t.m+(...)=\\Delta.m+v\\)  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613155033958-997254904.png)  
只要\\(v\\)的范数够小，就看可以恢复出明文，所以\\(v\\)也叫做密文\\(c\\)的内在噪音。  
下面给出内在噪音\\(v\\)的具体范数范围：  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613132606532-1517619135.png)  
所以能解密成功。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613155430443-1389271726.png)

Leveled-FHE方案
-------------

下面基础上面的公钥加密方案，给出一个SWHE方案YASHE，包含同态计算以及分析其计算过程中密文噪音的上限：  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613135540962-1424295057.png)  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613135557392-1078535472.png)  
可以看到，在乘法后需要进行密钥交换，降低密文维数，加法则不用，因为加法不会导致密文维数变大。  
重点在于：计算密钥\\(\\gamma\\)是如何生成的？同态乘法计算后如何降低密文噪音和维数的？

### 同态加法

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613143324873-734466415.png)

同态加法就是将两个密文直接相加，加完后的噪音小于两个密文的噪音之和+模操作产生的噪音\\(r\_t(q)\\)，其中\\(r\_t(q)=q mod t\\)。这里给了相加密文的噪音上限。  
这里需要知道：$$\\Delta t =\\left \\lfloor q/t \\right \\rfloor t=-r\_t(q)(mod q)=-q (mod t) (mod q)\\to q(mod t)=q-\\left \\lfloor q/t \\right \\rfloor t$$

### 同态乘法

密文乘法分为两步：（1）直接将两密文相乘，获得一个中间密文(对应的明文是\\(\[m\_1.m\_2\]\_t\\))，它不能直接使用私钥解密。（2）将其转换为一个可以用私钥解密的新密文，在这里用到了重线性化技术(BV11)/密钥交换技术(BGV)进行密文转换。  
噪音处理主要在该步骤。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613145055212-2114764639.png)  
第一步给出了如何计算中间密文\\(\\widetilde{c}\_{mult}\\)，并且分析噪音增长上限，这里可以看出将两个密文先进行PowerOfTwo操作，然后张量乘，维数扩张一倍，所以后面需要降维，同时这步骤也产生了噪音，所以也需要降噪。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613150453727-154518921.png)  
第二步给出了密钥交换的过程，以及分析噪音增长的上界。  
首先，需要求出用于密钥交换的计算密钥\\(evk\\)，它其实可以看作是\\(f^{-1}P(D(f)\\bigotimes D(f))\\)在公钥\\(h\\)下的加密，当然可以用私钥\\(f\\)解密。这里的\\(evk\\)是公开的，所以这里需要做一个“循环安全假设(circular security assumption)”，即即使公开\\(evk\\)，也不会影响方案的安全性。  
另外可以看出，这里做密钥交换，也产生了一些噪音。这些噪音通过Decompt和PowerOfTwo技术控制在一定的范围内，增长缓慢。

### 正确性

这里给出在解密正确的前提下乘法次数的界限。方案的安全性基于DSPR问题，需要设置好参数。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613151908968-1711545510.png)

### 安全性

为了证明方案是安全的，需要假设即使敌手知道了\\(evk\\)，方案也可以保证是IND-CPA安全的。  
在“循环安全假设”下，YASHE方案的IND-CPA安全性来自基于公钥加密方案的IND-CPA安全，而基于公钥加密方案的IND-CPA安全是基于RLWE困难问题。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613160609111-1058180330.png)  
要证明循环安全假设，需要方案设置的参数满足：  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613160812414-673303123.png)

### 变为FHE

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613161826067-290560465.png)  
如何将Leveled-FHE变为FHE，目前唯一的方法还是Gentry提出的“自举”（bootstrapping）技术。  
即方案能够同态的计算自己的解密电路，这里需要用公钥将私钥的每一个比特加密，类似于密钥交换中的计算密，这里需要一个“安全假设”，即加密私钥的每个比特不会影响方案的安全性！  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613162106866-782673012.png)  
这里将解密电路的复杂度降低为\\(O(log(log(q))+log(d))\\)，具体是将**缩放（scaling）和舍入（rounding）操作**换成消耗更小的**乘法和移位运算**。最后的模2并不会增加计算深度。

YASHE的变体YASHE‘
--------------

不同之处是同态乘法，YASHE‘中乘法的中间密文只是一个简单的多项式，而YASHE中的中间密文是一个多项式向量，这就导致了计算密钥\\(evk\\)中只需包含\\(l\_{w,q}\\)个多项式，而不是\\(l\_{w,q}^3\\)个多项式，所以密钥交换更加简单了。下面介绍简化过程和噪音分析。

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613180427554-336826796.png)  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613180502309-1137294820.png)  
在YASHE方案中，\\(\\widetilde{c}\_{mult}\\)相当于是\\(\[m\_1.m\_2\]\_t\\)在\\(D(f)\\bigotimes D(f)\\)下加密的；而在YASHE‘方案中，\\(\\widetilde{c}\_{mult}\\)相当于是\\(\[m\_1.m\_2\]\_t\\)在\\(f^2\\)下加密的。  
可以看出，在新方案中，乘法中没有使用Decompt和PowerOfTwo技术，仅在密钥交换中使用到。

### 同态乘法

这部分给出在乘法计算中，中间密文的噪音上限。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613181532851-1550246472.png)

### 密钥交换

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613182039299-280960129.png)  
同样，这里的\\(evk\\)可以看作是私钥\\(f\\)在公钥\\(h\\)下的加密。另外需要额外的“循环安全假设”保证方案的安全性。

### 正确性

每一层的密文中的噪音大小是近似的，为了减少计算量，尽量使用更多的加法，使用更少的乘法。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220613182540709-321834436.png)  
这里给出密文的内在噪音的上限\\(V\\)、乘法深度\\(L\\)，与方案其它参数的关系，需要满足该条件才能执行L次乘法运算，即 Leveled-FHE方案。

### 安全性

新方案的安全性依赖于RLWE问题、“循环安全假设”和DSPR问题，原方案可以根据根据参数设置而避免使用DSPR假设。  
可以证明在RLWE问题和DSPR问题下，该方案是安全的，即方案的IND-CPA安全是基于RLWE假设和DSPR假设的。且需要满足于当 \\(evk\\)公开时，方案也是安全的。  
这里给出一个更弱的DSPR假设（参数选取的分布不同，导致噪音上线不同）。  
另外私钥一般取值很小，可以为每一个级提供一个公私钥对从而避免使用“循环安全假设”，此时每一层的\\(evk\\)和该层的公私钥有关，具体如下：  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220614101216087-298960001.png)

### 参数推荐

这里给出了需要事先确定的两个重要参数：  
（1）密文模数\\(q\\)  
一般在64bit~1024bit之间取值  
（2）多项式的级数  
\\(n=\\varphi (d)\\)一般取2的次幂，这里给出\\(2^{11}\\)和\\(2^{16}\\)。  
（3）下面给出推荐参数，两种情况：固定\\(q\\)，求\\(n\_{min}\\)，然后给出最大的层数\\(L\_{max}\\)；固定级数\\(n\\)，求最大的\\(q\_{max}\\)，然后给出最大的层数\\(L\_{max}\\)  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220614104921206-1010746425.png)  
可以看出，随着参数的增大，支持计算的层数就变大，但计算量也随之变大。

（4）【Can homomorphic encryption be practical? 】中给出的实验结果  
参数：\\(R=Z\[X\]/(X^{4096}+1),t=2^{10},q:130bit\\)  
结果：加密：756ms，加法：4ms，乘法：1590ms，解密：57ms

（5）该方案的实验结果

> 代码不依赖于第三方库，基于C编写

参数：\\(q:127bit,w=2^{23}\\)，其它参数一样  
结果：加密：27ms（百万次循环），加法：0.024ms（7万次循环），乘法：31ms（9070万循环），解密：5ms（1410万循环）

（6）方案的实际乘法次数为\\(2^2～2^5\\)，性能更好。

### 截断密文（Truncating）

![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220614115935854-794581683.png)

在Bra12中提出scale-变体的LWE方案，即丢弃密文最低位（least signiﬁcant bits ），基于该思想，方案给出两种优化方向：  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220614135114677-703449408.png)

（1）约减密文长度  
\\(YASHE.Discard\_w(c,i)\\)：输入一个密文和要被阶段的个数\\(i\\)，输出\\(c'=\\left \\lfloor w\_{-i}c \\right \\rfloor\\)，这里的\\(w\\)时基，一般取2。且\\(w^i.c'\\)等于\\(c\\)的最低\\(i\\)位取0。  
这里举例子：给出密文\\(c=7=(0 1 1 1)\_w\\)，\\(w=2\\)  
当\\(i=2\\)，\\(c'=1\\)，正好对应\\(c\\)去掉后两位得到的\\((0 1)\_w\\)；且\\(w^i.c'=4\\)，即\\((0 1 0 0)\_w\\)  
当\\(i=3\\)，\\(c'=0\\)，正好对应\\(c\\)去掉后两位得到的\\((0)\_w\\)；且\\(w^i.c'=0\\)，即\\((0 0 0 0)\_w\\)

如果\\(cf=\\Delta m+v(mod q)\\)，则\\(w^ic'f=\\Delta m+v'(mod q)\\)

通过截取密文，密文的长度变短，且不依赖于\\(q\\)，而是依赖于\\(q\\)和噪音的比值。当用\\(D\_{w,q}(c)\\)表示密文\\(c\\)时，大概需要\\(log\_w(q/B)\\)的基，且最低\\(log\_w(B)\\)位为0。

如果\\(c\\)在\\(f^2\\)解密，则在密钥交换时，我们仅需要\\(evk\\)中的前\\(log\_w(q/B)\\)位的信息进行切换。

（2）约减计算密钥中元素个数  
每次乘法，都需要减少\\(evk\\)中的元素数量。

### 通过CRT编码

上面给出了推荐的参数和输入边界，以此来保证方案的正确性和安全性。  
当需要更多的计算时，在不增加参数的情况下，使用该技术可以增大计算量。思想就是，利用中国剩余定理将多个输入编码为一个更大数，使得计算精度更好或者输入的数值更大。其中使用的参数一直不变，只需要密文个数变大。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220614140416294-582534600.png)  
通过CRT将每个输入编码为都是模\\(t\_i\\)的集合元素，来进行边界为\\(B\\)的整数计算；然后对集合进行计算，相当于对这些整数不涉及模约减（modular reductions）的运算，只要\\(t\_i\\)的乘积不超过\\(B\\)。集合中的每个整数都相当于对应模\\(t\_i\\)的明文（plain text）被加密的密文，并且能并行计算这些密文并返回结果；在解密时，利用CRT将输出或恢复为实际的整数。  
![image](https://img2022.cnblogs.com/blog/1928790/202206/1928790-20220614142651028-182762463.png)

此时的技术不同于【Batch fully homomorphic encryption over the integers】【Fully homomorphic simd operations】中的技术，这里没有利用CRT将信息打包到一个密文（single ciphertext）中的不同明文槽中（plain text slots）而是简单加密了一个密文中每一个CRT编码的部分，对应于模\\(t\_i\\)的明文（plain text ）。密文现在由多个环元素组成，但是可以并行计算，这可以使我们使用相同的参数处理双位（integers of double bit length）长的整数，仅使用不同的值\\(t\_0,t\_1\\)扩展到两个密文。

> 没看太懂。说的太抽象。没有具体例子。