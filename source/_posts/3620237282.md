---
layout: post
title: "Java泛型知识总结"
date: "2022-06-08T13:39:52.123Z"
---
Java泛型知识总结
==========

泛型
==

前言
--

> 在没有泛型之前，程序员必须使用Object编写适用于多种类型的代码。很繁琐，也不安全。  
> 泛型的引入使Java有了一个很强的类型系统，允许设计者详细地描述变量和方法的类型要如何变化。  
> 在普通的情况下，实现泛型代码很容易。在更高级的情况下，我们的目标是提供让其他程序员可以轻松使用的类和方法，这对实现者来说会非常复杂。

为什么要使用泛型
--------

用泛型编写的代码可以对多种不同对象的类型进行重用。

没有泛型之前，使用Object（继承）实现不同类型对象间的匹配。这种方法有两个弊端

*   获取一个值时必须进行强制转换（繁琐）
*   编译期没有错误检查（不安全）

因此，泛型提供了一种解决方案：类型参数（type parameter）。 使代码更具有可读性。  
编译器也可以充分利用这个类型信息。调用get的时候不需要强制转换。编译器还知道add方法有一个类型为String的类型参数，这比Object类型要安全。现在，编译器可以检查，防止你插入错误类型的对象。编译期出现错误比运行期出现类的强制转换异常要好的多。

泛型类
---

> 有一个或多个类型变量的类。

例如：定义一个类型变量T，用 `<>` 括起来，放在类名后边。泛型类还可以有多个类型变量，<T, U>。  
变量类型可以应用于方法的返回值类型以及字段和局部变量。

使用具体的类型替换类型变量来实例化反省类型，可以把结果想像成一个普通类。

泛型方法
----

泛型方法可以定义在普通类中，也可以定义在泛型类中。

注意，泛型变量要放在方法返回值前。

**调用泛型方法的方式（例子是调用静态方法）：**

*   ArrAlg.<String>getMiddle(); 注意调用格式
*   ArrAlg.getMiddle(); 简单调用

类型变量的限定
-------

场景：某个方法参数为泛型T，在方法体中要调用compareTo方法来比较大小，既然使用了泛型，说明该方法可以传入任何参数对象，那么如何知道T所属的类有一个compareTo方法呢？

解决这个问题的方法就是限制T只能是实现了Comparable接口的类。可以通过对变量类型T设置一个限定来实现这一点：**`public static <T extends Comparable> T min(T[] t)`**

此时，在调用泛型方法min时只能传递实现了Comparable接口的类型对象的参数。

语法就是：**<T extends BoundingType>**，T和限定类可以是类也可以是接口。

一个类型变量或通配符可以有多个限定：

*   类型变量用**逗号**分隔
    *   <T, U extends Comparable>
*   限定类型用**&**分隔
    *   <T extends Comparable & Serializable>

**注意：** 可以限定多个接口，类最多只能限定一个。如果有一个类作为限定，这个类必须是第一个限定。

泛型代码和虚拟机
--------

无论何时定义一个泛型，都会自动提供一个原始类型（raw type）。这个原始类型就是去掉类型参数后的泛型类型名。对于无限定的变量替换为Object。

原始类型第一个限定类型来替换类型变量，如果没有给定限定，则替换为Object。例如：

    public class Interval<T extends Comparable & Serializable> {
        private T lower;
    }
    // Comparable为第一个限定类型，所以使用它来替换
    public class Interval {
        private Comparable lower;
    }
    

### 泛型转换的步骤

*   对原始方法Pair.getFirst调用返回Object类型
*   将返回的Object类型转换为Employee类型

### 泛型转换规则

*   虚拟机中没有泛型，只有普通的类和方法
*   所有的类型参数都会替换为他们的限定类型
*   会合成桥方法来保持多态
*   为保持类的安全性，必要时会插入强制类型转换

### @SuppressWarnings("unchecked")

> 这个注解会关闭代码检查

泛型的限制与局限性
---------

*   泛型不能使用基本数据类型
*   类型比较只适用于原始类型
*   不能创建泛型数组

通配符
---

> 泛型通配符搭配集合使用一般在方法的参数中比较常见  
> 方法中的参数是一个集合,集合如果携带了通配符，要特别注意如下：  
> 1 集合的类型会提升为Object类型。  
> 2 方法中的参数是一个集合,集合如果携带了通配符,那么此集合不能进行添加和修改操作 , 可以删除和获取  
> 在集合中泛型是不支持多态的，如果为了匹配任意类型，我们就会使用泛型通配符了。

**`<?>`** 可以表示任意类型

### 受限通配符

> 对泛型做约束，给泛型指定类型时，只能是某个类的父类或子类。

*   下限
    *   ? super 类型
*   上限
    *   ? extends 类型

visualgo.net