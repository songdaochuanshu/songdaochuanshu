---
layout: post
title: "反射"
date: "2022-06-19T12:32:09.231Z"
---
反射
==

快速入门：

    re.properties文件：
    classfullpath=com.example.Cat
    methodName=cry
    

    package com.example.reflection.question;
    
    import java.io.FileInputStream;
    import java.io.IOException;
    import java.lang.reflect.InvocationTargetException;
    import java.lang.reflect.Method;
    import java.util.Properties;
    
    /**
     * @Author 郜庆辉
     * @Time 2022/6/14 17:13
     * @Version 1.0
     */
    public class ReflectionQuestion {
        public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
            
            
            Properties properties = new Properties();
            properties.load(new FileInputStream("src\\re.properties"));
            String  classfullpath = properties.get("classfullpath").toString();
            String methodName = properties.get("methodName").toString();
            
            System.out.println("classfullpath=" + classfullpath);
            System.out.println("method=" + methodName);
            
            
            //使用反射机制解决
            //1.加载类，返回Class类型的对象cls
            Class cls = Class.forName(classfullpath);
            //2.通过cls得到你加载的类com.example.Cat的对象实例
            //这里返回的类型是classfullpath所在类的运行类型也就是com.example.Cat
            Object o = cls.newInstance();
            System.out.println("getClass=" + o.getClass());
            
            //3.通过cls得到你加载的类com.example.Cat的methodName hi的方法对象
            //在反射中，万物皆是对象，包括方法
            Method method = cls.getMethod(methodName);
            
            //4.通过method调用方法：即通过方法对象来实现调用方法
            System.out.println("=========================");
            method.invoke(o);
        }
    }
    

Cat类：

    package com.example;
    
    /**
     * @Author 郜庆辉
     * @Time 2022/6/14 17:05
     * @Version 1.0
     */
    public class Cat {
        private String name = "招财猫";
        
        public void hi(){
            System.out.println("hello " + name);
        }
        
        public void cry(){//常用方法
            System.out.println(name + " 喵喵叫");
        }
        
    }
    

> > 简单一句话：反射的作用就是通过不修改源代码，修改配置文件来得到代码结果的改变；

  

class 类
-------

> *   Class类本身也是一个类，也继承Object类
> *   Class类对象不是new出来的，而是系统创建的
> *   对于某个类的Class对象，在内存中只有一份，因为类只加载一次
> *   一个Class对象对应的是一个加载到JVM中的一个.class文件
> *   每个类的实例都会记得自己是由哪个Class实例所生成
> *   通过Class可以完整的得到一个类中的所有被加载的结构，通过API
> *   Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象
> *   Class对象是存放在堆中的
> *   类的字节码二进制数据是放在方法区的，有的地方称为类的元素据

![image](https://img2022.cnblogs.com/blog/2471572/202206/2471572-20220619154419101-1693409202.png)

  

反射机制
----

1.反射机制允许程序在执行期间借助与Reflection API取得任何类的内部信息(比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法。

2.加载完类以后，在堆中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了类的完整结构信息。通过这个对象得到类的结构，这个Class对象就像一面镜子，透过这个镜子看到类的结构，所以就称为反射；

![image](https://img2022.cnblogs.com/blog/2471572/202206/2471572-20220619154403193-1074228549.png)

  

### 反射优点和缺点

优点：可以动态的创建和使用对象(也是框架底层核心)，使用灵活，没有反射机制，框架技术就失去底层支撑；

缺点：使用反射机制是解释执行，对执行速度有影响；

  

反射的常用方法
-------

    package com.example.reflection.class_;
    
    /**
     * @Author 郜庆辉
     * @Time 2022/6/15 17:19
     * @Version 1.0
     */
    public class Car {
        public String brand = "宝马";
        public double price = 5000000;
        public String color = "黑色";
        
        @Override
        public String toString() {
            return "Car{" + "brand='" + brand + '\'' + ", price=" + price + ", color='" + color + '\'' + '}';
        }
    }
    

    package com.example.reflection.class_;
    
    import java.lang.reflect.Field;
    
    /**
     * @Author 郜庆辉
     * @Time 2022/6/15 17:18
     * @Version 1.0
     * 演示Class类的常用方法
    */
     public class Class02 {
        public static void main(String[] args) throws Exception {
            
            String classAllPath = "com.example.reflection.class_.Car";
            
            //1.获取到Car类对应的Class对象
            //<?>表示不确定的java类型
            Class<?> cls = Class.forName(classAllPath);
            //2.输出cls
            //显示cls对象，是哪个类的Class对象 com.example.reflection.class_.Car
            System.out.println(cls);
            
            //显示cls运行类型 java.lang.Class
            System.out.println(cls.getClass());
            
            //3.得到包名
            System.out.println(cls.getPackage());
            
            //4.得到完整类名
            System.out.println(cls.getName());
            
            //5.通过cls创建对象实例，默认是Object，cls的运行类型是Car，也可以强转成Car
            Car car = (Car) cls.newInstance();
            System.out.println(car);
            
            //6.通过反射获取属性brand
            Field brand = cls.getField("brand");
            System.out.println(brand.get(car));
            
            //7.通过反射给属性赋值
            brand.set(car, "劳斯莱斯");
            System.out.println(brand.get(car));
            
            //8.遍历所有属性和值
            Field[] fields = cls.getFields();
            for (Field f : fields) {
                System.out.println(f.getName() + "=" + f.get(car));
            }
        
        }
    }
    
    

  

创建反射的几种方式
---------

    package com.example.reflection.class_;
    
    /**
     * @Author 郜庆辉
     * @Time 2022/6/15 14:44
     * @Version 1.0
     * <p>
     * 演示class类的创建方式有哪些
     */
    public class CreateClass {
        public static void main(String[] args) throws ClassNotFoundException {
            Person student = new Student();
            System.out.println(student.name);
            
            //方式一：通过对象获得
            //应用场景：
            Class c1 = student.getClass();
            System.out.println(c1);
            
            //方式二：forname获得
            //前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法Class.forName()来获取
            //应用场景：多用于配置文件，读取类全路径，加载类
            Class c2 = Class.forName("com.example.reflection.class_.Student");
            System.out.println(c2);
            
            //方式三：通过类名.class获得
            //前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高
            //应用场景：多用于参数传递，比如通过反射得到对应构造器对象
            Class c3 = Student.class;
            System.out.println(c3);
            
            //方式4：通过类加载器得到Class对象
            //1.先得到类加载器
            ClassLoader classLoader = student.getClass().getClassLoader();
            //2.通过类加载器得到class对象
            Class c4 = classLoader.loadClass("com.example.reflection.class_.Student");
            System.out.println(c4);
        
            //这4个class对象是同一个
            if(c1.equals(c2) && c3.equals(c4)){
                System.out.println(true);
            }
            
            //5.基本数据类型(int,char,boolean.float.double,byte,long,short)按如下方式得到Class类对象
            Class<Integer> integerClass = int.class;
            Class<Character> characterClass = char.class;
            Class<Double> doubleClass = double.class;
            System.out.println(integerClass);
        
            //6.基本数据类型对应的包装类可以通过 包装类.TYPE 得到Class类对象
            Class<Integer> type = Integer.TYPE;
            Class<Character> type1 = Character.TYPE;
            Class<Double> type2 = Double.TYPE;
            //。。。
        }
    }
    
    class Person {
        public String name;
        
        public Person() {
        }
        
        public Person(String name) {
            this.name = name;
        }
        
        @Override
        public String toString() {
            return "Person{" + "name='" + name + '\'' + '}';
        }
    }
    
    class Student extends Person {
        public Student() {
            this.name = "学生";
        }
    }
    
    class Teacher extends Person {
        public Teacher() {
            this.name = "老师";
        }
    }
    

哪些类型有Class对象
------------

> 1.外部类、成员内部类、静态内部类、局部内部类、匿名内部类
> 
> 2.interface: 接口
> 
> 3.数组
> 
> 4.enum: 枚举
> 
> 5.annotation: 注解
> 
> 6.基本数据类型
> 
> 7.void

  

类加载
---

基本说明：

反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载；

​ 1.动态加载：编译时加载相关的类，如果没有则报错，依赖性太强；

​ 2.动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，也不保存，降低了依赖性

类加载时机：

​ 1.当创建对象时(new) //静态加载

​ 2.当子类被加载时，父类也加载 //静态加载

​ 3.调用类中的静态成员时 //静态加载

​ 4.通过反射 //动态加载

![image](https://img2022.cnblogs.com/blog/2471572/202206/2471572-20220619154400173-1719325992.png)

![image](https://img2022.cnblogs.com/blog/2471572/202206/2471572-20220619154332331-774352782.png)

**加载阶段：**

JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件，也可能是jar包，甚至网络)转化为**二进制字节流加载到内存**中，并生成一个代表该类的java.lang.Class对象

**连接阶段--验证：**

1.目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

2.包括：文件格式验证(是否以魔数 oxcafebabe开头)、元数据验证、字节码验证和符号引用验证

3.可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间

**连接阶段--准备**

1.JVM在该阶段对静态变量，分配内存并默认初始化(对应数据类型的默认初始值，如0、0L、null、false等)，这些变量所使用的内润都将在方法区中进行分配

    class A {
        //分析类加载得 连接阶段--准备 属性是如何处理
        //n1是实例属性，不是静态变量，因此在准备阶段，是不会分配内存的
        //n2是静态变量，分配内存n2是默认初始化为0，到后面inital的时候才赋值为20
        //n3是static final常量，和静态变量不同，因为一旦赋值就不变，直接就是n3 = 30
        public int n1 = 10;
        public static int n2 =20;
        public static final int n3 = 30;
    }
    

**连接阶段--解析**

虚拟机将常量池内的符号引用替换为直接引用的过程

**初始化阶段(Initialization)：**

1.到初始化阶段：才真正开始执行类中定义的Java程序代码，此阶段是执行()方法的过程；

2.()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并(相当于后面相同的属性名字替换前面的属性的值)；

3.虚拟机会保证一个类的()方法在多线程环境中被正确的加锁、同步、如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直接活动线程执行()方法完毕；

  

反射爆破
----

反射爆破创建实例：

    package com.example.reflection;
    
    import java.lang.reflect.Constructor;
    
    
    
    /**
     * @Author 郜庆辉
     * @Time 2022/6/17 14:25
     * @Version 1.0
     * 演示通过反射机制创建实例
     */
    public class ReflecCreateInstance {
        public static void main(String[] args) throws Exception {
            //1.先获取到User类的Class对象
            Class<?> userClass = Class.forName("com.example.reflection.User");
            
            //2.通过public的无参构造器创建实例
            Object o = userClass.newInstance();
            System.out.println(o);
            
            //3.通过public的有参构造器创建实例
            //3.1先得到对应构造器
            Constructor<?> constructor = userClass.getConstructor(String.class);
            ////3.2 创建实例，并传入实参
            Object gqh = constructor.newInstance("gqh");
            System.out.println("gqh=" + gqh);
            
            //4.通过非public的有参构造器创建实例
            Constructor<?> declaredConstructor = userClass.getDeclaredConstructor(int.class, String.class);
            //暴破【暴力破解】 , 使用反射可以访问 private 构造器/方法/属性
            declaredConstructor.setAccessible(true);
            Object user2 = declaredConstructor.newInstance(100, "郜庆辉");
        
            System.out.println("user2=" + user2);
        }
    }
    
    class User {//User 类
        private int age = 10;
        private String name = "韩顺平教育";
        
        public User() {//无参 public
        }
        
        public User(String name) {//public 的有参构造器
            this.name = name;
        }
        
        private User(int age, String name) {//private 有参构造器
            this.age = age;
            this.name = name;
        }
        
        public String toString() {
            return "User [age=" + age + ", name=" + name + "]";
        }
    }
    

  

反射爆破操作方法：

    package com.example.reflection;
    
    import java.lang.reflect.Field;
    
    /**
     * @Author 郜庆辉
     * @Time 2022/6/17 14:45
     * @Version 1.0
     * 演示反射操作属性
     */
    public class ReflecAccessProperty {
        public static void main(String[] args) throws Exception {
            //1.得到Student类对应的Class对象
            Class<?> stuClass = Class.forName("com.example.reflection.Student");
            
            //2.创建对象
            Object o = stuClass.newInstance();
            System.out.println(o.getClass()); //Student
            
            //3使用反射得到age属性对象
            Field age = stuClass.getField("age");
            age.set(o,80);
            System.out.println(o);
            System.out.println(age.get(o));
            
            //4.使用反射操作name属性
            Field name = stuClass.getDeclaredField("name");
            //对 name 进行暴破, 可以操作 private 属性
            name.setAccessible(true);
            name.set(null,"辉");
            //name.set(o,"郜庆辉");
            System.out.println(o);
            System.out.println(name.get(o));//获取属性值
            System.out.println(name.get(null));//获取属性值，要求name是static
        }
    }
    
    class Student {//类
        public int age;
        private static String name;
        
        public Student() {//构造器
        }
        
        public String toString() {
            return "Student [age=" + age + ", name=" + name + "]";
        }
    }
    
    
    

  

通过反射爆破调用方法：

    
    package com.example.reflection;
    
    import java.lang.reflect.Method;
    
    /**
     * @Author 郜庆辉
     * @Time 2022/6/17 15:08
     * @Version 1.0
     * 演示通过反射调用方法
     */
    public class ReflecAccessMethod {
        public static void main(String[] args) throws Exception {
            //1.得到Boss类对应的Class对象
            Class<?> bossCls = Class.forName("com.example.reflection.Boss");
            //2.创建对象
            Object o = bossCls.newInstance();
            //3.调用public的hi方法
            Method hi = bossCls.getDeclaredMethod("hi", String.class);
            hi.invoke(o,"郜庆辉");
            
            //4.调用private statice方法
            //4.1得到say方法对象
            Method say = bossCls.getDeclaredMethod("say", int.class, String.class, char.class);
            //4.2 因为 say 方法是 private, 所以需要暴破，原理和前面讲的构造器和属性一样
            say.setAccessible(true);
            System.out.println(say.invoke(o, 100, "张三", '男'));
        
            //5. 在反射中，如果方法有返回值，统一返回 Object , 但是他运行类型和方法定义的返回类型一致
            Object reVal = say.invoke(null, 300, "王五", '男');
            System.out.println("reVal 的运行类型=" + reVal.getClass());//String
            
            
        }
        
    }
    
    class Boss {//类
        public int age;
        private static String name;
        
        public Boss() {//构造器
        }
        
        private static String say(int n, String s, char c) {//静态方法
            return n + " " + s + " " + c;
        }
        
        public void hi(String s) {//普通 public 方法
            System.out.println("hi " + s);
        }
        
    }