---
layout: post
title: "『忘了再学』Shell基础 — 21、变量的测试与内容置换"
date: "2022-05-27T23:19:14.944Z"
---
『忘了再学』Shell基础 — 21、变量的测试与内容置换
=============================

目录

*   [1、什么是变量的测试与内容置换](#1什么是变量的测试与内容置换)
*   [2、变量的测试与内容置换](#2变量的测试与内容置换)
*   [3、示例](#3示例)
    *   [例1：](#例1)
    *   [例2：](#例2)
    *   [例3：](#例3)

1、什么是变量的测试与内容置换
---------------

我们之前说过，在Shell中，一个变量未定义，和一个变量为空值的输出效果是一样的。

    # 先直接输出一个未定义的变量y
    [root@Lyl ~]# echo $y
    
    # 再定义变量y为空值，并输出变量y
    [root@Lyl ~]# y=""
    [root@Lyl ~]# echo $y
    
    [root@Lyl ~]#
    

其结果都是没有任何显示。

前边在说`set`命令的时候说过，执行`set -u`命令后，如果一个变量不存在，则会报错。如果变量为空，则会显示空。

    # 先直接输出一个未定义的变量x，结果会报错。
    [root@Lyl ~]# echo $x
    -bash: x: unbound variable
    
    # 再定义一个空值y，结果就显示为空。
    [root@Lyl ~]# y=""
    [root@Lyl ~]# echo $y
    
    [root@Lyl ~]#
    

所以通过`set -u`可以让我们分清楚Shell中的一个变量是未定义的还是有空值的。

但是人执行命令看提示，是可以区分变量未定义和空值的情况。那如何让Shell程序来判断，一个Shell变量是否存在还是有空值，还是有值。（人肉眼能看到的，不见得程序能识别）

当然我们可以识别提示，并根据提示内容做判断来区分，也是很麻烦的。

Shell觉得我们面对上面的情况会频率很高，所以Shell帮我们准备了判断上述情况的表达式。

我们先来看一个变量的测试与内容置换的例子，如下：

变量置换方式

变量y没有设置（未定义）

变量y为空值

变量y设置值

`x=${y-新值}`

`x=新值`

`x为空值`

`x=$y`

> 说明：
> 
> `x=${y-新值}`的意思是，通过`${y-新值}`表达式，来判断变量x的值是什么。
> 
> 如果变量y的值未定义，则变量x的值等于新值；
> 
> 如果变量y的值是空，则变量x的值也为空（其实就是`x=$y`）；
> 
> 如果变量y有值，则变量x的值等于变量y的值。
> 
> 这个变量的测试，是测试的变量y是否有值，无值，还是未定义。
> 
> 然后再把结果赋值给变量x。
> 
> 同理通过变量x的值，也可以判断变量y的情况是什么。

2、变量的测试与内容置换
------------

变量置换方式

变量y没有设置（未定义）

变量y为空值

变量y设置值

`x=${y-新值}`

`x=新值`

`x为空值`

`x=$y`

`x=${y:-新值}`

`x=新值`

`x=新值`

`x=$y`

`x=${y+新值}`

`x为空值`

`x=新值`

`x=新值`

`x=${y:+新值}`

`x为空值`

`x为空值`

`x=新值`

`x=${y=新值}`

`x=新值`  
`y=新值`

`x为空值`  
`y值不变`

`x=$y`  
`y值不变`

`x=${y:=新值}`

`x=新值`  
`y=新值`

`x=新值`  
`y=新值`

`x=$y`  
`y值不变`

`x=${y?新值}`

新值输出到标准错误输出（就是屏幕）

`x为空值`

`x=$y`

`x=${y:?新值}`

新值输出到标准错误输出

新值输出到标准错误输出

`x=$y`

说明：

*   如果大括号内没有`:`，则变量y是为空，还是没有设置，处理方法是不同的；  
    如果大括号内有`:`，则变量y不论是为空，还是没有没有设置，处理方法是一样的。
*   如果大括号内是`-`或`+`，则在改变变量x值的时候，变量y是不改变的；  
    如果大括号内是`=`，则在改变变量x值的同时，变量y的值也会改变。
*   如果大括号内是`?`，则当变量y不存在或为空时，会把“新值”当成报错输出到屏幕上。

3、示例
----

### 例1：

    # 情况1：有一个变量y，未被定义
    # 进行测试
    [root@Lyl ~]# x=${y-new}
    
    # 因为变量y不存在，所以x=new
    [root@Lyl ~]# echo $x
    new
    
    # 查看变量y，但是变量y还是不存在的
    [root@Lyl ~]# echo $y
    
    [root@Lyl ~]#
    
    
    # 情况2：变量y为空
    # 定义变量y为空
    [root@Lyl ~]# y=""
    
    # 进行测试
    [root@Lyl ~]# x=${y-new}
    
    # 变量x和变量y值都是空
    [root@Lyl ~]# echo $x
    
    [root@Lyl ~]# echo $y
    
    [root@Lyl ~]#
    
    
    # 情况3：变量y有值
    # 给变量y赋值
    [root@Lyl ~]# y=old
    
    # 进行测试
    [root@Lyl ~]# x=${y-new}
    
    # 变量x和变量y的值都是old
    [root@Lyl ~]# echo $x
    old
    [root@Lyl ~]# echo $y
    old
    [root@Lyl ~]#
    

### 例2：

    # =号的练习
    
    # 情况1：有一个变量y，未被定义
    # 进行测试
    [root@Lyl ~]# x=${y:=new}
    
    # 变量x和变量y的值都是new
    [root@Lyl ~]# echo $x
    new
    [root@Lyl ~]# echo $y
    new
    
    
    # 注意：
    # 一旦使用“=”号，那么变量y和变量x都会同时进行处理，
    # 而不像例子1中只改变变量x的值。
    
    # 情况2：变量y为空
    # 定义变量y为空
    [root@Lyl ~]# y=""
    
    # 进行测试
    [root@Lyl ~]# x=${y:=new}
    
    # 变量x和变量y的值都是new
    [root@Lyl ~]# echo $x
    new
    [root@Lyl ~]# echo $y
    new
    
    # 注意;
    # 一旦在大括号中使用"："，那么变量y为空或者不设定，处理方式都是一样的了。
    
    # 情况3：变量y有值
    # 给变量y赋值
    [root@Lyl ~]# y=old
    
    # 进行测试
    [root@Lyl ~]# x=${y:=new}
    
    # 变量x和变量y的值都是old
    [root@Lyl ~]# echo $x
    old
    [root@Lyl ~]# echo $y
    old
    
    

### 例3：

    # ?号的练习
    
    # 情况1：有一个变量y，未被定义
    # 进行测试
    # 会把值"new"输出到屏幕上。
    [root@Lyl ~]# x=${y?new}
    -bash: y: new
    
    # 情况2：变量y为空
    # 定义变量y为空
    [root@Lyl ~]# y=""
    
    # 进行测试
    [root@Lyl ~]# x=${y?new}
    
    # 变量x和变量y值都是空
    [root@Lyl ~]# echo $x
    
    [root@Lyl ~]# echo $y
    
    [root@Lyl ~]#
    
    
    # 情况3：变量y有值
    # 给变量y赋值
    [root@Lyl ~]# y=old
    
    # 进行测试
    [root@Lyl ~]# x=${y?new}
    
    # 变量x和变量y的值都是old
    [root@Lyl ~]# echo $x
    old
    [root@Lyl ~]# echo $y
    old