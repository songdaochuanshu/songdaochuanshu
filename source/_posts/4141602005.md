---
layout: post
title: "HCNP Routing&Switching之代理ARP"
date: "2022-04-24T20:20:08.990Z"
---
HCNP Routing&Switching之代理ARP
============================

![HCNP Routing&amp;Switching之代理ARP](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424235011449-1121854515.png) 所谓代理ARP是指，如果ARP请求是从一个网络的主机发往同一网段，却不再同一物理物理网络上的另一台主机（即相互隔离的同一网段内的主机），那么连接它们的具有代理ARP功能的设备就可以回答该请求，这个过程就叫做代理ARP（Proxy ARP）；代理ARP屏蔽了分离的物理网络，使用户使用起来就好像在同一物理网络上一样；代理ARP可以分为两大类，一类是连接相同三层接口的本地代理和连接不同三层接口的普通代理arp；

　　前文我们了解了端口隔离相关话题，回顾请参考[https://www.cnblogs.com/qiuhom-1874/p/16186451.html](https://www.cnblogs.com/qiuhom-1874/p/16186451.html)；今天我们来聊一聊ARP代理相关话题；

　　端口隔离之破解之道

　　前文我们通过抓包可以看到，当同一vlan下的端口做了双向端口隔离或者单向端口隔离以后，对应的端口就不能正常通信；其中最主要的原因是通信双方在通信时，拿不到对方的mac；拿不到通信对方的mac，以太网二层封装就封装不了，从而导致通信无法正常进行；那怎么打破端口隔离这样的限制呢？其实也很简单，我们找一个中间设备或接口，该接口能够和通信双方正常通信，然后赋予该接口转发arp的功能，是不是可以实现做过端口隔离的双方实现通信呢？

　　代理ARP

　　所谓代理ARP是指，如果ARP请求是从一个网络的主机发往同一网段，却不再同一物理物理网络上的另一台主机（即相互隔离的同一网段内的主机），那么连接它们的具有代理ARP功能的设备就可以回答该请求，这个过程就叫做代理ARP（Proxy ARP）；代理ARP屏蔽了分离的物理网络，使用户使用起来就好像在同一物理网络上一样；代理ARP可以分为两大类，一类是连接相同三层接口的本地代理和连接不同三层接口的普通代理arp；

　　普通代理ARP

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424225036866-589348992.png)

　　提示：普通代理ARP是通信双方分别连接到设备的不同三层接口上，且这些主机不再同一广播域上；如上图主机A和主机B，分别连接路由器的两个端口上；但是主机A和主机B通信时，由于掩码都是16位，网络地址都一样，所以主机A和主机B通信时，它们都会先发送ARP请求（因为同一网段，不需要找网关）；但是主机A或主机B如果直接发送arp请求，都会被路由器分割，所以导致通信无法正常进行；要想正常进行，我们需要在路由器的两个接口上开启代理ARP，这样主机A或主机B发送的arp请求都会通过开启路由器代理arp的接口转发，从而实现拿到对方mac实现通信；

　　本地代理ARP

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424225937422-1205976188.png)

　　提示：本地代理ARP就是指想要互通的主机连接到设备的同一个三层接口上，且这些主机不再同一广播域中；如上图主机A和主机B都同属VLAN2 且有做了双向端口隔离，此时主机A和主机B的通信就依赖一个三层接口来代理ARP实现通信；

　　实验：在交换机上我们做了pc1和pc2双向端口隔离，pc1和pc3做了单向端口隔离，在不取消端口隔离的情况下是实现pc1和pc2、pc3互通

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424231225014-1799822059.png)

　　交换机配置

![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

sys
sys sw1
vlan 12
int g0/0/1
port link\-type access
port default vlan 12
int g0/0/2
port link\-type access
port default vlan 12
int g0/0/3
port link\-type access
port default vlan 12
int g0/0/1
port\-isolate en
int g0/0/2
port\-isolate en 
int g0/0/3
am isolate g0/0/1

View Code

　　验证隔离信息

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424231712809-620060169.png)

　　验证：pc1和pc2、pc3的互通性

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424231822817-242043592.png)

　　提示：现在pc1和pc2、pc3都是不通的；

　　在交换机上启用一个vlanif12的接口，并配置和pc1、pc2同网段ip地址

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424232051274-1200072530.png)

　　在vlanif 12接口上开启同vlan内arp代理

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424232226984-1493687077.png)

　　提示：在三层交换机上开启arp代理分同一vlan内的arp代理和不同vlan间的arp代理；上述实验环境需要在三层接口上开启同一vlan内的arp代理；arp-proxy 这个命令是路由器上开启arp代理；

　　验证：pc1和pc2、pc3的互通性

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424232541405-1419920350.png)

　　提示：可以看到现在pc1和pc2、pc3都能正常通信；

　　在pc1上查看arp表

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424232701861-1111920273.png)

　　提示：可以看到在pc1上pc2和pc3的mac地址都是同vlanif 12接口mac地址一样，这是为什么呢？其实从上面的mac地址表我们就能想到，pc1和pc2、pc3通信都是用的vlanif 12的mac，这是因为pc1和pc2、pc3通信时发送arp请求，对应回复pc1的都是vlanif12接口；

　　清空三台pc上的arp地址表和交换机的mac地址表，抓包查看其过程

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424234219930-428169301.gif)

　　提示：可以看到pc1pingpc2时，首先是pc1发送arp广播，说谁是1.0.0.2，请告诉我你的mac地址，此时vlanif 12收到pc1发送的arp广播后，它一看自己的路由表是可以直接到达1.0.0.2，所以它就把自己的mac地址告诉pc1，然后vlanif 12又发送arp请求，说谁是1.0.0.2，请把mac地址告诉1.0.0.12，此时pc2收到arp广播后，就把自己的mac告诉1.0.0.12，后续pc发送数据给vlanif12 ，vlanif12 通过拆除以太网二层包头，然后又用pc2的mac地址作为目标mac封装以太网二层包头发送给pc2；pc1同pc3的通信过程同pc1和pc2的过程一样；

　　端口隔离之防破解之道

　　通过上述实验可以看到如果我们在三层交换机上创建vlanif接口，并开启arp代理，那么我们之前配置的端口隔离就失效了，那怎么避免呢？其实很简单，默认情况下端口隔离只是隔离的二层，如果我们想要把三层也给隔离了，只需要修改端口隔离模式为all即可，如下所示

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220425005901437-13246676.png)

　　验证：pc1和pc2、pc3的互通性

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220425010138820-64814546.png)

　　提示：可以看到现在把隔离模式修改为all以后，即便我们在交换机上创建了vlanif接口，也开启了arp代理，对应通信还是被隔离的；这是因为之前只是隔离二层，现在修改隔离模式为all，表示二层和三层都做隔离；所以现在即便有三层接口，也开启了arp代理，对应通信也是被隔离的；

　　代理arp之写静态路由出接口和下一跳区别

　　在前边聊静态路由时，我们特意提到在写静态路由时，如果是以太网链路上，我们推荐写下一跳地址，不推荐写出接口，这是为什么呢？先看一个实验

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220424235849483-2111450742.png)

　　如上实验环境，我们在R1上配置静态路由时，为什么推荐写下一跳呢？

　　写下一跳，然后r1 ping 2.2.2.2 抓包查看其过程

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220425000242987-989352309.png)

　　在R1抓包看看通信过程

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220425000506345-1750317328.gif)

　　提示：可以看到R1ping 2.2.2.2时，根据静态路由，它首先会发送arp请求下一跳的arp；

　　静态路由改写成出接口，看看对应通信又有什么变化呢？

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220425000732016-807504816.png)

　　在R1上抓包，看看通信过程

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220425000908203-58857113.gif)

　　提示：可以看到当我们写静态路由写成出接口后，R1会直接问2.2.2.2的mac地址，它会认为2.2.2.2和本地直连；这样一来会导致一个问题就是拿不到2.2.2.2的mac；从而导致通信无法正常完成；

　　分析：之所以在以太网环境中写静态路由推荐写下一跳地址，是因为写下一跳，路由器会发送要下一跳的mac地址，从而实现通信；写出接口就是告诉路由器去往目标网段，直接将数据发送给对应出接口即可；这样一来导致路由器认为目标网段和出接口直连（误认为出接口和目标地址在同一广播域，所以它就直接发送arp请求目标地址的mac地址），从而导致拿不到目标网段的mac，导致通信无法正常完成；

　　在R2上开启arp代理，实现通信

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220425001730460-117991549.png)

　　验证：R1ping2.2.2.2看看是否能通？

![](https://img2022.cnblogs.com/blog/1503305/202204/1503305-20220425001838091-911558898.png)

　　提示：可以看到在R2上开启arp代理以后，对应通信就能正常进行；这是因为R1发送arp请求2.2.2.2的mac地址，R2的g0/0/0口收到arp请求以后，一看自己的路由表中能够到达2.2.2.2,且该接口也开启了arp代理，所以它会把自己的mac告诉给R1，然后R1有了2.2.2.2的mac后，后续就可以直接封装以太网包头发送数据；

　　那为什么点到点的串行链路中写下一跳或出接口都行呢？

　　因为，串行链路中不需要封装mac地址！！！

作者：[Linux-1874](https://www.cnblogs.com/qiuhom-1874/)

出处：[https://www.cnblogs.com/qiuhom-1874/](https://www.cnblogs.com/qiuhom-1874/)

本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.