---
layout: post
title: "动态规划"
date: "2023-02-03T07:15:10.939Z"
---
动态规划
====

###        动态规划程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。不像前面所述的那些搜索或数值计算那样，具有一个标准的数学表达式和明确清晰的解题方法。动态规划程序设计往往是针对一种最优化问题，由于各种问题的性质不同，确定最优解的条件也互不相同，因而动态规划的设计方法对不同的问题，有各具特色的解题方法，而不存在一种万能的动态规划算法，可以解决各类最优化问题。因此读者在学习时，除了要对基本概念和方法正确理解外，必须具体问题具体分析处理，以丰富的想象力去建立模型，用创造性的技巧去求解。我们也可以通过对若干有代表性的问题的动态规划算法进行分析、讨论，逐渐学会并掌握这一设计方法。

* * *

第一节 动态规划的基本模型：
==============

多阶段决策过程的最优化问题。
--------------

### 在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。当然，各个阶段决策的选取不是任意确定的，它依赖于当前面临的状态，又影响以后的发展，当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线，这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题就称为多阶段决策问题。如下图所示：

![](https://img2023.cnblogs.com/blog/3084775/202302/3084775-20230203083237773-473666009.png)

### 多阶段决策过程，是指这样的一类特殊的活动过程，问题可以按时间顺序分解成若干相互联系的阶段，在每一个阶段都要做出决策，全部过程的决策是一个决策序列。

* * *

典型例题：
-----

### 【例1】最短路径问题。下图给出了一个地图，地图中的每个顶点代表一个城市，两个城市间的一条连线代表道路，连线上的数值代表道路的长度。现在想从城市A到达城市E，怎样走路程最短？最短路程的长度是多少？

![](https://img2023.cnblogs.com/blog/3084775/202302/3084775-20230203083555240-1749682842.png)

### 【算法分析】 把A到E的全过程分成四个阶段，用K表示阶段变量，第1阶段有一个初始状态A，有两条可供选择的支路A-B1、A-B2；第2阶段有两个初始状态B1、B2，B1有三条可供选择的支路，B2有两条可供选择的支路……。用DK（XI，X+1J）表示在第K阶段由初始状态XI到下阶段的初始状态X+1J的路径距离，FK（XI）表示从第K阶段的XI到终点E的最短距离，利用倒推的方法，求解A到E的最短距离。

###  具体计算过程如下： S1： K = 4 有 F4（D1）= 3，

### 　　　　　　　　    F4（D2）= 4， F4（D3）= 3；

### 　　　　　　　　　S2： K = 3 有 F3（C1）= MIN{ D3（C1，D1）+ F4（D1），D3（C1，D2）+ F4（D2）} = MIN{ 5+3，6+4 } = 8

### 　　　　　　　　　 F3（C2）= D3（C2，D1）+ F4（D1）= 5+3 = 8

### 　　　　　　　　　 F3（C3）= D3（C3，D3）+ F4（D3）= 8+3 = 11

### 　　　　　　　　　F3（C4）= D3（C4，D3）+ F4（D3）= 3+3 = 6

### 　　　　　　　　　S3： K = 2 有 F2（B1）= MIN{ D2（B1，C1）+ F3（C1），

### 　　　　　　　　　D2（B1，C2）+ F3（C2）， D2（B1，C3）+ F3(C3)} = MIN{ 1+8,6+8,3+11} = 9

### 　　　　　　　　　F2（B2）= MIN{ D2（B2，C2）+ F3（C2），D2（B2，C4）+ F3（C4）} = MIN{ 8+8，4+6 } = 10

### 　　　　　　　　　S4： K = 1 有 F1（A）= MIN{ D1（A，B1）+ F2（B1），D1（A，B2）+ F2（B2）} = MIN{ 5+9，3+10} = 13

### 　　因此由A点到E点的全过程最短路径为A→B2→C4→D3→E；最短路程长度为13。 从以上过程可以看出，每个阶段中，都求出本阶段的各个初始状态到终点E的最短距离，当逆序倒推到过程起点A时，便得到了全过程的最短路径和最短距离。 在上例的多阶段决策问题中，各个阶段采取的决策，一般来说是与阶段有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，我们称这种解决多阶段决策最优化的过程为动态规划程序设计方法。

* * *

动态规划的基本概念和基本模型构成：
-----------------

###        现在我们来介绍动态规划的基本概念。 1. 阶段和阶段变量： 用动态规划求解一个问题时，需要将问题的全过程恰当地分成若干个相互联系的阶段，以便按一定的次序去求解。描述阶段的变量称为阶段变量，通常用K表示，阶段的划分一般是根据时间和空间的自然特征来划分，同时阶段的划分要便于把问题转化成多阶段决策过程，如例题1中，可将其划分成4个阶段，即K = 1，2，3，4。 2. 状态和状态变量： 某一阶段的出发位置称为状态，通常一个阶段包含若干状态。一般地，状态可由变量来描述，用来描述状态的变量称为状态变量。如例题1中，C3是一个状态变量。 3. 决策、决策变量和决策允许集合： 在对问题的处理中作出的每种选择性的行动就是决策。即从该阶段的每一个状态出发，通过一次选择性的行动转移至下一阶段的相应状态。一个实际问题可能要有多次决策和多个决策点，在每一个阶段的每一个状态中都需要有一次决策，决策也可以用变量来描述，称这种变量为决策变量。在实际问题中，决策变量的取值往往限制在某一个范围之内，此范围称为允许决策集合。如例题1中，F3（C3）就是一个决策变量。 4．策略和最优策略： 所有阶段依次排列构成问题的全过程。全过程中各阶段决策变量所组成的有序总体称为策略。在实际问题中，从决策允许集合中找出最优效果的策略成为最优策略。 5. 状态转移方程 前一阶段的终点就是后一阶段的起点，对前一阶段的状态作出某种决策，产生后一阶段的状态，这种关系描述了由k阶段到k+1阶段状态的演变规律，称为状态转移方程。

最优化原理与无后效性：
-----------

### 　　上面已经介绍了动态规划模型的基本组成，现在需要解决的问题是：什么样的“多阶段决策问题”才可以采用动态规划的方法求解。 一般来说，能够采用动态规划方法求解的问题，必须满足最优化原理和无后效性原则： 1、动态规划的最优化原理。作为整个过程的最优策略具有：无论过去的状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略的性质。也可以通俗地理解为子问题的局部最优将导致整个问题的全局最优，即问题具有最优子结构的性质，也就是说一个问题的最优解只取决于其子问题的最优解，而非最优解对问题的求解没有影响。在例题1最短路径问题中，A到E的最优路径上的任一点到终点E的路径，也必然是该点到终点E的一条最优路径，即整体优化可以分解为若干个局部优化。 2、动态规划的无后效性原则。所谓无后效性原则，指的是这样一种性质：某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响。也就是说，“未来与过去无关”，当前的状态是此前历史的一个完整的总结，此前的历史只能通过当前的状态去影响过程未来的演变。在例题1最短路径问题中，问题被划分成各个阶段之后，阶段K中的状态只能由阶段K+1中的状态通过状态转移方程得来，与其它状态没有关系，特别与未发生的状态没有关系，例如从Ci到E的最短路径，只与Ci的位置有关，它是由Di中的状态通过状态转移方程得来，与E状态，特别是A到Ci的路径选择无关，这就是无后效性。 由此可见，对于不能划分阶段的问题，不能运用动态规划来解；对于能划分阶段，但不符合最优化原理的，也不能用动态规划来解；既能划分阶段，又符合最优化原理的，但不具备无后效性原则，还是不能用动态规划来解；误用动态规划程序设计方法求解会导致错误的结果。

* * *

* * *

第二节 背包问题
========

一、01背包问题
--------

### 　　 问题： 有N件物品和一个容量为V的背包。第i件物品的费用（即体积，下同）是w\[i\]，价值是c\[i\]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路： 　　这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 　　用子问题定义状态：即f\[i\]\[v\]表示前i件物品(部分或全部)恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f\[i\]\[v\]=max{f\[i-1\]\[v\],f\[i-1\]\[v-w\[i\]\]+c\[i\]}。 　　这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-w\[i\]的背包中”，此时能获得的最大价值就是f \[i-1\]\[v-w\[i\]\]再加上通过放入第i件物品获得的价值c\[i\]。

### 　　注意f\[i\]\[v\]有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是f\[N\]\[V\]，而是f\[N\]\[0..V\]的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f\[i-1\]\[v\]，这样就可以保证f\[N\]\[V\]就是最后的答案。但是若将所有f\[i\]\[j\]的初始值都赋为0，你会发现f\[n\]\[v\]也会是最后的答案。为什么呢？因为这样你默认了最开始f\[i\]\[j\]是有意义的，只是价值为0，就看作是无物品放的背包价值都为0，所以对最终价值无影响，这样初始化后的状态表示就可以把“恰”字去掉。

* * *

优化空间复杂度 　　
----------

### 　　以上方法的时间和空间复杂度均为O(N\*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。 　

### 　先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f\[i\]\[0..V\]的所有值。那么，如果只用一个数组f \[0..V\]，能不能保证第i次循环结束后f\[v\]中表示的就是我们定义的状态f\[i\]\[v\]呢？f\[i\]\[v\]是由f\[i-1\]\[v\]和f\[i-1\]\[v-w\[i\]\]两个子问题递推而来，能否保证在推f\[i\]\[v\]时（也即在第i次主循环中推f\[v\]时）能够得到f\[i-1\]\[v\]和f\[i-1\]\[v-w\[i\]\]的值呢？事实上，这要求在每次主循环中我们以v=V..0的逆序推f\[v\]，这样才能保证推f\[v\]时f\[v-w\[i\]\]保存的是状态f\[i-1\]\[v-w\[i\]\]的值。 伪代码如下： 　　for i=1..N 　　　for v=V..0　　　　　f\[v\]=max{f\[v\],f\[v-w\[i\]\]+c\[i\]}; 　　其中f\[v\]=max{f\[v\],f\[v-w\[i\]\]+c\[i\]}相当于转移方程f\[i\]\[v\]=max{f\[i-1\]\[v\],f\[i-1\]\[v-w\[i\]\]+c\[i\]}，因为现在的f\[v-w\[i\]\]就相当于原来的f\[i-1\]\[v-w\[i\]\]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f\[i\]\[v\]由f\[i\]\[v-w\[i\]\]推知，与本题意不符，但它却是另一个重要的完全背包问题最简捷的解决方案，故学习只用一维

### 数组解01背包问题是十分必要的。

### 　　总结: 　　01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体

### 会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。

* * *

二、完全背包问题
--------

### 问题: 　　　有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是w\[i\]，价值是c\[i\]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

### 基本思路: 　　 这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f\[i\]\[v\]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f\[i\]\[v\]=max{f\[i-1\]\[v-k\*w\[i\]\]+k\*c\[i\]|0<=k\*w\[i\]<= v}。 　　将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。 　　这个算法使用一维数组，先看伪代码： 　　for i=1..N 　　　for v=0..V 　　　　 f\[v\]=max{f\[v\],f\[v-w\[i\]\]+c\[i\]}; 　　 你会发现，这个伪代码与01背包问题的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么01背包问题中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f\[i\]\[v\]是由状态f\[i-1\]\[v-w\[i\]\]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f\[i-1\]\[v-w\[i\]\]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f\[i\]\[v-w\[i\]\]，所以就可以并且必须采用v= 0..V的顺序循环。这就是这个简单的程序为何成立的道理。 　　 这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：f\[i\]\[v\]=max{f\[i-1\]\[v\],f\[i\]\[v-w\[i\]\]+c\[i\]}，将这个方程用一维数组实现，便得到了上面的伪代码。一个简单有效的优化 　　 完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足w\[i\]<=w\[j\]且c\[i\]>=c\[j\]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高的j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。 转化为01背包问题求解 　　 既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/w\[i\]件，于是可以把第i种物品转化为V/w\[i\]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。 　　更高效的转化方法是：把第i种物品拆成费用为w\[i\]\*2^k、价值为c\[i\]\*2^k的若干件物品，其中k满足w\[i\]\*2^k<V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log(V/w\[i\])+1)件物品，是一个很大的改进。 总结 　　 完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。

* * *

三、多重背包问题
--------

### 有N种物品和一个容量为V的背包。第i种物品最多有n\[i\]件可用，每件费用是w\[i\]，价值是c\[i\]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

### 基本算法: 　　 这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n\[i\]+1种策略：取0件，取1件……取n\[i\]件。令f\[i\]\[v\]表示前i种物品恰放入一个容量为v的背包的最大权值，则：f\[i\]\[v\]=max{f\[i-1\]\[v-k\*w\[i\]\]+ k\*c\[i\]|0<=k<=n\[i\]}。复杂度是O(V\*∑n\[i\])。 转化为01背包问题 　　 另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n\[i\]件01背包中的物品，则得到了物品数为∑n\[i\]的01背包问题，直接求解，复杂度仍然是O(V\*∑n\[i\])。 　　 但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n\[i\]件——均能等价于取若干件代换以后的物品。另外，取超过n\[i\]件的策略必不能出现。 　　 方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,...,2^(k-1),n\[i\]-2^k+1，且k是满足n\[i\]-2^k+1>0的最大整数(注意：这些系数已经可以组合出1~n\[i\]内的所有数字)。例如，如果n\[i\]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。 　　 分成的这几件物品的系数和为n\[i\]，表明不可能取多于n\[i\]件的第i种物品。另外这种方法也能保证对于0..n\[i\]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n\[i\]两段来分别讨论得出，并不难，希望你自己思考尝试一下。 　　 这样就将第i种物品分成了O(logn\[i\])种物品，将原问题转化为了复杂度为O(V\*∑logn\[i\])的01背包问题，是很大的改进。

* * *

四、混合三种背包问题
----------

### 　　问题 　　　如果将01背包、完全背包、多重背包混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？ 01背包与完全背包的混合 　　考虑到在01背包和完全背包中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)。 伪代码如下： for i=1..N 　if 第i件物品是01背包　　for v=V..0 　　　f\[v\]=max{f\[v\],f\[v-w\[i\]\]+c\[i\]}; 　else if 第i件物品是完全背包 　　for v=0..V 　　　f\[v\]=max{f\[v\],f\[v-w\[i\]\]+c\[i\]};

### 再加上多重背包 　　如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN)的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用多重背包中将每个这类物品分成O(logn\[i\])个01背包的物品的方法也已经很优了。

### 　　有人说，困难的题目都是由简单的题目叠加而来的。这句话是否是公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。

* * *

五、二维费用的背包问题
-----------

### 　　问题 　　　二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a\[i\]和b\[i\]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为c\[i\]。

### 　　算法 　　费用加了一维，只需状态也加一维即可。设f\[i\]\[v\]\[u\]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。 　　状态转移方程就是：f \[i\]\[v\]\[u\]=max{f\[i-1\]\[v\]\[u\],f\[i-1\]\[v-a\[i\]\]\[u-b\[i\]\]+c\[i\]}。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。 物品总个数的限制 　　有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f\[v\]\[m\]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f\[0..V\]\[0..M\]范围内寻找答案。 另外，如果要求“恰取M件物品”，则在f\[0..V\]\[M\]范围内寻找答案。

### 　　小结 事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一维以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。

* * *

六、分组的背包问题
---------

### 　　 问题 　　　有N件物品和一个容量为V的背包。第i件物品的费用是w\[i\]，价值是c\[i\]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包

### 可使这些物品的费用总和不超过背包容量，且价值总和最大。

### 　　 算法 　　这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f\[k\]\[v\]表示前k组物品花费费用v能取得的最大权值，则有f\[k\]\[v\]=max{f\[k-1\]\[v\]，f\[k-1\]\[v-w\[i\]\]+c\[i\]|物品i属于第k组}。 使用一维数组的伪代码如下： for 所有的组k for v=V..0 for 所有的i属于组k 　　　　　　f\[v\]=max{f\[v\],f\[v-w\[i\]\]+c\[i\]} 　　注意这里的三层循环的顺序，“for v=V..0”这一层循环必须在“for 所有的i属于组k”之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。 另外，显然可以对每组中的物品应用完全背包中“一个简单有效的优化”。

* * *

七、有依赖的背包问题
----------

### 　　简化的问题 这种背包问题的物品间存在某种“依赖”的关系。也就是说，i依赖于j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 算法 这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。 按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有n个附件，则策略有2^n+1个，为指数级。） 考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于分组的背包中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。 再考虑分组的背包中的一句话： 可以对每组中的物品应用完全背包中“一个简单有效的优化”。这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件i的“附件集合”先一次01背包，得到费用依次为0..V-w\[i\]所有这些值时相应的最大价值f'\[0..V-w\[i\]\]。那么这个主件及它的附件集合相当于V-w\[i\]+1个物品的物品组，其中费用为w\[i\]+k的物品的价值为f'\[k\]+c\[i\]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为 V-w\[i\]+1个物品的物品组，就可以直接应用分组的背包的算法解决问题了。 更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。 解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。 事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。

　　小结     
---------

　　NOIP2006的那道背包问题，通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。
------------------------------------------------------------------------------------------------------------------------------------------------------

* * *

八、背包问题的方案总数 　　
--------------

### 　　对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。 　　对于这类改变问法的问题，一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是01背包中的物品，转移方程即为f\[i\]\[v\]=sum{f\[i-1\]\[v\],f\[i-1\]\[v-w\[i\]\]+c\[i\]}，初始条件f\[0\]\[0\]=1。 　　事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。

### 　　小结 　　 显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。 　　触类旁通、举一反三，应该也是一个OIer应有的品质吧。

* * *

* * *

记忆化搜索的应用
========

### 　　一般来说，动态规划总要遍历所有的状态，而搜索可以排除一些无效状态。更重要的是搜索还可以剪枝，可能剪去大量不必要的状态，因此在空间开销上往往比动态规划要低很多。 如何协调好动态规划的高效率与高消费之间的矛盾呢？有一种折中的办法就是记忆化算法。记忆化算法在求解的时候还是按着自顶向下的顺序，每求解一个状态，就将它的解保存下来，以后再次遇到这个状态的时候，就不必重新求解了。这种方法综合了搜索和动态规划两方面的优点，因而还是很有使用价值的。举一个例子：如下图所示是一个有向无环图，求从顶点1到顶点6的最长路径。（规定边的方向从左到右）

![](https://img2023.cnblogs.com/blog/3084775/202302/3084775-20230203085219775-1125744789.png)

### 　　我们将从起点（顶点1）开始到某个顶点的最长路径作为状态，用一维数组opt记录。Opt\[j\]表示由起点到顶点j时的最长路径。显然，opt\[1\]=0，这是初始状态，即动态规划的边

### 界条件。于是，我们很容易地写出状态转移方程式：opt\[j\]=max{opt\[k\]+a\[k\]\[j\]}（k到j有一条长度为a\[k\]\[j\]的边）。虽然有了完整的状态转移方程式，但是还是不知道动态规划的顺序。所以，还需要先进行一下拓扑排序，按照排序的顺序推下去，opt\[6\]就是问题的解。 可以看出，动态规划相比搜索之所以高效，是因为它将所有的状态都保存了下来。当遇到重复子问题时，它不像搜索那样把这个状态的最优值再计算一遍，只要把那个状态的最优值调出来就可以了。例如，当计算opt\[4\]和opt\[5\]时，都用到了opt\[3\]的值。因为已经将它保存下来了，所以就没有必要再去搜索了。 但是动态规划仍然是有缺点的。一个很突出的缺点就是要进行拓扑排序。这道题的拓扑关系是很简单的，但有些题的拓扑关系是很复杂的。对于这些题目，如果也进行拓扑排序，工作量非常大。遇到这种情况，我们可以用记忆化搜索的方法，避免拓扑排序。

码字不易，一键三连再走吧！
-------------

本文来自博客园，作者：[张其勋](https://www.cnblogs.com/zhangqixun/)，转载请注明原文链接：[https://www.cnblogs.com/zhangqixun/p/17087966.html](https://www.cnblogs.com/zhangqixun/p/17087966.html)