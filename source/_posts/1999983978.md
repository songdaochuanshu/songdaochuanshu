---
layout: post
title: "『忘了再学』Shell基础 — 29、AWK内置变量"
date: "2022-06-10T11:22:37.840Z"
---
『忘了再学』Shell基础 — 29、AWK内置变量
==========================

目录

*   [1、AWK内置变量](#1awk内置变量)
*   [2、练习说明](#2练习说明)
    *   [（1）`$n`变量练习](#1n变量练习)
    *   [（2）`FS`变量练习](#2fs变量练习)
    *   [（3）`NF`变量和`NR`变量练习](#3nf变量和nr变量练习)
*   [3、总结：](#3总结)

1、AWK内置变量
---------

AWK内置变量如下表：

awk内置变量

作用

`$0`

代表目前AWK所读入的整行数据。我们已知AWK是一行一行读入数据的，`$0`就代表当前读入行的整行数据。

`$n`

代表目前读入行的第n个字段。

`NF`

当前行拥有的字段（列）总数。

`NR`

当前AWK所处理的行，是总数据的第几行。

`FS`

用户定义分隔符。AWK的默认分隔符是任何空格（tab键或者空格），如果想要使用其他分隔符（如“：”），就需要`FS`变量定义。

`ARGC`

命令行参数个数。

`ARGV`

命令行参数数组。

`FNR`

当前文件中的当前记录数（对输入文件起始为1）。

`OFMT`

数值的输出格式（默认为`%.6g`）。

`OFS`

输出字段的分隔符（默认为空格）。

`ORS`

输出记录分隔符（默认为换行符）。

`RS`

输入记录分隔符（默认为换行符）。

2、练习说明
------

### （1）`$n`变量练习

使用如下文本：

    ID      Name    Python  Linux   MySQL   Java
    1       Tangs   88      87      86      85.55
    2       Sunwk   99      98      97      96,66
    3       Zhubj   77      76      75      74.44
    4       Shahs   66      65      64      63.33
    

比如我们提取文本中的第2列数据，执行如下命令：

    [root@localhost tmp]# awk '{printf $2 "\n"}' student.txt
    Name
    Tangs
    Sunwk
    Zhubj
    Shahs
    

### （2）`FS`变量练习

AWK的默认分隔符是任何空格（`tab`键或者空格），如果想要使用其他分隔符，就需要`FS`变量定义。

`cut`命令默认是以`tab`键做为分隔符。

我们之前用`cut`命令提取过`/etc/passwd`文件中普通用户的用户名，现在我们来用AWK来提取能正常登陆用户的用户名。

执行如下命令：

    [root@localhost tmp]# cat /etc/passwd | grep "/bin/bash" | awk '{FS=":"} {printf $1 "\n"}'
    root:x:0:0:root:/root:/bin/bash
    user1
    user2
    

> 说明：`FS`变量指定分隔符是一个单独的动作，而打印输出是另外一个动作。

看到上面的结果我们会发现，`user1`和`user2`用户的信息正确提取了，而第一行`root`用户的信息，是把整行的数据都打印输出了，没有按`:`冒号做为分隔符来正确的提取。

是因为AWK先把一行数据读取进AWK中，然后在用后面的动作，再对读入的数据进行处理。

也就是说我已经把第一行的`root`用户的信息，已经读入到awk中，`$0`、`$1`、`$2`等变量已经赋值好了，然后才在后边的动作中看到你指定了`:`冒号作为分隔符，这个时候第一行数据已经来不及处理了，只能用AWK默认的处理方式，用空格作为分隔符来处理，这一行没有空格，就会把这一行的所有数据全部打印出来了。

到了处理第二行数据的时候，AWK已经知道要用`:`冒号作为分隔符，这个时候就可以正确处理数据了。

现在就需要用的`BEGIN`来处理这个问题，把分隔符的指定`{FS=":"}`放入`BEGIN`中就可以了。

    [root@localhost tmp]# cat /etc/passwd | grep "/bin/bash" | awk 'BEGIN{FS=":"} {printf $1 "\n"}'
    root
    user1
    user2
    

这样就可以正确提取到我们需要的数据了。

所以在使用AWK的时候，如果需要手动指定分隔符，要把这个指定分隔符的动作写在`BEGIN`中。

> 总结：如果有明显的分隔符，推荐优先使用`cut`命令，因为简单。

但是如果需要一些判断的话，比如我需要根据用户ID，查看某一个用户的用户名。

这个时候用AWK就方便很多，`cut`命令就不能直接处理了，需要写脚本程序进行过滤。

比如打印`uid=500`的用户的用户名，命令如下：

    [root@localhost tmp]# cat /etc/passwd | grep "/bin/bash" | awk 'BEGIN{FS=":"} $3=="500" {printf $1 "\n"}'
    user1
    
    # $3=="500"也可以写成$3==500或者$3=/500/都可以
    

### （3）`NF`变量和`NR`变量练习

我们还是以`/etc/passwd`文件中的内容为例，需求打印输出可登录的用户的用户名，用户ID，行号，字段数（也就是列数）。

执行如下命令：

    # 提示：写法是，输出格式在双引号里，变量在双引号外。
    [root@192 tmp]# cat /etc/passwd | grep "/bin/bash" | awk 'BEGIN{FS=":"} {printf $1 "\t" $3 "\t 行号：" NR "\t 字段数：" NF "\n"}'
    root    0    行号：1    字段数：7
    user1   500  行号：2    字段数：7
    user2   501  行号：3    字段数：7
    
    

注意一下，最终传入AWK中处理的数据就三行，如下：

    [root@192 tmp]# cat /etc/passwd | grep "/bin/bash"
    root:x:0:0:root:/root:/bin/bash
    user1:x:500:500::/home/user1:/bin/bash
    user2:x:501:501::/home/user2:/bin/bash
    

3、总结：
-----

> 我们就学会前5个AWK内置变量就可以了，后边的AWK内置变量一般用不到，换句话说就是能用Shell处理的，就少用AWK处理，以后如果真要用到AWK进行更深层次的编程，自己再单独的学习一下AWK。