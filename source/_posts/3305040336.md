---
layout: post
title: "粘包拆包及解决方案"
date: "2023-01-05T13:24:50.427Z"
---
粘包拆包及解决方案
=========

#### 一、粘包与拆包是什么？

TCP在接受数据的时候，有一个滑动窗口来控制接受数据的大小，这个滑动窗口你就可以理解为一个缓冲区的大小。缓冲区满了就会把数据发送。数据包的大小是不固定的，有时候比缓冲区大有时候小。  
如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；  
如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包，也就是将一个大的包拆分为多个小包进行发送。

举例：

当发送方发送了数据包 \`消息1：ABC\` 和 \`消息2：DEF\` 时,但接收方接收到的数据包却是 \`消息：ABCDEF\`,像这种一次性读取了两条数据包的数据粘连在一起的情况就叫做粘包(正常情况应该是一条一条读取的)。`   `

![](https://img2023.cnblogs.com/blog/1923561/202301/1923561-20230105200600917-2031636843.png)

  当发送方发送了数据包 \` 消息1：ABC \` 和 \`消息2：DEF\` 时,接收方接收到数据包经拆分后获得了 \`ABCD\` 和 \`EF\` 两个数据包信息的情况,像这种情况有时候也叫做半包。

![](https://img2023.cnblogs.com/blog/1923561/202301/1923561-20230105200645225-679910973.png)

#### 二、粘包与拆包为什么发生？

1.TCP会发生粘包问题：TCP 是面向连接的传输协议,TCP 传输的数据是以流的形式,而流数据是没有明确的开始结尾边界,所以 TCP 也没办法判断哪一段流属于一个消息;TCP协议是流式协议;所谓流式协议,即协议的内容是像流水一样的字节流,内容与内容之间没有明确的分界标志,需要认为手动地去给这些协议划分边界。  
粘包时：发送方每次写入数据 < 接收方套接字(Socket)缓冲区大小。  
拆包时：发送方每次写入数据 > 接收方套接字(Socket)缓冲区大小。  

2.UDP不会发生粘包问题：UDP具有保护消息边界,在每个UDP包中就有了消息头(UDP长度、源端口、目的端口、校验和)。

#### 三、遇到粘包、拆包怎么办？

对于粘包和拆包问题，常见的解决方案有四种：

1.      客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式**补全到指定长度**；
2.      客户端在每个包的末尾使用固定的分隔符，例如\\r\\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\\r\\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；
3.      将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；
4.      通过自定义协议进行粘包和拆包的处理。