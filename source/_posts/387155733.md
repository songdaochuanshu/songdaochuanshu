---
layout: post
title: "最容易懂的策略模式消除if-else分支，实现开闭原则，提高可扩展性"
date: "2023-02-04T16:20:46.549Z"
---
最容易懂的策略模式消除if-else分支，实现开闭原则，提高可扩展性
==================================

### 1 介绍

策略模式最常用的场景就是用于消除代码中的`if-else`，这里所说的`if-else`并不是说任何简单的判断都引入策略模式来优化，这样反而会增加代码的复杂度。

反例：使用策略模式对一个`boolean`类型的变量进行优化

### 2 背景

我负责的有一个基于流程引擎开发的项目，有一个功能模块是查看申请单的详情，由于不同的申请单展示的信息各不相同，最开始负责这部分功能开发的同学使用`if-else`来判断申请单的类型，并对不同的申请单做不同的处理。

由于系统中的申请单越来越多，这部分的`if-else`分支也变得臃肿，而且每次新增申请单的时候，都需要在后面再加一个分支，不仅破坏了开闭原则，而且可读性极差，也不利于扩展。

![](https://img2023.cnblogs.com/blog/2039746/202302/2039746-20230204172936877-887867777.png)

### 3 引入策略接口

![](https://img2023.cnblogs.com/blog/2039746/202302/2039746-20230204173054796-784849708.png)

不同的申请单有自己处理detail的逻辑，实现这个策略接口，重写 `doDetail()`即可

这是一个默认实现：

![](https://img2023.cnblogs.com/blog/2039746/202302/2039746-20230204173111515-227422919.png)

### 4 引入策略上下文对象

有了策略接口后，现在需要一个上下文对象将所有的策略放在一个集合中，方便后续调用

![](https://img2023.cnblogs.com/blog/2039746/202302/2039746-20230204173031709-365486840.png)

这里使用了 spring 框架提供的 `applycationContext` 来获取策略接口的所有实现类，在策略上下文对象完成初始化后，将实现类注册到 `map` 中。（@PostConstruct：在bean初始化完成后处理一些逻辑）

### 5 客户端调用

只要持有 策略上下文对象，就能拿到策略接口的实现类，从而执行相关逻辑：

![](https://img2023.cnblogs.com/blog/2039746/202302/2039746-20230204172916619-1465380664.png)

### 6 总结

后续开发的同学添加申请单的时候，只需要新增一个详情类，实现策略接口，重写方法即可，大大提高了这部分功能的扩展性。

关于策略上下文对象使用集合存储所有策略的解释：使用 `Map` 来存储，需要一个key来标识使用哪种策略来处理。