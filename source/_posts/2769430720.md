---
layout: post
title: "第三周总结"
date: "2022-10-16T14:21:25.502Z"
---
第三周总结
=====

目录

*   [文件](#文件)
*   [函数](#函数)
*   [装饰器](#装饰器)
*   [递归函数和二分法](#递归函数和二分法)
*   [生成式](#生成式)
*   [内置函数](#内置函数)
*   [可迭代对象和迭代器对象](#可迭代对象和迭代器对象)
*   [异常捕获](#异常捕获)

文件
--

1.1 文件操作

    文件的概念：操作系统暴露给用户操作硬盘的快捷方式
    
    文件打开的两种方式：
    f=open(文件路径，读写模式，encoding='utf8')
    f.close
    
    with open('a.txt','r',encoding='utf8') as f1:
        with 子代码块
    	
    with支持一次性打开多个文件
    with open() as f1, open() as f2,open() as f3:
        子代码
    

1.2 文件读写模式

    'r' 只读模式: 只能读不能写
    1.文件路径不存在，会直接报错  2.文件路径存在，正常读取文件内容
    
    'w'  只写模式: 只能写不能看
    1.文件路径不存在，自动创建  2.文件路径存在：先清空文件内容，之后再写入
    
    'a' 只追加模式: 文件末尾添加数据
    1.文件路径不存在，自动创建  2.文件路径存在，自动在末尾等待追加内容
    

1.3 文件操作模式

    t 文本模式
    默认的模式，我们上面写的r w a 其实全称是rt wt at
    
    1.只能操作文本文件
    2.读写都是以字符为单位
    3.需要指定encoding参数 如果不知道则会采用计算机默认的编码
    
    b 二进制模式（bytes模式）
    不是默认的模式 需要自己指定rb wb ab
    
    1.可以操作任意类型的文件
    2.读写都是以bytes为单位
    3.不需要指定encoding参数，因为它已经是二进制模式，不需要编码
    

1.4 文件诸多方法

    read()  一次性读取所有内容
    for 循环  一行行读取文件内容，避免内存溢出现象的产生
    readline() 一次只读一行内容
    readlines() 一次性读取文件内容，会按照行数组织成列表的一个个数据值
    readable() 判断文件是否具备读数据的能力
    write()  写入数据
    writeable() 判断文件是否具备写数据能力
    writelines（）接收一个列表一次性将列表中所有的数据值写入
    flush（）将内存中文件数据立刻刷到硬盘
    

1.5 文件光标

    seek(offset,whence)
    offset 是位移量  以字节为单位
    whence是模式 0 1 2
    
    0 是基于文件开头， 文本和二进制模式都可以使用
    1 是基于当前位置 只有二进制模式可以使用
    2 是基于文件末尾  只有二进制可以使用
    

函数
--

2.1 函数的语法结构

    def 函数名(参数)：
        '''函数注释'''
        函数体代码
        return 返回值
    
    def  定义函数的关键字
    函数名  命名等于变量名
    参数  可有可无，主要是在使用函数的时候规定要不要外界传数据进来
    函数注释  类似于工具说明书
    函数体代码 是整个函数的核心 主要取决于程序员的编写
    return  使用函数之后可以返回给使用者的数据 可有可无
    

2.2 函数的定义与调用

    函数在定义阶段只检测语法，不执行代码
    函数在调用阶段才会执行函数体的代码
    函数必须先定义后调用
    

2.3 函数的分类

    空函数、无参函数、有参函数
    

2.4 函数的返回值

    返回值：调用函数之后返回给调用者的结果
    res = func() #先执行func函数，然后将返回值赋值给变量res
    
    函数返回值得多种情况
    函数体代码没有return关键字 默认返回None
    函数体代码有return 如果后面没有写任何东西还是返回None
    函数体代码有return 后面写什么就返回什么
    函数体代码有return并且后面有多个数据值 则自动组织成元组返回
    函数体代码遇到renturn会立刻结束
    

2.5 函数的参数

    形式参数：在函数定义阶段括号内填写的参数，简称'形参'
    实际参数：在函数调用阶段括号内填写的参数，简称'实参'
    

2.6 函数参数之位置参数

    位置形参：函数定义阶段括号内从左往右依次填写的变量名
    位置实参：函数调用阶段括号内从左往右依次填写的数据值
    

2.7 默认参数

    本质其实就是关键字参数，用户可以不传，也可以传
    """也遵循短的简单的靠前，长的复杂的靠后"""
    

2.8 可变长形参

    *args  星号在形参中作用：用于接收多余的位置参数，组织成元组赋值给星号后面的变量名
    **kwargs ：星号在形参中作用：用于接收多余关键字参数，组织成字典的形式赋值给两个星号后面的变量名
    

2.9 可变长实参

    *在实参中：类似于for循环，将所有循环遍历出来的数据按照位置参数一次性传给函数
    **在实参中：将字典打散成关键字参数的形式传递给函数
    

2.10 名称空间

    名称空间就是用来存储变量名和数据值绑定关系的地方
    内置名称空间：
    存活周期：python解释器启动创建，关闭销毁
    作用域：解释器级别的全局有效
    
    全局名称空间
    存活周期：py文件执行创建，运行结束销毁
    作用域：py文件级别的全局有效
    
    局部名称空间
    存活周期：函数体代码运行创建，函数体代码结束则销毁
    作用域：函数体代码内有效，运行结束则销毁
    

2.11 名字的查找顺序

    局部名称空间：局部名称空间-->全局名称-->内置名称空间
    全局名称空间：全局名称空间-->内置名称空间
    

2.12 global和nonlocal

    global：局部名称空间直接修改全局名称空间中的数据
    nonlocal：内部局部名称空间修改外层局部名称空间中的数据
    

2.13 函数名的多种用法

    1.可以当做变量名使用
    2.可以当做函数的参数
    3.可以当做函数的返回值
    4.可以当做容器类型（可以存放多个数据的数据类型）的数据
    

2.14 闭包函数

    定义在函数内部的函数，并且用到了外部函数名称空间的名字
    

装饰器
---

3.1 函数器简介

    概念：在不改变被装饰对象原代码和调用方式的情况下给被装饰对象添加新的功能
    本质：不是一门新技术，而是由函数参数、名称空间、函数名多种用法、闭包函数组合一起到的结果
    口诀：对修改封闭，对扩展开放
    

3.2 装饰器推导流程

    1.直接在调用原函数的前后添加代码
    2.调用的地方较多，不能反复拷贝，改用函数
    3.函数体代码写死了，通过传参来解决
    4.变更了使用方式，改成闭包
    5.调用方式不对，改成变量名赋值绑定，和原函数一致
    6.只能装饰无参函数，兼容性差，改成支持有参装饰
    7.原函数有返回值，改成支持返回值
    

3.3 装饰器模板

    def outer(func_name):
        def inner(*args, **kwargs):
            res = func_name(*args, **kwargs)
            return res
        return inner
    

3.4 语法糖

    会自动将下面挨着的函数名当做第一个参数自动传给@函数调用
    @outer()  # func = outer(func)
    def func():
        pass
    

3.5 多层语法糖

    加载顺序由下往上，每次执行之后如果上面还有语法糖，则直接返回值函数名传给上面的语法糖
    如果上面没有语法糖了 则变形 index=outter1(wrapper2)
    

3.6 有参装饰器模板

    def outer_plus(mode):
        def outer(func_name):
            def inner(*args, **kwargs):
                res = func_name(*args, **kwargs)
                return res
            return  inner
        return  outer
    

递归函数和二分法
--------

4.1 递归函数

    1.直接或者间接调用自己
    2.每次调用都必须比上一次简单，并且需要有一个明确的结束条件
    递推：一层层往下    回溯：基于明确的结果一层层往上
    

4.2 算法之二分法

    算法：解决问题的有效方法，不是所有的算法都很高效，也有不合格的算法
    二分法使用要求：待查找的数据必须有序
    缺陷：针对开头结尾的数据，查找效率很低
    l1 = [11, 22, 33, 44, 55, 66, 77, 88, 99]
    def get_middle(l1,target_num):
       if len(l1) == 0:
            print('数据找不到')
            return
       middle_index = len(l1) // 2
       if target_num > l1[middle_index]:
          right_num = l1[middle_index+1:]
          print(right_num)
          return get_middle(right_num,target_num)
       elif target_num < l1[middle_index]:
          left_num = l1[:middle_index]
          print(left_num)
          return get_middle(left_num,target_num)
       else:
          print('猜测正确')
          return
    get_middle(l1,48)
    

生成式
---

5.1 三元表达式

    数据值1 if 条件 else 数据值2
    条件成立使用数据值1 条件不成立使用数据值2
    当结果是二选一的情况下 使用三元表达式较为简便
    

5.2 各种生成式

    列表生成式
    res = [ i+'1' for i in 'hello']
    
    字典生成式
    res = {i:j for i,j in enumerate('hello')}
    
    集合生成式
    res = {i for i in 'hello'}
    

5.3 匿名函数

    语法结构： lambda 形参:返回值
    

内置函数
----

    map() 映射
    l1 = [1, 2, 3, 4, 5]
    res = map(lambda x:x+1, l1)
    
    max 最大值  min 最小值
    
    reduce  传多个值 返回一个值
    
    zip 拉链
    l1 = [11,22,33]
    l2=[1,2,3]
    res=zip(l1,l2)
    print(list(res)) # [(11, 1), (22, 2), (33, 3)]
    
    filter  过滤   sorted 排序
    
    bytes() 转换成bytes类型
    
    callable（）判断名字是否可以加括号调用
    
    chr（）order（）基于ASCII吗做数字与字母的转换
    
    A-Z 65-90  a-z 97-122
    
    divmod（） 第一个数据为整除数，第二个是余数
    
    res = divmode(100, 2)
    
    print(res) # (50,0)
    
    enumerate() 枚举
    
    eval（）exec（） 能够识别字符串中的python并执行
    
    id（）查看内存地址   input()接收用户输入  
    
    isinstance（）判断数据类型  
    
    pow（）幂指数
    
    round（）四舍五入
    
    sum（）求和
    

可迭代对象和迭代器对象
-----------

6.1 可迭代对象

    对象内置有__iter__方法的都称为可迭代对象(双下iter方法)
    
    可迭代对象：str  list  dict  tuple set 文件对象
    不可迭代对象 int float  bool  函数对象
    

6.2 迭代器对象

    迭代器对象：由可迭代对象调用__iter__方法产生
    
    迭代器对象判断的本质是看是否内置有__iter__和__next__
    

6.3 for循环的本质

    for 变量名 in 可迭代对象
        循环体代码
    
    1.先将in后面的数据调用__iter__转变成迭代器对象
    2.依次让迭代器对象调用__next__取值
    3.一旦__next__取不到值报错 for循环会自动捕获并处理
    

异常捕获
----

    异常：代码运行报错，行业俗语叫bug
    
    异常分类：语法和逻辑错误
    
    异常结构：错误位置、错误类型、错误详情