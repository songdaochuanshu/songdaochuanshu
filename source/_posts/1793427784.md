---
layout: post
title: "清源正本,鉴往知来,Go lang1.18入门精炼教程,由白丁入鸿儒,Golang中引用类型是否进行引用传递EP18"
date: "2022-09-14T22:21:37.701Z"
---
清源正本,鉴往知来,Go lang1.18入门精炼教程,由白丁入鸿儒,Golang中引用类型是否进行引用传递EP18
==========================================================

开篇明义，Go lang中从来就不存在所谓的“引用传递”，从来就只有一种变量传递方式，那就是值传递。因为引用传递的前提是存在“引用变量”，但是Go lang中从来就没有出现过所谓的“引用变量”，所以也就不可能存在引用传递这种变量传递的方式。

引用类型
----

首先，Go lang的基本数据类型是值类型，比如整数、浮点、字符串、布尔、数组及错误类型，它们本质上是原始类型，也就是不可改变的，所以对它们进行操作，一般都会返回一个新创建的值，所以把这些值传递给函数时，其实传递的是一个值的拷贝副本，这一点，基本没啥争议。

而引用类型指的是它的修改动作可以影响到任何引用到它的变量。在 Go 语言中，引用类型有切片(slice)、字典(map)、接口(interface)、函数(func) 以及通道(chan) 。

问题是，如果我们在某一个函数体内对外部定义的引用类型数据做修改操作：

    package main  
      
    import "fmt"  
      
    func changeMap(data map[string]string) {  
    	data["123"] = "333"  
    }  
      
    func main() {  
    	a := map[string]string{}  
    	a["123"] = "123"  
    	fmt.Println("begin:", a)  
    	changeMap(a)  
    	fmt.Println("after:", a)  
    }
    

程序返回：

    begin: map[123:123]  
    after: map[123:333]
    

很明显，函数changeMap改变了外部的字典类型的值，那么我们就可以得出结论，引用类型的传参是使用的引用传递？

引用变量(reference variable)和引用传递(pass-by-reference)
------------------------------------------------

事实上，引用变量(reference variable)和引用传递(pass-by-reference)确实存在，只不过存在于其他的语言中，比如说Python:

    a = [2]  
    print(id(a))  
      
    def change(a):  
        print(id(a))  
        a.append(1)  
      
      
    if __name__ == '__main__':  
      
        print(a)  
      
        change(a)  
      
        print(a)
    

这里我们定义了一个可变数据类型：列表a，然后将它传入函数change中，进行修改操作，同时使用系统内置的id()方法分别打印修改前的值和内存地址以及修改后的值和内存地址，程序返回：

    4311179392  
    [2]  
    4311179392  
    [2, 1]
    

这说明什么？说明变量a是引用变量(reference variable)，同时它作为参数的传递方式是引用传递(pass-by-reference)，证据就是它原始的内存地址和传递到函数内的内存地址是一致的，都是4311179392。

所以引用变量和引用传递应该具备如下特点：引用变量和原变量的内存地址一样。就像上面的例子里函数内引用变量a和原变量a的内存地址相同。函数使用引用传递，可以改变外部实参的值。就像上面的例子里，change函数使用了引用传递，改变了外部实参a的值。

Golang是否存在引用变量(reference variable)
----------------------------------

Go lang中不存在引用变量：

    package main  
      
    import "fmt"  
      
    func main() {  
    	a := 1  
    	var a1 *int = &a  
    	var a2 *int = &a  
    	fmt.Println("值", a1, " 内存地址:", &a1)  
    	fmt.Println("值:", a2, " 内存地址:", &a2)  
    }
    

程序返回：

    值 0x140000140b8  内存地址: 0x1400000e028  
    值: 0x140000140b8  内存地址: 0x1400000e030
    

和Python不同的是，在Go lang里，不可能有两个变量有相同的内存地址，所以也就不存在引用变量了。变量a1和a2的值相同，都指向变量a的内存地址，但是变量a1和a2自己本身的内存地址是不一样的，而Python里的引用变量和原变量的内存地址是相同的。

因此，在Go语言里是不存在引用变量的，也就自然没有引用传递了。

字典为什么可以做到值传递但是可以更改原对象？
----------------------

因为字典虽然名字叫做字典，或者叫做map，但那并不重要，其实它是指针：

    package main  
      
    import (  
    	"fmt"  
    	"unsafe"  
    )  
      
    func main() {  
    	data := make(map[string]int)  
    	var p uintptr  
    	fmt.Println("字典大小:", unsafe.Sizeof(data))  
    	fmt.Println("指针大小:", unsafe.Sizeof(p))  
    }
    

程序返回：

    字典大小: 8  
    指针大小: 8
    

从占据内存空间大小就可以看出，字典和指针其实就是一种东西，那如果字典是指针，那make返回的不应该是\*map\[string\]int吗？为什么我们使用字典传实参，从来都不加\*？

在Go lang早期，的确对于字典是使用过指针形式的，但是最后Golang的设计者发现，几乎没有人使用字典不加指针，因此就直接去掉了形式上的指针符号\*，类比的话，我们会发现现实中几乎从来就没有人管AC米兰叫AC米兰，都是直呼米兰，因为大家都认为米兰就是AC米兰，所以都自动省略了形式上的“AC”。

本质上，我们可以理解字典作为参数传递方式是值传递，只不过引用类型传递的是一个指向底层数据的指针，所以我们在操作的时候，可以修改共享的底层数据的值，进而影响到所有引用到这个共享底层数据的变量，这也就是为什么字典在函数内操作可以影响原对象的原因。

结语
--

引用类型之所以可以引用，是因为我们创建引用类型的变量，其实是一个标头值，标头值里包含一个指针，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因，换句话说，Go lang为了保证值传递的纯粹性，才引入了指针的概念，如果Go lang里存在引用变量和引用传递，那指针不就成了画蛇添足的浮笔浪墨了吗？