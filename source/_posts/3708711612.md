---
layout: post
title: "计网学习笔记三 MAC与LAN"
date: "2023-03-12T01:16:39.557Z"
---
计网学习笔记三 MAC与LAN
===============

> 在上一讲中，我们学习了链路层可以提供的服务😶：framing，link access，reliable delivery，error detection&correction。这一讲我们从link access中的broadcast接入方式深入，学习这种接入方式下的协议，以及衍生出的MAC地址，最后会学习一下主要的局域网种类。
> 
> 课件地址：[https://cs.nju.edu.cn/lwz/networks/CH2-Direct Link Networks-3.pdf](https://cs.nju.edu.cn/lwz/networks/CH2-Direct%20Link%20Networks-3.pdf)

多路访问协议（MAC协议）
-------------

在上一讲我们提到了在`link access`中有`point-to-point`和`broadcast`两种链路接入方式。

在`broadcast`中，_多路复用问题_需要使用一系列的MAC协议来解决，它负责”当多个节点处于活跃状态时，为了确保广播信道执行有用的工作，以某种方式协调活跃节点的传输“。

设计这些协议前，在`broadcast`信道的传输速率为`R bps`的前提下，我们设定了协议需要实现的一系列的_理想状态_：

*   单一活跃节点传输时，能达到`R`的传输速率
*   当`M`个节点共用信道时，每个节点传输平均速率达到`R/M`
*   完全分散（`fully decentralized`），没有所谓的主节点
    *   不需要特殊节点来协调传输
    *   尽量时钟、时隙不同步
*   尽可能简单，使实现不昂贵

我们尽量按这些理想状态设计了一些协议，这些协议可以划分为三类：

### 信道划分协议

`Channel partitioning`主要思想是把信道划分为小片，然后把这些小片分下去给各个节点单独使用。划分标准可以为时隙（`time slot`）、频段（`frequency`）、编码（`code`）有以下几种：

*   `TDMA`：_时分多址_。和前文的时分复用TDM一样，在时间帧内按照时隙来划分信道；
    
    ![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001829480-1420371596.png)
    
*   `FDMA`：频分多址。和前文的频分复用FDM一样，按照划分的频段来划分信道；
    
    ![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001830605-2108216547.png)
    
*   `CDMA`：码分多址。给用户分配不同的正交的`chipping sequece`，对用户要发送的数据进行编码，使得多个用户的数据可以进行叠加后变成“一个数据”在信道上传输，然后再由接收方分别根据`chipping sequece`来解码消除噪音拿到数据。流程如下图：
    

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001831128-382524117.png)

### 随机接入协议

`random access`协议可以让单个活跃节点传输达到`R`的速率，而且传输前不用对各个节点进行协调，但这就很容易产生`collision`。如何探测并解决这些`collision`，是我们在随机接入协议中主要考虑解决的问题。主要有以下几种协议：

#### ALOHA

ALOHA的主要解决 collision 的方法是：一旦有帧准备好了就立刻发送，发生 collision 就根据`p`的概率进行重传（`1-p`的概率等一段时间，等待的时间是随机的），进行重传后还是没有收到ACK信息就把当前帧直接丢弃。

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001831468-321367535.png)

#### Slotted ALOHA

相比于纯ALOHA，时隙ALOHA做的一个改变就是把所有帧定义为相同大小，并且根据帧的大小来划分时隙（ `T == Size/R` ）。这样子的操作使得节点在时间上的传输和等待都是同步的，都得向时隙对齐。

它的具体操作是一旦有帧准备好了就在下一个时隙中进行发送，发生 collision 就根据`p`的概率进行重传（`1-p`的概率等一段时间，等待的时间是随机的），直到重传成功为止。它的效率刚好是纯ALOHA的两倍，为`1/e`。

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001831882-977348631.png)

#### CSMA

_载波监听多路访问_。在两种ALOHA中节点进行帧发送时是完全不够别的节点的死活的，想传就传，这放到生活中是非常不礼貌不道德的行为。这会导致`collision`的数量大大地增加，CSMA协议对此进行了优化。

在CSMA中，每个节点必须“ listen before transmit”， 先听一下有没有人在讲话，也就是观测信道上有无能量波动（帧的传输），这种观测行为会一直进行直到当前信道从 busy 变为 idle 为止。在观测的过程中，如果信道是 busy 的，那么就推迟发送。

CSMA对 busy 的推迟操作因算法而不同。有三种busy推迟处理算法：

*   `Non persistent CSMA` ：如果busy就先躺平一会（躺一个 random time，这减少了 collision 的概率）再回来听，也就是它不是全天候保持观测的；但是这种算法虽然减少了碰撞概率，但是如果信道在节点躺平还没结束时变为了idle，那么信道就会存在被浪费的情况；
    
*   `1-persistent CSMA` ：为了避免`non persistent`中的信道浪费情况，我们节点不再开摆，全天候工作一直从 busy 听到 idle 为止 😤 ，信道 idle 了就把帧传输出去；但这种算法就会导致节点们太自私，如果有多个节点同时等待监听，信道变为 idle 时就一定会发生碰撞；
    
*   `p-Persistent CSMA` ：折中方案，既能像第二种那样减少idle时间，又能减少碰撞概率；信道 idle 时以`p` 的概率进行传输，以`1-p`的概率等待一个时间单位（大小为最大传播时延）p的值取等待发送的节点数N的倒数即`1/N`。
    
    ![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001832322-181602093.png)
    

但我们进行了这么多的工作，还是会因为传播延迟的问题出现碰撞的情况……😭所以我们搞出了CSMA/CD！

#### CSMA/CD

根据CSMA协议进行帧发送，按理说都万事俱备了，怎么还会发生collision呢？🤯

原来是在帧发送过程中，因为在链路上传播速率的问题，帧会产生因_端对端传播时延_产生的碰撞。CSMA没有进行碰撞的检测，即使碰撞了还是会继续传输这些帧。而在CSMA/CD中，当某节点进行碰撞检测时，一旦它检测到了碰撞就会立刻停止帧的传输。

CSMA/CD的帧发送步骤为：

> 1.  If medium idle, transmit; otherwise, step 2
> 2.  If busy, listen for idle, then transmit immediately （采用的1-persistent算法）
> 3.  If collision detected, send **jam signal** then **abort**
> 4.  After jam, wait random time then start from step 1

在这个协议的工作环境下，我们可以解释Minimum Frame Size的由来：

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001832734-615596865.png)

在当下，`size`作为协议的接口是不能变的，物理传播速率`v`也是不变的，所以变的就只有链路长度`L`和带宽`B`；

所以，早期以太网能连几百米，到了现在带宽越来越快，链路长度就只有十几米喽😄

IEEE 802.3协议用的是CSMA/CD加上1-persistence算法，同时为了解决因 1-persistent 出现的频繁collision问题，打上了一个叫“二进制指数后退”（`binary exponential backoff`）的补丁。在自顶向下中对这个算法的描述如下：

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001833100-1817770608.png)

### 轮流协议

`taking-turns`类型的协议可以让`M`个节点共用信道时，每个节点传输平均速率达到`R/M`。我们来看两种比较重要的协议：

#### Polling

_轮询协议_。协议会指定链路上的多个节点之一为主节点，主节点_能够通过观察在信道上是否缺乏信号，来决定一个节点何时完成帧的发送_，它以循环的方式`poll`每个节点，告诉节点可以传输的最大帧数量，传输了_某些帧_后继续下一个节点的`poll`。

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001833511-1818416894.png)

`polling`协议有几个缺点：

*   产生了轮询时延；
*   单一活跃节点传输因轮询而速率小于`R`；
*   主节点故障是很糟糕的，会导致整个信道的崩溃

我们使用的蓝牙就是采用了这种MAC协议。

#### Token passing

_令牌传递协议_。该协议没有主节点，一个被称为令牌（`token`）的小帧在节点之间以某种固定顺序交换传递。_令牌意味着帧发送的许可证。当一个节点需要进行帧的发送时它才能持有令牌，否则立刻释放令牌转发给下一个节点_。

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001833820-1478643010.png)

`token passing`有几个缺点：

*   要不停地传令牌，产生时延；
*   单个节点的故障同样会导致整个信道的崩溃，如节点忘记释放令牌；
*   公平性问题：虽然拿到 token 的节点想发多大就发多大，但这耗时很长，其他节点得等好久。

具体的实现有IBM的 `TOKEN ring`，`FDDI`，我们会在后面的LAN中看到`TOKEN ring`的具体情况。

### 协议性能分析结论

> 这里放的是分析后得出的结论，分析过程见ppt嗷 XD

一个协议性能的好坏可以用_帧的传输时间比_来衡量。

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001834133-733978678.png)

设传播时延为a，传输时延为1，则代表各个协议效率的 U 如下：

*   `point2point`：无论 a 大于1还是小于1，U的结果都是`1/(1+a)`.
*   `ring`：当环中存在N个节点时，有
    *   令牌环释放前提是帧头部被接收到&帧完成传输；
    *   a大于1时，U为`1/(a + a/N)`
    *   a小于1时，U为`1/(1 + a/N)`
*   `slotted ALOHA`：
    *   N 个节点全部成功发送的概率为 `A = N*p*(1-p)^(N-1)`
    *   p 等于 `1/N` 时， A 达到最大为`1/e`
    *   成功发送的用时为 `1/(1+2a)`
    *   所以 `U = 1/(1+2a) * A` --> `1/e`
*   `pure ALOHA`：
    *   N 个节点全部成功发送的概率为 `A = N*p*(1-p)^(2N-1)`
    *   p 等于 `1/2N` 时， A 达到最大为`1/2e`
    *   成功发送的用时为 `1/(1+2a)`
    *   所以 `U = 1/(1+2a) * A` --> `1/2e`
*   `CSMA/CD + p-persistence`： U 经过种种分析后最终为`1/(1 + (2e-1)*a)`

MAC
---

### MAC地址

_什么是MAC地址？_

> MAC地址的全称为 Medium Access Control (MAC) Address，它是一个与网络适配器相关联的数字地址。链路层地址有许多种称呼：LAN地址，物理地址或MAC地址，MAC地址是目前最广泛的链路层地址称呼。

_有啥特点？_

*   MAC地址具有扁平结构，而IP是层次结构，两者相当于身份证号和邮政地址的区别（后者会因搬家而变动），网卡是出生厂家，mac就是它给你配的身份证号，独一无二，永久存在（但现在的技术可以靠软件来改）。
*   MAC分配给网络适配器的方式是：IEEE把前三个字节分配给（卖给）厂家，然后后三个字节的内容由厂家决定写啥。
*   交换机没有MAC地址。
*   特殊广播地址 FF-FF-FF-FF-FF-FF，用于让信道上所有`adaptor`接收处理该帧。

### 从MAC地址出发

我们现在知道，一个主机“诞生”时只知道自己的 MAC 地址，它想要和远处的主机通信，就像寄信，是需要确切的地址的，怎么办？

*   我的IP地址是啥？
*   对面的IP地址是啥？
*   如果在同一个LAN中，对面的MAC地址是啥？
*   如果不在，那我要找的第一跳的路由器地址是啥？
*   ………………

解决了这些问题，我们才能成功达成通信。**我们需要ARP和DHCP协议。**

### ARP

_地址解析协议.Address Resolution Protocol（RFC 826）_

ARP的功能就是**将子网内的任意IP地址解析为MAC地址**。ARP仅仅在LAN下才能工作！！它不能跨越子网而去解析别的主机！！

ARP的具体工作原理是：

*   首先，每个主机或路由器的内存中都放着一个动态的ARP表，动态表示它所有的表项都不是永久的，表项具有一个寿命值（TTL），是会过期的。（在cmd中输入`arp -a`可以看到这个表）

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001834471-402724415.png)

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001834845-695803501.png)

*   好，我们要开始通信了！发送端主机首先通过拿到的对方的IP地址来查找自己的ARP表，如果存在映射，就直接获取MAC；
*   如果在ARP表中找不到表项，那么就会经历以下过程：
    *   发送端构造一个特殊的ARP packet；这里有[ARP报文格式详解](http://c.biancheng.net/view/6389.html)！
    *   发送端把一个这样的查询packet传递到适配器中，适配器在链路层中封装它，使用广播MAC地址来作为帧的目的地址，并将帧传输到子网中；
    *   子网上的其它适配器接收到该帧并向上传递给ARP模块，由模块检查目的IP是否与自己匹配；
    *   匹配的主机给查询主机返回一个响应packet；
    *   查询主机拿到目的MAC，将其封装在IP数据报后发送。

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001835169-121607506.png)

要注意的是，查询ARP报文是在广播帧中发送，而响应报文是在标准帧中；ARP"即插即用"，不用自己配置；ARP并不划分到具体的链路层或网络层，它可以看成跨这两层之间的协议。

当主机想要向外网通信时，需要用寻找的MAC是第一跳路由器的MAC。（用子网掩码来识别通信的主机在外网）

### DHCP

_动态主机配置协议.Dynamic Host Configuration Protocol（RFC 2131）_

一个主机用DHCP协议来配置自己的IP地址、子网掩码、DNS服务器的IP地址、第一跳路由器的IP地址。

DHCP执行的过程为：

*   客户端在其子网上广播一条DHCP-DISCOVER消息；
*   每台服务器都可以使用一条DHCP-Offer消息进行响应；
*   客户端选择一个服务器，广播包含服务器IP的DHCP请求消息；
*   选定的服务器提交绑定，并使用一条DHCP-ACK消息进行响应；
*   客户端在DHCP-ACK内设置其配置参数；
*   客户端通过DHCP-Release消息放弃绑定；
*   如果客户端之前没有续订(重新绑定)绑定，则绑定将到期。

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001835590-221080511.png)

### 网络层地址和链路层地址共存原因

> **IP-to-IP communication is really just a series of MAC-to-MAC communication taking place at each router hop**.

自顶向下对现象的解释：

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001836081-960371061.png)

[也可以看看这里的讨论！](https://networkengineering.stackexchange.com/questions/3329/reason-for-both-a-mac-and-an-ip-address)

LAN
---

### TOKEN Ring

_令牌环_是一个局域网的协议，可以说是轮流协议中`token passing`类协议的一个实例，它由IEEE 802.5所规定。

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001836478-1963034394.png)

每个节点有三种状态：监听状态，传输状态和通行状态。

*   `Listen State`： 节点会监听流经自身的比特流，它会将传输过来的帧抓住copy一份后再释放转发，如果这个帧发给自己的，那么节点欢欢喜喜收下copy的一份后，对原始帧进行一个ACK的修改；
*   `Transmit State`：发送方节点在发送帧后所处的状态，它会等待自己发出去的帧转回来然后进行回收；在此过程，它有一个buffer用来暂存其它节点发出来的帧（不让它们跑，只让自己发的帧跑）
*   `Bypass State`：啥也不干，只是单纯地连接；

节点发出去的帧是肯定能到达目的地的，除非中途有节点故障（因为环形的结构）。这个协议在大的负载量传输下需要多次轮询，在小负载量下效率也不会很高。

具体图示如下：

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001836815-646798365.png)

具体的标准有：

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001837216-658418464.png)

### Ethernet

_以太网_是一类计算机局域网技术。它以便宜的实现价格占领了有线局域网市场，取代了其他局域网标准如TOKEN ring、FDDI和ARCNET。

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001837639-2139574908.png)

IEEE组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。

以太网在逻辑上使用总线型拓扑（以前是bus结构，当前快速以太网使用了交换机，拓扑结构变成了star）和CSMA/CD的总线技术。

> 在当下交换机的使用下，就没必要用CSMA/CD的broadcast链路接入了，详细可以看看这个问答：
> 
> [switch - If no CSMA/CD on switches what are they using](https://networkengineering.stackexchange.com/questions/67098/if-no-csma-cd-on-switches-what-are-they-using)

以太网的特点有俩：`unreliable`、`connectionless`。

*   `unreliable`：在NIC之间发送接收帧时，不用进行握手；
    
*   `connectionless`：接收方不会返回ACK信息给发送方；
    
    > data in dropped frames recovered only if initial sender uses higher layer rdt (e.g., TCP), otherwise dropped data lost.
    > 
    > 仅当初始发送者使用更高层的RDT(例如，TCP)时，丢弃的帧中的数据才能恢复，否则丢弃的数据会丢失。
    

以太网的演化非常快。啥都变了就只有**帧的格式**没有变化，作为一个接口，以太网帧的实现是非常成功的。_（以太网规定了最小帧长应满足：帧的传输时延等于最远两个站点间信号的往返传播时延。）_我们来看看**帧的结构**：

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001838047-1287982961.png)

*   `Preamble`: 前同步码字段，8个字节；7个字节用以唤醒接收适配器并进行时钟同步，每个字节的值都是0xAA；后一个字节用以确认帧的起始位。（为了确定起始位我们使用了一个哨兵位机制，对数据进行每5个1填充1个0）
*   `Addresses`: 地址字段，两个地址字段都是6个字节，地址是MAC地址。
*   `Type`: 类型字段，2个字节，说明了上层的协议是啥（可以记录2^16种）
*   `Data payload`: 最大1500字节，最小46字节；
*   `CRC`: 循环冗余检测字段，4个字节；

以太网具体的标准有：

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001838340-216948345.png)

使用的802.3协议（CSMA/CD+1-persistent+beb）的算法逻辑图如下：

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001838750-855630395.png)

> _octet是什么？_
> 
> octet 表示的是8个bit ，当我们在谈论网络上的问题时，更喜欢使用这个词而不是Byte。

一些小的点
-----

**NOTE**：物理上看到的节点星型组网形状并不一定是broadcast的接入方式，很可能是多个point-to-point！这种逻辑上的组网拓扑的link access 因中心设备不同而不同：中心设备是switch的话其实是多个point-to-point，今天的以太局域网基本就是这样，这就不用MAC协议了；而中心是hub的话对应的就是broadcast，hub相当于一个总线。

一个IEE802图示：

![](https://img2023.cnblogs.com/blog/2565949/202303/2565949-20230312001839167-1982538357.png)

一些看到的比较好的文章：

[以太网与令牌环网](https://zhuanlan.zhihu.com/p/28563689)

[Efficiency Of Token Ring](https://www.geeksforgeeks.org/efficiency-of-token-ring/)