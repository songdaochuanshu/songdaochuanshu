---
layout: post
title: "Redis6.0.6的三大内存过期策略和八大淘汰策略"
date: "2022-09-13T04:49:31.173Z"
---
Redis6.0.6的三大内存过期策略和八大淘汰策略
==========================

一、前言
----

Redis在我们日常开发中是经常用到的，Redis也是功能非常强大，可以进行缓存，还会有一些排行榜、点赞、消息队列、购物车等等；当然还有`分布式锁Redisson`，我们使用肯定少不了集群！小编最近学习到一些内存如果满了Redis是怎么操作呢？肯定像我们`JVM`一样，有回收或者淘汰的机制！今天小编和大家一起学习一下，小编也是看了阳哥的课，觉得讲的很好，记录一下，希望可以帮助到大家！！

二、自己配置Redis内存大小
---------------

redis安装上，如果你不配置的话，默认就是按你的电脑内存的大小。  
我们打开配置文件看一下哈！`这里以6.0.6配置文件为例`

打开`redis.conf文件：856行`：

我们可以设置大小，我们可以看到是以字节为单位的哈！

    maxmemory <bytes>
    

我们可以使用命令查询内存大小：

    127.0.0.1:6379> config get maxmemory
    1) "maxmemory"
    2) "0"
    

不配置默认为0使用电脑最大内存。

当然也可以通过命令进行设置：

    127.0.0.1:6379> config set maxmemory 2
    OK
    127.0.0.1:6379> config get maxmemory
    1) "maxmemory"
    2) "2"
    127.0.0.1:6379> set k1 wang
    (error) OOM command not allowed when used memory > 'maxmemory'.
    

根据测试：我们发现redis也会像JVM一样报OOM异常

心得： **我们一般不会调整Redis的内存大小，如果调也是一般像HashMap的加载因子一样，也就是3/4即可**

三、三大过期策略
--------

三大过期策略：`定时删除、惰性删除、定期删除`

过期策略存在原因：

Redis不可能时时刻刻遍历所有被设置了生存时间的key，来检测数据是否已经到达过期时间，然后对它进行删除。

**1\. 定时删除**

定时删除又名立即删除：能保证内存中数据的最大新鲜度，因为它保证`过期键值会在过期后马上被删除`，其所占用的内存也会随之释放。但是`立即删除对cpu是最不友好`的。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或排序等计算的时候，就会给cpu造成额外的压力，让CPU心累，时时需要删除，忙死。  
这会`产生大量的性能消耗，同时也会影响数据的读取操作`。

**2\. 惰性删除**

`数据到达过期时间，不做处理。等下次访问该数据时，如果未过期，返回数据；发现已过期，删除，返回不存在`。  
惰性删除策略的缺点是，它对`内存是很不友好的`。  
如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。  
在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏 – 无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。

**3\. 定期删除**

定期删除策略是前两种策略的折中：  
`定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响`。  
周期性轮询Redis库中的时效性数据，来用随机抽取的策略，利用过期数据占比的方式控制删除频度  
特点1：CPU性能占用设置有峰值，检测频度可自定义设置  
特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理

**4\. 附例子：**

redis默认每个100ms检查，是否有过期的key，有过期key则删除。  
注意：`redis不是每隔100ms将所有的key检查一次而是随机抽取进行检查`(如果每隔100ms，全部key进行检查，redis直接进去ICU)。因此，如果只采用定期删除策略，`会导致很多key到时间没有删除`。

定期删除策略的难点是确定删除操作执行的时长和频率:如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除束略一样，出现浪费内存的情况。因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。

**5\. 总结**

**定时删除 ：对CPU不友好，用处理器性能换取存储空间（拿时间换空间）  
惰性删除：对memory不友好，用存储空间换取处理器性能（拿空间换时间）  
定期删除：周期性抽查存储空间，随机抽查，重点抽查（存在漏网之鱼）**

**6.思考**

我们会发现，三种情况都存在瑕疵，如果数据量大，一定会出现内存满了，报OOM！所以我们下面引出八大淘汰策略！！

四、八大淘汰策略
--------

我们还是打开`redis.conf`配置文件，找到`861`行：

    # volatile-lru -> Evict using approximated LRU, only keys with an expire set.
    # allkeys-lru -> Evict any key using approximated LRU.
    # volatile-lfu -> Evict using approximated LFU, only keys with an expire set.
    # allkeys-lfu -> Evict any key using approximated LFU.
    # volatile-random -> Remove a random key having an expire set.
    # allkeys-random -> Remove a random key, any key.
    # volatile-ttl -> Remove the key with the nearest expire time (minor TTL)
    # noeviction -> Don't evict anything, just return an error on write operations.
    

我们来翻译一下哈：

volatile-lru：当内存放不下新添加的数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行删除key；  
allkeys-lru：当内存放不下新添加的数据时，从所有key中使用LRU（最近最少使用）算法进行删除key。  
volatile-lfu：当内存放不下新添加的数据时，从设置了过期时间的key中，使用LFU（最近频繁使用）算法进行删除key。  
allkeys-lfu：当内存放不下新添加的数据时，从所有key中使用LFU（最近频繁使用）算法进行删除key；  
volatile-random：当内存放不下新添加的数据时，从设置了过期时间的key中，随机删除key；。  
allkeys-random：当内存放不下新添加的数据时，从所有key中随机删除key。  
volatile-ttl：当内存放不下新添加的数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被删除key；  
noeviction：当内存放不下新添加的数据时，新写入操作会报错。`默认策略`

五、手动配置淘汰策略
----------

打开`redis.conf`配置文件找到：`887`行，把注释去掉，添加自己需要的淘汰策略

    maxmemory-policy noeviction
    

当然我们也可以使用命令进行修改：

    127.0.0.1:6379> config set maxmemory-policy allkeys-Lru
    OK
    127.0.0.1:6379> config get maxmemory-policy
    1) "maxmemory-policy"
    2) "allkeys-lru"
    

六、总结
----

这样我们对Redis就有了进一步的了解，谢谢大家跟着小编一起走下来，看到这里还不动一下你的发财小手点个关注哈！！

* * *

有缘人才可以看得到的哦！！！

[点击访问！小编自己的网站，里面也是有很多好的文章哦！](https://wangzhenjun.xyz)